<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736413274805" as="style"/><link rel="stylesheet" href="styles.css?v=1736413274805"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jerf.org/iri/post/2025/programming_language_ideas/">Some programming language ideas</a> <span class="domain">(<a href="https://jerf.org">jerf.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>121 comments</span></div><br/><div><div id="42643170" class="c"><input type="checkbox" id="c-42643170" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#42641953">next</a><span>|</span><label class="collapse" for="c-42643170">[-]</label><label class="expand" for="c-42643170">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised these are called &quot;<i>programming language</i> ideas&quot;. They seem to be solvable, at least many of them, with <i>libraries</i>. For example, my Haskell effect system Bluefin can be seen as a capability system for Haskell.  My database library Opaleye is basically a relational query language for Haskell.  Maybe I&#x27;m short-sighted but I haven&#x27;t seen the need for a whole new <i>language</i> to support any of that functionality.  In fact one gets huge benefits from implementing such things in an existing language.<p>* <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin</a><p>* <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;opaleye" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;opaleye</a></div><br/></div></div><div id="42641953" class="c"><input type="checkbox" id="c-42641953" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#42643170">prev</a><span>|</span><a href="#42637954">next</a><span>|</span><label class="collapse" for="c-42641953">[-]</label><label class="expand" for="c-42641953">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing your thoughts.<p>I am also agreeing that relational approach to in-memory data is a good, efffective thought.<p>I recently compiled some of my C code with the sqlite database and I&#x27;m preparing to think how the SQL model of my standard code could be used as the actual implementation language of in memory operations.<p>Instead of writing the hundredth loop through objects I just write a SQL query instead with joining with seeing the internal data representation of the software as an information system instead of bespoke code.<p>I was hoping to make it possible to handle batches of data and add parallelism because arrays are useful when you want to parallelise.<p>I was thinking, wouldn&#x27;t it be good if you could write your SQL queries in advance of the software and then parse them and then compile them to C code (using an unrolled loop of the SQLite VM) so they&#x27;re performant. (For example, instead of a btree for a regular system operation, you can just use a materialised array a bit like a filesystem so you&#x27;re not rejoining the same data all the time)<p>I was thinking of ways of representing actors somehow communicating by tables but I do not have anything concrete for that.</div><br/></div></div><div id="42637954" class="c"><input type="checkbox" id="c-42637954" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42641953">prev</a><span>|</span><a href="#42638110">next</a><span>|</span><label class="collapse" for="c-42637954">[-]</label><label class="expand" for="c-42637954">[4 more]</label></div><br/><div class="children"><div class="content">- Looser functions (badly chosen name)<p>Timeouts on calls are, as the OP mentions, a thing in Erlang. Inter-process and inter-computer calls in QNX can optionally time out, and this includes all system calls that can block. Real-time programs use such features. Probably don&#x27;t want it on more than that. It&#x27;s like having exceptions raised in things you thought worked.<p>- Capabilities<p>They&#x27;ve been tried at the hardware level, and IBM used them in the System&#x2F;38, but they never caught on. They&#x27;re not really compatible with C&#x27;s flat memory model, which is partly they fell out of fashion.
Capabilities mean having multiple types of memory. Might come back if partially-shared multiprocessors make a comeback.<p>- Production-Level Releases<p>That&#x27;s kind of vague. Semantic versioning is a related concept. It&#x27;s more of a tooling thing than a language thing.<p>- Semi-Dynamic Language<p>I once proposed this for Python. The idea was that, at some point, the program made a call that told the system &quot;Done initializing&quot;. After that point, you couldn&#x27;t load more code, and some other things that inhibit optimization would be prohibited. At that point, the JIT compiler runs, once. No need for the horrors inside PyPy which deal with cleanup when someone patches one module from another.<p>Guido didn&#x27;t like it.<p>- Value Database<p>The OP has a good criticism of why this is a bad idea. It&#x27;s an old idea, mostly from LISP land, where early systems saved the whole LISP environment state.
Source control? What&#x27;s that?<p>- A Truly Relational Language<p>Well, in Python, almost everything is a key&#x2F;value store. The NoSQL people were going in that direction. Then people remembered that you want atomic transactions to keep the database from turning to junk, and mostly backed off from NoSQL where the data matters long-term.<p>- A Language To Encourage Modular Monoliths<p>Hm. Needs further development. Yes, we still have trouble putting parts together.
There&#x27;s been real progress. Nobody has to keep rewriting Vol. I of Knuth algorithms in each new project any more. But what&#x27;s being proposed here?<p>- Modular Linting<p>That&#x27;s mostly a hack for when the original language design was botched.
View this from the point of the maintenance programmer - what guarantees apply to this code? What&#x27;s been prevented from happening? Rust has one linter, and you can add directives <i>in the code</i> which allow exceptions. This allows future maintenance programmers to see what is being allowed.</div><br/><div id="42638377" class="c"><input type="checkbox" id="c-42638377" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#42637954">parent</a><span>|</span><a href="#42638401">next</a><span>|</span><label class="collapse" for="c-42638377">[-]</label><label class="expand" for="c-42638377">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In general, while I can’t control how people react to this list, should this end up on, say, Hacker News, I’m looking more for replies of the form “that’s interesting and it makes me think of this other interesting idea” and less “that’s stupid and could never work because X, Y, and Z so everyone stop talking about new ideas” or “why hasn’t jerf heard of this other obscure language that tried that 30 years ago”. (Because, again, of course I don’t know everything that has been tried.)</div><br/></div></div><div id="42642329" class="c"><input type="checkbox" id="c-42642329" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#42637954">parent</a><span>|</span><a href="#42638401">prev</a><span>|</span><a href="#42638110">next</a><span>|</span><label class="collapse" for="c-42642329">[-]</label><label class="expand" for="c-42642329">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Source control? What&#x27;s that?<p>I think squeak had Monticello for source control with their image based approach almost
20+ years ago and there was something else for smalltalk in the &#x27;80s too.<p>But yeah people like text and hate images, and I believe Pharo switched back to some git integration.</div><br/></div></div></div></div><div id="42638110" class="c"><input type="checkbox" id="c-42638110" checked=""/><div class="controls bullet"><span class="by">aziis98</span><span>|</span><a href="#42637954">prev</a><span>|</span><a href="#42638169">next</a><span>|</span><label class="collapse" for="c-42638110">[-]</label><label class="expand" for="c-42638110">[10 more]</label></div><br/><div class="children"><div class="content">I agree about relational languages. It&#x27;s absurd when I think that SQL and Datalog came from the same foundations of relational calculus. It&#x27;s just so much lost expressive power.<p>I really like what PRQL [1] did, at least it makes table operations easily chainable. Another one that comes to mind is Datomic [2].<p>[1]: <a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;prql-lang.org&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;docs.datomic.com&#x2F;peer-tutorial&#x2F;query-the-data.html" rel="nofollow">https:&#x2F;&#x2F;docs.datomic.com&#x2F;peer-tutorial&#x2F;query-the-data.html</a></div><br/><div id="42638384" class="c"><input type="checkbox" id="c-42638384" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#42638110">parent</a><span>|</span><a href="#42638437">next</a><span>|</span><label class="collapse" for="c-42638384">[-]</label><label class="expand" for="c-42638384">[1 more]</label></div><br/><div class="children"><div class="content">I explore the idea with <a href="https:&#x2F;&#x2F;tablam.org" rel="nofollow">https:&#x2F;&#x2F;tablam.org</a> (relational + array). I even toyed with making relational queries to make types:<p><pre><code>    data Person = User ?except .password ?select .name, .id + Customer ?select .name, .customer_id AS .id
</code></pre>
So the types are in full sync when changes on the schema happen. And all of this is type safe.</div><br/></div></div><div id="42638437" class="c"><input type="checkbox" id="c-42638437" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42638110">parent</a><span>|</span><a href="#42638384">prev</a><span>|</span><a href="#42638218">next</a><span>|</span><label class="collapse" for="c-42638437">[-]</label><label class="expand" for="c-42638437">[3 more]</label></div><br/><div class="children"><div class="content">I was struggling with doing interesting things with the semantic web circa 2007 and was thinking &quot;OWL sucks&quot; and looking at Datalog as an alternative.  At that time Datalog was an obscure topic and hard to find information about it.  10 years later it was big.<p>(Funny after years of searching I found somebody who taught me how to do really complex modelling in OWL DL but from reading the literature I&#x27;m pretty sure the average PhD or prof in the field has no idea.)</div><br/><div id="42640865" class="c"><input type="checkbox" id="c-42640865" checked=""/><div class="controls bullet"><span class="by">leoc</span><span>|</span><a href="#42638110">root</a><span>|</span><a href="#42638437">parent</a><span>|</span><a href="#42638218">next</a><span>|</span><label class="collapse" for="c-42640865">[-]</label><label class="expand" for="c-42640865">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I found somebody who taught me how to do really complex modelling in OWL DL<p>Is there any resource you could recommend for that?</div><br/><div id="42641000" class="c"><input type="checkbox" id="c-42641000" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42638110">root</a><span>|</span><a href="#42640865">parent</a><span>|</span><a href="#42638218">next</a><span>|</span><label class="collapse" for="c-42641000">[-]</label><label class="expand" for="c-42641000">[1 more]</label></div><br/><div class="children"><div class="content">I wrote up what I learned an a technical report that got sent to the editors at ISO a month or so ago and ought to appear pretty soon.  Look up my profile and send me a note.</div><br/></div></div></div></div></div></div><div id="42638218" class="c"><input type="checkbox" id="c-42638218" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#42638110">parent</a><span>|</span><a href="#42638437">prev</a><span>|</span><a href="#42638169">next</a><span>|</span><label class="collapse" for="c-42638218">[-]</label><label class="expand" for="c-42638218">[5 more]</label></div><br/><div class="children"><div class="content">Uh... given the beauty of relational algebra I don&#x27;t understand how we ended up with the ugly mess of sql.</div><br/><div id="42638443" class="c"><input type="checkbox" id="c-42638443" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42638110">root</a><span>|</span><a href="#42638218">parent</a><span>|</span><a href="#42638169">next</a><span>|</span><label class="collapse" for="c-42638443">[-]</label><label class="expand" for="c-42638443">[4 more]</label></div><br/><div class="children"><div class="content">This makes me want to throw up<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;queries-with.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;queries-with.html</a></div><br/><div id="42638694" class="c"><input type="checkbox" id="c-42638694" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#42638110">root</a><span>|</span><a href="#42638443">parent</a><span>|</span><a href="#42638169">next</a><span>|</span><label class="collapse" for="c-42638694">[-]</label><label class="expand" for="c-42638694">[3 more]</label></div><br/><div class="children"><div class="content">If you would like some exposure therapy: <a href="https:&#x2F;&#x2F;databasearchitects.blogspot.com&#x2F;2024&#x2F;12&#x2F;advent-of-code-2024-in-pure-sql.html" rel="nofollow">https:&#x2F;&#x2F;databasearchitects.blogspot.com&#x2F;2024&#x2F;12&#x2F;advent-of-co...</a> [0]<p>[0] Recent discussion <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42577736">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42577736</a></div><br/><div id="42642883" class="c"><input type="checkbox" id="c-42642883" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#42638110">root</a><span>|</span><a href="#42638694">parent</a><span>|</span><a href="#42639426">next</a><span>|</span><label class="collapse" for="c-42642883">[-]</label><label class="expand" for="c-42642883">[1 more]</label></div><br/><div class="children"><div class="content">Life finds a way, I suppose:-)</div><br/></div></div><div id="42639426" class="c"><input type="checkbox" id="c-42639426" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42638110">root</a><span>|</span><a href="#42638694">parent</a><span>|</span><a href="#42642883">prev</a><span>|</span><a href="#42638169">next</a><span>|</span><label class="collapse" for="c-42639426">[-]</label><label class="expand" for="c-42639426">[1 more]</label></div><br/><div class="children"><div class="content">Some people might think it is crazy but I like wrapping queries like that up in JooQ so I can write<p><pre><code>  recursiveQuery(table, linkClause, selectCaluse)</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="42638169" class="c"><input type="checkbox" id="c-42638169" checked=""/><div class="controls bullet"><span class="by">billytetrud</span><span>|</span><a href="#42638110">prev</a><span>|</span><a href="#42637978">next</a><span>|</span><label class="collapse" for="c-42638169">[-]</label><label class="expand" for="c-42638169">[1 more]</label></div><br/><div class="children"><div class="content">You might be interesting in looking at the Lima programming language: <a href="http:&#x2F;&#x2F;btetrud.com&#x2F;Lima&#x2F;Lima-Documentation.html" rel="nofollow">http:&#x2F;&#x2F;btetrud.com&#x2F;Lima&#x2F;Lima-Documentation.html</a> . It has ideas that cover some of these things. For example, it&#x27;s intended to operate with fully automatic optimization. This assumption allows shedding lots of complexity that arises from needing to do the same logical thing in multiple ways that differ in their physical efficiency characteristics. Like instead of having 1000 different tree classes, you have 1 and optimisers can then look at your code and decide what available tree structures make most sense in each place. Related to your async functions idea, it does provide some convenient ways of handling these things. While functions are just normal functions, it has a very easy way to make a block of async (using &quot;thread&quot;) and provides means of capturing async errors that result from that.</div><br/></div></div><div id="42637978" class="c"><input type="checkbox" id="c-42637978" checked=""/><div class="controls bullet"><span class="by">racingmars</span><span>|</span><a href="#42638169">prev</a><span>|</span><a href="#42638672">next</a><span>|</span><label class="collapse" for="c-42637978">[-]</label><label class="expand" for="c-42637978">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Value Database<p>&gt; Smalltalk and another esoteric programming environment I used for a while called Frontier had an idea of a persistent data store environment. Basically, you could set global.x = 1, shut your program down, and start it up again, and it would still be there.<p>Frontier! I played with that way back when on the Mac. Fun times.<p>But as for programming language with integrated database... MUMPS! Basically a whole language and environment (and, in the beginning, operating system) built around a built-in global database. Any variable name prefixed with ^ is global and persistent, with a sparse multi-dimensional array structure to be able to organize and access the variables (e.g. ^PEOPLE(45,&quot;firstname&quot;) could be &quot;Matthew&quot; for the first name of person ID 45). Lives on today in a commercial implementation from Intersystems, and a couple Free Software implementations (Reference Standard M, GT.M, and the GT.M fork YottaDB). The seamless global storage is really nice, but the language itself is truly awful.</div><br/><div id="42639921" class="c"><input type="checkbox" id="c-42639921" checked=""/><div class="controls bullet"><span class="by">SeenNotHeard</span><span>|</span><a href="#42637978">parent</a><span>|</span><a href="#42638125">next</a><span>|</span><label class="collapse" for="c-42639921">[-]</label><label class="expand" for="c-42639921">[1 more]</label></div><br/><div class="children"><div class="content">TADS, an OOP language + VM for interactive fiction, has this &quot;value database&quot; model.  Once loaded into memory, the compiled image can be updated with values stored in a separate save file.  The compiled image itself could store updated values as well.<p>In fact, it does this during a &quot;preinit&quot; stage that runs immediately after compilation.  Once all preinit code finishes executing, the compiled image is overwritten with the updated state.  The language includes a &quot;transient&quot; keyword to permit creating objects that should not be stored.<p>This same mechanism permits in-memory snapshots, which are used for the game&#x27;s UNDO feature.  No need to rewind or memento-ize operations, just return to a previous state.<p>It&#x27;s not a general-purpose mechanism.  After all, the language is for building games with multiple player-chosen save files, and to permit restarting the game from a known Turn 0 state.</div><br/></div></div><div id="42638125" class="c"><input type="checkbox" id="c-42638125" checked=""/><div class="controls bullet"><span class="by">jonathaneunice</span><span>|</span><a href="#42637978">parent</a><span>|</span><a href="#42639921">prev</a><span>|</span><a href="#42638191">next</a><span>|</span><label class="collapse" for="c-42638125">[-]</label><label class="expand" for="c-42638125">[5 more]</label></div><br/><div class="children"><div class="content">Image persistence was one of the cool ideas of Smalltalk. And in practice, one of the biggest drawbacks. Cruft and old values accumulated steadily, with very little way to find and eliminate them. Transient execution has some cons. But on the pro side, every run starts from a &quot;clean slate.&quot;</div><br/><div id="42638990" class="c"><input type="checkbox" id="c-42638990" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42637978">root</a><span>|</span><a href="#42638125">parent</a><span>|</span><a href="#42638584">next</a><span>|</span><label class="collapse" for="c-42638990">[-]</label><label class="expand" for="c-42638990">[2 more]</label></div><br/><div class="children"><div class="content">&gt; with very little way to find and eliminate them.<p>The best Smalltalk these days is GlamorousToolkit: <a href="https:&#x2F;&#x2F;gtoolkit.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gtoolkit.com&#x2F;</a><p>It has a sort of git in it, so you can easily &quot;rollback&quot; your image to previous states. So going back and forth in history is trivial.</div><br/><div id="42642342" class="c"><input type="checkbox" id="c-42642342" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#42637978">root</a><span>|</span><a href="#42638990">parent</a><span>|</span><a href="#42638584">next</a><span>|</span><label class="collapse" for="c-42642342">[-]</label><label class="expand" for="c-42642342">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can easily &quot;rollback&quot; your image to previous states.<p>Sounds very interesting. Does it support multi-developer merging and&#x2F;or rebasing of changes?</div><br/></div></div></div></div><div id="42638584" class="c"><input type="checkbox" id="c-42638584" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#42637978">root</a><span>|</span><a href="#42638125">parent</a><span>|</span><a href="#42638990">prev</a><span>|</span><a href="#42638191">next</a><span>|</span><label class="collapse" for="c-42638584">[-]</label><label class="expand" for="c-42638584">[2 more]</label></div><br/><div class="children"><div class="content">This may fall in the &quot;you think you do, but you don&#x27;t category&quot;, but I&#x27;ve always wanted a Smalltalk (or similar, not that picky) with a persistent virtual memory.<p>That is, the VM is mapped to a backing file, changes persisted automatically, no &quot;saving&quot;, limited by drive space (which, nowadays, is a lot). But nowadays we also have vast memory space to act as a page cache and working memory.<p>My contrived fantasy use case was having a simple array name &quot;mail&quot;, which an array containing all of my email messages (in email object, of course). Naturally as you get more mail, the array gets longer. Also, as you delete mail, then the array shifts. It&#x27;s no different, roughly, than the classic mbox format, save it&#x27;s not just text, its objects.<p>You can see if you delete a email, from a large (several GBs), there would be a lot of churn. That implies maybe it&#x27;s not a great idea to use that data structure, but that&#x27;s not the point. You CAN use that data structure if you like (just like you can use mbox if you like).<p>Were it to be indexed, that would be done with parallel data structures (trees or hashes or whatever).<p>But this is all done automagically. Just tweaks to pages in working memory backed by the disk using the virtual memory manager. Lots and lot of potential swapping. C&#x27;est la vie, no different from anything else. This what happens when you map 4TB into a 16GB work space.<p>The problem with such a system, is how fragile is potentially is. Corrupt something and it happily persists that corruption, wrecking the system. You can&#x27;t reboot to fix it.<p>Smalltalk suffers from that today. Corrupt the image (oops, did I delete the Object become: method again?), and its gone for good. This is mitigated by having backup images, and the changelist to try to bring you back to the brink but no further.<p>I&#x27;m guessing a way to do that in this system is to use a copy on write facility. Essentially, snapshot the persistent store on each boot (or whatever), and present a list of previous snapshot at start up.<p>Given the structure of a ST VM you&#x27;d like to think this is not that dreadful to work up. I&#x27;d like to think a paper napkin implementation PoC would be possible, just to see what it&#x27;s like. One of those things were the performance isn&#x27;t really that great, but the modern systems are so fast, we don&#x27;t really notice it in human terms.<p>But I do think it would be interesting.</div><br/><div id="42639202" class="c"><input type="checkbox" id="c-42639202" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42637978">root</a><span>|</span><a href="#42638584">parent</a><span>|</span><a href="#42638191">next</a><span>|</span><label class="collapse" for="c-42639202">[-]</label><label class="expand" for="c-42639202">[1 more]</label></div><br/><div class="children"><div class="content">Have you looked at Pharo? Their git integration makes it relatively easy to export and backup parts of your main image, and to pull the things back into a fresher one once you mess up.</div><br/></div></div></div></div></div></div><div id="42638191" class="c"><input type="checkbox" id="c-42638191" checked=""/><div class="controls bullet"><span class="by">kweingar</span><span>|</span><a href="#42637978">parent</a><span>|</span><a href="#42638125">prev</a><span>|</span><a href="#42638672">next</a><span>|</span><label class="collapse" for="c-42638191">[-]</label><label class="expand" for="c-42638191">[2 more]</label></div><br/><div class="children"><div class="content">The MUMPS database is wild. When I was working in MUMPS, it was so easy and fun to whip up an internal tool to share with my coworkers. You don&#x27;t have to give any special thought at all to persistence, so you&#x27;re able to stay in the flow of thinking about your business logic.<p>But as you said, the language itself is almost unbearable to use.</div><br/><div id="42638320" class="c"><input type="checkbox" id="c-42638320" checked=""/><div class="controls bullet"><span class="by">danielhlockard</span><span>|</span><a href="#42637978">root</a><span>|</span><a href="#42638191">parent</a><span>|</span><a href="#42638672">next</a><span>|</span><label class="collapse" for="c-42638320">[-]</label><label class="expand" for="c-42638320">[1 more]</label></div><br/><div class="children"><div class="content">I had a professor who is responsible for a lot of the more &quot;modern&quot; MUMPS stuff (lets be real, MUMPS is OLD!). Guy was pretty unbearable too.</div><br/></div></div></div></div></div></div><div id="42638672" class="c"><input type="checkbox" id="c-42638672" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#42637978">prev</a><span>|</span><a href="#42641097">next</a><span>|</span><label class="collapse" for="c-42638672">[-]</label><label class="expand" for="c-42638672">[2 more]</label></div><br/><div class="children"><div class="content">For semi-dynamic language, Julia definitely took the approach of being a dynamic language that can be (and is) JITed to excellent machine code. I personally have some larger projects that do a lot of staged programming and even runtime compilation of user-provided logic using Julia. Obviously the JIT is slower to complete than running a bit of Lua or whatever, but the speed after that is phenomenal and there’s no overhead when you run the same code a second time. It’s pretty great and I’d love to see more of that ability in other languages!<p>Some of the other points resonate with me. I think sensible dynamic scoping would be an easy way to do dependency injection. Together with something like linear types you could do capabilities pretty smoothly, I think. No real reason why you couldn’t experiment with some persistent storage as one of these dependencies, either. Together with a good JIT story would make for a good, modular environment.</div><br/><div id="42638717" class="c"><input type="checkbox" id="c-42638717" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#42638672">parent</a><span>|</span><a href="#42641097">next</a><span>|</span><label class="collapse" for="c-42638717">[-]</label><label class="expand" for="c-42638717">[1 more]</label></div><br/><div class="children"><div class="content">Oh and Zig is another option for allowing injections that are checked when used at a call site rather than predefined through interfaces.<p>AFAIK it doesn’t have closures (it’s too C-like) so you need to use methods for all your (implicit) interfaces, but that’s okay…<p>I think the “exemplars” could be automatically yoinked from documentation and tests and existing usage of the function in the code base. Work needs to be done on the IDE front to make this accessible to the user.</div><br/></div></div></div></div><div id="42641097" class="c"><input type="checkbox" id="c-42641097" checked=""/><div class="controls bullet"><span class="by">OkayPhysicist</span><span>|</span><a href="#42638672">prev</a><span>|</span><a href="#42637924">next</a><span>|</span><label class="collapse" for="c-42641097">[-]</label><label class="expand" for="c-42641097">[4 more]</label></div><br/><div class="children"><div class="content">An interesting problem I&#x27;ve played around with fair bit is the idea of a maximally expressable non-Turing complete language, trying to make a language that is at least somewhat comfortable to use for many tasks, while still being able to make static assertions about runtime behavior.<p>The best I&#x27;ve managed is a functional language that allows for map, filter, and reduce, but forbids recursion or any other looping or infinite expansion in usercode.<p>The pitch is that this kind of language could be useful in contexts where you&#x27;re executing arbitrary code provided by a potentially malicious third party.</div><br/><div id="42641633" class="c"><input type="checkbox" id="c-42641633" checked=""/><div class="controls bullet"><span class="by">ameliaquining</span><span>|</span><a href="#42641097">parent</a><span>|</span><a href="#42641296">next</a><span>|</span><label class="collapse" for="c-42641633">[-]</label><label class="expand" for="c-42641633">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re asking for Starlark (<a href="https:&#x2F;&#x2F;starlark-lang.org" rel="nofollow">https:&#x2F;&#x2F;starlark-lang.org</a>), a language that strongly resembles Python but isn&#x27;t Turing-complete, originally designed at Google for use in their build system. There&#x27;s also Dhall (<a href="https:&#x2F;&#x2F;dhall-lang.org" rel="nofollow">https:&#x2F;&#x2F;dhall-lang.org</a>), which targets configuration use cases; I&#x27;m less familiar with it.<p>One problem is that, while non-Turing-completeness can be helpful for maintainability, it&#x27;s not really sufficient for security. Starlark programs can still consume exponential amounts of time and memory, so if you run an adversary&#x27;s Starlark program without sandboxing it, you&#x27;re just as vulnerable to denial-of-service attacks as you&#x27;d be with a Turing-complete language. The most common solution is sandboxing, wherein you terminate the program if it exceeds time or memory limits; however, once you have that, it&#x27;s no longer necessary for the language to not be Turing-complete, so you might as well use a popular mainstream language that&#x27;s easy to sandbox, like JavaScript.<p>One other intriguing option in the space is CEL (<a href="https:&#x2F;&#x2F;cel.dev" rel="nofollow">https:&#x2F;&#x2F;cel.dev</a>), also designed at Google. This targets use cases like policy engines where programs are typically small, but need to be evaluated frequently in contexts where performance matters. CEL goes beyond non-Turing-completeness, and makes it possible to statically verify that a program&#x27;s time and space complexity are within certain bounds. This, combined with the lack of I&#x2F;O facilities, makes it safe to run an adversary&#x27;s CEL program outside a sandbox.</div><br/></div></div><div id="42641296" class="c"><input type="checkbox" id="c-42641296" checked=""/><div class="controls bullet"><span class="by">tjalfi</span><span>|</span><a href="#42641097">parent</a><span>|</span><a href="#42641633">prev</a><span>|</span><a href="#42641498">next</a><span>|</span><label class="collapse" for="c-42641296">[-]</label><label class="expand" for="c-42641296">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested in prior art, Ian Currie&#x27;s <i>NewSpeak</i> was an attempt at a non-Turing complete language for safety critical systems. Most of the search results are for a different language with the same name, but &quot;RSRE currie newspeak&quot; should find relevant links.</div><br/></div></div><div id="42641498" class="c"><input type="checkbox" id="c-42641498" checked=""/><div class="controls bullet"><span class="by">BriggyDwiggs42</span><span>|</span><a href="#42641097">parent</a><span>|</span><a href="#42641296">prev</a><span>|</span><a href="#42637924">next</a><span>|</span><label class="collapse" for="c-42641498">[-]</label><label class="expand" for="c-42641498">[1 more]</label></div><br/><div class="children"><div class="content">Could be a good idea for a multiplayer ingame scripting language.</div><br/></div></div></div></div><div id="42637924" class="c"><input type="checkbox" id="c-42637924" checked=""/><div class="controls bullet"><span class="by">continuational</span><span>|</span><a href="#42641097">prev</a><span>|</span><a href="#42637997">next</a><span>|</span><label class="collapse" for="c-42637924">[-]</label><label class="expand" for="c-42637924">[1 more]</label></div><br/><div class="children"><div class="content">Interesting points!<p>We&#x27;re working on a language with some of these ideas:<p><a href="https:&#x2F;&#x2F;www.firefly-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.firefly-lang.org&#x2F;</a><p>Object capabilities, async calls as easy as sync calls, modular monoliths, and (eventually) unified logging.<p>None of the relational language features though.<p>Feedback appreciated!</div><br/></div></div><div id="42637997" class="c"><input type="checkbox" id="c-42637997" checked=""/><div class="controls bullet"><span class="by">lihaoyi</span><span>|</span><a href="#42637924">prev</a><span>|</span><a href="#42638038">next</a><span>|</span><label class="collapse" for="c-42637997">[-]</label><label class="expand" for="c-42637997">[1 more]</label></div><br/><div class="children"><div class="content">Starlark, a variant of Python, can be thought of as semi dynamic: all mutation in each file happens once, single threaded, and then that file and all its data structures are frozen so downstream files can use it in parallel<p>A lot of &quot;staged&quot; programs can be thought of as semi dynamic as well, even things like C++ template expansion or Zig comptime: run some logic up front, freeze it, then run the rest of the application later</div><br/></div></div><div id="42638038" class="c"><input type="checkbox" id="c-42638038" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42637997">prev</a><span>|</span><a href="#42638508">next</a><span>|</span><label class="collapse" for="c-42638038">[-]</label><label class="expand" for="c-42638038">[8 more]</label></div><br/><div class="children"><div class="content">My wild idea is that I&#x27;d like to see a modern &quot;high-level assembler&quot; language that doesn&#x27;t have a callstack. Just like in the olden days, all functions statically allocate enough space for their locals. Then, combine this with some semi-convenient facility for making sure that local variables for a given function always fit into registers; yes, I admit that I&#x27;m strange when I say that I dream of a language that forces me to do manual register allocation. :P But mostly what I want to explore is if it&#x27;s possible to create a &quot;&quot;modern&quot;&quot; structured programming language that maps cleanly to assembly, and that provides <i>no</i> optimization backend at all, but has enough mechanical sympathy that it still winds up fast enough to be usable.</div><br/><div id="42638088" class="c"><input type="checkbox" id="c-42638088" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#42638038">parent</a><span>|</span><a href="#42638194">next</a><span>|</span><label class="collapse" for="c-42638088">[-]</label><label class="expand" for="c-42638088">[2 more]</label></div><br/><div class="children"><div class="content">&gt; all functions statically allocate enough space for their locals.<p>Would you still have distinct activation records per call or forfeit the ability to have reentrant functions and recursion?<p>That&#x27;s one of the main reasons to move to dynamic (as in a call stack) allocation of your activation records versus a single static allocation per function.</div><br/><div id="42638347" class="c"><input type="checkbox" id="c-42638347" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42638038">root</a><span>|</span><a href="#42638088">parent</a><span>|</span><a href="#42638194">next</a><span>|</span><label class="collapse" for="c-42638347">[-]</label><label class="expand" for="c-42638347">[1 more]</label></div><br/><div class="children"><div class="content">In this hypothetical language I&#x27;m assuming that recursion is unsupported and that if threading is supported at all, then each thread has its own copy of every function&#x27;s locals (or at least every function that can be called concurrently; structured concurrency might be leveraged to prove that some functions don&#x27;t need to be reentrant, or maybe you just chuck a mutex in each function prologue and YOLO). However, while enforcing that basic recursion is forbidden isn&#x27;t too difficult (you make the language statically-typed, all names lexically-scoped, and don&#x27;t support forward declarations), it does probably(?) mean that you also lose first-class functions and function pointers, although I haven&#x27;t thought deeply about that.</div><br/></div></div></div></div><div id="42638194" class="c"><input type="checkbox" id="c-42638194" checked=""/><div class="controls bullet"><span class="by">vaylian</span><span>|</span><a href="#42638038">parent</a><span>|</span><a href="#42638088">prev</a><span>|</span><a href="#42638690">next</a><span>|</span><label class="collapse" for="c-42638194">[-]</label><label class="expand" for="c-42638194">[2 more]</label></div><br/><div class="children"><div class="content">Why would you like to have this language? Is it about control over the execution? About better ways to personally optimize? Or just intellectual pleasure? Or is it about reliving the olden days of assembly language programming but with a modern conveniences?</div><br/><div id="42638379" class="c"><input type="checkbox" id="c-42638379" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42638038">root</a><span>|</span><a href="#42638194">parent</a><span>|</span><a href="#42638690">next</a><span>|</span><label class="collapse" for="c-42638379">[-]</label><label class="expand" for="c-42638379">[1 more]</label></div><br/><div class="children"><div class="content">I would simply find pleasure in being able to understand basically every level of the stack. For a RISC architecture, it&#x27;s not too hard to get a grasp on how it works. Likewise for a simple-enough programming language. The problem(?) is that in between these two is an opaque black box--the optimization backend, which I feel I have no hope of understanding. So instead I wonder if it&#x27;s possible to have a &quot;safe&quot; (safer than C) and &quot;high-level&quot; (more abstractive than C) language that is still useful and semi-performant, and I&#x27;m wondering how much ergonomics would need to be sacrificed to get there. It&#x27;s a thought experiment.</div><br/></div></div></div></div><div id="42638690" class="c"><input type="checkbox" id="c-42638690" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42638038">parent</a><span>|</span><a href="#42638194">prev</a><span>|</span><a href="#42638508">next</a><span>|</span><label class="collapse" for="c-42638690">[-]</label><label class="expand" for="c-42638690">[3 more]</label></div><br/><div class="children"><div class="content">Have you thought about what happens if you want to read and parse a file? Do you declare the maximum filesize you want to support and statically allocate that much memory?</div><br/><div id="42638865" class="c"><input type="checkbox" id="c-42638865" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42638038">root</a><span>|</span><a href="#42638690">parent</a><span>|</span><a href="#42638838">next</a><span>|</span><label class="collapse" for="c-42638865">[-]</label><label class="expand" for="c-42638865">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not intending to imply that the language I&#x27;m describing can&#x27;t support heap-allocated memory; Rust shows us that it&#x27;s even possible to do so without having to manually deallocate, if you&#x27;re okay with a single-ownership discipline (which is a rather simple analysis to implement, as long as you don&#x27;t also want a borrow checker along for the ride). Instead, this is about trying to make a language that makes it easy to keep locals in registers&#x2F;cache, rather than relying on the compiler backed to do register allocation and hoping that your CPU can handle all that cache you&#x27;re thrashing.</div><br/></div></div><div id="42638838" class="c"><input type="checkbox" id="c-42638838" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42638038">root</a><span>|</span><a href="#42638690">parent</a><span>|</span><a href="#42638865">prev</a><span>|</span><a href="#42638508">next</a><span>|</span><label class="collapse" for="c-42638838">[-]</label><label class="expand" for="c-42638838">[1 more]</label></div><br/><div class="children"><div class="content">No, you have a scoped pointer to dynamically allocated memory; when the scoped pointer is destroyed&#x2F;cleaned up&#x2F;released at the end of the function, it releases the allocated memory.</div><br/></div></div></div></div></div></div><div id="42638508" class="c"><input type="checkbox" id="c-42638508" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#42638038">prev</a><span>|</span><a href="#42638354">next</a><span>|</span><label class="collapse" for="c-42638508">[-]</label><label class="expand" for="c-42638508">[28 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll throw another idea here I&#x27;ve been thinking from a time now.<p>Most languages have a while construct and a do-while.<p><pre><code>  while(condition){block};
  do{block}while(condition);
</code></pre>
The while is run as<p><pre><code>    ...
  start:
    condition
    branch-if-false &gt; end
    block
    branch-always &gt; start
  end:
    ...
</code></pre>
And the do-while switches the order:<p><pre><code>    ...
  start:
    block
    condition
    branch-if-true &gt; start
    ...
</code></pre>
The issue with the while is that more often than not you need to do some preparations before the condition. So you need to move that to a function, or duplicate it before and inside the loop. Do-while doesn&#x27;t help, since with that you can&#x27;t do anything after the condition.
The alternative is a while(true) with a condition in the middle.<p><pre><code>  while(true){
    prepare;
    if(!check) break;
    process
  }
</code></pre>
But what if there was a language construct for this? Something like<p><pre><code>  do{prepare}while(condition){process}
</code></pre>
Is there a language that implements this somehow? (I&#x27;m sure there is, but I know no one)<p>The best thing is that this construct can be optimized in assembly perfectly:<p><pre><code>    ...
    jump-always &gt; start
  after:
    process
  start:
    prepare
    condition
    branch-if-true &gt; after
    ...</code></pre></div><br/><div id="42638883" class="c"><input type="checkbox" id="c-42638883" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42639180">next</a><span>|</span><label class="collapse" for="c-42638883">[-]</label><label class="expand" for="c-42638883">[4 more]</label></div><br/><div class="children"><div class="content">I suspect you&#x27;ll love Common Lisp&#x27;s LOOP: <a href="https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;loop-for-black-belts" rel="nofollow">https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;loop-for-black-belts</a><p>Example:<p><pre><code>    (loop repeat 8
               ;; init x, then decide how to &quot;prepare&quot; next  iteration
               for x = 0 then (+ (* 2 x) 1)
               collect x)

    (0 1 3 7 15 31 63 127)
</code></pre>
You can insert a condition check in the middle, of course:<p><pre><code>    (loop repeat 8
               for x = 0 then (+ (* 2 x) 1)
               ;; but stop if x gets too big
               while (&lt; x 100)
               collect x)

    (0 1 3 7 15 31 63)
</code></pre>
And much, much more. It&#x27;s the ultimate loop construct.</div><br/><div id="42641181" class="c"><input type="checkbox" id="c-42641181" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638883">parent</a><span>|</span><a href="#42639676">next</a><span>|</span><label class="collapse" for="c-42641181">[-]</label><label class="expand" for="c-42641181">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget about the `prog*` family.<p>---<p><pre><code>    (prog1 foo bar*)
</code></pre>
Evaluates foo, then bar(s), and returns the result of evaluating foo and discards the results of bar(s).<p>Useful if `foo` is the condition and you need to perform some change to it immediately after, eg:<p><pre><code>    (while (prog1 (&lt; next prev) (setq prev next)) ...)
</code></pre>
---<p><pre><code>    (prog2 foo bar baz*)
</code></pre>
Evaluates foo, then bar, then baz(s) (if present), returns the result of evaluating bar and discards the results of evaluating foo and baz(s).<p>Might be what GP wants. `foo` is the preparation, `bar` is the condition`, and `baz` can be some post-condition mutation on the compared value. Not too dissimilar to<p><pre><code>    for (pre, cond, post) {}
</code></pre>
With `prog2` you could achieve similar behavior with no built in `for`:<p><pre><code>    (while (prog2 pre cond post) ...)
</code></pre>
---<p><pre><code>    (progn foo*)
</code></pre>
Evaluate each foo in order, return the result of evaluating the last element of foo and discard all the others.<p>`progn` is similar to repeated uses of the comma operator in C, which GP has possibly overlooked as one solution.<p><pre><code>    while (prepare, condition) { process }</code></pre></div><br/></div></div><div id="42639676" class="c"><input type="checkbox" id="c-42639676" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638883">parent</a><span>|</span><a href="#42641181">prev</a><span>|</span><a href="#42639554">next</a><span>|</span><label class="collapse" for="c-42639676">[-]</label><label class="expand" for="c-42639676">[1 more]</label></div><br/><div class="children"><div class="content">actually, according to the LOOP syntax, the REPEAT clause has to follow the FOR clause...</div><br/></div></div><div id="42639554" class="c"><input type="checkbox" id="c-42639554" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638883">parent</a><span>|</span><a href="#42639676">prev</a><span>|</span><a href="#42639180">next</a><span>|</span><label class="collapse" for="c-42639554">[-]</label><label class="expand" for="c-42639554">[1 more]</label></div><br/><div class="children"><div class="content">Lambda The Ultimate Loop!</div><br/></div></div></div></div><div id="42639180" class="c"><input type="checkbox" id="c-42639180" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42638883">prev</a><span>|</span><a href="#42641862">next</a><span>|</span><label class="collapse" for="c-42639180">[-]</label><label class="expand" for="c-42639180">[1 more]</label></div><br/><div class="children"><div class="content">In some way it&#x27;s the dual of break, in that you want to jump into the middle of the loop, while break is to jump out of it.<p>Let&#x27;s rewrite the loop this way, with &#x27;break&#x27; expanded to &#x27;goto&#x27;:<p><pre><code>  while (true) {
    prepare...
    if (!cond) goto exitpoint;
    process...
  }
  exitpoint:
</code></pre>
The dual would be:<p><pre><code>  goto entrypoint;
  do {
    process...
  entrypoint:
    prepare...
  } while(cond);
</code></pre>
Both constructs need two points: where the jump begins and where it lands. The &#x27;break&#x27; is syntactic sugar that removes the need to specify the label &#x27;exitpoint&#x27;. In fact with &#x27;break&#x27; the starting point is explicit, it&#x27;s where the &#x27;break&#x27; is, and the landing point is implicit, after the closing &#x27;}&#x27;.<p>If we want to add the same kind of syntactic sugar for the jump-in case, the landing point must be explicit (no way for the compiler to guess it), so the only one we can make implicit is the starting point, that is where the &#x27;do&#x27; is.<p>So we need: a new statement, let&#x27;s call it &#x27;entry&#x27;, that is the dual of &#x27;break&#x27; and a new semantic of &#x27;do&#x27; to not start the loop at the opening &#x27;{&#x27; but at &#x27;entry&#x27;.<p><pre><code>  do {
    process...
    entry;
    prepare...
  } while (cond);
</code></pre>
Is it more readable than today&#x27;s syntax? I don&#x27;t know...</div><br/></div></div><div id="42641862" class="c"><input type="checkbox" id="c-42641862" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42639180">prev</a><span>|</span><a href="#42639427">next</a><span>|</span><label class="collapse" for="c-42641862">[-]</label><label class="expand" for="c-42641862">[1 more]</label></div><br/><div class="children"><div class="content">Ada has had something similar and very flexible since from the 80s ... like:<p><pre><code>  loop
    Get(Current_Character);
  exit when Current_Character = &#x27;*&#x27;;
    Echo(Current_Character);
  end loop;
</code></pre>
There&#x27;s not that much new under the prog lang sun :(</div><br/></div></div><div id="42639427" class="c"><input type="checkbox" id="c-42639427" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42641862">prev</a><span>|</span><a href="#42638951">next</a><span>|</span><label class="collapse" for="c-42639427">[-]</label><label class="expand" for="c-42639427">[1 more]</label></div><br/><div class="children"><div class="content">C-style for-loop is kinda sorta this. Although the &quot;prepare&quot; part has to be an expression rather than a statement, given that you have the comma operator and ?: you can do a lot there even in C. In C++, you can always stick a statement in expression context by using a lambda. So:<p><pre><code>    for ([]{
        &#x2F;*prepare*&#x2F;
    }(); &#x2F;*condition*&#x2F;;) {
        &#x2F;*body*&#x2F;
    }
</code></pre>
However, the most interesting take on loops that I&#x27;ve seen is in Sather, where they are implemented on top of what are, essentially, coroutines, with some special facilities that make it possible to exactly replicate the semantics of the usual `while`, `break` etc in this way: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;sather&#x2F;docs-1.2&#x2F;tutorial&#x2F;iterators.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;sather&#x2F;docs-1.2&#x2F;tutorial&#x2F;iterat...</a></div><br/></div></div><div id="42638951" class="c"><input type="checkbox" id="c-42638951" checked=""/><div class="controls bullet"><span class="by">tajpulo</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42639427">prev</a><span>|</span><a href="#42639112">next</a><span>|</span><label class="collapse" for="c-42638951">[-]</label><label class="expand" for="c-42638951">[1 more]</label></div><br/><div class="children"><div class="content">I think we have a similar way of thinking. I once wrote a blog post about a for loop extension (based on Golang for illustration) [0].<p><pre><code>  values := []string{&quot;hello&quot;, &quot;world&quot;}
  for v, value := range values {
    fmt.Printf(&quot;%s&quot;, value);
  }
  inter {
    fmt.Printf(&quot;,&quot;)
  }
  before {
    fmt.Printf(&quot;[&quot;)
  }
  after {
    fmt.Println(&quot;]&quot;)
  }
  empty {
    fmt.Println(&quot;(nothing found)&quot;)
  }
</code></pre>
[0] <a href="https:&#x2F;&#x2F;lukas-prokop.at&#x2F;articles&#x2F;2024-04-24-for-loop-extension" rel="nofollow">https:&#x2F;&#x2F;lukas-prokop.at&#x2F;articles&#x2F;2024-04-24-for-loop-extensi...</a></div><br/></div></div><div id="42639112" class="c"><input type="checkbox" id="c-42639112" checked=""/><div class="controls bullet"><span class="by">cdhdc</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42638951">prev</a><span>|</span><a href="#42638600">next</a><span>|</span><label class="collapse" for="c-42639112">[-]</label><label class="expand" for="c-42639112">[1 more]</label></div><br/><div class="children"><div class="content">Eiffel has the loop structure.<p>from
   &lt;initialization statements&gt;
until
   &lt;termination condition&gt;
loop
   &lt;group of statements&gt;
end</div><br/></div></div><div id="42638600" class="c"><input type="checkbox" id="c-42638600" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42639112">prev</a><span>|</span><a href="#42638822">next</a><span>|</span><label class="collapse" for="c-42638600">[-]</label><label class="expand" for="c-42638600">[6 more]</label></div><br/><div class="children"><div class="content">Interesting idea, but once you add scoping:<p><pre><code>  do {
      let value = prepare();
  } while (value.is_valid) {
      process(value);
  }
</code></pre>
Can the second block of the do-while see `value` in its lexical scope? If yes, you have this weird double brace scope thing. And if no, most non-trivial uses will be forced to fall back to `if (...) break;` anyway, and that&#x27;s already clear enough imo.</div><br/><div id="42638637" class="c"><input type="checkbox" id="c-42638637" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638600">parent</a><span>|</span><a href="#42640995">next</a><span>|</span><label class="collapse" for="c-42638637">[-]</label><label class="expand" for="c-42638637">[2 more]</label></div><br/><div class="children"><div class="content">The scope should be unique, yes. In your example value should be visible.<p>Your are right about the word double braces, but I can&#x27;t think of an alternate syntax other than just removing the braces around the while. But in that case it may seem odd to have a keyword that can only be used inside a specific block...wich is basically a macro for a if(.)break;
Maybe I&#x27;m too used to the c&#x2F;java syntax, maybe with a different way of defining blocks?</div><br/></div></div><div id="42640995" class="c"><input type="checkbox" id="c-42640995" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638600">parent</a><span>|</span><a href="#42638637">prev</a><span>|</span><a href="#42638664">next</a><span>|</span><label class="collapse" for="c-42640995">[-]</label><label class="expand" for="c-42640995">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Can the second block of the do-while see `value` in its lexical scope? If yes, you have this weird double brace scope thing</i><p>As long as it&#x27;s documented and expected, it&#x27;s not weird.<p>The scope then is the whole &quot;do-while&quot; statement, not the brace.</div><br/></div></div><div id="42638664" class="c"><input type="checkbox" id="c-42638664" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638600">parent</a><span>|</span><a href="#42640995">prev</a><span>|</span><a href="#42638698">next</a><span>|</span><label class="collapse" for="c-42638664">[-]</label><label class="expand" for="c-42638664">[1 more]</label></div><br/><div class="children"><div class="content">That seems more like a programmer expectations issue than something fundamental. Essentially, you have &quot;do (call some function that returns a chunk of state) while (predicate that evaluates the state) ...&quot;<p>Hard to express without primitives to indicate that, maybe.</div><br/></div></div><div id="42638698" class="c"><input type="checkbox" id="c-42638698" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638600">parent</a><span>|</span><a href="#42638664">prev</a><span>|</span><a href="#42638822">next</a><span>|</span><label class="collapse" for="c-42638698">[-]</label><label class="expand" for="c-42638698">[1 more]</label></div><br/><div class="children"><div class="content">Let me FTFY:<p><pre><code>  do {
      let value = prepare();
      while (value.is_valid) {
         process(value);
  }</code></pre></div><br/></div></div></div></div><div id="42638822" class="c"><input type="checkbox" id="c-42638822" checked=""/><div class="controls bullet"><span class="by">jolmg</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42638600">prev</a><span>|</span><a href="#42638721">next</a><span>|</span><label class="collapse" for="c-42638822">[-]</label><label class="expand" for="c-42638822">[2 more]</label></div><br/><div class="children"><div class="content">You mean like a shell&#x27;s while-do-done? It&#x27;s just about allowing statements as the conditions, rather than just a single expression. Here&#x27;s an example from a repl I wrote:<p><pre><code>  repl_prompt=&quot;${repl_prompt-repl$ }&quot;
  while
    printf &quot;%s&quot; &quot;$repl_prompt&quot;
    read -r line
  do
    eval &quot;$line&quot;
  done
  echo
</code></pre>
The `printf` is your `prepare`.<p>This should also be doable in languages where statements are expressions, like Ruby, Lisp, etc.<p>Here&#x27;s a similar Ruby repl:<p><pre><code>  while (
    print &quot;repl&gt; &quot;
    line = gets
  ) do
    result = eval line
    puts result.inspect
  end
  puts</code></pre></div><br/><div id="42638878" class="c"><input type="checkbox" id="c-42638878" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638822">parent</a><span>|</span><a href="#42638721">next</a><span>|</span><label class="collapse" for="c-42638878">[-]</label><label class="expand" for="c-42638878">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, here you are basically keeping it as a while with a condition but allowing it to be any code that at the end returns a boolean, although you need to make sure that variables defined in that block can be used in the do part.<p>Sidenote: I wasn&#x27;t aware that shell allows for multiple lines, good to know!</div><br/></div></div></div></div><div id="42638721" class="c"><input type="checkbox" id="c-42638721" checked=""/><div class="controls bullet"><span class="by">digging</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42638822">prev</a><span>|</span><a href="#42639730">next</a><span>|</span><label class="collapse" for="c-42638721">[-]</label><label class="expand" for="c-42638721">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t write a lot of while loops so this is just a bit unfamiliar to me, but I&#x27;m not really understanding how this isn&#x27;t the same as `do{block}while(condition);`? Could you give a simple example of what kind of work `prepare` is doing?</div><br/><div id="42638847" class="c"><input type="checkbox" id="c-42638847" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42638721">parent</a><span>|</span><a href="#42639730">next</a><span>|</span><label class="collapse" for="c-42638847">[-]</label><label class="expand" for="c-42638847">[1 more]</label></div><br/><div class="children"><div class="content">Think of a producer (a method that returns data each time you request one, like reading a file line by line or extracting the top of a queue for example) that you need to parse and process until you find a special element that means &quot;stop&quot;.<p>Something like<p><pre><code>  do{
    raw_data=produce.get()
    data=parse(raw_data)
  }while(data!=STOP){
    process(data)
  }
</code></pre>
I&#x27;m aware this example can be trivially replaced with a while(data=parse(producer.get())){process(data)} but you are forced to have a method, and if you need both the raw and parsed data at the same time, either you mix them into a wrapper or you need to somehow transfer two variables at the same time from the parse&gt;condition&gt;process<p>A do-while here also has the same issue, but in this case after you check the condition you can&#x27;t do any processing afterwards (unless you move the check and process into a single check_and_process method...which you can totally do but again the idea is to not require it)</div><br/></div></div></div></div><div id="42639730" class="c"><input type="checkbox" id="c-42639730" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42638721">prev</a><span>|</span><a href="#42638844">next</a><span>|</span><label class="collapse" for="c-42639730">[-]</label><label class="expand" for="c-42639730">[3 more]</label></div><br/><div class="children"><div class="content">The C language construct for that is &#x27;goto&#x27;.</div><br/><div id="42641033" class="c"><input type="checkbox" id="c-42641033" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42639730">parent</a><span>|</span><a href="#42638844">next</a><span>|</span><label class="collapse" for="c-42641033">[-]</label><label class="expand" for="c-42641033">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, but the parent wants a non brain-damaged too-general construct</div><br/><div id="42642045" class="c"><input type="checkbox" id="c-42642045" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42641033">parent</a><span>|</span><a href="#42638844">next</a><span>|</span><label class="collapse" for="c-42642045">[-]</label><label class="expand" for="c-42642045">[1 more]</label></div><br/><div class="children"><div class="content">What if loops are a design mistake?<p>Look at C: it has 5 loop-related keywords (4.5; &#x27;break&#x27; is two-timing in &#x27;switch&#x27;)  yet it is still not enough.</div><br/></div></div></div></div></div></div><div id="42638844" class="c"><input type="checkbox" id="c-42638844" checked=""/><div class="controls bullet"><span class="by">url00</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42639730">prev</a><span>|</span><a href="#42639251">next</a><span>|</span><label class="collapse" for="c-42638844">[-]</label><label class="expand" for="c-42638844">[1 more]</label></div><br/><div class="children"><div class="content">Not quite the same but almost feels like the BEGIN block in awk.</div><br/></div></div><div id="42639251" class="c"><input type="checkbox" id="c-42639251" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42638844">prev</a><span>|</span><a href="#42639268">next</a><span>|</span><label class="collapse" for="c-42639251">[-]</label><label class="expand" for="c-42639251">[2 more]</label></div><br/><div class="children"><div class="content">When we are on subject of loops... I&#x27;d love to have &#x27;else&#x27; block for loops that runs when the loop had zero iterations.</div><br/><div id="42642109" class="c"><input type="checkbox" id="c-42642109" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42638508">root</a><span>|</span><a href="#42639251">parent</a><span>|</span><a href="#42639268">next</a><span>|</span><label class="collapse" for="c-42642109">[-]</label><label class="expand" for="c-42642109">[1 more]</label></div><br/><div class="children"><div class="content">Not the same thing (although I thought it was), according to the Python docs, but related:<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;reference&#x2F;compound_stmts.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;reference&#x2F;compound_stmts.html</a><p>See sections 8.3, the for statement, and 8.2, the while statement.</div><br/></div></div></div></div><div id="42639268" class="c"><input type="checkbox" id="c-42639268" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42639251">prev</a><span>|</span><a href="#42638527">next</a><span>|</span><label class="collapse" for="c-42639268">[-]</label><label class="expand" for="c-42639268">[1 more]</label></div><br/><div class="children"><div class="content">In Scala you can do:<p><pre><code>    while { prepare; condition } 
    do { process }
</code></pre>
This runs all 3 in order every iteration but quits if condition evaluates to false. It just uses the fact that value of a block is the value of the last expression in the block.<p>Scala has a lot of syntax goodies although some stuff is exotic. For example to have a &#x27;break&#x27; you need to import it and indicate where from exactly you want to break out of.</div><br/></div></div><div id="42638527" class="c"><input type="checkbox" id="c-42638527" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#42638508">parent</a><span>|</span><a href="#42639268">prev</a><span>|</span><a href="#42638354">next</a><span>|</span><label class="collapse" for="c-42638527">[-]</label><label class="expand" for="c-42638527">[1 more]</label></div><br/><div class="children"><div class="content">At what point are you just doing async and coroutines?</div><br/></div></div></div></div><div id="42638354" class="c"><input type="checkbox" id="c-42638354" checked=""/><div class="controls bullet"><span class="by">stuhood</span><span>|</span><a href="#42638508">prev</a><span>|</span><a href="#42638676">next</a><span>|</span><label class="collapse" for="c-42638354">[-]</label><label class="expand" for="c-42638354">[3 more]</label></div><br/><div class="children"><div class="content">We have built something that hits on points 1, 3, 5, and 7 at <a href="https:&#x2F;&#x2F;reboot.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;reboot.dev&#x2F;</a> ... but in a multi-language framework (supporting Python and TypeScript to start).<p>The end result is something that looks a lot like distributed, persistent, transactional memory. Rather than explicit interactions with a database, local variable writes to your state are transactionally persisted if a method call succeeds, even across process&#x2F;machine boundaries. And that benefits point 7, because transactional method calls compose across team&#x2F;application boundaries.<p>[1] Loosen Up The Functions
[3] Production-Level Releases
[5] Value Database
[7] A Language To Encourage Modular Monoliths</div><br/><div id="42639154" class="c"><input type="checkbox" id="c-42639154" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#42638354">parent</a><span>|</span><a href="#42638676">next</a><span>|</span><label class="collapse" for="c-42639154">[-]</label><label class="expand" for="c-42639154">[2 more]</label></div><br/><div class="children"><div class="content">This seems to be similar to Azure Durable Functions:<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;azure-functions&#x2F;durable&#x2F;durable-functions-overview" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;azure-functions&#x2F;dura...</a></div><br/><div id="42639262" class="c"><input type="checkbox" id="c-42639262" checked=""/><div class="controls bullet"><span class="by">stuhood</span><span>|</span><a href="#42638354">root</a><span>|</span><a href="#42639154">parent</a><span>|</span><a href="#42638676">next</a><span>|</span><label class="collapse" for="c-42639262">[-]</label><label class="expand" for="c-42639262">[1 more]</label></div><br/><div class="children"><div class="content">They are related, for sure. But one of the biggest differences is that operations affecting multiple Reboot states are transactional, unlike Azure&#x27;s &quot;entity functions&quot;.<p>Because multiple Azure entity functions are not updated transactionally, you are essentially always implementing the saga pattern: you have to worry about cleaning up after yourself in case of failure.<p>In Reboot, transactional function calls automatically roll back all state changes if they fail, without any extra boilerplate code. Our hypothesis is that that enables a large portion of an application to skip worrying about failure entirely.<p>Code that has side-effects impacting the outside world can be isolated using our workflow mechanism (effectively durable execution), which can themselves be encapsulated inside of libraries and composed. But we don&#x27;t think that that is the default mode that developers should be operating in.</div><br/></div></div></div></div></div></div><div id="42638676" class="c"><input type="checkbox" id="c-42638676" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42638354">prev</a><span>|</span><a href="#42638118">next</a><span>|</span><label class="collapse" for="c-42638676">[-]</label><label class="expand" for="c-42638676">[1 more]</label></div><br/><div class="children"><div class="content">Well OP, are you me? everything you listed is also in my 
short wishlist for a programming language (well except for the value database, once to you have first class relational tables in your language, persistence can be tied to the table identity, doesn&#x27;t need to be implicit).<p>Capabilities and dynamic scoping for &quot;modularisation&quot; nicely lead to implicit variables instead of truly  global dynamically scoped variables.  Implicit variables also probably work well to implement effect systems which means well behaved asyncs.<p>Edit: other features I want:<p>- easy embedding in other low level languages (c++ specifically)<p>- conversely, easy to embed functions written in another language (again c++).<p>- powerful, shell-like, process control system (including process trees and pipelines), including across machines.<p>- built-in cooperative shared memory concurrency, and preemptive shared nothing.<p>- built-in distributed content addressed store<p>I guess I want Erlang :)</div><br/></div></div><div id="42638118" class="c"><input type="checkbox" id="c-42638118" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42638676">prev</a><span>|</span><a href="#42638310">next</a><span>|</span><label class="collapse" for="c-42638118">[-]</label><label class="expand" for="c-42638118">[1 more]</label></div><br/><div class="children"><div class="content">I like a lot of these ideas.<p>&quot;Semi-dynamic&quot; is one of the most common architectures there is for large &amp; complex systems.  AAA games are usually written in a combination of C++ and a scripting language.  GNU Emacs is a Lisp application with a custom interpreter that is optimized for writing a text editor.  Python + C is a popular choice as well as Java + Groovy or Clojure,  I&#x27;ve even worked with a Lua + FORTRAN system.<p>I also think &quot;parsers suck&quot;.  It should be a few hundred lines at most,  including the POM file,  to add an &quot;unless&quot; statement to the Java compiler.  You need to (1) generate a grammar which references the base grammar and adds a single production,  (2) create a class in the AST that represents the &quot;unless&quot; statement and (3) add an transformation that rewrites<p><pre><code>   unless(X) {...} -&gt; if(!X) {...}
</code></pre>
You should be able to mash up a SQL grammar and the Java grammar so you can write<p><pre><code>   var statement = &lt;&lt;&lt;SELECT * FROM page where id=:pageId&gt;&gt;&gt;;
</code></pre>
this system should be able to export a grammar to your IDE.  Most parser generators are terribly unergonomic (cue the event-driven interface of yacc) and not accessible to people who don&#x27;t have a CS education (if you need a bunch of classes to represent your AST shouldn&#x27;t these get generated from your grammar?)  When you generate a parser you should get an unparser.  Concrete syntax trees are an obscure data structure but were used in obscure RAD tools in the 1990s that would let you modify code visually and make the kind of patch that a professional programmer would write.<p>The counter to this you hear is that compile time is paramount and there&#x27;s a great case for that in large code bases.  (I had a system with a 40 minute build)  Yet there&#x27;s also a case that people do a lot of scripty programming and trading compile time for a ergonomics can be a win (see Perl and REBOL)<p>I think one goal in programming languages is to bury Lisp the way Marc Anthony buried Caesar.  Metaprogramming would be a lot more mainstream if it was combined with Chomksy-based grammars,  supported static typing,  worked with your IDE and all that.  Graham&#x27;s <i>On Lisp</i> is a brilliant book (read it!) that left me disappointed in the end because he avoids anything involving deep tree transformations or compiler theory:  people do much more advanced transformations to Java bytecodes.  It might be easier to write those kind of transformations if you had an AST comprised of Java objects instead of the anarchy of nameless tuples.+</div><br/></div></div><div id="42638310" class="c"><input type="checkbox" id="c-42638310" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42638118">prev</a><span>|</span><a href="#42638848">next</a><span>|</span><label class="collapse" for="c-42638310">[-]</label><label class="expand" for="c-42638310">[1 more]</label></div><br/><div class="children"><div class="content">Interesting that E is cited under “capabilities”, but not under “loosen up the functions”. E’s eventual-send RPC model is interesting in a number of ways. If the receiver is local then it works a bit like a JavaScript callback in that there’s an event loop driving execution; if it’s remote then E has a clever “promise pipelining” mechanism that can hide latency. However E didn’t do anything memorable (to me at least!) about handling failure, which was the main point of that heading.<p>For “capabilities” and “A Language To Encourage Modular Monoliths”, I like the idea of a capability-secure module system. Something like ML’s signatures and functors, but modules can’t import, they only get access to the arguments passed into a functor. Everything is dependency injection. The build system determines which modules are compiled with which dependencies (which functors are passed which arguments).<p>An existing “semi-dynamic language” is CLOS, the Common Lisp object system. Its metaobject protocol is designed so that there are clear points when defining or altering parts of the object system (classes, methods, etc.) at which the result is compiled, so you know when you pay for being dynamic. It’s an interesting pre-Self design that doesn’t rely on JITs.<p>WRT “value database”, a friend of mine used to work for a company that had a Lisp-ish image-based geospatial language. They were trying to modernise its foundations by porting to the JVM. He had horror stories about their language’s golden image having primitives whose implementation didn’t correspond to the source, because of decades of mutate-in-place development.<p>The most common example of the “value database” or image-based style of development is in fact your bog standard SQL database: DDL and stored procedures are very much mutate-in-place development. We avoid the downsides by carefully managing migrations, and most people prefer not to put lots of cleverness into the database. The impedance mismatch between database development by mutate-in-place and non-database development by rebuild and restart is a horribly longstanding problem.<p>As for “a truly relational language”, at least part of what they want is R style data frames.</div><br/></div></div><div id="42638848" class="c"><input type="checkbox" id="c-42638848" checked=""/><div class="controls bullet"><span class="by">losvedir</span><span>|</span><a href="#42638310">prev</a><span>|</span><a href="#42638385">next</a><span>|</span><label class="collapse" for="c-42638848">[-]</label><label class="expand" for="c-42638848">[2 more]</label></div><br/><div class="children"><div class="content">I love these ideas! I&#x27;ve been thinking about the &quot;fully relational&quot; language ever since I worked with some product folks and marketers at my start up 15 years ago who &quot;couldn&#x27;t code&quot; but were wizards at cooking up SQL queries to answer questions about what was going on with our users and product. There was a language written in rust, Tablam[0] that I followed for a while, which seemed to espouse those ideas, but it seems like it&#x27;s not being owrked on anymore. And Jamie from Scattered Thoughts[1] has posted some interesting articles in that direction as well. He used to work on the old YC-company&#x2F;product LightTable or Eve or something, which was in the same space.<p>I&#x27;ve also always thought Joe Armstrong&#x27;s (RIP) thought of &quot;why do we need modules&quot; is really interesting, too. There&#x27;s a language I&#x27;ve seen posted on HN here a couple times that seems to go in that approach, with functions named by their normalized hash contents, and referred to anywhere by that, but I can&#x27;t seem to remember what it&#x27;s called right now. Something like &quot;Universe&quot; I think?<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Tablam&#x2F;TablaM">https:&#x2F;&#x2F;github.com&#x2F;Tablam&#x2F;TablaM</a>
[1] <a href="https:&#x2F;&#x2F;www.scattered-thoughts.net" rel="nofollow">https:&#x2F;&#x2F;www.scattered-thoughts.net</a>
[2] <a href="https:&#x2F;&#x2F;erlang.org&#x2F;pipermail&#x2F;erlang-questions&#x2F;2011-May&#x2F;058768.html" rel="nofollow">https:&#x2F;&#x2F;erlang.org&#x2F;pipermail&#x2F;erlang-questions&#x2F;2011-May&#x2F;05876...</a></div><br/><div id="42638887" class="c"><input type="checkbox" id="c-42638887" checked=""/><div class="controls bullet"><span class="by">stux</span><span>|</span><a href="#42638848">parent</a><span>|</span><a href="#42638385">next</a><span>|</span><label class="collapse" for="c-42638887">[-]</label><label class="expand" for="c-42638887">[1 more]</label></div><br/><div class="children"><div class="content">&gt; with functions named by their normalized hash contents, and referred to anywhere by that, but I can&#x27;t seem to remember what it&#x27;s called right now. Something like &quot;Universe&quot; I think?<p>Unison: <a href="https:&#x2F;&#x2F;www.unison-lang.org&#x2F;docs&#x2F;the-big-idea&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.unison-lang.org&#x2F;docs&#x2F;the-big-idea&#x2F;</a></div><br/></div></div></div></div><div id="42638385" class="c"><input type="checkbox" id="c-42638385" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#42638848">prev</a><span>|</span><a href="#42640971">next</a><span>|</span><label class="collapse" for="c-42638385">[-]</label><label class="expand" for="c-42638385">[1 more]</label></div><br/><div class="children"><div class="content">The section about language support for modular monoliths reminds me of John Lakos&#x27;s <i>&quot;Large-Scale C++ Software Design&quot;</i>, which focuses on the physical design&#x2F;layout of large C++ projects to enforce interfaces and reduce coupling and compilation time. Example recommendations include defining architecture layers using subdirectories and the PImpl idiom. It&#x27;s pretty dated (1996, so pre-C++98), but still a unique perspective on an overlooked topic.<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;dp&#x2F;0201633620" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;dp&#x2F;0201633620</a></div><br/></div></div><div id="42640971" class="c"><input type="checkbox" id="c-42640971" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#42638385">prev</a><span>|</span><a href="#42637877">next</a><span>|</span><label class="collapse" for="c-42640971">[-]</label><label class="expand" for="c-42640971">[2 more]</label></div><br/><div class="children"><div class="content">Thanks - this was one of the more interesting things I&#x27;ve read here in a while.<p>I wonder if &quot;Programming languages seem to have somewhat stagnated to me.&quot;, a sentiment I share, is just me paying less attention to them or a real thing.</div><br/><div id="42642412" class="c"><input type="checkbox" id="c-42642412" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#42640971">parent</a><span>|</span><a href="#42637877">next</a><span>|</span><label class="collapse" for="c-42642412">[-]</label><label class="expand" for="c-42642412">[1 more]</label></div><br/><div class="children"><div class="content">I think there is innovation, but there&#x27;s more than innovation required to be a good language. If a innovative feature is the cornerstone of a language, it frequently means that the language neglects pragmatic coding features that while not particularly special contribute to the language being nice to use.<p>I feel like in the next few years in languages will be things like Rust descendants where people with experience in using Rust want to keep what works for them but scales back some of the rigidity in favour of pragmatism.<p>It&#x27;s also with noting that there are existing languages that are also changing over time.  Freepascal has developed a lot of features over the years that make it fairly distant from original Pascal.   More recent languages like Haxe are still developing into their final form. TypeScript has gone from a language that provided a tangible solution to an existing problem to a quagmire of features that I&#x27;d rather not have.</div><br/></div></div></div></div><div id="42637877" class="c"><input type="checkbox" id="c-42637877" checked=""/><div class="controls bullet"><span class="by">jinwoo68</span><span>|</span><a href="#42640971">prev</a><span>|</span><a href="#42637902">next</a><span>|</span><label class="collapse" for="c-42637877">[-]</label><label class="expand" for="c-42637877">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not very convincing to me when the article talks about truly relational language but fails to mention Prolog and anything that we learned from it.</div><br/><div id="42638298" class="c"><input type="checkbox" id="c-42638298" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42637877">parent</a><span>|</span><a href="#42637902">next</a><span>|</span><label class="collapse" for="c-42638298">[-]</label><label class="expand" for="c-42638298">[2 more]</label></div><br/><div class="children"><div class="content">Logic languages are definitely not what I&#x27;d expect a relational-first language to look like.<p>What we learned from Prolog is mostly that starting from an exponentially-complex primitive and then trying to beat it into submission doesn&#x27;t work at scale. Relational DBs don&#x27;t have that problem. They do go n-squared and n-cubed and so forth easily, but there are lots of solutions to that as well.</div><br/><div id="42638549" class="c"><input type="checkbox" id="c-42638549" checked=""/><div class="controls bullet"><span class="by">jinwoo68</span><span>|</span><a href="#42637877">root</a><span>|</span><a href="#42638298">parent</a><span>|</span><a href="#42637902">next</a><span>|</span><label class="collapse" for="c-42638549">[-]</label><label class="expand" for="c-42638549">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you mean with &quot;an exponentially-complex primitive&quot;. In my opinion, Prolog lets you start with simple relations (n-squared, using your terms) and then enables you to build more complex relations using them.</div><br/></div></div></div></div></div></div><div id="42637902" class="c"><input type="checkbox" id="c-42637902" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#42637877">prev</a><span>|</span><a href="#42639504">next</a><span>|</span><label class="collapse" for="c-42637902">[-]</label><label class="expand" for="c-42637902">[6 more]</label></div><br/><div class="children"><div class="content">for &quot;Semi-Dynamic Language&quot; it might be worth looking into rpython: interpreters written in rpython have two phases, in the first phase one has full python semantics, but in the second phase everything is assumed to be less dynamic, more restricted (the <i>r</i> of rpython?) so the residual interpreter is then transpiled to C sources, which, although compiled, can also make use of the built-in GC and JIT.</div><br/><div id="42637976" class="c"><input type="checkbox" id="c-42637976" checked=""/><div class="controls bullet"><span class="by">MillironX</span><span>|</span><a href="#42637902">parent</a><span>|</span><a href="#42639027">next</a><span>|</span><label class="collapse" for="c-42637976">[-]</label><label class="expand" for="c-42637976">[2 more]</label></div><br/><div class="children"><div class="content">I immediately thought of Julia as a semi-dynamic language. Julia is a dynamic language, but (as I understand it) the first time a function is called with a specific type signature, that specific method is JIT compiled as static LLVM.</div><br/><div id="42638075" class="c"><input type="checkbox" id="c-42638075" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#42637902">root</a><span>|</span><a href="#42637976">parent</a><span>|</span><a href="#42639027">next</a><span>|</span><label class="collapse" for="c-42638075">[-]</label><label class="expand" for="c-42638075">[1 more]</label></div><br/><div class="children"><div class="content">Which is then used for future dispatches on that same signature and gives it very good performance. Julia is dynamic, and definitely beats the 10x slower than C barrier jerf mentioned.<p>For what I was using it for at the time (~3 years ago when I used it seriously) it offered performance close to the compiled orbital analysis code we had (in more conventional languages, Fortran and C) but with the flexibility for developing models of Python and other dynamic&#x2F;interactive languages. An excellent tradeoff: very small performance cost for better interactivity and flexibility.</div><br/></div></div></div></div><div id="42639027" class="c"><input type="checkbox" id="c-42639027" checked=""/><div class="controls bullet"><span class="by">rirze</span><span>|</span><a href="#42637902">parent</a><span>|</span><a href="#42637976">prev</a><span>|</span><a href="#42641595">next</a><span>|</span><label class="collapse" for="c-42639027">[-]</label><label class="expand" for="c-42639027">[2 more]</label></div><br/><div class="children"><div class="content">Sans the python compatiblity, rhai is pretty close to what rpython is trying to be.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rhaiscript&#x2F;rhai">https:&#x2F;&#x2F;github.com&#x2F;rhaiscript&#x2F;rhai</a></div><br/><div id="42641686" class="c"><input type="checkbox" id="c-42641686" checked=""/><div class="controls bullet"><span class="by">gsf_emergency</span><span>|</span><a href="#42637902">root</a><span>|</span><a href="#42639027">parent</a><span>|</span><a href="#42641595">next</a><span>|</span><label class="collapse" for="c-42641686">[-]</label><label class="expand" for="c-42641686">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<a href="https:&#x2F;&#x2F;github.com&#x2F;rhaiscript&#x2F;rhai#for-those-who-actually-want-their-own-language">https:&#x2F;&#x2F;github.com&#x2F;rhaiscript&#x2F;rhai#for-those-who-actually-wa...</a><p>(｢ ⊙Д⊙)｢</div><br/></div></div></div></div><div id="42641595" class="c"><input type="checkbox" id="c-42641595" checked=""/><div class="controls bullet"><span class="by">gsf_emergency</span><span>|</span><a href="#42637902">parent</a><span>|</span><a href="#42639027">prev</a><span>|</span><a href="#42639504">next</a><span>|</span><label class="collapse" for="c-42641595">[-]</label><label class="expand" for="c-42641595">[1 more]</label></div><br/><div class="children"><div class="content">Of all the non-esolangs (=exolangs?) APL+kith seem to be almost designorismic&#x2F;estuarine (formerly, Riverian) beasts..<p>In your informed opinion, how would it make sense to be thrilled thinking about (not just a semi-dynamic APL (=S-DAPL?) as above but) designing<p><pre><code>  a APL-kith for widespread adoption by BOTH (demoscenic)gamecoders &amp; Analysts (the academic variety)???
</code></pre>
Specifically, which of the sneering checklist items[0] would be killer to cross off?<p>[0] <a href="https:&#x2F;&#x2F;www.mcmillen.dev&#x2F;language_checklist.html" rel="nofollow">https:&#x2F;&#x2F;www.mcmillen.dev&#x2F;language_checklist.html</a><p>(Note in particular that the very APL inspired Wolfram has  monopoly with physicists BUT does nothing for engineers<p><a href="https:&#x2F;&#x2F;www.stephenwolfram.com&#x2F;media&#x2F;physics-whiz-goes-into-biz&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.stephenwolfram.com&#x2F;media&#x2F;physics-whiz-goes-into-...</a><p>1988<p>&gt;<i>“But we tricked him, so to speak,” says Nobelist Murray Gell-Mann, who helped to bring Wolfram west. “We gave him a Ph.D.”</i>
)</div><br/></div></div></div></div><div id="42639504" class="c"><input type="checkbox" id="c-42639504" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42637902">prev</a><span>|</span><a href="#42639056">next</a><span>|</span><label class="collapse" for="c-42639504">[-]</label><label class="expand" for="c-42639504">[2 more]</label></div><br/><div class="children"><div class="content">As far as &quot;semi-dynamic&quot; goes, C# has an interesting take coming from the other direction - i.e. a fully statically typed language originally bolting dynamic duck typing later on.<p>It&#x27;s done in a way that allows for a lot of subtlety, too. Basically you can use &quot;dynamic&quot; in lieu of most type annotations, and what this does is make any dispatch (in a broad sense - this includes stuff like e.g. overload resolution, not just member dispatch) <i>on that particular value</i> dynamic, but without affecting other values involved in the expression.</div><br/><div id="42639544" class="c"><input type="checkbox" id="c-42639544" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42639504">parent</a><span>|</span><a href="#42639056">next</a><span>|</span><label class="collapse" for="c-42639544">[-]</label><label class="expand" for="c-42639544">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in a broad sense - this includes stuff like e.g. overload resolution, not just member dispatch<p>It specifically allows for multiple dispatch that is not even available in most dynamic languages not called lisp!</div><br/></div></div></div></div><div id="42639056" class="c"><input type="checkbox" id="c-42639056" checked=""/><div class="controls bullet"><span class="by">cmontella</span><span>|</span><a href="#42639504">prev</a><span>|</span><a href="#42638176">next</a><span>|</span><label class="collapse" for="c-42639056">[-]</label><label class="expand" for="c-42639056">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A Truly Relational Language... Value Database<p>I helped on a language called Eve about 10 years ago. A truly relational language was exactly what that language was supposed to be, or at least that&#x27;s what we were aiming at as a solution for a user-centric programming language.<p><a href="https:&#x2F;&#x2F;witheve.com" rel="nofollow">https:&#x2F;&#x2F;witheve.com</a><p>The language we came up with was sort of like Smalltalk + Prolog + SQL. Your program was a series of horn clauses that was backed by a Entity-Attribute-Value relational database. So you could write queries like &quot;Search for all the clicks and get those whose target is a specific id, then as a result create a new fact that indicates a a button was pressed. Upon the creation of that fact, change the screen to a new page&quot;. We even played around with writing programs like this in natural language before LLMs were a thing (you can see some of that here <a href="https:&#x2F;&#x2F;incidentalcomplexity.com&#x2F;2016&#x2F;06&#x2F;10&#x2F;jan-feb&#x2F;" rel="nofollow">https:&#x2F;&#x2F;incidentalcomplexity.com&#x2F;2016&#x2F;06&#x2F;10&#x2F;jan-feb&#x2F;</a>)<p>Here&#x27;s a flappy bird game written in that style: <a href="https:&#x2F;&#x2F;play.witheve.com&#x2F;#&#x2F;examples&#x2F;flappy.eve" rel="nofollow">https:&#x2F;&#x2F;play.witheve.com&#x2F;#&#x2F;examples&#x2F;flappy.eve</a><p>It&#x27;s very declarative, and you have to wrap you brain around the reactivity and working with collections of entities rather than individual objects, so programming this way can be very disorienting for people used to imperative OOP langauges.<p>But the results are that programs are much shorter, and you get the opportunity for really neat tooling like time travel debugging, where you roll the database back to a previous point; &quot;what-if&quot; scenarios, where you ask the system &quot;what would happen if x were y&quot; and you can potentially do that for many values of y; &quot;why not&quot; scenarios, where you ask the system why a value was not generated; value providence, where you trace back how a value was generated... this kind tooling that just doesn&#x27;t exist with most languages due to how they languages are built to throw away as much information away as possible on each stage of compilation. The kind of tooling I&#x27;m describing requires keeping and logging information about your program, and then leveraging it at runtime.<p>Most compilers and runtimes throw away that information as the program goes through the compilation process and as its running. There is a cost to pay in terms of memory and speed, but I think Python shows that interpretation speed is not that much of a barrier to language adoptions.<p>But like I said, that was many years ago and that team has disbanded. I think a lot of what we had in Eve still hasn&#x27;t reached mainstream programming, although some of what we were researching found its way into Excel eventually.<p>&gt; Loosen Up The Functions... Capabilities... Production-Level Releases... Semi-Dynamic Language... Modular Monoliths<p>I really like where the author&#x27;s head at, I think we have similar ideas about programming because I&#x27;ve been developing a language called Mech that fits these descriptors to some degree since Eve development was shut down.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mech-lang&#x2F;mech">https:&#x2F;&#x2F;github.com&#x2F;mech-lang&#x2F;mech</a><p>So this language is not supposed to be relational like Eve, but it&#x27;s more like Matlab + Python + ROS (or Erlang if you want to keep it in the languages domain).<p>I have a short 10 min video about it here: <a href="https:&#x2F;&#x2F;www.hytradboi.com&#x2F;2022&#x2F;i-tried-rubbing-a-database-on-a-robot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hytradboi.com&#x2F;2022&#x2F;i-tried-rubbing-a-database-on...</a> (brief plug for HYTRADBOI 2025, Jamie also worked on Eve, and if you&#x27;re interested in the kinds of thing the author is, I&#x27;m sure you&#x27;ll find interesting videos at HYTRADBOI &#x27;22 archives and similarly interested people at HYTRADBOI &#x27;25), but this video is out of date because the language has changed a lot since then.<p>Mech is really more of a hobby than anything since I&#x27;m the only one working on it aside from my students, who I conscript, but if anyone wants to tackle some of these issues with me I&#x27;m always looking for collaborators. If you&#x27;re generally interested in this kind of stuff drop by HYTRADBOI, and there&#x27;s also the Future Of Coding slack, where likeminded individuals dwell: <a href="https:&#x2F;&#x2F;futureofcoding.org" rel="nofollow">https:&#x2F;&#x2F;futureofcoding.org</a>. You can also find this community at the LIVE programming workshop which often coincides with SPLASH: <a href="https:&#x2F;&#x2F;liveprog.org" rel="nofollow">https:&#x2F;&#x2F;liveprog.org</a></div><br/><div id="42643243" class="c"><input type="checkbox" id="c-42643243" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#42639056">parent</a><span>|</span><a href="#42638176">next</a><span>|</span><label class="collapse" for="c-42643243">[-]</label><label class="expand" for="c-42643243">[1 more]</label></div><br/><div class="children"><div class="content">I remember both LightTable and Eve. At the time I thought they were both really interesting ideas but wasn&#x27;t sure where they were going.<p>Re-reading the eve website now, with 10+ years more experience and understanding of languages I&#x27;m really astounded at how brilliant Eve was, and how far ahead of it&#x27;s time it was (and still is). Also at how rare it is to have any revolutionary ideas in modern programming language design make it out of theory in contemporary times. There were many radical ideas in the 60 and 70s, but so much now is incremental.<p>It&#x27;s a shame Eve couldn&#x27;t continue, just to see what it would&#x27;ve become and the influence it would have had on language expectations. Really cool stuff in there. While not likely, I hope someone picks up those ideas and continues them.<p>Did the effort just run out of funding? Or did it hit a stumbling block?</div><br/></div></div></div></div><div id="42638176" class="c"><input type="checkbox" id="c-42638176" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#42639056">prev</a><span>|</span><a href="#42637974">next</a><span>|</span><label class="collapse" for="c-42638176">[-]</label><label class="expand" for="c-42638176">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Some Lisps may be able to do all this, although I don’t know if they quite do what I’m talking about here; I’m talking about there being a very distinct point where the programmer says “OK, I’m done being dynamic” for any given piece of code.</i><p>In Common Lisp there are tricks you can pull like declaring functions in a lexical scope (using labels or flet) to remove their lookup overhead. But CL is generally fast enough that it doesn&#x27;t really matter much.</div><br/><div id="42638894" class="c"><input type="checkbox" id="c-42638894" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42638176">parent</a><span>|</span><a href="#42637974">next</a><span>|</span><label class="collapse" for="c-42638894">[-]</label><label class="expand" for="c-42638894">[1 more]</label></div><br/><div class="children"><div class="content">You can declaim inline a toplevel function. That doesn&#x27;t necessarily mean that it will be integrated into callers. Among the possible effects is that the dynamism of reference can be culled away. If a function A calls B where B is declaimed inline then A can be compiled to assume <i>that</i> B definition. (Such that if B is redefined at run-time, A can keep calling the old B, not going through the #&#x27;B function binding lookup.).<p>I seem to remember that Common Lisp compilers are allowed to do this for functions that are in the same file even if they are not declaimed inline. If A and B are in the same file, and B is not declaimed <i>notinline</i> (the opposite of <i>inline</i>), then A can be translated to assume the B definition.<p>So all your helper functions in a Lisp module are allowed to be called more efficiently, not having to go through the function binding of the symbol.</div><br/></div></div></div></div><div id="42637974" class="c"><input type="checkbox" id="c-42637974" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#42638176">prev</a><span>|</span><a href="#42638147">next</a><span>|</span><label class="collapse" for="c-42637974">[-]</label><label class="expand" for="c-42637974">[3 more]</label></div><br/><div class="children"><div class="content">As for &quot;capabilities&quot;, I&#x27;m not sure I fully understand how that is advantageous to the convention of passing the helper function (&quot;capability&quot;) as an argument to the &quot;capable&quot; function.<p>For instance, in Zig, you can see that a function allocates memory (capability) because it requires you to pass an allocator that it can call!<p>I&#x27;d like to see if others are more creative than me!</div><br/><div id="42638734" class="c"><input type="checkbox" id="c-42638734" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42637974">parent</a><span>|</span><a href="#42638693">next</a><span>|</span><label class="collapse" for="c-42638734">[-]</label><label class="expand" for="c-42638734">[1 more]</label></div><br/><div class="children"><div class="content">In Zig it&#x27;s conventional to pass an allocator, but any code can end run around the convention by reaching for page_allocator or c_allocactor behind your back. Capabilities upgrade that convention into a guarantee.</div><br/></div></div><div id="42638693" class="c"><input type="checkbox" id="c-42638693" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#42637974">parent</a><span>|</span><a href="#42638734">prev</a><span>|</span><a href="#42638147">next</a><span>|</span><label class="collapse" for="c-42638693">[-]</label><label class="expand" for="c-42638693">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much how it plays out, as I understand it.<p>The trick is making sure that that object is the Only possible way to do the thing. And making more features like that, for example Networking, or File I&#x2F;O, etc</div><br/></div></div></div></div><div id="42638147" class="c"><input type="checkbox" id="c-42638147" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#42637974">prev</a><span>|</span><a href="#42637754">next</a><span>|</span><label class="collapse" for="c-42638147">[-]</label><label class="expand" for="c-42638147">[2 more]</label></div><br/><div class="children"><div class="content">Totally agree that programming languages are a bit stagnant, with most new features being either trying to squeeze a bit more correctness out via type systems (we&#x27;re well into diminishing returns here at the moment), or minor QoL improvements. Both are useful and welcome but they aren&#x27;t revolutionary.<p>That said, here&#x27;s some of the feedback of the type you said you didn&#x27;t want &gt;8)<p>(1) Function timeouts. I don&#x27;t quite understand how what you want isn&#x27;t just exceptions. Use a Java framework like Micronaut or Spring that can synthesize RPC proxies and you have things that look and work just like function calls, but which will throw exceptions if they time out. You can easily run them async by using something like &quot;CompletableFuture.supplyAsync(() -&gt; proxy.myCall(myArgs))&quot; or in Kotlin&#x2F;Groovy syntax with a static import &quot;supplyAsync { proxy.myCall(myArgs) }&quot;. You can then easily wait for it by calling get() or skip past it. With virtual threads this approach scales very well.<p>The hard&#x2F;awkward part of this is that APIs are usually defined these days in a way that doesn&#x27;t actually map well to standard function calling conventions because they think in terms of POSTing JSON objects rather than being a function with arguments. But there are tools that will convert OpenAPI specs to these proxies for you as best they can. Stricter profiles that result in more idiomatic and machine-generatable proxies aren&#x27;t that hard to do, it&#x27;s just nobody pushed on it.<p>(2) Capabilities. A language like Java has everything needed to do capabilities (strong encapsulation, can restrict reflection). A java.io.File is a capability, for instance. It didn&#x27;t work out because ambient authority is needed for good usability. For instance, it&#x27;s not obvious how you write config files that contain file paths in systems without ambient authority. I&#x27;ve seen attempts to solve this and they were very ugly. You end up needing to pass a lot of capabilities down the stack, ideally in arguments but that breaks every API ever designed so in reality in thread locals or globals, and then it&#x27;s not really much different to ambient authority in a system like the SecurityManager. At least, this isn&#x27;t really a programming language problem but more like a standard library and runtime problem.<p>(3) Production readiness. The support provided by app frameworks like Micronaut or Spring for things like logging is pretty good. I&#x27;ve often thought that a new language should really start by taking a production server app written in one of these frameworks and then examining all the rough edges where the language is mismatched with need. Dependency injection is an obvious one - modern web apps (in Java at least) don&#x27;t really use the &#x27;new&#x27; keyword much which is a pretty phenomenal change to the language. Needing to declare a logger is pure boilerplate. They also rely heavily on code generators in ways that would ideally be done by the language compiler itself. Arguably the core of Micronaut <i>is</i> a compiler and it <i>is</i> a different language, one that just happens to hijack Java infrastructure along the way!<p>What&#x27;s interesting about this is that you could start by forking javac and go from there, because all the features already exist and the work needed is cleaning up the resulting syntax and semantics.<p>(4) Semi-dynamic. This sounds almost exactly like Java and its JIT. Java is a pretty dynamic language in a lot of ways. There&#x27;s even &quot;invokedynamic&quot; and &quot;constant dynamic&quot; features in the bytecode that let function calls and constants be resolved in arbitrarily dynamic ways at first use, at which point they&#x27;re JITd like regular calls. It sounds very similar to what you&#x27;re after and performance is good despite the dynamism of features like lazy loading, bytecode generated on the fly, every method being virtual by default etc.<p>(5) There&#x27;s a library called Permazen that I think gets really close to this (again for Java). It tries to match the feature set of an RDBMS but in a way that&#x27;s far more language integrated, so no SQL, all the data types are native etc. But it&#x27;s actually used in a mission critical production application and the feature set is really extensive, especially around smooth but rigorous schema evolution. I&#x27;d check it out, it certainly made me want to have that feature set built into the language.<p>(6) Sounds a bit like PL&#x2F;SQL? I know you say you don&#x27;t want SQL but PL&#x2F;SQL and derivatives are basically regular programming languages that embed SQL as native parts of their syntax. So you can do things like define local variables where the type is &quot;whatever the type of this table column is&quot; and things like that. For your example of easily loading and debug dumping a join, it&#x27;d look like this:<p><pre><code>    DECLARE
       -- Define a custom record type for the selected columns
       TYPE EmpDept IS RECORD (
          name    employees.first_name%TYPE,
          salary  employees.salary%TYPE,
          dept    departments.department_name%TYPE
       );
       empDept EmpDept;
    BEGIN
       -- Select columns from the joined tables into the record
       SELECT e.first_name, e.salary, d.department_name INTO empDept
       FROM employees e JOIN departments d ON e.department_id = d.department_id
       WHERE e.employee_id = 100;
    
       -- Output the data
       DBMS_OUTPUT.PUT_LINE(&#x27;Name: &#x27; || empDept.name);
       DBMS_OUTPUT.PUT_LINE(&#x27;Salary: &#x27; || empDebt.salary);
       DBMS_OUTPUT.PUT_LINE(&#x27;Department: &#x27; || emptDebt.name);
    END;
</code></pre>
It&#x27;s not a beautiful language by any means, but if you want a natively relational language I&#x27;m not sure how to make it moreso.<p>(7) I think basically all server apps are written this way in Java, and a lot of client (mobile) too. It&#x27;s why I think a language with integrated DI would be interesting. These frameworks provide all the features you&#x27;re asking for already (overriding file systems, transactions, etc), but you don&#x27;t need to declare interfaces to use them. Modern injectors like Avaje Inject, Micronaut etc let you directly inject classes. Then you can override that injection for your tests with a different class, like a subclass. If you don&#x27;t want a subtyping relationship then yes you need an interface, but that seems OK if you have two implementations that are really so different they can&#x27;t share any code at all. Otherwise you&#x27;d just override the methods you care about.<p>Automatically working out the types of parameters sounds a bit like Hindley-Milner type inference, as seen in Haskell.<p>(8) The common way to do this in the Java world is have an annotation processor (compiler plugin) that does the lints when triggered by an annotation, or to create an IntelliJ plugin or pre-canned structural inspection that does the needed AST matching on the fly. IntelliJ&#x27;s structural searches can be saved into XML files in project repositories and there&#x27;s a pretty good matching DSL that lets you say things like &quot;any call to this method with arguments like that and which is inside a loop should be flagged as a warning&quot;, so often you don&#x27;t need to write a proper plugin to find bad code patterns.<p>I realize you didn&#x27;t want feedback of the form &quot;but X can do this already&quot;, still, a lot of these concepts have been explored elsewhere and could be merged or refined into one super-language that includes many of them together.</div><br/><div id="42639536" class="c"><input type="checkbox" id="c-42639536" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#42638147">parent</a><span>|</span><a href="#42637754">next</a><span>|</span><label class="collapse" for="c-42639536">[-]</label><label class="expand" for="c-42639536">[1 more]</label></div><br/><div class="children"><div class="content">PL&#x2F;SQL is an abomination of a language. It’s easily the worst example you could have given.</div><br/></div></div></div></div><div id="42637754" class="c"><input type="checkbox" id="c-42637754" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#42638147">prev</a><span>|</span><a href="#42637712">next</a><span>|</span><label class="collapse" for="c-42637754">[-]</label><label class="expand" for="c-42637754">[1 more]</label></div><br/><div class="children"><div class="content">For relational, look into term-rewriting systems which just keep transforming specified relationships into other things. Maude’s rewriting logic and engine could probably be used for relational programming. It’s fast, too.<p><a href="https:&#x2F;&#x2F;maude.cs.illinois.edu&#x2F;wiki&#x2F;The_Maude_System" rel="nofollow">https:&#x2F;&#x2F;maude.cs.illinois.edu&#x2F;wiki&#x2F;The_Maude_System</a></div><br/></div></div><div id="42637712" class="c"><input type="checkbox" id="c-42637712" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#42637754">prev</a><span>|</span><a href="#42640980">next</a><span>|</span><label class="collapse" for="c-42637712">[-]</label><label class="expand" for="c-42637712">[3 more]</label></div><br/><div class="children"><div class="content">My 4 cents:<p>- I like the idea of a multiparadigm programming language (many exists) but where you can write part of the code in a different language, not trying to embed everything in the same syntax. I think in this way you can write code and express  your ideas differently.<p>- A [social] programming language where some variables and workflows are shared between users [1][2].<p>- A superreflective programming language inspired by Python, Ruby, and others where you can override practically everything to behave different. For example, in Python you can override a function call for an object but not for the base system, globals() dict cannot be overriden. See [3]. In this way you save a lot of time writing a parser and the language basic logic.<p>- A declarative language to stop reinventing the wheel: &quot;I need a website with a secure login&#x2F;logout&#x2F;forgot_your_password_etc, choose a random() template&quot;. It doesn&#x27;t need to be in natural language though.<p>[1] <a href="https:&#x2F;&#x2F;blog.databigbang.com&#x2F;ideas-egont-a-web-orchestration-language&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.databigbang.com&#x2F;ideas-egont-a-web-orchestration...</a><p>[2] <a href="https:&#x2F;&#x2F;blog.databigbang.com&#x2F;egont-part-ii&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.databigbang.com&#x2F;egont-part-ii&#x2F;</a><p>[3] <a href="https:&#x2F;&#x2F;www.moserware.com&#x2F;2008&#x2F;06&#x2F;ometa-who-what-when-where-why.html" rel="nofollow">https:&#x2F;&#x2F;www.moserware.com&#x2F;2008&#x2F;06&#x2F;ometa-who-what-when-where-...</a></div><br/><div id="42638244" class="c"><input type="checkbox" id="c-42638244" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#42637712">parent</a><span>|</span><a href="#42640980">next</a><span>|</span><label class="collapse" for="c-42638244">[-]</label><label class="expand" for="c-42638244">[2 more]</label></div><br/><div class="children"><div class="content">Egont sounds a bit like SQL, no? A social way to share data and work with it ... a shared RDBMS where everyone has a user account and can create tables&#x2F;share them with other users, built in security, etc. Splat a GUI on top and you have something similar.<p>Modern web frameworks are getting pretty declarative. If you want a basic web app with a log in&#x2F;out page that&#x27;s not hard to do. I&#x27;m more familiar with Micronaut than Spring but you&#x27;d just add:<p><pre><code>    micronaut.security.authentication=cookie
</code></pre>
and the relevant dependencies. Now you write a class that checks the username&#x2F;password, or use LDAP, or configure OAuth and the &#x2F;login URL takes a POST of username&#x2F;password. Write a bit of HTML that looks good for your website and you&#x27;re done.<p><a href="https:&#x2F;&#x2F;micronaut-projects.github.io&#x2F;micronaut-security&#x2F;latest&#x2F;guide&#x2F;" rel="nofollow">https:&#x2F;&#x2F;micronaut-projects.github.io&#x2F;micronaut-security&#x2F;late...</a></div><br/><div id="42638654" class="c"><input type="checkbox" id="c-42638654" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#42637712">root</a><span>|</span><a href="#42638244">parent</a><span>|</span><a href="#42640980">next</a><span>|</span><label class="collapse" for="c-42638654">[-]</label><label class="expand" for="c-42638654">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Egont sounds a bit like SQL, no? A social way to share data and work with it ... a shared RDBMS where everyone has a user account and can create tables&#x2F;share them with other users, built in security, etc. Splat a GUI on top and you have something similar.<p>Yes, SQL or a global spreadsheet. I would say that it is like SQL plus a DAG or, we can imagine an aggregation of SQLs. The interesting thing is that parts of the global system are only recalculated if there is a change, like in a spreadsheet.<p>&gt; a shared RDBMS where everyone has a user account and can create tables&#x2F;share them with other users, built in security, etc. Splat a GUI on top and you have something similar.<p>We need a little bit more but not much more: security by namespaces and&#x2F;or rows so the same database is shared but you can restrict who change what: your &quot;rows&quot; are yours. I think something like OrbitDB but with namespaces will be cool.<p>&gt; Modern web frameworks are getting pretty declarative.<p>Yes but my proposal was at a higher level. I don&#x27;t want to know what a cookie is when I just want to create a website. I am not saying that you can create complex components with this idea but you can create common use cases.</div><br/></div></div></div></div></div></div><div id="42640980" class="c"><input type="checkbox" id="c-42640980" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42637712">prev</a><span>|</span><a href="#42637704">next</a><span>|</span><label class="collapse" for="c-42640980">[-]</label><label class="expand" for="c-42640980">[1 more]</label></div><br/><div class="children"><div class="content">&gt; solve the problem by making all function calls async.<p>This is just blocking code and it’s beautiful.</div><br/></div></div><div id="42637704" class="c"><input type="checkbox" id="c-42637704" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#42640980">prev</a><span>|</span><label class="collapse" for="c-42637704">[-]</label><label class="expand" for="c-42637704">[14 more]</label></div><br/><div class="children"><div class="content">Is it just me or whatever &quot;Capabilities&quot; is, is not explained at all?</div><br/><div id="42637777" class="c"><input type="checkbox" id="c-42637777" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42637704">parent</a><span>|</span><a href="#42637827">next</a><span>|</span><label class="collapse" for="c-42637777">[-]</label><label class="expand" for="c-42637777">[4 more]</label></div><br/><div class="children"><div class="content">It is not. I didn&#x27;t want to give a half explanation, but it is another case of the increasing difficulty in coming up with good Google searches anymore.<p><a href="https:&#x2F;&#x2F;erights.org&#x2F;elib&#x2F;capability&#x2F;ode&#x2F;ode-capabilities.html" rel="nofollow">https:&#x2F;&#x2F;erights.org&#x2F;elib&#x2F;capability&#x2F;ode&#x2F;ode-capabilities.htm...</a> is a good start.<p>But you use capabilities all the time... operating system users work that way. As a user, you can&#x27;t &quot;just&quot; execute some binary somewhere and thereby get access to parts of the system your user doesn&#x27;t have rights to. (Forget setuid for a second, which is intended precisely to get around this, and let&#x27;s just look at the underlying primitive.)<p>Capabilities in programming languages take the granularity further down. You might call some image manipulation code in a way that it doesn&#x27;t have the capability to manipulate the file system in general, for example, or call a function to change a user&#x27;s login name with capabilities that <i>only</i> allow changing that user, even if another user ID somehow gets in there.<p>It would be a fairly comprehensive answer to the software dependency issues that continue to bubble up; it would matter less if a bad actor took over &quot;leftpad&quot; if leftpad was actively constrained by the language to <i>only</i> be able to manipulate strings, so the worst an actor could do is make it manipulate strings the wrong way, rather than start running arbitrary code. Or put another way, if the result of the bad actor taking the package wasn&#x27;t that people got hacked but users started getting<p><pre><code>    compile error in file.X:28: library &quot;leftpad&quot; tried to open a file without file system capabilities
    compile error in file.X:30: library &quot;leftpad&quot; tried to open a socket without network capabilities
</code></pre>
which would immediately raise eyebrows.<p>It&#x27;s not a new idea, in that E already tried it, and bits and pieces of it are <i>everywhere</i> (&quot;microkernels&quot; is another place where you&#x27;ll see this idea, but at the OS level and implemented in languages that have no native concept of the capabilities), but for the most part our programming languages do not reflect this.</div><br/><div id="42641390" class="c"><input type="checkbox" id="c-42641390" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#42637704">root</a><span>|</span><a href="#42637777">parent</a><span>|</span><a href="#42637855">next</a><span>|</span><label class="collapse" for="c-42641390">[-]</label><label class="expand" for="c-42641390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But you use capabilities all the time... operating system users work that way.<p>Most operating systems don&#x27;t have proper capabilities - they use things like ACLS, RBAC, MAC, etc for permissions.<p>The golden rule of capabilities is that you should not separate designation from authority. The capability itself represents the authority to access something, and designates what is being accessed.</div><br/></div></div><div id="42637855" class="c"><input type="checkbox" id="c-42637855" checked=""/><div class="controls bullet"><span class="by">NeutralForest</span><span>|</span><a href="#42637704">root</a><span>|</span><a href="#42637777">parent</a><span>|</span><a href="#42641390">prev</a><span>|</span><a href="#42637827">next</a><span>|</span><label class="collapse" for="c-42637855">[-]</label><label class="expand" for="c-42637855">[2 more]</label></div><br/><div class="children"><div class="content">I think the Austral language tries to do some capability based things: <a href="https:&#x2F;&#x2F;austral-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;austral-lang.org&#x2F;</a>.</div><br/><div id="42639127" class="c"><input type="checkbox" id="c-42639127" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#42637704">root</a><span>|</span><a href="#42637855">parent</a><span>|</span><a href="#42637827">next</a><span>|</span><label class="collapse" for="c-42639127">[-]</label><label class="expand" for="c-42639127">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this link!<p>It has this other link that explains more on it : <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Capability-based_security" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Capability-based_security</a><p>I think I get it now. I honestly never had heard about this before and trying to Google search from the original post I was coming up empty.</div><br/></div></div></div></div></div></div><div id="42637827" class="c"><input type="checkbox" id="c-42637827" checked=""/><div class="controls bullet"><span class="by">RainyDayTmrw</span><span>|</span><a href="#42637704">parent</a><span>|</span><a href="#42637777">prev</a><span>|</span><a href="#42637833">next</a><span>|</span><label class="collapse" for="c-42637827">[-]</label><label class="expand" for="c-42637827">[3 more]</label></div><br/><div class="children"><div class="content">For the equivalent in operating systems land, look at the respective manual pages for Linux capabilities[1] or OpenBSD pledge[2] and unveil[3]. The general idea is that there are some operations that might be dangerous, and maybe we don&#x27;t want our program to have unrestricted access to them. Instead, we opt-in to the subset that we know we need, and don&#x27;t have access to the rest.<p>There&#x27;s some interest in the same thing, but at the programming language level. I&#x27;m only aware of it being implemented academically.<p>[1]: <a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;capabilities.7.html" rel="nofollow">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;capabilities.7.html</a>
[2]: <a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;pledge.2" rel="nofollow">https:&#x2F;&#x2F;man.openbsd.org&#x2F;pledge.2</a>
[3]: <a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;unveil.2" rel="nofollow">https:&#x2F;&#x2F;man.openbsd.org&#x2F;unveil.2</a></div><br/><div id="42638534" class="c"><input type="checkbox" id="c-42638534" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42637704">root</a><span>|</span><a href="#42637827">parent</a><span>|</span><a href="#42637899">next</a><span>|</span><label class="collapse" for="c-42638534">[-]</label><label class="expand" for="c-42638534">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that Linux capabilities have much to do with the capabilities that the OP intends.<p>In a capabilities system, a program  has permission to act on any object if it has a reference (aka a capability) to the object, there is no other access control. A program acquires a capability either by receiving it from is parent (or caller in the case of a function) or some other way like message passing. There is no other source of capabilities and they are unforgeable.<p>Unix file descriptors act in many ways as capabilities: they are inherited by processes from their parents and can be passed around via Unix sockets, and grant to the FD holder the same permissions to the referenced object as the creator of the file descriptor.<p>Of course as Unix has other ways from creating file descriptors other than inheritance and message passing is not truly a capabilities system.</div><br/></div></div><div id="42637899" class="c"><input type="checkbox" id="c-42637899" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#42637704">root</a><span>|</span><a href="#42637827">parent</a><span>|</span><a href="#42638534">prev</a><span>|</span><a href="#42637833">next</a><span>|</span><label class="collapse" for="c-42637899">[-]</label><label class="expand" for="c-42637899">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s implemented in Java! .NET tried it too, UNIX file descriptors are capabilities, Mach ports are capabilities. Capabilities are widely used far outside of academia and have been for a long time.<p>What people often mean when they say this is a so-called pure capability system, where there are no ambient permissions at all. Such systems have terrible usability and indeed have never been made to work anywhere, not even in academia as far as I know.</div><br/></div></div></div></div><div id="42637833" class="c"><input type="checkbox" id="c-42637833" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42637704">parent</a><span>|</span><a href="#42637827">prev</a><span>|</span><a href="#42641742">next</a><span>|</span><label class="collapse" for="c-42637833">[-]</label><label class="expand" for="c-42637833">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is not a new idea, so I won’t go deeply into what it is<p>So, no, the author claims it too.<p>Capabilities are a way to do access control where the client holds the key to access something, instead of the server holds a list of what is allowed based on the clients identities.<p>But when people use that word, they are usually talking about fine-grained access control. On a language level, that would mean not granting access for example for a library to do network connections, even though your program as a whole has that kind of access.</div><br/><div id="42639476" class="c"><input type="checkbox" id="c-42639476" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#42637704">root</a><span>|</span><a href="#42637833">parent</a><span>|</span><a href="#42641742">next</a><span>|</span><label class="collapse" for="c-42639476">[-]</label><label class="expand" for="c-42639476">[1 more]</label></div><br/><div class="children"><div class="content">Kind of. At a more fundamental level, it&#x27;s applying the idea that &quot;invalid states should be unrepresentable&quot; (e.g. <a href="https:&#x2F;&#x2F;hugotunius.se&#x2F;2020&#x2F;05&#x2F;16&#x2F;making-invalid-state-unrepresentable.html" rel="nofollow">https:&#x2F;&#x2F;hugotunius.se&#x2F;2020&#x2F;05&#x2F;16&#x2F;making-invalid-state-unrepr...</a> ) but to our code itself.<p>For example, consider a simple function to copy files. We <i>could</i> implement it like this:<p><pre><code>    def copy(fs: Filesystem, in: Path, out: Path) {
      inH: HandleRead = fs.openRead(in);
      outH: HandleWrite = fs.openWrite(&quot;&#x2F;tmp&#x2F;TEST_OUTPUT&quot;);
      finished: Boolean = false;
      while (!finished) {
        match (inH.read()) {
          case None: finished = true;
          case Some(data) = outH.write(data);
        }
      }
      inH.close();
      outH.close();
    }
</code></pre>
However, there are many ways that things could go awry when writing code like this; e.g. it will write to the wrong file, since I forgot to put the real `out` value back after testing (oops!). Such problems are only possible because we&#x27;ve given this function the capability to call `fs.open` (in many languages the situation&#x27;s even worse, since that capability is &quot;ambient&quot;: available everywhere, without having to be passed in like `fs` above). There are also other capabilities&#x2F;permissions&#x2F;authorities implicit in this code, since any call to `fs.open` has to have the right permissions to read&#x2F;write those files.<p>In contrast, consider this alternative implementation:<p><pre><code>    def copy(inH: HandleRead, outH: HandleWrite) {
      finished: Boolean = false;
      while (!finished) {
        match (inH.read()) {
          case None: finished = true;
          case Some(data) = outH.write(data);
        }
      }
      inH.close();
      outH.close();
    }
</code></pre>
This version <i>can&#x27;t</i> use the wrong files, since it doesn&#x27;t have any access to the filesystem: there&#x27;s literally nothing we could write here that would mean &quot;open a file&quot;; it&#x27;s unrepresentable. This code also can&#x27;t mix up the input&#x2F;output, since only `inH` has a `.read()` method and only `outH` has a `.write()` method. The `fs.open` calls will still need to be made somewhere, but there&#x27;s no reason to give our `copy` function that capability.<p>In fact, we can see the same thing on the CLI:<p>- The first version is like `cp oldPath newPath`. Here, the `cp` command needs access to the filesystem, it needs permission to open files, and we have to trust that it won&#x27;t open the wrong files.<p>- The second version is like `cat &lt; oldPath &gt; newPath`. The `cat` command doesn&#x27;t need any filesystem access or permissions, it just dumps data from stdin to stdout; and there&#x27;s no way it can get them mixed up.<p>The fundamental idea is that trying to choose whether an action should be allowed or not (e.g. based on permissions) is too late. It&#x27;s better if those who shouldn&#x27;t be allowed to do an action, aren&#x27;t even able to express it at all.<p>You&#x27;re right that this can often involve &quot;keys&quot;, but that&#x27;s quite artificial: it&#x27;s like adding extra arguments to each function, and limiting which code is scoped to see the values that need to be passed as those arguments (e.g. `fs.openRead(inPath, keyThatAllowsAccess)`), when we could have instead scoped our code to limit access to the functions themselves (though for HTTP APIs, everything is a URL; so &quot;unguessable function endpoint URL&quot; is essentially the same as &quot;URL with secret key in it&quot;)</div><br/></div></div></div></div><div id="42641742" class="c"><input type="checkbox" id="c-42641742" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#42637704">parent</a><span>|</span><a href="#42637833">prev</a><span>|</span><a href="#42638369">next</a><span>|</span><label class="collapse" for="c-42641742">[-]</label><label class="expand" for="c-42641742">[1 more]</label></div><br/><div class="children"><div class="content">A capability is basically a reference which both designates some resource to be accessed <i>and</i> provides the authority to access it. The authority is not held somewhere else like an Access Control List - the reference <i>is</i> the authority. Capabilities must be <i>unforgeable</i> - they&#x27;re obtained by delegation.<p>---<p>To give an example of where this has been used in a programming language, Kernel[1] uses a capability model for mutating environments. Every function (or operative) has an environment which holds all of its local variables, the environment is encapsulated and internally holds a reference to the parent environment (the surrounding scope). The rule is that we can only mutate the local variables of an environment to which we have a direct reference, but we cannot mutate variables in the parents. In order to mutate the variables in the parent, we must have a <i>direct reference</i> to the parent, but there is no mechanism in the language to extract the parent reference from the environment it is encapsulated in.<p>For example, consider the following trivial bit of code: We define some variable `x` with initial value &quot;foo&quot;, we then mutate it to have the value &quot;bar&quot;, then look up `x`.<p><pre><code>    ($define! x &quot;foo&quot;)
    ($set! (get-current-environment) x &quot;bar&quot;) 
    x
</code></pre>
As expected, this returns &quot;bar&quot;. We have a direct reference to the local environment via `(get-current-environment)`.<p>Technically we could&#x27;ve just written `($define! x &quot;bar&quot;)`, where the current environment is assumed, but I used `$set!` because we need it for the next example.<p>When we introduce a new scope, the story is different.<p><pre><code>    ($define! x &quot;foo&quot;)
    ($define! foo
      ($lambda ()
        ($set! (get-current-environment) x &quot;bar&quot;)))
    (foo)
    x
</code></pre>
Here we create a function foo, which has its own local environment, with the top-level environment as its parent. We can <i>read</i> `x` from inside this environment, but we can&#x27;t mutate it. In fact, this code inserts a new variable `x` into the child environment which shadows the existing one within the scope of the function, but after `foo` has returned, this environment is lost, so the result of the computation is &quot;foo&quot;. There is no way for the body of this lambda to mutate the top-level environment here because it doesn&#x27;t have a direct reference to it.<p>So far basically the same static scoping rules you are used to, but environments in Kernel are first-class, so we <i>can</i> get a reference to the top-level environment which grants the child environment the authority to mutate the top level environment.<p><pre><code>    ($define! x &quot;foo&quot;)
    ($define! env (get-current-environment))
    ($define! foo
      ($lambda ()
        ($set! env x &quot;bar&quot;)))
    (foo)
    x
</code></pre>
And the result of this computation is &quot;bar&quot;.<p>However, by binding `env` in the top-level environment, all child scopes can now have the ability to mutate the top-level.<p>To avoid polluting the environment in such way, the better way to write this is with an <i>operative</i> (as opposed to $lambda), which implicitly receives the caller&#x27;s environment as an argument, which it binds to a variable in its local environment.<p><pre><code>    ($define! x &quot;foo&quot;)
    ($define! foo
      (wrap ($vau () caller-env
        ($set! caller-env x &quot;bar&quot;))))
    (foo)
    x
</code></pre>
Now `foo` specifically can mutate it&#x27;s caller&#x27;s <i>local</i> environment, but it can&#x27;t mutate the variables of the caller of the caller, and we have not exposed this authority to all children of the top-level.<p>---<p>This is only a trivial example, but we can do much more clever things with environments in Kernel. We can construct new environments at runtime, and they can have multiple parents, ultimately forming a DAG, where environment lookup is a Depth-First-Search, but the references to the parent environments are encapsulated and cannot be accessed, so we cannot mutate parent scopes without a direct reference - we can only mutate the root node of the DAG for an environment to which we have a direct reference. The direct reference is a <i>capability</i> - it&#x27;s both the means and the authority to mutate.<p>---<p>We can use these first-class environments in conjunction with things like `$remote-eval`, which evaluates some piece of code in an environment provided by the user, which may contain only the bindings they specify, and does not capture anything from the surrounding scope.<p><pre><code>  ($define! calculator-environment
    ($bindings-&gt;environment (+ +) (- -) (* *) (&#x2F; &#x2F;)))

  ($remote-eval (+ 1 2) calculator-environment)
</code></pre>
However, if we try to use some feature like IO, to write an output to the console.<p><pre><code>  ($remote-eval (write (+ 1 2)) calculator-environment)
</code></pre>
We get an error, `write` is unbound - even though `write` is available in the scope in which we performed this evaluation. We could catch this error with a guarded continuation so the program does not crash.<p>This combination of features basically let you create &quot;mini sandboxes&quot;, or custom DSLs, with more limited capabilities than the context in which they&#x27;re evaluated. Most languages only let you <i>add new capabilities</i> to the static environment, by defining new functions and types - but how many languages let you <i>subtract</i> capabilities, so that fewer features are available in a given context? Most languages do this purely at compile time via a module&#x2F;import system, or with static access modifiers like `public` and `private`. Kernel lets you do this at runtime.<p>---<p>One thing missing from this example, which is required for <i>true capabilities</i>, is the ability to revoke the authority. The only way we could revoke the capability of a function to mutate an environment is to suspend the program.<p>Proper capabilities allow revocation <i>at any time</i>. If the creator of a capability revokes the authority, this should propagate to all duplicated, delegated, or derived capabilities with immediate effect. The capabilities that were held become &quot;zombies&quot;, which no longer provide the means nor the authority - and this is why it is essential that we don&#x27;t separate designation from authority, and why these should both be encapsulated in the capability.<p>This clearly makes it difficult to provide proper capabilities in programming languages, because we have to handle every possible error where we attempt to access a zombie capability. The use of such capabilities should be limited to where they really matter such as access to operating system resources, cryptographic keys, etc. where it&#x27;s reasonable to implement robust error handling code. We don&#x27;t want capabilities for every programming language feature because we would need to insert error checks on every expression to handle the potential zombie. Attempting to check if a capability is live before using it is no solution anyway, because you would have race conditions, so the correct approach to using them is to just try and catch the error if it occurs.<p>Another take-away from this is that if capabilities are provided in a language via a type system, <i>it must be a dynamic type system</i>. You cannot grant authority in a static type system at compile time if the capability may have already been revoked by the time the program is run. Capabilities are inherently dynamic by nature because they can be revoked <i>at any time</i>. This doesn&#x27;t mean you can&#x27;t use capabilities in conjunction with a static type system - only that the static type system can&#x27;t really represent capabilities.<p>You can find out a lot more about them on the erights page that others have linked, and I would recommend looking into seL4 if you&#x27;re interested in how they&#x27;re applied to operating systems.<p>---<p>[1]:<a href="http:&#x2F;&#x2F;web.cs.wpi.edu&#x2F;%7Ejshutt&#x2F;kernel.html" rel="nofollow">http:&#x2F;&#x2F;web.cs.wpi.edu&#x2F;%7Ejshutt&#x2F;kernel.html</a></div><br/></div></div><div id="42638369" class="c"><input type="checkbox" id="c-42638369" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42637704">parent</a><span>|</span><a href="#42641742">prev</a><span>|</span><a href="#42637784">next</a><span>|</span><label class="collapse" for="c-42638369">[-]</label><label class="expand" for="c-42638369">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a fancy word for &quot;access things through a handle&quot;.</div><br/><div id="42638560" class="c"><input type="checkbox" id="c-42638560" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42637704">root</a><span>|</span><a href="#42638369">parent</a><span>|</span><a href="#42637784">next</a><span>|</span><label class="collapse" for="c-42638560">[-]</label><label class="expand" for="c-42638560">[1 more]</label></div><br/><div class="children"><div class="content">The key property being that everything can only be accessed via handles, including, recursively, other handles (i.e. to get an handle to an object you need first to already have an handle to the handle-giver for that object).</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>