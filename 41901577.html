<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729760475229" as="style"/><link rel="stylesheet" href="styles.css?v=1729760475229"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://osa1.net/posts/2024-10-09-oop-good.html">OOP is not that bad</a> <span class="domain">(<a href="https://osa1.net">osa1.net</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>190 comments</span></div><br/><div><div id="41904146" class="c"><input type="checkbox" id="c-41904146" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#41904055">next</a><span>|</span><label class="collapse" for="c-41904146">[-]</label><label class="expand" for="c-41904146">[53 more]</label></div><br/><div class="children"><div class="content">The author brings up the basically the canonical example of where OOP style design shines, and where functional programming will falter.<p>The simple truth however is that overly going into either functional or OOP camp will hurt because strict adherence becomes subscribing to a silver-bullet.<p>The middle road is simply a better engineering option, use a practical language that supports both paradigms.<p>Keep data transforms and algorithmic calculations in functional style because those tend to become hot messes if you rely overly on mutation (even if there is performance gains, correctness is far far easier to get right and write tests for with a functional approach), then there are other concerns where an OOP derived system with inheritance abstractions will make things easier.</div><br/><div id="41904311" class="c"><input type="checkbox" id="c-41904311" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904270">next</a><span>|</span><label class="collapse" for="c-41904311">[-]</label><label class="expand" for="c-41904311">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The middle road is simply a better engineering option, use a practical language that supports both paradigms.<p>Agreed - I would get more specific with this too. Which arrangement makes more sense:<p>1. A solution that has an OOP outer shell hosting an FP inner core<p>2. A solution that has an FP outer shell hosting an OOP inner core<p>I argue that 1 makes way more sense - I look at the OOP&#x2F;procedural code as the foundation layer upon which the FP code can be executed. This firewalls the messy outside world from the pure maths. For me this would be entry points like BusinessLogic.ExecuteRules() after having externally prepared all of the data contexts for execution. The results of this are then processed again by the external OOP code for downstream handling (writing to database, responding to web client, etc).<p>The other way around feels nonsensical to me.</div><br/><div id="41932747" class="c"><input type="checkbox" id="c-41932747" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904311">parent</a><span>|</span><a href="#41933245">next</a><span>|</span><label class="collapse" for="c-41932747">[-]</label><label class="expand" for="c-41932747">[1 more]</label></div><br/><div class="children"><div class="content">Mutation is infectious. It will take great care to have an OOP core and outer FP shell. The OOP core might have to become completely threadsafe and use mutexes and such, to be reliable. This might be more painful than sticking to either one paradigm.</div><br/></div></div><div id="41933245" class="c"><input type="checkbox" id="c-41933245" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904311">parent</a><span>|</span><a href="#41932747">prev</a><span>|</span><a href="#41904270">next</a><span>|</span><label class="collapse" for="c-41933245">[-]</label><label class="expand" for="c-41933245">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The other way around feels nonsensical to me.</i><p>Wonder if that&#x27;s because you&#x27;ve learned the pattern - &quot;functional core, imperative shell&quot;? I feel it&#x27;s not a coincidence you used the terms &quot;shell&quot; and &quot;core&quot; in your comment :).<p>Myself, I&#x27;m very much in favor on a theoretical basis. In practice, I&#x27;ve got bitten by this a couple times - keeping a purely functional core didn&#x27;t play nice with the modularization and testing setup we had, using C++17 with CMake and GTest&#x2F;GMock. I blame this on my inexperience, filing off sharp corners as I go along. I&#x27;d sure could use a detailed study of how to apply this pattern in modern C++, on an application scale, taking account the real tradeoffs - like how to &quot;firewall&quot; the core from outside mess, <i>and</i> allow tests to poke through that firewall, <i>and</i> not end up in weird linking hell, <i>and</i> not blow a single module into 10 tiny ones, <i>and</i> keep the whole thing debuggable in practice[0].<p>One thing I occasionally do even in the &quot;FP inner core&quot; is apply the idea I picked up from Clojure&#x27;s &quot;transient&quot; data structures: there is no difference between purely-functional, immutable, referentially transparent code, and imperative code carrying mutable state, <i>if no one on the outside can tell</i>. Sometimes it&#x27;s just easier to make a typical imperative procedural or OOP solution and isolate it in a functional interface.<p>--<p>[0] - I used to like point-free coding; especially with functional style, it makes for nice, readable, highly-expressive one-liners. But each time I had to debug such code, I ended up regretting it. Now I&#x27;m starting to favor more explicit steps with intermediary variables storing results, simply to have good targets for potential breakpoints&#x2F;tracepoints, and because such code is more convenient to step through. You could say I&#x27;m only doing it because the tools I use are limited, but frankly, almost all of &quot;readable code&quot; principles and even the shape of modern languages are driven by limitations of the tools we use, so ¯\_(ツ)_&#x2F;¯.</div><br/></div></div></div></div><div id="41904270" class="c"><input type="checkbox" id="c-41904270" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904311">prev</a><span>|</span><a href="#41932392">next</a><span>|</span><label class="collapse" for="c-41904270">[-]</label><label class="expand" for="c-41904270">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m less an OOP fan and more an extreme late-binding fan. It is a really nice lever to use when you need it. You don&#x27;t necessarily need a language built for it if you have sufficient infrastructure in place (such as dependency injection).<p>That said, FP is a great default for most code, and I try not to write any new code in languages that don&#x27;t support algebraic data types. You can express things much more precisely with them.<p>Languages that let you use both styles (Kotlin&#x2F;Swift) are probably my favorite, despite using Haskell in production at work. Haskell punishes needing to use mutability too harshly IMO.</div><br/><div id="41932414" class="c"><input type="checkbox" id="c-41932414" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904270">parent</a><span>|</span><a href="#41932392">next</a><span>|</span><label class="collapse" for="c-41932414">[-]</label><label class="expand" for="c-41932414">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Late bind all the things&quot; is pretty much what Alan Kay&#x27;s idea of OO was. In particular it means that methods are invoked by name and selected based on message name by the receiving object. Any object can be sent any message; how that message is handled is determined by the object at invocation time. No vtbls or other such mechanisms used by statically typed OO languages are involved.<p>Kay has spoken positively, for instance, of Erlang, which has nothing like Smalltalk&#x27;s OO model.</div><br/><div id="41933303" class="c"><input type="checkbox" id="c-41933303" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932414">parent</a><span>|</span><a href="#41932392">next</a><span>|</span><label class="collapse" for="c-41933303">[-]</label><label class="expand" for="c-41933303">[2 more]</label></div><br/><div class="children"><div class="content">But late binding doesn&#x27;t have performance implications? If the compiler doesn&#x27;t know the type it can&#x27;t do optimizations.</div><br/><div id="41933511" class="c"><input type="checkbox" id="c-41933511" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41933303">parent</a><span>|</span><a href="#41932392">next</a><span>|</span><label class="collapse" for="c-41933511">[-]</label><label class="expand" for="c-41933511">[1 more]</label></div><br/><div class="children"><div class="content">It has, but that can be overcome by thick enough runtime.<p>My experience is with Common Lisp, which has a <i>quite sophisticated</i> object system (CLOS) with a metaobject protocol. Theoretically, pretty much <i>everything</i> there can be altered on the fly at runtime - classes and methods can be added, <i>modified</i> and deleted, inheritance hierarchy changed, method invocation rules arbitrarily altered, etc. In practice, efficient implementations like SBCL (which tries to eagerly compile everything down to machine code, including at runtime) tend to have a lot of logic for keeping track how <i>how things currently are</i>.<p>99.9% of the time, the current shape of the object model is fixed, so it&#x27;s kept optimized in advance. For example, calling (my-method my-obj) can do <i>anything</i>, depending on what my-method, my-obj, (class-of my-obj), etc. are at the moment - however both you and the runtime know that, right now, my-method is only defined on class-foo, which uses standard object model rules, so the runtime ensures the call is just a fixed-address jump. Define my-method for another class, the runtime will make calls to my-method a simple lookup on a tag (or something equivalent). Mess with the method combination order, or class definitions, and the runtime will redo its own book-keeping and keep the calls as efficient as possible. So you still pay for the flexibility - but mostly just-in-time, in the 0.1% of the time you invalidate some optimization, forcing the runtime to re-optimize itself.<p>I don&#x27;t have as much experience with Smalltalk, but I hear that the story there is similar - you usually have a fat runtime with gnarly, stateful internals that re-optimizes itself on the fly to keep the flexibility performant. It&#x27;s a nice benefit of image-based languages, where the compiler is an integral part of the runtime.</div><br/></div></div></div></div></div></div></div></div><div id="41932392" class="c"><input type="checkbox" id="c-41932392" checked=""/><div class="controls bullet"><span class="by">piyush_soni</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904270">prev</a><span>|</span><a href="#41904438">next</a><span>|</span><label class="collapse" for="c-41932392">[-]</label><label class="expand" for="c-41932392">[11 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Keep data transforms and algorithmic calculations in functional style</i><p>What annoys me greatly though is kids coding various &#x27;fancy&#x27; functional paradigms for data transformation without realizing their performance implications, still thinking they&#x27;ve actually done the &#x27;smarter&#x27; thing by transforming it multiple times and changing a simple loop to three or four loops. Example : Array.map.filter.map.reduce. Also when talked about it, they have learned to respond with another fancy term : &quot;that would be premature optimization&quot;. :|</div><br/><div id="41932590" class="c"><input type="checkbox" id="c-41932590" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932392">parent</a><span>|</span><a href="#41932725">next</a><span>|</span><label class="collapse" for="c-41932590">[-]</label><label class="expand" for="c-41932590">[1 more]</label></div><br/><div class="children"><div class="content">This is just an unfortunate consequence of how map and filter are implemented via iterators.<p>Of you work with transducers, the map filter map reduce is still just one single loop.</div><br/></div></div><div id="41932725" class="c"><input type="checkbox" id="c-41932725" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932392">parent</a><span>|</span><a href="#41932590">prev</a><span>|</span><a href="#41933282">next</a><span>|</span><label class="collapse" for="c-41932725">[-]</label><label class="expand" for="c-41932725">[1 more]</label></div><br/><div class="children"><div class="content">That kind of thing really depends on the language. Some of the stronger functional languages like Haskell have lazy evaluation, so that operation won&#x27;t be as bad as it looks. But then you really need to fully understand the tradeoffs of lazy evaluation too.</div><br/></div></div><div id="41933282" class="c"><input type="checkbox" id="c-41933282" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932392">parent</a><span>|</span><a href="#41932725">prev</a><span>|</span><a href="#41932466">next</a><span>|</span><label class="collapse" for="c-41933282">[-]</label><label class="expand" for="c-41933282">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how things are implemented in other languages but in C# 9, these operations are optimized.</div><br/><div id="41933555" class="c"><input type="checkbox" id="c-41933555" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41933282">parent</a><span>|</span><a href="#41933478">next</a><span>|</span><label class="collapse" for="c-41933555">[-]</label><label class="expand" for="c-41933555">[1 more]</label></div><br/><div class="children"><div class="content">There are ways to keep functional transformations and immutable data structures efficient. Copy-on-write, unrolling expressions into loops, etc. Proper functional languages have them built into the runtime - your clean map-reduce chain will get translated to some gnarly, state-mutating imperative code during compilation. In non-FP or mixed-paradigm languages, where functional building blocks are just regular library functions (standard or otherwise), map-reduce is <i>exactly what it says on the tin</i> - two loops and a lot of copying; you want it fast, you have to mostly optimize it yourself.<p>In other words, you need to know which things in your language are considered to be language&#x2F;compiler&#x2F;runtime primitives, and which are just regular code.</div><br/></div></div><div id="41933478" class="c"><input type="checkbox" id="c-41933478" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41933282">parent</a><span>|</span><a href="#41933555">prev</a><span>|</span><a href="#41932466">next</a><span>|</span><label class="collapse" for="c-41933478">[-]</label><label class="expand" for="c-41933478">[1 more]</label></div><br/><div class="children"><div class="content">Most languages don&#x27;t have these facilities at all - so you need to be really careful what you are doing.
This works &quot;fine&quot; with test data, because your test data usually is a few hundert items max.
A few years back people at our firm build all data filtering in the frontend, to keep the &quot;backend clean&quot;. That worked fine in testing. In production with 100k rows? Not so much.<p>Even in C# it depends on the linq provider - if you are talking to a DB, your quers should be optimized. Linq to objects doesn&#x27;t do that and repeated scanning can kill your performance.  E.g. repeated filtering on large lists.</div><br/></div></div></div></div><div id="41932466" class="c"><input type="checkbox" id="c-41932466" checked=""/><div class="controls bullet"><span class="by">kosmozaut</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932392">parent</a><span>|</span><a href="#41933282">prev</a><span>|</span><a href="#41932441">next</a><span>|</span><label class="collapse" for="c-41932466">[-]</label><label class="expand" for="c-41932466">[3 more]</label></div><br/><div class="children"><div class="content">Why would your example be O(n³)?</div><br/><div id="41932568" class="c"><input type="checkbox" id="c-41932568" checked=""/><div class="controls bullet"><span class="by">piyush_soni</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932466">parent</a><span>|</span><a href="#41932441">next</a><span>|</span><label class="collapse" for="c-41932568">[-]</label><label class="expand" for="c-41932568">[2 more]</label></div><br/><div class="children"><div class="content">Oh yes, sorry I meant to write 3 * O(n) which though doesn&#x27;t change the order is still three times the operations. The example I was remembering was doing filters &#x27;inside&#x27; maps.</div><br/></div></div></div></div><div id="41932441" class="c"><input type="checkbox" id="c-41932441" checked=""/><div class="controls bullet"><span class="by">Gunax</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932392">parent</a><span>|</span><a href="#41932466">prev</a><span>|</span><a href="#41904438">next</a><span>|</span><label class="collapse" for="c-41932441">[-]</label><label class="expand" for="c-41932441">[2 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t those all linear operations?</div><br/><div id="41932578" class="c"><input type="checkbox" id="c-41932578" checked=""/><div class="controls bullet"><span class="by">piyush_soni</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932441">parent</a><span>|</span><a href="#41904438">next</a><span>|</span><label class="collapse" for="c-41932578">[-]</label><label class="expand" for="c-41932578">[1 more]</label></div><br/><div class="children"><div class="content">Yes, wrote quickly without thinking. Even if it doesn&#x27;t change the complexity,  it&#x27;s still three or four times the operations.</div><br/></div></div></div></div></div></div><div id="41904438" class="c"><input type="checkbox" id="c-41904438" checked=""/><div class="controls bullet"><span class="by">ndriscoll</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41932392">prev</a><span>|</span><a href="#41905421">next</a><span>|</span><label class="collapse" for="c-41904438">[-]</label><label class="expand" for="c-41904438">[1 more]</label></div><br/><div class="children"><div class="content">The example is a single-abstract-method class, i.e. a lambda function. You can define it as<p><pre><code>  `type Logger = (String, Severity) =&gt; IO ()`

  `def empty: Logger = (_, _) =&gt; IO.unit`

  `def aboveSeverity(l: Logger)(minsev: Severity): Logger = (s, sev) =&gt; if sev &gt;= minsev l(s, sev) else IO.unit`
</code></pre>
Or Curried if you like. In Scala, you might put these on a companion object so that you can give Logger.empty to your tests, etc. You don&#x27;t need the type to remember which type of logger you had. The only thing you care about is that you can call it.</div><br/></div></div><div id="41905421" class="c"><input type="checkbox" id="c-41905421" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904438">prev</a><span>|</span><a href="#41933225">next</a><span>|</span><label class="collapse" for="c-41905421">[-]</label><label class="expand" for="c-41905421">[6 more]</label></div><br/><div class="children"><div class="content">This is strange to me because I don&#x27;t see FP faltering here at all.  I suppose it depends on precisely what you mean by &quot;OOP&quot; and &quot;FP&quot;.  Below is an example implementation in my Haskell effect system Bluefin.  It defines a Logger interface (that can log a message with severity) and then instantiates it with two implementations<p><a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;bluefin</a><p>1. a logger that logs to stdout<p>2. a logger that logs to a file<p>The file logger also brackets the opening of the file so that if abnormal termination is encountered then the file handle is guaranteed to be cleaned up.  This is similar to RAII.<p>I really like this solution!  It&#x27;s just programming against an interface, and then instantiating the interface in different ways.  I think an solution using inheritance would be worse, because it would use a special language concept (inheritance) rather than a standard one (function definition).<p>Perhaps this is &quot;OOP&quot; and not &quot;FP&quot;? That&#x27;s fine by me!  But in that case I conclude Haskell is an excellent OOP language.  (I already conclude that it&#x27;s an excellent imperative language.)<p><pre><code>    {-# LANGUAGE GHC2021 #-}
    
    import Bluefin.Compound
    import Bluefin.Eff
    import Bluefin.IO
    import System.IO
    import Prelude hiding (log)
    
    newtype Logger e =
        -- Log a message with a severity
        MkLogger {log :: String -&gt; Int -&gt; Eff e ()}
    
    withStdoutLogger ::
      (e1 :&gt; es) =&gt;
      IOE e1 -&gt;
      (forall e. Logger e -&gt; Eff (e :&amp; es) r) -&gt;
      Eff es r
    withStdoutLogger io k =
      useImplIn
        k
        MkLogger
          { log =
              \msg sev -&gt;
                effIO io (putStrLn (show sev ++ &quot;: &quot; ++ msg))
          }
    
    withFileLogger ::
      (e1 :&gt; es) =&gt;
      FilePath -&gt;
      IOE e1 -&gt;
      (forall e. Logger e -&gt; Eff (e :&amp; es) r) -&gt;
      Eff es r
    withFileLogger fp io k =
      bracket
        (effIO io (openFile fp ReadMode))
        (effIO io . hClose)
        ( \handle -&gt; do
            useImplIn
              k
              MkLogger
                { log =
                    \msg sev -&gt;
                      effIO io (hPutStr handle (show sev ++ &quot;: &quot; ++ msg))
                }
        )</code></pre></div><br/><div id="41905498" class="c"><input type="checkbox" id="c-41905498" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41905421">parent</a><span>|</span><a href="#41933225">next</a><span>|</span><label class="collapse" for="c-41905498">[-]</label><label class="expand" for="c-41905498">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fine, but suppose you wanted to swap out loggers (or add an extra logger target) at runtime.  Maybe someone wants transiently hooks in an observer by logging into a webpage that shoots the logs at that users browser.  I don&#x27;t know enough Haskell (and it&#x27;s hard enough to read) that I can&#x27;t tell if this code can deal with that case.</div><br/><div id="41905792" class="c"><input type="checkbox" id="c-41905792" checked=""/><div class="controls bullet"><span class="by">ndriscoll</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41905498">parent</a><span>|</span><a href="#41906009">next</a><span>|</span><label class="collapse" for="c-41905792">[-]</label><label class="expand" for="c-41905792">[3 more]</label></div><br/><div class="children"><div class="content">Swapping out loggers at runtime is a separate concern (inheritance and OOP don&#x27;t make that any easier), and is more to do with control flow or whether there&#x27;s an indirection when accessing the logger.</div><br/><div id="41932406" class="c"><input type="checkbox" id="c-41932406" checked=""/><div class="controls bullet"><span class="by">kergonath</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41905792">parent</a><span>|</span><a href="#41906009">next</a><span>|</span><label class="collapse" for="c-41932406">[-]</label><label class="expand" for="c-41932406">[2 more]</label></div><br/><div class="children"><div class="content">Polymorphism definitely makes it much easier, and it is a core concept in OOP. I am not advocating for or against OOP, but “swapping behaviour at runtime” is one of the things it’s good at.</div><br/><div id="41932941" class="c"><input type="checkbox" id="c-41932941" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932406">parent</a><span>|</span><a href="#41906009">next</a><span>|</span><label class="collapse" for="c-41932941">[-]</label><label class="expand" for="c-41932941">[1 more]</label></div><br/><div class="children"><div class="content">If you want to be able to swap out implementations, personally I’d much rather rust’s trait system (or Java or typescript’s interfaces) over what “OO languages” like C++ give you. I basically never want a strict tree of object types with inheritance.<p>This isn’t an OO idea. I’m pretty sure FP languages like Haskell or ocaml have something very similar.</div><br/></div></div></div></div></div></div><div id="41906009" class="c"><input type="checkbox" id="c-41906009" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41905498">parent</a><span>|</span><a href="#41905792">prev</a><span>|</span><a href="#41933225">next</a><span>|</span><label class="collapse" for="c-41906009">[-]</label><label class="expand" for="c-41906009">[1 more]</label></div><br/><div class="children"><div class="content">Sure, it could handle that case. You&#x27;d have to write a `withSwappableLogger` function which produces a logger that listens for updates telling it where to log to in future.</div><br/></div></div></div></div></div></div><div id="41933225" class="c"><input type="checkbox" id="c-41933225" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41905421">prev</a><span>|</span><a href="#41904174">next</a><span>|</span><label class="collapse" for="c-41933225">[-]</label><label class="expand" for="c-41933225">[1 more]</label></div><br/><div class="children"><div class="content">Elm has taught me that pure FP can work beautifully. But it didn&#x27;t quite catch on, which says something (but not necessarily that this approach is wrong), and it&#x27;s also clealry not suited for every type of programming (e.g. systems programming or other low level stuff).<p>Pure OOP aka Java has been a mistake, even though it&#x27;s probably the most popular.</div><br/></div></div><div id="41904174" class="c"><input type="checkbox" id="c-41904174" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41933225">prev</a><span>|</span><a href="#41904177">next</a><span>|</span><label class="collapse" for="c-41904174">[-]</label><label class="expand" for="c-41904174">[5 more]</label></div><br/><div class="children"><div class="content">How do functional styles falter?  Erlang&#x27;s telemetry&#x2F;logger systems are absolutely fantastic.</div><br/><div id="41904363" class="c"><input type="checkbox" id="c-41904363" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904174">parent</a><span>|</span><a href="#41904177">next</a><span>|</span><label class="collapse" for="c-41904363">[-]</label><label class="expand" for="c-41904363">[4 more]</label></div><br/><div class="children"><div class="content">While Erlang itself is pure, in practice it seems like a lot of practical mutation and state issues are tucked in other processes. Nothing wrong with it and it sidesteps the purity issues that the Haskell example in the article presents.</div><br/><div id="41906062" class="c"><input type="checkbox" id="c-41906062" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904363">parent</a><span>|</span><a href="#41905455">next</a><span>|</span><label class="collapse" for="c-41906062">[-]</label><label class="expand" for="c-41906062">[1 more]</label></div><br/><div class="children"><div class="content">The supposed problems in the Haskell example presented in the article have nothing to do with purity.  Logging is by definition an effect.  Haskell supports effects just fine.  (I&#x27;d personally say better than any other language I know.)</div><br/></div></div><div id="41905455" class="c"><input type="checkbox" id="c-41905455" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904363">parent</a><span>|</span><a href="#41906062">prev</a><span>|</span><a href="#41904177">next</a><span>|</span><label class="collapse" for="c-41905455">[-]</label><label class="expand" for="c-41905455">[2 more]</label></div><br/><div class="children"><div class="content">Is this no true scottish languaging on what constitutes fp?  More to the point with the original article, erlang is assuredly not OOP in the modern sense (no matter how much joe Armstrong tried to rope java shops in by saying that actors are actually the true objects)<p>Also:<p>&gt; Erlang itself is pure<p>Very not true. erlang is extremely impure fp and that&#x27;s a big part of what makes it what it is.</div><br/><div id="41912090" class="c"><input type="checkbox" id="c-41912090" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41905455">parent</a><span>|</span><a href="#41904177">next</a><span>|</span><label class="collapse" for="c-41912090">[-]</label><label class="expand" for="c-41912090">[1 more]</label></div><br/><div class="children"><div class="content">Right, and that&#x27;s my point about practical languages that promotes a functional style being a better choice. The requirement for purity in Haskell (due to lazy evaluation) makes anything but purity a problem, it seems sometimes that just because things are possible to do purely it&#x27;s the only way to do things according to adherents.</div><br/></div></div></div></div></div></div></div></div><div id="41904177" class="c"><input type="checkbox" id="c-41904177" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904174">prev</a><span>|</span><a href="#41904355">next</a><span>|</span><label class="collapse" for="c-41904177">[-]</label><label class="expand" for="c-41904177">[1 more]</label></div><br/><div class="children"><div class="content">Semi-mutable, semi-private, semi-nullable, semi-determistic, and semi-statically-typed.  Best of both camps.</div><br/></div></div><div id="41904355" class="c"><input type="checkbox" id="c-41904355" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904177">prev</a><span>|</span><a href="#41932486">next</a><span>|</span><label class="collapse" for="c-41904355">[-]</label><label class="expand" for="c-41904355">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The middle road is simply a better engineering option, use a practical language that supports both paradigms.<p>I recommend reading &quot;The curse of the excluded middle&quot; paper by Erik Meijer on why this approach does not work.</div><br/><div id="41904575" class="c"><input type="checkbox" id="c-41904575" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904355">parent</a><span>|</span><a href="#41904430">next</a><span>|</span><label class="collapse" for="c-41904575">[-]</label><label class="expand" for="c-41904575">[7 more]</label></div><br/><div class="children"><div class="content">It was from 2014.<p>In the past decade, we&#x27;ve seen &quot;the middle way&quot; has won.<p>- Every mainstream OOP languages now support passing functions as parameters.<p>- Optional type annotation became mainstream, e.g. Typescript and modern Python.</div><br/><div id="41904729" class="c"><input type="checkbox" id="c-41904729" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904575">parent</a><span>|</span><a href="#41904783">next</a><span>|</span><label class="collapse" for="c-41904729">[-]</label><label class="expand" for="c-41904729">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Optional type annotation became mainstream, e.g. Typescript and modern Python.</i><p>It became mainstream indeed but, in my opinion, it&#x27;s still a mess. Optional type annotations seem like the worst of every possible world to me, and it leads to unprincipled [1] developers to just not use them or use them so inconsistently it doesn&#x27;t matter and we revert to &quot;no type annotations at all&quot;.<p>Just my experience, of course.<p>----<p>[1] which, in the wild, is the most common type of developer. And really, features should help with the most common developer, not the most principled ones.</div><br/><div id="41908111" class="c"><input type="checkbox" id="c-41908111" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904729">parent</a><span>|</span><a href="#41904783">next</a><span>|</span><label class="collapse" for="c-41908111">[-]</label><label class="expand" for="c-41908111">[3 more]</label></div><br/><div class="children"><div class="content">Typescript&#x2F;Python aren&#x27;t good examples of mainstream adoption of Haskell related ideas. Haskell always has types but has inference. A better example would be Kotlin or Swift style languages, where type inference is much more pervasive than in the past albeit deliberately limited so as to not be as extensive as in Haskell.</div><br/><div id="41909412" class="c"><input type="checkbox" id="c-41909412" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41908111">parent</a><span>|</span><a href="#41904783">next</a><span>|</span><label class="collapse" for="c-41909412">[-]</label><label class="expand" for="c-41909412">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think either Swift or Kotlin have &quot;optional type annotations&quot; of the sort mentioned in the comment I was replying to...<p>In this context &quot;optional&quot; means &quot;you can either use or not use type annotations&quot;, which is not related to type inference [1] but is a way to <i>gradually</i> add types, usually in a half-baked, unsatisfying way.<p>[1] because unlike with Kotlin or Swift, there&#x27;s no inference when you leave out the annotations, but instead you &quot;switch off&quot; static typechecking for portions of the code you don&#x27;t want to annotate.</div><br/><div id="41914985" class="c"><input type="checkbox" id="c-41914985" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41909412">parent</a><span>|</span><a href="#41904783">next</a><span>|</span><label class="collapse" for="c-41914985">[-]</label><label class="expand" for="c-41914985">[1 more]</label></div><br/><div class="children"><div class="content">Yes I know, but I think we&#x27;re discussing the extent to which ideas from FP languages leaked into the mainstream? Optional-as-in-dynamic typing didn&#x27;t come from the FP world, whereas optional-as-in-inferred did.</div><br/></div></div></div></div></div></div></div></div><div id="41904783" class="c"><input type="checkbox" id="c-41904783" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904575">parent</a><span>|</span><a href="#41904729">prev</a><span>|</span><a href="#41904430">next</a><span>|</span><label class="collapse" for="c-41904783">[-]</label><label class="expand" for="c-41904783">[2 more]</label></div><br/><div class="children"><div class="content">In Haskell, you pay the penalty of using map-reduce style semantics (&quot;why can&#x27;t I just use for-loops which are so much simpler?&quot;) instead of mutation.  But the benefit is you get your nice determinism properties.<p>The middle-way languages adopted the penalties, but not the benefits.  So the real winner was &quot;lose-lose&quot;.</div><br/><div id="41905099" class="c"><input type="checkbox" id="c-41905099" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904783">parent</a><span>|</span><a href="#41904430">next</a><span>|</span><label class="collapse" for="c-41905099">[-]</label><label class="expand" for="c-41905099">[1 more]</label></div><br/><div class="children"><div class="content">No. The middle-way languages didn&#x27;t adopt functional programming&#x27;s properties. They adopted the <i>syntax</i>. The syntax alone, even without the immunatbility and other properties from functional programming, is extremely useful to elimiate boilerplate like Observer and Strategy patterns.</div><br/></div></div></div></div></div></div><div id="41904430" class="c"><input type="checkbox" id="c-41904430" checked=""/><div class="controls bullet"><span class="by">red_admiral</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904355">parent</a><span>|</span><a href="#41904575">prev</a><span>|</span><a href="#41904718">next</a><span>|</span><label class="collapse" for="c-41904430">[-]</label><label class="expand" for="c-41904430">[1 more]</label></div><br/><div class="children"><div class="content">Functional programming has found its way into Java, where it works ok for some tasks; scheme&#x2F;kotlin might advertise themselves as FP in the sense of &quot;even more FP-ish than Java&quot; but they&#x27;re really mixed paradigm too, and not just because of backwards compatibility with other JVM libraries.<p>We&#x27;ve made the middle road work. It is not the magical 10x speed upgrade that some managers hoped for if you just sprinkle some FP on top of the project like icing, but it works quite well in practice because you have the right tools for dealing with different kinds of subproblems.<p>Meijer&#x27;s paper is what I would call &quot;FP maximalist&quot;. (Or &quot;Haskell maximalist&quot;, as even OcaML manages without hiding all IO away in monads.) It&#x27;s a defensible opinion to have, but doesn&#x27;t have anything to do with the work environments that I have experience with.</div><br/></div></div><div id="41904718" class="c"><input type="checkbox" id="c-41904718" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41904355">parent</a><span>|</span><a href="#41904430">prev</a><span>|</span><a href="#41932486">next</a><span>|</span><label class="collapse" for="c-41904718">[-]</label><label class="expand" for="c-41904718">[1 more]</label></div><br/><div class="children"><div class="content">Most of the &quot;horrible&quot; examples in that paper are uncommon&#x2F;unrealistic constructs to prove a point, yes there are real footguns in that are analogous to them but even with junior developers around I&#x27;ve yet to see many in practice.</div><br/></div></div></div></div><div id="41932486" class="c"><input type="checkbox" id="c-41932486" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904355">prev</a><span>|</span><a href="#41908709">next</a><span>|</span><label class="collapse" for="c-41932486">[-]</label><label class="expand" for="c-41932486">[4 more]</label></div><br/><div class="children"><div class="content">I like your post.  There is a long YouTube video of a dev doing a long breakdown about why FP &quot;lost&quot; to OOP.  In reality, it didn&#x27;t lose...or rather, it won by using the backdoor.  OOP integrated many FP features into their own languages.  As a result, you can do lots of FPish coding in modern OOP languages.</div><br/><div id="41932766" class="c"><input type="checkbox" id="c-41932766" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932486">parent</a><span>|</span><a href="#41908709">next</a><span>|</span><label class="collapse" for="c-41932766">[-]</label><label class="expand" for="c-41932766">[3 more]</label></div><br/><div class="children"><div class="content">How on Earth did FP &quot;lose&quot;? Most systems I work on these days use TypeScript, it&#x27;s taken over huge parts of the industry, and OOP in TS is like an after thought that most people forget is even there at all. All the TS codebases I work on are 99% functional, with most JS&#x2F;TS devs leaning into it more rather than less.</div><br/><div id="41932964" class="c"><input type="checkbox" id="c-41932964" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932766">parent</a><span>|</span><a href="#41908709">next</a><span>|</span><label class="collapse" for="c-41932964">[-]</label><label class="expand" for="c-41932964">[2 more]</label></div><br/><div class="children"><div class="content">Excel is still arguably the world’s most popular programming language. And excel is much more functional than imperative.</div><br/><div id="41933182" class="c"><input type="checkbox" id="c-41933182" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41932964">parent</a><span>|</span><a href="#41908709">next</a><span>|</span><label class="collapse" for="c-41933182">[-]</label><label class="expand" for="c-41933182">[1 more]</label></div><br/><div class="children"><div class="content">But VBA is OOP&#x2F;imperative.  And most Excel apps that I know use a combination of FP in the sheet, and OOP&#x2F;imperative in the VBA.</div><br/></div></div></div></div></div></div></div></div><div id="41908709" class="c"><input type="checkbox" id="c-41908709" checked=""/><div class="controls bullet"><span class="by">librasteve</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41932486">prev</a><span>|</span><a href="#41904242">next</a><span>|</span><label class="collapse" for="c-41908709">[-]</label><label class="expand" for="c-41908709">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;raku.org" rel="nofollow">https:&#x2F;&#x2F;raku.org</a> is a great language if you want all the paradigms in a smooth way</div><br/><div id="41910894" class="c"><input type="checkbox" id="c-41910894" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41908709">parent</a><span>|</span><a href="#41904242">next</a><span>|</span><label class="collapse" for="c-41910894">[-]</label><label class="expand" for="c-41910894">[3 more]</label></div><br/><div class="children"><div class="content">How is Perl 6&#x2F;Rakudo coming along these days?<p>I mean in terms of overall spec compliance and production use cases.<p>Im guessing larger adoption would still be low unless Rakudo can run CPAN modules as is.</div><br/><div id="41912652" class="c"><input type="checkbox" id="c-41912652" checked=""/><div class="controls bullet"><span class="by">librasteve</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41910894">parent</a><span>|</span><a href="#41904242">next</a><span>|</span><label class="collapse" for="c-41912652">[-]</label><label class="expand" for="c-41912652">[2 more]</label></div><br/><div class="children"><div class="content">Raku has a healthy and stable community that is making steady progress in developing the language. Joint us on IRC or Discord (see <a href="https:&#x2F;&#x2F;raku.org" rel="nofollow">https:&#x2F;&#x2F;raku.org</a> for details) to get a feel for the activity level. For me it is an opportunity to hang out wiht very deep knowledgable compiler core folk and I have learned tons.<p>The big effort going into v.6.e (ie the 5th major release of Perl6 == 6.e) is Raku AST which is now in PREVIEW and is a big boost for writing Slangs (Raku sub languages) since you can now use the built in Grammar parsing to generate AST code - and is the precursor to macros and improved JIT optimisation.<p>The Raku spec is actually the ROAST test suite <a href="https:&#x2F;&#x2F;github.com&#x2F;Raku&#x2F;roast">https:&#x2F;&#x2F;github.com&#x2F;Raku&#x2F;roast</a> and Raku has been compliant to this since 6.c which was the first production release.<p>Raku can run Perl5 CPAN modules (Inline::Perl5) and Python modules (Inline::Python) out of the box and it has deep FFI C NativeCall facilities. There are also a couple of Raku + Rust exemplars such as Dan::Polars (note: I am the author).<p>Raku also has some very nice modules - Red is an ORM that leverages traits to make OO&#x2F;ORM seamless, Cro is a web server framework that uses concurrent features such as Supplies to enable pluggable middleware (think WebSockets).<p>As to larger adoption, I would say that this is still slow - there are some reputational concerns around the Perl to Raku transition and some points have been made about slow execution speed (although I would say that Raku is no slower than Python &#x2F; Ruby were at this point in the development curve and of course there is no GIL limitation and many built in features for multi core such as hypers).<p>At the moment, I would say the &quot;killer app&quot; for Raku is the use of Grammars in conjunction with LLMs (language meets language) - take a look at the work of antononcube for some great use cases... <a href="https:&#x2F;&#x2F;raku.land&#x2F;zef:antononcube&#x2F;LLM::Functions" rel="nofollow">https:&#x2F;&#x2F;raku.land&#x2F;zef:antononcube&#x2F;LLM::Functions</a></div><br/><div id="41932736" class="c"><input type="checkbox" id="c-41932736" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#41904146">root</a><span>|</span><a href="#41912652">parent</a><span>|</span><a href="#41904242">next</a><span>|</span><label class="collapse" for="c-41932736">[-]</label><label class="expand" for="c-41932736">[1 more]</label></div><br/><div class="children"><div class="content">For those interested in the last remark and unfamiliar with grammars: <a href="https:&#x2F;&#x2F;docs.raku.org&#x2F;language&#x2F;grammars" rel="nofollow">https:&#x2F;&#x2F;docs.raku.org&#x2F;language&#x2F;grammars</a></div><br/></div></div></div></div></div></div></div></div><div id="41904242" class="c"><input type="checkbox" id="c-41904242" checked=""/><div class="controls bullet"><span class="by">pseudonamed</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41908709">prev</a><span>|</span><a href="#41932270">next</a><span>|</span><label class="collapse" for="c-41904242">[-]</label><label class="expand" for="c-41904242">[1 more]</label></div><br/><div class="children"><div class="content">The middle of the road option in a language like Clojure is almost always functional with a small amount of mutable state.<p>Programming styles are just that, style; Language =&#x2F;= style.</div><br/></div></div><div id="41932270" class="c"><input type="checkbox" id="c-41932270" checked=""/><div class="controls bullet"><span class="by">Nathanael_M</span><span>|</span><a href="#41904146">parent</a><span>|</span><a href="#41904242">prev</a><span>|</span><a href="#41904055">next</a><span>|</span><label class="collapse" for="c-41932270">[-]</label><label class="expand" for="c-41932270">[1 more]</label></div><br/><div class="children"><div class="content">Would you have any advice or resources for learning paradigms and practical paradigm usage?</div><br/></div></div></div></div><div id="41904055" class="c"><input type="checkbox" id="c-41904055" checked=""/><div class="controls bullet"><span class="by">kerand</span><span>|</span><a href="#41904146">prev</a><span>|</span><a href="#41904144">next</a><span>|</span><label class="collapse" for="c-41904055">[-]</label><label class="expand" for="c-41904055">[9 more]</label></div><br/><div class="children"><div class="content">The GoF book did a lot of damage. I&#x27;ve finally read it and was amazed that the entire book is in fact about writing GUIs, which is just one tiny part of programming.<p>Several patterns are trivial, others are very similar and are just a linked list of objects that are searched for performing some action.<p>The composition over inheritance meme in the book does not make things easier (there is no &quot;composition&quot; going on anyway, it is just delegation).<p>Objects themselves for resource cleanup like RAII are fine of course.</div><br/><div id="41904111" class="c"><input type="checkbox" id="c-41904111" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#41904055">parent</a><span>|</span><a href="#41904407">next</a><span>|</span><label class="collapse" for="c-41904111">[-]</label><label class="expand" for="c-41904111">[1 more]</label></div><br/><div class="children"><div class="content">Some people will say that the book is not a training guide but a naming guide for patterns (or antipatterns) people already were using with success.</div><br/></div></div><div id="41904407" class="c"><input type="checkbox" id="c-41904407" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#41904055">parent</a><span>|</span><a href="#41904111">prev</a><span>|</span><a href="#41904774">next</a><span>|</span><label class="collapse" for="c-41904407">[-]</label><label class="expand" for="c-41904407">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, OOP became 10 times worse after the GoF book. People started to see these patterns everywhere, and mutated fine looking code to conform to that expectation. Just compare Java classes and interfaces when the language was created (most of that based on previous experience with Smalltalk) and the hot mess that was invented after GoF was released.</div><br/></div></div><div id="41904774" class="c"><input type="checkbox" id="c-41904774" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41904055">parent</a><span>|</span><a href="#41904407">prev</a><span>|</span><a href="#41904144">next</a><span>|</span><label class="collapse" for="c-41904774">[-]</label><label class="expand" for="c-41904774">[6 more]</label></div><br/><div class="children"><div class="content">OOP is entirely about writing GUIs. (Well, the C++ idea of OOP.)<p>It&#x27;s a much larger part of programing than most people give credit, but yeah, it&#x27;s only a part.<p>Anyway, the GoF book is about getting good abstractions from the 90s limitations in OOP languages. Nobody should read them now, except for historical reference.</div><br/><div id="41905724" class="c"><input type="checkbox" id="c-41905724" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41904055">root</a><span>|</span><a href="#41904774">parent</a><span>|</span><a href="#41904144">next</a><span>|</span><label class="collapse" for="c-41905724">[-]</label><label class="expand" for="c-41905724">[5 more]</label></div><br/><div class="children"><div class="content">&gt; OOP is entirely about writing GUIs. (Well, the C++ idea of OOP.)<p>Nope.<p>One thing I like to do in C++ is, on an embedded system, wrap an object around a hardware resource.  It means that no other code needs to know about the details of talking to that hardware.  Also, if there are multithreading concerns, it leaves a very small set of places to worry about mutexes.</div><br/><div id="41906095" class="c"><input type="checkbox" id="c-41906095" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41904055">root</a><span>|</span><a href="#41905724">parent</a><span>|</span><a href="#41904144">next</a><span>|</span><label class="collapse" for="c-41906095">[-]</label><label class="expand" for="c-41906095">[4 more]</label></div><br/><div class="children"><div class="content">Ok, so you like to use OOP to emulate a module system.<p>Yeah, plenty of people like that too. That doesn&#x27;t make it an application for OOP. The fact that the 90s killed the modular languages is quite a bummer, as neither modern FP nor C++ style OOP have anything nearly as useful.</div><br/><div id="41906252" class="c"><input type="checkbox" id="c-41906252" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41904055">root</a><span>|</span><a href="#41906095">parent</a><span>|</span><a href="#41904144">next</a><span>|</span><label class="collapse" for="c-41906252">[-]</label><label class="expand" for="c-41906252">[3 more]</label></div><br/><div class="children"><div class="content">Shallow dismissals aside, do you have anything of substance to say?  I&#x27;d especially like to see your justification for saying &quot;That doesn&#x27;t make it an application for OOP&quot;.</div><br/><div id="41907846" class="c"><input type="checkbox" id="c-41907846" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41904055">root</a><span>|</span><a href="#41906252">parent</a><span>|</span><a href="#41904144">next</a><span>|</span><label class="collapse" for="c-41907846">[-]</label><label class="expand" for="c-41907846">[2 more]</label></div><br/><div class="children"><div class="content">FP languages will give you the exact same abstraction (not that you&#x27;d want to use any on a device driver). And before OOP was hyped and pushed everywhere, you could already get the same thing, but better (not on C, of course).<p>The fact that you need objects to get this on your current language is a bug, not a feature.<p>(There is the one version of OOP that most people call &quot;multi-agent systems&quot; that would bring very good abstractions to a driver, but it&#x27;s not C++&#x27;s OOP, and you&#x27;d need a heavyweight library to get it there.)</div><br/><div id="41933368" class="c"><input type="checkbox" id="c-41933368" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41904055">root</a><span>|</span><a href="#41907846">parent</a><span>|</span><a href="#41904144">next</a><span>|</span><label class="collapse" for="c-41933368">[-]</label><label class="expand" for="c-41933368">[1 more]</label></div><br/><div class="children"><div class="content">What modular languages with &quot;multi-agent systems&quot; are you talking about? Please give some examples. The only domain where I saw &quot;multi-agent systems&quot; paradigm being used is AI, not programming languages.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41904144" class="c"><input type="checkbox" id="c-41904144" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41904055">prev</a><span>|</span><a href="#41933550">next</a><span>|</span><label class="collapse" for="c-41904144">[-]</label><label class="expand" for="c-41904144">[2 more]</label></div><br/><div class="children"><div class="content">This article describes the OOP approach of changing, say, a Logger to an abstract class with a default implementation, without needing to modify code that uses it, and also describes this as something that could be done in C++.  But this doesn’t work at all in C++ if there is ever a Logger on the stack!<p><pre><code>    Logger l;
</code></pre>
That’s a Logger, and it will not magically become a subclass.<p>And changing this to go through pointers everywhere and to use virtual functions, <i>in C++</i>, is not very performant. A good JIT compiler may be able to effectively devirtualize it, but C++ compilers are unlikely to be able to do this effectively.</div><br/><div id="41932209" class="c"><input type="checkbox" id="c-41932209" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41904144">parent</a><span>|</span><a href="#41933550">next</a><span>|</span><label class="collapse" for="c-41932209">[-]</label><label class="expand" for="c-41932209">[1 more]</label></div><br/><div class="children"><div class="content">In the case of a Logger, though, it is likely passed around by reference or pointer. So users of the Logger (reference&#x2F;pointer) do not have to change if its definition changes to that of an interface.<p>The &quot;Server&quot; class, or whatever instantiates the Logger, will have to change, but that might not be such a big deal.<p>So yes, the author was wrong about not having to modify any code, but likely you won&#x27;t have to modify most code.</div><br/></div></div></div></div><div id="41933550" class="c"><input type="checkbox" id="c-41933550" checked=""/><div class="controls bullet"><span class="by">ryandv</span><span>|</span><a href="#41904144">prev</a><span>|</span><a href="#41933341">next</a><span>|</span><label class="collapse" for="c-41933550">[-]</label><label class="expand" for="c-41933550">[1 more]</label></div><br/><div class="children"><div class="content">I find this article difficult to understand because it almost seems as if the characterization of FP-style approaches to the problem of multiple polymorphic logger implementations is a strawman, or otherwise not idiomatic or awkwardly designed. If Haskell is indeed unergonomic for the purpose of being polymorphic in the types of logger implementations that can be supplied, it would seem that it would also be unergonomic for the purpose of being polymorphic in the types of exception&#x2F;error handling implementations that can be supplied.<p>But... it&#x27;s not? See `catchE` [0] from Control.Monad.Trans.Except:<p><pre><code>    catchE :: Monad m =&gt; ExceptT e m a -&gt; (e -&gt; ExceptT e&#x27; m a) -&gt; ExceptT e&#x27; m a
</code></pre>
... where the callsite-provided exception handler is the second parameter to the function, which can do basically anything (especially if the monad m is MonadIO). Hardly unergonomic or overcomplicated in my view, and no effects algebras or even type declarations in sight.<p>[0] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;transformers-0.6.1.2&#x2F;docs&#x2F;Control-Monad-Trans-Except.html#v:catchE" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;transformers-0.6.1.2&#x2F;doc...</a></div><br/></div></div><div id="41933341" class="c"><input type="checkbox" id="c-41933341" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41933550">prev</a><span>|</span><a href="#41933398">next</a><span>|</span><label class="collapse" for="c-41933341">[-]</label><label class="expand" for="c-41933341">[1 more]</label></div><br/><div class="children"><div class="content">Eric Lippert, one of the designers of C# language, wrote a series of articles about object oriented design problems.<p>Here&#x27;s the first article in the series: <a href="https:&#x2F;&#x2F;ericlippert.com&#x2F;2015&#x2F;04&#x2F;27&#x2F;wizards-and-warriors-part-one&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ericlippert.com&#x2F;2015&#x2F;04&#x2F;27&#x2F;wizards-and-warriors-part...</a></div><br/></div></div><div id="41933398" class="c"><input type="checkbox" id="c-41933398" checked=""/><div class="controls bullet"><span class="by">jy14898</span><span>|</span><a href="#41933341">prev</a><span>|</span><a href="#41933540">next</a><span>|</span><label class="collapse" for="c-41933398">[-]</label><label class="expand" for="c-41933398">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However, unlike our OOP example, existing code that uses the Logger type and log function cannot work with this new type. There needs to be some refactoring, and how the user code will need to be refactored depends on how we want to expose this new type to the users.<p>This is odd to me. There are solutions to make data types extensible in haskell, but for example in purescript you&#x27;d just use a record. But more importantly, why would you want existing functions to use the new type? Why not just pass the _logger from FileLogger in? The existing functions can&#x27;t use the _flush ability anyway (in both OOP and FP cases)</div><br/></div></div><div id="41904026" class="c"><input type="checkbox" id="c-41904026" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41933540">prev</a><span>|</span><a href="#41904324">next</a><span>|</span><label class="collapse" for="c-41904026">[-]</label><label class="expand" for="c-41904026">[9 more]</label></div><br/><div class="children"><div class="content">In moderation, yes. The problem with OOP, like all other paradigms that came before, is applying it dogmatically and excessively, which always happens when there&#x27;s a lot of hype, novelty, and $$$ to be made.</div><br/><div id="41904181" class="c"><input type="checkbox" id="c-41904181" checked=""/><div class="controls bullet"><span class="by">hk1337</span><span>|</span><a href="#41904026">parent</a><span>|</span><a href="#41904396">next</a><span>|</span><label class="collapse" for="c-41904181">[-]</label><label class="expand" for="c-41904181">[1 more]</label></div><br/><div class="children"><div class="content">I agree but &quot;moderation&quot; isn&#x27;t the best word. OOP is good when used appropriately and not when you fixate that everything has to be within the OOP structure.<p>It&#x27;s the same thing with languages, IMO. People try to shoehorn tasks into a language when it would be better off in another language.</div><br/></div></div><div id="41904396" class="c"><input type="checkbox" id="c-41904396" checked=""/><div class="controls bullet"><span class="by">faizshah</span><span>|</span><a href="#41904026">parent</a><span>|</span><a href="#41904181">prev</a><span>|</span><a href="#41904259">next</a><span>|</span><label class="collapse" for="c-41904396">[-]</label><label class="expand" for="c-41904396">[6 more]</label></div><br/><div class="children"><div class="content">I think bad OOP is still better than bad functional code. Having seen what happens when a React codebase reaches &gt;100k LOC are we really any better off than a class hierarchy?<p>The OOP model fits nicely into most people’s heads because of the analogy to the real world and OOP implementations generally seem to give better signals when you are doing something wrong. Rather than functional implementations which mainly rely on human expert code reviewers and linters to give negative signals instead of say exception hierarchies.<p>A lot of the time you don’t realize your codebase is bad until “it’s just a button how hard can it be” somehow takes 3 months and 4 rollbacks.<p>At least this is what I have observed working on large codebases.</div><br/><div id="41905048" class="c"><input type="checkbox" id="c-41905048" checked=""/><div class="controls bullet"><span class="by">gorjusborg</span><span>|</span><a href="#41904026">root</a><span>|</span><a href="#41904396">parent</a><span>|</span><a href="#41932832">next</a><span>|</span><label class="collapse" for="c-41905048">[-]</label><label class="expand" for="c-41905048">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The OOP model fits nicely into most people’s heads because of the analogy to the real world<p>It also has been the default programing language paradigm for a while now, which I think explains why experienced programmers can cling to it despite its drawbacks. Try to teach object oriented programming to a beginner and it becomes clear that it isn&#x27;t as natural as you are suggesting.<p>&gt; generally seem to give better signals when you are doing something wrong.<p>Better than what? Functional programming is a far simpler abstraction: a function. Data in, data out. That&#x27;s about as simple as it gets. Also, culturally, functional programmers generally understand the downside of distributed state, and actively try to minimize it. That&#x27;s a good thing.<p>Bad code is bad code, but OOP gives you unique weapons to hurt yourself with. Inheritance allows one to change an unbounded number of objects without you even knowing. Modeling everything as a collection of objects with state tends to lead to programs that need to synchronize distributed state rather than a central state that is easier to keep consistent.</div><br/></div></div><div id="41932832" class="c"><input type="checkbox" id="c-41932832" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41904026">root</a><span>|</span><a href="#41904396">parent</a><span>|</span><a href="#41905048">prev</a><span>|</span><a href="#41933406">next</a><span>|</span><label class="collapse" for="c-41932832">[-]</label><label class="expand" for="c-41932832">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Having seen what happens when a React codebase reaches &gt;100k LOC are we really any better off than a class hierarchy?<p>I’m not sure if you correctly understand what functional programming is.<p>Check out Grokking simplicity, great book.</div><br/></div></div><div id="41933406" class="c"><input type="checkbox" id="c-41933406" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41904026">root</a><span>|</span><a href="#41904396">parent</a><span>|</span><a href="#41932832">prev</a><span>|</span><a href="#41904518">next</a><span>|</span><label class="collapse" for="c-41933406">[-]</label><label class="expand" for="c-41933406">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The OOP model fits nicely into most people’s heads because of the analogy to the real world<p>Nothing in real world resembles OOP.</div><br/></div></div><div id="41904518" class="c"><input type="checkbox" id="c-41904518" checked=""/><div class="controls bullet"><span class="by">veidelis</span><span>|</span><a href="#41904026">root</a><span>|</span><a href="#41904396">parent</a><span>|</span><a href="#41933406">prev</a><span>|</span><a href="#41911580">next</a><span>|</span><label class="collapse" for="c-41904518">[-]</label><label class="expand" for="c-41904518">[1 more]</label></div><br/><div class="children"><div class="content">I assume you&#x27;re talking React&#x27;s hooks. That is not functional programming.</div><br/></div></div><div id="41911580" class="c"><input type="checkbox" id="c-41911580" checked=""/><div class="controls bullet"><span class="by">Fire-Dragon-DoL</span><span>|</span><a href="#41904026">root</a><span>|</span><a href="#41904396">parent</a><span>|</span><a href="#41904518">prev</a><span>|</span><a href="#41904259">next</a><span>|</span><label class="collapse" for="c-41911580">[-]</label><label class="expand" for="c-41911580">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because the programming language used is not FP, even if people pretend to.<p>Js is still stateful everywhere, even where you don&#x27;t want it to be</div><br/></div></div></div></div></div></div><div id="41904324" class="c"><input type="checkbox" id="c-41904324" checked=""/><div class="controls bullet"><span class="by">o_nate</span><span>|</span><a href="#41904026">prev</a><span>|</span><a href="#41904426">next</a><span>|</span><label class="collapse" for="c-41904324">[-]</label><label class="expand" for="c-41904324">[2 more]</label></div><br/><div class="children"><div class="content">I think its important to be aware of functional style and the weaknesses of OOP, so you can write OOP code that avoids the worst pitfalls. Classes still remain a nice way to organize code, but you should try to make them immutable if you can.</div><br/><div id="41933457" class="c"><input type="checkbox" id="c-41933457" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41904324">parent</a><span>|</span><a href="#41904426">next</a><span>|</span><label class="collapse" for="c-41933457">[-]</label><label class="expand" for="c-41933457">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Classes still remain a nice way to organize code<p>Using classes as code containers doesn&#x27;t make your code OOP. I use C# which demands most code being put inside classes, but my code isn&#x27;t OOP because I seldom use inheritance, encapsulation or method overriding.</div><br/></div></div></div></div><div id="41904426" class="c"><input type="checkbox" id="c-41904426" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#41904324">prev</a><span>|</span><a href="#41904231">next</a><span>|</span><label class="collapse" for="c-41904426">[-]</label><label class="expand" for="c-41904426">[13 more]</label></div><br/><div class="children"><div class="content">OOP is not fundamentally bad or good. But I had some first-hand experience about how it&#x27;s taught &quot;wrong&quot;.<p>The following might sound ridiculous, but I swear I&#x27;m not making them up:<p>- In my highschool, students on their &quot;Computer &amp; Information 101&quot; class were asked to answer what polymorphism is. Most of the said students had zero programming experienece at the time.<p>- In my sophomore year (CS major), students were asked to finish a mini game &quot;with design patterns&quot; and explain what design patterns they used. For most of the said students, that was the first time they wrote a program with more than 300 LoC. Before that, all the assignments they had seen are &quot;leetcode-like&quot;, like implementing Sieve of Eratosthenes in C.</div><br/><div id="41904818" class="c"><input type="checkbox" id="c-41904818" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41904426">parent</a><span>|</span><a href="#41908864">next</a><span>|</span><label class="collapse" for="c-41904818">[-]</label><label class="expand" for="c-41904818">[10 more]</label></div><br/><div class="children"><div class="content">Yes. OOP pedagogy is completely messed up.<p>First, examples are often unpractical and divorced from reality. The canonical meme examples of “Dog and Cat inherit from Animal” or “Car inherits from Vehicle” are not really applicable to Veterinary Clinic Software or Self Driving Cars. People use those kinds of examples to say that OOP is good at modeling reality, but business software is 90% of the time better served by a different level of abstraction.<p>Second, a lot of descriptive information is passed as prescriptive. Patterns are a good example of how shoehorning concepts in a piece of software without having the knowledge to come up with it by yourself can make it worse, and yet teachers spend whole semesters dedicated to it.<p>Third, inheritance is still being taught as a fundamental part of OOP from the beginning in every curriculum I have seen, only to have pretty much everyone else saying “prefer composition” down the line, after the damage is already done.</div><br/><div id="41932884" class="c"><input type="checkbox" id="c-41932884" checked=""/><div class="controls bullet"><span class="by">simulo</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41904818">parent</a><span>|</span><a href="#41908237">next</a><span>|</span><label class="collapse" for="c-41932884">[-]</label><label class="expand" for="c-41932884">[1 more]</label></div><br/><div class="children"><div class="content">These examples (dogs,cars...) are badly used in most programming books, but they can make sense if you show them in context of a small game or whatever else actually draws you an (inter) active virtual car or animal (which made OOP click for me, using processing). Printing &quot;meow&quot; and &quot;woof&quot; in the terminal, however, only makes sense as a demonstration if you already know what it should demonstrate.</div><br/></div></div><div id="41908237" class="c"><input type="checkbox" id="c-41908237" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41904818">parent</a><span>|</span><a href="#41932884">prev</a><span>|</span><a href="#41905224">next</a><span>|</span><label class="collapse" for="c-41908237">[-]</label><label class="expand" for="c-41908237">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty good at modelling reality and such hierarchies are useful. Look at the code of software that models reality:<p><a href="https:&#x2F;&#x2F;dev.epicgames.com&#x2F;documentation&#x2F;en-us&#x2F;unreal-engine&#x2F;API&#x2F;Runtime&#x2F;Engine&#x2F;GameFramework&#x2F;ASpectatorPawn" rel="nofollow">https:&#x2F;&#x2F;dev.epicgames.com&#x2F;documentation&#x2F;en-us&#x2F;unreal-engine&#x2F;...</a><p>The reason we don&#x27;t tend to see such hierarchies used in clinic software is that RDBMS engines aren&#x27;t OOP and don&#x27;t model inheritance hierarchies well.<p>Self driving cars are big piles of C++ so probably have plenty of OOP, albeit given the ML bent probably more for dealing with UI and sensors than modelling the nearby landscape.<p>Inheritance is taught because most real OOP codebases use it extensively and it works OK. If you don&#x27;t understand inheritance you can&#x27;t understand the standard libraries of most OO languages, most UI toolkits etc.</div><br/><div id="41913111" class="c"><input type="checkbox" id="c-41913111" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41908237">parent</a><span>|</span><a href="#41905224">next</a><span>|</span><label class="collapse" for="c-41913111">[-]</label><label class="expand" for="c-41913111">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that this is an artifact of history at this point. This was the popular style when unreal was made, and that&#x27;s why it&#x27;s there. Since Unreal is an old piece of software that powers older games, this code won&#x27;t get removed. Because of compatibility.<p>The industry (and this includes Unreal, albeit slowly) has been moving to runtime composition for a reason: it is simpler and more flexible. And much better at modeling reality.<p>Your last paragraph pretty much sums it up: the main reason at this point for teaching implementation inheritance is because of legacy code bases. It can be a valid technique (I personally enjoy the Template Method Pattern, although it is today a maligned pattern) but it does causes more problems than it solves.</div><br/><div id="41914902" class="c"><input type="checkbox" id="c-41914902" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41913111">parent</a><span>|</span><a href="#41905224">next</a><span>|</span><label class="collapse" for="c-41914902">[-]</label><label class="expand" for="c-41914902">[3 more]</label></div><br/><div class="children"><div class="content">Heh, there&#x27;s nothing legacy about Unreal. It&#x27;s the premier game engine in the world today and actively maintained by hundreds of developers. They&#x27;re now pushing into film and do new releases regularly, often breaking backwards compatibility when they do. Where is this move away from OOP and inheritance? Even newly developed features like Nanite use it:<p><a href="https:&#x2F;&#x2F;dev.epicgames.com&#x2F;documentation&#x2F;en-us&#x2F;unreal-engine&#x2F;API&#x2F;Runtime&#x2F;Landscape&#x2F;ULandscapeNaniteComponent" rel="nofollow">https:&#x2F;&#x2F;dev.epicgames.com&#x2F;documentation&#x2F;en-us&#x2F;unreal-engine&#x2F;...</a><p>But more importantly, is this take falsifiable? What does &quot;old&quot; or &quot;legacy&quot; mean? People have been pushing this line for at least 15 years here on HN, yet what we see in the most well funded and actively maintained codebases is lots and lots of inheritance, with no efforts to remove it. Not just Unreal but also Chrome, MS Office, iOS, Android, Java, and more, all use this technique with no ill effects as far as anyone can tell. When the maintainers talk about what issues they face and are putting refactoring efforts into, inheritance or OOP never seem to be on the list. In the Java case it&#x27;s actually the opposite, they like to complain about people violating OOP encapsulation and want to make enforcement stricter. Meanwhile heavily hyped successors that lacked it, like Haskell, have vanished without a trace, leaving not even one widely used program in their wake.<p>What would it take to falsify the claim that inheritance is a legacy technique? Because I see no real evidence of it. Every codebase I&#x27;ve worked on has used it without anyone remarking on that fact, and it didn&#x27;t seem to cause issues more often than other design patterns.</div><br/><div id="41933053" class="c"><input type="checkbox" id="c-41933053" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41914902">parent</a><span>|</span><a href="#41919305">next</a><span>|</span><label class="collapse" for="c-41933053">[-]</label><label class="expand" for="c-41933053">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Meanwhile heavily hyped successors that lacked it, like Haskell, have vanished without a trace, leaving not even one widely used program in their wake.<p>Do you think that inheritance had something to do with that?</div><br/></div></div><div id="41919305" class="c"><input type="checkbox" id="c-41919305" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41914902">parent</a><span>|</span><a href="#41933053">prev</a><span>|</span><a href="#41905224">next</a><span>|</span><label class="collapse" for="c-41919305">[-]</label><label class="expand" for="c-41919305">[1 more]</label></div><br/><div class="children"><div class="content">A programming style isn&#x27;t automatically &quot;good&quot; just because it&#x27;s financially and technically unfeasible to migrate to something else overnight.<p>The reason Unreal uses inheritance is because this is what people did in 1998. The reason it can&#x27;t stop using is because it&#x27;s too late to change. There&#x27;s nothing more to it.</div><br/></div></div></div></div></div></div></div></div><div id="41905224" class="c"><input type="checkbox" id="c-41905224" checked=""/><div class="controls bullet"><span class="by">superxpro12</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41904818">parent</a><span>|</span><a href="#41908237">prev</a><span>|</span><a href="#41908864">next</a><span>|</span><label class="collapse" for="c-41905224">[-]</label><label class="expand" for="c-41905224">[3 more]</label></div><br/><div class="children"><div class="content">I feel like if these classes focused on where objects can shine, like with dependency injection, we&#x27;d feel alot different about things. But instead we focus on modelling the problem, without demonstrating how to solve practical issues, and now we&#x27;re left with this tool that noones knows how to use much beyond a CS203 exam.</div><br/><div id="41933517" class="c"><input type="checkbox" id="c-41933517" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41905224">parent</a><span>|</span><a href="#41906430">next</a><span>|</span><label class="collapse" for="c-41933517">[-]</label><label class="expand" for="c-41933517">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I feel like if these classes focused on where objects can shine, like with dependency injection<p>Dependency injection is not OOP. When used in an OOP context, it just solves an issue created by OOP. In an OOP context you can&#x27;t call code from another object unless you have a reference to it. So you either instantiate the object or use DI to supply an object reference so you can call a method.<p>In contrast to that, if you have functions as first class citizens or your code resides in a static class, you seldom need DI because you can call the function or method from wherever you need.</div><br/></div></div><div id="41906430" class="c"><input type="checkbox" id="c-41906430" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41904426">root</a><span>|</span><a href="#41905224">parent</a><span>|</span><a href="#41933517">prev</a><span>|</span><a href="#41908864">next</a><span>|</span><label class="collapse" for="c-41906430">[-]</label><label class="expand" for="c-41906430">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Dependency injection, interfaces, runtime composition, passing objects&#x2F;lambdas for configuration&#x2F;changing behavior (Strategy pattern).<p>Plus teaching proper separation of concerns rather than the &quot;one line per method&quot; from Clean Code.<p>All this would lead to better software than the &quot;Dog inherits from Cat&quot; bs.</div><br/></div></div></div></div></div></div><div id="41908864" class="c"><input type="checkbox" id="c-41908864" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#41904426">parent</a><span>|</span><a href="#41904818">prev</a><span>|</span><a href="#41908154">next</a><span>|</span><label class="collapse" for="c-41908864">[-]</label><label class="expand" for="c-41908864">[1 more]</label></div><br/><div class="children"><div class="content">You had bad teachers which says nothing about the paradigm or how it&#x27;s taught generally.<p>When I did my CS classes (at the beginning of the &#x27;OOP will solve all the problems&#x27; era), we had excellent introductions to encapsulation and polymorphism and the rest with detailed examples in (early, cfront) C++ and Modula-2 &amp; Ada.  But then we had FP with SML &amp; Hope and a couple of others that were poorly taught and most of us thought &quot;this functional stuff is awful&quot;.  YMMV.</div><br/></div></div><div id="41908154" class="c"><input type="checkbox" id="c-41908154" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41904426">parent</a><span>|</span><a href="#41908864">prev</a><span>|</span><a href="#41904231">next</a><span>|</span><label class="collapse" for="c-41908154">[-]</label><label class="expand" for="c-41908154">[1 more]</label></div><br/><div class="children"><div class="content">The first isn&#x27;t necessarily related to OOP. My first CS class at university gave everyone a programming quiz, in the very first lecture. The goal was to identify self-taught students so they could be made to help others in group work.</div><br/></div></div></div></div><div id="41904231" class="c"><input type="checkbox" id="c-41904231" checked=""/><div class="controls bullet"><span class="by">carapace</span><span>|</span><a href="#41904426">prev</a><span>|</span><a href="#41905070">next</a><span>|</span><label class="collapse" for="c-41904231">[-]</label><label class="expand" for="c-41904231">[3 more]</label></div><br/><div class="children"><div class="content">I sure am glad that, when I was twelve and learning Pascal at middle school, my teacher took pains to point out that OOP is just a way of arranging code, it doesn&#x27;t change the code semantically, it&#x27;s just topological.  You avoid a lot of noise and nonsense if you just keep that simple idea in mind: OOP is a style of arrangement, not semantics.<p>It&#x27;s especially odd to compare and contrast OOP style with Functional Programming paradigm because these things are orthogonal.</div><br/><div id="41904446" class="c"><input type="checkbox" id="c-41904446" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#41904231">parent</a><span>|</span><a href="#41905070">next</a><span>|</span><label class="collapse" for="c-41904446">[-]</label><label class="expand" for="c-41904446">[2 more]</label></div><br/><div class="children"><div class="content">My view of OOP is that is a way for people to replicate in code the experience of &quot;bullet lists&quot;. In other words, create a hierarchy by a particular method of code engineering that conforms to traditional techniques that many people (specially in management) already use. The disadvantages come exactly from the fact that not everything in math, science and engineering can be easily modeled using bullet lists.</div><br/><div id="41905638" class="c"><input type="checkbox" id="c-41905638" checked=""/><div class="controls bullet"><span class="by">graypegg</span><span>|</span><a href="#41904231">root</a><span>|</span><a href="#41904446">parent</a><span>|</span><a href="#41905070">next</a><span>|</span><label class="collapse" for="c-41905638">[-]</label><label class="expand" for="c-41905638">[1 more]</label></div><br/><div class="children"><div class="content">I think that might come from OOP&#x27;s middle-era in xtreme-programming and early agile. A lot of focus on mapping user stories to classes&#x2F;CRC diagrams, which eventually get mapped to some specific file&#x2F;bytes on disk. Pretty explicitly modelling the code after bullet lists of messages that need to be passed around.<p><a href="http:&#x2F;&#x2F;www.agile-process.org&#x2F;model.html" rel="nofollow">http:&#x2F;&#x2F;www.agile-process.org&#x2F;model.html</a><p><a href="https:&#x2F;&#x2F;agilemodeling.com&#x2F;artifacts&#x2F;crcmodel.htm" rel="nofollow">https:&#x2F;&#x2F;agilemodeling.com&#x2F;artifacts&#x2F;crcmodel.htm</a></div><br/></div></div></div></div></div></div><div id="41905070" class="c"><input type="checkbox" id="c-41905070" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#41904231">prev</a><span>|</span><a href="#41933348">next</a><span>|</span><label class="collapse" for="c-41905070">[-]</label><label class="expand" for="c-41905070">[1 more]</label></div><br/><div class="children"><div class="content">The post&#x27;s conclusion looks like the author has an axe to grind:<p>&gt; I think it would be beneficial for the functional programming community to stop dismissing OOP’s successes in the industry as an accident of history and try to understand what OOP does well.<p>But the author has spent enough time in the haskell ecosystem, and probably has some cause for this statement. I would personally have liked to hear more about that cause, and the perceived issues in the community, rather than code examples.</div><br/></div></div><div id="41933348" class="c"><input type="checkbox" id="c-41933348" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#41905070">prev</a><span>|</span><a href="#41933390">next</a><span>|</span><label class="collapse" for="c-41933348">[-]</label><label class="expand" for="c-41933348">[1 more]</label></div><br/><div class="children"><div class="content">Meanwhile us procedural folk think you&#x27;re all silly.</div><br/></div></div><div id="41933390" class="c"><input type="checkbox" id="c-41933390" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41933348">prev</a><span>|</span><a href="#41904353">next</a><span>|</span><label class="collapse" for="c-41933390">[-]</label><label class="expand" for="c-41933390">[1 more]</label></div><br/><div class="children"><div class="content">GoF patterns, Martin Fowler books and Uncle Bob books had the same impact to programming as the invention of null.</div><br/></div></div><div id="41904353" class="c"><input type="checkbox" id="c-41904353" checked=""/><div class="controls bullet"><span class="by">kwar13</span><span>|</span><a href="#41933390">prev</a><span>|</span><a href="#41903821">next</a><span>|</span><label class="collapse" for="c-41904353">[-]</label><label class="expand" for="c-41904353">[1 more]</label></div><br/><div class="children"><div class="content">Going from C++ to Rust, I now really love how Rust implements &quot;OOP&quot;. I highly suggest reading this chapter even if you don&#x27;t care about Rust.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch17-00-oop.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch17-00-oop.html</a></div><br/></div></div><div id="41903821" class="c"><input type="checkbox" id="c-41903821" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#41904353">prev</a><span>|</span><a href="#41904019">next</a><span>|</span><label class="collapse" for="c-41903821">[-]</label><label class="expand" for="c-41903821">[59 more]</label></div><br/><div class="children"><div class="content">I changed my mine on this.  I did OOP since the mid-1990s when I learned it in high school up until about 10 years ago.  I find OOP works best when you have a single coder who can store the model of the system in this mind and work out how to design the base and abstract classes well.  And they also have freedom to refactor THE WHOLE CODEBASE when they get it wrong (probably multiple times.)  Then you can make these webs of elegant ontologies work.<p>But in real life, when there is a team, you run into the fragile base class [1] constantly and changing that base class causes horrible issues across your code base.<p>I have found that OOP with inheritance is actually a form of tight coupling and that it is best to not use class hierarchies.<p>I agree with encapsulation and modularity and well defined interfaces (typed function signatures are amazing.)  I just completely disagree with inheritance in all forms.<p>There are no benefits to it (besides feeling smart because you&#x27;ve made an elegant but ultimately brittle ontology of objects and methods), just a ton of downsides.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragile_base_class#:~:text=The%20fragile%20base%20class%20problem,the%20derived%20classes%20to%20malfunction" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragile_base_class#:~:text=The...</a>.</div><br/><div id="41933582" class="c"><input type="checkbox" id="c-41933582" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41904206">next</a><span>|</span><label class="collapse" for="c-41933582">[-]</label><label class="expand" for="c-41933582">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But in real life, when there is a team, you run into the fragile base class [1] constantly and changing that base class causes horrible issues across your code base.<p>And then you start writing unit tests for everything and wait 10 hours for building and deployment. Or you can&#x27;t fix a bug without creating other 10 new bugs, which is a good thing because your employer will need you to solve that 10 new bugs.</div><br/></div></div><div id="41904206" class="c"><input type="checkbox" id="c-41904206" checked=""/><div class="controls bullet"><span class="by">ravenstine</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41933582">prev</a><span>|</span><a href="#41904031">next</a><span>|</span><label class="collapse" for="c-41904206">[-]</label><label class="expand" for="c-41904206">[5 more]</label></div><br/><div class="children"><div class="content">I totally agree that class hierarchies are mostly a trap, especially when there&#x27;s more than one developer on a project.<p>What I don&#x27;t understand is why many programmers still use classes even when they plan on avoiding inheritance.  I&#x27;ve seen this sort of thing on the past few major projects I&#x27;ve been involved with; initial creators heavily relied on inheritance, future developers realize that was a mistake, then said future developers continue using the class construct of whatever given language.<p>At that point, why not just use functions and regular objects?  Without inheritance, classes tend to have these other rules and complications that don&#x27;t seem to really add anything when there is no hierarchy.</div><br/><div id="41905560" class="c"><input type="checkbox" id="c-41905560" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904206">parent</a><span>|</span><a href="#41904247">next</a><span>|</span><label class="collapse" for="c-41905560">[-]</label><label class="expand" for="c-41905560">[3 more]</label></div><br/><div class="children"><div class="content">OO was created for a reason.<p>Before OO, you had these data structures, and they got passed around between functions.  Well-designed data structures were not just a random collection of items - they had a relationship between the elements.  And you kept finding structures that were in an invalid state - the relationship among the elements had been broken.  Well, who did that?  You couldn&#x27;t tell.  It could have been any function anywhere in the code that took the structure.<p>With OO, you could have a very small set of functions that could change the structure.  If the constraints got broken, you had a very small footprint to look at to see how it could have happened.  <i>That</i> was the OO advantage.<p>And this advantage did not go away with multiple programmers.  In fact, it increased.  If you had a class that you &quot;owned&quot;, some other new (or incompetent) programmer could not break your code without changing that class&#x27;s code.  You didn&#x27;t have to rely on everyone else always doing the right thing with your structure.<p>Note that this advantage is orthogonal to inheritance vs. non-inheritance.</div><br/><div id="41933335" class="c"><input type="checkbox" id="c-41933335" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41905560">parent</a><span>|</span><a href="#41906476">next</a><span>|</span><label class="collapse" for="c-41933335">[-]</label><label class="expand" for="c-41933335">[1 more]</label></div><br/><div class="children"><div class="content">Encapsulation is not solely an OOP idea, it&#x27;s also a modular programming thing. That many languages lack proper module support is a whole other matter.<p>But there are many advantages to doing encapsulation through modules over classes, if nothing else being able to have the internal functions organized in different files, and having &quot;internal&quot;&#x2F;&quot;external&quot; functions have the exact same syntax without needing hacks like extension methods.</div><br/></div></div><div id="41906476" class="c"><input type="checkbox" id="c-41906476" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41905560">parent</a><span>|</span><a href="#41933335">prev</a><span>|</span><a href="#41904247">next</a><span>|</span><label class="collapse" for="c-41906476">[-]</label><label class="expand" for="c-41906476">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And you kept finding structures that were in an invalid state - the relationship among the elements had been broken.<p>Which is why functions should have typed arguments and results. :)</div><br/></div></div></div></div><div id="41904247" class="c"><input type="checkbox" id="c-41904247" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904206">parent</a><span>|</span><a href="#41905560">prev</a><span>|</span><a href="#41904031">next</a><span>|</span><label class="collapse" for="c-41904247">[-]</label><label class="expand" for="c-41904247">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At that point, why not just use functions and regular objects? Without inheritance, classes tend to have these other rules and complications that don&#x27;t seem to really add anything when there is no hierarchy.<p>I have done this myself.  In TypeScript I would write a class that supports an interface.  There is no hierarchy, but writing as a class gives it structure, a clear name, you know how to instantiate it, what it supports, private methods, private state, static functions, etc.  So I find that classes still do great encapsulation for mutable objects.</div><br/></div></div></div></div><div id="41904031" class="c"><input type="checkbox" id="c-41904031" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41904206">prev</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41904031">[-]</label><label class="expand" for="c-41904031">[43 more]</label></div><br/><div class="children"><div class="content">&gt; I have found that OOP with inheritance is actually a form of tight coupling and that it is best to not use class hierarchies.<p>Tight coupling is the basis of oop. A method is tied to an instance. Methods cannot be composed with other methods or functions without instantiating state. Methods cannot be moved into other scope.<p>The literal definition of an object is a tightly bound set of methods that cannot ever be used without instantiating state.</div><br/><div id="41904193" class="c"><input type="checkbox" id="c-41904193" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904031">parent</a><span>|</span><a href="#41904150">next</a><span>|</span><label class="collapse" for="c-41904193">[-]</label><label class="expand" for="c-41904193">[3 more]</label></div><br/><div class="children"><div class="content">Coupling behaviors to types is not a problem. Class inheritance and multi-inheritance with their weird taxonomical trees are the problem.<p>There&#x27;s little practical reason to build a family tree of supertypes and subtypes outside of building GUIs, yet this is how class-based OOP is designed and taught.<p>Trait-based OOP gets this right. The hierarchy is completely flat. You simply implement the behaviors for the types you want and don&#x27;t have to think about grandparent behavior and final interfaces.</div><br/><div id="41904879" class="c"><input type="checkbox" id="c-41904879" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904193">parent</a><span>|</span><a href="#41905870">next</a><span>|</span><label class="collapse" for="c-41904879">[-]</label><label class="expand" for="c-41904879">[1 more]</label></div><br/><div class="children"><div class="content">IMO: The hierarchy part itself is not as problematic when there is no implementation inheritance involved. Hierarchical interface chains can be fine in my experience, but I’m open to changing my mind.<p>The problem IMO arises when you mix both deep hierarchies and implementation inheritance.</div><br/></div></div><div id="41905870" class="c"><input type="checkbox" id="c-41905870" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904193">parent</a><span>|</span><a href="#41904879">prev</a><span>|</span><a href="#41904150">next</a><span>|</span><label class="collapse" for="c-41905870">[-]</label><label class="expand" for="c-41905870">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Coupling behaviors to types is not a problem. Class inheritance and multi-inheritance with their weird taxonomical trees are the problem.<p>I didn’t mention coupling behaviors to types. I said coupling behaviors to state is the problem. When I couple method a to state it’s a big problem. I want method banana but method banana lives in the jungle and has all the other methods related to jungle.<p>So all I wanted was a banana now I have a jungle. Why not think of the banana as modular from the jungle? Why even use oop?<p>I agree with you on the inheritance thing. Thats a different issue.</div><br/></div></div></div></div><div id="41904150" class="c"><input type="checkbox" id="c-41904150" checked=""/><div class="controls bullet"><span class="by">chucksmash</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904031">parent</a><span>|</span><a href="#41904193">prev</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41904150">[-]</label><label class="expand" for="c-41904150">[18 more]</label></div><br/><div class="children"><div class="content">&gt; Tight coupling is the basis of oop.<p>This is not what OOP people are talking about when they talk about tight or loose coupling though.<p>They are talking about the relationship between classes.</div><br/><div id="41905777" class="c"><input type="checkbox" id="c-41905777" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904150">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41905777">[-]</label><label class="expand" for="c-41905777">[17 more]</label></div><br/><div class="children"><div class="content">And that’s the fundamental problem. They fail to see that if they took those same methods and made it independent of state then those things are now called functions.<p>Functions can be moved to different scopes. Functions don’t rely on state to exist.<p>You can compose functions with other functions to build new functions.<p>And here’s the kicker. All of these functions did the same thing as the method.<p>Functions are more modular. A method, is a restricted function that is tightly bounded with state and all other sibling methods.</div><br/><div id="41907226" class="c"><input type="checkbox" id="c-41907226" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41905777">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41907226">[-]</label><label class="expand" for="c-41907226">[16 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a trade-off.<p>Functional programs are easier to read, because the structure makes the state transitions and dependencies obvious - you see your dependencies in the arguments list. But it forces you to basically rewrite big parts of your program after even very simple changes.<p>You had the structure of the program so fine-tuned to the dependencies of every part of the code - that when any dependencies change you have to completely change that structure. It&#x27;s rewrite-only programming style.<p>Imperative (and OO) programming idiomatically let you do a bigger mess with side effects, and you know less about the data dependencies just from looking at the function specifications - but it also allows you to do exploratory programming much faster (no need to pass a new argument down 20 levels of your call stack when some code deep down suddenly requires a new argument). And it allows you to modify the behaviour locally without refactoring the whole thing constantly.<p>If you have a for loop that filters out even numbers and suddenly you want to sum the numbers and find maximum and minimum too - most of the code stays the same.<p>If you have functional code doing the same and want to modify it in similar manner - it&#x27;s a completely different code. Most people would just rewrite it from scratch.<p>And that&#x27;s just a very small scale example. With larger programs the rewrite gets harder.<p>That&#x27;s why big programs are almost never functional.</div><br/><div id="41908338" class="c"><input type="checkbox" id="c-41908338" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41907226">parent</a><span>|</span><a href="#41908173">next</a><span>|</span><label class="collapse" for="c-41908338">[-]</label><label class="expand" for="c-41908338">[6 more]</label></div><br/><div class="children"><div class="content">&gt;If you have a for loop that filters out even numbers and suddenly you want to sum the numbers and find maximum and minimum too - most of the code stays the same.<p><pre><code>   x = [1,2,3,4,5,6,7,8]
   even = [i for i in x if x%2 == 0]
   </code></pre>
Now I want to sum the numbers and add maximum and minimum too.<p><pre><code>  s = max(x) + min(x)
  res = reduce(lambda acc, y: acc + y, x, 0) 
</code></pre>
I achieved your desired goal without rewriting code? The thing is with functional programming all state is immutable, so you can always access intermediary state without modification of the program at all.<p>It&#x27;s an improvement on imperative and OO. Because I only needed to add additional code to achieve the additional goal and those additions are modular and moveable. With imperative I would be changing the code and changing the nature of the original logic and none of it is modular and all of it is tightly integrated.</div><br/><div id="41908687" class="c"><input type="checkbox" id="c-41908687" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41908338">parent</a><span>|</span><a href="#41908173">next</a><span>|</span><label class="collapse" for="c-41908687">[-]</label><label class="expand" for="c-41908687">[5 more]</label></div><br/><div class="children"><div class="content">Sure, if you want to have 4 loops where 1 suffices.</div><br/><div id="41909434" class="c"><input type="checkbox" id="c-41909434" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41908687">parent</a><span>|</span><a href="#41908173">next</a><span>|</span><label class="collapse" for="c-41909434">[-]</label><label class="expand" for="c-41909434">[4 more]</label></div><br/><div class="children"><div class="content">The big oh is the same man. It just feels like it’s less efficient but it’s not. Think about it.<p>And it’s more modular with more loops. If you’re trying to shove 4 different operations into one loop you’re not programming modularly and you’re trying to take shortcuts.</div><br/><div id="41909566" class="c"><input type="checkbox" id="c-41909566" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41909434">parent</a><span>|</span><a href="#41908173">next</a><span>|</span><label class="collapse" for="c-41909566">[-]</label><label class="expand" for="c-41909566">[3 more]</label></div><br/><div class="children"><div class="content">Reduce FPS of your game from 60 to 15, tell players it&#x27;s the same cause complexity haven&#x27;t changed.<p>But it&#x27;s not even mainly about performance. The structure of the code changes with every requirement change. In a non-artificial code you&#x27;re doing stuff other than calculating the result, and all the associated state and dependencies now have to be passed to 4 different loops.<p>While in the ugly non-modular imperative code you add 3 local variables and you&#x27;re done, everything outside that innermost loop stays exactly the same.<p>&gt; you’re trying to take shortcuts<p>Yes, that&#x27;s the point. I started by admiting FP code is more elegant. But shortcuts are not inherently worse than elegance. They are just the opposite sides of a trade-off.</div><br/><div id="41916740" class="c"><input type="checkbox" id="c-41916740" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41909566">parent</a><span>|</span><a href="#41915157">next</a><span>|</span><label class="collapse" for="c-41916740">[-]</label><label class="expand" for="c-41916740">[1 more]</label></div><br/><div class="children"><div class="content">tbh FP is so heavily modularized that even the concept of &quot;looping&quot; is modularized away from the logical operation itself. In haskell it looks like this:<p><pre><code>   f = a . b . c . d
   a1 = map a 
   b1 = map b
   c1 = map c
   d1 = map d
   f2 = a1 . b1 . c1 . d1
</code></pre>
Where f is the composition of operations on a single value and f2 operates on a list of values and returns the mapped list.</div><br/></div></div><div id="41915157" class="c"><input type="checkbox" id="c-41915157" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41909566">parent</a><span>|</span><a href="#41916740">prev</a><span>|</span><a href="#41908173">next</a><span>|</span><label class="collapse" for="c-41915157">[-]</label><label class="expand" for="c-41915157">[1 more]</label></div><br/><div class="children"><div class="content">Gaming and applications that require extreme performance is the only application where Fp doesn’t work well.<p>&gt; But it&#x27;s not even mainly about performance. The structure of the code changes with every requirement change. In a non-artificial code you&#x27;re doing stuff other than calculating the result, and all the associated state and dependencies now have to be passed to 4 different loops.<p>No. I’m saying the initial design needs to be one loop for every module. You then compose the modules to form higher level compositions.<p>If you want new operations then all you do is use the operations on intermediary state.<p>That’s how the design should be. Your primitive modules remain untouched through out the life cycle of your code and any additional requirements are simply new modules or new compositions of unchanged and solid design modules.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41908173" class="c"><input type="checkbox" id="c-41908173" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41907226">parent</a><span>|</span><a href="#41908338">prev</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41908173">[-]</label><label class="expand" for="c-41908173">[9 more]</label></div><br/><div class="children"><div class="content">&gt;Functional programs are easier to read, because the structure makes the state transitions and dependencies obvious - you see your dependencies in the arguments list. But it forces you to basically rewrite big parts of your program after even very simple changes.<p>Disagree. Readability is opinionated so I won&#x27;t address that but this is an example of functional:<p><pre><code>   gg = (x) =&gt; x * x * x

   y = 1
   a = (x) =&gt; x + 1
   b = (x) =&gt; x * 2
   c = (x) =&gt; x * x
   d = (x) =&gt; x - 4
   f = a . b . c . d
   
   result = f(y)
</code></pre>
OOP example:<p><pre><code>   class Domain1
      constructor(n: int)
          this.x = n

      def gg()
         this.x *= this.x * this.x      

      def getX() -&gt; int
         return this.x

   class Domain2:
      constructor(n: int)
          this.x = n
      
      def a:
          this.x += 1

      def b:
          this.x *= 2

      def c:
          this.x *= this.x

      def d:
          this.x -= 4

      def f:
         this.a()
         this.b()
         this.c()
         this.d()

      def getX() -&gt; int
         return this.x

  state = Domain(1)
  state.f()
  result = state.getX()   

         
</code></pre>
What if realize d and a fits better in Domain1 and I want to compose  d and a with gg in the OOP program? I have to refactor Domain2 and Domain1. Or I create a Domain3 that includes a Domain1 and a Domain2<p>How do I do it in functional programming?<p><pre><code>      domain3 = gg . d . a


      #Note I use the fucntion composition operator which means: a . b = (x) =&gt; b(a(x)) or a . b . c = (x) =&gt; c(b(a(x)))

</code></pre>
Functions by nature with the right types are composable without modification. A can compose with B without A knowing about B or vice versa. The same cannot be said for objects.<p>Try achieving the same goal with OOP.... It will be a mess of instantiating state and objects within objects and refactoring your classes. OOP is NOT modular.<p>It&#x27;s pretty clear. One style is more modular than the other. Objects tie methods to state such that the methods are tied to each other and can&#x27;t be composed without instantiating state or doing complex Object compositions and rewriting the Objects themselves.<p>In programming you want legos. You want legos to compose. You don&#x27;t want legos that don&#x27;t fit such that you have to break the legos or glue them together.<p>&gt;Imperative (and OO) programming idiomatically let you do a bigger mess with side effects, and you know less about the data dependencies just from looking at the function specifications - but it also allows you to do exploratory programming much faster (no need to pass a new argument down 20 levels of your call stack when some code deep down suddenly requires a new argument). And it allows you to modify the behaviour locally without refactoring the whole thing constantly.<p>you shouldn&#x27;t be programming with state ever if you&#x27;re doing FP. You need to segregate state away from your program as much as possible. State by nature is hard to modularize. State should be very simple generic mutation operations like getValue and setValue, it should rarely ever contain operational logic.</div><br/><div id="41908787" class="c"><input type="checkbox" id="c-41908787" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41908173">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41908787">[-]</label><label class="expand" for="c-41908787">[8 more]</label></div><br/><div class="children"><div class="content">Your examples are inherently functional, and in practice people would do ABCDService that just returns the result. But ignoring that - how is the code changing when you need to call some external API from the c(x) function and handle the credentials, session, errors etc? Real world has external state and we do need to work with it.<p>&gt; you shouldn&#x27;t be programming with state ever if you&#x27;re doing FP. You need to segregate state away from your program as much as possible. State by nature is hard to modularize. State should be very simple generic mutation operations like getValue and setValue, it should rarely ever contain operational logic.<p>This approach to state management is exactly what is causing the need to rewrite almost everything when requirements change in a functional program.<p>I like how clean FP code is when it&#x27;s done. But I hate writing FP code when I&#x27;m not 100% sure what needs to be done and what might change in the future. If I could write imperative code with side effects and once I&#x27;m done have it transpiled into efficient, elegant, minimized state functional code - that would be great. Maybe it will happen at some point with AI getting better.</div><br/><div id="41909416" class="c"><input type="checkbox" id="c-41909416" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41908787">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41909416">[-]</label><label class="expand" for="c-41909416">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Your examples are inherently functional, and in practice people would do ABCDService that just returns the result. But ignoring that - how is the code changing when you need to call some external API from the c(x) function and handle the credentials, session, errors etc? Real world has external state and we do need to work with it.<p>Abcdservice is bad because I want to use a b c and d in different contexts. You’re saying in the real world oop promotes a style where you can’t break down your code into legos. With oop you need to glue a b c and d together.<p>My code is not inherently functional. I literally picked the smallest possible logical operations and interpreted them as either functional or oop. And then I tried to compose the logical operations.<p>I mean look at it. A b and c are just one or two mathematical operators. If you’re saying this is inherently functional then your saying computing at its most primitive state is inherently functional.<p>&gt; This approach to state management is exactly what is causing the need to rewrite almost everything when requirements change in a functional program.<p>Not true. Fp programs segregate state. Look at my code. All the code for fp is stateless. The only state is y=1.<p>&gt; But I hate writing FP code when I&#x27;m not 100% sure what needs to be done and what might change in the future.<p>You hate what’s inherently better for the future. Fp is more modular and therefore more adaptable for the future. You hate it because you don’t get it.</div><br/><div id="41909800" class="c"><input type="checkbox" id="c-41909800" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41909416">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41909800">[-]</label><label class="expand" for="c-41909800">[6 more]</label></div><br/><div class="children"><div class="content">&gt; If you’re saying this is inherently functional then your saying computing at its most primitive state is inherently functional.<p>Sure. But computing isn&#x27;t what most code does.<p>&gt; Fp is more modular and therefore more adaptable for the future<p>That is wrong. It&#x27;s cleaner to read, but it usually requires more lines of code to be changed when requirements change - so it&#x27;s less adaptable.<p>Before changes<p>FP:<p><pre><code>   y = 1
   a = (x) =&gt; x + 1
   b = (x) =&gt; x \* 2
   c = (x) =&gt; x \* x
   d = (x) =&gt; x - 4
   f = a . b . c . d

   result = f(y)
</code></pre>
ugly imperative code:<p><pre><code>    y = 1;
    void doABCD() {
       y += 1;
       y *= 2;
       y *= y;
       y -= 4;
    }
</code></pre>
Now you want to count how many times you squared numbers larger than 1000.<p>FP:<p><pre><code>   y = [1, 0]
   a = (x) =&gt; [x[0] + 1, x[1]]
   b = (x) =&gt; [x[0] \* 2, x[1]]
   c = (x) =&gt; [x[0] \* x, x&gt;1000 ? x[1]+1 : x[1]]
   d = (x) =&gt; [x[0] - 4, x[1]]
   f = a . b . c . d

   result = f(y)
</code></pre>
imperative:<p><pre><code>    y = 1;
    count = 0;
    void doABCD() {
       y += 1;
       y *= 2;
       if (y &gt; 1000)
           count ++;
       y *= y;
       y -= 4;
    }
</code></pre>
Total lines changed in FP - all except 2.
Total lines changed in imperative - 3.<p>Of course you can refactor the FP version to split the part that requires the new state from the other parts. But in any big program that refactor is going to be PITA.<p>Do you get my point now? I&#x27;m not saying imperative is better. It is ugly. But it&#x27;s faster to adapt to the new requirements.</div><br/><div id="41910092" class="c"><input type="checkbox" id="c-41910092" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41909800">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41910092">[-]</label><label class="expand" for="c-41910092">[5 more]</label></div><br/><div class="children"><div class="content">No way. Imperative is worse.<p>You&#x27;re just not using FP correctly. You&#x27;re trying to do something monadic which is something I would avoid unless we absolutely need an actual side effect.<p><pre><code>   y = 1
   a = (x) =&gt; x + 1
   b = (x) =&gt; x \* 2
   c = (x) =&gt; x \* x
   d = (x) =&gt; x - 4
   f = a . b . c . d

   result = f(y)
</code></pre>
You&#x27;re doing the refactor wrong let me show you. You have to compose new pipelines that reveal the intermediate values.<p><pre><code>   count = 0
   firstPart = a . b
   secondPart = c . d
   countIfGreaterThan1000 = (x, prevCount) =&gt; x &gt; 1000 ? prevCount + 1 : prevCount

   n = firstPart(y)
   newCount = countIfGreaterThan1000(n, count)
   result = secondPart(n)
</code></pre>
The key here isn&#x27;t the amount of lines of code. The key here is to see that under FP the original code is like legos. If you want to reconfigure your fundamental primitives you just recompose it into something different. You don&#x27;t have to modify your original library of primitives. With OOP you HAVE to modify it. doABCD() can&#x27;t be reused. What if I want something additional (doABCD2) that does the EXACT same thing as doABCD() but now without counting the amount of times something was squared and greater than 1000 but now instead I want it for the amount of times the total was greater than 3?<p>You can&#x27;t reconfigure the code. You have to duplicate the code now.<p>Basically you have to imagine functional programming as pipelines. If you want to add something in the middle of the pipeline, you cut the composition in half and split the pipe. One pipe goes towards the end result of what d outputs  and the other pipe goes towards countGreaterThan1000</div><br/><div id="41910342" class="c"><input type="checkbox" id="c-41910342" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41910092">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41910342">[-]</label><label class="expand" for="c-41910342">[4 more]</label></div><br/><div class="children"><div class="content">So your solution to changing 5 lines out of 7 was to do the refactor I wrote about and change 7 lines :)<p>I agree it&#x27;s prettier. But it&#x27;s objectively a larger change than the 3 lines you&#x27;d do in the imperative code. And it&#x27;s pretty much how adapting to changes usually goes with FP. You constantly have to change the outermost structure of the program even if the change in the requirements is localized to one specific corner case.<p>&gt; What if I want something that does the EXACT same thing as doABCD() but now without counting the amount of times something was squared and greater than 1000 but now instead I want it for the amount of times the total was greater than 3?<p>&gt; You can&#x27;t reconfigure the code. You have to duplicate the code now.<p>I could, but at this point refactoring is warranted.<p><pre><code>    y = 1;
    y2 = 1;
    count = 0;
    _ = 0;
    count2 = 0;
    void doABCD(int &amp;y, int &amp;count, int &amp;count2) {
       y += 1;
       y *= 2;
       if (y &gt; 1000)
           count ++;
       y *= y;
       y -= 4;
       if (y &gt; 3)
           count2 ++;
    }
    doABCD(y, count, _);
    doABCD(y2, _, count2);
</code></pre>
8 changes. 11 in total for both modifications.<p>In FP you had 7 lines of code changed for the first refactor<p><pre><code>   y = 1
   a = (x) =&gt; x + 1
   b = (x) =&gt; x \* 2
   c = (x) =&gt; x \* x
   d = (x) =&gt; x - 4
   count = 0;
   firstPart = a . b
   secondPart = c . d
   countIfGreaterThan1000= (x, prevCount) =&gt; x &gt; 1000 ? prevCount + 1 : prevCount
   n = firstPart(y)
   newCount = countIfGreaterThan1000(n, count)
   result = secondPart(n)
</code></pre>
and now you&#x27;d have sth like<p><pre><code>   y = 1
   y2 = 1
   a = (x) =&gt; x + 1
   b = (x) =&gt; x \* 2
   c = (x) =&gt; x \* x
   d = (x) =&gt; x - 4
   count = 0
   count2 = 0
   firstPart = a . b
   secondPart = c . d
   countIfGreaterThan = (x, target, prevCount) =&gt; x &gt; target ? prevCount + 1 : prevCount
   n = firstPart(y)
   newCount = countIfGreaterThan(n, 1000, count)
   result = secondPart(n)
   result2 = (firstPart . secondPart) (y2)
   newCount2 = countIfGreaterThan(result2, 3, count2)
</code></pre>
That&#x27;s 7 + 6 = 13 lines for 2 changes if I&#x27;m counting correctly.<p>What FP buys you is not deduplication (you can do that in any paradigm) - it&#x27;s easier understanding of the code.</div><br/><div id="41915430" class="c"><input type="checkbox" id="c-41915430" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41910342">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41915430">[-]</label><label class="expand" for="c-41915430">[3 more]</label></div><br/><div class="children"><div class="content">Let me emphasize it’s not about prettier. Prettier doesn’t matter.<p>The key is that the original code is untouched. I don’t have to modify the original code. Anytime you modify your original code it means you initially designed poor primitives. It means you made a mistake in the beginning and you didn’t design your code in a modular way. It’s a design problem. You designed your code wrong in the beginning so when a new change is introduced you have to modify your design. This is literally a form of technical debt.<p>Do you see what Fp solves? I am not redesigning my code. I made the perfect abstraction from the beginning. The design was already perfect such that I don’t have to change anything about the original primitives. That is the benefit of Fp.<p>Nirvana in programming is to find the ultimate design scheme such that you never need to do redesigns. Your code becomes so modular that you are simply reconfiguring modules or adding modules as new requirements are introduced. Any time you redesign it means there was technical debt in your design. Your design was not flexible enough to account for changing requirements.<p>Stop looking at lines. In the real world if you modify your code that usually cascades into thousands of changes on dependent code. In Fp I simply link modules together in a different way. The core primitives remain the same. The original design is solid enough that I don’t change code. I just add new features to the design.<p>Also for your example you misinterpreted what I said. I don’t want to change the original signature of doABCD because it’s already used everywhere in the application. I want a new doABCD2 that does exactly the same as the original. Remove the side effect from the original and add a new side effect to the new doABCD of counting something else.<p>Do it without duplicating code or refactoring because duplicate code is technical debt and refactoring old code is admission that old code was not the right design. Be mindful that refactoring the signature means changing all the thousands of other code that depends on doABCD. I don’t want to do that. I want new features to be added to an already perfect design.<p>FP in my opinion, ironically is actually harder to read.</div><br/><div id="41916053" class="c"><input type="checkbox" id="c-41916053" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41915430">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41916053">[-]</label><label class="expand" for="c-41916053">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You designed your code wrong in the beginning so when a new change is introduced you have to modify your design. This is literally a form of technical debt.<p>Yes. And just like in real life if you want to do business - you have to accept some degree of debt to get anywhere. Trying to predict the future and make the perfect design upfront is almost always a mistake.<p>&gt; Stop looking at lines<p>We can&#x27;t communicate without establishing some objective measures. Otherways we&#x27;ll just spew contradictory statements at each other. These toy examples are bad, obviously, but the fact that there&#x27;s basically no big functional programs speaks for itself.<p>&gt; refactoring old code is admission that old code was not the right design<p>And that&#x27;s perfectly fine.<p>&gt; I want a new doABCD2 that does exactly the same as the original. Remove the side effect from the original and add a new side effect to the new doABCD of counting something else.<p>According to your definition of &quot;code changed&quot; if I duplicate everything and leave the old lines there - no code was changed which means the design was perfect :)<p>I don&#x27;t think we&#x27;ll get to a point where we agree about this. One last thing I&#x27;d like to know is why do you think nobody writes big projects in functional languages?</div><br/><div id="41916465" class="c"><input type="checkbox" id="c-41916465" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41916053">parent</a><span>|</span><a href="#41904082">next</a><span>|</span><label class="collapse" for="c-41916465">[-]</label><label class="expand" for="c-41916465">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Yes. And just like in real life if you want to do business - you have to accept some degree of debt to get anywhere. Trying to predict the future and make the perfect design upfront is almost always a mistake.<p>And I&#x27;m saying FP offers a way to avoid this type of debt all together. You can accept it if you want. I&#x27;m just telling you of a methodology that avoids debt: A perfect initial design that doesn&#x27;t need refactoring.<p>&gt;We can&#x27;t communicate without establishing some objective measures. Otherways we&#x27;ll just spew contradictory statements at each other. These toy examples are bad, obviously, but the fact that there&#x27;s basically no big functional programs speaks for itself.<p>Sure then I&#x27;m saying lines of code is not an objective measure. Let&#x27;s establish another objective measure that&#x27;s more &quot;good&quot;: The amount of lines of structural changes made to the original design. It&#x27;s universally accepted that lines of code aren&#x27;t really a good measure but it&#x27;s one of the few quantitative numbers. So I offer a new metric. How many lines of the original design did you change? In mine: 0.<p>I don&#x27;t want to write the psuedocode for it, but let&#x27;s say doABCD() is called in 1000 different places as well. Then in the imperative code you have 1000 lines of changes thanks to a structural change. Structural design changes leads to exponential changes in the rest of the code hence this is a better metric.<p>That&#x27;s an objective measure showing how FP is better. I didn&#x27;t take any jumps into intuition here and I am sticking with your definition of an &quot;objective measure&quot;<p>&gt;And that&#x27;s perfectly fine.<p>That&#x27;s just opinion. Surely you see the benefit of a perfect initial design such that code never needs refactoring. It happens so often in business that it&#x27;s normal to refactor code. But I&#x27;m saying here&#x27;s a way where you perfect your design in the beginning. That&#x27;s the whole point of modularity right? It&#x27;s an attempt to anticipate future changes and minimize refactoring and FP offers this in a way Objectively better than imperative. If your always changing the design when a new feature was added what&#x27;s the point of writing modular and well designed code? Just make it work and forget about everything else because it&#x27;s &quot;okay&quot; to redesign it.<p>&gt;According to your definition of &quot;code changed&quot; if I duplicate everything and leave the old lines there - no code was changed which means the design was perfect :)<p>But then you introduced more technical debt. You duplicated logic. What if I want to change the &quot;a&quot; operation. Now I have to change it for both doABCD and doABCD2. Let&#x27;s assume I have doABCD3 and 4 and 5 and 6 all the way to 20 who all use operation &quot;a&quot; and now they all have to be changed because they all used duplicate code.<p>Let&#x27;s not be pedantic. Refactoring code is a sign of technical debt from the past. But also obviously duplicating code is also known to be technical debt.<p>&gt;I don&#x27;t think we&#x27;ll get to a point where we agree about this.<p>Sure but under objective measures FP has better metrics. Opinion wise we may never agree, but objectively if we use more detailed and comprehensive rules for the metric, FP is better.<p>&gt;One last thing I&#x27;d like to know is why do you think nobody writes big projects in functional languages?<p>Part of the reason is because of people with your mentality who don&#x27;t understand. It&#x27;s the same reason why the US doesn&#x27;t use metric. Old cultural habits on top of lack of understanding.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41904082" class="c"><input type="checkbox" id="c-41904082" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904031">parent</a><span>|</span><a href="#41904150">prev</a><span>|</span><a href="#41904253">next</a><span>|</span><label class="collapse" for="c-41904082">[-]</label><label class="expand" for="c-41904082">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think a method being tied to an instance is the best case for calling it &quot;tight coupling&quot;.<p>OOP can be used to design <i>relatively</i> uncoupled systems.<p>One of the lessons learned in all these decades is what the grandparent post alludes to, which is distilled into &quot;prefer composition over inheritance&quot;. Implementation inheritance (as opposed to interface inheritance) indeed introduces coupling and is therefore discouraged in current advice.</div><br/><div id="41904157" class="c"><input type="checkbox" id="c-41904157" checked=""/><div class="controls bullet"><span class="by">gorjusborg</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904082">parent</a><span>|</span><a href="#41905830">next</a><span>|</span><label class="collapse" for="c-41904157">[-]</label><label class="expand" for="c-41904157">[4 more]</label></div><br/><div class="children"><div class="content">&gt; OOP can be used to design relatively uncoupled systems.<p>Never go full-Object-oriented programming.<p>In this case I think it is valuable to make a distinction between OOP which is a style of programming, and object-oriented languages, which are just a language designed with that style in mind.<p>I have seen issues in codebases where developers have used OOP as style to aspire to, using it in an academic sense. They tend to try to use inheritance frequently, have deep inheritance trees, and suffer from hidden coupling through these.<p>On the other hand, those who use object oriented languages in a mostly functional style (side-effect free functions, effective immutability, and almost no use of inheritance) tend to be much healthier in the long term.<p>So it&#x27;s fine to use OO languages, but never go full OO programming.</div><br/><div id="41905401" class="c"><input type="checkbox" id="c-41905401" checked=""/><div class="controls bullet"><span class="by">jnwatson</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904157">parent</a><span>|</span><a href="#41904658">next</a><span>|</span><label class="collapse" for="c-41905401">[-]</label><label class="expand" for="c-41905401">[1 more]</label></div><br/><div class="children"><div class="content">I think the poster child of going full OOP (that one can look at) is ACE&#x2F;TAO [1], an implementation of CORBA.  It had deep inheritance trees and abstractions piled on abstractions.<p>Similar to Mach and microkernels, folks ran ACE&#x2F;TAO and thought CORBA was slow, when it was just the implementation that was not built for speed.<p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;DOCGroup&#x2F;ACE_TAO">https:&#x2F;&#x2F;github.com&#x2F;DOCGroup&#x2F;ACE_TAO</a></div><br/></div></div><div id="41904658" class="c"><input type="checkbox" id="c-41904658" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904157">parent</a><span>|</span><a href="#41905401">prev</a><span>|</span><a href="#41905830">next</a><span>|</span><label class="collapse" for="c-41904658">[-]</label><label class="expand" for="c-41904658">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Never go full-Object-oriented programming.</i><p>Agreed, but that wasn&#x27;t what I was saying or replying to, was it?<p>I was arguing that method implementation tied to an instance isn&#x27;t the type of thing people mean when they refer to tight coupling. Coupling is related to breakage&#x2F;maintenance; when you touch this thing here, if it&#x27;s tightly coupled with some other component, it will also require (sometimes unexpected) changes in that other component.<p>Whether one should or shouldn&#x27;t go full OO is an orthogonal consideration.</div><br/><div id="41904797" class="c"><input type="checkbox" id="c-41904797" checked=""/><div class="controls bullet"><span class="by">gorjusborg</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904658">parent</a><span>|</span><a href="#41905830">next</a><span>|</span><label class="collapse" for="c-41904797">[-]</label><label class="expand" for="c-41904797">[1 more]</label></div><br/><div class="children"><div class="content">Oh, no, I didn&#x27;t intend to suggest anything contrary to what you said, I was just adding on.</div><br/></div></div></div></div></div></div><div id="41905830" class="c"><input type="checkbox" id="c-41905830" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904082">parent</a><span>|</span><a href="#41904157">prev</a><span>|</span><a href="#41904253">next</a><span>|</span><label class="collapse" for="c-41905830">[-]</label><label class="expand" for="c-41905830">[4 more]</label></div><br/><div class="children"><div class="content">You don’t see the problem.<p>It’s better to have all your logic be loosely coupled down to the smallest primitive.<p>What’s the point of tying up groups of logic together and glue it up with state and say this is the fundamental unit of composition?<p>You see the problem? 2 years down the line you find out that a certain class has methods that are better reused in another context but it’s so tightly coupled that the refactoring is insanity.<p>Better to have had state decoupled from function and to have functions decoupled from each other and not tied together by common state. If you do this you get rid of all the fundamental technical debt that arises from oop. You guys don’t see it. Oop is a major cause of technical debt because of tight coupling.<p>We can’t predict the future. You can’t guess that a method that exists in class A will 2 years down the line be better fit in class B or as its own class. So because you can’t know the future isn’t it logically better to not couple all your logic together into these arbitrary bundles called classes?<p>Break your function down into more smaller modules of computation. The object class is too large.<p>But then you ask how do I create bigger abstractions? Just compose functions together to form bigger functions. For state Compose struct types together to form bigger structs. Using this method to build your abstractions allows you to break down your abstractions into smaller units whenever you want!<p>You can’t break down the class. The class is stuck. I can’t reuse a portion of state in another context and I can’t do the same thing with my methods. What’s the point of using classes to place arbitrary and pointless restrictions on modularity? None.</div><br/><div id="41906719" class="c"><input type="checkbox" id="c-41906719" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41905830">parent</a><span>|</span><a href="#41906626">next</a><span>|</span><label class="collapse" for="c-41906719">[-]</label><label class="expand" for="c-41906719">[2 more]</label></div><br/><div class="children"><div class="content">I agree that in many cases there is a problem, and indeed, objects can be designed as too coarse.<p>I agree in many cases it leads to problems of composition. Some design principles have been devised to mitigate this, such as the &quot;Single Responsibility Principle&quot;  (and others). Nothing is fool-proof however, and everything is further complicated by the fact no-one seems to agree on precise definitions of any principles.<p>God Objects are one such know problem of highly coupled, low cohesion functions grouped into arbitrary objects.<p>Objects naturally group related functions in some cases (when they truly conform to a coherent entity), so I guess I disagree they are <i>always</i> wrong. But when OOP became fashionable, designers started thinking <i>everything must be an object</i>, and this is obviously wrong -- but is it OOP&#x27;s fault, or was it the fault of its adopters? The &quot;everything is an object&quot; mantra is indeed misguided when applied to <i>every</i> software system.<p>Functions can fall prey to the same faulty thinking. I&#x27;ve seen many times functions &quot;in the wild&quot; that do too many things, tweakeable through too many parameters. They usually must be refactored.<p>In fact, refactoring is where you split objects that have become too large or ill-defined for their own good, is it not?<p>In the end, I think this is more about good software engineering practices rather than &quot;one must use&#x2F;must not use OOP&#x2F;FP&quot; or whatever ?Programming style.</div><br/><div id="41906871" class="c"><input type="checkbox" id="c-41906871" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41906719">parent</a><span>|</span><a href="#41906626">next</a><span>|</span><label class="collapse" for="c-41906871">[-]</label><label class="expand" for="c-41906871">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I agree that in many cases there is a problem, and indeed, objects can be designed as too coarse.<p>Or don&#x27;t put your methods in an object at all. Then you don&#x27;t need to even worry about everything being designed coarse because your object doesn&#x27;t even exist in the first place.<p>&gt;Objects naturally group related functions in some cases (when they truly conform to a coherent entity), so I guess I disagree they are always wrong.<p>Think of it like this: You can build a lego project by gluing all the pieces together (aka OOP) but I would say this is always wrong because if you just connect the pieces together without glue they will stick together but they can be split apart at the same time. In OOP your mistakes may not be evident until years later, OR changing requirements make the glue hard to remove...<p>Thus I say it&#x27;s always wrong to use OOP. Just don&#x27;t glue anything together. Leave it all decoupled. There&#x27;s no point to bring glue to a lego set.<p>&gt;Functions can fall prey to the same faulty thinking. I&#x27;ve seen many times functions &quot;in the wild&quot; that do too many things, tweakeable through too many parameters. They usually must be refactored.<p>So? It&#x27;s not like Taking the SAME function and placing it in an Object doesn&#x27;t solve this problem. This problem you describe is completely orthogonal to the issue I&#x27;m describing because it exists in your logic independent of whether or not that logic is a method or a function.<p>&gt;In fact, refactoring is where you split objects that have become too large or ill-defined for their own good, is it not?<p>Yeah, If your logic was a collection of functions you don&#x27;t have to spend the inordinate effort to remove the glue. All you need to do is recompose the lego building blocks in a different way because there wasn&#x27;t any glue holding it together (if you didn&#x27;t use OOP)<p>&gt;In the end, I think this is more about good software engineering practices rather than &quot;one must use&#x2F;must not use OOP&#x2F;FP&quot; or whatever ?Programming style.<p>I didn&#x27;t specify FP here. OOP is NOT good software engineering practice is what I&#x27;m saying here.</div><br/></div></div></div></div></div></div></div></div><div id="41904253" class="c"><input type="checkbox" id="c-41904253" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904031">parent</a><span>|</span><a href="#41904082">prev</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41904253">[-]</label><label class="expand" for="c-41904253">[12 more]</label></div><br/><div class="children"><div class="content">obviously when they refer to loose coupling, they&#x27;re refer to that between interface and hidden states&#x2F;implementation of object.<p>It&#x27;s very easy to deliberately miss the point and complain about the &quot;tight coupling&quot; that, by design, prevents messages to be sent to&#x2F;called upon invalid states, which functional programming also has, albeit with different a approach using static type inference &amp; pattern matching.</div><br/><div id="41904805" class="c"><input type="checkbox" id="c-41904805" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904253">parent</a><span>|</span><a href="#41906943">next</a><span>|</span><label class="collapse" for="c-41904805">[-]</label><label class="expand" for="c-41904805">[4 more]</label></div><br/><div class="children"><div class="content">The tight coupling the OP refers to is between different components, in this case different classes in the same inheritance tree.<p>If you use implementation inheritance, i.e. a base class with a tree inheritance of derived classes, there&#x27;s coupling between the derived classes and the base class, because changes done carelessly in the base class (for example, to accommodate one additional child class) may impact the behavior of already existing derived classes. There are all sorts of principles to minimize this risk, but they are there precisely because it&#x27;s such a big risk.<p>Therefore &quot;inheritance as reuse&quot; introduces dangerous coupling, but it&#x27;s not a case of the &quot;interface being coupled to the implementation of the object&quot;.</div><br/><div id="41905249" class="c"><input type="checkbox" id="c-41905249" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904805">parent</a><span>|</span><a href="#41906943">next</a><span>|</span><label class="collapse" for="c-41905249">[-]</label><label class="expand" for="c-41905249">[3 more]</label></div><br/><div class="children"><div class="content">no one ever brought up &quot;inheritance as reuse&quot; in this thread, don&#x27;t straw man.<p>It&#x27;s called OOP, NONE of those letters stands for &quot;inheritance&quot;</div><br/><div id="41905372" class="c"><input type="checkbox" id="c-41905372" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41905249">parent</a><span>|</span><a href="#41906943">next</a><span>|</span><label class="collapse" for="c-41905372">[-]</label><label class="expand" for="c-41905372">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>no one ever brought up &quot;inheritance as reuse&quot; in this thread, don&#x27;t straw man.</i><p>Yes they did. I quote one of the statements at the top of this thread:<p>&gt; <i>But in real life, when there is a team, you run into the fragile base class [1] constantly and changing that base class causes horrible issues across your code base.</i><p>The &quot;fragile base class&quot; is one of the problems of &quot;inheritance as reuse&quot;. It simply doesn&#x27;t occur with <i>interface</i> inheritance (the other common type of OOP inheritance).<p>&gt; <i>It&#x27;s called OOP, NONE of those letters stands for &quot;inheritance&quot;</i><p>That line of conversation is fruitless. We&#x27;re discussing OOP as practiced, not as defined by Alan Kay (who came to regret the name &quot;OOP&quot; anyway).<p>OOP <i>as practiced</i> is all about inheritance, and sadly, its pitfalls. This is exactly what other people in this thread are discussing pros and cons of! Not OOP in academia, but in practice.<p>Also, it&#x27;s mentioned in the article which you hopefully have read:<p><pre><code>    In this post I use the word “OOP” to mean programming in statically-typed language with:
    
    - Classes, that combine state and methods that can modify the state.
    - Inheritance, which allows classes to reuse state and methods of other classes.
    - Subtyping, where if a type B implements the public interface of type A, values of type B can be passed as A.
    - Virtual calls, where receiver class of a method call is not determined by the static type of the receiver but it’s runtime type.</code></pre></div><br/><div id="41905531" class="c"><input type="checkbox" id="c-41905531" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41905372">parent</a><span>|</span><a href="#41906943">next</a><span>|</span><label class="collapse" for="c-41905531">[-]</label><label class="expand" for="c-41905531">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Tight coupling is the basis of oop. A method is tied to an instance. Methods cannot be composed with other methods or functions without instantiating state. Methods cannot be moved into other scope.<p>&gt; The literal definition of an object is a tightly bound set of methods that cannot ever be used without instantiating state.<p>That is the nonsensical point I responded too, you&#x27;re bringing up an actual bigger debate that&#x27;s out of scope.</div><br/></div></div></div></div></div></div></div></div><div id="41906943" class="c"><input type="checkbox" id="c-41906943" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904253">parent</a><span>|</span><a href="#41904805">prev</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41906943">[-]</label><label class="expand" for="c-41906943">[7 more]</label></div><br/><div class="children"><div class="content">&gt;obviously when they refer to loose coupling, they&#x27;re refer to that between interface and hidden states&#x2F;implementation of object.<p>Right and I&#x27;m saying it&#x27;s the tight coupling of Objects themselves that&#x27;s the main problem.<p>&gt;It&#x27;s very easy to deliberately miss the point and complain about the &quot;tight coupling&quot; that, by design, prevents messages to be sent to&#x2F;called upon invalid states,<p>More like you missed my point. You should avoid coupling logic and state as much as possible period. OOP encourages this. You have one state called A, and A has 20 methods attached to it. Boom now All methods and A are tightly coupled.<p>At most one should have only a simple setter and getter on A, and all the transformational logic be pure functions and decoupled from the changing of state.<p>Oh and you can use type checking to prevent logic to operate on invalid state.</div><br/><div id="41912442" class="c"><input type="checkbox" id="c-41912442" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41906943">parent</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41912442">[-]</label><label class="expand" for="c-41912442">[6 more]</label></div><br/><div class="children"><div class="content">&gt; avoid coupling logic and state as much as possible period<p>depending on how you define &quot;state&quot;. In OOP, the coupling is between a bunch of transitions (as a single class) to a bunch of states (as a single type). It&#x27;s actually *loose* coupling that is the problem here because that set-up can easily produce invalid states. It can be addressed with the builder pattern.<p>Tight coupling is a problem alright, no one is denying that. It&#x27;s just there is nothing wrong conceptually about &quot;coupling state to the logic&quot;, that is a non-problem, and &quot;tight coupling&quot; has never meant that.</div><br/><div id="41915590" class="c"><input type="checkbox" id="c-41915590" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41912442">parent</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41915590">[-]</label><label class="expand" for="c-41915590">[5 more]</label></div><br/><div class="children"><div class="content">Highly disagree state to logic is a huge problem. Once you couple state and logic together you lose modularity so such couplings need to be avoided.<p>The reason is as I said. Once state and logic are coupled it becomes entangled with all the logic related to the same state.<p>What you’re referring to is a transaction. Where multiple states must be changed at the same time as a transaction. And while you don’t explicitly say it you’re implying that transactions are required. They can’t be avoided. And that’s where I agree. Coupling state and logic is a problem and must be avoided as much as possible, but you can’t fully avoid it.<p>The main problem with oop is that it promotes the coupling of state and logic everywhere. The style of programming maximizes tight coupling all over the place. That is the problem and the insight you’re not seeing. Years of doing oop makes you feel that such couplings can’t be minimized. This makes oop highly unmodular. It makes it so that refactoring a of code are normal almost every time a new feature is introduced.<p>If you want more insight into what I’m talking about you can follow some of the branching threads that I’m in where I write examples and maybe you’ll see what I’m talking about.</div><br/><div id="41921031" class="c"><input type="checkbox" id="c-41921031" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41915590">parent</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41921031">[-]</label><label class="expand" for="c-41921031">[4 more]</label></div><br/><div class="children"><div class="content">no one is talking about transaction. I&#x27;m talking about state machine which is what most program boils down to.<p>The problem with OOP is, AGAIN that all states are lumped together in a single type (class) and so are all the state transitions (methods). This IS a problem, but it is not &quot;tight coupling&quot;. &quot;Tight coupling&quot; has a known meaning and refers to relationship between components&#x2F;classes, see what people mean by it in this thread.<p>I can simply just repeat that the situation here is actually *loose* coupling, because in order to correctly model state machine, you need to further break down the class into individual states (states not properties, I feel like you need to be noted this distinction) and attribute only the relevant states transitions&#x2F;methods to each of them, making the coupling of the logic and the state even tighter.<p>Functional programming is the same, in a strong type system, which they often have, you can&#x27;t pass input of this function to another. The solution to that is you write more unixy functions that take more generic types. But for high-level, domain-related functions, this coupling is what you actually want.<p>We can disagree on whether &quot;coupling state to logic is a huge problem&quot;. My original point is that it&#x27;s an entire other thing not the particular &quot;tight coupling&quot; that is the downside of OOP, as widely discussed.</div><br/><div id="41925628" class="c"><input type="checkbox" id="c-41925628" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41921031">parent</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41925628">[-]</label><label class="expand" for="c-41925628">[3 more]</label></div><br/><div class="children"><div class="content">&gt; no one is talking about transaction. I&#x27;m talking about state machine which is what most program boils down to.<p>A transaction is an operation on a state machine in the form you yourself described below:<p>&gt; depending on how you define &quot;state&quot;. In OOP, the coupling is between a bunch of transitions (as a single class) to a bunch of states (as a single type).<p>The bunch of transitions on a bunch of state is a “transaction”<p>&gt; &quot;Tight coupling&quot; has a known meaning and refers to relationship between components&#x2F;classes, see what people mean by it in this thread.<p>Tight coupling does not mean that. See the generalized response from ChatGPT: <a href="https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;6719060e-9e8c-8001-bdf9-79502712c114" rel="nofollow">https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;6719060e-9e8c-8001-bdf9-79502712c1...</a><p>Tight coupling encompasses the relationship between components and classes but it has a more generalized meaning illustrated in the link above.<p>&gt; I can simply just repeat that the situation here is actually <i>loose</i> coupling, because in order to correctly model state machine, you need to further break down the class into individual states (states not properties, I feel like you need to be noted this distinction) and attribute only the relevant states transitions&#x2F;methods to each of them, making the coupling of the logic and the state even tighter.<p>Not clear what you’re saying here. State on classes does come in the form of properties. They are the same in my mind. Please illustrate the distinction. Also what do you mean by break it down? And how does breaking it down make coupling tighter?<p>Are you saying if class A has two properties, say two ints x and y whose state changes need to happen at the same and if I break down x and y into individual classes then to ensure that changes on x and y happen at the same time I have to use object composition and have x and y owned by a third even bigger class and this is the “tighter coupling” you’re talking about that is ironically caused by “loosely coupling” x and y into separate classes?<p>Functional programming doesn’t address this if this is what you’re talking about. Functional programming addresses the coupling between method and state.<p>Coupling between state and state isn’t an issue in Fp because everything is immutable.<p>Why don’t you write some pseudo code so I can better understand what you’re addressing? I was going to do it but I want to be sure about what you’re talking about.<p>&gt; Functional programming is the same, in a strong type system, which they often have, you can&#x27;t pass input of this function to another. The solution to that is you write more unixy functions that take more generic types. But for high-level, domain-related functions, this coupling is what you actually want.<p>Again not clear. You talk about state machines then you say Fp is the same when Fp doesn’t have a state machine. Fp is all about writing functions that declare the entire state in one go.<p>&gt; I&#x27;m talking about state machine which is what most program boils down to.<p>In Fp, the state machine is abstracted away from the program so not sure how this relates? State change is a problem that can’t fully go away but it’s segregated from your code as much as possible in Fp.<p>Perhaps you should illustrate your point with pseudocode because at this point there could be a number of issues we aren’t seeing eye to eye on some of which may only be related to communication.</div><br/><div id="41926752" class="c"><input type="checkbox" id="c-41926752" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41925628">parent</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41926752">[-]</label><label class="expand" for="c-41926752">[2 more]</label></div><br/><div class="children"><div class="content">Sorry I just can&#x27;t</div><br/><div id="41927080" class="c"><input type="checkbox" id="c-41927080" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41926752">parent</a><span>|</span><a href="#41904101">next</a><span>|</span><label class="collapse" for="c-41927080">[-]</label><label class="expand" for="c-41927080">[1 more]</label></div><br/><div class="children"><div class="content">It’s fine. My honest interpretation of it is that you’re not well informed. But I gave you the benefit of the doubt thinking that maybe I can learn more in case you actually knew what you’re talking about.<p>Good day to you sir.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41904101" class="c"><input type="checkbox" id="c-41904101" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41904031">prev</a><span>|</span><a href="#41904149">next</a><span>|</span><label class="collapse" for="c-41904101">[-]</label><label class="expand" for="c-41904101">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I have found that OOP with inheritance is actually a form of tight coupling<p>You are not the only one.  Prefer composition to inheritance is a saying for a reason.  Inheritance is powerful and useful for small problems, but as you say it introduces tight coupling and so should only be used where that is intended.  Tight coupling isn&#x27;t always bad, but it is bad often enough to avoid it.</div><br/></div></div><div id="41904149" class="c"><input type="checkbox" id="c-41904149" checked=""/><div class="controls bullet"><span class="by">ajuc</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41904101">prev</a><span>|</span><a href="#41903874">next</a><span>|</span><label class="collapse" for="c-41904149">[-]</label><label class="expand" for="c-41904149">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I find OOP works best when you have a single coder who can store the model of the system in this mind and work how out to design the base and abstract classes well.<p>When all the states of the program and all the transitions between them fit into one programmer&#x27;s head - every programming paradigm works well.</div><br/><div id="41904808" class="c"><input type="checkbox" id="c-41904808" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41904149">parent</a><span>|</span><a href="#41903874">next</a><span>|</span><label class="collapse" for="c-41904808">[-]</label><label class="expand" for="c-41904808">[1 more]</label></div><br/><div class="children"><div class="content">Good observation.  That makes my statement is an even worse condemnation of OOP that I thought.</div><br/></div></div></div></div><div id="41903874" class="c"><input type="checkbox" id="c-41903874" checked=""/><div class="controls bullet"><span class="by">piva00</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41904149">prev</a><span>|</span><a href="#41903979">next</a><span>|</span><label class="collapse" for="c-41903874">[-]</label><label class="expand" for="c-41903874">[1 more]</label></div><br/><div class="children"><div class="content">Similar thinking, I&#x27;ve been through much pain from a class hierarchy degrading into an unusable mess, also done a lot of rework refactoring those and it doesn&#x27;t pay off.<p>Instead of inheritance I much rather prefer the composition approach, not extending classes but defining interfaces for the API, using other classes in the composition of an object rather than relying on overrides&#x2F;implementations from a base class. It&#x27;s much clearer to reason about (no more 3-4 layers of indirection), easier to refactor as well.</div><br/></div></div><div id="41903979" class="c"><input type="checkbox" id="c-41903979" checked=""/><div class="controls bullet"><span class="by">bn-l</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41903874">prev</a><span>|</span><a href="#41904044">next</a><span>|</span><label class="collapse" for="c-41903979">[-]</label><label class="expand" for="c-41903979">[1 more]</label></div><br/><div class="children"><div class="content">Exactly my thoughts. When I started really getting functional programming it was a breath of fresh air. For me the test is not just how fast someone else can pick up the codebase but how fast I can remember how it all works in n years.</div><br/></div></div><div id="41904044" class="c"><input type="checkbox" id="c-41904044" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41903979">prev</a><span>|</span><a href="#41903878">next</a><span>|</span><label class="collapse" for="c-41904044">[-]</label><label class="expand" for="c-41904044">[1 more]</label></div><br/><div class="children"><div class="content">My thoughts as well. Inheritance forces you into spaghettification sooner or later if you didn&#x27;t consider everything you&#x27;ll ever need from the start to the end of the universe. Even if you&#x27;re working on it by yourself the refactors become frequent and take too much time for little gain.<p>Self contained encapsulated parts with an eventbus for entirely decoupled data propagation are much easier to manage and edit. Just duplicate a bit more than you think would be best to reuse, disk space is cheap and if you get that part wrong you&#x27;re screwed and will need another rewrite.<p>And it&#x27;s probably more performant too with newer hardware since you can usually just spin out  any self contained part as its own thread if need be, often with almost zero changes.</div><br/></div></div><div id="41903878" class="c"><input type="checkbox" id="c-41903878" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41904044">prev</a><span>|</span><a href="#41932781">next</a><span>|</span><label class="collapse" for="c-41903878">[-]</label><label class="expand" for="c-41903878">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I have found that OOP with inheritance is actually a form of tight coupling and that it is best to not use class hierarchies [..] I just completely disagree with inheritance in all forms<p>This is pretty common advice (at least IME), usually distilled into the form &quot;prefer composition to inheritance&quot;.</div><br/><div id="41903896" class="c"><input type="checkbox" id="c-41903896" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#41903821">root</a><span>|</span><a href="#41903878">parent</a><span>|</span><a href="#41932781">next</a><span>|</span><label class="collapse" for="c-41903896">[-]</label><label class="expand" for="c-41903896">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is pretty common advice (at least IME), usually distilled into the form &quot;prefer composition to inheritance&quot;.<p>I think this is why in the current JavaScript era, it is rare to find a popular library that makes significant use of inheritance (as opposed to just supporting interfaces) even though it is supported in the language.<p>ThreeJS is one of those exceptions, but they are few and far between.</div><br/></div></div></div></div><div id="41932781" class="c"><input type="checkbox" id="c-41932781" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41903821">parent</a><span>|</span><a href="#41903878">prev</a><span>|</span><a href="#41904019">next</a><span>|</span><label class="collapse" for="c-41932781">[-]</label><label class="expand" for="c-41932781">[1 more]</label></div><br/><div class="children"><div class="content">A useful rule is not to extend a class you don&#x27;t own. This is usually taken to mean don&#x27;t extend a class from a third party library. But it should also mean classes that are shared by multiple developers. In that case, compose, don&#x27;t inherit.</div><br/></div></div></div></div><div id="41904019" class="c"><input type="checkbox" id="c-41904019" checked=""/><div class="controls bullet"><span class="by">ildon</span><span>|</span><a href="#41903821">prev</a><span>|</span><a href="#41903812">next</a><span>|</span><label class="collapse" for="c-41904019">[-]</label><label class="expand" for="c-41904019">[3 more]</label></div><br/><div class="children"><div class="content">I noticed there&#x27;s an entire paragraph explaining what OOP is, but it might be helpful to clarify that OOP stands for Object-Oriented Programming. Even though it&#x27;s a well-known acronym, adding that explanation could benefit readers who are new to the concept.</div><br/><div id="41904179" class="c"><input type="checkbox" id="c-41904179" checked=""/><div class="controls bullet"><span class="by">Tempest1981</span><span>|</span><a href="#41904019">parent</a><span>|</span><a href="#41903812">next</a><span>|</span><label class="collapse" for="c-41904179">[-]</label><label class="expand" for="c-41904179">[2 more]</label></div><br/><div class="children"><div class="content">I remember the early days of HTML, when people excitedly used hyperlinks to define acronyms.</div><br/></div></div></div></div><div id="41903812" class="c"><input type="checkbox" id="c-41903812" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#41904019">prev</a><span>|</span><a href="#41904767">next</a><span>|</span><label class="collapse" for="c-41903812">[-]</label><label class="expand" for="c-41903812">[2 more]</label></div><br/><div class="children"><div class="content">Although short, this article is quite interesting because it presents code examples from &quot;both sides&quot; and the author seems to have a good understanding of both.</div><br/><div id="41932365" class="c"><input type="checkbox" id="c-41932365" checked=""/><div class="controls bullet"><span class="by">sbergot</span><span>|</span><a href="#41903812">parent</a><span>|</span><a href="#41904767">next</a><span>|</span><label class="collapse" for="c-41932365">[-]</label><label class="expand" for="c-41932365">[1 more]</label></div><br/><div class="children"><div class="content">Except it is biased in its conclusion:<p>&gt; However, unlike our OOP example, existing code that uses the Logger type and log function cannot work with this new type. There needs to be some refactoring, and how the user code will need to be refactored depends on how we want to expose this new type to the users.<p>It is super simple to create a Logger from a FileLogger an pass that to old code. In OOP you also need to refactor code when you are changing base types, and you need to think about what to expose to client code.<p>To me option 1 is the correct simple approach, but the author dissmisses it for unclear reasons.</div><br/></div></div></div></div><div id="41904767" class="c"><input type="checkbox" id="c-41904767" checked=""/><div class="controls bullet"><span class="by">pull_my_finger</span><span>|</span><a href="#41903812">prev</a><span>|</span><a href="#41905001">next</a><span>|</span><label class="collapse" for="c-41904767">[-]</label><label class="expand" for="c-41904767">[1 more]</label></div><br/><div class="children"><div class="content">Old school OO languages where they had to use classes and objects to patch missing language features probably did suck. OOP as an abstraction API on a modern, type annotated language is really nice and intuitive. Anyone in doubt, but open-minded should be encouraged to checkout a language like Pony[1]. Although it _would_ be nice to have first-class functions instead of the lambda objects they have it&#x27;s otherwise really nice. No inheritance, real type interfaces and traits instead of &quot;abstract classes&quot;. Combine a modern language like Pony with (mostly) sane modern OO advice like in Elegant Objects[2] and you&#x27;re finally cooking with grease.<p>[1]: <a href="https:&#x2F;&#x2F;tutorial.ponylang.io&#x2F;types&#x2F;classes" rel="nofollow">https:&#x2F;&#x2F;tutorial.ponylang.io&#x2F;types&#x2F;classes</a><p>[2]: <a href="https:&#x2F;&#x2F;www.elegantobjects.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.elegantobjects.org&#x2F;</a></div><br/></div></div><div id="41905001" class="c"><input type="checkbox" id="c-41905001" checked=""/><div class="controls bullet"><span class="by">mekoka</span><span>|</span><a href="#41904767">prev</a><span>|</span><a href="#41904240">next</a><span>|</span><label class="collapse" for="c-41905001">[-]</label><label class="expand" for="c-41905001">[1 more]</label></div><br/><div class="children"><div class="content">Every code base that I&#x27;ve read that made faithful use of OOP artifacts such as inheritance (in all its forms) has been made more difficult to understand <i>because</i> of it, rarely despite it.<p>OOP certainly has good features (e.g. encapsulation of state), but I think it tends to shine best when programmers are really aware of the trade-offs. Most aren&#x27;t. The same person that agrees that mixins are a bad idea in React, will then turn around and happily organize their logic as class-based views in Django.<p>And due to sunk cost, it&#x27;s nearly impossible to convince someone who&#x27;s invested time in this paradigm that the acrobatics are often probably unnecessary.<p>In my opinion, newer languages expose programmers to better mental models than &quot;the class hierarchy&quot; to solve code organizational problems. Work with Go or Elixir for a while and see your Java and Python improve.</div><br/></div></div><div id="41904240" class="c"><input type="checkbox" id="c-41904240" checked=""/><div class="controls bullet"><span class="by">d_burfoot</span><span>|</span><a href="#41905001">prev</a><span>|</span><a href="#41932643">next</a><span>|</span><label class="collapse" for="c-41904240">[-]</label><label class="expand" for="c-41904240">[5 more]</label></div><br/><div class="children"><div class="content">One very important issue in OOP is packaging together variable names. You can see the issue by looking at this atrocious function signature from the Python Pandas library:<p>&gt; pandas.read_csv(filepath_or_buffer, *, sep=&lt;no_default&gt;, delimiter=None, header=&#x27;infer&#x27;, names=&lt;no_default&gt;, index_col=None, usecols=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=&lt;no_default&gt;, skip_blank_lines=True, parse_dates=None, infer_datetime_format=&lt;no_default&gt;, keep_date_col=&lt;no_default&gt;, date_parser=&lt;no_default&gt;, date_format=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression=&#x27;infer&#x27;, thousands=None, decimal=&#x27;.&#x27;, lineterminator=None, quotechar=&#x27;&quot;&#x27;, quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors=&#x27;strict&#x27;, dialect=None, on_bad_lines=&#x27;error&#x27;, delim_whitespace=&lt;no_default&gt;, low_memory=True, memory_map=False, float_precision=None, storage_options=None, dtype_backend=&lt;no_default&gt;)<p>An OOP approach would define a Reader object that has many methods supporting various configuration options (setSkipRows(..), setNaFilter(...), etc), perhaps using a fluent style. Finally you call a read() method that returns the DataFrame.</div><br/><div id="41904411" class="c"><input type="checkbox" id="c-41904411" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#41904240">parent</a><span>|</span><a href="#41904677">next</a><span>|</span><label class="collapse" for="c-41904411">[-]</label><label class="expand" for="c-41904411">[1 more]</label></div><br/><div class="children"><div class="content">This seems like a trivial example though.<p><pre><code>    read_csv(options: Options)
</code></pre>
All you&#x27;ve shown is that Options has a lot of configurability, but you&#x27;d have the same problem if you posted the whole class with all of its fluent API methods; it would be even more characters.<p>Also, you can use built-in control flow logic to modify options before passing them into the function rather than depend on a developer to implement a fluent API for every class.<p>But this isn&#x27;t an example of FP vs OOP. Just replace `read_csv(options)` with `constructor(options)`.</div><br/></div></div><div id="41904677" class="c"><input type="checkbox" id="c-41904677" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#41904240">parent</a><span>|</span><a href="#41904411">prev</a><span>|</span><a href="#41904367">next</a><span>|</span><label class="collapse" for="c-41904677">[-]</label><label class="expand" for="c-41904677">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a Reader object that has many methods supporting various configuration options (setSkipRows(..), setNaFilter(...), etc), perhaps using a fluent style<p>I don&#x27;t understand what that would bring as opposed to the current situation you mention, where you just call read_csv and name each parameter you want with the value you want.<p>If anything, I&#x27;d say the builder pattern is a crutch for languages that don&#x27;t have named parameters.</div><br/></div></div><div id="41904367" class="c"><input type="checkbox" id="c-41904367" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#41904240">parent</a><span>|</span><a href="#41904677">prev</a><span>|</span><a href="#41933076">next</a><span>|</span><label class="collapse" for="c-41904367">[-]</label><label class="expand" for="c-41904367">[1 more]</label></div><br/><div class="children"><div class="content">While this signature really looks atrocious, it doesn&#x27;t make the programmer experience bad at all, because all these parameters have default values. So it basically works as an interface with many options with convenient standard values and you can change only what you need.</div><br/></div></div><div id="41933076" class="c"><input type="checkbox" id="c-41933076" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#41904240">parent</a><span>|</span><a href="#41904367">prev</a><span>|</span><a href="#41932643">next</a><span>|</span><label class="collapse" for="c-41933076">[-]</label><label class="expand" for="c-41933076">[1 more]</label></div><br/><div class="children"><div class="content">A much better example for the issue with OOP gone wrong is the Spring framework:<p><a href="https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-framework&#x2F;docs&#x2F;current&#x2F;javadoc-api&#x2F;org&#x2F;springframework&#x2F;aop&#x2F;config&#x2F;SimpleBeanFactoryAwareAspectInstanceFactory.html" rel="nofollow">https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-framework&#x2F;docs&#x2F;current&#x2F;javadoc...</a></div><br/></div></div></div></div><div id="41932643" class="c"><input type="checkbox" id="c-41932643" checked=""/><div class="controls bullet"><span class="by">Hashex129542</span><span>|</span><a href="#41904240">prev</a><span>|</span><a href="#41904133">next</a><span>|</span><label class="collapse" for="c-41932643">[-]</label><label class="expand" for="c-41932643">[1 more]</label></div><br/><div class="children"><div class="content">I was actually fan of OOP languages particularly C++ &amp; Java but no improvements so far on the main stream programming languages. Still there are lot of improvements need to do. Still C occupies the first place.<p>PS: I really hate python style paradigm &amp; declarative programmings. Rust is top of my ignore list.</div><br/></div></div><div id="41904133" class="c"><input type="checkbox" id="c-41904133" checked=""/><div class="controls bullet"><span class="by">nashashmi</span><span>|</span><a href="#41932643">prev</a><span>|</span><a href="#41905865">next</a><span>|</span><label class="collapse" for="c-41904133">[-]</label><label class="expand" for="c-41904133">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Subtyping, where if a type B implements the public interface of type A, values of type B can be passed as A.<p>I am confused by this statement or it is going against what I understand.<p>If you have created a Type B variable, and you also have a new interface called A,  and B implements A, then why would Type B variable&#x27;s values be passed to A&#x27;s values.  &#x27;A&#x27; is only an interface.</div><br/><div id="41904321" class="c"><input type="checkbox" id="c-41904321" checked=""/><div class="controls bullet"><span class="by">Shywim</span><span>|</span><a href="#41904133">parent</a><span>|</span><a href="#41904300">next</a><span>|</span><label class="collapse" for="c-41904321">[-]</label><label class="expand" for="c-41904321">[2 more]</label></div><br/><div class="children"><div class="content">It says &quot;values of type B&quot;, as in &quot;instance of type B&quot;, can be passed as if they are &quot;instance of type A&quot; (which they are actually).<p>But yes, values inside B specific to type B will not be able to be accessed when manipulating the type A.</div><br/><div id="41904634" class="c"><input type="checkbox" id="c-41904634" checked=""/><div class="controls bullet"><span class="by">nashashmi</span><span>|</span><a href="#41904133">root</a><span>|</span><a href="#41904321">parent</a><span>|</span><a href="#41904300">next</a><span>|</span><label class="collapse" for="c-41904634">[-]</label><label class="expand" for="c-41904634">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. :)</div><br/></div></div></div></div><div id="41904300" class="c"><input type="checkbox" id="c-41904300" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41904133">parent</a><span>|</span><a href="#41904321">prev</a><span>|</span><a href="#41905865">next</a><span>|</span><label class="collapse" for="c-41904300">[-]</label><label class="expand" for="c-41904300">[2 more]</label></div><br/><div class="children"><div class="content">Passed &#x27;as&#x27; A, not passed &#x27;to&#x27; A.</div><br/><div id="41904620" class="c"><input type="checkbox" id="c-41904620" checked=""/><div class="controls bullet"><span class="by">nashashmi</span><span>|</span><a href="#41904133">root</a><span>|</span><a href="#41904300">parent</a><span>|</span><a href="#41905865">next</a><span>|</span><label class="collapse" for="c-41904620">[-]</label><label class="expand" for="c-41904620">[1 more]</label></div><br/><div class="children"><div class="content">That clears it up!</div><br/></div></div></div></div></div></div><div id="41905865" class="c"><input type="checkbox" id="c-41905865" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41904133">prev</a><span>|</span><a href="#41904488">next</a><span>|</span><label class="collapse" for="c-41905865">[-]</label><label class="expand" for="c-41905865">[4 more]</label></div><br/><div class="children"><div class="content">Dark Side has such powerful allure, such temptation; they are strong emotions that leave such indelible marks.<p>And I feel like code culture is one place in need of some checks, on it&#x27;s checking. There&#x27;s so many wide-ranging beers out there, prejudices. Some have fought those battles &amp; have real experience, speak from the heart. But I feel like over time the tribalisms that form, of passed down old biases, are usually more successful &amp; better magnets when they are anti- a thing than pro a thing.<p>JavaScript, PHP, Ruby, rust. Systemd, PipeWire, Wayland. Kubernetes. OOP, CORBA, SOAP. These are examples topics are all magnets for very strong disdain, that in various circles are accepted as bad.<p>It&#x27;s usually pretty easy to identify the darksiders. Theres almost never any principle of charity; they rarely see in greys, rarely even substantiate or enumerate their complaints at all. I&#x27;ve been struggling to find words, good words, for the disdain which doesn&#x27;t justify itself, which accepts it&#x27;s own premise, but the callous disregard &amp; trampling over a topic is something I would like very much to be a faux pas. Say what you mean, clearly, with arguments. Manage your emotional reactions. Don&#x27;t try to stir up antagonism. If you can, cultivate within yourself a sense of possibility &amp; appreciation, even if only for what <i>might</i> be. Principles of Charity. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principle_of_charity" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principle_of_charity</a><p>I&#x27;m forgetting what else to link, but around the aughts this anti- anti-social behavior has a bit of a boom. Two examples, <a href="https:&#x2F;&#x2F;marco.org&#x2F;2008&#x2F;05&#x2F;21&#x2F;jeff-atwood-who-knows-nothing-about-php-insults-php" rel="nofollow">https:&#x2F;&#x2F;marco.org&#x2F;2008&#x2F;05&#x2F;21&#x2F;jeff-atwood-who-knows-nothing-a...</a> <a href="https:&#x2F;&#x2F;steveklabnik.com&#x2F;writing&#x2F;matz-is-nice-so-we-are-nice&#x2F;" rel="nofollow">https:&#x2F;&#x2F;steveklabnik.com&#x2F;writing&#x2F;matz-is-nice-so-we-are-nice...</a><p>(And those on the pro side need to also have charity too.)<p>The idea of the Speaker For The Dead, someone who tries to paint clearly both upsides and downsides of a thing, is one I respect a lot &amp; want to see. A thing I wish we saw more of.<p>(I feel like I have a decent ability to see up and down sides to a lot of the techs I listed. One I&#x27;d like better illumination on, a speaker for the dead on: CORBA.)</div><br/><div id="41908896" class="c"><input type="checkbox" id="c-41908896" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41905865">parent</a><span>|</span><a href="#41933307">next</a><span>|</span><label class="collapse" for="c-41908896">[-]</label><label class="expand" for="c-41908896">[2 more]</label></div><br/><div class="children"><div class="content">I agree with the general sentiment of your comment and I think there are several factors at play here.<p>* The human brain is not capable of evaluating and re-evaluating every possible option amongst the plethora of technical choices developers are faced with. This forces us to develop certain coarse grained mental heuristics (prejudices and biases) to navigate technology, and even if these broad generalizations are roughly true initially, we tend not to re-evaluate them over time. This leads to stale biases (e.g. some library&#x2F;language was missing an API 10 years ago, and someone formed an immutable opinion on it).<p>* These broad generalizations lack nuance. I watched a talk recently by Dan Abramov where he calls these heuristics (I&#x27;m paraphrasing) a form of information compression [1]. That compression is <i>lossy</i> — it doesn&#x27;t preserve the original context in which the heuristic was formed.<p>* There&#x27;s also some insecurity at play here too. Developers want to believe that they&#x27;ve chosen The One True Solution, and harshly invalidating the alternatives is one way to reenforce that fantasy.<p>* And of course, social media has exacerbated this problem by rewarding inflammatory hot takes. You won&#x27;t get nearly as many views&#x2F;upvotes&#x2F;likes for a sober take that says &quot;technology X is well suited for this narrow use case&quot; as you will for a hot take that says &quot;why technology X failed&quot;, or &quot;why everyone hates technology X&quot;.<p>You might enjoy this link: <a href="https:&#x2F;&#x2F;blog.aurynn.com&#x2F;2015&#x2F;12&#x2F;16-contempt-culture" rel="nofollow">https:&#x2F;&#x2F;blog.aurynn.com&#x2F;2015&#x2F;12&#x2F;16-contempt-culture</a><p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=17KCHwOwgms" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=17KCHwOwgms</a></div><br/><div id="41933196" class="c"><input type="checkbox" id="c-41933196" checked=""/><div class="controls bullet"><span class="by">throwawayie6</span><span>|</span><a href="#41905865">root</a><span>|</span><a href="#41908896">parent</a><span>|</span><a href="#41933307">next</a><span>|</span><label class="collapse" for="c-41933196">[-]</label><label class="expand" for="c-41933196">[1 more]</label></div><br/><div class="children"><div class="content">I think a general lack of criticism also plays a part. When someone has decided that X is the best approach, they tend to point to blog articles that favour their point of view as &quot;proof&quot;, while dismissing other point of views as &quot;uninformed&quot;.<p>A typical example are all those &quot;We rewrote our service from X to Y and got huge benefits&quot; articles.<p>- They are ignoring the fact that the new version has the benefit of years of experience with the actual problem domain and can be optimized<p>- They also tend to use a different stack such as a more specialized database, async processing using message queues etc. that provides huge benefits.<p>Someone will always cherry pick some aspect of that article (language or choice of database) as proof that their point of view is correct, while ignoring the fact that they are not comparing an apple with an apple.<p>To get a real comparison they should have written a third system using their new architecture and the old langauge, but that would of course be hard to justify outside of academic research. The developers probably wouldn&#x27;t do it anyway, because if the old language proved just as effective it would be harder to justify why they chose a new language. Resumé Driven Development is unfortunately a real thing.</div><br/></div></div></div></div><div id="41933307" class="c"><input type="checkbox" id="c-41933307" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#41905865">parent</a><span>|</span><a href="#41908896">prev</a><span>|</span><a href="#41904488">next</a><span>|</span><label class="collapse" for="c-41933307">[-]</label><label class="expand" for="c-41933307">[1 more]</label></div><br/><div class="children"><div class="content">I was such a darksider once, definitely not any more, I don&#x27;t think there was anything other than gaining broad experience that changed me. I can see how specialization and too narrow focused experience would&#x27;ve resulted in me never changing. In conclusion, the wisdom is just to understand that opinions (including your own) are worthless, there is no real way to tell the objective difference between a good one and a bad one.<p>You can know the good and the bad, specifically about something, and that&#x27;s very useful, but even that list is always going to be incomplete and possibly cherry picked.</div><br/></div></div></div></div><div id="41904488" class="c"><input type="checkbox" id="c-41904488" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#41905865">prev</a><span>|</span><a href="#41904058">next</a><span>|</span><label class="collapse" for="c-41904488">[-]</label><label class="expand" for="c-41904488">[1 more]</label></div><br/><div class="children"><div class="content">I think this is really comparing programming without effects to programming with effects. If you want the benefits of using an effects system, you&#x27;ll have to work a little harder for them. If those benefits don&#x27;t matter to you, then the extra work is for nothing. The article assumes the second case, and doesn&#x27;t present it as a trade-off, but only as extra work for the same result, which is misleading.<p>So how could we compare OOP to FP in a way that evens out this difference? It depends on how you define FP.<p>You can (like this article seem to) restrict the definition of FP to only purely functional programming, in which a program cannot directly execute side effects, and must return a value representing the effects that the runtime system will then execute. Then an apples-to-apples comparison would compare the FP program with an OOP program that uses an effects system to manage its effects.<p>How do we do that? Well, if we define FP in a way that forces us to use effects, then the definition excludes a language like Scala, which is essentially a side-effecting OO imperative language that has features that enable FP-style programming. Scala isn&#x27;t FP by the article&#x27;s definition, because you can write impure code, but it <i>does</i> let you write programs that manage effects using an effects system. So you can do a reasonably fair comparison that way. I think you would discover that the pain of using effects is the same, if not greater, in an OO language where they have to be added as a framework.<p>Or you could define FP more broadly to include side-effecting languages like Clojure and F#, and you could compare a side-effecting OO program to a side-effecting FP program. This would be tricky because it would be very difficult to draw a style line between OOP and FP. Would you allow the FP program use OO constructs and the OO program to use FP constructs? If so, you might end up comparing two identical Scala programs. Would you ban the FP program from using OO constructs and ban the OO program from using FP constructs? In that case, you would get an OO program in the style of the 1990s or 2000s, which wouldn&#x27;t be fair to modern OOP.<p>I don&#x27;t think either choice really leads to a meaningful comparison between OOP and FP. I think comparisons have to be more specific to be meaningful, and they have to be in the context of a particular application, so you can fairly compare programs that use effects systems with ones that don&#x27;t. You can compare Java with Haskell for a particular application. You can compare C# with F# for a particular application. You can compare Scala with an effects system like Cats Effect to Scala without an effects system, again for a particular application. These comparisons are more realistic because you can take into account the pros and cons of using an effects system versus not for the given application.</div><br/></div></div><div id="41904058" class="c"><input type="checkbox" id="c-41904058" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41904488">prev</a><span>|</span><a href="#41903903">next</a><span>|</span><label class="collapse" for="c-41904058">[-]</label><label class="expand" for="c-41904058">[7 more]</label></div><br/><div class="children"><div class="content">Having chewed on this for a while now, my personal synthesis is this: The problem with OO is actually a problem with &quot;inheritance&quot; as the default tool you reach for. Get rid of that and you have what is effectively a different paradigm, with its own cost&#x2F;benefit tradeoffs.<p>Inheritance&#x27;s problem is not that it is &quot;intrinsically&quot; bad, but that it is <i>too big</i>. It is the primary tool for &quot;code reuse&quot; in an inheritance-based language, and it is <i>also</i> the primary tool for &quot;enforcing interfaces&quot; in an inheritance-based language.<p>However, these two things have no business being bound together like that. Not only do I quite often just want one but not the other, a criticism far more potent than the size of the text in this post making it indicates (this is a <i>huge</i> problem), the binding introduces its own brand new problem, the Liskov Substitution Principle, which in a nutshell is that any subclass must be able to be be <i>fully</i> substituted into any place where the superclass appears and not only &quot;function correctly&quot; but continue to maintain all properties of the superclass. This turns out to be <i>vastly</i> more limiting than most OO programmers realize, and they break it quite casually. And this is unfortunately one of those pernicious errors that doesn&#x27;t immediately crash the program and blow up, but corrodes not only the code base, but the <i>architecture</i> as you scale up. The architecture tends to develop such that it creates situations where LSP violations are forced. A simple example would be that you need to provide some instance of a deeply-inherited class in order to do some operation, but you need that functionality in a context that can not provide all the promises necessary to have an LSP-compliant class. As a simple example of <i>that</i>, imagine the class requires having some logging functionality but you can&#x27;t provide it for some reason, but you have to jam it in anyhow.<p>It is far better to uncouple these two things. Use interfaces&#x2F;traits&#x2F;whatever your language calls them that anything can conform to, and use functions for code reuse. Become comfortable with the idea that you may have to provide a &quot;default method&quot; implementation that other implementers may have to explicitly pick up once per data type rather than get &quot;automatically&quot; through a subclass inheritance. In my experience this turns out to happen a lot less than you&#x27;d think anyhow, but still, in general, I really suggest being comfortable with the idea that you can provide a lot of functionality through functions and composed objects and don&#x27;t strain to save users of that code one line of invocation or whatever.<p>Plus, getting rid of inheritance gets rid of the LSP, which turns out to be a really good thing since almost nobody is thinking about it or honoring it anyhow. I don&#x27;t mean that as a criticism against programmers, either; it&#x27;s honestly a rather twitchy principle in real life and in my opinion ignoring it is generally the right answer anyhow, for most people most of the time. But that becomes problematic when you&#x27;re working in a language that technically, secretly, without most people realizing it, actually <i>requires</i> it for scaling up.</div><br/><div id="41904194" class="c"><input type="checkbox" id="c-41904194" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#41904058">parent</a><span>|</span><a href="#41903903">next</a><span>|</span><label class="collapse" for="c-41904194">[-]</label><label class="expand" for="c-41904194">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Plus, getting rid of inheritance gets rid of the LSP<p>No it doesn&#x27;t.  Interfaces need to follow substitutability rules too.  Any type you substitute for another does, and that includes things like functions too.</div><br/><div id="41904357" class="c"><input type="checkbox" id="c-41904357" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41904058">root</a><span>|</span><a href="#41904194">parent</a><span>|</span><a href="#41904429">next</a><span>|</span><label class="collapse" for="c-41904357">[-]</label><label class="expand" for="c-41904357">[4 more]</label></div><br/><div class="children"><div class="content">It does, because it is no longer a matter of <i>substitutability</i>. You are not intrinsically taking an X and modifying it to become a Y while also being an X. You are now just providing an X, and another X, and another X, and another X over there. You need to maintain the constraints of the one interface you are satisfying, but you are not <i>also</i> maintaining the constraints of the superclass, and all of its superclasses. You <i>only</i> have the interface to worry about, only the one dimension, not two (or more, depending on how you count in multiple inheritance languages).<p>You also can do things like take a subset of the interface and have things that implement just that. You can&#x27;t do that to a class hierarchy; once a method is put in the hierarchy, it <i>must</i> be implemented by all children. (Note that if you&#x27;re jumping up to say &quot;But I can just implement an interface in Java or whatever if I want to do that&quot;, you&#x27;re agreeing with me, not disagreeing. That&#x27;s not a legal move in <i>inheritance</i>, though. Languages have been very, very slowly but very surely moving away from pure inheritance for a long time now.)<p>Having interfaces separated from reusability means you don&#x27;t have to worry about all these things at once, just the interface.</div><br/><div id="41905585" class="c"><input type="checkbox" id="c-41905585" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#41904058">root</a><span>|</span><a href="#41904357">parent</a><span>|</span><a href="#41904429">next</a><span>|</span><label class="collapse" for="c-41905585">[-]</label><label class="expand" for="c-41905585">[3 more]</label></div><br/><div class="children"><div class="content">I think trying to overformalize this by bringing in LSP might make it harder to understand and easier to nitpick. Another way to look at the same thing is that subclassing&#x2F;implementation inheritance is an extremely stringent but poorly enforced contract (yeah, also a kind of formalism) that&#x27;s, in your typical OO language, far too easy break without noticing.</div><br/><div id="41905930" class="c"><input type="checkbox" id="c-41905930" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41904058">root</a><span>|</span><a href="#41905585">parent</a><span>|</span><a href="#41904429">next</a><span>|</span><label class="collapse" for="c-41905930">[-]</label><label class="expand" for="c-41905930">[2 more]</label></div><br/><div class="children"><div class="content">Ironically, the fact that LSP is complicated and to a first approximation nobody understands it is a major part of my point.<p>(Or, if you prefer, LSP itself isn&#x27;t that complicated conceptually, but if you try to manifest it in reality it turns out to be very complicated in practice. Code makes a lot more guarantees than we think it does. See also <a href="https:&#x2F;&#x2F;hyrumslaw.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hyrumslaw.com&#x2F;</a> , which a very different view on the same phenomenon.)</div><br/><div id="41906112" class="c"><input type="checkbox" id="c-41906112" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41904058">root</a><span>|</span><a href="#41905930">parent</a><span>|</span><a href="#41904429">next</a><span>|</span><label class="collapse" for="c-41906112">[-]</label><label class="expand" for="c-41906112">[1 more]</label></div><br/><div class="children"><div class="content">I agree.  I think the LSP makes it essentially impossible to subclass a concrete superclass, because the subclass must retain all the observable behaviour of the superclass.  If it does so then what&#x27;s the point?  On the other hand, implementing an interface is fine.  Different implementations of the interface can just uphold the interface invariants without needing any relationship to each other.</div><br/></div></div></div></div></div></div></div></div><div id="41904429" class="c"><input type="checkbox" id="c-41904429" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41904058">root</a><span>|</span><a href="#41904194">parent</a><span>|</span><a href="#41904357">prev</a><span>|</span><a href="#41903903">next</a><span>|</span><label class="collapse" for="c-41904429">[-]</label><label class="expand" for="c-41904429">[1 more]</label></div><br/><div class="children"><div class="content">It is much harder to violate LSP by writing new code which simply adheres to an interface, than it is to violate by writing new code which is run <i>instead of the old code</i> (and all the old code&#x27;s side effects)</div><br/></div></div></div></div></div></div><div id="41903903" class="c"><input type="checkbox" id="c-41903903" checked=""/><div class="controls bullet"><span class="by">whobre</span><span>|</span><a href="#41904058">prev</a><span>|</span><label class="collapse" for="c-41903903">[-]</label><label class="expand" for="c-41903903">[1 more]</label></div><br/><div class="children"><div class="content">It’s pretty bad, actually. Especially the Smalltalk&#x2F;Objective-C flavor with its late binding and messages</div><br/></div></div></div></div></div></div></div></body></html>