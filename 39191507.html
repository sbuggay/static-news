<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706691660760" as="style"/><link rel="stylesheet" href="styles.css?v=1706691660760"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.philipzucker.com/cbmc_tut/">The C bounded model checker: criminally underused</a>Â <span class="domain">(<a href="https://www.philipzucker.com">www.philipzucker.com</a>)</span></div><div class="subtext"><span>philzook</span> | <span>83 comments</span></div><br/><div><div id="39194973" class="c"><input type="checkbox" id="c-39194973" checked=""/><div class="controls bullet"><span class="by">obl</span><span>|</span><a href="#39194805">next</a><span>|</span><label class="collapse" for="c-39194973">[-]</label><label class="expand" for="c-39194973">[41 more]</label></div><br/><div class="children"><div class="content">Weird that this treats uninitialized variables as unknown values. For example in ex3.c, the program<p><pre><code>  int main(){
      int x;
      if (x &lt;= 42){
              assert(x != 12345);
      }
  }
</code></pre>
is of course UB in C, even though under a &quot;uninitialized is random&quot; model the program is valid and does not assert (as the model checker concludes).<p>(even in O1 clang gets rid of the whole function, including even the ret instruction, I&#x27;m surprised it does not at least leave an ud2 for an empty function to help debugging since it would not cost anything <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;eK8cz3EPe" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;eK8cz3EPe</a> )</div><br/><div id="39195847" class="c"><input type="checkbox" id="c-39195847" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194973">parent</a><span>|</span><a href="#39200941">next</a><span>|</span><label class="collapse" for="c-39195847">[-]</label><label class="expand" for="c-39195847">[18 more]</label></div><br/><div class="children"><div class="content">Well, specifically, it counts uninitialized variables as being set to a non-deterministic value. The point of this tool isn&#x27;t to optimize functions as a compiler would, but rather to find bad behavior based on its machine model.<p>This isn&#x27;t perfect, of course. In this case, the compiler can rightly treat x as uninitialized, meaning that its value could be &lt;= 42 at one point, and not be &lt;= 42 at another point. Since the uninitialized variable isn&#x27;t &quot;pinned&quot;, it could technically be different values in different locations.<p>CBMC&#x27;s machine model works differently. In this case, x is assigned a non-deterministic value. The branch condition creates a refinement of this value within the scope of that statement. If the branch is taken, then by SMT rules, x can&#x27;t equal 12345, because it was already refined as being &lt;= 42.<p>On its own, a model checker can miss situations like these. It&#x27;s why I recommend -Wall -Werror -Wpedantic in conjunction with CBMC. The compiler should catch this as a warning, and it should be upgraded as an error.</div><br/><div id="39196123" class="c"><input type="checkbox" id="c-39196123" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195847">parent</a><span>|</span><a href="#39198740">next</a><span>|</span><label class="collapse" for="c-39196123">[-]</label><label class="expand" for="c-39196123">[8 more]</label></div><br/><div class="children"><div class="content">&gt; In this case, the compiler can rightly treat x as uninitialized, meaning that its value could be &lt;= 42 at one point, and not be &lt;= 42 at another point. Since the uninitialized variable isn&#x27;t &quot;pinned&quot;, it could technically be different values in different locations.<p>LLVM has a &quot;freeze&quot; command to stop propagation of undefined values (although I think that command was added later than the first version), so that the value is &quot;pinned&quot; as you say. However, the &quot;undef&quot; command, if you do not use &quot;freeze&quot;, will not do this.<p>I think that the C compiler should &quot;pin&quot; such undefined values where they are used, but I don&#x27;t know which compilers have an option to do this. (Perhaps CBMC should also have such a switch, so that you can use the same options that you will use with the C compiler.)<p>With this ex.3 file, the optimizer should be allowed to result in a function that does nothing and has an unspecified return value (which might or might not be the same each time it is executed). (If optimizations are disabled, then it should actually compile the conditional branch instruction.)</div><br/><div id="39196259" class="c"><input type="checkbox" id="c-39196259" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196123">parent</a><span>|</span><a href="#39198740">next</a><span>|</span><label class="collapse" for="c-39196259">[-]</label><label class="expand" for="c-39196259">[7 more]</label></div><br/><div class="children"><div class="content">This is one reason why I explored model checking machine code output, since at this point, the behavior is very much defined, even if it differs from implied source behavior. But, this gets complicated for other reasons.</div><br/><div id="39196409" class="c"><input type="checkbox" id="c-39196409" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196259">parent</a><span>|</span><a href="#39198740">next</a><span>|</span><label class="collapse" for="c-39196409">[-]</label><label class="expand" for="c-39196409">[6 more]</label></div><br/><div class="children"><div class="content">This is actually one of the reasons I&#x27;ve been tinkering with CBMC <a href="https:&#x2F;&#x2F;www.philipzucker.com&#x2F;pcode2c&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.philipzucker.com&#x2F;pcode2c&#x2F;</a> The idea is to use Ghidra to lift a specialized C interpreter of the machine code and then compare to source or ask other questions via CBMC</div><br/><div id="39196503" class="c"><input type="checkbox" id="c-39196503" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196409">parent</a><span>|</span><a href="#39198740">next</a><span>|</span><label class="collapse" for="c-39196503">[-]</label><label class="expand" for="c-39196503">[5 more]</label></div><br/><div class="children"><div class="content">This kind of analysis is excellent.<p>I do recommend standardizing on hardware and toolchain for projects like these, as it can ensure that the machine code is matched.<p>The third phase of my work will round the corner with machine code analysis. Currently, I&#x27;m working on constructive proofs and equivalence proofs of imported C code to handle the pieces that CBMC doesn&#x27;t do so well, as part of my second phase. So far, I can extract efficient C from Lean 4, but I want to import C directly into Lean 4 to prove it equivalent to extracted code. Hand-written C is easier to read than the line noise I can extract.<p>In particular, model checking doesn&#x27;t fare well with data structures, algorithms, and cryptography. These can be torn down quite a bit, and at least we can verify that the algorithms don&#x27;t leak memory or make bad integer assumptions. But, if we want to verify other properties, this requires constructive proofs.<p>Between 80 and 95 percent of the time, depending on the type of code being written, CBMC is enough. I&#x27;m now solving for that 5 - 20 percent of code that CBMC can&#x27;t easily tackle.</div><br/><div id="39200753" class="c"><input type="checkbox" id="c-39200753" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196503">parent</a><span>|</span><a href="#39196705">next</a><span>|</span><label class="collapse" for="c-39200753">[-]</label><label class="expand" for="c-39200753">[1 more]</label></div><br/><div class="children"><div class="content">&gt; model checking doesn&#x27;t fare well with data structures, algorithms, and cryptography<p>To the contrary, that&#x27;s what I&#x27;m using it for in most of my projects. It found interesting algorithmic bugs in my ctl find function (3-way comparison callback missing cases), is used to crack poor hashes. 
Also my tiny-regex matcher profited from it.<p>Also a lot of baremetal firmware.</div><br/></div></div><div id="39196705" class="c"><input type="checkbox" id="c-39196705" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196503">parent</a><span>|</span><a href="#39200753">prev</a><span>|</span><a href="#39198740">next</a><span>|</span><label class="collapse" for="c-39196705">[-]</label><label class="expand" for="c-39196705">[3 more]</label></div><br/><div class="children"><div class="content">ooooooh. link?<p>What do you mean by standardizing on hardware and toolchain? I am currently choosing ghidra and cbmc, and it seems like the approach is applicable to any compiler or arch that ghidra supports without too much change. I have only been doing x86-64 and gcc so far though</div><br/><div id="39196892" class="c"><input type="checkbox" id="c-39196892" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196705">parent</a><span>|</span><a href="#39196977">next</a><span>|</span><label class="collapse" for="c-39196892">[-]</label><label class="expand" for="c-39196892">[1 more]</label></div><br/><div class="children"><div class="content">Sadly, I don&#x27;t have a link for this yet. My goal is to write this up once I have a compelling example.<p>In the meantime, check out my github. <a href="https:&#x2F;&#x2F;github.com&#x2F;nanolith">https:&#x2F;&#x2F;github.com&#x2F;nanolith</a><p>Currently, I&#x27;m feeding commits into libcparse, which is the start of this effort. That stream is currently about 180 days out of phase with what&#x27;s in my local repositories, but it is slowly trickling in. The first step of this second phase will be to use libcparse to verify itself via constructive proofs in Lean. Currently, and by that I mean what hits in March or April, libcparse has a mostly C18 compliant lexical scanner for the C preprocessor. The goal is to have a SAX-like C18 parser that can detect all C declarations and definitions. Tooling will include a utility that imports C declarations and definitions into both Lean 4 and Coq. This is a moonlighting effort for an upcoming book I intend to write.</div><br/></div></div><div id="39196977" class="c"><input type="checkbox" id="c-39196977" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196705">parent</a><span>|</span><a href="#39196892">prev</a><span>|</span><a href="#39198740">next</a><span>|</span><label class="collapse" for="c-39196977">[-]</label><label class="expand" for="c-39196977">[1 more]</label></div><br/><div class="children"><div class="content">As for standardizing on hardware and toolchain, what I mean is that I try to get projects to commit to using specific hardware and a specific toolchain. The goal is to limit variables for automated testing and analysis.<p>OpenBSD, in particular, is adamant about testing their OS on real hardware for platforms that they support. Their definition of &quot;working&quot; is on real hardware. I think that&#x27;s a reasonable goal.<p>It helps with analysis like this, as you don&#x27;t have to worry about different compilers or different hardware. GCC, in particular, can produce different output depending on which hardware it was compiled on, unless a specific configuration is locked down. If there is a flaw in how it does vector operations on a particular Xeon processor, this won&#x27;t be caught if testing locally on a Core i5 processor that produces different code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39198740" class="c"><input type="checkbox" id="c-39198740" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195847">parent</a><span>|</span><a href="#39196123">prev</a><span>|</span><a href="#39198829">next</a><span>|</span><label class="collapse" for="c-39198740">[-]</label><label class="expand" for="c-39198740">[8 more]</label></div><br/><div class="children"><div class="content">Since any use of the variable is undefined behavior, that&#x27;s what we want to be informed about.<p>The reasoning about nondeterministic values should be spared for situations when it&#x27;s other than undefined behavior. For instance, accessing an uninitialized structure member that came from malloc isn&#x27;t undefined behavior. It&#x27;s (I think) unspecified behavior. In an implementation that has trap representations for some types, it could hit a trap.</div><br/><div id="39198912" class="c"><input type="checkbox" id="c-39198912" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39198740">parent</a><span>|</span><a href="#39200435">next</a><span>|</span><label class="collapse" for="c-39198912">[-]</label><label class="expand" for="c-39198912">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s understandable, and I would suggest reaching out to the CBMC developers. It shouldn&#x27;t be difficult to add an uninitialized variable pass to the solver.<p>Practically speaking, -Wall -Werror should catch this. Any use of a tool like CBMC should be part of a defense in depth strategy for code safety.<p>It does in clang.<p><pre><code>   $ cc -Wall -Werror bar.c
   bar.c:5:11: error: variable &#x27;x&#x27; is uninitialized when used here [-Werror,-Wuninitialized]
      if (x &lt;= 42){
          ^
   bar.c:4:12: note: initialize the variable &#x27;x&#x27; to silence this warning
      int x;
           ^
            = 0

   $ cc --version
   clang version 16.0.6
</code></pre>
It also does in gcc.<p><pre><code>   $ gcc -Wall -Werror bar.c
   bar.c: In function &#x27;main&#x27;:
   bar.c:5:10: error: &#x27;x&#x27; is used uninitialized [-Werror=uninitialized]
    5 |       if (x &lt;= 42){
      |          ^
   bar.c:4:11: note: &#x27;x&#x27; was declared here
    4 |       int x;
      |           ^
   cc1: all warnings being treated as errors

   $ gcc --version
   gcc 12.2.0</code></pre></div><br/><div id="39199753" class="c"><input type="checkbox" id="c-39199753" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39198912">parent</a><span>|</span><a href="#39200435">next</a><span>|</span><label class="collapse" for="c-39199753">[-]</label><label class="expand" for="c-39199753">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I would suggest reaching out to the CBMC developers</i><p>For something I don&#x27;t use?<p>How about this: I would suggest the CMBC developers read HN comments about their stuff, when it comes up.</div><br/><div id="39200647" class="c"><input type="checkbox" id="c-39200647" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39199753">parent</a><span>|</span><a href="#39200435">next</a><span>|</span><label class="collapse" for="c-39200647">[-]</label><label class="expand" for="c-39200647">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, notifying them directly would be too much effort.<p>The sensible way for developers to become aware of possible improvements they could make is for them to constantly scan the rest of the internet.</div><br/><div id="39200877" class="c"><input type="checkbox" id="c-39200877" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39200647">parent</a><span>|</span><a href="#39201523">next</a><span>|</span><label class="collapse" for="c-39200877">[-]</label><label class="expand" for="c-39200877">[2 more]</label></div><br/><div class="children"><div class="content">I do that! Some of my projects are packaged in distros. In the past, I&#x27;ve found discussions of problems among distro people, who didn&#x27;t contact upstream at all, but just tried to patch things on their own. I fixed things on my end, and in such a way that their patch would fail to apply when they update. No words exchanged at all.<p>I&#x27;m not a user of CMBC. I read about it here, I wrote a comment here, and that&#x27;s the end of it.<p>But for a minute I will bite. The submission has no link to the actual project. I found that by a web search.
 The project has no project trappings: no mailing list, or anything of the sort. The page says, &quot;For questions about CBMC, contact Daniel Kroening&quot;. The name is a link to his home page. His home page has no obvious contact information. There are links to papers; probably his e-mail address is given in some of them. Let&#x27;s click on &quot;A Tool for Checking ANSI-C Programs&quot;. Hey, e-mail links in that page, before we even get to the PDF. But ... from 2004.   Is k-----g@cs.cmu.edu from two decades ago going to work, given that he&#x27;s at Oxford?<p>Suppose I hunt down his current e-mail address. What do I say? &quot;Dear Sir, I feel really awkward to be contacting you about your CBMC program, <i>which I have never actually used</i>, but believe me when I say I have a valuable suggestion ...&quot;<p>If I used the thing, I&#x27;d fix it myself and send a patch!</div><br/><div id="39201390" class="c"><input type="checkbox" id="c-39201390" checked=""/><div class="controls bullet"><span class="by">pastage</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39200877">parent</a><span>|</span><a href="#39201523">next</a><span>|</span><label class="collapse" for="c-39201390">[-]</label><label class="expand" for="c-39201390">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I have had luck mailing old research emails, I read my 20 year old university email. It is one of the best signal to noise ratios in communications I have.<p>I would not mail if it is only about unintialized variables.</div><br/></div></div></div></div><div id="39201523" class="c"><input type="checkbox" id="c-39201523" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39200647">parent</a><span>|</span><a href="#39200877">prev</a><span>|</span><a href="#39200435">next</a><span>|</span><label class="collapse" for="c-39201523">[-]</label><label class="expand" for="c-39201523">[1 more]</label></div><br/><div class="children"><div class="content">People can comment on a project in public discussion forums without then also having a responsibility to become a contributor to the project.</div><br/></div></div></div></div></div></div></div></div><div id="39200435" class="c"><input type="checkbox" id="c-39200435" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39198740">parent</a><span>|</span><a href="#39198912">prev</a><span>|</span><a href="#39198829">next</a><span>|</span><label class="collapse" for="c-39200435">[-]</label><label class="expand" for="c-39200435">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Since any use of the variable is undefined behavior</i><p>use of the variable as an lvalue is not undefined</div><br/></div></div></div></div><div id="39198829" class="c"><input type="checkbox" id="c-39198829" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195847">parent</a><span>|</span><a href="#39198740">prev</a><span>|</span><a href="#39200941">next</a><span>|</span><label class="collapse" for="c-39198829">[-]</label><label class="expand" for="c-39198829">[1 more]</label></div><br/><div class="children"><div class="content">Recall trying to find some fun bugs caused by uninitialized memory, which was made harder to find due to the fact that the debug runtime zeroed memory allocations while the release runtime did not.</div><br/></div></div></div></div><div id="39200941" class="c"><input type="checkbox" id="c-39200941" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#39194973">parent</a><span>|</span><a href="#39195847">prev</a><span>|</span><a href="#39195116">next</a><span>|</span><label class="collapse" for="c-39200941">[-]</label><label class="expand" for="c-39200941">[1 more]</label></div><br/><div class="children"><div class="content">Uninitialized local variables are documented as a source of a certain type of nondeterminism: <a href="http:&#x2F;&#x2F;www.cprover.org&#x2F;cprover-manual&#x2F;modeling&#x2F;nondeterminism&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.cprover.org&#x2F;cprover-manual&#x2F;modeling&#x2F;nondeterminis...</a><p>So the checker treats them as defined, but with an unknown variable. You could have written this instead:<p><pre><code>    extern int unknown_int_value(void);
    int x = unknown_int_value();
</code></pre>
And leaving unknown_int_value undefined (so it&#x27;s not visible to the analyzer). Or write a function and use x as a parameter.<p>I suspect CBMC does this to have a convenient syntax for this frequent scenario. Apparently, it&#x27;s used quite often, as in these examples: <a href="https:&#x2F;&#x2F;model-checking.github.io&#x2F;cbmc-training&#x2F;cbmc&#x2F;overview&#x2F;proof.html" rel="nofollow">https:&#x2F;&#x2F;model-checking.github.io&#x2F;cbmc-training&#x2F;cbmc&#x2F;overview...</a><p>It seems that CBMC is not intended to check production sources directly against C semantics, but to prove things about programs written in a C-like syntax.</div><br/></div></div><div id="39195116" class="c"><input type="checkbox" id="c-39195116" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194973">parent</a><span>|</span><a href="#39200941">prev</a><span>|</span><a href="#39194805">next</a><span>|</span><label class="collapse" for="c-39195116">[-]</label><label class="expand" for="c-39195116">[21 more]</label></div><br/><div class="children"><div class="content">I see the calling an undefined prototype style more often, perhaps for this reason.  You are probably right this is undefined behavior, but it&#x27;s subtle. <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;11962457&#x2F;why-is-using-an-uninitialized-variable-undefined-behavior" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;11962457&#x2F;why-is-using-an...</a> I suspect CBMC just picks some concrete behavior for undefined behavior. It may not be a good detector for that. I&#x27;m not sure. This gets into shaky territory of understanding for me.</div><br/><div id="39195192" class="c"><input type="checkbox" id="c-39195192" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195116">parent</a><span>|</span><a href="#39195249">next</a><span>|</span><label class="collapse" for="c-39195192">[-]</label><label class="expand" for="c-39195192">[19 more]</label></div><br/><div class="children"><div class="content">Speaking as a compiler writer:<p>Any invocation of undefined behavior should be considered an assertion failure as far as any model checker should be concerned. Compilers can--<i>and will</i>--treat undefined behavior as license to alter the semantics of your program without any constraint, and most instances of undefined behavior are clearly programmer error (there is no good reason to read uninitialized memory, for example).<p>Reading an uninitialized variable is <i>not</i> &quot;subtle&quot; undefined behavior. It&#x27;s one of the most readily accessible examples not only of what undefined behavior can exist, but also the ways compilers will mutilate your code just because you did it. To be honest, if something as simple as the consequences of reading uninitialized memory are shaky understanding for someone trying to prove code correct, that will completely undermine any trust I have in the validity of your proofs.</div><br/><div id="39195475" class="c"><input type="checkbox" id="c-39195475" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195192">parent</a><span>|</span><a href="#39200985">next</a><span>|</span><label class="collapse" for="c-39195475">[-]</label><label class="expand" for="c-39195475">[10 more]</label></div><br/><div class="children"><div class="content">Also, even <i>if</i> the compiler does what a &quot;Real programmer&quot; type thinks it &quot;should&quot; do for this case (and I agree with you that you&#x27;re not entitled to expect that), you aren&#x27;t guaranteed that there&#x27;s some particular value since you never initialized it.<p>Your operating system likely feels entitled to assume that if you never wrote to this page of RAM you don&#x27;t care what exactly is in it. After all what kind of lunatic <i>reads</i> a bunch of unknown data, says &quot;Yeah, that&#x27;s coincidentally what I wanted&quot; and just leaves it unmodified? No, almost anybody would <i>write</i> data they want to keep instead. So, if you never wrote to this particular page of RAM and your OS finds it convenient to swap that page for a different one, no harm no foul right? But now the contents of your uninitialized variable changed!</div><br/><div id="39195820" class="c"><input type="checkbox" id="c-39195820" checked=""/><div class="controls bullet"><span class="by">addaon</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195475">parent</a><span>|</span><a href="#39195837">next</a><span>|</span><label class="collapse" for="c-39195820">[-]</label><label class="expand" for="c-39195820">[6 more]</label></div><br/><div class="children"><div class="content">&gt; So, if you never wrote to this particular page of RAM and your OS finds it convenient to swap that page for a different one, no harm no foul right? But now the contents of your uninitialized variable changed!<p>No sane OS will do this. Any page that&#x27;s handed to a process that was last written by a different process must be zero&#x27;d (or otherwise have every address initialized) by the OS to avoid leaking information across process boundaries. You could, in theory, have a page that was munmap&#x27;d by &#x2F;this&#x2F; process be handed back to the same process to fill a request for a different virtual address without zeroing it, but I can&#x27;t imagine that any OS tracks the last writer to enable this &quot;optimization&quot; in the few cases it would apply.</div><br/><div id="39196049" class="c"><input type="checkbox" id="c-39196049" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195820">parent</a><span>|</span><a href="#39195837">next</a><span>|</span><label class="collapse" for="c-39196049">[-]</label><label class="expand" for="c-39196049">[5 more]</label></div><br/><div class="children"><div class="content">glibc marks freed pages with MADV_FREE, and on Linux, an MADV_FREE page won&#x27;t be unmapped immediately. It&#x27;s possible to read a value of an MADV_FREE&#x27;d page, have Linux swap the page out, and then read it again and now observe a zero-init&#x27;d page. If malloc returns a new allocation to a freed page, it isn&#x27;t written to by the allocator (which would prevent the page from being subsequently zeroed if it hasn&#x27;t already done so), so it doesn&#x27;t guarantee that the contents won&#x27;t be randomly zeroed.<p>Whether or not this is a sane OS I leave an exercise to the reader, but it is nonetheless the property of a common OS.</div><br/><div id="39197351" class="c"><input type="checkbox" id="c-39197351" checked=""/><div class="controls bullet"><span class="by">addaon</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196049">parent</a><span>|</span><a href="#39198177">next</a><span>|</span><label class="collapse" for="c-39197351">[-]</label><label class="expand" for="c-39197351">[1 more]</label></div><br/><div class="children"><div class="content">&gt; glibc marks freed pages with MADV_FREE, and on Linux, an MADV_FREE page won&#x27;t be unmapped immediately. It&#x27;s possible to read a value of an MADV_FREE&#x27;d page, have Linux swap the page out, and then read it again and now observe a zero-init&#x27;d page. If malloc returns a new allocation to a freed page, it isn&#x27;t written to by the allocator (which would prevent the page from being subsequently zeroed if it hasn&#x27;t already done so), so it doesn&#x27;t guarantee that the contents won&#x27;t be randomly zeroed.<p>Oh.<p>I feel like I should have more to say than that, but... oh.</div><br/></div></div><div id="39198177" class="c"><input type="checkbox" id="c-39198177" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196049">parent</a><span>|</span><a href="#39197351">prev</a><span>|</span><a href="#39195837">next</a><span>|</span><label class="collapse" for="c-39198177">[-]</label><label class="expand" for="c-39198177">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t that be canceled by the read fault?<p>(there&#x27;s also <i>usually</i> a write, unless the allocation-head-metadata is on a different page than the parts of the allocation you&#x27;re acting spooky with)<p>Edit: after watching the video elsewhere in thread, it was indeed crossing page boundary, but that behavior has to be a kernel bug since the documentation says &quot;accesses&quot; are sufficient to repopulate it.</div><br/><div id="39198338" class="c"><input type="checkbox" id="c-39198338" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39198177">parent</a><span>|</span><a href="#39195837">next</a><span>|</span><label class="collapse" for="c-39198338">[-]</label><label class="expand" for="c-39198338">[2 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s specifically a write that causes the page to actually be freed. Per the man page:<p>&gt; However, subsequent writes to pages in the range will succeed and then kernel cannot free those dirtied pages, so that the caller can always see just written data.  If there is no subsequent write, the  kernel  can free  the  pages at any time.  Once pages in the range have been freed, the caller will see zero-fill-on-demand pages upon subsequent page references.</div><br/><div id="39198391" class="c"><input type="checkbox" id="c-39198391" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39198338">parent</a><span>|</span><a href="#39195837">next</a><span>|</span><label class="collapse" for="c-39198391">[-]</label><label class="expand" for="c-39198391">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I mixed up MADV_DONTNEED (which is older) with MADV_FREE.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39195837" class="c"><input type="checkbox" id="c-39195837" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195475">parent</a><span>|</span><a href="#39195820">prev</a><span>|</span><a href="#39200985">next</a><span>|</span><label class="collapse" for="c-39195837">[-]</label><label class="expand" for="c-39195837">[3 more]</label></div><br/><div class="children"><div class="content">Neither Linux nor Windows have this sort of uninitialized memory, and it would be quite the security hole if they did.<p>In general, the things your compiler thinks are UB are not the same things your OS or CPU thinks are undefined.</div><br/><div id="39196634" class="c"><input type="checkbox" id="c-39196634" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195837">parent</a><span>|</span><a href="#39200985">next</a><span>|</span><label class="collapse" for="c-39196634">[-]</label><label class="expand" for="c-39196634">[2 more]</label></div><br/><div class="children"><div class="content">At least Linux does this, and it is not a security hole because it only reuses pages with memory of the current process (as in the worst case you end up reading data from some other part of your program, but not other programs).<p>And yes, it does happen in practice, most famously it has been mentioned in the &quot;The strange details of std::string at Facebook&quot; talk at CppCon 2016 <a href="https:&#x2F;&#x2F;youtu.be&#x2F;kPR8h4-qZdk?t=1150&amp;si=2R358wniZfxTJLmc" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;kPR8h4-qZdk?t=1150&amp;si=2R358wniZfxTJLmc</a></div><br/><div id="39198270" class="c"><input type="checkbox" id="c-39198270" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39196634">parent</a><span>|</span><a href="#39200985">next</a><span>|</span><label class="collapse" for="c-39198270">[-]</label><label class="expand" for="c-39198270">[1 more]</label></div><br/><div class="children"><div class="content">After watching, that <i>has</i> to be a kernel bug, since the documentation says &quot;accesses&quot; will cause repopulation, not &quot;writes&quot;.<p>Edit: nevermind, I mixed up MADV_DONTNEED with MADV_FREE</div><br/></div></div></div></div></div></div></div></div><div id="39200985" class="c"><input type="checkbox" id="c-39200985" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195192">parent</a><span>|</span><a href="#39195475">prev</a><span>|</span><a href="#39197709">next</a><span>|</span><label class="collapse" for="c-39200985">[-]</label><label class="expand" for="c-39200985">[2 more]</label></div><br/><div class="children"><div class="content">&gt; there is no good reason to read uninitialized memory, for example<p>That&#x27;s an assumption on your part.<p>One very good reason might be to ensure that memory really is there given the optimistic allocation schemes and to force a page to be read into core. You could also write to it to get the same effect. Another good reason to do a read on uninitialized memory is to see what&#x27;s still there from the previous program that ran. Now arguably that&#x27;s a nefarious reason but it is still a good one and it may help uncover bugs in the underlying system.</div><br/><div id="39201176" class="c"><input type="checkbox" id="c-39201176" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39200985">parent</a><span>|</span><a href="#39197709">next</a><span>|</span><label class="collapse" for="c-39201176">[-]</label><label class="expand" for="c-39201176">[1 more]</label></div><br/><div class="children"><div class="content">The code doesn&#x27;t read uninitialized memory.  Automatic storage of objects need not be in memory.  The C99 standard only uses the word &quot;memory&quot; in normative sections when talking about &quot;malloc&quot;</div><br/></div></div></div></div><div id="39197709" class="c"><input type="checkbox" id="c-39197709" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195192">parent</a><span>|</span><a href="#39200985">prev</a><span>|</span><a href="#39195305">next</a><span>|</span><label class="collapse" for="c-39197709">[-]</label><label class="expand" for="c-39197709">[3 more]</label></div><br/><div class="children"><div class="content">The problem is that uninitialized memory really <i>is</i> subtle.
After initializing all members of a struct, the padding bytes of that struct are still uninitialized. Yet, it is valid to memcpy the whole struct somewhere else; even with a hand-written char*-based copying loop. (and indeed, this is a good reason for reading uninitialized memory!)
So reading uninitialized memory is not always undefined behavior; just most of the time.<p>The C standard text is barely sufficient for the purposes of compilers, but wholly insufficient for what a model checker would need to know.</div><br/><div id="39199631" class="c"><input type="checkbox" id="c-39199631" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39197709">parent</a><span>|</span><a href="#39198154">next</a><span>|</span><label class="collapse" for="c-39199631">[-]</label><label class="expand" for="c-39199631">[1 more]</label></div><br/><div class="children"><div class="content">&gt; After initializing all members of a struct, the padding bytes of that struct are still uninitialized.<p>Depends on how you initialize them. If you do it all in one go, then yes. If you partially initialize it, then no: some of the padding bytes are guaranteed to be zero. (Observing this and maintaining this variant is an exercise for the reader.)</div><br/></div></div><div id="39198154" class="c"><input type="checkbox" id="c-39198154" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39197709">parent</a><span>|</span><a href="#39199631">prev</a><span>|</span><a href="#39195305">next</a><span>|</span><label class="collapse" for="c-39198154">[-]</label><label class="expand" for="c-39198154">[1 more]</label></div><br/><div class="children"><div class="content">For reference, GCC has `__builtin_clear_padding` which is very useful to avoid problems there.</div><br/></div></div></div></div><div id="39195305" class="c"><input type="checkbox" id="c-39195305" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195192">parent</a><span>|</span><a href="#39197709">prev</a><span>|</span><a href="#39195249">next</a><span>|</span><label class="collapse" for="c-39195305">[-]</label><label class="expand" for="c-39195305">[3 more]</label></div><br/><div class="children"><div class="content">Yes, I do not trust my understanding of C. Which is why I want mechanized assistance.</div><br/><div id="39195454" class="c"><input type="checkbox" id="c-39195454" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195305">parent</a><span>|</span><a href="#39195249">next</a><span>|</span><label class="collapse" for="c-39195454">[-]</label><label class="expand" for="c-39195454">[2 more]</label></div><br/><div class="children"><div class="content">I apologize for using the word subtle. What I should have said is I don&#x27;t understand the topic and reading about it has left me a sense that one should be very careful.</div><br/><div id="39200999" class="c"><input type="checkbox" id="c-39200999" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195454">parent</a><span>|</span><a href="#39195249">next</a><span>|</span><label class="collapse" for="c-39200999">[-]</label><label class="expand" for="c-39200999">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re spot on. The CVE lists are filled with people who thought they understood this stuff better than they really did.</div><br/></div></div></div></div></div></div></div></div><div id="39195249" class="c"><input type="checkbox" id="c-39195249" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194973">root</a><span>|</span><a href="#39195116">parent</a><span>|</span><a href="#39195192">prev</a><span>|</span><a href="#39194805">next</a><span>|</span><label class="collapse" for="c-39195249">[-]</label><label class="expand" for="c-39195249">[1 more]</label></div><br/><div class="children"><div class="content">For undefined behavior detection, I have heard of these:<p>- UB sanitizer <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;UndefinedBehaviorSanitizer.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;UndefinedBehaviorSanitizer.html</a><p>- Cerberus Semantics <a href="https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;~pes20&#x2F;cerberus&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;~pes20&#x2F;cerberus&#x2F;</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kframework&#x2F;c-semantics">https:&#x2F;&#x2F;github.com&#x2F;kframework&#x2F;c-semantics</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;TrustInSoft&#x2F;tis-interpreter">https:&#x2F;&#x2F;github.com&#x2F;TrustInSoft&#x2F;tis-interpreter</a></div><br/></div></div></div></div></div></div><div id="39194805" class="c"><input type="checkbox" id="c-39194805" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39194973">prev</a><span>|</span><a href="#39194699">next</a><span>|</span><label class="collapse" for="c-39194805">[-]</label><label class="expand" for="c-39194805">[11 more]</label></div><br/><div class="children"><div class="content">Nice but can you run it on non-toy programs?<p>I gave a talk about Frama-C a few years ago.  It&#x27;s very interesting technology, but not too useful at any scale  (<a href="http:&#x2F;&#x2F;oirase.annexia.org&#x2F;tmp&#x2F;2020-frama-c-tech-talk.mp4" rel="nofollow">http:&#x2F;&#x2F;oirase.annexia.org&#x2F;tmp&#x2F;2020-frama-c-tech-talk.mp4</a>)  One aim we had with Bounds Checking GCC back in &#x27;95 was to make it possible to use with real programs.  Although it was quite slow, any open source program of the era could use it (<a href="https:&#x2F;&#x2F;www.doc.ic.ac.uk&#x2F;~phjk&#x2F;BoundsChecking.html" rel="nofollow">https:&#x2F;&#x2F;www.doc.ic.ac.uk&#x2F;~phjk&#x2F;BoundsChecking.html</a>).</div><br/><div id="39195586" class="c"><input type="checkbox" id="c-39195586" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194805">parent</a><span>|</span><a href="#39200832">next</a><span>|</span><label class="collapse" for="c-39195586">[-]</label><label class="expand" for="c-39195586">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used CBMC in large commercial projects ranging around half a million lines of code. The secret is to break down every one of those functions into small pieces that the model checker can analyze.<p>CBMC works best with a contract-based programming style, where contracts are enforced by assertions and shadow functions exist to simplify model checking.<p>A single reply on HN is hardly a place where idiomatic styles can be expounded, but it is quite possible to build a resource-oriented idiomatic style that is reinforced with CBMC.</div><br/><div id="39195815" class="c"><input type="checkbox" id="c-39195815" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194805">root</a><span>|</span><a href="#39195586">parent</a><span>|</span><a href="#39200832">next</a><span>|</span><label class="collapse" for="c-39195815">[-]</label><label class="expand" for="c-39195815">[4 more]</label></div><br/><div class="children"><div class="content">I would love to hear more</div><br/><div id="39196026" class="c"><input type="checkbox" id="c-39196026" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194805">root</a><span>|</span><a href="#39195815">parent</a><span>|</span><a href="#39200832">next</a><span>|</span><label class="collapse" for="c-39196026">[-]</label><label class="expand" for="c-39196026">[3 more]</label></div><br/><div class="children"><div class="content">In particular, one of the more important rules I made when using CBMC was to keep the search depth for each invocation as shallow as possible. If CBMC runs in less than five minutes, you&#x27;re doing it right. If it takes more than that, then you&#x27;re asking it to do too much.<p>This led to the creation of function contracts and shadow functions. When evaluating functions, we actually want any calls that it makes to go to shadow functions instead of real functions. When we write a function, we include a contract that includes anything it may return, any side-effects it may have, and any memory it may touch &#x2F; allocate &#x2F; initialize. We then write a twin function -- its shadow function -- that technically follows the same contract in the most simplified terms, randomly choosing whether to succeed or fail. From CBMC&#x27;s perspective, it&#x27;s equivalent enough for model checking. But, it removes additional stack depth or recursion.<p>A good example of this would be a shadow function for the POSIX read function. Its contract should verify that the descriptor it is passed is valid. It should also assert that the memory region it is passed is bounded by the size it is given. The shadow function picks a non-deterministic state based on how it should set errno and how it should return. This state follows the POSIX standard, but the underlying system calls don&#x27;t matter. Likewise, depending on the return code, it should initialize a number of bytes in the read buffer with non-deterministic values.<p>I used this shadow read function to find a buffer overflow in networking code and also to find a DOS infinite loop error in a tagged binary file format reader we were using.<p>CBMC isn&#x27;t perfect, but when coupled with a good linter and -Wall &#x2F; -Werror &#x2F; -Wpedantic, it is a very useful layer in a defense in depth strategy for safer software.</div><br/><div id="39196969" class="c"><input type="checkbox" id="c-39196969" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39194805">root</a><span>|</span><a href="#39196026">parent</a><span>|</span><a href="#39200832">next</a><span>|</span><label class="collapse" for="c-39196969">[-]</label><label class="expand" for="c-39196969">[2 more]</label></div><br/><div class="children"><div class="content">&gt; CBMC isn&#x27;t perfect, but when coupled with a good linter and -Wall &#x2F; -Werror &#x2F; -Wpedantic, it is a very useful layer in a defense in depth strategy for safer software.<p>I agree to a certain extent, but at what point are you putting in more effort than it would take to migrate to a stricter language that offers more safety by default?</div><br/><div id="39197070" class="c"><input type="checkbox" id="c-39197070" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194805">root</a><span>|</span><a href="#39196969">parent</a><span>|</span><a href="#39200832">next</a><span>|</span><label class="collapse" for="c-39197070">[-]</label><label class="expand" for="c-39197070">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not aware of any language that can&#x27;t be improved by this strategy. Amazon even added SMT solving tooling around Rust, because Rust&#x27;s built-in safety guarantees aren&#x27;t enough.<p>I&#x27;d say that the added effort is minimal. The compiler spits out more errors. We think a little more carefully about how we write functions so CBMC doesn&#x27;t complain. There are no silver bullets.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39200832" class="c"><input type="checkbox" id="c-39200832" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#39194805">parent</a><span>|</span><a href="#39195586">prev</a><span>|</span><a href="#39194959">next</a><span>|</span><label class="collapse" for="c-39200832">[-]</label><label class="expand" for="c-39200832">[1 more]</label></div><br/><div class="children"><div class="content">Klee (another tool mentioned in TFA) was run successfully against unmodified versions of all GNU textutils (or maybe it was coreutils... in any case, except for GNU sort, which was tricky due to large dynamically allocated buffers), and found bugs in quite a number of them.</div><br/></div></div><div id="39194959" class="c"><input type="checkbox" id="c-39194959" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#39194805">parent</a><span>|</span><a href="#39200832">prev</a><span>|</span><a href="#39194848">next</a><span>|</span><label class="collapse" for="c-39194959">[-]</label><label class="expand" for="c-39194959">[1 more]</label></div><br/><div class="children"><div class="content">One of the examples they gave was an HTTP client, which would be a surprisingly non-toy example, so I looked at what they actually did in the code (<a href="https:&#x2F;&#x2F;github.com&#x2F;FreeRTOS&#x2F;coreHTTP&#x2F;tree&#x2F;main&#x2F;test&#x2F;cbmc">https:&#x2F;&#x2F;github.com&#x2F;FreeRTOS&#x2F;coreHTTP&#x2F;tree&#x2F;main&#x2F;test&#x2F;cbmc</a>).<p>Not that I&#x27;m an expert in processing what exactly is being tested, but it basically looks only able to prove that an individual function doesn&#x27;t overrun buffers. If you tell it to assume that integer overflows can&#x27;t happen (!). So I&#x27;m not impressed.</div><br/></div></div><div id="39194848" class="c"><input type="checkbox" id="c-39194848" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194805">parent</a><span>|</span><a href="#39194959">prev</a><span>|</span><a href="#39194699">next</a><span>|</span><label class="collapse" for="c-39194848">[-]</label><label class="expand" for="c-39194848">[3 more]</label></div><br/><div class="children"><div class="content">Non trivial example projects <a href="https:&#x2F;&#x2F;model-checking.github.io&#x2F;cbmc-training&#x2F;projects.html" rel="nofollow">https:&#x2F;&#x2F;model-checking.github.io&#x2F;cbmc-training&#x2F;projects.html</a>
Some crypto, AWS common C, FreeRTOS. Other interesting applications <a href="https:&#x2F;&#x2F;www.cprover.org&#x2F;cbmc&#x2F;applications&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cprover.org&#x2F;cbmc&#x2F;applications&#x2F;</a></div><br/><div id="39194967" class="c"><input type="checkbox" id="c-39194967" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194805">root</a><span>|</span><a href="#39194848">parent</a><span>|</span><a href="#39194699">next</a><span>|</span><label class="collapse" for="c-39194967">[-]</label><label class="expand" for="c-39194967">[2 more]</label></div><br/><div class="children"><div class="content">Frama-C is also very cool. Also Coq VST and however seL4 does it. I think out of all of these, CBMC requires the least expertise &#x2F; has highest automation. I also don&#x27;t see how it can scale beyond the unit test level, or patch together verification conditions into global properties. Perhaps this could be done by some meta framework plugging together calls to CBMC. Given the level of penetration of formal methods generally, I think the relatively low ambition of CBMC compared to these higher ceiling techniques is good.</div><br/><div id="39195300" class="c"><input type="checkbox" id="c-39195300" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39194805">root</a><span>|</span><a href="#39194967">parent</a><span>|</span><a href="#39194699">next</a><span>|</span><label class="collapse" for="c-39195300">[-]</label><label class="expand" for="c-39195300">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, very interesting stuff!</div><br/></div></div></div></div></div></div></div></div><div id="39194699" class="c"><input type="checkbox" id="c-39194699" checked=""/><div class="controls bullet"><span class="by">gaudat</span><span>|</span><a href="#39194805">prev</a><span>|</span><a href="#39198698">next</a><span>|</span><label class="collapse" for="c-39194699">[-]</label><label class="expand" for="c-39194699">[2 more]</label></div><br/><div class="children"><div class="content">I miss this kind of stuff in computer programming languages.<p>In hardware design, verification is done simultaneously with design, and semiconductor companies would be bankrupt if they did not verify the hell out of their designs before committing millions in manufacturing these chips.<p>Even among hobbyists this is getting traction with yosys.perhaps its time for programmers to adapt this kind of tooling so there will be less buggy software released...</div><br/><div id="39195348" class="c"><input type="checkbox" id="c-39195348" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#39194699">parent</a><span>|</span><a href="#39198698">next</a><span>|</span><label class="collapse" for="c-39195348">[-]</label><label class="expand" for="c-39195348">[1 more]</label></div><br/><div class="children"><div class="content">There are probably orders of magnitude in difference between hardware design output and programming output. At least at the time, seL4&#x27;s verification was quite impressive for a codebase on the order of 10,000 lines. But we should work towards the goal of improved formal modelling and checking all the same.</div><br/></div></div></div></div><div id="39198698" class="c"><input type="checkbox" id="c-39198698" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39194699">prev</a><span>|</span><a href="#39195886">next</a><span>|</span><label class="collapse" for="c-39198698">[-]</label><label class="expand" for="c-39198698">[2 more]</label></div><br/><div class="children"><div class="content">The most important thing about this:<p><pre><code>  int x;

  if (x &lt; 42) { assert (x != 12345); }
</code></pre>
isn&#x27;t to have a checker is clever enough to know that the assert will not go off, but to be informed that the automatic variable <i>x</i> is being accessed without being initialized!!!</div><br/><div id="39201542" class="c"><input type="checkbox" id="c-39201542" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#39198698">parent</a><span>|</span><a href="#39195886">next</a><span>|</span><label class="collapse" for="c-39201542">[-]</label><label class="expand" for="c-39201542">[1 more]</label></div><br/><div class="children"><div class="content">To repurpose an old meme...<p>Intelligence is knowing that the assert will never go off.<p>Wisdom is knowing that it might.</div><br/></div></div></div></div><div id="39195886" class="c"><input type="checkbox" id="c-39195886" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#39198698">prev</a><span>|</span><a href="#39194907">next</a><span>|</span><label class="collapse" for="c-39195886">[-]</label><label class="expand" for="c-39195886">[2 more]</label></div><br/><div class="children"><div class="content">&gt; however runs all possible executions,<p>No, it does not. It probably does constraint based verification or looks for &quot;proofs&quot; of possible error conditions or asserts. In the case shown, an uninitialized variable is trivial to prove that it could equal the asseted value.</div><br/><div id="39195998" class="c"><input type="checkbox" id="c-39195998" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39195886">parent</a><span>|</span><a href="#39194907">next</a><span>|</span><label class="collapse" for="c-39195998">[-]</label><label class="expand" for="c-39195998">[1 more]</label></div><br/><div class="children"><div class="content">Yes, correct. It does not and could not _actually_ run all possible executions unless the program state space is quite small. But from a user&#x27;s perspective, it is similar. I have tried this pedagogical approach to describing verifiers like these as &quot;infinite&quot; unit tests before (to mixed results). It feels to me that what  symbolic or constraint based reasoning (algebraic identities, programs, integrals, what have you) in general is doing is finding a way to finitely reason about a very large or actually infinite number of concretized cases.</div><br/></div></div></div></div><div id="39194907" class="c"><input type="checkbox" id="c-39194907" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39195886">prev</a><span>|</span><a href="#39195801">next</a><span>|</span><label class="collapse" for="c-39194907">[-]</label><label class="expand" for="c-39194907">[20 more]</label></div><br/><div class="children"><div class="content">Unfortunately,<p><pre><code>    int main(){
        char buffer[10];
        buffer[10] = 0;
    }
</code></pre>
are so rare they are hardly worth bothering with. The more usual case is:<p><pre><code>    int get(char* buffer)
    {
        return buffer[10];
    }

    void test() {
        char buffer[10];
        get(buffer);
    }
</code></pre>
I.e. the array bounds for buffer get lost in the function call. I have proposed a fix:<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a><p>that is compatible with existing code.<p>And yet, nobody cares. Oh well! Instead, we have overly complex solutions like this:<p><a href="https:&#x2F;&#x2F;developers.redhat.com&#x2F;articles&#x2F;2022&#x2F;09&#x2F;17&#x2F;gccs-new-fortification-level" rel="nofollow">https:&#x2F;&#x2F;developers.redhat.com&#x2F;articles&#x2F;2022&#x2F;09&#x2F;17&#x2F;gccs-new-f...</a></div><br/><div id="39195040" class="c"><input type="checkbox" id="c-39195040" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194907">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39195040">[-]</label><label class="expand" for="c-39195040">[16 more]</label></div><br/><div class="children"><div class="content">Your example does not pass the verifier<p><pre><code>   cbmc &#x2F;tmp&#x2F;walter.c --bounds-check --pointer-check --function test

   ...
   [get.pointer_dereference.5] line 3 dereference failure: pointer outside object bounds in buffer[(signed long int)10]: FAILURE
   ...
</code></pre>
There are many footguns. People love their guns. Makes them feel powerful.</div><br/><div id="39196855" class="c"><input type="checkbox" id="c-39196855" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39195040">parent</a><span>|</span><a href="#39195485">next</a><span>|</span><label class="collapse" for="c-39196855">[-]</label><label class="expand" for="c-39196855">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There are many footguns. People love their guns. Makes them feel powerful.<p>Well, duh: if you remove the most egregious footguns from C, you end up basically with Pascal, and here is Why Pascal Is Not My Favorite Programming Language.<p>And when you try to explain to them that C&#x27;s abstract machine has semantics of &quot;when you omit a safety check, you actually makes a promise to the compiler that this check is redundant, that you&#x27;ll promise that you&#x27;ll make sure in some other way that in no possible execution will the illegal values ever show up in this place, and the compiler will actually hold you to this promise&quot; â they throw tantrums and try to argue that no, it hasn&#x27;t this semantics, and even if has, it&#x27;s not the semantics as originally intended by K&amp;R and it is the authors of the C compilers who are wrong (even though the authors of C compilers are the people who actually write both the C standards <i>and</i> the C compilers...)<p>Must have to do something with imprintment: I&#x27;ve learned C as my 3rd language, and from the start I was taught that its UB is absolutely insane â and I&#x27;ve never felt &quot;nah, it should just do what I meant, dangit&quot; denial about it, only &quot;this is sad, how can I even know while writing code when I am making a baseless promise especially when it&#x27;s made by <i>omitting</i> something?&quot; But like you&#x27;ve said, people like their footguns.</div><br/><div id="39201367" class="c"><input type="checkbox" id="c-39201367" checked=""/><div class="controls bullet"><span class="by">GuestHNUser</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39196855">parent</a><span>|</span><a href="#39195485">next</a><span>|</span><label class="collapse" for="c-39201367">[-]</label><label class="expand" for="c-39201367">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Must have to do something with imprintment<p>Eh, I think most C programmers frustrations with UB stem from knowing that the C standard has fundamental flaws and modern compilers abuse that fact for &quot;optimizations&quot; on UB. This paper covers the topic pretty well[0].<p>I fully support Casey Muratori&#x27;s viewpoint that undefined behavior should not exist in the standard[1]. Instead, the C standard should enumerate all valid behaviors compliant compilers can implement. This would allow compilers to make unintuitive optimizations for the platforms that need them, but still allow programmers to be certain that their program semantics will not change in different versions of the said compiler.<p>[0] <a href="https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;kps2015&#x2F;proceedings&#x2F;KPS_2015_submission_29.pdf" rel="nofollow">https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;kps2015&#x2F;proceedings&#x2F;KPS_20...</a>
[1] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;dyI0CwK386E?si=vsqJ8uWHY8xkGmFm" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;dyI0CwK386E?si=vsqJ8uWHY8xkGmFm</a></div><br/></div></div></div></div><div id="39195485" class="c"><input type="checkbox" id="c-39195485" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39195040">parent</a><span>|</span><a href="#39196855">prev</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39195485">[-]</label><label class="expand" for="c-39195485">[13 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    int get(char* buffer, int i)
    {
        return buffer[i];
    }

    #include &lt;stdio.h&gt;

    void test() {
        char buffer[10];
        get(buffer, getc(stdin));
    }</code></pre></div><br/><div id="39195629" class="c"><input type="checkbox" id="c-39195629" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39195485">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39195629">[-]</label><label class="expand" for="c-39195629">[12 more]</label></div><br/><div class="children"><div class="content">CBMC&#x27;s default contract for getc returns a non-deterministic integer value. A non-deterministic integer value basically counts as &quot;pick a value that would cause this de-reference to crash the machine model&quot;.<p>So, it will find a counter-example.</div><br/><div id="39195681" class="c"><input type="checkbox" id="c-39195681" checked=""/><div class="controls bullet"><span class="by">philzook</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39195629">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39195681">[-]</label><label class="expand" for="c-39195681">[11 more]</label></div><br/><div class="children"><div class="content">Yes, it returned the same &quot;FAILURE&quot; along with a couple new checks about getc that do pass.</div><br/><div id="39196309" class="c"><input type="checkbox" id="c-39196309" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39195681">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39196309">[-]</label><label class="expand" for="c-39196309">[10 more]</label></div><br/><div class="children"><div class="content">Sounds like it&#x27;s doing a solid job of data flow analysis. But I can still produce cases where it cannot determine either the range of the index or the length of the array being pointed to.<p>The programmer will have to add code to keep track of the length of the array, and add code to check the value of the index. The good thing is the analyzer will tell you where you&#x27;ll need to add those checks.<p>With the proposal I made, none of this is necessary. It just works. Over two decades of experience with this approach in D is it-just-works.</div><br/><div id="39196352" class="c"><input type="checkbox" id="c-39196352" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39196309">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39196352">[-]</label><label class="expand" for="c-39196352">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, have you used CBMC?<p>The machine model tracks the array with its size and compares this to any index. This is loaded into an SMT solver. This is not a standard static analyzer. It&#x27;s compiling the code to an abstract machine model and then running through this model with an SMT solver.<p>CBMC isn&#x27;t perfect, but the strategies you are talking about are meant to defeat a linter or a shallow analyzer in a compiler. CBMC isn&#x27;t a linter.</div><br/><div id="39196951" class="c"><input type="checkbox" id="c-39196951" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39196352">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39196951">[-]</label><label class="expand" for="c-39196951">[8 more]</label></div><br/><div class="children"><div class="content">I have never heard of CBMC before this thread.<p>SMT cannot solve cases where it simply cannot know what the length of an array is. For example, when array is allocated in code not available to the solver, or is set by the environment.<p>I remember trying out Spark a few years ago, which advertised its compile time checking abilities. I tried using an integer equation that used an OR, and it gave up on it.<p>If you need to add in range checking code to help the solver along, then the range check itself is a source of bugs, and the range limit has to be made available somewhere and be correct.<p>In my proposal, the array length is set at the time of creation of the array, and the length is carried along with the pointer. The solver&#x27;s role then becomes one of <i>eliminating</i> the bounds check in the cases where it can prove the index is within range. The user doesn&#x27;t have to do anything.<p>We&#x27;ve been using it in the implementation of the D compiler for a very long time now, and problems with buffer overflows are a faded memory.<p>P.S. I also added manual integer overflow checks when passing the size to malloc(), no matter how unlikely an overflow would be :-)</div><br/><div id="39197181" class="c"><input type="checkbox" id="c-39197181" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39196951">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39197181">[-]</label><label class="expand" for="c-39197181">[7 more]</label></div><br/><div class="children"><div class="content">&gt; SMT cannot solve cases where it simply cannot know what the length of an array is.<p>Sure it can. It sets the array length to a non-deterministic unsigned integer, and then finds a counter-example where this array length is invalid. CBMC will also make the array pointer itself non-deterministic if you haven&#x27;t refined it. So, the pointer could be NULL, could be pointing to invalid memory, etc.<p>Don&#x27;t think of values as fixed numbers, but rather as functions shaping a non-deterministic value. The range check made upstream becomes part of this function. The goal of the SMT solver is to find a counter-example that crashes the machine model. If you want a rather leaky abstraction, imagine that by transforming the source code into an SMT equation, it&#x27;s effectively turning it inside out and transforming it into a logic equation with modulo math.<p>I agree with you that it would be nice if bounds were included in C arrays. But, we have to work with what we have. Unfortunately, especially in firmware that requires a commercial C compiler, we are stuck with C. In those cases, if we want safer software, we need tooling like this.</div><br/><div id="39197722" class="c"><input type="checkbox" id="c-39197722" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39197181">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39197722">[-]</label><label class="expand" for="c-39197722">[6 more]</label></div><br/><div class="children"><div class="content">Thank you for the explanation.<p>I agree that if one isn&#x27;t going to enhance C, one is going to have to resort to these tools.<p>C gets new features now and then. Why not add something incredibly useful, like the slice proposal? Instead, C23 got enhanced with the crazy Unicode identifiers. Richard Cattermole has been adding them to D&#x27;s C support, requiring 6000 lines of code!!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;pull&#x2F;15307">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;pull&#x2F;15307</a><p>The <i>entire</i> C parser is 6000 lines of code:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;blob&#x2F;master&#x2F;compiler&#x2F;src&#x2F;dmd&#x2F;cparse.d">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;blob&#x2F;master&#x2F;compiler&#x2F;src&#x2F;dmd&#x2F;cp...</a></div><br/><div id="39198017" class="c"><input type="checkbox" id="c-39198017" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39197722">parent</a><span>|</span><a href="#39200810">next</a><span>|</span><label class="collapse" for="c-39198017">[-]</label><label class="expand" for="c-39198017">[1 more]</label></div><br/><div class="children"><div class="content">Yeah... I&#x27;m not too happy with some of the choices made in C18 and C23. One of the reasons why I chose to standardize my C SAX-like parser on C18 for now was to avoid the Unicode complexity. There&#x27;s also a widening feature gap between modern C and modern C++ that makes interop harder.</div><br/></div></div><div id="39200810" class="c"><input type="checkbox" id="c-39200810" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39197722">parent</a><span>|</span><a href="#39198017">prev</a><span>|</span><a href="#39200112">next</a><span>|</span><label class="collapse" for="c-39200810">[-]</label><label class="expand" for="c-39200810">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C23 got enhanced with the crazy Unicode identifiers.<p>Actually, this spec security  bug was added with C11. But nobody really added it, until gcc decided that this new &quot;feature&quot; needs to be supported around C23 time. C23 tried to mitigate that mess by disallowing non-identifiable  normalization variants, but still does not care about Unicode security guidelines.</div><br/></div></div><div id="39200112" class="c"><input type="checkbox" id="c-39200112" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39197722">parent</a><span>|</span><a href="#39200810">prev</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39200112">[-]</label><label class="expand" for="c-39200112">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Richard Cattermole has been adding them to D&#x27;s C support, requiring 6000 lines of code!!<p>I wondered if you were implementing a normalization (which <i>is</i> complicated), but that doesn&#x27;t seem the case? I have read the PR and it&#x27;s clear that it solves multiple issues at once: no start-continue distinction (bug), a code generator, the table itself (which is just an inefficiently formatted block of data). 6000 lines of code <i>just</i> for Unicode identifiers are simply an exaggeration.</div><br/><div id="39201116" class="c"><input type="checkbox" id="c-39201116" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39200112">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39201116">[-]</label><label class="expand" for="c-39201116">[2 more]</label></div><br/><div class="children"><div class="content">There are different ways to count lines. I included in the C parser count the comment lines.<p>6000 is also a round number, I did that deliberately to imply the number was not exact.</div><br/><div id="39201580" class="c"><input type="checkbox" id="c-39201580" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39201116">parent</a><span>|</span><a href="#39197943">next</a><span>|</span><label class="collapse" for="c-39201580">[-]</label><label class="expand" for="c-39201580">[1 more]</label></div><br/><div class="children"><div class="content">A new generated code alone is 4000 lines long [1]. The actual code added is just 2000 lines, and some are used to pay debts, I mean, to make a proper code generator. It is debatable whether that generator should count in the number of lines, since you can always write a generator in a simpler scripting language (for example, Rust uses Python to generate the `unicode-xid` crate). In any case however it is far less complex and, in my opinion, much smaller than the entire C parser proper.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;pull&#x2F;15307&#x2F;files#diff-3677bcc896b4eacdde46b6df9ddfd0be58e388de66016b53d2f4fcbc5cefab84">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;pull&#x2F;15307&#x2F;files#diff-3677bcc89...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39197943" class="c"><input type="checkbox" id="c-39197943" checked=""/><div class="controls bullet"><span class="by">sigsev_251</span><span>|</span><a href="#39194907">parent</a><span>|</span><a href="#39195040">prev</a><span>|</span><a href="#39195801">next</a><span>|</span><label class="collapse" for="c-39197943">[-]</label><label class="expand" for="c-39197943">[3 more]</label></div><br/><div class="children"><div class="content">With all respect, please don&#x27;t say nobody cares. There many people in the C community that want this but it&#x27;s not easy to add a fat pointer to C after all these years. Though, there are people who are planning to work on this exact solution [1]. The best thing the rest of the ecosystem can do, is support them.<p>[1]: <a href="https:&#x2F;&#x2F;thephd.dev&#x2F;_vendor&#x2F;future_cxx&#x2F;papers&#x2F;C%20-%20Non-owning%20Sized%20Arrays.html" rel="nofollow">https:&#x2F;&#x2F;thephd.dev&#x2F;_vendor&#x2F;future_cxx&#x2F;papers&#x2F;C%20-%20Non-own...</a></div><br/><div id="39199235" class="c"><input type="checkbox" id="c-39199235" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39197943">parent</a><span>|</span><a href="#39195801">next</a><span>|</span><label class="collapse" for="c-39199235">[-]</label><label class="expand" for="c-39199235">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never gotten a positive response for it. I thank you for your interest on it and the reference, that&#x27;s good!<p>BTW, it&#x27;s simple to implement.</div><br/><div id="39199834" class="c"><input type="checkbox" id="c-39199834" checked=""/><div class="controls bullet"><span class="by">sigsev_251</span><span>|</span><a href="#39194907">root</a><span>|</span><a href="#39199235">parent</a><span>|</span><a href="#39195801">next</a><span>|</span><label class="collapse" for="c-39199834">[-]</label><label class="expand" for="c-39199834">[1 more]</label></div><br/><div class="children"><div class="content">(Just to be clear, I am not the author of the draft I posted in the parent comment, but it&#x27;s the feature I want the most to be added in C2y. I was actually meaning of writting a proposal, but realized that I don&#x27;t know a thing about compilers and language design.)
I have examined many other ways one could add such functionality in C. I found that the most pleasant one is a combination of your syntax and some runtime operators to retrieve the length. As for the lack of implementation burden, I would send an email to thephd in your position. I think that having that comment coming from you would be really beneficial for the paper.</div><br/></div></div></div></div></div></div></div></div><div id="39195389" class="c"><input type="checkbox" id="c-39195389" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39195801">prev</a><span>|</span><a href="#39196442">next</a><span>|</span><label class="collapse" for="c-39195389">[-]</label><label class="expand" for="c-39195389">[1 more]</label></div><br/><div class="children"><div class="content">This is also the backend for Kani - Amazon&#x27;s formal verification tool for Rust.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani">https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani</a></div><br/></div></div><div id="39196442" class="c"><input type="checkbox" id="c-39196442" checked=""/><div class="controls bullet"><span class="by">p0w3n3d</span><span>|</span><a href="#39195389">prev</a><span>|</span><label class="collapse" for="c-39196442">[-]</label><label class="expand" for="c-39196442">[2 more]</label></div><br/><div class="children"><div class="content">I believe valgrind shows uninitialised variables</div><br/><div id="39197924" class="c"><input type="checkbox" id="c-39197924" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#39196442">parent</a><span>|</span><label class="collapse" for="c-39197924">[-]</label><label class="expand" for="c-39197924">[1 more]</label></div><br/><div class="children"><div class="content">Valgrind can only detect this for single executions, not for all possible ones.</div><br/></div></div></div></div></div></div></div></div></div></body></html>