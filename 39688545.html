<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710320462169" as="style"/><link rel="stylesheet" href="styles.css?v=1710320462169"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fly.io/blog/jit-wireguard-peers/">JIT WireGuard</a> <span class="domain">(<a href="https://fly.io">fly.io</a>)</span></div><div class="subtext"><span>Lwrless</span> | <span>31 comments</span></div><br/><div><div id="39689109" class="c"><input type="checkbox" id="c-39689109" checked=""/><div class="controls bullet"><span class="by">niz4ts</span><span>|</span><a href="#39689128">next</a><span>|</span><label class="collapse" for="c-39689109">[-]</label><label class="expand" for="c-39689109">[2 more]</label></div><br/><div class="children"><div class="content">When I read this, I got a little too excited and thought they managed to get wireguard connections happening in the browser with webassembly (this isn&#x27;t impossible, but the only attempt[0] I know of so far only works because of extra things tailscale has). It&#x27;s an idea I&#x27;ve had for a project, but one I haven&#x27;t had time to dedicate to (yet).<p>In any case, really cool write-up! I wonder if they thought about making `flyctl` do a check with their API for any command that requires talking over wireguard to ensure the keys would be installed in the gateway. Since `flyctl` knows when the last command was run with it, it could do this only after some inactivity. And on the gateway machines, they&#x27;d just clean up any inactive peers with a cron (which they seem to be doing already).<p>Not a solution as elegant as the one they reached (which is super cool), but I&#x27;m assuming the considerably lower effort would make it appealing.<p>[0]: <a href="https:&#x2F;&#x2F;labs.leaningtech.com&#x2F;blog&#x2F;webvm-virtual-machine-with-networking-via-tailscale" rel="nofollow">https:&#x2F;&#x2F;labs.leaningtech.com&#x2F;blog&#x2F;webvm-virtual-machine-with...</a></div><br/><div id="39689268" class="c"><input type="checkbox" id="c-39689268" checked=""/><div class="controls bullet"><span class="by">apignotti</span><span>|</span><a href="#39689109">parent</a><span>|</span><a href="#39689128">next</a><span>|</span><label class="collapse" for="c-39689268">[-]</label><label class="expand" for="c-39689268">[1 more]</label></div><br/><div class="children"><div class="content">WebAssembly is not magic, the simple reality is that browsers do not expose low level socket interfaces, so they cannot connect to arbitrary services on the wider internet.<p>We choose to use Tailscale since they allow WebSocket-based connections via their DERPs.<p>It is interesting that, originally, DERPs were intended to be a solution for machines in extremely limited networking environment where nothing but HTTP is allowed. Turns out browsers are exactly one of those extremely limited networking environments.</div><br/></div></div></div></div><div id="39689128" class="c"><input type="checkbox" id="c-39689128" checked=""/><div class="controls bullet"><span class="by">protoman3000</span><span>|</span><a href="#39689109">prev</a><span>|</span><a href="#39688677">next</a><span>|</span><label class="collapse" for="c-39689128">[-]</label><label class="expand" for="c-39689128">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The problem you quickly run into to build this design is that Linux kernel WireGuard doesn’t have a feature for installing peers on demand.<p>I don&#x27;t seem to understand. You can add peers at runtime, e.g.<p><a href="https:&#x2F;&#x2F;serverfault.com&#x2F;questions&#x2F;1101002&#x2F;wireguard-client-addition-without-restart" rel="nofollow">https:&#x2F;&#x2F;serverfault.com&#x2F;questions&#x2F;1101002&#x2F;wireguard-client-a...</a><p>Can somebody clarify?<p>EDIT:
If I understand correctly, that step is already too late. They want to authenticate a peer before adding it to the interface in order to prevent stale entries on the interface.<p>They thus put a eBPF filter in front of the interface and do the cryptokey-routing based association to an authorized counterpart by themselves. If it checks out, then they add the peer to the interface and remove it after a timeout.</div><br/></div></div><div id="39688677" class="c"><input type="checkbox" id="c-39688677" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#39689128">prev</a><span>|</span><a href="#39689261">next</a><span>|</span><label class="collapse" for="c-39688677">[-]</label><label class="expand" for="c-39688677">[9 more]</label></div><br/><div class="children"><div class="content">For everyone else, I&#x27;ll shamelessly use this to plug Netmaker[0].<p>Not affiliated, just a satisfied guy that needs access to private AWS VPCs across multiple accounts and would love to see them be more widely adopted.<p>[0] <a href="https:&#x2F;&#x2F;www.netmaker.io&#x2F;">https:&#x2F;&#x2F;www.netmaker.io&#x2F;</a></div><br/><div id="39688729" class="c"><input type="checkbox" id="c-39688729" checked=""/><div class="controls bullet"><span class="by">porker</span><span>|</span><a href="#39688677">parent</a><span>|</span><a href="#39688692">next</a><span>|</span><label class="collapse" for="c-39688729">[-]</label><label class="expand" for="c-39688729">[2 more]</label></div><br/><div class="children"><div class="content">Is Netmaker like Tailscale? From their site I&#x27;m unclear what the distinguishing factor is.</div><br/><div id="39688755" class="c"><input type="checkbox" id="c-39688755" checked=""/><div class="controls bullet"><span class="by">thunfischbrot</span><span>|</span><a href="#39688677">root</a><span>|</span><a href="#39688729">parent</a><span>|</span><a href="#39688692">next</a><span>|</span><label class="collapse" for="c-39688755">[-]</label><label class="expand" for="c-39688755">[1 more]</label></div><br/><div class="children"><div class="content">Roughly, yes. Netmaker has a self-hostable server though. With tailscsle of course the 3rd-party headscale is available. Netbird also seems promising. See <a href="https:&#x2F;&#x2F;github.com&#x2F;cedrickchee&#x2F;awesome-wireguard">https:&#x2F;&#x2F;github.com&#x2F;cedrickchee&#x2F;awesome-wireguard</a> for more alternatives.</div><br/></div></div></div></div><div id="39688768" class="c"><input type="checkbox" id="c-39688768" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#39688677">parent</a><span>|</span><a href="#39688692">prev</a><span>|</span><a href="#39689261">next</a><span>|</span><label class="collapse" for="c-39688768">[-]</label><label class="expand" for="c-39688768">[5 more]</label></div><br/><div class="children"><div class="content">Can’t you do that “AWS native” with private link or vpc peering? I’m a noob with these so I don’t understand the benefit of netmaker</div><br/><div id="39688834" class="c"><input type="checkbox" id="c-39688834" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#39688677">root</a><span>|</span><a href="#39688768">parent</a><span>|</span><a href="#39689261">next</a><span>|</span><label class="collapse" for="c-39688834">[-]</label><label class="expand" for="c-39688834">[4 more]</label></div><br/><div class="children"><div class="content">The goal isn&#x27;t to make the networks seem like one and connect resources across accounts, which is what those products do.<p>My goal is to access private resources via SSH bastion&#x2F;jump machines in a specific account. There&#x27;s a few ways to do this in AWS, but all of them are more costly by a pretty wide margin.</div><br/><div id="39689314" class="c"><input type="checkbox" id="c-39689314" checked=""/><div class="controls bullet"><span class="by">verticalscaler</span><span>|</span><a href="#39688677">root</a><span>|</span><a href="#39688834">parent</a><span>|</span><a href="#39688905">next</a><span>|</span><label class="collapse" for="c-39689314">[-]</label><label class="expand" for="c-39689314">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;systems-manager&#x2F;latest&#x2F;userguide&#x2F;what-is-systems-manager.html" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;systems-manager&#x2F;latest&#x2F;userguide...</a><p><pre><code>  aws ssm start-session --target $instance-id</code></pre></div><br/></div></div><div id="39688905" class="c"><input type="checkbox" id="c-39688905" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#39688677">root</a><span>|</span><a href="#39688834">parent</a><span>|</span><a href="#39689314">prev</a><span>|</span><a href="#39688945">next</a><span>|</span><label class="collapse" for="c-39688905">[-]</label><label class="expand" for="c-39688905">[1 more]</label></div><br/><div class="children"><div class="content">AWS VPN is pretty cost effective, we used if for a few years with a multi account setup. And it&#x27;s pretty much zero work.</div><br/></div></div><div id="39688945" class="c"><input type="checkbox" id="c-39688945" checked=""/><div class="controls bullet"><span class="by">seany</span><span>|</span><a href="#39688677">root</a><span>|</span><a href="#39688834">parent</a><span>|</span><a href="#39688905">prev</a><span>|</span><a href="#39689261">next</a><span>|</span><label class="collapse" for="c-39688945">[-]</label><label class="expand" for="c-39688945">[1 more]</label></div><br/><div class="children"><div class="content">You can forward ssh through ssm, and dump that into your ssh config file.  Works pretty nicely with some of the sso automation for the cli that&#x27;s around these days.</div><br/></div></div></div></div></div></div></div></div><div id="39689261" class="c"><input type="checkbox" id="c-39689261" checked=""/><div class="controls bullet"><span class="by">tinco</span><span>|</span><a href="#39688677">prev</a><span>|</span><a href="#39688977">next</a><span>|</span><label class="collapse" for="c-39689261">[-]</label><label class="expand" for="c-39689261">[2 more]</label></div><br/><div class="children"><div class="content">While I generally agree with the idea that a direct HTTP request for a single point to point message would be more reliable than routing through a message queue, I&#x27;m a little bit surprised that there would be so many messages lost by NATS it had significant impact on their services.<p>Wouldn&#x27;t a lost message just mean NATS would retry delivery until succesful? Anyone know why they would experience noticeable unreliability?</div><br/><div id="39689315" class="c"><input type="checkbox" id="c-39689315" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#39689261">parent</a><span>|</span><a href="#39688977">next</a><span>|</span><label class="collapse" for="c-39689315">[-]</label><label class="expand" for="c-39689315">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn&#x27;t a lost message just mean NATS would retry delivery until succesful? Anyone know why they would experience noticeable unreliability?<p>I believe if you&#x27;re using core nats (not JetStream) there&#x27;s no option for re-delivering like at all.</div><br/></div></div></div></div><div id="39688977" class="c"><input type="checkbox" id="c-39688977" checked=""/><div class="controls bullet"><span class="by">d-z-m</span><span>|</span><a href="#39689261">prev</a><span>|</span><a href="#39688910">next</a><span>|</span><label class="collapse" for="c-39688977">[-]</label><label class="expand" for="c-39688977">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We can install the peer as if we’re the initiator, and flyctl is the responder. The Linux kernel will initiate a WireGuard connection back to flyctl. This works; the protocol doesn’t care a whole lot who’s the server and who’s the client. We get new connections established about as fast as they can possibly be installed.<p>Is this adding a half round-trip to the handshake? i.e.<p><pre><code>  1. -&gt;flyctl sends Initiation
  2. &lt;-peer is added via netlink(which causes new Initiation to be sent)
  3. -&gt;Response from flyctl</code></pre></div><br/></div></div><div id="39688910" class="c"><input type="checkbox" id="c-39688910" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39688977">prev</a><span>|</span><a href="#39688689">next</a><span>|</span><label class="collapse" for="c-39688910">[-]</label><label class="expand" for="c-39688910">[6 more]</label></div><br/><div class="children"><div class="content">I always felt the disappointment of wireguard was wrapping it up into an opinionated network interface.  It really should have been a generic &quot;filter&quot; that you could attach to any type of file handle.  Then the configuration would be far less strongly coupled, less weirdly communicated to the kernel,  and the status of your connection more immediately obvious.<p>Plus,  you could have wireguard files on your local or remote filesystems,  or any character device,  or named pipes if you felt like it.  You could use a &quot;jit&quot; daemon to build tap or other interfaces for you,  or just do it individually at the application layer.  You could have pre registered keys with the kernel,  or you could manage that directly,  or generate them randomly.<p>It&#x27;s always been a weird smelling underspecified IPSEC clone to me,  when it could have been so much more.</div><br/><div id="39689172" class="c"><input type="checkbox" id="c-39689172" checked=""/><div class="controls bullet"><span class="by">d-z-m</span><span>|</span><a href="#39688910">parent</a><span>|</span><a href="#39689331">prev</a><span>|</span><a href="#39688939">next</a><span>|</span><label class="collapse" for="c-39689172">[-]</label><label class="expand" for="c-39689172">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I always felt the disappointment of wireguard was wrapping it up into an opinionated network interface.<p>Why? WireGuard is a VPN, it&#x27;s pretty normal for VPN solutions to expose themselves as a network interface.<p>&gt; It really should have been a generic &quot;filter&quot; that you could attach to any type of file handle.<p>What&#x27;s the use-case you had in mind here? I&#x27;m not sure how generifying it to a &quot;filter&quot; on any type of file descriptor looks for an interactive protocol like wireguard.<p>&gt; It&#x27;s always been a weird smelling underspecified IPSEC clone to me[...]<p>Just because there isn&#x27;t an RFC? I&#x27;ve always found the wireguard paper[0] to be quite readable and thorough in it&#x27;s specification of the protocol.<p>[0]:<a href="https:&#x2F;&#x2F;www.wireguard.com&#x2F;papers&#x2F;wireguard.pdf" rel="nofollow">https:&#x2F;&#x2F;www.wireguard.com&#x2F;papers&#x2F;wireguard.pdf</a></div><br/><div id="39689231" class="c"><input type="checkbox" id="c-39689231" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#39688910">root</a><span>|</span><a href="#39689172">parent</a><span>|</span><a href="#39688939">next</a><span>|</span><label class="collapse" for="c-39689231">[-]</label><label class="expand" for="c-39689231">[1 more]</label></div><br/><div class="children"><div class="content">Not the OP, but the main problem with WireGuard[0] is not the protocol[1], it&#x27;s good, but the opinionated tooling around it, be it .INI style configurations (god I hate it), mutual incompatibility of wg and wg-quick or just outright stupid decisions around storing config files and interacting with the user in the Windows client.<p>Though there are some nuances with the routing selection&#x2F;filtering too, which gets troublesome  when you just need a pipe and run a proper routing protocols over it. ::&#x2F;0 solves most of it but still there are some rough edges.<p>[0] well, for *me*<p>[1] One of the amusing things I discovered what I have a full 10MB&#x2F;s+ to the SMB server in the DC over the WireGuard tunnel (and that&#x27;s because it&#x27;s 100Mbit&#x2F;s uplink), while the Synology which sits <i>on the same router on a 1Gbit port</i> only makes 3-5MB&#x2F;s.</div><br/></div></div></div></div><div id="39688939" class="c"><input type="checkbox" id="c-39688939" checked=""/><div class="controls bullet"><span class="by">mellutussa</span><span>|</span><a href="#39688910">parent</a><span>|</span><a href="#39689172">prev</a><span>|</span><a href="#39688689">next</a><span>|</span><label class="collapse" for="c-39688939">[-]</label><label class="expand" for="c-39688939">[2 more]</label></div><br/><div class="children"><div class="content">But why don&#x27;t use the nice smelling IPSEC if that ticks your boxes?</div><br/><div id="39688993" class="c"><input type="checkbox" id="c-39688993" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39688910">root</a><span>|</span><a href="#39688939">parent</a><span>|</span><a href="#39688689">next</a><span>|</span><label class="collapse" for="c-39688993">[-]</label><label class="expand" for="c-39688993">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t.  It just foresaw the need to be able to dynamically configure tunnels on first connection and specified all of that.  Which seems to me is a lot of what fly io has just mostly reimplemented here.<p>In any case the point is I would prefer to just have the basic components available and let me piece them together however I want.  Mostly to allow using the underlying technology in more contexts that it is currently available in.</div><br/></div></div></div></div></div></div><div id="39688689" class="c"><input type="checkbox" id="c-39688689" checked=""/><div class="controls bullet"><span class="by">rubatuga</span><span>|</span><a href="#39688910">prev</a><span>|</span><a href="#39689196">next</a><span>|</span><label class="collapse" for="c-39688689">[-]</label><label class="expand" for="c-39688689">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s stopping the initial handshake packet from being replayed into the network stack? Seems like there would be no packets lost that way. Also, what is the purpose of checking for &quot;udp[8] = 1&quot; in the eBPF filter?</div><br/><div id="39688807" class="c"><input type="checkbox" id="c-39688807" checked=""/><div class="controls bullet"><span class="by">zekica</span><span>|</span><a href="#39688689">parent</a><span>|</span><a href="#39689196">next</a><span>|</span><label class="collapse" for="c-39688807">[-]</label><label class="expand" for="c-39688807">[1 more]</label></div><br/><div class="children"><div class="content">udp[8] = 1 filters only handshake packets. Without it, data packets would also be sent to the userspace daemon.<p>I&#x27;m not sure if initial handshakes can be replayed, but since WireGuard ignores unknown clients, it might be possible.</div><br/></div></div></div></div><div id="39689196" class="c"><input type="checkbox" id="c-39689196" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#39688689">prev</a><span>|</span><a href="#39688697">next</a><span>|</span><label class="collapse" for="c-39689196">[-]</label><label class="expand" for="c-39689196">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and gateways with hundreds of thousands of peers that will never be used again<p>My thoughts exactly as I was reading the first paragraphs.<p>&gt; Note that there’s no API call to subscribe for “incoming connection attempt” events. That’s OK! We can just make our own events. WireGuard connection requests are packets, and they’re easily identifiable, so we can efficiently snatch them with a BPF filter and a packet socket.<p>Nice idea.<p>&gt; When we get an incoming initiation message, we have the 4-tuple address of the desired connection, including the ephemeral source port flyctl is using. We can install the peer as if we’re the initiator, and flyctl is the responder<p>And this works behind NAT?</div><br/></div></div><div id="39688697" class="c"><input type="checkbox" id="c-39688697" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#39689196">prev</a><span>|</span><label class="collapse" for="c-39688697">[-]</label><label class="expand" for="c-39688697">[6 more]</label></div><br/><div class="children"><div class="content">&gt; You could yeet them out of the kernel any time you wanted<p>Can we not?</div><br/><div id="39688779" class="c"><input type="checkbox" id="c-39688779" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#39688697">parent</a><span>|</span><a href="#39688720">next</a><span>|</span><label class="collapse" for="c-39688779">[-]</label><label class="expand" for="c-39688779">[1 more]</label></div><br/><div class="children"><div class="content">Language is fluid :)</div><br/></div></div><div id="39688720" class="c"><input type="checkbox" id="c-39688720" checked=""/><div class="controls bullet"><span class="by">hug</span><span>|</span><a href="#39688697">parent</a><span>|</span><a href="#39688779">prev</a><span>|</span><a href="#39688990">next</a><span>|</span><label class="collapse" for="c-39688720">[-]</label><label class="expand" for="c-39688720">[2 more]</label></div><br/><div class="children"><div class="content">Not yeeting them would appear to be a valid option, yes. You can leave them un-yote for as long as you wish.</div><br/><div id="39688833" class="c"><input type="checkbox" id="c-39688833" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#39688697">root</a><span>|</span><a href="#39688720">parent</a><span>|</span><a href="#39688990">next</a><span>|</span><label class="collapse" for="c-39688833">[-]</label><label class="expand" for="c-39688833">[1 more]</label></div><br/><div class="children"><div class="content">&gt; un-yote<p>:joy:</div><br/></div></div></div></div><div id="39688990" class="c"><input type="checkbox" id="c-39688990" checked=""/><div class="controls bullet"><span class="by">Takennickname</span><span>|</span><a href="#39688697">parent</a><span>|</span><a href="#39688720">prev</a><span>|</span><label class="collapse" for="c-39688990">[-]</label><label class="expand" for="c-39688990">[2 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t you hip and with it?</div><br/><div id="39689071" class="c"><input type="checkbox" id="c-39689071" checked=""/><div class="controls bullet"><span class="by">ndsipa_pomu</span><span>|</span><a href="#39688697">root</a><span>|</span><a href="#39688990">parent</a><span>|</span><label class="collapse" for="c-39689071">[-]</label><label class="expand" for="c-39689071">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re so unhip, their trousers keep falling down</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>