<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714467680628" as="style"/><link rel="stylesheet" href="styles.css?v=1714467680628"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.bigmessowires.com/2016/05/06/fc8-faster-68k-decompression/">FC8 – Faster 68K Decompression (2016)</a> <span class="domain">(<a href="https://www.bigmessowires.com">www.bigmessowires.com</a>)</span></div><div class="subtext"><span>electricant</span> | <span>8 comments</span></div><br/><div><div id="40204667" class="c"><input type="checkbox" id="c-40204667" checked=""/><div class="controls bullet"><span class="by">dansalvato</span><span>|</span><a href="#40203841">next</a><span>|</span><label class="collapse" for="c-40204667">[-]</label><label class="expand" for="c-40204667">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m working on a game for Amiga (another 68k-based platform) and settled on ZX0 to decompress assets on the fly: <a href="https:&#x2F;&#x2F;github.com&#x2F;einar-saukas&#x2F;ZX0">https:&#x2F;&#x2F;github.com&#x2F;einar-saukas&#x2F;ZX0</a><p>I was originally using LZ4, but I switched to ZX0 after learning that it can do in-place decompression, which means I don&#x27;t have to allocate separate memory for the compressed data. I&#x27;m very happy with the compression ratio, and decompression of large assets (~48kb) only takes a few frames on a 7MHz 68000.<p>Also of note is LZ4W, included in Sega Genesis Dev Kit (and discussed in the comments section of OP&#x27;s article), a variant of LZ4 that only uses word-aligned operations. That makes it much faster on the 68000, which can struggle to efficiently handle 8-bit data. More info here: <a href="https:&#x2F;&#x2F;github.com&#x2F;Stephane-D&#x2F;SGDK&#x2F;blob&#x2F;master&#x2F;bin&#x2F;lz4w.txt">https:&#x2F;&#x2F;github.com&#x2F;Stephane-D&#x2F;SGDK&#x2F;blob&#x2F;master&#x2F;bin&#x2F;lz4w.txt</a></div><br/><div id="40205103" class="c"><input type="checkbox" id="c-40205103" checked=""/><div class="controls bullet"><span class="by">bananaboy</span><span>|</span><a href="#40204667">parent</a><span>|</span><a href="#40203841">next</a><span>|</span><label class="collapse" for="c-40205103">[-]</label><label class="expand" for="c-40205103">[3 more]</label></div><br/><div class="children"><div class="content">Nice! When you say “on the fly” are you literally decompressing assets from disk during gameplay? Can you do asynchronous IO on the Amiga?</div><br/><div id="40206762" class="c"><input type="checkbox" id="c-40206762" checked=""/><div class="controls bullet"><span class="by">the-rc</span><span>|</span><a href="#40204667">root</a><span>|</span><a href="#40205103">parent</a><span>|</span><a href="#40203841">next</a><span>|</span><label class="collapse" for="c-40206762">[-]</label><label class="expand" for="c-40206762">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually harder to do synchronous floppy I&#x2F;O on the Amiga. Data transfer is done over DMA, then you perform MFM decoding. The latter can be done by the CPU, or, asynchronously again, by the blitter, in which case you can&#x27;t use it at the same time for graphic operations.</div><br/><div id="40208031" class="c"><input type="checkbox" id="c-40208031" checked=""/><div class="controls bullet"><span class="by">VelesDude</span><span>|</span><a href="#40204667">root</a><span>|</span><a href="#40206762">parent</a><span>|</span><a href="#40203841">next</a><span>|</span><label class="collapse" for="c-40208031">[-]</label><label class="expand" for="c-40208031">[1 more]</label></div><br/><div class="children"><div class="content">Depending on what you are going for in terms of gameplay experience, that can be a reasonable trade off. Say an RPG where you page in&#x2F;out assets as needed but doesn&#x27;t break the flow is probably going to be a bigger issue on gameplay styles that need more compute to achieve.</div><br/></div></div></div></div></div></div></div></div><div id="40203841" class="c"><input type="checkbox" id="c-40203841" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#40204667">prev</a><span>|</span><label class="collapse" for="c-40203841">[-]</label><label class="expand" for="c-40203841">[3 more]</label></div><br/><div class="children"><div class="content">In “faster than memcpy” series we have also Blosch for modern CPUs<p><a href="https:&#x2F;&#x2F;www.blosc.org&#x2F;pages&#x2F;blosc-in-depth&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.blosc.org&#x2F;pages&#x2F;blosc-in-depth&#x2F;</a><p>I have never been able to use Blosch myself. But it sounds really interesting, outperforming RAM. Not sure what are the applications - columnar data processing, Parquet files, etc?</div><br/><div id="40204459" class="c"><input type="checkbox" id="c-40204459" checked=""/><div class="controls bullet"><span class="by">jeramey</span><span>|</span><a href="#40203841">parent</a><span>|</span><a href="#40204309">next</a><span>|</span><label class="collapse" for="c-40204459">[-]</label><label class="expand" for="c-40204459">[1 more]</label></div><br/><div class="children"><div class="content">It gets used a fair amount in the weather data space. Forecasting and climate reanalysis grids are typically large (gigabytes) N-dimensional arrays of float32 values and Blosc provides enough tunable knobs that it&#x27;s fairly easy to find a combination that performs acceptably without writing a bunch of custom handling code to keep track of which underlying compression schemes and settings were used. Additionally, it supports byte- and bit-shuffling filters which can really help boost the compressibility of certain data sets.</div><br/></div></div><div id="40204309" class="c"><input type="checkbox" id="c-40204309" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#40203841">parent</a><span>|</span><a href="#40204459">prev</a><span>|</span><label class="collapse" for="c-40204309">[-]</label><label class="expand" for="c-40204309">[1 more]</label></div><br/><div class="children"><div class="content">Why doesn&#x27;t BLOSC have a little chart comparing itself to LZ4, Zstd, etc? Kinda like this:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;37614410&#x2F;comparison-between-lz4-vs-lz4-hc-vs-blosc-vs-snappy-vs-fastlz" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;37614410&#x2F;comparison-betw...</a><p>Because it seems like such a trivial chart to make.</div><br/></div></div></div></div></div></div></div></div></div></body></html>