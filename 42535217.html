<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735462849312" as="style"/><link rel="stylesheet" href="styles.css?v=1735462849312"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fishshell.com/blog/rustport/">Fish 4.0: The Fish of Theseus</a> <span class="domain">(<a href="https://fishshell.com">fishshell.com</a>)</span></div><div class="subtext"><span>jdxcode</span> | <span>90 comments</span></div><br/><div><div id="42536036" class="c"><input type="checkbox" id="c-42536036" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#42536080">next</a><span>|</span><label class="collapse" for="c-42536036">[-]</label><label class="expand" for="c-42536036">[4 more]</label></div><br/><div class="children"><div class="content">Congrats to the fish team!  Great writeup with lots of interesting detail.<p>I wonder if this is the biggest project that has moved from C++ entirely to Rust (or maybe even C to Rust?)  It probably has useful lessons for other projects.<p>If I&#x27;m reading this right, it looks like fish was not released as a hybrid C++ &#x2F; Rust program, with the autocxx-generated bindings.  There was a release during that time, but it says &quot;fish 3.7 remains a C++ program&quot; [1]<p>It sounds like they could have released if they wanted to, but there was a last stage of testing that didn&#x27;t happen until the end.<p>Some people didn&#x27;t quite get the motivation for adding C++ features to Rust [2], and vice versa, to enable inter-op.  But perhaps this is a good case study.<p>It would be nice if you could just write new Rust code in a C++ codebase, without writing&#x2F;generating bindings, and then throwing them away, which is mentioned in this post.<p>---<p>Also the #1 gripe with Rust seems to be that it supports version detection, not feature detection.<p>But feature detection is better for distros, web browsers, and compilers:<p><i>Feature Detection Is Better than Version Detection</i> - <a href="https:&#x2F;&#x2F;github.com&#x2F;oils-for-unix&#x2F;oils&#x2F;wiki&#x2F;Feature-Detection-Is-Better-than-Version-Detection">https:&#x2F;&#x2F;github.com&#x2F;oils-for-unix&#x2F;oils&#x2F;wiki&#x2F;Feature-Detection...</a><p>Version&#x2F;name detection is why Chrome and IE pretend to be Mozilla, and why Clang pretends to be GCC.  Feature detection (e.g. .&#x2F;configure and eval() ) doesn&#x27;t cause this problem!<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;fish-shell&#x2F;fish-shell&#x2F;releases">https:&#x2F;&#x2F;github.com&#x2F;fish-shell&#x2F;fish-shell&#x2F;releases</a><p>[2] e.g. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=safecpp.org">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=safecpp.org</a></div><br/><div id="42537298" class="c"><input type="checkbox" id="c-42537298" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536036">parent</a><span>|</span><a href="#42538340">next</a><span>|</span><label class="collapse" for="c-42537298">[-]</label><label class="expand" for="c-42537298">[1 more]</label></div><br/><div class="children"><div class="content">To clarify, work on the rust rewrite started after 3.7.0, but the C++ code remained in a working branch on the git repo. Midway through the rewrite, we backported additions and improvements to fish scripts (most observable being new and improved completions) and a couple of important bugfixes from the rust-containing `master` branch to the C++ branch and released that as 3.7.1.<p>We never considered releasing anything with a hybrid codebase; aside from the philosophical purity of fully making the switch to rust, it would have been a complete distribution nightmare (we take package maintainer requirements very seriously). Moreover, the code itself was not in a very pretty state - the port was very much like trying to undo a knot: you had to make it much uglier in order to get it properly undone. There were proverbial tons of SLoC that were introduced only for transitional interop purposes that were later removed, this code was never held to the same quality standards (in terms of maintainability; it was still intended to be bug-free and required to pass all our unit and integration tests, however).<p>As mentioned in the article, we prefer to do feature detection when and where needed&#x2F;possible. The old codebase was purely feature-detected via the CMake build system but we ended up writing our own feature detection crate for rust invoked via build.rs (maintained here [0]) though we just defer to libc on a lot (which doesn&#x27;t do that <i>yet</i>). One side effect of the libc issue is that we&#x27;re beholden to <i>their</i> minimum supported targets (though I&#x27;m not sure if that&#x27;s strictly the case if we don&#x27;t use the specific apis that cause that restriction?), which are higher than what we would have liked because we were fine with feature detecting and implementing using both older and newer apis where needed.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;mqudsi&#x2F;rsconf">https:&#x2F;&#x2F;github.com&#x2F;mqudsi&#x2F;rsconf</a></div><br/></div></div><div id="42538340" class="c"><input type="checkbox" id="c-42538340" checked=""/><div class="controls bullet"><span class="by">boris</span><span>|</span><a href="#42536036">parent</a><span>|</span><a href="#42537298">prev</a><span>|</span><a href="#42537070">next</a><span>|</span><label class="collapse" for="c-42538340">[-]</label><label class="expand" for="c-42538340">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Feature Detection Is Better than Version Detection<p>The problem with feature detection (normally referred to as configuration probing), at least the way it&#x27;s done in .&#x2F;configure and similar, is that it relies on compiling and&#x2F;or linking (and sometimes even running, which doesn&#x27;t work when cross-compiling) of a test program and then assuming that if compilation&#x2F;linking fails, then the feature is not available.<p>But the compilation&#x2F;linking can fail for a myriad of other reasons: misconfigured toolchain, bug in test, etc. For example, there were a bunch of recent threads on this website where both GCC and Clang stopped accepting certain invalid C constructs which in turn broke a bunch of .&#x2F;configure tests. And &quot;broke&quot; doesn&#x27;t mean you get an error, it means your build now thinks the latest Fedora and Ubuntu all of a sudden don&#x27;t have strlen().</div><br/></div></div><div id="42537070" class="c"><input type="checkbox" id="c-42537070" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42536036">parent</a><span>|</span><a href="#42538340">prev</a><span>|</span><a href="#42536080">next</a><span>|</span><label class="collapse" for="c-42537070">[-]</label><label class="expand" for="c-42537070">[1 more]</label></div><br/><div class="children"><div class="content">Although Clang does set the `__GNUC__` macro and you have to distinguish it using the `__clang__` macro, Clang and GCC also both have very fine-grained feature detection features as well, both at the CLI level and in the preprocessor (such as the `__has_feature` family of builtins).</div><br/></div></div></div></div><div id="42536080" class="c"><input type="checkbox" id="c-42536080" checked=""/><div class="controls bullet"><span class="by">scop</span><span>|</span><a href="#42536036">prev</a><span>|</span><a href="#42536190">next</a><span>|</span><label class="collapse" for="c-42536080">[-]</label><label class="expand" for="c-42536080">[21 more]</label></div><br/><div class="children"><div class="content">I remember switching from bash to zsh a few years back and thinking I was the bees knees. After the switch trying other shells seemed like bike-shedding because, I mean, what more could a shell? Then I got a new computer and decided to start from scratch with my tooling and downloaded fish. I was shocked how it instantly made zsh feel <i>cumbersome and ancient</i>.<p>Heartily recommend others give it a try as a daily driver for a couple of weeks. I liken it to Sublime Text: an excellent “out of the box” tool. Just the right amount of features, with the option to add more if you want. But you also don’t feel like your missing out if you keep it bare bones. A great tool in and of itself.</div><br/><div id="42536344" class="c"><input type="checkbox" id="c-42536344" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#42536080">parent</a><span>|</span><a href="#42536820">next</a><span>|</span><label class="collapse" for="c-42536344">[-]</label><label class="expand" for="c-42536344">[12 more]</label></div><br/><div class="children"><div class="content">Interesting, I went the other way about 7 years ago - switched from fish to zsh (initially with oh-my-zsh). The interactive experience was similar enough on both shells, and the performance was great on fish and okay-ish on zsh, but two things won me over:<p>1. With zsh, I can copy-paste some bash snippet and in 99% of cases it will just work. Aside of copy-pasting from StackExchange, I also know a lot of bash syntax by heart by now, and can write some clever one-liners. With zsh, I didn&#x27;t need to learn everything from scratch. (I guess this matters less now that you can ask AI to convert a bash one-liner into fish one-liner?)<p>2. For standalone scripts... well, I think it&#x27;s best to reach for a proper programming language (e.g. Python) instead of any shell language, but if I had to use one, I would pick bash. Sure, it has many footguns, but I know them pretty well. And fish language is also not ideal - e.g. IIRC it doesn&#x27;t have an equivalent of `set -e`, you have to add `; or return 1` to each line.</div><br/><div id="42536778" class="c"><input type="checkbox" id="c-42536778" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536344">parent</a><span>|</span><a href="#42537311">next</a><span>|</span><label class="collapse" for="c-42536778">[-]</label><label class="expand" for="c-42536778">[1 more]</label></div><br/><div class="children"><div class="content">I use fish and on the very, very rare occasion I need to copy and paste bash from the internet it&#x27;s pretty easy to just type &#x27;bash&#x27; into fish and paste it in. Its not like bash and fish conflict, you can have them both installed.</div><br/></div></div><div id="42537311" class="c"><input type="checkbox" id="c-42537311" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536344">parent</a><span>|</span><a href="#42536778">prev</a><span>|</span><a href="#42537140">next</a><span>|</span><label class="collapse" for="c-42537311">[-]</label><label class="expand" for="c-42537311">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, fish is much more bash-compatible these days. We&#x27;ve introduced support for a lot of bash-isms that don&#x27;t completely break the fish spirit or clash with its syntax in the last few releases.</div><br/></div></div><div id="42537140" class="c"><input type="checkbox" id="c-42537140" checked=""/><div class="controls bullet"><span class="by">jorvi</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536344">parent</a><span>|</span><a href="#42537311">prev</a><span>|</span><a href="#42538229">next</a><span>|</span><label class="collapse" for="c-42537140">[-]</label><label class="expand" for="c-42537140">[1 more]</label></div><br/><div class="children"><div class="content">I “devolved” mostly along the same path. Bespoke shell to OMZSH to Zsh to Bash.<p>Zsh has a few nasty Bashism footgun incompatibilities. If I remember correctly the worst one is with how globbing &#x2F; “*” works, which is why that is guarded with an option.<p>My main reason for sticking with Bash is that it’s everywhere, and the places where it isn’t try very hard to support the most-used featureset of Bash.<p>A stock Bash shell does feel a little naked without my dotfiles though :)</div><br/></div></div><div id="42538229" class="c"><input type="checkbox" id="c-42538229" checked=""/><div class="controls bullet"><span class="by">wzdd</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536344">parent</a><span>|</span><a href="#42537140">prev</a><span>|</span><a href="#42536717">next</a><span>|</span><label class="collapse" for="c-42538229">[-]</label><label class="expand" for="c-42538229">[2 more]</label></div><br/><div class="children"><div class="content">Reading the associated issue (<a href="https:&#x2F;&#x2F;github.com&#x2F;fish-shell&#x2F;fish-shell&#x2F;issues&#x2F;510">https:&#x2F;&#x2F;github.com&#x2F;fish-shell&#x2F;fish-shell&#x2F;issues&#x2F;510</a>) about the lack of &quot;set -e&quot; was interesting as it highlighted how weird Bash, and shell scripting in general, is from a programming language perspective. Imagine programming in any other environment where every function you call could either succeed or fail catastrophically. There&#x27;s some talk about adding exception handling to Fish, but maybe the sensible thing to do is to have a mode where Fish ensures that you&#x27;ve dealt with each possible error before moving on. Which is what you would do anyway if you were invoking external programs from a non-shell language (like Python&#x27;s subprocess.check_call).<p>In any case the discussion in that issue made a convincing (to me) argument that if you&#x27;re doing the sort of scripting for which &quot;set -e&quot; makes sense, which is most of it, you should be using Bash. That doesn&#x27;t mean you need to use Bash interactively though, as others have pointed out.</div><br/><div id="42538287" class="c"><input type="checkbox" id="c-42538287" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42538229">parent</a><span>|</span><a href="#42536717">next</a><span>|</span><label class="collapse" for="c-42538287">[-]</label><label class="expand" for="c-42538287">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine programming in any other environment where every function you call could either succeed or fail catastrophically<p>There&#x27;s not much to imagine since that&#x27;s pretty much every other language?<p>Sure you can recover with error handlers (sometimes[0]), but by default all of them will hard abort in case of exceptions.<p>In our modern language landscape shells are very much the odd ones, where errors are completely silent by default and the thing just carries on oblivious that the world around it might be crumbling completely.<p>[0]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-01-unrecoverable-errors-with-panic.html#unwinding-the-stack-or-aborting-in-response-to-a-panic" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-01-unrecoverable-errors-...</a></div><br/></div></div></div></div><div id="42536717" class="c"><input type="checkbox" id="c-42536717" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536344">parent</a><span>|</span><a href="#42538229">prev</a><span>|</span><a href="#42537452">next</a><span>|</span><label class="collapse" for="c-42536717">[-]</label><label class="expand" for="c-42536717">[4 more]</label></div><br/><div class="children"><div class="content">&gt; 2. For standalone scripts... well, I think it&#x27;s best to reach for a proper programming language (e.g. Python) instead of any shell language, but if I had to use one, I would pick bash. Sure, it has many footguns, but I know them pretty well. And fish language is also not ideal - e.g. IIRC it doesn&#x27;t have an equivalent of `set -e`, you have to add `; or return 1` to each line.<p>I&#x27;m sure you know this, but: no particular reason the interactive shell you use has to match the shell you use for scripts. All of my scripts are in bash, but I haven&#x27;t used bash interactively in decades now, at least on purpose.</div><br/><div id="42537108" class="c"><input type="checkbox" id="c-42537108" checked=""/><div class="controls bullet"><span class="by">johnthuss</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536717">parent</a><span>|</span><a href="#42537452">next</a><span>|</span><label class="collapse" for="c-42537108">[-]</label><label class="expand" for="c-42537108">[3 more]</label></div><br/><div class="children"><div class="content">I write all my scripts with the hash bang as &quot;#! &#x2F;bin&#x2F;bash&quot; so even though fish is my interactive shell, I still use bash for all shell scripts. I think the restrictions you mention only apply if you use &quot;#! &#x2F;bin&#x2F;sh&quot; rather than bash specifically.</div><br/><div id="42537315" class="c"><input type="checkbox" id="c-42537315" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42537108">parent</a><span>|</span><a href="#42537452">next</a><span>|</span><label class="collapse" for="c-42537315">[-]</label><label class="expand" for="c-42537315">[2 more]</label></div><br/><div class="children"><div class="content">Just fyi, you should use `#!&#x2F;usr&#x2F;bin&#x2F;env bash` instead of `#!&#x2F;bin&#x2F;bash` or whatever because you can&#x27;t assume the location of bash (but the location of `env` is indeed portably fixed). e.g. FreeBSD (and macOS?) has bash at `&#x2F;usr&#x2F;local&#x2F;bin&#x2F;bash`</div><br/><div id="42537867" class="c"><input type="checkbox" id="c-42537867" checked=""/><div class="controls bullet"><span class="by">carlhjerpe</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42537315">parent</a><span>|</span><a href="#42537452">next</a><span>|</span><label class="collapse" for="c-42537867">[-]</label><label class="expand" for="c-42537867">[1 more]</label></div><br/><div class="children"><div class="content">And NixOS has bash somewhere in the Nix store... :)<p>Clarification: &#x2F;usr&#x2F;bin&#x2F;env should be used for pretty much every shebang since it looks up the binary on $PATH.</div><br/></div></div></div></div></div></div></div></div><div id="42537452" class="c"><input type="checkbox" id="c-42537452" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536344">parent</a><span>|</span><a href="#42536717">prev</a><span>|</span><a href="#42536923">next</a><span>|</span><label class="collapse" for="c-42537452">[-]</label><label class="expand" for="c-42537452">[1 more]</label></div><br/><div class="children"><div class="content">I think that oilshell is aimed at people like you. I’ve never used it, but their website does make some interesting points about how a shell ought to work and how this could be compatible with bash.</div><br/></div></div><div id="42536923" class="c"><input type="checkbox" id="c-42536923" checked=""/><div class="controls bullet"><span class="by">assbuttbuttass</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536344">parent</a><span>|</span><a href="#42537452">prev</a><span>|</span><a href="#42536820">next</a><span>|</span><label class="collapse" for="c-42536923">[-]</label><label class="expand" for="c-42536923">[1 more]</label></div><br/><div class="children"><div class="content">As a go programmer, &quot;; or return&quot; makes a lot of sense to me</div><br/></div></div></div></div><div id="42536820" class="c"><input type="checkbox" id="c-42536820" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42536080">parent</a><span>|</span><a href="#42536344">prev</a><span>|</span><a href="#42536846">next</a><span>|</span><label class="collapse" for="c-42536820">[-]</label><label class="expand" for="c-42536820">[1 more]</label></div><br/><div class="children"><div class="content">I went bash -&gt; fish -&gt; zsh.<p>The main reason I switched is because zsh can (often) source bash scripts and can use bash completion scripts (usually), and I was tired of having to translate things from bash to fish. I also ran into a few things where something that was relatively easy to do in bash was impossible to do with fish. But that was years ago so maybe that is less of an issue now, and I don&#x27;t remember exactly what it was.<p>Having used zsh, I think a big advantage it has over fish is the completions. There are  completions available for more programs for zsh, and the zsh completions are sometimes higher quality in zsh.<p>But I do generally like the syntax, and good out of the box experience of fish. I wish it had a bash or even posix compatibility mode and more available completions.</div><br/></div></div><div id="42536846" class="c"><input type="checkbox" id="c-42536846" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42536080">parent</a><span>|</span><a href="#42536820">prev</a><span>|</span><a href="#42536547">next</a><span>|</span><label class="collapse" for="c-42536846">[-]</label><label class="expand" for="c-42536846">[3 more]</label></div><br/><div class="children"><div class="content">Same here. I used it for about 3 days before I installed it on all my systems and permanently switched. For me, it was like the first time I learned a non-Latin language, and my eyes were opened to how much stuff I took for granted was completely arbitrary.<p>For example, here&#x27;s how you write an autoloaded function &quot;foo&quot; in Fish: you make a file called &quot;foo.fish&quot; in its config directory. Inside that, you write &quot;function foo ...&quot; to implement it. There&#x27;s no step 3. That&#x27;s it.<p>Want to customize your shell prompt? Follow the process above to write a function called &quot;fish_prompt&quot; that uses normal scripting things like echo, pwd, git, or whatever to write your prompt to the screen. There&#x27;s no step 2. That&#x27;s it.<p>Fish was revelatory. Other shells of the same vintage feel hopelessly outdated to me now. For context, I was the maintainer of FreeBSD&#x27;s &quot;bash-completion&quot; port for a few years way back when. It&#x27;s not that I don&#x27;t have experience with other shells. I have plenty. I just don&#x27;t want to use any of the others now.</div><br/><div id="42537724" class="c"><input type="checkbox" id="c-42537724" checked=""/><div class="controls bullet"><span class="by">coffeeindex</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536846">parent</a><span>|</span><a href="#42536547">next</a><span>|</span><label class="collapse" for="c-42537724">[-]</label><label class="expand" for="c-42537724">[2 more]</label></div><br/><div class="children"><div class="content">Is the “foo.fish” name required? Could I have “bar.fish” with “function foo…” inside and still autoload function foo?</div><br/><div id="42537741" class="c"><input type="checkbox" id="c-42537741" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42537724">parent</a><span>|</span><a href="#42536547">next</a><span>|</span><label class="collapse" for="c-42537741">[-]</label><label class="expand" for="c-42537741">[1 more]</label></div><br/><div class="children"><div class="content">Not autoload, no. You can have as many functions as you want in a single .fish file, but it&#x27;ll only be lazily autoloaded if it has the same name as the command you are trying to execute. It&#x27;s how we avoid doing the I&#x2F;O of scanning all fish directories and parsing their contents at startup.</div><br/></div></div></div></div></div></div><div id="42536547" class="c"><input type="checkbox" id="c-42536547" checked=""/><div class="controls bullet"><span class="by">bravura</span><span>|</span><a href="#42536080">parent</a><span>|</span><a href="#42536846">prev</a><span>|</span><a href="#42536190">next</a><span>|</span><label class="collapse" for="c-42536547">[-]</label><label class="expand" for="c-42536547">[4 more]</label></div><br/><div class="children"><div class="content">Do you mind sharing what you think are the killer features of fish?</div><br/><div id="42536741" class="c"><input type="checkbox" id="c-42536741" checked=""/><div class="controls bullet"><span class="by">matthewmc3</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536547">parent</a><span>|</span><a href="#42536633">next</a><span>|</span><label class="collapse" for="c-42536741">[-]</label><label class="expand" for="c-42536741">[1 more]</label></div><br/><div class="children"><div class="content">Fish has a lot of features out of the box I find really useful:<p>* Command auto suggestions as you type based on your history<p>* History search (using up arrow) based on a partial command<p>* Helpful completions and descriptions when you hit TAB<p>* Muti-line command editing<p>* Syntax highlighting<p>You can get all those same features in Zsh by using plugins, but those features work out-of-the-box with Fish with zero configuration. Zsh is a bit of a pain to configure, and pretty anemic without plugins. Fish makes configuration optional because it works how you&#x27;d hope your shell would out of the box. Even though Zsh has those features as plugins, they&#x27;re kinda janky, not well maintained, and often conflict with other plugins.<p>Additionally, Fish also has:<p>* Excellent built in commands (string, math, argparse)<p>* Sane scripting (word parsing where you don&#x27;t need to quote everything, etc)<p>* Great documentation<p>* A web-based configuration if you&#x27;re into that sort of thing (it&#x27;s a bit of a gimmick for beginners)<p>The main reason I use Zsh (or Bash) at all is for POSIX&#x2F;portability, or for when I can&#x27;t install something else. But for an interactive shell on a machine I control, it&#x27;s hard to compete with Fish for speed, features, and ease of use.</div><br/></div></div><div id="42536633" class="c"><input type="checkbox" id="c-42536633" checked=""/><div class="controls bullet"><span class="by">chabons</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536547">parent</a><span>|</span><a href="#42536741">prev</a><span>|</span><a href="#42536190">next</a><span>|</span><label class="collapse" for="c-42536633">[-]</label><label class="expand" for="c-42536633">[2 more]</label></div><br/><div class="children"><div class="content">For me, it&#x27;s that the ergonomics are straightforward, and everything works out of the box. If I find myself on a new machine, just installing fish gives me an ergonomic setup without having to install too many additional tools or mess with configuration.</div><br/><div id="42536674" class="c"><input type="checkbox" id="c-42536674" checked=""/><div class="controls bullet"><span class="by">HKH2</span><span>|</span><a href="#42536080">root</a><span>|</span><a href="#42536633">parent</a><span>|</span><a href="#42536190">next</a><span>|</span><label class="collapse" for="c-42536674">[-]</label><label class="expand" for="c-42536674">[1 more]</label></div><br/><div class="children"><div class="content">Also, fish_config is there if you want to make quick changes without having to look up syntax.</div><br/></div></div></div></div></div></div></div></div><div id="42536190" class="c"><input type="checkbox" id="c-42536190" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#42536080">prev</a><span>|</span><a href="#42536267">next</a><span>|</span><label class="collapse" for="c-42536190">[-]</label><label class="expand" for="c-42536190">[14 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The one platform we care about a bit that it does not currently seem to have enough support for is Cygwin, which is sad, but we have to make a cut somewhere.</i><p>&gt; <i>We’re also losing Cygwin as a supported platform for the time being, because there is no Rust target for Cygwin and so no way to build binaries targeting it. We hope that this situation changes in future, but we had also hoped it would improve during the almost two years of the port. For now, the only way to run fish on Windows is to use WSL.</i><p>I understand, but this is indeed incredibly sad.  To this day I still use Cygwin, and in fact prefer it to WSL depending on what I&#x27;m doing.  Cygwin is an incredible project that is borderline miraculous for what it accomplished and provides.  Without Cygwin I may not have any sanity left.  I can&#x27;t exude enough love for the Cygwin team.<p>Hopefully rust will support cygwin as a build target in the future!</div><br/><div id="42537299" class="c"><input type="checkbox" id="c-42537299" checked=""/><div class="controls bullet"><span class="by">bloppe</span><span>|</span><a href="#42536190">parent</a><span>|</span><a href="#42536552">next</a><span>|</span><label class="collapse" for="c-42537299">[-]</label><label class="expand" for="c-42537299">[5 more]</label></div><br/><div class="children"><div class="content">genuinely curious: with so much love for cygwin, why not just run Linux? possibly with a dual boot?</div><br/><div id="42537488" class="c"><input type="checkbox" id="c-42537488" checked=""/><div class="controls bullet"><span class="by">3eb7988a1663</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42537299">parent</a><span>|</span><a href="#42537641">next</a><span>|</span><label class="collapse" for="c-42537488">[-]</label><label class="expand" for="c-42537488">[1 more]</label></div><br/><div class="children"><div class="content">Corporate jobs are nearly always on Windows machines. Cygwin+GitBash can usually sneak past the gate without raising too many eyebrows. WSL is still voodoo dark mark that can require conversations to get IT to allow.</div><br/></div></div><div id="42537641" class="c"><input type="checkbox" id="c-42537641" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42537299">parent</a><span>|</span><a href="#42537488">prev</a><span>|</span><a href="#42536552">next</a><span>|</span><label class="collapse" for="c-42537641">[-]</label><label class="expand" for="c-42537641">[3 more]</label></div><br/><div class="children"><div class="content">Switching between OSes is a hassle. Besides WSL already has all the loveable parts of Linux, there isn&#x27;t much point in dual booting anymore</div><br/><div id="42537738" class="c"><input type="checkbox" id="c-42537738" checked=""/><div class="controls bullet"><span class="by">coffeeindex</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42537641">parent</a><span>|</span><a href="#42536552">next</a><span>|</span><label class="collapse" for="c-42537738">[-]</label><label class="expand" for="c-42537738">[2 more]</label></div><br/><div class="children"><div class="content">If you’re using WSL, why use Cygwin?</div><br/><div id="42537937" class="c"><input type="checkbox" id="c-42537937" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42537738">parent</a><span>|</span><a href="#42536552">next</a><span>|</span><label class="collapse" for="c-42537937">[-]</label><label class="expand" for="c-42537937">[1 more]</label></div><br/><div class="children"><div class="content">To avoid using cmd.exe&#x2F;PowerShell for stuff that needs to run natively. For example, when I used Linux I&#x27;d use this very small program named darkhttpd for sharing files among my computers over WiFi; when I switched to Windows I compiled it on Cygwin and it worked just as fine.</div><br/></div></div></div></div></div></div></div></div><div id="42536552" class="c"><input type="checkbox" id="c-42536552" checked=""/><div class="controls bullet"><span class="by">anonnon</span><span>|</span><a href="#42536190">parent</a><span>|</span><a href="#42537299">prev</a><span>|</span><a href="#42536267">next</a><span>|</span><label class="collapse" for="c-42536552">[-]</label><label class="expand" for="c-42536552">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s strange how the article starts off complaining about C++&#x27;s platform &quot;issues&quot;:<p>&gt; We’ve experienced some pain with C++. In short:<p>&gt; tools and compiler&#x2F;platform differences<p>before conceding that, because of Rust, they 1) are actually dropping support for a platform they previously supported and 2) can only support (in theory) a small fraction of those platforms supported by g++, but that that&#x27;s OK because those are the only platforms which really matter. I get that it&#x27;s a trade-off, but it would have been more intellectually honest to just admit this is one area (portability, backwards compatibility, and ABI stability) where C++ mops the floor with Rust, instead of pretending it&#x27;s a another paintpoint Rust avoids.</div><br/><div id="42537204" class="c"><input type="checkbox" id="c-42537204" checked=""/><div class="controls bullet"><span class="by">mymoomin</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42536552">parent</a><span>|</span><a href="#42538573">next</a><span>|</span><label class="collapse" for="c-42537204">[-]</label><label class="expand" for="c-42537204">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how the article is pretending anything. They had platform issues with C++ (portability and usability on the platforms they supported), and switching to Rust fixed those issues but gave them a different set of platform issues (they could no longer support Cygwin).</div><br/></div></div><div id="42538573" class="c"><input type="checkbox" id="c-42538573" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42536552">parent</a><span>|</span><a href="#42537204">prev</a><span>|</span><a href="#42537387">next</a><span>|</span><label class="collapse" for="c-42538573">[-]</label><label class="expand" for="c-42538573">[1 more]</label></div><br/><div class="children"><div class="content">C++ may run in more places than Rust but that&#x27;s nothing to do with how good the tooling is. C++ runs everywhere <i>AND</i> its tooling is abysmal.</div><br/></div></div><div id="42537387" class="c"><input type="checkbox" id="c-42537387" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42536552">parent</a><span>|</span><a href="#42538573">prev</a><span>|</span><a href="#42536867">next</a><span>|</span><label class="collapse" for="c-42537387">[-]</label><label class="expand" for="c-42537387">[1 more]</label></div><br/><div class="children"><div class="content">Neither c++ nor rust is a clear winner in portability and platform support. C++ is available on more platforms,  but in some ways rust makes it easier to support multiple platforms than it is in c++, for example using rustup to install the latest version of the compiler.<p>What they got from this isn&#x27;t that they can now support more platforms, but that they now don&#x27;t have to spend as much effort on supporting dealing with differences between different platforms.</div><br/></div></div><div id="42536867" class="c"><input type="checkbox" id="c-42536867" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42536552">parent</a><span>|</span><a href="#42537387">prev</a><span>|</span><a href="#42536267">next</a><span>|</span><label class="collapse" for="c-42536867">[-]</label><label class="expand" for="c-42536867">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s somewhat interesting that they point to Debian&#x27;s popcon (which is opt-in), when the statistics are basically coming from amd64, whereas I think it would be much more interesting (if possible) to see what the number of installs of fish are on openwrt (and other embedded distros). Currently the openwrt fish install is ~2MB (which is massive on a router), I wonder what the new install size will be with the rust version, and if practically they&#x27;ve dropped everything except desktop&#x2F;server linux and MacOS?</div><br/><div id="42537329" class="c"><input type="checkbox" id="c-42537329" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42536867">parent</a><span>|</span><a href="#42536267">next</a><span>|</span><label class="collapse" for="c-42537329">[-]</label><label class="expand" for="c-42537329">[3 more]</label></div><br/><div class="children"><div class="content">Rust binaries, once stripped, are not necessarily much fatter than their C++ counterparts. We&#x27;re not expecting a huge increase there.<p>Embedded distros should still be supported, though you <i>might</i> need to cross-compile for a few depending on rust toolchain availability. Cygwin is <i>supposed</i> to be getting a working rust target at some point, but who knows?</div><br/><div id="42537781" class="c"><input type="checkbox" id="c-42537781" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42537329">parent</a><span>|</span><a href="#42536267">next</a><span>|</span><label class="collapse" for="c-42537781">[-]</label><label class="expand" for="c-42537781">[2 more]</label></div><br/><div class="children"><div class="content">I fully expect fish 4.0 to be in openwrt (because openwrt runs on x86_64), but what percentage openwrt machines have the space to run it would be interesting (I suspect it won&#x27;t be an issue, as likely those near the lower limit of openwrt are probably sticking with busybox anyway, and not installing a different shell).<p>Personally, what I want is inexpensive hardware (routers, but also storage devices) that don&#x27;t use much power (e.g. ~5W) but are also viable targets for projects like fish, so we can all have nice things.</div><br/><div id="42537919" class="c"><input type="checkbox" id="c-42537919" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536190">root</a><span>|</span><a href="#42537781">parent</a><span>|</span><a href="#42536267">next</a><span>|</span><label class="collapse" for="c-42537919">[-]</label><label class="expand" for="c-42537919">[1 more]</label></div><br/><div class="children"><div class="content">I <i>know</i> rust-fish is being used on at least some non-x86_64 non-aarch64 routers because we&#x27;ve accepted patches by those users to make it build on platforms without native 64-bit CAS.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42536267" class="c"><input type="checkbox" id="c-42536267" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#42536190">prev</a><span>|</span><a href="#42538460">next</a><span>|</span><label class="collapse" for="c-42536267">[-]</label><label class="expand" for="c-42536267">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The one goal of the port we did not succeed in was removing CMake.<p>&gt; That’s because, while cargo is great at building things, it is very simplistic at installing them. Cargo wants everything in a few neat binaries, and that isn’t our use case. Fish has about 1200 .fish scripts (961 completions, 217 associated functions), as well as about 130 pages of documentation (as html and man pages), and the web-config tool and the man page generator (both written in python).<p>Our issue for this is <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;2729">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;2729</a><p>Personally, I lean away from Cargo expanding into these use cases and prefer another tool being implemented on top. I&#x27;ve written more about this at <a href="https:&#x2F;&#x2F;epage.github.io&#x2F;blog&#x2F;2023&#x2F;08&#x2F;are-we-gui-build-yet&#x2F;" rel="nofollow">https:&#x2F;&#x2F;epage.github.io&#x2F;blog&#x2F;2023&#x2F;08&#x2F;are-we-gui-build-yet&#x2F;</a></div><br/><div id="42536492" class="c"><input type="checkbox" id="c-42536492" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42536267">parent</a><span>|</span><a href="#42538460">next</a><span>|</span><label class="collapse" for="c-42536492">[-]</label><label class="expand" for="c-42536492">[3 more]</label></div><br/><div class="children"><div class="content">(hi Ed!)<p>I would definitely love to see Cargo have the ability to do this -- it means that `cargo install --locked` stays as a viable approach. It probably won&#x27;t apply to fish, but I think being able to run a post-install command from the binary you just installed would suffice for my needs.</div><br/><div id="42537333" class="c"><input type="checkbox" id="c-42537333" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536267">root</a><span>|</span><a href="#42536492">parent</a><span>|</span><a href="#42538460">next</a><span>|</span><label class="collapse" for="c-42537333">[-]</label><label class="expand" for="c-42537333">[2 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve actually added support to make single-binary fish deployments possible by (optionally) bundling static resources that would be part of the CMake-based deployment into the binary itself and having it unwrap those on first execution. The limitations of Cargo and the idiomatic `cargo install` usage primarily motivated this.</div><br/><div id="42538427" class="c"><input type="checkbox" id="c-42538427" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42536267">root</a><span>|</span><a href="#42537333">parent</a><span>|</span><a href="#42538460">next</a><span>|</span><label class="collapse" for="c-42538427">[-]</label><label class="expand" for="c-42538427">[1 more]</label></div><br/><div class="children"><div class="content">Ah interesting, I looked through your build.rs for the &quot;installable&quot; feature, and it looked like you were running sphinx-build in there. Do you plan to ship those artifacts in the .crate file?</div><br/></div></div></div></div></div></div></div></div><div id="42538460" class="c"><input type="checkbox" id="c-42538460" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#42536267">prev</a><span>|</span><a href="#42538511">next</a><span>|</span><label class="collapse" for="c-42538460">[-]</label><label class="expand" for="c-42538460">[1 more]</label></div><br/><div class="children"><div class="content">Very nice too see Rust being used where it is actually appropriate! Hopefully Rust &quot;easy&quot; multi-threading will allow more parts of fish to be async, even though it&#x27;s already much better in that regard than bash (or any other shell I&#x27;ve seen).<p>One weird thing I&#x27;d also like to see is more bash integration, as others pointed out that being their primary motivation against switching to fish full-time. My use case is mostly sourcing bashrc&#x2F;bashevv, and theoretically it should be possible in fish if I understand correctly: you need to be able to import e.g. every new env variable that changed before and after sourcing a bash script via real bash.</div><br/></div></div><div id="42538511" class="c"><input type="checkbox" id="c-42538511" checked=""/><div class="controls bullet"><span class="by">outlore</span><span>|</span><a href="#42538460">prev</a><span>|</span><a href="#42538518">next</a><span>|</span><label class="collapse" for="c-42538511">[-]</label><label class="expand" for="c-42538511">[2 more]</label></div><br/><div class="children"><div class="content">I am curious to ask others here, are there other low-config alternative tools like Fish that, looking back, now seem like a no brainer? Ghostty is a recent example, Helix seems like another. I’d love to know about other tools people are using that have improved or simplified their lives.</div><br/><div id="42538582" class="c"><input type="checkbox" id="c-42538582" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#42538511">parent</a><span>|</span><a href="#42538518">next</a><span>|</span><label class="collapse" for="c-42538582">[-]</label><label class="expand" for="c-42538582">[1 more]</label></div><br/><div class="children"><div class="content">mise, uv, ruff, starship is my current list.</div><br/></div></div></div></div><div id="42536331" class="c"><input type="checkbox" id="c-42536331" checked=""/><div class="controls bullet"><span class="by">OptionOfT</span><span>|</span><a href="#42538518">prev</a><span>|</span><a href="#42537912">next</a><span>|</span><label class="collapse" for="c-42536331">[-]</label><label class="expand" for="c-42536331">[3 more]</label></div><br/><div class="children"><div class="content">&gt; it is often better to use if cfg!(...) instead of #[cfg(...)] because code behind the latter is eliminated very early<p>My experience with this is the other way around, especially if you have crates tied to that feature.<p>The cfg! is a marco that compiles to true&#x2F;false, so whatever is inside of the if guard needs to compile regardless.<p>E.g.:<p>Cargo.toml<p><pre><code>    [features]
    default = []
    my_feature = [&quot;deps:feature_dependency&quot;]

    [dependencies]
    feature_dependency = &quot;1.0.0&quot;
</code></pre>
And in code:<p><pre><code>    if cfg!(feature = &quot;my_feature&quot;) {
        feature_dependency::something::Something::invoke();
    }
</code></pre>
This will fail if you compile without `my_feature`.</div><br/><div id="42536416" class="c"><input type="checkbox" id="c-42536416" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42536331">parent</a><span>|</span><a href="#42538541">next</a><span>|</span><label class="collapse" for="c-42536416">[-]</label><label class="expand" for="c-42536416">[1 more]</label></div><br/><div class="children"><div class="content">That was the point. The paragraph is talking about how errors only show up in some configurations, leading to “works for me” behavior for some of the devs. When you can get away with cfg!, you are more confident that it will at least compile regardless of the config being checked.</div><br/></div></div><div id="42538541" class="c"><input type="checkbox" id="c-42538541" checked=""/><div class="controls bullet"><span class="by">dajonker</span><span>|</span><a href="#42536331">parent</a><span>|</span><a href="#42536416">prev</a><span>|</span><a href="#42537912">next</a><span>|</span><label class="collapse" for="c-42538541">[-]</label><label class="expand" for="c-42538541">[1 more]</label></div><br/><div class="children"><div class="content">I might be wrong but most optimizing compilers will treat &quot;if false&quot; and the following code as dead and remove it.</div><br/></div></div></div></div><div id="42537912" class="c"><input type="checkbox" id="c-42537912" checked=""/><div class="controls bullet"><span class="by">underdeserver</span><span>|</span><a href="#42536331">prev</a><span>|</span><a href="#42536790">next</a><span>|</span><label class="collapse" for="c-42537912">[-]</label><label class="expand" for="c-42537912">[1 more]</label></div><br/><div class="children"><div class="content">The tone in the &quot;The Timeline&quot; section seems apologetic:<p>&gt; The initial PR had a timeline of “handwaving, half a year”. It was clear to all of us that it might very well be entirely off, and we’re not disappointed that it was.<p>I&#x27;m amazed that you estimated it at so little time originally, and I&#x27;m amazed you shipped it in full in just 2 years. Congrats!</div><br/></div></div><div id="42536790" class="c"><input type="checkbox" id="c-42536790" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42537912">prev</a><span>|</span><a href="#42535879">next</a><span>|</span><label class="collapse" for="c-42536790">[-]</label><label class="expand" for="c-42536790">[4 more]</label></div><br/><div class="children"><div class="content">Congrats to the Fish team. The best shell just got better.<p>How about updating the project tagline to: &quot;Finally, a shell for the 00s!&quot;</div><br/><div id="42537363" class="c"><input type="checkbox" id="c-42537363" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536790">parent</a><span>|</span><a href="#42535879">next</a><span>|</span><label class="collapse" for="c-42537363">[-]</label><label class="expand" for="c-42537363">[3 more]</label></div><br/><div class="children"><div class="content">Thanks but one cannot be too ambitious like that! &#x27;00s would mean the end of zip drives, dealing with unstandardized flash drives flakier than the floppy disks of old, and supporting point-and-shoot digital cameras!</div><br/><div id="42538430" class="c"><input type="checkbox" id="c-42538430" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#42536790">root</a><span>|</span><a href="#42537363">parent</a><span>|</span><a href="#42538463">next</a><span>|</span><label class="collapse" for="c-42538430">[-]</label><label class="expand" for="c-42538430">[1 more]</label></div><br/><div class="children"><div class="content">I guess the author meant &quot;the shell for &#x27;000s&quot;, but that&#x27;s too much to type</div><br/></div></div><div id="42538463" class="c"><input type="checkbox" id="c-42538463" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42536790">root</a><span>|</span><a href="#42537363">parent</a><span>|</span><a href="#42538430">prev</a><span>|</span><a href="#42535879">next</a><span>|</span><label class="collapse" for="c-42538463">[-]</label><label class="expand" for="c-42538463">[1 more]</label></div><br/><div class="children"><div class="content">That’s true. Better to stick to the 90s where we are safe.</div><br/></div></div></div></div></div></div><div id="42535879" class="c"><input type="checkbox" id="c-42535879" checked=""/><div class="controls bullet"><span class="by">petepete</span><span>|</span><a href="#42536790">prev</a><span>|</span><a href="#42536825">next</a><span>|</span><label class="collapse" for="c-42535879">[-]</label><label class="expand" for="c-42535879">[1 more]</label></div><br/><div class="children"><div class="content">Really happy to see this, such a mammoth effort by the team and everyone else involved.<p>I switched over from zsh about four years ago and my config went from several hundred lines to a handful with just one plugin (fzf.fish).<p>It just works how I expect it to and I can&#x27;t imagine changing again any time soon.</div><br/></div></div><div id="42536825" class="c"><input type="checkbox" id="c-42536825" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#42535879">prev</a><span>|</span><a href="#42536814">next</a><span>|</span><label class="collapse" for="c-42536825">[-]</label><label class="expand" for="c-42536825">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be really interested to hear from distro packagers how this is going - how amenable is rust-fish to being packaged following e.g. Debian guidelines?</div><br/><div id="42537370" class="c"><input type="checkbox" id="c-42537370" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42536825">parent</a><span>|</span><a href="#42537218">next</a><span>|</span><label class="collapse" for="c-42537370">[-]</label><label class="expand" for="c-42537370">[1 more]</label></div><br/><div class="children"><div class="content">We took an incredible amount of care to consider the package maintainer requirements for our the most popular distributions using&#x2F;distributing fish. One of our maintainers is very careful about letting us know when we&#x27;re doing something that might upset distro packagers, and we&#x27;re constantly letting package maintainer guidelines and requirements influence how we structure fish itself and which dependencies we pull in.</div><br/></div></div><div id="42537218" class="c"><input type="checkbox" id="c-42537218" checked=""/><div class="controls bullet"><span class="by">zanchey</span><span>|</span><a href="#42536825">parent</a><span>|</span><a href="#42537370">prev</a><span>|</span><a href="#42536814">next</a><span>|</span><label class="collapse" for="c-42537218">[-]</label><label class="expand" for="c-42537218">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hopefully not too tricky - it can&#x27;t be packaged as a crate using (say) debcargo, as the install path still requires CMake. The Debian experimental package changes are mostly about pulling in the right dependencies (including some internal mangling to support some policy choices).</div><br/></div></div></div></div><div id="42536814" class="c"><input type="checkbox" id="c-42536814" checked=""/><div class="controls bullet"><span class="by">nixpulvis</span><span>|</span><a href="#42536825">prev</a><span>|</span><a href="#42538039">next</a><span>|</span><label class="collapse" for="c-42536814">[-]</label><label class="expand" for="c-42536814">[1 more]</label></div><br/><div class="children"><div class="content">Awesome to see. Can&#x27;t wait to see how things improve from here.<p>Here&#x27;s the code if you were looking for it: <a href="https:&#x2F;&#x2F;github.com&#x2F;fish-shell&#x2F;fish-shell&#x2F;tree&#x2F;4.0b1">https:&#x2F;&#x2F;github.com&#x2F;fish-shell&#x2F;fish-shell&#x2F;tree&#x2F;4.0b1</a></div><br/></div></div><div id="42538039" class="c"><input type="checkbox" id="c-42538039" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#42536814">prev</a><span>|</span><a href="#42535898">next</a><span>|</span><label class="collapse" for="c-42538039">[-]</label><label class="expand" for="c-42538039">[3 more]</label></div><br/><div class="children"><div class="content">I use the shell a lot every day, mainly bash and some ash (alpine).<p>Does something like fish make the experience a bit smoother? is it pretty easy to get into?</div><br/><div id="42538321" class="c"><input type="checkbox" id="c-42538321" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#42538039">parent</a><span>|</span><a href="#42538076">next</a><span>|</span><label class="collapse" for="c-42538321">[-]</label><label class="expand" for="c-42538321">[1 more]</label></div><br/><div class="children"><div class="content">I have to ssh into different places quite frequently and keeping the zsh configuration synced was a pain. Fish had 95% of what I needed out of the box so rather than putting a ton of scripts in place, installing omz, plug-ins etc, I run a single install command.</div><br/></div></div><div id="42538076" class="c"><input type="checkbox" id="c-42538076" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42538039">parent</a><span>|</span><a href="#42538321">prev</a><span>|</span><a href="#42535898">next</a><span>|</span><label class="collapse" for="c-42538076">[-]</label><label class="expand" for="c-42538076">[1 more]</label></div><br/><div class="children"><div class="content">fish is intended to be beginner friendly, whether you&#x27;re new to the commandline world or not. It&#x27;s essentially configuration-free, so that&#x27;s about as easy to get into as you might imagine.</div><br/></div></div></div></div><div id="42535898" class="c"><input type="checkbox" id="c-42535898" checked=""/><div class="controls bullet"><span class="by">Spoof7726</span><span>|</span><a href="#42538039">prev</a><span>|</span><a href="#42537103">next</a><span>|</span><label class="collapse" for="c-42535898">[-]</label><label class="expand" for="c-42535898">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Fish also uses threads for its award-winning (note to editor: find an actual award) autosuggestions and syntax highlighting, and one long-term project is to add concurrency to the language.<p>(note to editor: find an actual award)</div><br/><div id="42536073" class="c"><input type="checkbox" id="c-42536073" checked=""/><div class="controls bullet"><span class="by">syhol</span><span>|</span><a href="#42535898">parent</a><span>|</span><a href="#42536051">next</a><span>|</span><label class="collapse" for="c-42536073">[-]</label><label class="expand" for="c-42536073">[2 more]</label></div><br/><div class="children"><div class="content">The two most popular zsh plugins are total clones of this at 31k and 20k gh stars respectively. Not an award but certainly an indication of its success.</div><br/><div id="42536431" class="c"><input type="checkbox" id="c-42536431" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42535898">root</a><span>|</span><a href="#42536073">parent</a><span>|</span><a href="#42536051">next</a><span>|</span><label class="collapse" for="c-42536431">[-]</label><label class="expand" for="c-42536431">[1 more]</label></div><br/><div class="children"><div class="content">Having used zsh with those plugins for a while and not having used fish personally, I&#x27;ll nominate them for &quot;most desirable plugins to copy for your own shell to make it more user-friendly&quot;.</div><br/></div></div></div></div><div id="42536051" class="c"><input type="checkbox" id="c-42536051" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#42535898">parent</a><span>|</span><a href="#42536073">prev</a><span>|</span><a href="#42536472">next</a><span>|</span><label class="collapse" for="c-42536051">[-]</label><label class="expand" for="c-42536051">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s a joke my friend</div><br/></div></div><div id="42536472" class="c"><input type="checkbox" id="c-42536472" checked=""/><div class="controls bullet"><span class="by">paradox460</span><span>|</span><a href="#42535898">parent</a><span>|</span><a href="#42536051">prev</a><span>|</span><a href="#42537103">next</a><span>|</span><label class="collapse" for="c-42536472">[-]</label><label class="expand" for="c-42536472">[2 more]</label></div><br/><div class="children"><div class="content">They should make an award, like RL Stein did<p><a href="https:&#x2F;&#x2F;x.com&#x2F;RL_Stine&#x2F;status&#x2F;1337768882988347393" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;RL_Stine&#x2F;status&#x2F;1337768882988347393</a></div><br/><div id="42536622" class="c"><input type="checkbox" id="c-42536622" checked=""/><div class="controls bullet"><span class="by">nosrepa</span><span>|</span><a href="#42535898">root</a><span>|</span><a href="#42536472">parent</a><span>|</span><a href="#42537103">next</a><span>|</span><label class="collapse" for="c-42536622">[-]</label><label class="expand" for="c-42536622">[1 more]</label></div><br/><div class="children"><div class="content">Or like any car award that oems advertise.</div><br/></div></div></div></div></div></div><div id="42537103" class="c"><input type="checkbox" id="c-42537103" checked=""/><div class="controls bullet"><span class="by">cute_boi</span><span>|</span><a href="#42535898">prev</a><span>|</span><a href="#42537482">next</a><span>|</span><label class="collapse" for="c-42537103">[-]</label><label class="expand" for="c-42537103">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations. Rust is really a great language. I wrote a small rust web server and its been a year and it seems to work great on $5 vps without any issue.</div><br/></div></div><div id="42537482" class="c"><input type="checkbox" id="c-42537482" checked=""/><div class="controls bullet"><span class="by">preisschild</span><span>|</span><a href="#42537103">prev</a><span>|</span><a href="#42536513">next</a><span>|</span><label class="collapse" for="c-42537482">[-]</label><label class="expand" for="c-42537482">[2 more]</label></div><br/><div class="children"><div class="content">I would love to use fish, but it seems there really isnt a oh-my-zsh equivalent.<p>I dont even need the OMZ prompt (i use starship for that), but the aliases from the kubectl and git plugins are just so great to have if you use kubectl and git often.<p>Other plugins (like colored-man-pages, fzf-tab and syntax-highlighting) are also nice.<p>Is there something like that for fish?<p>Oh-my-fish has some of those features, but it seems to be abandoned.</div><br/><div id="42537506" class="c"><input type="checkbox" id="c-42537506" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42537482">parent</a><span>|</span><a href="#42536513">next</a><span>|</span><label class="collapse" for="c-42537506">[-]</label><label class="expand" for="c-42537506">[1 more]</label></div><br/><div class="children"><div class="content">Integration with 3rd party scripts and tools is often a single line in your config.fish, something like `foo --init-fish | source` or better yet, `command -q foo &amp;&amp; foo --init-fish | source`<p>We don&#x27;t recommend oh-my-fish for various reasons, but I guess what&#x27;s really missing is just a gallery.</div><br/></div></div></div></div><div id="42536513" class="c"><input type="checkbox" id="c-42536513" checked=""/><div class="controls bullet"><span class="by">wellthisisgreat</span><span>|</span><a href="#42537482">prev</a><span>|</span><a href="#42535858">next</a><span>|</span><label class="collapse" for="c-42536513">[-]</label><label class="expand" for="c-42536513">[3 more]</label></div><br/><div class="children"><div class="content">Is fish better than Zsh?</div><br/><div id="42537559" class="c"><input type="checkbox" id="c-42537559" checked=""/><div class="controls bullet"><span class="by">SMP-UX</span><span>|</span><a href="#42536513">parent</a><span>|</span><a href="#42536935">next</a><span>|</span><label class="collapse" for="c-42537559">[-]</label><label class="expand" for="c-42537559">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s &#x27;easier&#x27; for some people but you lose GNU bash compatibility and it kinda underlines all of the issues with interactive only shell systems -- a lack of interoperability.<p>It&#x27;s honestly a non-issue in the current year to learn zsh or tcsh</div><br/></div></div><div id="42536935" class="c"><input type="checkbox" id="c-42536935" checked=""/><div class="controls bullet"><span class="by">assbuttbuttass</span><span>|</span><a href="#42536513">parent</a><span>|</span><a href="#42537559">prev</a><span>|</span><a href="#42535858">next</a><span>|</span><label class="collapse" for="c-42536935">[-]</label><label class="expand" for="c-42536935">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely better out of the box, with no configuration. If you add a bunch of fancy plugins to zsh then they can be very similar</div><br/></div></div></div></div><div id="42537586" class="c"><input type="checkbox" id="c-42537586" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42535858">prev</a><span>|</span><a href="#42537186">next</a><span>|</span><label class="collapse" for="c-42537586">[-]</label><label class="expand" for="c-42537586">[1 more]</label></div><br/><div class="children"><div class="content">Another rewrite? Hope it&#x27;ll take off this time</div><br/></div></div><div id="42537186" class="c"><input type="checkbox" id="c-42537186" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#42537586">prev</a><span>|</span><a href="#42537501">next</a><span>|</span><label class="collapse" for="c-42537186">[-]</label><label class="expand" for="c-42537186">[1 more]</label></div><br/><div class="children"><div class="content">Glad to see at least one Rust rewrite successful (unlike [1])!<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;remacs&#x2F;remacs">https:&#x2F;&#x2F;github.com&#x2F;remacs&#x2F;remacs</a></div><br/></div></div><div id="42537501" class="c"><input type="checkbox" id="c-42537501" checked=""/><div class="controls bullet"><span class="by">gothroach</span><span>|</span><a href="#42537186">prev</a><span>|</span><a href="#42537550">next</a><span>|</span><label class="collapse" for="c-42537501">[-]</label><label class="expand" for="c-42537501">[1 more]</label></div><br/><div class="children"><div class="content">W4w4</div><br/></div></div><div id="42537550" class="c"><input type="checkbox" id="c-42537550" checked=""/><div class="controls bullet"><span class="by">SMP-UX</span><span>|</span><a href="#42537501">prev</a><span>|</span><a href="#42537039">next</a><span>|</span><label class="collapse" for="c-42537550">[-]</label><label class="expand" for="c-42537550">[1 more]</label></div><br/><div class="children"><div class="content">Another niche shell project that is going the way of the meme language. Nice.</div><br/></div></div><div id="42537039" class="c"><input type="checkbox" id="c-42537039" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42537550">prev</a><span>|</span><a href="#42537746">next</a><span>|</span><label class="collapse" for="c-42537039">[-]</label><label class="expand" for="c-42537039">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What would test -x say on Windows, which has no executable bit?<p>It would say whether the file extension is executable (part of pathext env variable)</div><br/><div id="42537168" class="c"><input type="checkbox" id="c-42537168" checked=""/><div class="controls bullet"><span class="by">pie_flavor</span><span>|</span><a href="#42537039">parent</a><span>|</span><a href="#42537746">next</a><span>|</span><label class="collapse" for="c-42537168">[-]</label><label class="expand" for="c-42537168">[1 more]</label></div><br/><div class="children"><div class="content">I should think it says the same thing as on Linux, since there absolutely is an &#x27;executable bit&#x27; (GENERIC_EXECUTE) in the ACL.</div><br/></div></div></div></div><div id="42537746" class="c"><input type="checkbox" id="c-42537746" checked=""/><div class="controls bullet"><span class="by">msoad</span><span>|</span><a href="#42537039">prev</a><span>|</span><label class="collapse" for="c-42537746">[-]</label><label class="expand" for="c-42537746">[3 more]</label></div><br/><div class="children"><div class="content">I love fish and I’ve been a user for years. In the wake of AI, I am really interested in getting out of completes via a local tiny AI model<p>Does the fish team have any plans for integrating AI models for other completion?</div><br/><div id="42537753" class="c"><input type="checkbox" id="c-42537753" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42537746">parent</a><span>|</span><label class="collapse" for="c-42537753">[-]</label><label class="expand" for="c-42537753">[2 more]</label></div><br/><div class="children"><div class="content">We ship fish with completions ollama and llm, maybe others. We don&#x27;t have any plans to &quot;integrate&quot; AI into the actual codebase.</div><br/><div id="42537830" class="c"><input type="checkbox" id="c-42537830" checked=""/><div class="controls bullet"><span class="by">msoad</span><span>|</span><a href="#42537746">root</a><span>|</span><a href="#42537753">parent</a><span>|</span><label class="collapse" for="c-42537830">[-]</label><label class="expand" for="c-42537830">[1 more]</label></div><br/><div class="children"><div class="content">I had no idea! Where can I find docs to set this up?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>