<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704099666227" as="style"/><link rel="stylesheet" href="styles.css?v=1704099666227"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cs.brown.edu/~sk/Publications/Papers/Published/ck-core-calc-doc-lambda-ultimate-doc/paper.pdf">A Core Calculus for Documents [pdf]</a> <span class="domain">(<a href="https://cs.brown.edu">cs.brown.edu</a>)</span></div><div class="subtext"><span>hasheddan</span> | <span>16 comments</span></div><br/><div><div id="38809219" class="c"><input type="checkbox" id="c-38809219" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38830135">next</a><span>|</span><label class="collapse" for="c-38809219">[-]</label><label class="expand" for="c-38809219">[11 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Any document language with a foreach-loop must somehow flatten the node list to one dimension; the key design question is where in the pipeline this should happen.</i><p>Or —and hear me out— if one uses streams (monoids) instead of lists (trees) as the basic semantics, one has associativity for free:<p><pre><code>    (s; t); u == s; (t; u)
</code></pre>
and need not kludge up unquote-splicing or other flattening schemes.<p>(the brave who proceed to use streams instead of lists not just on the right hand side, but also on the left hand side of the application operator, may discover that all their &quot;monad law&quot; proof obligations become trivial)</div><br/><div id="38828691" class="c"><input type="checkbox" id="c-38828691" checked=""/><div class="controls bullet"><span class="by">digdugdirk</span><span>|</span><a href="#38809219">parent</a><span>|</span><a href="#38829067">next</a><span>|</span><label class="collapse" for="c-38828691">[-]</label><label class="expand" for="c-38828691">[9 more]</label></div><br/><div class="children"><div class="content">If someone has zero understanding of what you just wrote but is curious to learn, what resources would you recommend starting with?</div><br/><div id="38828867" class="c"><input type="checkbox" id="c-38828867" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38828691">parent</a><span>|</span><a href="#38828772">next</a><span>|</span><label class="collapse" for="c-38828867">[-]</label><label class="expand" for="c-38828867">[7 more]</label></div><br/><div class="children"><div class="content">No need for category theory (although that might be interesting in its own right, later) or Haskell (ditto).<p>I might start with <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Monoid#Definition" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Monoid#Definition</a> or pp17-20 of <a href="https:&#x2F;&#x2F;www.cs.utoronto.ca&#x2F;~hehner&#x2F;aPToP&#x2F;aPToP.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.utoronto.ca&#x2F;~hehner&#x2F;aPToP&#x2F;aPToP.pdf</a><p>Monoid is a greek-derived name, but the structure itself is very simple: as the name implies, it&#x27;s completely one-dimensional (aka linear: you can think of them as being like those whiteboard pens that snap together).<p>If I have a monoid y, I can prepend x to it to get (x;y), or I can append z to it to get (y;z), or I can do both, in either order, to get (x;y;z). You are certainly familiar with this behaviour for addition: 1+(2+3) == (1+2)+3, and may be familiar with matrix multiplication, which differs from elementary school multiplication in that A*B is no longer necessarily equal to B*A, but it is still always true that A*(B*C) == (A*B)*C.<p>This is distinct from the behaviour of lists, where one order will produce [x [y z]] and the other order will produce [[x y] z] — despite having the same leaves, they are different lists, with distinct nesting patterns.<p>Finally, what distinguishes monoids from semigroups is that they have an identity: if we call it ∊, then we have that ∊;y == y == y;∊ (in practice this is not a big distinction, because even without a natural identity one can almost always add a formal identity) Note that you probably are already very familiar with identities in various contexts: 0+2 == 2 == 2+0, 1*3 == 3 == 3*1, and &quot;&quot;++&quot;foo&quot; == &quot;foo&quot; == &quot;foo&quot;++&quot;&quot;, etc. (and you may be familiar with the difference between finite automata which allow identity transitions —easy to build, not so efficient to use— and those which do not —efficient to use, not so easy to build—).<p>Does any of that make sense?</div><br/><div id="38829113" class="c"><input type="checkbox" id="c-38829113" checked=""/><div class="controls bullet"><span class="by">maxk42</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38828867">parent</a><span>|</span><a href="#38828772">next</a><span>|</span><label class="collapse" for="c-38829113">[-]</label><label class="expand" for="c-38829113">[6 more]</label></div><br/><div class="children"><div class="content">How does this differ from a one-dimensional array?</div><br/><div id="38830108" class="c"><input type="checkbox" id="c-38830108" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38829113">parent</a><span>|</span><a href="#38829338">next</a><span>|</span><label class="collapse" for="c-38830108">[-]</label><label class="expand" for="c-38830108">[1 more]</label></div><br/><div class="children"><div class="content">The other replies are massively overcomplicating things. A monoid is<p>- a set `X`<p>- together with an associative binary operation (let&#x27;s call it `+`)<p>- and an element (`0`) such that `a + 0 = 0 + a = a` for all elements `a` in `X`.<p>Monoids are a class of structures, the collection of all arrays of a given type (with concatenation as the monoid operation, and the empty array as its identity element) is a particular example of a monoid.<p>Other examples include the natural numbers under addition, the integers under multiplication, functions `T =&gt; T` under function composition, booleans under and, booleans under or, and strings under concatenation. They&#x27;re one of the simplest and most common algebraic structures.</div><br/></div></div><div id="38829338" class="c"><input type="checkbox" id="c-38829338" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38829113">parent</a><span>|</span><a href="#38830108">prev</a><span>|</span><a href="#38829193">next</a><span>|</span><label class="collapse" for="c-38829338">[-]</label><label class="expand" for="c-38829338">[3 more]</label></div><br/><div class="children"><div class="content">It depends upon what you mean by &quot;a one-dimensional array&quot;.<p>In the C or Fortran sense, it&#x27;s easy to work with individual elements of the array, but not so much the array as a whole.<p>(in the example above, both y and x;y;z are values in the monoid, conceptually at the same level, like &quot;f&quot; and &quot;foo&quot; are both strings despite one being length-1, and like 5 and 60 are both numbers despite one being prime)<p>In more recent, but still algol-like, languages, it&#x27;s possible to work with slices of arrays as well as individual elements, but often these slices are views backed by physical arrays, so slices and arrays are similar but still not equivalent.<p>In array languages (the APL family), there is very little difference, as it is perfectly natural to treat entire arrays (or parts of them) as values and prepend or append them to each other.<p>(pedantry: these languages go well beyond the 1D model and allow N-dimensional cubical structures; after they started to allow ragged structures as well they came much closer to the tree-orientation of LISP-likes)<p>As stated earlier, I think of whiteboard pens (snapping top to bottom, resulting in something equally snappable), or the bytestreams that flow through Unix pipes, where there is always a before and an after but nesting isn&#x27;t part of the basic deal.<p>I believe many things in CS are best treated (involved fewer arbitrary decisions) as monoids and semilattices and interactions between these structures, but because of tradition we try to attack them with lists and sets, then wind up mired in accidental complexity trying to remove layers of nesting that would never have occurred had we started with simpler representations. (eg if you feel the need to invent a &quot;programmable semicolon&quot; to ensure that all your lists get flattened as-you-go or the need to make &quot;samefringe&quot; break free of normal stack discipline, you may well make great strides in implementing Haskell or Go, but you may also be doing work which could have been completely avoided [ok, at least abstracted away] by a different choice of representation)<p>Finally, note that this whole digression was due to the (in my view &quot;accidental&quot;) problem of unquote-splicing: using monoids (a) removes the need for two unquote forms, but (b) doesn&#x27;t prevent anyone from expressing their computed SGML fragments via a monoid of tree values; a &quot;forest&quot; if you will.</div><br/><div id="38829889" class="c"><input type="checkbox" id="c-38829889" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38829338">parent</a><span>|</span><a href="#38829193">next</a><span>|</span><label class="collapse" for="c-38829889">[-]</label><label class="expand" for="c-38829889">[2 more]</label></div><br/><div class="children"><div class="content">Fortran is literally a language designed to work with (multi-dimensional) arrays as a whole.</div><br/><div id="38829969" class="c"><input type="checkbox" id="c-38829969" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38829889">parent</a><span>|</span><a href="#38829193">next</a><span>|</span><label class="collapse" for="c-38829969">[-]</label><label class="expand" for="c-38829969">[1 more]</label></div><br/><div class="children"><div class="content">Ummm...no.<p>Fortran was originally designed as a language that made dealing with numbers <i>in</i> arrays easy, but the arrays themselves were containers that had a fundamentally different type than numbers. In a true array language like APL there&#x27;s no difference.<p>Modern versions of Fortran have blurred the distinction somewhat but in older Fortran arrays were very different from numbers. Arrays couldn&#x27;t even be dynamically allocated or resized back in the day much less &quot;added together,&quot; whatever that might mean.<p>An analogy: Fortran has arrays like C has functions. But that doesn&#x27;t make Fortran an array language any more than C is a functional language.<p>APL is an array language like Haskell is a functional language.<p>In Fortran, numbers are the fundamental data type. Arrays are just collections of numbers. In APL, arrays are fundamental. A number in APL is just a lonely array.</div><br/></div></div></div></div></div></div><div id="38829193" class="c"><input type="checkbox" id="c-38829193" checked=""/><div class="controls bullet"><span class="by">selecsosi</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38829113">parent</a><span>|</span><a href="#38829338">prev</a><span>|</span><a href="#38828772">next</a><span>|</span><label class="collapse" for="c-38829193">[-]</label><label class="expand" for="c-38829193">[1 more]</label></div><br/><div class="children"><div class="content">As part of the definition of the monad it includes &quot;applying&quot; computation on the underlying dataset (wrapping and then applying a function is defined). The mondad also defines the resultant type of the operation (unwrapping) and so in another language, something like mapping a function over a dataset is a built in &quot;consequence&quot; of the definition.<p>This makes it natural to express a program as a pipeline of operations over a variety of dataset inputs by wrapping, mapping, and unwrapping operations.<p>An example is something like the IO monad in haskell allows a programmer to incorporate non-functional (side-effect) computations (e.g.  writing to disk or to console) naturally where as a 1d list (more like a buffer) doesn&#x27;t naturally express the same semantics</div><br/></div></div></div></div></div></div><div id="38828772" class="c"><input type="checkbox" id="c-38828772" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#38809219">root</a><span>|</span><a href="#38828691">parent</a><span>|</span><a href="#38828867">prev</a><span>|</span><a href="#38829067">next</a><span>|</span><label class="collapse" for="c-38828772">[-]</label><label class="expand" for="c-38828772">[1 more]</label></div><br/><div class="children"><div class="content">Category Theory for Programmers [1] covers monoids (and other concepts).  There’s a YouTube series of lectures by Bartosz Milewski too.<p>To get a complete intuition spending some time learning Haskell will also help.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;hmemcpy&#x2F;milewski-ctfp-pdf">https:&#x2F;&#x2F;github.com&#x2F;hmemcpy&#x2F;milewski-ctfp-pdf</a></div><br/></div></div></div></div><div id="38829067" class="c"><input type="checkbox" id="c-38829067" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#38809219">parent</a><span>|</span><a href="#38828691">prev</a><span>|</span><a href="#38830135">next</a><span>|</span><label class="collapse" for="c-38829067">[-]</label><label class="expand" for="c-38829067">[1 more]</label></div><br/><div class="children"><div class="content">I think their choice of distinguishing stream level semantics from tree level semantics is probably correct if you want to talk about general documents.<p>I mean an HTML document is much better modelled as a tree of nodes than a long string.</div><br/></div></div></div></div><div id="38830135" class="c"><input type="checkbox" id="c-38830135" checked=""/><div class="controls bullet"><span class="by">macmac</span><span>|</span><a href="#38809219">prev</a><span>|</span><a href="#38828978">next</a><span>|</span><label class="collapse" for="c-38830135">[-]</label><label class="expand" for="c-38830135">[1 more]</label></div><br/><div class="children"><div class="content">The arguments against for loops in Scheme returning the result of evaluation of the last form seems to be confused to me. This is what all lisps that I know of do for all blocks&#x2F;functions.</div><br/></div></div><div id="38828978" class="c"><input type="checkbox" id="c-38828978" checked=""/><div class="controls bullet"><span class="by">clircle</span><span>|</span><a href="#38830135">prev</a><span>|</span><a href="#38829744">next</a><span>|</span><label class="collapse" for="c-38828978">[-]</label><label class="expand" for="c-38828978">[2 more]</label></div><br/><div class="children"><div class="content">There will be a smidgen of irony if the authors have to convert this to Word to submit to their journal.</div><br/><div id="38829851" class="c"><input type="checkbox" id="c-38829851" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#38828978">parent</a><span>|</span><a href="#38829744">next</a><span>|</span><label class="collapse" for="c-38829851">[-]</label><label class="expand" for="c-38829851">[1 more]</label></div><br/><div class="children"><div class="content">I have yet to see an ACM conference that requires Word. I <i>am</i> a pretty new grad student, but still. I think all the CS (esp. PL folks) would throw a fit and boycott such stupidity.<p>But yes. Oh how ironic that would be. It hurts me just thinking about it.</div><br/></div></div></div></div><div id="38829744" class="c"><input type="checkbox" id="c-38829744" checked=""/><div class="controls bullet"><span class="by">lopsotronic</span><span>|</span><a href="#38828978">prev</a><span>|</span><label class="collapse" for="c-38829744">[-]</label><label class="expand" for="c-38829744">[1 more]</label></div><br/><div class="children"><div class="content">This. Is. Pure. Catnip. For. Me. What a new years present. Thanks for sending this along.<p>As always, a bit miffed they don&#x27;t mention Asciidoc, which has formal functionalities in core (transclusion, conditionals) without needing template languages or entering extension-landia.<p>But about that - I&#x27;m not convinced that non-natural language functionality like transclusion even belong in the content layer. Tech pubs teams always, always, always underestime the complexity of an interface between natural language and formalist structures (transclusion, conditionals). Ah, and the authors go through this. Boy oh boy, can I say thanks again? I&#x27;ve been looking for a paper in this vein for literal decades, as I lack the deep math.</div><br/></div></div></div></div></div></div></div></body></html>