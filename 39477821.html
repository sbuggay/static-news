<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708765281071" as="style"/><link rel="stylesheet" href="styles.css?v=1708765281071"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://go.dev/blog/generic-slice-functions">Go(lang): Robust generic functions on slices</a> <span class="domain">(<a href="https://go.dev">go.dev</a>)</span></div><div class="subtext"><span>signa11</span> | <span>23 comments</span></div><br/><div><div id="39489335" class="c"><input type="checkbox" id="c-39489335" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#39488964">next</a><span>|</span><label class="collapse" for="c-39489335">[-]</label><label class="expand" for="c-39489335">[15 more]</label></div><br/><div class="children"><div class="content">The problems with the API they point out are almost all things that rust&#x27;s ownership system was built to solve.<p>Things like:<p><pre><code>    slices.Sort(s) &#x2F;&#x2F; correct
    slices.Compact(s) &#x2F;&#x2F; incorrect
    slices.Delete(s, ...) &#x2F;&#x2F; incorrect
    s := slices.Delete(s, ...) &#x2F;&#x2F; incorrect if &#x27;s&#x27; is referenced again in the outer scope
    s = slices.Delete(s, ...) &#x2F;&#x2F; correct
</code></pre>
All of those are solved by having functions like &#x27;slices.Sort&#x27; take a &#x27;&amp;mut&#x27; reference in rust speak, and having &#x27;slices.Compact&#x27; and &#x27;Delete&#x27; take an owned slice, and return a new owned slice.</div><br/><div id="39489439" class="c"><input type="checkbox" id="c-39489439" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39489335">parent</a><span>|</span><a href="#39489861">next</a><span>|</span><label class="collapse" for="c-39489439">[-]</label><label class="expand" for="c-39489439">[13 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even need a notion of ownership. A distinction between an immutable and mutable slice should be enough, because an immutable slice can never be changed which implies that its excess capacity (if any) can&#x27;t be exploited for optimization.</div><br/><div id="39489955" class="c"><input type="checkbox" id="c-39489955" checked=""/><div class="controls bullet"><span class="by">DinaCoder99</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489439">parent</a><span>|</span><a href="#39489521">next</a><span>|</span><label class="collapse" for="c-39489955">[-]</label><label class="expand" for="c-39489955">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d need three types: immutable slice of an immutable array, mutable slice of a mutable array (ie basically a reference to a mutable array), and an immutable slice of a mutable array.</div><br/></div></div><div id="39489521" class="c"><input type="checkbox" id="c-39489521" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489439">parent</a><span>|</span><a href="#39489955">prev</a><span>|</span><a href="#39489861">next</a><span>|</span><label class="collapse" for="c-39489521">[-]</label><label class="expand" for="c-39489521">[11 more]</label></div><br/><div class="children"><div class="content">None of these functions would apply to an immutable slice, so how is it related?</div><br/><div id="39489559" class="c"><input type="checkbox" id="c-39489559" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489521">parent</a><span>|</span><a href="#39489861">next</a><span>|</span><label class="collapse" for="c-39489559">[-]</label><label class="expand" for="c-39489559">[10 more]</label></div><br/><div class="children"><div class="content">If immutable and mutable slices are differently typed [2], it is natural to define two functions (say, `slices.Compact` vs. `slices.Compacted`) to handle each type, like Python `list.sort` vs. `sorted`. It should be natural to expect `slices.Compacted` to never alter its input, and any attempt to use a mutable version will be very explicit except for slicing [1].<p>[1] Especially given that the capacity is preserved by default, which contributes to the current confusion. See my older comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39112735">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39112735</a><p>[2] Originally &quot;...are different&quot; but edited for clarity.</div><br/><div id="39489674" class="c"><input type="checkbox" id="c-39489674" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489559">parent</a><span>|</span><a href="#39489605">next</a><span>|</span><label class="collapse" for="c-39489674">[-]</label><label class="expand" for="c-39489674">[7 more]</label></div><br/><div class="children"><div class="content">This would not allow the previous errors to be checked by the compiler since the main thing you&#x27;re relying on is the name. Nothing prevents you to call deleted(mutable) and discard the result apart from the name.</div><br/><div id="39489858" class="c"><input type="checkbox" id="c-39489858" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489674">parent</a><span>|</span><a href="#39489895">next</a><span>|</span><label class="collapse" for="c-39489858">[-]</label><label class="expand" for="c-39489858">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nothing prevents you to call deleted(mutable) and discard the result<p>The Go compiler generates an error when you are (silently) ignoring the return value of any function.
Or, to put it in other words, every compiler which does allow to (silently) ignore the return value of a function, should not be used at all (C++ has at least `[[nodiscard]]` since 17 and C with C23 - which is &quot;too little and too late&quot;, as always).</div><br/></div></div><div id="39489895" class="c"><input type="checkbox" id="c-39489895" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489674">parent</a><span>|</span><a href="#39489858">prev</a><span>|</span><a href="#39489806">next</a><span>|</span><label class="collapse" for="c-39489895">[-]</label><label class="expand" for="c-39489895">[2 more]</label></div><br/><div class="children"><div class="content">While that&#x27;s a valid concern, it is an orthogoal issue as it can be similarly replicated in Rust as well. Rust references always track mutability but we can sidestep that by using `std::borrow::Cow`:<p><pre><code>    fn compacted&lt;T: ...&gt;(input: Cow&lt;&#x27;_, [T]&gt;) -&gt; Cow&lt;&#x27;_, [T]&gt; { ... }
</code></pre>
Then it is clear that, for example, `compacted(vec![...].into());` as a statement will exhibit the same behavior because `Cow` doesn&#x27;t have `#[must_use]`. Rust avoids this issue mainly by encouraging explicitly mutable or immutable values by default, and at this point the language should have substantially altered that Go can do the same.</div><br/><div id="39489987" class="c"><input type="checkbox" id="c-39489987" checked=""/><div class="controls bullet"><span class="by">nrabulinski</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489895">parent</a><span>|</span><a href="#39489806">next</a><span>|</span><label class="collapse" for="c-39489987">[-]</label><label class="expand" for="c-39489987">[1 more]</label></div><br/><div class="children"><div class="content">must_use doesn’t have to be on a type, it can be applied to a function</div><br/></div></div></div></div><div id="39489806" class="c"><input type="checkbox" id="c-39489806" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489674">parent</a><span>|</span><a href="#39489895">prev</a><span>|</span><a href="#39489605">next</a><span>|</span><label class="collapse" for="c-39489806">[-]</label><label class="expand" for="c-39489806">[3 more]</label></div><br/><div class="children"><div class="content">Indeed.  Though, Rust does have a way to mark a function such that any caller that implicitly discards its return value gets a compiler warning.  This feature largely solves the problem you’re talking about.  But it’s orthogonal to Rust’s borrowing system or mutable versus immutable distinction.<p>That said, I’d also point out that, while you can more or less replicate the Go example with Rust slices, in Rust it would be more idiomatic to pass around a Vec (or a mutable reference to a Vec) if a callee needs to do something like change the length.  And you can’t resize a Vec if there are other references to its contents.</div><br/><div id="39489879" class="c"><input type="checkbox" id="c-39489879" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489806">parent</a><span>|</span><a href="#39489605">next</a><span>|</span><label class="collapse" for="c-39489879">[-]</label><label class="expand" for="c-39489879">[2 more]</label></div><br/><div class="children"><div class="content">`#[must_use]`.
I really don&#x27;t know why Rust made that error.</div><br/><div id="39489954" class="c"><input type="checkbox" id="c-39489954" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489879">parent</a><span>|</span><a href="#39489605">next</a><span>|</span><label class="collapse" for="c-39489954">[-]</label><label class="expand" for="c-39489954">[1 more]</label></div><br/><div class="children"><div class="content">I think it is notable that both `try!` (`?` today) and `#[must_use]` (originally restricted to `Result`, then made available in general later) appeared in the same release (0.10). In the other words, `#[must_use]` was strongly tied to `Result` back then. While we can put `#[must_use]` to any type now, the set of types that absolutely have to be `#[must_use]` remains relatively small, with a major addition being iterators and futures. Once they have been covered, any additional value from adding `#[must_use]` is not large enough to make it default, I think.</div><br/></div></div></div></div></div></div></div></div><div id="39489605" class="c"><input type="checkbox" id="c-39489605" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489559">parent</a><span>|</span><a href="#39489674">prev</a><span>|</span><a href="#39489861">next</a><span>|</span><label class="collapse" for="c-39489605">[-]</label><label class="expand" for="c-39489605">[2 more]</label></div><br/><div class="children"><div class="content">This sounds awful in practice having to memorize different functions for the same thing based on mutability of the thing.</div><br/><div id="39489652" class="c"><input type="checkbox" id="c-39489652" checked=""/><div class="controls bullet"><span class="by">ttymck</span><span>|</span><a href="#39489335">root</a><span>|</span><a href="#39489605">parent</a><span>|</span><a href="#39489861">next</a><span>|</span><label class="collapse" for="c-39489652">[-]</label><label class="expand" for="c-39489652">[1 more]</label></div><br/><div class="children"><div class="content">In practice it&#x27;s not that bad</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39489861" class="c"><input type="checkbox" id="c-39489861" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39489335">parent</a><span>|</span><a href="#39489439">prev</a><span>|</span><a href="#39488964">next</a><span>|</span><label class="collapse" for="c-39489861">[-]</label><label class="expand" for="c-39489861">[1 more]</label></div><br/><div class="children"><div class="content">Long before that, the problems with the API are solved by having a separate heap type for length manipulations rather than confusing the interfaces.<p>If Delete or Compact are only available there and it’s modified in place, the problems don’t arise in the first place.</div><br/></div></div></div></div><div id="39488964" class="c"><input type="checkbox" id="c-39488964" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#39489335">prev</a><span>|</span><label class="collapse" for="c-39488964">[-]</label><label class="expand" for="c-39488964">[7 more]</label></div><br/><div class="children"><div class="content">A missing tidbit that may help contextualize this post: One of the things about Go that surprised me is that if you have a slice which does not represent the full capacity of the underlying array, you can go ahead and reslice it up to that full capacity even though it&#x27;s a panic to access the things you&#x27;re reslicing directly: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;oThz2bNFwgr" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;oThz2bNFwgr</a><p>Consequently, the GC has to assume that anything forward of any given slice into the underlying array may become accessible in the future as there is legal Go that can access it. It&#x27;s still memory safe, but it surprised me.<p>I had some code that was using my incorrect belief that slices could not be resliced up in size to implement some light security boundaries. Fortunately it was still legal, because the code in question simply didn&#x27;t slice things larger and it&#x27;s not like I was allowing arbitrary user-supplied code to run, so it was still correct in what it was doing. But I was expecting the runtime to scream if I did somehow screw it up when in fact it may not, depending on the exact capacity and what happened when.<p>It&#x27;s also asymmetric, as far as I know; you can slice forward into the array if there is capacity, but if you&#x27;ve got a slice that starts after index 0 in the backing array you can&#x27;t use that slice to walk back into the underlying array. That is, with<p><pre><code>     s := []int{11, 12, 13, 14, 15}
     s = s[2:]
</code></pre>
as far as I know, 11 and 12 are no longer accessible to any legal Go code (not using &quot;unsafe&quot;) after that second line executes.<p>Corrections (again not involving &quot;unsafe&quot;, it&#x27;s obvious those two values are still accessible through &quot;unsafe&quot;) welcome. I was wrong once, it&#x27;s easy to believe I could be wrong again.</div><br/><div id="39489050" class="c"><input type="checkbox" id="c-39489050" checked=""/><div class="controls bullet"><span class="by">stock_toaster</span><span>|</span><a href="#39488964">parent</a><span>|</span><a href="#39489160">next</a><span>|</span><label class="collapse" for="c-39489050">[-]</label><label class="expand" for="c-39489050">[1 more]</label></div><br/><div class="children"><div class="content">You can prevent later longer reslicing by add an additional cap() element to the slicing to shrink the capacity.<p><pre><code>  s = s[:3:3]
</code></pre>
from your first example link.</div><br/></div></div><div id="39489160" class="c"><input type="checkbox" id="c-39489160" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#39488964">parent</a><span>|</span><a href="#39489050">prev</a><span>|</span><a href="#39489755">next</a><span>|</span><label class="collapse" for="c-39489160">[-]</label><label class="expand" for="c-39489160">[2 more]</label></div><br/><div class="children"><div class="content">One detail in the latest 1.22 release is a change in the &quot;slices&quot; library [1] (the library is based on generics, introduced in 1.21) that helps avoid such cases:<p>&gt; Functions that shrink the size of a slice (Delete, DeleteFunc, Compact, CompactFunc, and Replace) now zero the elements between the new length and the old length.<p>[1]: <a href="https:&#x2F;&#x2F;tip.golang.org&#x2F;doc&#x2F;go1.22#slices" rel="nofollow">https:&#x2F;&#x2F;tip.golang.org&#x2F;doc&#x2F;go1.22#slices</a><p>[2]: <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;slices" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;slices</a></div><br/></div></div><div id="39489755" class="c"><input type="checkbox" id="c-39489755" checked=""/><div class="controls bullet"><span class="by">hairyplanter</span><span>|</span><a href="#39488964">parent</a><span>|</span><a href="#39489160">prev</a><span>|</span><a href="#39489054">next</a><span>|</span><label class="collapse" for="c-39489755">[-]</label><label class="expand" for="c-39489755">[1 more]</label></div><br/><div class="children"><div class="content">In your playground example, if you print the capacity and the length before and after “re-extension”, it becomes clear what happened. In fact, accessing item 5 after reduction gives a size panic, where as accessing item 6 after re-extension gives you a capacity panic.<p>Understanding rsc’s “Go Slices” blog is very helpful here. Coming from Java or something, this exposure of underlying storage could be jarring, but coming from C, Go slices are basically built in fat arrays, and this behavior doesn’t surprise <i>me</i>. Maybe it was a design mistake to expose so much of the underlying machinery. Ymmv.</div><br/></div></div><div id="39489054" class="c"><input type="checkbox" id="c-39489054" checked=""/><div class="controls bullet"><span class="by">never_inline</span><span>|</span><a href="#39488964">parent</a><span>|</span><a href="#39489755">prev</a><span>|</span><a href="#39489013">next</a><span>|</span><label class="collapse" for="c-39489054">[-]</label><label class="expand" for="c-39489054">[1 more]</label></div><br/><div class="children"><div class="content">It is reinforcing my belief that language design is hard. Go is supposed to be a simple language, one may write it for long time, but there will be some trap you discover once in a while.</div><br/></div></div><div id="39489013" class="c"><input type="checkbox" id="c-39489013" checked=""/><div class="controls bullet"><span class="by">sitzkrieg</span><span>|</span><a href="#39488964">parent</a><span>|</span><a href="#39489054">prev</a><span>|</span><label class="collapse" for="c-39489013">[-]</label><label class="expand" for="c-39489013">[1 more]</label></div><br/><div class="children"><div class="content">interesting catch, thanks for sharing. my poor memory is already racing thinking about cases where i may have left traps with the same assumption</div><br/></div></div></div></div></div></div></div></div></div></body></html>