<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712826053866" as="style"/><link rel="stylesheet" href="styles.css?v=1712826053866"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.val.town/blog/search-notes/">Code search is hard</a> <span class="domain">(<a href="https://blog.val.town">blog.val.town</a>)</span></div><div class="subtext"><span>stevekrouse</span> | <span>117 comments</span></div><br/><div><div id="39994894" class="c"><input type="checkbox" id="c-39994894" checked=""/><div class="controls bullet"><span class="by">sqs</span><span>|</span><a href="#39999168">next</a><span>|</span><label class="collapse" for="c-39994894">[-]</label><label class="expand" for="c-39994894">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m at Sourcegraph (mentioned in the blog post). We obviously have to deal with massive scale, but for anyone starting out adding code search to their product, I&#x27;d recommend not starting with an index and just doing on-the-fly searching until that does not scale. It actually will scale well for longer than you think if you just need to find the first N matches (because that result buffer can be filled without needing to search everything exhaustively). Happy to chat with anyone who&#x27;s building this kind of thing, including with folks at Val Town, which is awesome.</div><br/><div id="39995268" class="c"><input type="checkbox" id="c-39995268" checked=""/><div class="controls bullet"><span class="by">isker</span><span>|</span><a href="#39994894">parent</a><span>|</span><a href="#39996066">next</a><span>|</span><label class="collapse" for="c-39995268">[-]</label><label class="expand" for="c-39995268">[1 more]</label></div><br/><div class="children"><div class="content">And when you&#x27;re ready to do indexed search, Zoekt (over which Sourcegraph graciously took maintainership a while ago) is the best way to do it that I&#x27;ve found. After discounting both Livegrep and Hound (they both struggled to perform in various dimensions with the amount of stuff we wanted indexed, Hound moreso than Livegrep), we migrated to Zoekt from a (necessarily) very old and creaky deployment of OpenGrok and it&#x27;s night and day, both in terms of indexing performance and search performance&#x2F;ergonomics.<p>Sourcegraph of course adds many more sophisticated features on top of just the code search that Zoekt provides.</div><br/></div></div><div id="39996066" class="c"><input type="checkbox" id="c-39996066" checked=""/><div class="controls bullet"><span class="by">morgante</span><span>|</span><a href="#39994894">parent</a><span>|</span><a href="#39995268">prev</a><span>|</span><a href="#39996347">next</a><span>|</span><label class="collapse" for="c-39996066">[-]</label><label class="expand" for="c-39996066">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been surprised at how far you can get without indexing.<p>Ex. I always assume we&#x27;ll need to add an index to speed up GritQL (<a href="https:&#x2F;&#x2F;github.com&#x2F;getgrit&#x2F;gritql">https:&#x2F;&#x2F;github.com&#x2F;getgrit&#x2F;gritql</a>), but we&#x27;ve gotten pretty far with doing search entirely on the fly.</div><br/><div id="39996213" class="c"><input type="checkbox" id="c-39996213" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#39994894">root</a><span>|</span><a href="#39996066">parent</a><span>|</span><a href="#39996347">next</a><span>|</span><label class="collapse" for="c-39996213">[-]</label><label class="expand" for="c-39996213">[3 more]</label></div><br/><div class="children"><div class="content">What does &#x27;on the fly&#x27; entail here?</div><br/><div id="39996278" class="c"><input type="checkbox" id="c-39996278" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39994894">root</a><span>|</span><a href="#39996213">parent</a><span>|</span><a href="#39996347">next</a><span>|</span><label class="collapse" for="c-39996278">[-]</label><label class="expand" for="c-39996278">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m going to guess brute force - scan everything for the search term,  rather than trying to use an index.<p>I&#x27;m always amazed at how fast ripgrep (rg) can brute force it&#x27;s way through hundreds of MBs of source code.</div><br/><div id="39996446" class="c"><input type="checkbox" id="c-39996446" checked=""/><div class="controls bullet"><span class="by">morgante</span><span>|</span><a href="#39994894">root</a><span>|</span><a href="#39996278">parent</a><span>|</span><a href="#39996347">next</a><span>|</span><label class="collapse" for="c-39996446">[-]</label><label class="expand" for="c-39996446">[1 more]</label></div><br/><div class="children"><div class="content">Yes, exactly. When doing a search, we parse and search every file without any indexing.<p>Of course, it could still be sped up considerably with an index but brute force is surprisingly effective (we use some of the same techniques&#x2F;crates as ripgrep).</div><br/></div></div></div></div></div></div></div></div><div id="39996347" class="c"><input type="checkbox" id="c-39996347" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39994894">parent</a><span>|</span><a href="#39996066">prev</a><span>|</span><a href="#39997851">next</a><span>|</span><label class="collapse" for="c-39996347">[-]</label><label class="expand" for="c-39996347">[1 more]</label></div><br/><div class="children"><div class="content">I apply this thinking to lots of problems. Do the dumb thing that involves the least state and prove we need to lean more towards memory for speed. It’s much simpler to keep things correct when nothing is cached</div><br/></div></div><div id="39997851" class="c"><input type="checkbox" id="c-39997851" checked=""/><div class="controls bullet"><span class="by">baobun</span><span>|</span><a href="#39994894">parent</a><span>|</span><a href="#39996347">prev</a><span>|</span><a href="#39996355">next</a><span>|</span><label class="collapse" for="c-39997851">[-]</label><label class="expand" for="c-39997851">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll also be in a much better spot to pick appropriate indexing when you actually have sizable and representative workloads.</div><br/></div></div><div id="39996355" class="c"><input type="checkbox" id="c-39996355" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39994894">parent</a><span>|</span><a href="#39997851">prev</a><span>|</span><a href="#39999168">next</a><span>|</span><label class="collapse" for="c-39996355">[-]</label><label class="expand" for="c-39996355">[1 more]</label></div><br/><div class="children"><div class="content">There was someone doing temporal databases that was compressing blocks on disk and doing streaming decompress and search on them. Things in L2 cache go very very fast.</div><br/></div></div></div></div><div id="39999168" class="c"><input type="checkbox" id="c-39999168" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39994894">prev</a><span>|</span><a href="#39998435">next</a><span>|</span><label class="collapse" for="c-39999168">[-]</label><label class="expand" for="c-39999168">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s why IDE and developer tool builders have long had the insight that in order to do code search properly, you need to open up the compiler platform as a lot of what you need to do boils down to reconstructing the exact same internal representations that a compiler would use. And of course good code search is the basis for refactoring support, auto completion, and other common IDE features.<p>Easier said then done of course as tools are often an afterthought for compiler builders. Even Jetbrains made this mistake with Kotlin initially, which is something they are partially rectifying with Kotlin 2.0 now to make it easier to support things like incremental compilation. The Rust community had this insight as well with a big effort a few years ago to make Rust more IDE friendly.<p>IBM actually nailed this with Eclipse back in the day and that hasn&#x27;t really been matched since then. Intellij never even got close to this being 2-3 orders of magnitudes slower. We&#x27;re talking seconds vs. milliseconds here. Eclipse had a blazing fast incremental compiler for Java that could even partially compile code in the presence of syntax errors. The IDEs representation of that code was hooked into that compiler.<p>With Eclipse, you could introduce a typo and break part of your code and watch the IDE mark all the files that now had issues across your code base getting red squiggles instantly. Fix the typo and the squiggles went away, also without any delay.<p>That&#x27;s only possible if you have a mapping between those files and your syntax tree, which is exactly what Eclipse was doing because it was hooked into the incremental compiler.<p>Intellij was never able to do this, it will actively lie to you about things being fine&#x2F;not fine until you rebuild your code and it will show phantom errors a lot when it&#x27;s internal state gets out of sync with what&#x27;s on disk. It often requires full rebuilds to fix this. If you run something, there&#x27;s a several second lag while it compiles things. Reason: the IDE internal state is calculated separately from the compiler and this gets out of sync easily. When you run something, it has to compile your code because it hasn&#x27;t been compiled yet. That&#x27;s often when you find out the IDE was lying to you about things being ready to run.<p>With Eclipse all this was instantly and unambiguous because it shared the internal state with the compiler. If it compiled, your IDE would be error free, if it didn&#x27;t it wouldn&#x27;t be. And it compiled incrementally and really quickly so you would know instantly. It had many flaws and annoying bugs but that&#x27;s a feature I miss.</div><br/><div id="39999965" class="c"><input type="checkbox" id="c-39999965" checked=""/><div class="controls bullet"><span class="by">callmeal</span><span>|</span><a href="#39999168">parent</a><span>|</span><a href="#39999531">next</a><span>|</span><label class="collapse" for="c-39999965">[-]</label><label class="expand" for="c-39999965">[1 more]</label></div><br/><div class="children"><div class="content">&gt;With Eclipse all this was instantly and unambiguous ...<p>Still is, and is the main reason why a lot of us will never jump ship.</div><br/></div></div><div id="39999531" class="c"><input type="checkbox" id="c-39999531" checked=""/><div class="controls bullet"><span class="by">high_na_euv</span><span>|</span><a href="#39999168">parent</a><span>|</span><a href="#39999965">prev</a><span>|</span><a href="#39998435">next</a><span>|</span><label class="collapse" for="c-39999531">[-]</label><label class="expand" for="c-39999531">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Easier said then done of course as tools are often an afterthought for compiler builders.<p>Except for Microsoft&#x27;s Roslyn (.NET compiler)<p><a href="https:&#x2F;&#x2F;willspeak.me&#x2F;2021&#x2F;11&#x2F;24&#x2F;red-green-syntax-trees-an-overview.html" rel="nofollow">https:&#x2F;&#x2F;willspeak.me&#x2F;2021&#x2F;11&#x2F;24&#x2F;red-green-syntax-trees-an-ov...</a><p><a href="https:&#x2F;&#x2F;ericlippert.com&#x2F;2012&#x2F;06&#x2F;08&#x2F;red-green-trees&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ericlippert.com&#x2F;2012&#x2F;06&#x2F;08&#x2F;red-green-trees&#x2F;</a><p>Ive used Roslyn SDKs to build tools and it is really good</div><br/></div></div></div></div><div id="39998435" class="c"><input type="checkbox" id="c-39998435" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#39999168">prev</a><span>|</span><a href="#39994538">next</a><span>|</span><label class="collapse" for="c-39998435">[-]</label><label class="expand" for="c-39998435">[6 more]</label></div><br/><div class="children"><div class="content">Basic code searching skills seems like something new developers are never explicitly taught, but which is an absolutely crucial skill to build early on.<p>I guess the knowledge progression I would recommend would look something kind this:<p>- Learning about Ctrl+F, which works basically everywhere.<p>- Transitioning to ripgrep <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep</a> - I wouldn&#x27;t even call this optional, it&#x27;s truly an incredible and very discoverable tool. Requires keeping a terminal open, but that&#x27;s a good thing for a newbie!<p>- Optional, but highly recommended: Learning one of the powerhouse command line editors. Teenage me recommended Emacs; current me recommends vanilla vim, purely because some flavor of it is installed almost everywhere. This is so that you can grep around and edit in the same window.<p>- In the same vein, moving <i>back</i> from ripgrep and learning about good old fashioned grep, with a few flags rg uses by default: `grep -r` for recursive search, `grep -ri` for case insensitive recursive search, and `grep -ril` for case insensitive recursive &quot;just show me which files this string is found in&quot; search. Some others too, season to taste.<p>- Finally hitting the wall with what ripgrep can do for you and switching to an actual indexed, dedicated code search tool.</div><br/><div id="39999403" class="c"><input type="checkbox" id="c-39999403" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#39998435">parent</a><span>|</span><a href="#39999673">next</a><span>|</span><label class="collapse" for="c-39999403">[-]</label><label class="expand" for="c-39999403">[1 more]</label></div><br/><div class="children"><div class="content">Apart from speed, what advantages does ripgrep offer over git grep when searching git repos?</div><br/></div></div><div id="39999673" class="c"><input type="checkbox" id="c-39999673" checked=""/><div class="controls bullet"><span class="by">mcintyre1994</span><span>|</span><a href="#39998435">parent</a><span>|</span><a href="#39999403">prev</a><span>|</span><a href="#39998468">next</a><span>|</span><label class="collapse" for="c-39999673">[-]</label><label class="expand" for="c-39999673">[1 more]</label></div><br/><div class="children"><div class="content">I’d also point out that VSCode uses ripgrep for its search feature which is a great starting point.</div><br/></div></div><div id="39998468" class="c"><input type="checkbox" id="c-39998468" checked=""/><div class="controls bullet"><span class="by">datascienced</span><span>|</span><a href="#39998435">parent</a><span>|</span><a href="#39999673">prev</a><span>|</span><a href="#39994538">next</a><span>|</span><label class="collapse" for="c-39998468">[-]</label><label class="expand" for="c-39998468">[3 more]</label></div><br/><div class="children"><div class="content">Also Github is a fantastic tool for searching code across repos, ones you may not even have cloned yet! Either public ones or org ones.</div><br/><div id="39999963" class="c"><input type="checkbox" id="c-39999963" checked=""/><div class="controls bullet"><span class="by">tex0</span><span>|</span><a href="#39998435">root</a><span>|</span><a href="#39998468">parent</a><span>|</span><a href="#39998831">next</a><span>|</span><label class="collapse" for="c-39999963">[-]</label><label class="expand" for="c-39999963">[1 more]</label></div><br/><div class="children"><div class="content">The new GitHub CS is pretty great indeed. Still not on par with it&#x27;s role model, but getting closer.</div><br/></div></div><div id="39998831" class="c"><input type="checkbox" id="c-39998831" checked=""/><div class="controls bullet"><span class="by">lambdaba</span><span>|</span><a href="#39998435">root</a><span>|</span><a href="#39998468">parent</a><span>|</span><a href="#39999963">prev</a><span>|</span><a href="#39994538">next</a><span>|</span><label class="collapse" for="c-39998831">[-]</label><label class="expand" for="c-39998831">[1 more]</label></div><br/><div class="children"><div class="content">yeah, I particularly like the combo regex + path: or lang:</div><br/></div></div></div></div></div></div><div id="39994538" class="c"><input type="checkbox" id="c-39994538" checked=""/><div class="controls bullet"><span class="by">ayberk</span><span>|</span><a href="#39998435">prev</a><span>|</span><a href="#39994908">next</a><span>|</span><label class="collapse" for="c-39994538">[-]</label><label class="expand" for="c-39994538">[42 more]</label></div><br/><div class="children"><div class="content">It indeed is hard, and a good code search platform makes life so much easier. If I ever leave Google, the internal code search is for sure going to be the thing I miss the most. It&#x27;s so well integrated into how everything else works (blaze target finding, guice bindings etc), I can&#x27;t imagine my life without it.<p>I remember to appreciate it even more every time I use Github&#x27;s search. Not that it&#x27;s bad, it&#x27;s just inherently so much harder to build a generalized code search platform.</div><br/><div id="39994712" class="c"><input type="checkbox" id="c-39994712" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#39994538">parent</a><span>|</span><a href="#39999027">next</a><span>|</span><label class="collapse" for="c-39994712">[-]</label><label class="expand" for="c-39994712">[40 more]</label></div><br/><div class="children"><div class="content">If you ever leave you can use Livegrep, which was based on code-search work done at Google. I personally don&#x27;t use it right now but it&#x27;s great and will probably meet all your needs.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;livegrep&#x2F;livegrep">https:&#x2F;&#x2F;github.com&#x2F;livegrep&#x2F;livegrep</a></div><br/><div id="39995700" class="c"><input type="checkbox" id="c-39995700" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39994712">parent</a><span>|</span><a href="#39994912">next</a><span>|</span><label class="collapse" for="c-39995700">[-]</label><label class="expand" for="c-39995700">[21 more]</label></div><br/><div class="children"><div class="content">&gt; If you ever leave you can use Livegrep, which was based on code-search work done at Google.<p>If I’ve learned anything from the fainting spells that I-work-at-X have over their internal tools on HN: no, whatever the public&#x2F;OSS variant is always a mere <i>shadow</i> of <i>the real thing</i>.</div><br/><div id="39997482" class="c"><input type="checkbox" id="c-39997482" checked=""/><div class="controls bullet"><span class="by">elevatedastalt</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995700">parent</a><span>|</span><a href="#39997264">next</a><span>|</span><label class="collapse" for="c-39997482">[-]</label><label class="expand" for="c-39997482">[1 more]</label></div><br/><div class="children"><div class="content">You would be better off actually trying to understand those sentiments instead of posting sarcastic replies on HN.<p>The sort of tight knit integration and developer-focus that internal tools at developer-friendly companies like Google has cannot be matched by clobbering together 50 different SaaS products, half of which will probably run out of funding in 3 years.<p>You literally have entire companies just LARPing internal tools that Google has because they are just that good. Glean is literally Moma. There&#x27;s really nothing like Critique or Buganizer.</div><br/></div></div><div id="39997264" class="c"><input type="checkbox" id="c-39997264" checked=""/><div class="controls bullet"><span class="by">alienchow</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995700">parent</a><span>|</span><a href="#39997482">prev</a><span>|</span><a href="#39995957">next</a><span>|</span><label class="collapse" for="c-39997264">[-]</label><label class="expand" for="c-39997264">[4 more]</label></div><br/><div class="children"><div class="content">Just left Google a few months ago.<p>My take is that there&#x27;s a difference between a company that is willing to invest money into EngProd endeavors, and a company that uses SaaS for everything. While I can understand that most companies don&#x27;t have the financial means to invest heavily into EngProd, the outcome is that the tightly integrated development experience in the former is far superior. Code Search is definitely #2 on the list of things I miss the most.</div><br/><div id="39997441" class="c"><input type="checkbox" id="c-39997441" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997264">parent</a><span>|</span><a href="#39995957">next</a><span>|</span><label class="collapse" for="c-39997441">[-]</label><label class="expand" for="c-39997441">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s #1? Memegen?</div><br/><div id="39997683" class="c"><input type="checkbox" id="c-39997683" checked=""/><div class="controls bullet"><span class="by">alienchow</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997441">parent</a><span>|</span><a href="#39997595">next</a><span>|</span><label class="collapse" for="c-39997683">[-]</label><label class="expand" for="c-39997683">[1 more]</label></div><br/><div class="children"><div class="content">Cheesy answer but, the people.</div><br/></div></div><div id="39997595" class="c"><input type="checkbox" id="c-39997595" checked=""/><div class="controls bullet"><span class="by">voiceblue</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997441">parent</a><span>|</span><a href="#39997683">prev</a><span>|</span><a href="#39995957">next</a><span>|</span><label class="collapse" for="c-39997595">[-]</label><label class="expand" for="c-39997595">[1 more]</label></div><br/><div class="children"><div class="content">The business end of gThanks</div><br/></div></div></div></div></div></div><div id="39995957" class="c"><input type="checkbox" id="c-39995957" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995700">parent</a><span>|</span><a href="#39997264">prev</a><span>|</span><a href="#39995902">next</a><span>|</span><label class="collapse" for="c-39995957">[-]</label><label class="expand" for="c-39995957">[14 more]</label></div><br/><div class="children"><div class="content">I suspect you&#x27;re being sarcastic - but can confirm that being nearly two years out of Amazon, I still miss its in-house CD system nearly every day. I&#x27;ve actively looked around for OSS replacements and very few come anywhere close.<p>(I would be _delighted_ for someone to &quot;Umm actually&quot; me by providing a great product!)</div><br/><div id="39996820" class="c"><input type="checkbox" id="c-39996820" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995957">parent</a><span>|</span><a href="#39996201">next</a><span>|</span><label class="collapse" for="c-39996820">[-]</label><label class="expand" for="c-39996820">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (I would be _delighted_ for someone to &quot;Umm actually&quot; me by providing a great product!)<p>I think the issue is, nobody would be willing to pay for a good solution since they usually come with a steep maintenance cost.  I wouldn&#x27;t be surprised if the in-house CD team at Amazon were putting out fires every week&#x2F;month behind the scene.</div><br/></div></div><div id="39996201" class="c"><input type="checkbox" id="c-39996201" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995957">parent</a><span>|</span><a href="#39996820">prev</a><span>|</span><a href="#39997638">next</a><span>|</span><label class="collapse" for="c-39996201">[-]</label><label class="expand" for="c-39996201">[10 more]</label></div><br/><div class="children"><div class="content">My experience has been that any of these in-house things do not adapt well to the <i>high chaos</i> of external environments, as if there are 3 companies one will find 9 systems and processes in use thus making &quot;one size fits all&quot; a fantasy<p>But, I&#x27;ll bite: what made the CD system so dreamy, and what have you evaluated thus far that fall short?</div><br/><div id="39996817" class="c"><input type="checkbox" id="c-39996817" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39996201">parent</a><span>|</span><a href="#39997638">next</a><span>|</span><label class="collapse" for="c-39996817">[-]</label><label class="expand" for="c-39996817">[9 more]</label></div><br/><div class="children"><div class="content">Amazon internal tools for building codes are _amazing_.<p>Brazil is their internal dependency management tool. It handles building and versioning software. It introduced the concept of version sets which essentially allows you to group up related software, e.g. version 1.0 of my app needs version 1.1 of library x and 2.0 of runtime y. This particular set of software versions get its own version number.<p>Everything from the CI&#x2F;CD to the code review tool to your local builds use the same build configuration with Brazil. All software packages in Brazil are built from source on Amazon&#x27;s gigantic fleet of build servers. Builds are cached, so even though Amazon builds its own version of Make, Java, etc., these are all built and cached by the build servers and downloaded.<p>A simple Java application at Amazon might have hundreds of dependencies (because you&#x27;ll need to build Java from scratch), but since this is all cached you don&#x27;t have to wait very long.<p>Lastly, you have Pipelines which is their internal CI&#x2F;CD tool which integrates naturally with Brazil + the build fleet. It can deploy to their internal fleet with Apollo, or to AWS Lambda, S3 buckets, etc.<p>In all, everything is just very well integrated. I haven&#x27;t seen anything come close to what you get internally at Amazon.</div><br/><div id="39997742" class="c"><input type="checkbox" id="c-39997742" checked=""/><div class="controls bullet"><span class="by">nosefrog</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39996817">parent</a><span>|</span><a href="#39997498">next</a><span>|</span><label class="collapse" for="c-39997742">[-]</label><label class="expand" for="c-39997742">[3 more]</label></div><br/><div class="children"><div class="content">How did you avoid version hell? At Google, almost everything just shipped from master (except for some things that had more subtle bugs, those did their work on  a dev branch and merged into master after testing).</div><br/><div id="39997763" class="c"><input type="checkbox" id="c-39997763" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997742">parent</a><span>|</span><a href="#39998294">next</a><span>|</span><label class="collapse" for="c-39997763">[-]</label><label class="expand" for="c-39997763">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t, you embrace version hell.</div><br/></div></div><div id="39998294" class="c"><input type="checkbox" id="c-39998294" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997742">parent</a><span>|</span><a href="#39997763">prev</a><span>|</span><a href="#39997498">next</a><span>|</span><label class="collapse" for="c-39998294">[-]</label><label class="expand" for="c-39998294">[1 more]</label></div><br/><div class="children"><div class="content">Version sets take care of everything. A version set can be thought of as a Git repo with just one file. The file is just key&#x2F;value pairs with the dependencies and major&#x2F;minor version mappings, e.g.<p>&lt;Name&gt; &lt;Major&gt;-&lt;Minor&gt;<p>Java 8-123<p>Lombok 1.12-456<p>...<p>A version set revision is essentially a git commit of that version set file. It&#x27;s what determines exactly what software version you use when building&#x2F;developing&#x2F;deploying&#x2F;etc.<p>Your pipeline (which is a specific noun at Amazon, not the general term) acts on a single version set. When you clone a repo, you have to choose which version set you want, when you deploy you have to choose a version set, etc.<p>Unlike most other dependency management systems, there&#x27;s no notion of a &quot;version of a package&quot; without choosing what version set you&#x27;re working on, which can choose the minor versions of _all of the packages you&#x27;re using_.<p>e.g. imagine you clone a Node project with all of its dependencies. Each dependency will have a package.json file declaring what versions it needs. You have some _additional_ metadata that goes a step further that chooses the exact minor version that a major version is mapped to.<p>All that to say that the package can declare what major version they depend on, but not what minor version. The version set that you&#x27;re using determines what minor version is used. The package determines the major version.<p>Version sets can only have one minor version per major version of a package which prevents consistency issues.<p>e.g. I can have Java 8-123 and Java 11-123 in my version set, but I cannot have Java 8-123 and Java 8-456 in my version set.<p>Your pipeline will automatically build in new minor versions into your version set from upstream. If the build fails then someone needs to do something. Every commit produces a new minor version of a package, that is to say that you can say your package is major version X, but the minor version is left up to Brazil.<p>This scheme actually works pretty well. There are internal tools (Gordian Knot) which performs analysis on your dependencies to make sure that your dependencies are correct.<p>It&#x27;s a lot to know. It took me a year or so to fully understand and appreciate. Most engineers at Amazon treat it like they do Git -- learn the things you need to and ignore the rest. For the most part, this stuff is all hands off, you just need one person on the team keeping everything correct.</div><br/></div></div></div></div><div id="39997498" class="c"><input type="checkbox" id="c-39997498" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39996817">parent</a><span>|</span><a href="#39997742">prev</a><span>|</span><a href="#39997638">next</a><span>|</span><label class="collapse" for="c-39997498">[-]</label><label class="expand" for="c-39997498">[5 more]</label></div><br/><div class="children"><div class="content">so what I&#x27;m hearing is that app-1.0 needs app-1.0-runtime-build-20240410 which was, itself, built from a base of runtime-y-2.0 and layering library-x-1.11 upon it, kind of like<p><pre><code>  # in some &quot;app-runtimes&quot; project, they assemble your app&#x27;s runtime
  cat &gt; Dockerfile &lt;&lt;FOO
  FROM public.ecr.aws&#x2F;runtimes&#x2F;runtime-y:2.0
  ADD https:&#x2F;&#x2F;cache.example&#x2F;library-x&#x2F;1.1&#x2F;library-x-1.1.jar
  FOO
  tar -cf - Dockerfile | podman build -t public.ecr.aws&#x2F;app-runtimes&#x2F;app-1.0-runtime-build:20240410 -

  # then you consume it in your project
  cat &gt; Dockerfile &lt;&lt;FOO
  FROM public.ecr.aws&#x2F;app-runtimes&#x2F;app-1.0-runtime-build:20240410
  ADD .&#x2F;app-1.0.jar
  FOO

  cat &gt; .gitlab-ci.yml &lt;&lt;&#x27;YML&#x27;
  # you can also distribute artifacts other than just docker images
  # https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;packages&#x2F;package_registry&#x2F;supported_package_managers.html
  cook image:
    stage: package
    script:
    # or this https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;topics&#x2F;autodevops&#x2F;customize.html#customize-buildpacks-with-cloud-native-buildpacks
    - podman build -t $CI_REGISTRY_IMAGE .
    # https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;packages&#x2F;#container-registry is built in
    - podman push     $CI_REGISTRY_IMAGE
  review env:
    stage: staging
    script: auto-devops deploy
    # for free: https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;ci&#x2F;review_apps&#x2F;index.html
    environment:
      name: review&#x2F;${CI_COMMIT_REF_SLUG}
      url: https:&#x2F;&#x2F;${CI_ENVIRONMENT_SLUG}.int.example
      on_stop: teardown-review
  teardown-review:
    stage: staging
    script: auto-devops stop
    when: manual
    environment:
      name: review&#x2F;${CI_COMMIT_REF_SLUG}
      action: stop
  ... etc ...
  YML
</code></pre>
and then, yadda, yadda, blue-green, incremental rollout &lt;<a href="https:&#x2F;&#x2F;gitlab.com&#x2F;gitlab-org&#x2F;gitlab&#x2F;-&#x2F;blob&#x2F;v16.10.2-ee&#x2F;lib&#x2F;gitlab&#x2F;ci&#x2F;templates&#x2F;Auto-DevOps.gitlab-ci.yml#L81-84" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;gitlab-org&#x2F;gitlab&#x2F;-&#x2F;blob&#x2F;v16.10.2-ee&#x2F;lib&#x2F;...</a>&gt;, feature flags &lt;<a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;operations&#x2F;feature_flags.html" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;operations&#x2F;feature_flags.html</a>&gt;, error capture &lt;<a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;operations&#x2F;error_tracking.html#integrated-error-tracking" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;operations&#x2F;error_tracking.html#in...</a>&gt;, project-managed provisioning &lt;<a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;infrastructure&#x2F;iac&#x2F;#integrate-your-project-with-terraform" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;infrastructure&#x2F;iac&#x2F;#integrat...</a>&gt;, on call management &lt;<a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;operations&#x2F;incident_management&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;operations&#x2F;incident_management&#x2F;</a>&gt;, on call runbooks &lt;<a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;project&#x2F;clusters&#x2F;runbooks&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;project&#x2F;clusters&#x2F;runbooks&#x2F;in...</a>&gt;<p>you can orchestrate all that from ~~Slack~~ Chime :-D if you&#x27;re into that kind of thing <a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;ci&#x2F;chatops&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;ci&#x2F;chatops&#x2F;</a></div><br/><div id="39997661" class="c"><input type="checkbox" id="c-39997661" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997498">parent</a><span>|</span><a href="#39997638">next</a><span>|</span><label class="collapse" for="c-39997661">[-]</label><label class="expand" for="c-39997661">[4 more]</label></div><br/><div class="children"><div class="content">No, not even close. You might even have it exactly backwards.</div><br/><div id="39997695" class="c"><input type="checkbox" id="c-39997695" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997661">parent</a><span>|</span><a href="#39997638">next</a><span>|</span><label class="collapse" for="c-39997695">[-]</label><label class="expand" for="c-39997695">[3 more]</label></div><br/><div class="children"><div class="content">which is why, as I originally asked GP: what have you already tried and what features were they missing<p>I presume by &quot;exactly backwards&quot; you mean that one should have absolutely zero knobs to influence anything because the Almighty Jeff Build System does all the things, which GitLab also supports but is less amusing to look at on an Internet forum because it&#x27;s &quot;you can&#x27;t modify anything, it just works, trust me&quot;<p>Or, you know, if you have something constructive to add to this discussion feel free to use more words than &quot;lol, no&quot;</div><br/><div id="39997746" class="c"><input type="checkbox" id="c-39997746" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997695">parent</a><span>|</span><a href="#39998282">next</a><span>|</span><label class="collapse" for="c-39997746">[-]</label><label class="expand" for="c-39997746">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t work at Amazon, and haven&#x27;t for a long time, and this format is insufficient to fully express what they&#x27;re doing, so I won&#x27;t try.<p>You&#x27;re better off searching for how Brazil and Apollo work.<p>That being said, the short of it is that: imagine when you push a new revision to source control, you (<i>you</i>) can run jobs testing every potential consumer of that new revision. As in, you push libx-1.1.2 and anyone consuming libx &gt;= 1.1 (or any variety of filters) is identified. If the tests succeed, you can update their dependencies on your package and even deploy them, safely and gradually, to production without involving the downstream teams at all. If they don&#x27;t, you can choose your own adventure: pin them, fork, fix them, patch the package, revise the versioning, whatever you want.<p>It&#x27;s designed to be extremely safe and put power in the hands of those updating dependencies to do so safely within reason.<p>Imagine you work on a library and you can test your PR against every consumers.<p>It&#x27;s not unlike what Google and other monorepos accomplish but it&#x27;s quite different also. You can have many live versions simultaneously. You don&#x27;t have to slog it out and patch all the dependents -- maybe you should, but you have plenty of options.<p>It all feels very simple. I&#x27;m glossing over a lot.</div><br/></div></div><div id="39998282" class="c"><input type="checkbox" id="c-39998282" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39997695">parent</a><span>|</span><a href="#39997746">prev</a><span>|</span><a href="#39997638">next</a><span>|</span><label class="collapse" for="c-39998282">[-]</label><label class="expand" for="c-39998282">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I wish I could phrase it better for you. All I can say is that I have tried a _lot_ of tools, and nothing has come close. Amazon has done a lot of work to make efficient tools.<p>Here&#x27;s a better explanation: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;terabyte&#x2F;15a2d3d407285b8b5a0a7964dd6283b0" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;terabyte&#x2F;15a2d3d407285b8b5a0a7964dd6...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39997638" class="c"><input type="checkbox" id="c-39997638" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995957">parent</a><span>|</span><a href="#39996201">prev</a><span>|</span><a href="#39998455">next</a><span>|</span><label class="collapse" for="c-39997638">[-]</label><label class="expand" for="c-39997638">[1 more]</label></div><br/><div class="children"><div class="content">NixOS&#x2F;nixpkgs is about the closest thing you&#x27;ll find in the wild. You have to squint a bit, I&#x27;ll admit.</div><br/></div></div><div id="39998455" class="c"><input type="checkbox" id="c-39998455" checked=""/><div class="controls bullet"><span class="by">tripdout</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995957">parent</a><span>|</span><a href="#39997638">prev</a><span>|</span><a href="#39995902">next</a><span>|</span><label class="collapse" for="c-39998455">[-]</label><label class="expand" for="c-39998455">[1 more]</label></div><br/><div class="children"><div class="content">Is it true that teams don&#x27;t do branches in source control at all? Just publishing a CR?</div><br/></div></div></div></div><div id="39995902" class="c"><input type="checkbox" id="c-39995902" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995700">parent</a><span>|</span><a href="#39995957">prev</a><span>|</span><a href="#39994912">next</a><span>|</span><label class="collapse" for="c-39995902">[-]</label><label class="expand" for="c-39995902">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just that. Livegrep isn&#x27;t just a pale imitation of something inside Google. It&#x27;s totally unrelated in implementation, capabilities, and use case.</div><br/></div></div></div></div><div id="39994912" class="c"><input type="checkbox" id="c-39994912" checked=""/><div class="controls bullet"><span class="by">init</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39994712">parent</a><span>|</span><a href="#39995700">prev</a><span>|</span><a href="#39995889">next</a><span>|</span><label class="collapse" for="c-39994912">[-]</label><label class="expand" for="c-39994912">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used both Code Search and Livegrep. No, Livegrep does not even come close to what Code Search can do.<p>Sourcegraph is the closest thing I know of.</div><br/><div id="39995005" class="c"><input type="checkbox" id="c-39995005" checked=""/><div class="controls bullet"><span class="by">isker</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39994912">parent</a><span>|</span><a href="#39995692">next</a><span>|</span><label class="collapse" for="c-39995005">[-]</label><label class="expand" for="c-39995005">[3 more]</label></div><br/><div class="children"><div class="content">Agreed. There are some public building blocks available (e.g. Kythe or meta&#x27;s Glean) but having something generic that produces the kind of experience you can get on cs.chromium.org seems impossible. You need such bespoke build integration across an entire organization to get there.<p>Basic text search, as opposed to navigation, is all you&#x27;ll get from anything out of the box.</div><br/><div id="39995100" class="c"><input type="checkbox" id="c-39995100" checked=""/><div class="controls bullet"><span class="by">init</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995005">parent</a><span>|</span><a href="#39995692">next</a><span>|</span><label class="collapse" for="c-39995100">[-]</label><label class="expand" for="c-39995100">[2 more]</label></div><br/><div class="children"><div class="content">In a past job I built a code search clone on top of Kythe, Zoekt and LSP (for languages that didn&#x27;t have bazel integration). I got help from another colleague to make the UI based on Monaco. We create a demo that many people loved but we didn&#x27;t productionize it for a few reasons (it was an unfunded hackathon project and the company was considering another solution when they already had Livegrep)<p>Producing the Kythe graph from the bazel artifacts was the most expensive part.<p>Working with Kythe is also not easy as there is no documentation on how to run it at scale.</div><br/><div id="39995154" class="c"><input type="checkbox" id="c-39995154" checked=""/><div class="controls bullet"><span class="by">isker</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995100">parent</a><span>|</span><a href="#39995692">next</a><span>|</span><label class="collapse" for="c-39995154">[-]</label><label class="expand" for="c-39995154">[1 more]</label></div><br/><div class="children"><div class="content">Very cool. I tried to do things with Kythe at $JOB in the past, but gave up because the build (really, the many many independent builds) precluded any really useful integration.<p>I did end up making a nice UI for vanilla Zoekt, as I mentioned elsewhere: <a href="https:&#x2F;&#x2F;github.com&#x2F;isker&#x2F;neogrok">https:&#x2F;&#x2F;github.com&#x2F;isker&#x2F;neogrok</a>.</div><br/></div></div></div></div></div></div><div id="39995692" class="c"><input type="checkbox" id="c-39995692" checked=""/><div class="controls bullet"><span class="by">birktj</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39994912">parent</a><span>|</span><a href="#39995005">prev</a><span>|</span><a href="#39995058">next</a><span>|</span><label class="collapse" for="c-39995692">[-]</label><label class="expand" for="c-39995692">[6 more]</label></div><br/><div class="children"><div class="content">I see most replies here ar mentioning the the build integration is what is mainly missing in the public tools. I wonder if nix and nixpkgs could be used here? Nix is a language agnostic build-system and with nixpkgs it has a build instructions for a massive amount of packages. Artifacts for all packages are also available via hydra.<p>Nix should also have enough context so that for any project it can get the source code of all dependencies and (optionally) all build-time dependencies.</div><br/><div id="39995930" class="c"><input type="checkbox" id="c-39995930" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995692">parent</a><span>|</span><a href="#39995058">next</a><span>|</span><label class="collapse" for="c-39995930">[-]</label><label class="expand" for="c-39995930">[5 more]</label></div><br/><div class="children"><div class="content">Build integration is not the main thing that is missing between Livegrep and Code Search. The main thing that is missing is the semantic index. Kythe knows the difference between this::fn(int) and this::fn(double) and that::fn(double) and so on. So you can find all the callers of the nullary constructor of some class, without false positives of the callers of the copy constructor or the move constructor. Livegrep simply doesn&#x27;t have that ability at all. Livegrep is what it says it is on the box: grep.</div><br/><div id="39996365" class="c"><input type="checkbox" id="c-39996365" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995930">parent</a><span>|</span><a href="#39995058">next</a><span>|</span><label class="collapse" for="c-39996365">[-]</label><label class="expand" for="c-39996365">[4 more]</label></div><br/><div class="children"><div class="content">The build system coherence provided by a monorepo with a single build system is what makes you understand this::fn(double) as a single thing. Otherwise, you will get N different mostly compatible but subtly different flavors of entities depending on the build flavor, combinations of versioned dependencies, and other things.</div><br/><div id="39996383" class="c"><input type="checkbox" id="c-39996383" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39996365">parent</a><span>|</span><a href="#39995058">next</a><span>|</span><label class="collapse" for="c-39996383">[-]</label><label class="expand" for="c-39996383">[3 more]</label></div><br/><div class="children"><div class="content">Sure. Also, if you eat a bunch of glass, you will get a stomach ache. I have no idea why anyone uses a polyrepo.</div><br/><div id="39996396" class="c"><input type="checkbox" id="c-39996396" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39996383">parent</a><span>|</span><a href="#39995058">next</a><span>|</span><label class="collapse" for="c-39996396">[-]</label><label class="expand" for="c-39996396">[2 more]</label></div><br/><div class="children"><div class="content">The problem with monorepos is that they&#x27;re so great that everyone has a few.</div><br/><div id="39996919" class="c"><input type="checkbox" id="c-39996919" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39996396">parent</a><span>|</span><a href="#39995058">next</a><span>|</span><label class="collapse" for="c-39996919">[-]</label><label class="expand" for="c-39996919">[1 more]</label></div><br/><div class="children"><div class="content">God that is good.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39995058" class="c"><input type="checkbox" id="c-39995058" checked=""/><div class="controls bullet"><span class="by">tayo42</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39994912">parent</a><span>|</span><a href="#39995692">prev</a><span>|</span><a href="#39995889">next</a><span>|</span><label class="collapse" for="c-39995058">[-]</label><label class="expand" for="c-39995058">[7 more]</label></div><br/><div class="children"><div class="content">Is there like a summary of what&#x27;s missing from public attempts and what makes it so much better?</div><br/><div id="39995464" class="c"><input type="checkbox" id="c-39995464" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995058">parent</a><span>|</span><a href="#39995510">next</a><span>|</span><label class="collapse" for="c-39995464">[-]</label><label class="expand" for="c-39995464">[4 more]</label></div><br/><div class="children"><div class="content">The short answer is context. The reason why Google&#x27;s internal code search is so good, is it is tied into their build system. This means, when you search, you know exactly what files to consider.  Without context, you are making an educated guess, with regards to what files to consider.</div><br/><div id="39995673" class="c"><input type="checkbox" id="c-39995673" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995464">parent</a><span>|</span><a href="#39995510">next</a><span>|</span><label class="collapse" for="c-39995673">[-]</label><label class="expand" for="c-39995673">[3 more]</label></div><br/><div class="children"><div class="content">How exactly integration with build system helps Google? Maybe you could give specific example?..</div><br/><div id="39995891" class="c"><input type="checkbox" id="c-39995891" checked=""/><div class="controls bullet"><span class="by">isker</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995673">parent</a><span>|</span><a href="#39995816">next</a><span>|</span><label class="collapse" for="c-39995891">[-]</label><label class="expand" for="c-39995891">[1 more]</label></div><br/><div class="children"><div class="content">Try clicking around <a href="https:&#x2F;&#x2F;source.chromium.org&#x2F;chromium&#x2F;chromium&#x2F;src" rel="nofollow">https:&#x2F;&#x2F;source.chromium.org&#x2F;chromium&#x2F;chromium&#x2F;src</a>, which is built with Kythe (I believe, or perhaps it&#x27;s using something internal to Google that Kythe is the open source version of).<p>By hooking into C++ compilation, Kythe is giving you things like _macro-aware_ navigation. Instead of trying to process raw source text off to the side, it&#x27;s using the same data the compiler used to compile the code in the first place. So things like cross-references are &quot;perfect&quot;, with no false positives in the results: Kythe knows the difference between two symbols in two different source files with the same name, whereas a search engine naively indexing source text, or even something with limited semantic knowledge like tree sitter, cannot perfectly make the distinction.</div><br/></div></div><div id="39995816" class="c"><input type="checkbox" id="c-39995816" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995673">parent</a><span>|</span><a href="#39995891">prev</a><span>|</span><a href="#39995510">next</a><span>|</span><label class="collapse" for="c-39995816">[-]</label><label class="expand" for="c-39995816">[1 more]</label></div><br/><div class="children"><div class="content">If you want to build a product with a build system, you need to tell it what source to include.  With this information, you know what files to consider and if you are dealing with a statically typed language like C or C++, you have build artifacts that can tell you where the implementation was defined.  All of this, takes the guess work out of answering questions like &quot;What foo() implentation was used&quot;.<p>If all you know are repo branches, the best you can do is return matches from different repo branches with the hopes that one of them is right.<p>Edit: I should also add that with a build system, you know what version of a file to use.</div><br/></div></div></div></div></div></div><div id="39995510" class="c"><input type="checkbox" id="c-39995510" checked=""/><div class="controls bullet"><span class="by">j2kun</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995058">parent</a><span>|</span><a href="#39995464">prev</a><span>|</span><a href="#39997644">next</a><span>|</span><label class="collapse" for="c-39995510">[-]</label><label class="expand" for="c-39995510">[1 more]</label></div><br/><div class="children"><div class="content">Google builds all the code in its momnorepo continuously, and the built artifacts are available for the search. Open source tools are never going to incur the cost of actually building all the code it indexes.</div><br/></div></div><div id="39997644" class="c"><input type="checkbox" id="c-39997644" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39995058">parent</a><span>|</span><a href="#39995510">prev</a><span>|</span><a href="#39995889">next</a><span>|</span><label class="collapse" for="c-39997644">[-]</label><label class="expand" for="c-39997644">[1 more]</label></div><br/><div class="children"><div class="content">The short summary is: It&#x27;s a suite of stuff that someone actually thought about making work together well, instead of a random assortment of pieces that, with tons of work, might be able to be cobbled together into a working system.<p>All the answers about the technical details or better&#x2F;worseness mostly miss the point entirely - the public stuff doesn&#x27;t work as well because it&#x27;s 1000 providers who produce 1000 pieces that trade integration flexibility for product coherence.  On purpose mind you, because it&#x27;s hard to survive in business (or attract open source users if that&#x27;s your thing) otherwise.<p>If you are trying to do something like make &quot;code review&quot; and &quot;code search&quot; work together well, it&#x27;s a lot easier to build a coherent, easy to use system that feels good to a user if you are trying to make <i>two</i> things total work together, and the product management directly talks to each other.<p>Most open source doesn&#x27;t have product management to begin with, and the corporate stuff often does but that&#x27;s just one provider.<p>They also have a matrix of, generously, 10-20 tools with meaningful marketshare they might need to try to work with.<p>So if you are a code search provider  are trying to make a code search tool integrate well with any of the top 20 code review tools, well, good luck.<p>Sometimes people come along and do a good enough job abstracting a problem that you can make this work (LSP is a good example), but it&#x27;s pretty rare.<p>Now try it with &quot;discover, search, edit, build, test, release, deploy, debug&quot;, etc.  Once you are talking about  10x10x10x10x10x10x10x10 combinations of possible tools, with nobody who gets to decide which combinations are the well lit path, ...<p>Also, when you work somewhere like Google or Amazon, it&#x27;s not just that someone made those specific things work really well together, but often, they have both data and insight into where you get stuck overall in the dev process and why (so they can fix it).<p>At a place like Google, I can actually tell you all the paths that people take when trying to achieve a journey.   So that means I know all the loops (counts, times, etc) through development tools that start with something like &quot;user opens their editor&quot;.  Whether that&#x27;s &quot;open editor, make change, build, test, review, submit&quot; or &quot;open editor, make change, go to lunch&quot;, or &quot;open editor, go look at docs, go back to editor, go back to docs, etc&quot;.<p>So i have real answers to something like &quot;how often do people start in their IDE, discover they can&#x27;t figure out how to do X, leave the IDE to go find the answer, not find it, give up,  and go to lunch&quot;. 
I can tell you what the top X where that happens is, and how much time is or is not wasted through this path, etc.<p>Just as an example.  I can then use all of this to improve the tooling so users can get more done.<p>You will not find this in most public tooling, and to the degree telemetry exists that you could generate for your own use, nobody thinks about how all <i>that</i> telemetry works together.<p>Now, mind you, all the above is meant as an explanation - i&#x27;m trying to explain why the public attempts don&#x27;t end up as &quot;good&quot;. But myself, good&#x2F;bad is all about what you value.<p>Most tradeoffs here were deliberate.<p>But they are tradeoffs.<p>Some people value the flexibility more than coherence.
or whatever.
I&#x27;m not gonna judge them, but I can explain why you can&#x27;t have it all :)</div><br/></div></div></div></div></div></div><div id="39995889" class="c"><input type="checkbox" id="c-39995889" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39994538">root</a><span>|</span><a href="#39994712">parent</a><span>|</span><a href="#39994912">prev</a><span>|</span><a href="#39999027">next</a><span>|</span><label class="collapse" for="c-39995889">[-]</label><label class="expand" for="c-39995889">[1 more]</label></div><br/><div class="children"><div class="content">Just want to note that Livegrep, its antecedent &quot;codesearch&quot;, and other things that are basically grep bear no resemblance to that which a person working at Google calls &quot;Code Search&quot;.</div><br/></div></div></div></div><div id="39999027" class="c"><input type="checkbox" id="c-39999027" checked=""/><div class="controls bullet"><span class="by">fmobus</span><span>|</span><a href="#39994538">parent</a><span>|</span><a href="#39994712">prev</a><span>|</span><a href="#39994908">next</a><span>|</span><label class="collapse" for="c-39999027">[-]</label><label class="expand" for="c-39999027">[1 more]</label></div><br/><div class="children"><div class="content">The guide bindings layer thing is nice, but its UI could be improved. I wish I could directly find for providers&#x2F;usages from the search box.</div><br/></div></div></div></div><div id="39994908" class="c"><input type="checkbox" id="c-39994908" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39994538">prev</a><span>|</span><a href="#39998971">next</a><span>|</span><label class="collapse" for="c-39994908">[-]</label><label class="expand" for="c-39994908">[3 more]</label></div><br/><div class="children"><div class="content">Surprised that hound <a href="https:&#x2F;&#x2F;github.com&#x2F;hound-search&#x2F;hound">https:&#x2F;&#x2F;github.com&#x2F;hound-search&#x2F;hound</a> isn&#x27;t mentioned. I thought it was the leader of open source solutions in this space.<p>I&#x27;ve been using Wikimedia&#x27;s instance ( <a href="https:&#x2F;&#x2F;codesearch.wmcloud.org&#x2F;search&#x2F;" rel="nofollow">https:&#x2F;&#x2F;codesearch.wmcloud.org&#x2F;search&#x2F;</a> ) and have generally been pretty happy with what it provides.</div><br/><div id="39995536" class="c"><input type="checkbox" id="c-39995536" checked=""/><div class="controls bullet"><span class="by">isker</span><span>|</span><a href="#39994908">parent</a><span>|</span><a href="#39998971">next</a><span>|</span><label class="collapse" for="c-39995536">[-]</label><label class="expand" for="c-39995536">[2 more]</label></div><br/><div class="children"><div class="content">Hound has made an interesting choice to not bound searches. <a href="https:&#x2F;&#x2F;codesearch.wmcloud.org&#x2F;search&#x2F;?q=test&amp;files=&amp;excludeFiles=&amp;repos=" rel="nofollow">https:&#x2F;&#x2F;codesearch.wmcloud.org&#x2F;search&#x2F;?q=test&amp;files=&amp;exclude...</a> produces an ajax request that (for me) took 13s to produce a 55MB JSON response, and then takes many more seconds to render into the DOM.<p>Properly bounding search response sizes was one of the things I had to ensure Zoekt could do in its JSON APIs that I use in neogrok: <a href="https:&#x2F;&#x2F;github.com&#x2F;sourcegraph&#x2F;zoekt&#x2F;pull&#x2F;615">https:&#x2F;&#x2F;github.com&#x2F;sourcegraph&#x2F;zoekt&#x2F;pull&#x2F;615</a></div><br/><div id="39996136" class="c"><input type="checkbox" id="c-39996136" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39994908">root</a><span>|</span><a href="#39995536">parent</a><span>|</span><a href="#39998971">next</a><span>|</span><label class="collapse" for="c-39996136">[-]</label><label class="expand" for="c-39996136">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, i agree, that is weird. Especially if you search for something super common like &quot;function&quot; you basically DoS it.</div><br/></div></div></div></div></div></div><div id="39998971" class="c"><input type="checkbox" id="c-39998971" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#39994908">prev</a><span>|</span><a href="#39995462">next</a><span>|</span><label class="collapse" for="c-39998971">[-]</label><label class="expand" for="c-39998971">[2 more]</label></div><br/><div class="children"><div class="content">Why am I not seeing anything here about ctags[0] or cscope[1]? Are they that out of fashion? cscope language comprehension appears limited to C&#x2F;C++ and Java, but “ctags” (I think I use “uctags” atm) language support is quite broad and ubiquitous…<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ctags" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ctags</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cscope" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cscope</a></div><br/><div id="39999234" class="c"><input type="checkbox" id="c-39999234" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#39998971">parent</a><span>|</span><a href="#39995462">next</a><span>|</span><label class="collapse" for="c-39999234">[-]</label><label class="expand" for="c-39999234">[1 more]</label></div><br/><div class="children"><div class="content">exactly <i>THIS</i> &lt;sorry for shouting !&gt; the only problem with `cscope` is that for modern c++ based code-bases it is woefully inadequate. for plain &#x2F; vanilla c based code-bases f.e. linux-kernel etc. it is just _excellent_<p>language-servers using clangd&#x2F;ccls&#x2F;... are definitely useful, but quite resource heavy. for example, each of these tools seem to starting new threads per file (!) and there are no knobs to not do that. i don&#x27;t really understand this rationale at all. yes, i have seen this exact behavior with both clangd and ccls. oftentimes, the memory in these processes balloon to some godawful numbers (more with clangd than ccls), necessitating a kill.<p>moreover, this might be an unpopular opinion, but mixing any regex based tool (ripgrep&#x2F;... come to mind) with language-server f.e. because the language server does not really find what you are looking for, or does not do that fast enough, are major points against it. if you already have language-server running, regex based tools should not be required at all.<p>i don&#x27;t really understand the reason for sql&#x27;ization of code searches at all. it is not a &#x27;natural&#x27; interface. typical usage is to see &#x27;who calls this function&#x27;, &#x27;where is the definition at&#x27; of this function etc. etc.</div><br/></div></div></div></div><div id="39995462" class="c"><input type="checkbox" id="c-39995462" checked=""/><div class="controls bullet"><span class="by">Macha</span><span>|</span><a href="#39998971">prev</a><span>|</span><a href="#39995611">next</a><span>|</span><label class="collapse" for="c-39995462">[-]</label><label class="expand" for="c-39995462">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is a pretty bad index: it has words that should be stop words, like function, and won’t split a.toString() into two tokens because . is not a default word boundary.<p>So github used to (maybe still does) &quot;fix&quot; this one and it&#x27;s annoying. Although github are ramping up their IDE like find-usages, it&#x27;s still not perfect, so somethings you just want to a text search equivalent for &quot;foo.bar()&quot; for all the uses it misses and this stemming behaviour then finds every while where foo and bar are mentioned which bloats results.</div><br/></div></div><div id="39995611" class="c"><input type="checkbox" id="c-39995611" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#39995462">prev</a><span>|</span><a href="#39998366">next</a><span>|</span><label class="collapse" for="c-39995611">[-]</label><label class="expand" for="c-39995611">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand their hand-waving of Zoekt. It was built exactly for this purpose, and is not a &quot;new infrastructure commitment&quot; any more than the other options. The server is a  single binary, the indexer is also a single binary, can&#x27;t get any simpler than that.<p>To me it doesn&#x27;t make sense to be more scared of it than Elasticsearch...</div><br/></div></div><div id="39998366" class="c"><input type="checkbox" id="c-39998366" checked=""/><div class="controls bullet"><span class="by">ethanwillis</span><span>|</span><a href="#39995611">prev</a><span>|</span><a href="#39999348">next</a><span>|</span><label class="collapse" for="c-39998366">[-]</label><label class="expand" for="c-39998366">[1 more]</label></div><br/><div class="children"><div class="content">There are tools from bioinformatics that would be more applicable here for code search than the ones linguistics has made for searching natural language.</div><br/></div></div><div id="39999348" class="c"><input type="checkbox" id="c-39999348" checked=""/><div class="controls bullet"><span class="by">louiskw</span><span>|</span><a href="#39998366">prev</a><span>|</span><a href="#39994563">next</a><span>|</span><label class="collapse" for="c-39999348">[-]</label><label class="expand" for="c-39999348">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;BloopAI&#x2F;bloop">https:&#x2F;&#x2F;github.com&#x2F;BloopAI&#x2F;bloop</a> Is fully open source and has full text + regex search built on tantivy fyi</div><br/></div></div><div id="39994563" class="c"><input type="checkbox" id="c-39994563" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#39999348">prev</a><span>|</span><a href="#39996203">next</a><span>|</span><label class="collapse" for="c-39994563">[-]</label><label class="expand" for="c-39994563">[1 more]</label></div><br/><div class="children"><div class="content">Oracle has USER&#x2F;ALL&#x2F;DBA_SOURCE views, and all of the PL&#x2F;SQL (SQL&#x2F;PSM) code that has been loaded into the database is presented there. These are all cleartext visible unless they have been purposefully obfuscated.<p>It has columns for the owner, object name, LINE[NUMBER] and TEXT[VARCHAR2(4000)] columns and you can use LIKE or regexp_like() on any of the retained source code.<p>I wonder if EnterpriseDB implements these inside of Postgres, and&#x2F;or if they are otherwise available as an extension.<p>Since most of SQL&#x2F;PSM came from Oracle anyway, these would be an obvious desired feature.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SQL&#x2F;PSM" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SQL&#x2F;PSM</a></div><br/></div></div><div id="39996203" class="c"><input type="checkbox" id="c-39996203" checked=""/><div class="controls bullet"><span class="by">boyter</span><span>|</span><a href="#39994563">prev</a><span>|</span><a href="#39997044">next</a><span>|</span><label class="collapse" for="c-39996203">[-]</label><label class="expand" for="c-39996203">[1 more]</label></div><br/><div class="children"><div class="content">Code search is indeed hard. Stop words, stemming and such do rule out most off the shelf indexing solutions but you can usually turn them off. You can even get around the splitting issues of things like<p><pre><code>    a.toString()
</code></pre>
With some pre-processing of the content. However were you really get into a world of pain is allowing someone to search for ring in the example. You can use partial term search, prefix, infix, or suffix but this massively bloats the index and is slow to run.<p>The next thing you try is trigrams, and suddenly you have to deal with false positive matches. So you add a positional portion to your index, and all of a sudden the underlying index is larger than the content you are indexing.<p>Its good fun though. For those curious about it I would also suggest reading posts by Michael Stapelberg <a href="https:&#x2F;&#x2F;michael.stapelberg.ch&#x2F;posts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;michael.stapelberg.ch&#x2F;posts&#x2F;</a> who writes about Debian Code Search (which I believe he started) in addition to the other posts mentioned here. Shameless plug, I also write about this <a href="https:&#x2F;&#x2F;boyter.org&#x2F;posts&#x2F;how-i-built-my-own-index-for-searchcode&#x2F;" rel="nofollow">https:&#x2F;&#x2F;boyter.org&#x2F;posts&#x2F;how-i-built-my-own-index-for-search...</a> where I go into some of the issues when building a custom index for searchcode.com<p>Oddly enough I think you can go a long way brute forcing the search if you don&#x27;t do anything obviously wrong. For situations where you are only allowed to search a small portion of the content, say just your own (which looks applicable in this situation) that&#x27;s what I would do. Adding an index is really only useful when you start searching at scale or you are getting semantic search out of it. For keywords which is what the article appears to be talking about, that&#x27;s what I would be inclined to do.</div><br/></div></div><div id="39997044" class="c"><input type="checkbox" id="c-39997044" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#39996203">prev</a><span>|</span><a href="#39999277">next</a><span>|</span><label class="collapse" for="c-39997044">[-]</label><label class="expand" for="c-39997044">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a million paths, but here&#x27;s one I like.<p>Use ElasticSearch.  It will scale more than Postgres.  Three hosted options are AWS, Elastic, Bonsai.  I founded Bonsai and retired (so am partial), but they will provide the best human support for you, and you won&#x27;t have to worry about java Xmx.<p>Your goal with ES is to use the Regex PatternAnalyzer to split the code into reasonable exact code-shaped tokens (not english words).<p>Here&#x27;s a rough GPT4 explanation with sample config that I&#x27;d head towards: <a href="https:&#x2F;&#x2F;chat.openai.com&#x2F;share&#x2F;e4d08586-b7ef-48f2-9de1-7f82ea3c1f14" rel="nofollow">https:&#x2F;&#x2F;chat.openai.com&#x2F;share&#x2F;e4d08586-b7ef-48f2-9de1-7f82ea...</a></div><br/><div id="39997449" class="c"><input type="checkbox" id="c-39997449" checked=""/><div class="controls bullet"><span class="by">bytefish</span><span>|</span><a href="#39997044">parent</a><span>|</span><a href="#39999277">next</a><span>|</span><label class="collapse" for="c-39997449">[-]</label><label class="expand" for="c-39997449">[1 more]</label></div><br/><div class="children"><div class="content">GitLab is also using ElasticSearch, so one could recreate the ElasticSearch Indices they came up with. [1]<p>They also share some of the challenges, they faced along the way. It also discusses interesting challenges, like implementing the authorization model. [2], [3]<p>When GitHub removed its most useful Search feature, which is sorting results by date, I wrote a small “Search Engine” with ElasticSearch to selectively index Microsoft repositories. It works good enough for my needs. [4]<p>[1] <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;gitlab-org&#x2F;gitlab&#x2F;-&#x2F;blob&#x2F;7bbbc00bd871aeb67660a1c42ff30c65ba6ed47a&#x2F;ee&#x2F;lib&#x2F;elastic&#x2F;latest&#x2F;config.rb" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;gitlab-org&#x2F;gitlab&#x2F;-&#x2F;blob&#x2F;7bbbc00bd871aeb6...</a><p>[2] <a href="https:&#x2F;&#x2F;about.gitlab.com&#x2F;blog&#x2F;2019&#x2F;07&#x2F;16&#x2F;elasticsearch-update&#x2F;" rel="nofollow">https:&#x2F;&#x2F;about.gitlab.com&#x2F;blog&#x2F;2019&#x2F;07&#x2F;16&#x2F;elasticsearch-updat...</a><p>[3] <a href="https:&#x2F;&#x2F;about.gitlab.com&#x2F;blog&#x2F;2020&#x2F;04&#x2F;28&#x2F;elasticsearch-update&#x2F;" rel="nofollow">https:&#x2F;&#x2F;about.gitlab.com&#x2F;blog&#x2F;2020&#x2F;04&#x2F;28&#x2F;elasticsearch-updat...</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;bytefish&#x2F;ElasticsearchCodeSearch">https:&#x2F;&#x2F;github.com&#x2F;bytefish&#x2F;ElasticsearchCodeSearch</a></div><br/></div></div></div></div><div id="39999277" class="c"><input type="checkbox" id="c-39999277" checked=""/><div class="controls bullet"><span class="by">reeyadalli</span><span>|</span><a href="#39997044">prev</a><span>|</span><a href="#39995819">next</a><span>|</span><label class="collapse" for="c-39999277">[-]</label><label class="expand" for="c-39999277">[1 more]</label></div><br/><div class="children"><div class="content">I have never actually given it much thought about the difference between code search and normal &quot;literature&quot;. Interesting read!!</div><br/></div></div><div id="39995819" class="c"><input type="checkbox" id="c-39995819" checked=""/><div class="controls bullet"><span class="by">campbel</span><span>|</span><a href="#39999277">prev</a><span>|</span><a href="#39995217">next</a><span>|</span><label class="collapse" for="c-39995819">[-]</label><label class="expand" for="c-39995819">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sourcegraph’s maintained fork of Zoekt is pretty cool, but is pretty fearfully niche and would be a big, new infrastructure commitment.<p>I don&#x27;t think Zoekt is as scary as this article makes it out to be. I set this up at my current company after getting experience with it at Shopify and its really great.</div><br/></div></div><div id="39995217" class="c"><input type="checkbox" id="c-39995217" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#39995819">prev</a><span>|</span><a href="#39994661">next</a><span>|</span><label class="collapse" for="c-39995217">[-]</label><label class="expand" for="c-39995217">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It’s hard to find any accounts of code-search using FTS<p>I&#x27;m actually going to be doing this soon.  I&#x27;ve thought about code search for close to a decade, but I walked away from it, because there really isn&#x27;t a business for it.  However, now with AI, I&#x27;m more interested in using it to help find relevant context and I have no reason to believe FTS won&#x27;t work.  In the past I used Lucene, but I&#x27;m planning on going all in with Postgres.<p>The magic to fast code search (search in general), is keeping things small. As long as your search solution is context aware, you can easily leverage Postgres sharding to reduce index sizes.  I&#x27;m a strong believer in &quot;disk space is cheap, time isn&#x27;t&quot;, which means I&#x27;m not afraid to create as many indexes as required, to shave 100&#x27;s of milliseconds of searches.</div><br/><div id="39996146" class="c"><input type="checkbox" id="c-39996146" checked=""/><div class="controls bullet"><span class="by">bevekspldnw</span><span>|</span><a href="#39995217">parent</a><span>|</span><a href="#39994661">next</a><span>|</span><label class="collapse" for="c-39996146">[-]</label><label class="expand" for="c-39996146">[5 more]</label></div><br/><div class="children"><div class="content">Mmm, it’s not that straight forward: indexes can vastly slow down large scale ingest, so it’s really about <i>when</i> to index as well.<p>I work with a lot of multi billion row datasets and a lot of my recent focus has been on developing strategies to avoid the slow down with ingest, and then enjoying the speed up for indexed on search.<p>I’ve also gotten some mjnd boggling speed increases by summarizing key searchable data in smaller tables, some with JSONB columns that are abstractions of other data, indexing those, and using pg prewarm to serve those tables purely from memory. I literally went from queries taking actual days to &lt; 1 sec.</div><br/><div id="39996580" class="c"><input type="checkbox" id="c-39996580" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#39995217">root</a><span>|</span><a href="#39996146">parent</a><span>|</span><a href="#39994661">next</a><span>|</span><label class="collapse" for="c-39996580">[-]</label><label class="expand" for="c-39996580">[4 more]</label></div><br/><div class="children"><div class="content">Yeah I agree.  I&#x27;ve had a lot of practice so far with coordinating between hundreds of thousands of tables to ensure ingestion&#x2F;lookup is fast.  Everything boils down to optimizing for your query patterns.<p>I also believe in using what I call &quot;compass tables&quot; (like your summarization tables), which I guess are indexes of indexes.</div><br/><div id="39997111" class="c"><input type="checkbox" id="c-39997111" checked=""/><div class="controls bullet"><span class="by">bevekspldnw</span><span>|</span><a href="#39995217">root</a><span>|</span><a href="#39996580">parent</a><span>|</span><a href="#39994661">next</a><span>|</span><label class="collapse" for="c-39997111">[-]</label><label class="expand" for="c-39997111">[3 more]</label></div><br/><div class="children"><div class="content">Scaling databases both oddly frustrating and also rewarding. Getting that first query that executes at 10x of the old one feels great. The week of agony that makes it possible…less so.</div><br/><div id="39997208" class="c"><input type="checkbox" id="c-39997208" checked=""/><div class="controls bullet"><span class="by">sdesol</span><span>|</span><a href="#39995217">root</a><span>|</span><a href="#39997111">parent</a><span>|</span><a href="#39994661">next</a><span>|</span><label class="collapse" for="c-39997208">[-]</label><label class="expand" for="c-39997208">[2 more]</label></div><br/><div class="children"><div class="content">Fully agree.  I do have to give hardware a lot of credit though.  With SSD and now NVME, fast random read&#x2F;write speed is what makes a lot of things possible.</div><br/><div id="39997807" class="c"><input type="checkbox" id="c-39997807" checked=""/><div class="controls bullet"><span class="by">bevekspldnw</span><span>|</span><a href="#39995217">root</a><span>|</span><a href="#39997208">parent</a><span>|</span><a href="#39994661">next</a><span>|</span><label class="collapse" for="c-39997807">[-]</label><label class="expand" for="c-39997807">[1 more]</label></div><br/><div class="children"><div class="content">Yup, I just wish Samsung made an 8TB NVME!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39994661" class="c"><input type="checkbox" id="c-39994661" checked=""/><div class="controls bullet"><span class="by">jackbravo</span><span>|</span><a href="#39995217">prev</a><span>|</span><a href="#39994582">next</a><span>|</span><label class="collapse" for="c-39994661">[-]</label><label class="expand" for="c-39994661">[3 more]</label></div><br/><div class="children"><div class="content">Would LLM vector embeddings work in this context? I&#x27;m guessing they should since they are very good at understanding code.</div><br/><div id="39995129" class="c"><input type="checkbox" id="c-39995129" checked=""/><div class="controls bullet"><span class="by">CityOfThrowaway</span><span>|</span><a href="#39994661">parent</a><span>|</span><a href="#39994582">next</a><span>|</span><label class="collapse" for="c-39995129">[-]</label><label class="expand" for="c-39995129">[2 more]</label></div><br/><div class="children"><div class="content">Yes but generating that index would be expensive</div><br/><div id="39996335" class="c"><input type="checkbox" id="c-39996335" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#39994661">root</a><span>|</span><a href="#39995129">parent</a><span>|</span><a href="#39994582">next</a><span>|</span><label class="collapse" for="c-39996335">[-]</label><label class="expand" for="c-39996335">[1 more]</label></div><br/><div class="children"><div class="content">Why exactly? You mean to construct the embeddings or to embed the queries?</div><br/></div></div></div></div></div></div><div id="39994582" class="c"><input type="checkbox" id="c-39994582" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#39994661">prev</a><span>|</span><a href="#39997597">next</a><span>|</span><label class="collapse" for="c-39994582">[-]</label><label class="expand" for="c-39994582">[4 more]</label></div><br/><div class="children"><div class="content">I suppose using something like tree sitter to get a consistent abstract syntax tree to work with would be a good starting point. And then try building a custom analyzer (if using elasticsearch lingo) with that?</div><br/><div id="39994902" class="c"><input type="checkbox" id="c-39994902" checked=""/><div class="controls bullet"><span class="by">azornathogron</span><span>|</span><a href="#39994582">parent</a><span>|</span><a href="#39995618">next</a><span>|</span><label class="collapse" for="c-39994902">[-]</label><label class="expand" for="c-39994902">[1 more]</label></div><br/><div class="children"><div class="content">Another option is to start with Kythe, which is Google&#x27;s own open source framework for getting a uniform cross-language semantic layer: <a href="https:&#x2F;&#x2F;kythe.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;kythe.io&#x2F;</a><p>Worth looking at as a source of inspiration and design ideas even if you don&#x27;t want to use it itself.</div><br/></div></div><div id="39995618" class="c"><input type="checkbox" id="c-39995618" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39994582">parent</a><span>|</span><a href="#39994902">prev</a><span>|</span><a href="#39997597">next</a><span>|</span><label class="collapse" for="c-39995618">[-]</label><label class="expand" for="c-39995618">[2 more]</label></div><br/><div class="children"><div class="content">Might be overkill unless you&#x27;re looking to do semantic search. I&#x27;ve thought about what a search DSL for code would look like, it&#x27;s challenging to embody a query like &quot;method which takes an Int64 and has a variable idx in it&quot; into something compact and memorable.<p>But a tokenizer seems like a good place to start, I think that&#x27;s the right granularity for this kind of application. You&#x27;d want to do some chunking so that foo.bar doesn&#x27;t find every foo and every bar, that sort of thing. Code search is, as the title says, a hard problem. But a language-aware token stream, the one you&#x27;d get from the lexer, is probably where one should start in building the database.</div><br/><div id="39996183" class="c"><input type="checkbox" id="c-39996183" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#39994582">root</a><span>|</span><a href="#39995618">parent</a><span>|</span><a href="#39997597">next</a><span>|</span><label class="collapse" for="c-39996183">[-]</label><label class="expand" for="c-39996183">[1 more]</label></div><br/><div class="children"><div class="content">Sure you should definitively not try to do the overkill use case first but I would assume that tree sitter can emit &quot;just&quot; tokens as well? Getting the flexibility and control of a tool like tree sitter should allow you to quickly throw away stuff like comments and keywords if you want since you can do syntax aware filtering.<p>Then again I haven&#x27;t used tree-sitter, can just imagine that this is a strength of it.</div><br/></div></div></div></div></div></div><div id="39997597" class="c"><input type="checkbox" id="c-39997597" checked=""/><div class="controls bullet"><span class="by">civilized</span><span>|</span><a href="#39994582">prev</a><span>|</span><a href="#39998083">next</a><span>|</span><label class="collapse" for="c-39997597">[-]</label><label class="expand" for="c-39997597">[1 more]</label></div><br/><div class="children"><div class="content">Is &quot;hard&quot; a bit of an overstatement for problems like &quot;I&#x27;m using a library that mangles the query&quot;? Couldn&#x27;t you search for the literal text the user inputs? Maybe let them use regex?</div><br/></div></div><div id="39998083" class="c"><input type="checkbox" id="c-39998083" checked=""/><div class="controls bullet"><span class="by">metalrain</span><span>|</span><a href="#39997597">prev</a><span>|</span><a href="#39996553">next</a><span>|</span><label class="collapse" for="c-39998083">[-]</label><label class="expand" for="c-39998083">[2 more]</label></div><br/><div class="children"><div class="content">I think you need to parse the code and build AST to make good search. Even then normalizing over different aliases, may not be simple.</div><br/><div id="39999560" class="c"><input type="checkbox" id="c-39999560" checked=""/><div class="controls bullet"><span class="by">vladak</span><span>|</span><a href="#39998083">parent</a><span>|</span><a href="#39996553">next</a><span>|</span><label class="collapse" for="c-39999560">[-]</label><label class="expand" for="c-39999560">[1 more]</label></div><br/><div class="children"><div class="content">The question is what code. In preprocessed languages there can be lots of ifdefs and such for various environments and architectures.</div><br/></div></div></div></div><div id="39996553" class="c"><input type="checkbox" id="c-39996553" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39998083">prev</a><span>|</span><a href="#39994502">next</a><span>|</span><label class="collapse" for="c-39996553">[-]</label><label class="expand" for="c-39996553">[3 more]</label></div><br/><div class="children"><div class="content">A feature I&#x27;d appreciate from Val Town is the ability to point it to a GitHub repo that I own and have it write the source code for all of my Vals to that repo, on an ongoing basis.<p>Then I could use GitHub code search, or even &quot;git pull&quot; and run ripgrep.</div><br/><div id="39997702" class="c"><input type="checkbox" id="c-39997702" checked=""/><div class="controls bullet"><span class="by">nbbaier</span><span>|</span><a href="#39996553">parent</a><span>|</span><a href="#39994502">next</a><span>|</span><label class="collapse" for="c-39997702">[-]</label><label class="expand" for="c-39997702">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually built a tool in Val Town that could be used as the basis for something like this: <a href="https:&#x2F;&#x2F;www.val.town&#x2F;v&#x2F;nbbaier&#x2F;valToGH" rel="nofollow">https:&#x2F;&#x2F;www.val.town&#x2F;v&#x2F;nbbaier&#x2F;valToGH</a><p>Right now it only commits one val, but it would be trivial to write it into a loop and then use a scheduled val to have it run over all your vals as a cron job!</div><br/><div id="39998229" class="c"><input type="checkbox" id="c-39998229" checked=""/><div class="controls bullet"><span class="by">nbbaier</span><span>|</span><a href="#39996553">root</a><span>|</span><a href="#39997702">parent</a><span>|</span><a href="#39994502">next</a><span>|</span><label class="collapse" for="c-39998229">[-]</label><label class="expand" for="c-39998229">[1 more]</label></div><br/><div class="children"><div class="content">nvm, just went in and changed it so now you could theoretically do all your vals at once. I realized though that it will not update file contents as is, so need to figure that out ...</div><br/></div></div></div></div></div></div><div id="39994502" class="c"><input type="checkbox" id="c-39994502" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#39996553">prev</a><span>|</span><a href="#39998217">next</a><span>|</span><label class="collapse" for="c-39994502">[-]</label><label class="expand" for="c-39994502">[3 more]</label></div><br/><div class="children"><div class="content">Surprised not to see Livegrep [0] on the list of options. Very well-engineered technology; the codebase is clean (if a little underdocumented on the architecture side) and you should be able to index your code without much difficulty. Built with Bazel (~meh, but useful if you don&#x27;t have an existing cpp toolchain all set up) and there are prebuilt containers you can run. Try that first.<p>By the way, there&#x27;s a demo running here for the linux kernel, you can try it out and see what you think: <a href="https:&#x2F;&#x2F;livegrep.com&#x2F;search&#x2F;linux" rel="nofollow">https:&#x2F;&#x2F;livegrep.com&#x2F;search&#x2F;linux</a><p>EDIT: by the way, &quot;code search&quot; is deeply underspecified. Before trying to compare all these different options, you really would benefit from writing down all the different types of queries you think your users will want to ask, including <i>why they want to run that query</i> and <i>what results they&#x27;d expect</i>. Building&#x2F;tuning search is almost as difficult a product problem as it is an engineering problem.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;livegrep&#x2F;livegrep">https:&#x2F;&#x2F;github.com&#x2F;livegrep&#x2F;livegrep</a></div><br/><div id="39994937" class="c"><input type="checkbox" id="c-39994937" checked=""/><div class="controls bullet"><span class="by">isker</span><span>|</span><a href="#39994502">parent</a><span>|</span><a href="#39998217">next</a><span>|</span><label class="collapse" for="c-39994937">[-]</label><label class="expand" for="c-39994937">[2 more]</label></div><br/><div class="children"><div class="content">When I investigated using livegrep for code search at work, it really struggled to scale to a large number of repositories. At least at the time (a few years ago) indexing in livegrep was a monolithic operation: you index all repos at once, which produces one giant index. This does not work well once you&#x27;re past a certain threshold.<p>I also recall that the indexes it produces are pretty heavyweight in terms of memory requirements, but I don&#x27;t have any numbers on hand to justify that claim.<p>Zoekt (also mentioned in TFA) has the correct properties in this regard. Except in niche configurations that are probably only employed at sourcegraph, each repo is (re)indexed independently and produces a separate set of index files.<p>But its builtin web UI left much to be desired (especially compared to livegrep), so I built one: <a href="https:&#x2F;&#x2F;github.com&#x2F;isker&#x2F;neogrok">https:&#x2F;&#x2F;github.com&#x2F;isker&#x2F;neogrok</a>.</div><br/><div id="39995269" class="c"><input type="checkbox" id="c-39995269" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#39994502">root</a><span>|</span><a href="#39994937">parent</a><span>|</span><a href="#39998217">next</a><span>|</span><label class="collapse" for="c-39995269">[-]</label><label class="expand" for="c-39995269">[1 more]</label></div><br/><div class="children"><div class="content">I like this better than livegrep. I haven&#x27;t actually operated either zoekt OR livegrep before, but I&#x27;ll probably start with zoekt+neogrok next time I want to stand up a codesearch page. Thanks for building and sharing this!</div><br/></div></div></div></div></div></div><div id="39998217" class="c"><input type="checkbox" id="c-39998217" checked=""/><div class="controls bullet"><span class="by">amarshall</span><span>|</span><a href="#39994502">prev</a><span>|</span><a href="#39994469">next</a><span>|</span><label class="collapse" for="c-39998217">[-]</label><label class="expand" for="c-39998217">[1 more]</label></div><br/><div class="children"><div class="content">&gt; GitHub’s search is excellent<p>Is it? I find it near-useless most of the time, and cloning + ripgrep to be way more efficient. Perhaps the problem is more in the UX being awful than the actual search.</div><br/></div></div><div id="39994469" class="c"><input type="checkbox" id="c-39994469" checked=""/><div class="controls bullet"><span class="by">healeycodes</span><span>|</span><a href="#39998217">prev</a><span>|</span><a href="#39997477">next</a><span>|</span><label class="collapse" for="c-39994469">[-]</label><label class="expand" for="c-39994469">[2 more]</label></div><br/><div class="children"><div class="content">When a val is deployed on val town, my understanding is that it&#x27;s parsed&#x2F;compiled. At that point, can you save the parts of the program that people might search for? Names of imports, functions, variables, comments, etc.</div><br/><div id="39996307" class="c"><input type="checkbox" id="c-39996307" checked=""/><div class="controls bullet"><span class="by">MH15</span><span>|</span><a href="#39994469">parent</a><span>|</span><a href="#39997477">next</a><span>|</span><label class="collapse" for="c-39996307">[-]</label><label class="expand" for="c-39996307">[1 more]</label></div><br/><div class="children"><div class="content">A val is just Typescript, no? So unless they are also storing the AST it would be JavaScript and that&#x27;s it</div><br/></div></div></div></div><div id="39997477" class="c"><input type="checkbox" id="c-39997477" checked=""/><div class="controls bullet"><span class="by">johnthescott</span><span>|</span><a href="#39994469">prev</a><span>|</span><a href="#39996339">next</a><span>|</span><label class="collapse" for="c-39997477">[-]</label><label class="expand" for="c-39997477">[1 more]</label></div><br/><div class="children"><div class="content">the rum index has worked well for us on roughly 1TB of pdfs.  written by postgrespro, same folks who wrote core text search and json indexing.  not sure why rum not in core.  we have no problems.<p><pre><code>   https:&#x2F;&#x2F;github.com&#x2F;postgrespro&#x2F;rum</code></pre></div><br/></div></div><div id="39996339" class="c"><input type="checkbox" id="c-39996339" checked=""/><div class="controls bullet"><span class="by">nbenitezl</span><span>|</span><a href="#39997477">prev</a><span>|</span><a href="#39995722">next</a><span>|</span><label class="collapse" for="c-39996339">[-]</label><label class="expand" for="c-39996339">[1 more]</label></div><br/><div class="children"><div class="content">Also <a href="https:&#x2F;&#x2F;github.com&#x2F;Debian&#x2F;dcs">https:&#x2F;&#x2F;github.com&#x2F;Debian&#x2F;dcs</a></div><br/></div></div><div id="39995722" class="c"><input type="checkbox" id="c-39995722" checked=""/><div class="controls bullet"><span class="by">herrington_d</span><span>|</span><a href="#39996339">prev</a><span>|</span><a href="#39996636">next</a><span>|</span><label class="collapse" for="c-39995722">[-]</label><label class="expand" for="c-39995722">[2 more]</label></div><br/><div class="children"><div class="content">Is it possible to combine n-gram and AST to dump a better indexing?<p>Take `sourceCode.toString()` as an example, the AST can dump it to `sourceCode` and `toString`. A further indexer can break `sourceCode` to `source` and `code`.<p>For ast dumping, project like <a href="https:&#x2F;&#x2F;github.com&#x2F;ast-grep&#x2F;ast-grep">https:&#x2F;&#x2F;github.com&#x2F;ast-grep&#x2F;ast-grep</a> can help.</div><br/><div id="39996392" class="c"><input type="checkbox" id="c-39996392" checked=""/><div class="controls bullet"><span class="by">boyter</span><span>|</span><a href="#39995722">parent</a><span>|</span><a href="#39996636">next</a><span>|</span><label class="collapse" for="c-39996392">[-]</label><label class="expand" for="c-39996392">[1 more]</label></div><br/><div class="children"><div class="content">You could, but I don&#x27;t know what you gain out of it. The underlying index would be almost the same size, and n-gram would also allow you to search for e.t for example which you are losing in this process.</div><br/></div></div></div></div><div id="39996636" class="c"><input type="checkbox" id="c-39996636" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#39995722">prev</a><span>|</span><a href="#39996684">next</a><span>|</span><label class="collapse" for="c-39996636">[-]</label><label class="expand" for="c-39996636">[2 more]</label></div><br/><div class="children"><div class="content">OpenGrok (<a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;opengrok">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;opengrok</a>) is a wonderful tool to search a codebase.<p>It runs on-prem and handles lots of popular programming languages.</div><br/><div id="39998500" class="c"><input type="checkbox" id="c-39998500" checked=""/><div class="controls bullet"><span class="by">AstralJaeger</span><span>|</span><a href="#39996636">parent</a><span>|</span><a href="#39996684">next</a><span>|</span><label class="collapse" for="c-39998500">[-]</label><label class="expand" for="c-39998500">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree with you there, OpenGrok is a wonderful, oudated-looking and feeling but lightning fast code search engine!</div><br/></div></div></div></div><div id="39996684" class="c"><input type="checkbox" id="c-39996684" checked=""/><div class="controls bullet"><span class="by">pomdtr</span><span>|</span><a href="#39996636">prev</a><span>|</span><a href="#39994103">next</a><span>|</span><label class="collapse" for="c-39996684">[-]</label><label class="expand" for="c-39996684">[5 more]</label></div><br/><div class="children"><div class="content">Hey! I&#x27;m a val.town fanboy and I immediately thought about a workaround while reading the blog post:<p>What if I dumped every publics vals in Github, in order to be able to user their (awesome) search ?<p>So here is my own &quot;Val Town Search&quot;: <a href="https:&#x2F;&#x2F;val-town-search.pomdtr.me" rel="nofollow">https:&#x2F;&#x2F;val-town-search.pomdtr.me</a><p>And here is the repo containing all vals, updated hourly thanks to a github action: <a href="https:&#x2F;&#x2F;github.com&#x2F;pomdtr&#x2F;val-town-mirror">https:&#x2F;&#x2F;github.com&#x2F;pomdtr&#x2F;val-town-mirror</a></div><br/><div id="39996714" class="c"><input type="checkbox" id="c-39996714" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39996684">parent</a><span>|</span><a href="#39997708">next</a><span>|</span><label class="collapse" for="c-39996714">[-]</label><label class="expand" for="c-39996714">[2 more]</label></div><br/><div class="children"><div class="content">Well this is fun...<p><pre><code>    git clone https:&#x2F;&#x2F;github.com&#x2F;pomdtr&#x2F;val-town-mirror
    cd val-town-mirror
    rg news.ycombinator.com
</code></pre>
Now I can ripgrep search public Vals, e.g. to see who&#x27;s hitting Hacker News from a Val.</div><br/><div id="39996746" class="c"><input type="checkbox" id="c-39996746" checked=""/><div class="controls bullet"><span class="by">pomdtr</span><span>|</span><a href="#39996684">root</a><span>|</span><a href="#39996714">parent</a><span>|</span><a href="#39997708">next</a><span>|</span><label class="collapse" for="c-39996746">[-]</label><label class="expand" for="c-39996746">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and you can finally run&#x2F;debug vals locally (kind of, the version query param is not yet supported)</div><br/></div></div></div></div><div id="39997708" class="c"><input type="checkbox" id="c-39997708" checked=""/><div class="controls bullet"><span class="by">nbbaier</span><span>|</span><a href="#39996684">parent</a><span>|</span><a href="#39996714">prev</a><span>|</span><a href="#39996824">next</a><span>|</span><label class="collapse" for="c-39997708">[-]</label><label class="expand" for="c-39997708">[1 more]</label></div><br/><div class="children"><div class="content">This is great!</div><br/></div></div><div id="39996824" class="c"><input type="checkbox" id="c-39996824" checked=""/><div class="controls bullet"><span class="by">MatthiasPortzel</span><span>|</span><a href="#39996684">parent</a><span>|</span><a href="#39997708">prev</a><span>|</span><a href="#39994103">next</a><span>|</span><label class="collapse" for="c-39996824">[-]</label><label class="expand" for="c-39996824">[1 more]</label></div><br/><div class="children"><div class="content">That is, uh, one solution, to say the least.<p>There’s a HN comment I’ll never forget where the commenter suggests that Discord move their search infrastructure to a series of text file searched with ripgrep, but Val.town’s scale is small enough that they could actually consider it.</div><br/></div></div></div></div><div id="39994103" class="c"><input type="checkbox" id="c-39994103" checked=""/><div class="controls bullet"><span class="by">semiquaver</span><span>|</span><a href="#39996684">prev</a><span>|</span><label class="collapse" for="c-39994103">[-]</label><label class="expand" for="c-39994103">[3 more]</label></div><br/><div class="children"><div class="content">Be careful with trigram indexes. At least in the postgres 10 era they caused severe index bloat for frequently updated tables.</div><br/><div id="39994541" class="c"><input type="checkbox" id="c-39994541" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#39994103">parent</a><span>|</span><label class="collapse" for="c-39994541">[-]</label><label class="expand" for="c-39994541">[2 more]</label></div><br/><div class="children"><div class="content">Interesting, do you know anywhere I can easily read more about this? (I will do my own research, too.)</div><br/><div id="39996448" class="c"><input type="checkbox" id="c-39996448" checked=""/><div class="controls bullet"><span class="by">boyter</span><span>|</span><a href="#39994103">root</a><span>|</span><a href="#39994541">parent</a><span>|</span><label class="collapse" for="c-39996448">[-]</label><label class="expand" for="c-39996448">[1 more]</label></div><br/><div class="children"><div class="content">Its a result of trigrams themselves. For example turning searchcode (please ignore plug, this is just the example I had to hand) goes from 1 thing you would need to index into 8.<p><pre><code>    &quot;searchcode&quot;   -&gt; [sea, ear, arc, rch, chc, hco, cod, ode]
</code></pre>
As a result the index rapidly becomes larger than you would expect.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>