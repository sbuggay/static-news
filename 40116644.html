<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713862859130" as="style"/><link rel="stylesheet" href="styles.css?v=1713862859130"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://16bpp.net/blog/post/the-performance-impact-of-cpp-final-keyword/">The Performance Impact of C++&#x27;s `final` Keyword</a>Â <span class="domain">(<a href="https://16bpp.net">16bpp.net</a>)</span></div><div class="subtext"><span>hasheddan</span> | <span>187 comments</span></div><br/><div><div id="40116928" class="c"><input type="checkbox" id="c-40116928" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40117389">next</a><span>|</span><label class="collapse" for="c-40116928">[-]</label><label class="expand" for="c-40116928">[34 more]</label></div><br/><div class="children"><div class="content">What final enables is devirtualization in certain cases. The
 main advantage of devirtualization is that it is necessary for inlining.<p>Inlining has other requirements as well -- LTO pretty much covers it.<p>The article doesn&#x27;t have sufficient data to tell whether the testcase is built in such a way that any of these optimizations can happen or is beneficial.</div><br/><div id="40128945" class="c"><input type="checkbox" id="c-40128945" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40116928">parent</a><span>|</span><a href="#40117555">next</a><span>|</span><label class="collapse" for="c-40128945">[-]</label><label class="expand" for="c-40128945">[3 more]</label></div><br/><div class="children"><div class="content">&gt; What final enables is devirtualization in certain cases. The main advantage of devirtualization is that it is necessary for inlining.<p>I think that enabling inlining is just one of the indirect consequences of devirtualization, and perhaps one that is largely irrelevant for performance improvements.<p>The whole point of devirtualization is eliminating the need to resort to pointer dereferencing when calling virtual members. The main trait of a virtual class is it&#x27;s use of a vtable that requires dereferencing virtual members to access each and every one of them.<p>In classes with larger inheritance chains, you can easily have more than one pointer dereferencing taking place before you call a virtual members function.<p>Once a class is final, none of that is required anymore. When a member is referred, no dereferencing takes place.<p>Devirtualization helps performance because you are able to benefit from inheritance and not have to pay a performance penalty for that. Without the final keyword, a performance oriented project would need to be architected to not use inheritance at all, or in the very least in code in the hot path, because that sneaks gratuitous pointer dereferences all over the place, which require running extra operations and has a negative impact on caching.<p>The whole purpose of the final keyword is that compilers can easily eliminate all pointer dereferencing used by virtual members. What stops them from applying this optimization is that they have no information on whether that class will be inherited and one of its members will either override any of its members or invoke any member function implemented by one of its parent classes.<p>With the introduction of the final keyword, you are now able to tell the compiler &quot;from thereon, this is exactly what you get&quot; and the compiler can trim out anything loose.</div><br/><div id="40129061" class="c"><input type="checkbox" id="c-40129061" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40128945">parent</a><span>|</span><a href="#40117555">next</a><span>|</span><label class="collapse" for="c-40129061">[-]</label><label class="expand" for="c-40129061">[2 more]</label></div><br/><div class="children"><div class="content">An extra indirection (indirect call versus direct call) is practically nothing on modern hardware. Branch predictors are insanely good, and this isn&#x27;t something you generally have to worry about.<p>Inlining is by far the most impactful optimization here, because it can eliminate the call altogether, and thus specialize the called function to the callsite, lifting constants, hoisting loop variables, etc.</div><br/><div id="40129864" class="c"><input type="checkbox" id="c-40129864" checked=""/><div class="controls bullet"><span class="by">silvestrov</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40129061">parent</a><span>|</span><a href="#40117555">next</a><span>|</span><label class="collapse" for="c-40129864">[-]</label><label class="expand" for="c-40129864">[1 more]</label></div><br/><div class="children"><div class="content">&quot;is practically nothing on modern hardware&quot; <i>if the data is already present in the L2 cache.</i>   Random RAM access that stalls execution is expensive.<p>My guess is this is why he didn&#x27;t see any speedup: all the code could fit inside the L2 cache, so he did not have to pay for RAM access for the deference.<p>The number of different classes is important, not the number of objects as they have the same small number of vtable pointers.<p>It might be different for large codebases like Chrome and Firefox.</div><br/></div></div></div></div></div></div><div id="40117555" class="c"><input type="checkbox" id="c-40117555" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#40116928">parent</a><span>|</span><a href="#40128945">prev</a><span>|</span><a href="#40117201">next</a><span>|</span><label class="collapse" for="c-40117555">[-]</label><label class="expand" for="c-40117555">[18 more]</label></div><br/><div class="children"><div class="content">See this is why I find this odd.<p>Is there a theory as to how devirtualisation could hurt performance?</div><br/><div id="40119416" class="c"><input type="checkbox" id="c-40119416" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40126867">next</a><span>|</span><label class="collapse" for="c-40119416">[-]</label><label class="expand" for="c-40119416">[8 more]</label></div><br/><div class="children"><div class="content">Jumps&#x2F;calls are actually be pretty cheap with modern branch predictors. Even indirect calls through vtables, which is the opposite of most programmers intuition.<p>And if the devirtualisation leads to inlining, that results in code bloat which can lower performance though more instruction cache misses, which are not cheap.<p>Inlining is actually pretty evil. It almost always speeds things up for microbenchmarks, as such benchmarks easily fit in icache. So programmers and modern compilers often go out of their way to do more inlining. But when you apply too much inlining to a whole program, things start to slow down.<p>But it&#x27;s not like inlining is universally bad in larger program, inlining can enable further optimisations, mostly because it allows constant propagation to travel across function boundaries.<p>Basically, compilers need better heuristics about when they should be inlining. If it&#x27;s just saving the overhead of a lightweight call, then they shouldn&#x27;t be inlining.</div><br/><div id="40128448" class="c"><input type="checkbox" id="c-40128448" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40119416">parent</a><span>|</span><a href="#40120402">next</a><span>|</span><label class="collapse" for="c-40128448">[-]</label><label class="expand" for="c-40128448">[2 more]</label></div><br/><div class="children"><div class="content">Another for the pro side: inlining can allow for better branch prediction if the different call sites would tend to drive different code paths in the function.</div><br/><div id="40128773" class="c"><input type="checkbox" id="c-40128773" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40128448">parent</a><span>|</span><a href="#40120402">next</a><span>|</span><label class="collapse" for="c-40128773">[-]</label><label class="expand" for="c-40128773">[1 more]</label></div><br/><div class="children"><div class="content">This was true 15 years ago, but not so much today.<p>The branch predictors actually hash the history of the last few branches taken into the branch prediction query. So the exact same branch within a child function will map different branch predictors entries depending on which parent function it was called from, and there is no benifit to inlining.<p>It also means that branch predictor can also learn correlations between branches within a function. Like when a branches at the top and bottom of functions share conditions, or have inverted conditions.</div><br/></div></div></div></div><div id="40120402" class="c"><input type="checkbox" id="c-40120402" checked=""/><div class="controls bullet"><span class="by">qsdf38100</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40119416">parent</a><span>|</span><a href="#40128448">prev</a><span>|</span><a href="#40126867">next</a><span>|</span><label class="collapse" for="c-40120402">[-]</label><label class="expand" for="c-40120402">[5 more]</label></div><br/><div class="children"><div class="content">&quot;Inlining is actually pretty evil&quot;.<p>No it&#x27;s not. Except if you __force_inline__ everything, of course.<p>Inlining reduces the number of instructions in a lot of cases. Especially when things are abstracted and factored with lot of indirections into small functions that calls other small functions and so on. Consider a &#x27;isEmpty&#x27; function, which dissolves to 1 cpu instruction once inlined, compared with a call&#x2F;save reg&#x2F;compare&#x2F;return. Highly dynamic code (with most functions being virtual) tend to result in a fest of chained calls, jumping into functions doing very little work. Yes the stack is usually hot and fast, but spending 80% of the instructions doing stack management is still a big waste.<p>Compilers already have good heuristics about when they should be inlining, chances are they are a lot better at it than you. They don&#x27;t always inline, and that&#x27;s not possible anyway.<p>My experience is that compiler do marvels with inlining decisions when there are lots of small functions they _can_ inline if they want to. It gives the compiler a lot of freedom. Lambdas are great for that as well.<p>Make sure you make the most possible compile-time information available to the compiler, factor your code, don&#x27;t have huge functions, and let the compiler do its magic. As a plus, you can have high level abstractions, deep hierarchies, and still get excellent performances.</div><br/><div id="40123388" class="c"><input type="checkbox" id="c-40123388" checked=""/><div class="controls bullet"><span class="by">grdbjydcv</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40120402">parent</a><span>|</span><a href="#40128074">next</a><span>|</span><label class="collapse" for="c-40123388">[-]</label><label class="expand" for="c-40123388">[1 more]</label></div><br/><div class="children"><div class="content">The âevilnessâ is just that sometimes if you inline aggressively in a microbenchmark things get faster but in real programs things get slower.<p>As you say: âchances are they are a lot better at it than youâ. Infrequently they are not.</div><br/></div></div><div id="40128074" class="c"><input type="checkbox" id="c-40128074" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40120402">parent</a><span>|</span><a href="#40123388">prev</a><span>|</span><a href="#40126867">next</a><span>|</span><label class="collapse" for="c-40128074">[-]</label><label class="expand" for="c-40128074">[3 more]</label></div><br/><div class="children"><div class="content">doesn&#x27;t the compiler usually do well enough that you really only need to worry about time critical sections of code? Even then you could go in and look at the assembler and see if it&#x27;s being inlined, no?</div><br/><div id="40128378" class="c"><input type="checkbox" id="c-40128378" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40128074">parent</a><span>|</span><a href="#40126867">next</a><span>|</span><label class="collapse" for="c-40128378">[-]</label><label class="expand" for="c-40128378">[2 more]</label></div><br/><div class="children"><div class="content">I find that gcc and clang are so aggressive about inlining that it&#x27;s usually more effective to tell them what <i>not</i> to inline.<p>In a moderately-sized codebase I regularly work on, I use __attribute__((noinline)) nearly ten times as often as __attribute__((always_inline)). And I use __attribute__((cold)) even more than noinline.<p>So yeah, I can kind of see why someone would say inlining is &#x27;evil&#x27;, though I think it&#x27;s more accurate to say that it&#x27;s just not possible for compilers to figure out these kinds of details without copious hints (like PGO).</div><br/><div id="40128647" class="c"><input type="checkbox" id="c-40128647" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40128378">parent</a><span>|</span><a href="#40126867">next</a><span>|</span><label class="collapse" for="c-40128647">[-]</label><label class="expand" for="c-40128647">[1 more]</label></div><br/><div class="children"><div class="content">+1 on the __attribute__((cold)). Compilers so aggressively optimize based on their heuristics that you spend more time telling them that an apparent optimization opportunity is not actually an optimization.<p>When writing ultra-robust code that has to survive every vaguely plausible contingency in a graceful way, the code is littered with code paths that only exist for astronomically improbable situations. The branch predictor can figure this out but the compiler frequently cannot without explicit instructions to not pollute the i-cache.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40126867" class="c"><input type="checkbox" id="c-40126867" checked=""/><div class="controls bullet"><span class="by">variadix</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40119416">prev</a><span>|</span><a href="#40117756">next</a><span>|</span><label class="collapse" for="c-40126867">[-]</label><label class="expand" for="c-40126867">[1 more]</label></div><br/><div class="children"><div class="content">It basically never should unless the inliner made a terrible judgement. Devirtualizing in C++ can remove 3 levels of pointer chasing, all of which could be cache misses. Many optimizations in modern compilers require the context of the function to be inlined to make major optimizations, which requires devirtualization. The only downside is I$ pressure, but this is generally not a problem because hot loops are usually tight.</div><br/></div></div><div id="40117756" class="c"><input type="checkbox" id="c-40117756" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40126867">prev</a><span>|</span><a href="#40117822">next</a><span>|</span><label class="collapse" for="c-40117756">[-]</label><label class="expand" for="c-40117756">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a cost to loading more instructions, especially if you have more types of instructions.<p>The main advantages to inlining are (1) avoiding a jump and other function call overhead, (2) the ability to push down optimizations.<p>If you execute the &quot;same&quot; code (same instructions, different location) in many places that can cause cache evictions and other slowdowns. It&#x27;s worse if some minor optimizations were applied by the inlining, so you have more types of instructions to unpack.<p>The question, roughly, is whether the gains exceed the costs. This can be a bit hard to determine because it can depend on the size of the whole program and other non-local parameters, leading to performance cliffs at various stages of complexity. Microbenchmarks will tend to suggest inlining is better in more cases that it actually is.<p>Over time you get a feel for which functions should be inlined. E.g., very often you&#x27;ll have guard clauses or whatnot around a trivial amount of work when the caller is expected to be able to prove the guarded information at compile-time. A function call takes space in the generated assembly too, and if you&#x27;re only guarding a few instructions it&#x27;s usually worth forcing an inline (even in places where the compiler&#x27;s heuristics would choose not to because the guard clauses take up too much space), regardless of the potential cache costs.</div><br/></div></div><div id="40117822" class="c"><input type="checkbox" id="c-40117822" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40117756">prev</a><span>|</span><a href="#40128634">next</a><span>|</span><label class="collapse" for="c-40117822">[-]</label><label class="expand" for="c-40117822">[1 more]</label></div><br/><div class="children"><div class="content">Through inlining.<p>If you have something like a `while` loop and that while loop&#x27;s instructions fit neatly on the cache line, then executing that loop can be quiet fast even if you have to jump to different code locations to do the internals.  However, if you pump in more instructions in that loop you can exceed the length of the cache line which causes you to need more memory loads to do the same work.<p>It can also create more code.  A method that took a `foo(NotFinal&amp; bar)` could be duplicated by the compiler for the specialized cases which would be bad if there&#x27;s a lot of implementations of `NotFinal` that end up being marshalled into foo.  You could end up loading multiple implementations of the same function which may be slower than just keeping the virtual dispatch tables warm.</div><br/></div></div><div id="40128634" class="c"><input type="checkbox" id="c-40128634" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40117822">prev</a><span>|</span><a href="#40117711">next</a><span>|</span><label class="collapse" for="c-40128634">[-]</label><label class="expand" for="c-40128634">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s done badly, the same code that runs N times also gets cached N times because it&#x27;s in N different locations in memory rather than one location that gets jumped to. Modern compilers and schedulers will eliminate a lot of that (but probably not for anything much smaller than a page), but in general there&#x27;s always a tradeoff.</div><br/></div></div><div id="40117711" class="c"><input type="checkbox" id="c-40117711" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40128634">prev</a><span>|</span><a href="#40117789">next</a><span>|</span><label class="collapse" for="c-40117711">[-]</label><label class="expand" for="c-40117711">[1 more]</label></div><br/><div class="children"><div class="content">Devirtualization maybe not necessarily, but inlining might make code fail to fit into instruction caches.</div><br/></div></div><div id="40117789" class="c"><input type="checkbox" id="c-40117789" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40117711">prev</a><span>|</span><a href="#40123832">next</a><span>|</span><label class="collapse" for="c-40117789">[-]</label><label class="expand" for="c-40117789">[1 more]</label></div><br/><div class="children"><div class="content">Code bloat causing icache evictions?</div><br/></div></div><div id="40123832" class="c"><input type="checkbox" id="c-40123832" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117555">parent</a><span>|</span><a href="#40117789">prev</a><span>|</span><a href="#40117201">next</a><span>|</span><label class="collapse" for="c-40123832">[-]</label><label class="expand" for="c-40123832">[3 more]</label></div><br/><div class="children"><div class="content">Practically - it never does. It is always cheaper to perform a direct, possibly inlined, call (devirtualization != inlining) than a virtual one.<p>Guarded devirtualization is also cheaper than virtual calls, even when it has to do<p><pre><code>    if (instance is SpecificType st) { st.Call() }
    else { instance.Call() } 
</code></pre>
or even chain multiple checks at once (with either regular ifs or emitting a jump table)<p>This technique is heavily used in various forms by .NET, JVM and JavaScript JIT implementations (other platforms also do that, but these are the major ones)<p>The first two devirtualize virtual and interface calls (important in Java because all calls default to virtual, important in C# because people like to abuse interfaces and occasionally inheritance, C# delegates are also devirtualized&#x2F;inlined now). The JS JIT (like V8) performs &quot;inline caching&quot; which is similar where for known object shapes property access is shape type identifier comparison and direct property read instead of keyed lookup which is way more expensive.</div><br/><div id="40129373" class="c"><input type="checkbox" id="c-40129373" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40123832">parent</a><span>|</span><a href="#40117201">next</a><span>|</span><label class="collapse" for="c-40129373">[-]</label><label class="expand" for="c-40129373">[2 more]</label></div><br/><div class="children"><div class="content">Caution! If you compare across languages like that, not all virtual calls are implemented equally.
A C++ virtual call is just a load from a fixed offset in the vtbl followed by an indirect call. This is fairly cheap, on modern CPUs pretty much the same as a non-virtual non-inlined call.
A Java&#x2F;C# interface call involves a lot more stuff, because there&#x27;s no single fixed vtbl offset that&#x27;s valid for all classes implementing the interface.</div><br/><div id="40129486" class="c"><input type="checkbox" id="c-40129486" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40129373">parent</a><span>|</span><a href="#40117201">next</a><span>|</span><label class="collapse" for="c-40129486">[-]</label><label class="expand" for="c-40129486">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is true that there is difference. I&#x27;m not sure about JVM implementation details but the reason the comment says &quot;virtual <i>and</i> interface&quot; calls is to outline it. Virtual calls in .NET are sufficiently close[0] to virtual calls in C++. Interface calls, however, are coded differently[1].<p>Also you are correct - virtual calls are not terribly expensive, but they encroach on ever limited* CPU resources like indirect jump and load predictors and, as noted in parent comments, block inlining, which is highly undesirable.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;5111fdc0dc464f01647d6b6078342f451bf3a499&#x2F;src&#x2F;coreclr&#x2F;vm&#x2F;amd64&#x2F;virtualcallstubcpu.hpp#L471-L505">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;5111fdc0dc464f01647d6...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;main&#x2F;docs&#x2F;design&#x2F;coreclr&#x2F;botr&#x2F;virtual-stub-dispatch.md">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;blob&#x2F;main&#x2F;docs&#x2F;design&#x2F;core...</a> (mind you, the text was initially written 18 years ago, wow)<p>* through great effort of our industry to take back whatever performance wins each generation brings with even more abstractions that fail to improve our productivity</div><br/></div></div></div></div></div></div></div></div><div id="40117201" class="c"><input type="checkbox" id="c-40117201" checked=""/><div class="controls bullet"><span class="by">i80and</span><span>|</span><a href="#40116928">parent</a><span>|</span><a href="#40117555">prev</a><span>|</span><a href="#40117389">next</a><span>|</span><label class="collapse" for="c-40117201">[-]</label><label class="expand" for="c-40117201">[12 more]</label></div><br/><div class="children"><div class="content">If you already have LTO, can&#x27;t the compiler determine this information for devirtualization purposes on its own?</div><br/><div id="40117547" class="c"><input type="checkbox" id="c-40117547" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117201">parent</a><span>|</span><a href="#40117297">next</a><span>|</span><label class="collapse" for="c-40117547">[-]</label><label class="expand" for="c-40117547">[2 more]</label></div><br/><div class="children"><div class="content">In general the compiler&#x2F;linker cannot assume that derived classes won&#x27;t arrive later through a shared object.<p>You can tell it &quot;I won&#x27;t do that&quot; though with additional flags, like Clang&#x27;s -fwhole-program-vtables, and even then it&#x27;s not that simple. There was an effort in Clang to better support whole program devirtualization, but I haven&#x27;t been following what kind of progress has been made: 
<a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;llvm-dev&#x2F;c&#x2F;6LfIiAo9g68?pli=1" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;llvm-dev&#x2F;c&#x2F;6LfIiAo9g68?pli=1</a></div><br/><div id="40129839" class="c"><input type="checkbox" id="c-40129839" checked=""/><div class="controls bullet"><span class="by">Slix</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117547">parent</a><span>|</span><a href="#40117297">next</a><span>|</span><label class="collapse" for="c-40129839">[-]</label><label class="expand" for="c-40129839">[1 more]</label></div><br/><div class="children"><div class="content">This optimization option isn&#x27;t on by default? That sounds like a lot of missed optimization. Most programs aren&#x27;t going to be loading from shared libraries.<p>Maybe I can set this option at work. Though it&#x27;s scary because I&#x27;d have to be certain.</div><br/></div></div></div></div><div id="40117297" class="c"><input type="checkbox" id="c-40117297" checked=""/><div class="controls bullet"><span class="by">wiml</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117201">parent</a><span>|</span><a href="#40117547">prev</a><span>|</span><a href="#40117736">next</a><span>|</span><label class="collapse" for="c-40117297">[-]</label><label class="expand" for="c-40117297">[3 more]</label></div><br/><div class="children"><div class="content">If your runtime environment has dynamic linking, then the LTO pass can&#x27;t always be sure that a subclass won&#x27;t be introduced later that overrides the method.</div><br/><div id="40117807" class="c"><input type="checkbox" id="c-40117807" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117297">parent</a><span>|</span><a href="#40117460">next</a><span>|</span><label class="collapse" for="c-40117807">[-]</label><label class="expand" for="c-40117807">[1 more]</label></div><br/><div class="children"><div class="content">You can tell the compiler it is indeed compiling the whole program.</div><br/></div></div><div id="40117460" class="c"><input type="checkbox" id="c-40117460" checked=""/><div class="controls bullet"><span class="by">i80and</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117297">parent</a><span>|</span><a href="#40117807">prev</a><span>|</span><a href="#40117736">next</a><span>|</span><label class="collapse" for="c-40117460">[-]</label><label class="expand" for="c-40117460">[1 more]</label></div><br/><div class="children"><div class="content">Aha! That makes sense. I wasn&#x27;t thinking of that case. Thanks!</div><br/></div></div></div></div><div id="40117736" class="c"><input type="checkbox" id="c-40117736" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117201">parent</a><span>|</span><a href="#40117297">prev</a><span>|</span><a href="#40117242">next</a><span>|</span><label class="collapse" for="c-40117736">[-]</label><label class="expand" for="c-40117736">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the cases where JIT compiling can shine. You can use a bazillion interfaces to decouple application code, and the JIT will optimize the calls after it found out which implementation is used. This works as long as there is only one or two of them actually active at runtime.</div><br/></div></div><div id="40117242" class="c"><input type="checkbox" id="c-40117242" checked=""/><div class="controls bullet"><span class="by">nickwanninger</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117201">parent</a><span>|</span><a href="#40117736">prev</a><span>|</span><a href="#40117401">next</a><span>|</span><label class="collapse" for="c-40117242">[-]</label><label class="expand" for="c-40117242">[3 more]</label></div><br/><div class="children"><div class="content">At the level that LLVM&#x27;s LTO operates, no information about classes or objects is left, so LLVM itself can&#x27;t really devirtualize C++ methods in most cases</div><br/><div id="40121330" class="c"><input type="checkbox" id="c-40121330" checked=""/><div class="controls bullet"><span class="by">nwallin</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117242">parent</a><span>|</span><a href="#40117401">next</a><span>|</span><label class="collapse" for="c-40121330">[-]</label><label class="expand" for="c-40121330">[2 more]</label></div><br/><div class="children"><div class="content">You appear to be correct. Clang does not devirtualize in LTO, but GCC does. Personally I consider this very strange.<p><pre><code>     $ cat animal.h cat.cpp main.cpp
    &#x2F;&#x2F; animal.h
    
    #pragma once
    
    class animal {
     public:
      virtual ~animal() {}
      virtual void speak() = 0;
    };
    
    animal&amp; get_mystery_animal();
    &#x2F;&#x2F; cat.cpp
    
    #include &quot;animal.h&quot;
    #include &lt;cstdio&gt;
    
    class cat final : public animal {
    public:
      ~cat() override{}
      void speak() override{
        puts(&quot;meow&quot;);
      }
    };
    
    static cat garfield{};
    
    animal&amp; get_mystery_animal() {
      return garfield;
    }
    &#x2F;&#x2F; main.cpp
    
    #include &quot;animal.h&quot;
    
    int main() {
      animal&amp; a = get_mystery_animal();
      a.speak();
    }
     $ make clean &amp;&amp; CXX=clang++ make -j &amp;&amp; objdump --disassemble=main -C lto_test
    rm -f *.o lto_test
    clang++ -c -flto -O3 -g cat.cpp -o cat.o
    clang++ -c -flto -O3 -g main.cpp -o main.o
    clang++ -flto -O3 -g cat.o main.o -o lto_test
    
    lto_test:     file format elf64-x86-64
    
    
    Disassembly of section .init:
    
    Disassembly of section .plt:
    
    Disassembly of section .plt.got:
    
    Disassembly of section .text:
    
    00000000000011b0 &lt;main&gt;:
        11b0: 50                    push   %rax
        11b1: 48 8b 05 58 2e 00 00  mov    0x2e58(%rip),%rax        # 4010 &lt;garfield&gt;
        11b8: 48 8d 3d 51 2e 00 00  lea    0x2e51(%rip),%rdi        # 4010 &lt;garfield&gt;
        11bf: ff 50 10              call   *0x10(%rax)
        11c2: 31 c0                 xor    %eax,%eax
        11c4: 59                    pop    %rcx
        11c5: c3                    ret
    
    Disassembly of section .fini:
     $ make clean &amp;&amp; CXX=g++ make -j &amp;&amp; objdump --disassemble=main -C lto_test|sed -e &#x27;s,^,    ,&#x27;
    rm -f *.o lto_test
    g++ -c -flto -O3 -g cat.cpp -o cat.o
    g++ -c -flto -O3 -g main.cpp -o main.o
    g++ -flto -O3 -g cat.o main.o -o lto_test
    
    lto_test:     file format elf64-x86-64
    
    
    Disassembly of section .init:
    
    Disassembly of section .plt:
    
    Disassembly of section .plt.got:
    
    Disassembly of section .text:
    
    0000000000001090 &lt;main&gt;:
        1090: 48 83 ec 08           sub    $0x8,%rsp
        1094: 48 8d 3d 75 2f 00 00  lea    0x2f75(%rip),%rdi        # 4010 &lt;garfield&gt;
        109b: e8 50 01 00 00        call   11f0 &lt;cat::speak()&gt;
        10a0: 31 c0                 xor    %eax,%eax
        10a2: 48 83 c4 08           add    $0x8,%rsp
        10a6: c3                    ret
    
    Disassembly of section .fini:</code></pre></div><br/><div id="40127454" class="c"><input type="checkbox" id="c-40127454" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40121330">parent</a><span>|</span><a href="#40117401">next</a><span>|</span><label class="collapse" for="c-40127454">[-]</label><label class="expand" for="c-40127454">[1 more]</label></div><br/><div class="children"><div class="content">What if you add -fwhole-program-vtables on clang?</div><br/></div></div></div></div></div></div><div id="40117401" class="c"><input type="checkbox" id="c-40117401" checked=""/><div class="controls bullet"><span class="by">adzm</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117201">parent</a><span>|</span><a href="#40117242">prev</a><span>|</span><a href="#40117423">next</a><span>|</span><label class="collapse" for="c-40117401">[-]</label><label class="expand" for="c-40117401">[1 more]</label></div><br/><div class="children"><div class="content">MSVC with LTO and PGO will inline virtual calls in some situations along with a check for the expected vtable, bypassing the inlined code and calling the virtual function normally if it is an unexpected value.</div><br/></div></div><div id="40117423" class="c"><input type="checkbox" id="c-40117423" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40116928">root</a><span>|</span><a href="#40117201">parent</a><span>|</span><a href="#40117401">prev</a><span>|</span><a href="#40117389">next</a><span>|</span><label class="collapse" for="c-40117423">[-]</label><label class="expand" for="c-40117423">[1 more]</label></div><br/><div class="children"><div class="content">not if there is a shared libray or other plugin. Then you coannot determine until runtime if there is an override.</div><br/></div></div></div></div></div></div><div id="40117389" class="c"><input type="checkbox" id="c-40117389" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40116928">prev</a><span>|</span><a href="#40116940">next</a><span>|</span><label class="collapse" for="c-40117389">[-]</label><label class="expand" for="c-40117389">[64 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t do much C++, but I have definitely found that engineers will just assert that something is &quot;faster&quot; without any evidence to back that up.<p>Quick example, I got in an argument with someone a few years ago that claimed in C# that a `switch` was better than an `if(x==1) elseif(x==2)...` because switch was &quot;faster&quot; and rejected my PR.  I mentioned that that doesn&#x27;t appear to be true, we went back and forth until I did a compile-then-decompile of a minimal test with equality-based-ifs, and showed that the compiler actually converts equality-based-ifs to `switch` behind the scenes. The guy accepted my PR after that.<p>But there&#x27;s tons of this stuff like this in CS, and I kind of blame professors for a lot of it [1].  A large part of becoming a decent engineer [2] for me was learning to stop trusting what professors taught me in college.  Most of what they said was fine, but you can&#x27;t <i>assume</i> that; what they tell you could be out of date, or simply never correct to begin with, and as far as I can tell you have to <i>always</i> test these things.<p>It doesn&#x27;t help that a lot of these &quot;it&#x27;s faster&quot; arguments are often reductive because they only are faster in extremely minimal tests.  Sometimes a microbenchmark will show that something is faster, and there&#x27;s value in that, but I think it&#x27;s important that that can also be a small percentage of the total program; compilers are obscenely good at optimizing nowadays, it can be difficult to determine <i>when</i> something will be optimized, and your assertion that something is &quot;faster&quot; might not actually be true in a non-trivial program.<p>This is why I don&#x27;t really like doing any kind of major optimizations before the program actually works. I try to keep the program in a reasonable Big-O and I try and minimize network calls cuz of latency, but I don&#x27;t bother with any kind of micro-optimizations in the first draft.  I don&#x27;t mess with bitwise, I don&#x27;t concern myself on which version of a particular data structure is a millisecond faster, I don&#x27;t focus too much on whether I can get away with a smaller sized float, etc.  Once I know that the program is correct, <i>then</i> I benchmark to see if any kind of micro-optimizations will actually matter, and often they really don&#x27;t.<p>[1] That includes me up to about a year ago.<p>[2] At least I like to pretend I am.</div><br/><div id="40118212" class="c"><input type="checkbox" id="c-40118212" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40117566">next</a><span>|</span><label class="collapse" for="c-40118212">[-]</label><label class="expand" for="c-40118212">[11 more]</label></div><br/><div class="children"><div class="content">A significant part of it is that what engineers believe was effectively true at one time. They simply haven&#x27;t revisited those beliefs or verified their relevance in a long time. It isn&#x27;t a terrible heuristic for life in general to assume that what worked ten years ago will work today. The rate at which the equilibriums shift due to changes in hardware and software environments when designing for system performance is so rapid that you need to make a continuous habit of checking that your understanding of how the world works maps to reality.<p>I&#x27;ve solved a lot of arguments with godbolt and simple performance tests. Some topics are recurring themes among software engineers e.g.:<p>- compilers are almost always better at micro-optimizations than you are<p>- disk I&#x2F;O is almost never a bottleneck in competent designs<p>- brute-force sequential scans are often optimal algorithms<p>- memory is best treated as a block device<p>- vectorization can offer large performance gains<p>- etc...<p>No one is immune to this. I am sometimes surprised at the extent to which assumptions are no longer true when I revisit optimization work I did 10+ years ago.<p>Most performance these days is architectural, so getting the initial design right often has a bigger impact than micro-optimizations and localized Big-O tweaks. You can always go back and tweak algorithms or codegen later but architecture is permanent.</div><br/><div id="40119418" class="c"><input type="checkbox" id="c-40119418" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118212">parent</a><span>|</span><a href="#40118774">next</a><span>|</span><label class="collapse" for="c-40119418">[-]</label><label class="expand" for="c-40119418">[1 more]</label></div><br/><div class="children"><div class="content">Yep, completely agree with you on this.  Intuition is often wrong, or at least outdated.<p>When I&#x27;m building stuff I try my best to focus on &quot;correctness&quot;, and try to come up with an algorithm&#x2F;design that will encompass all realistic use cases. If I focus on that, it&#x27;s relatively easy to go back and convert my `decimal` type to a float64, or even convert an if statement into a switch if it&#x27;s actually faster.</div><br/></div></div><div id="40118774" class="c"><input type="checkbox" id="c-40118774" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118212">parent</a><span>|</span><a href="#40119418">prev</a><span>|</span><a href="#40117566">next</a><span>|</span><label class="collapse" for="c-40118774">[-]</label><label class="expand" for="c-40118774">[9 more]</label></div><br/><div class="children"><div class="content">.NET is a particularly bad case for this because it was a decade of few performance improvements, which caused a certain intuition to develop within the industry, then 6-8 years of significant changes each year (with most wins compressed to the last 4 years or so). Companies moving from .NET Framework 4.6&#x2F;7&#x2F;8 to .NET 8 experience a 10x <i>average</i> performance improvement, which naturally comes with rendering a lot of performance know-how obsolete overnight.<p>(the techniques that used to work were similar to earlier Java versions and overall very dynamic languages with some exceptions, the techniques that still work and now are required today are the same as in C++ or Rust)</div><br/><div id="40127463" class="c"><input type="checkbox" id="c-40127463" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118774">parent</a><span>|</span><a href="#40117566">next</a><span>|</span><label class="collapse" for="c-40127463">[-]</label><label class="expand" for="c-40127463">[8 more]</label></div><br/><div class="children"><div class="content">.NET 4.6 to .NET 8 is a 10x &quot;average&quot; performance improvement.  I find this hard to believe.  In what scenarios?  I tried to Google for it and found very little hard evidence.</div><br/><div id="40127673" class="c"><input type="checkbox" id="c-40127673" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40127463">parent</a><span>|</span><a href="#40117566">next</a><span>|</span><label class="collapse" for="c-40127673">[-]</label><label class="expand" for="c-40127673">[7 more]</label></div><br/><div class="children"><div class="content">In general purpose scenarios, particularly in codebases which have high amount of abstractions, use ASP.NET Core and EF Core, parse and de&#x2F;serialize text with the use of JSON, Regex and other options, have network and file IO, and are deployed on many-core hosts&#x2F;container images.<p>There are a few articles on msft devblogs that cover from-netframework migration to older versions (Core 3.1, 5&#x2F;6&#x2F;7):<p>- <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;bing-ads-campaign-platform-journey-to-dotnet-6&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;bing-ads-campaign-plat...</a><p>- <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;microsoft-graph-dotnet-6-journey&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;microsoft-graph-dotnet...</a><p>- <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;the-azure-cosmos-db-journey-to-net-6&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;the-azure-cosmos-db-jo...</a><p>- <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;one-service-journey-to-dotnet-6&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;one-service-journey-to...</a><p>- <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;microsoft-commerce-dotnet-6-migration-journey&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;microsoft-commerce-dot...</a><p>The tl;dr is depending on codebase the latency reduction was anywhere from 2x to 6x, varying per percentile, or the RPS was maintained with CPU usage dropping by ~2-6x.<p>Now, these are codebases of likely above average quality.<p>If you consider that moving 6 -&gt; 8 yields another up to 15-30% on average through improved and enabled by default DynamicPGO, and if you also consider that the average codebase is of worse quality than whatever msft has, meaning that DPGO-reliant optimizations scale way better, it is not difficult to see the 10x number.<p>Keep in mind that while particular regular piece of enterprise code could have improved within bounds of &quot;poor netfx codegen&quot; -&gt; &quot;not far from LLVM with FLTO and PGO&quot;, the bottlenecks have changed significantly where previously they could have been in lock contention (within GC or user code), object allocation, object memory copying, e.g. for financial domains - anything including possibly complex Regex queries on imported payment reports (these alone have now difference anywhere between 2 and &gt;1000[0]), and for pretty much every code base also in interface&#x2F;virtual dispatch for layers upon layers of &quot;clean architecture&quot; solutions.<p>The vast majority of performance improvements (both compiler+gc and CoreLib+frameworks), which is difficult to think about, given it was 8 years, address the above first and foremost. At my previous employer the migration from NETFX 4.6 to .NET Core 3.1, while also deploying to much more constrained container images compared to beefy Windows Server hosts, reduced latency of most requests by the same factor of &gt;5x (certain request type went from 2s to 350ms). It was my first wow moment when I decided to stay with .NET rather than move over to Go back then (was never a fan of syntax though, and other issues, which subsequently got fixed in .NET, that Go still has, are not tolerable for me).<p>[0] Cumulative of<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;regex-performance-improvements-in-net-5&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;regex-performance-impr...</a><p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;regular-expression-improvements-in-dotnet-7&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;regular-expression-imp...</a><p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvements-in-net-8&#x2F;#regex" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;dotnet&#x2F;performance-improvemen...</a></div><br/><div id="40128327" class="c"><input type="checkbox" id="c-40128327" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40127673">parent</a><span>|</span><a href="#40117566">next</a><span>|</span><label class="collapse" for="c-40128327">[-]</label><label class="expand" for="c-40128327">[6 more]</label></div><br/><div class="children"><div class="content">Cheating.<p>All of the 6x performance improvement cases seem to be related to using the .net based Kestrel web server instead of IIS web server, which requires marshalling and interprocess communication. Several of the 2x gains appear to be related to using a different database backend. Claims that regex performance has improved a thousand-fold.... seem more troubling than cause for celebration. Were you not precompiling your regex&#x27;s in the older code? That would be a bug.<p>Somewhere in there, there might be 30% improvements in .net codegen (it&#x27;s hard to tell). Profile Guided Optimization (PGO) seems to provide a 35% performance improvement over older versions of .net with PGO disabled. But that&#x27;s dishonest. PGO was around long before .net Core. And claiming that PGO will provide 10x performance because our code is worse than Microsoft&#x27;s code insults both our code and our intelligence.</div><br/><div id="40128705" class="c"><input type="checkbox" id="c-40128705" checked=""/><div class="controls bullet"><span class="by">ygra</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40128327">parent</a><span>|</span><a href="#40128834">next</a><span>|</span><label class="collapse" for="c-40128705">[-]</label><label class="expand" for="c-40128705">[4 more]</label></div><br/><div class="children"><div class="content">Not sure about the 10Ã, either, and if true it would involve more than just the JIT changes. But changing ASP.NET to ASP.NET Core at the same time and the web server as well as other libraries may make it plausible. For certain applications moving from .NET Framework to .NET isn&#x27;t so simple when they have dependencies and those have changed their API significantly. And in that case most of the newer stuff seems to be built with performance in mind. So you gain 30 % from the JIT, 2Ã from Kestrel, and so on. Perhaps.<p>With a Roslyn-based compiler at work I saw 20 % perf improvement just by switching from .NET Core 3.1 to .NET 6. No idea how slow .NET Framework was, though. I probably can&#x27;t target the code to that anymore.<p>But for regex even with precompilation, the compiler got a lot better at transforming the regex into an equivalent regex that performs better (automatic atomic grouping to reduce unnecessary backtracking when it&#x27;s statically known that backtracking won&#x27;t create more matches for example) and it also benefits a lot from the various vectorized implementations of Index of, etc. Typically with each improvement of one of those core methods for searching stuff in memory there&#x27;s a corresponding change that uses them in regex.<p>So where in .NET Framework a regex might walk through a whole string character by character multiple times with backtracking it might be replaced with effectively an EndsWith and LastIndexOfAny call in newer versions.</div><br/><div id="40129123" class="c"><input type="checkbox" id="c-40129123" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40128705">parent</a><span>|</span><a href="#40128834">next</a><span>|</span><label class="collapse" for="c-40129123">[-]</label><label class="expand" for="c-40129123">[3 more]</label></div><br/><div class="children"><div class="content">Roslyn didn&#x27;t have much of changes in terms of optimizations - it compiles C# to IL so does very little of that, save for switches and certain new or otherwise features like collection literals. You are probably talking about RyuJIT, also called just JIT nowadays :D<p>(the distinction becomes important for targets serviced by Mono, so to outline the difference Mono is usually specified, while CoreCLR and RyuJIT may not be, it also doesn&#x27;t help that JIT, that is, the IL to machine code compiler, also services NativeAOT, so it gets more annoying to be accurate in a conversation without saying the generic &quot;.net compiler&quot;, some people refer to it as JIT&#x2F;ILC)</div><br/><div id="40129570" class="c"><input type="checkbox" id="c-40129570" checked=""/><div class="controls bullet"><span class="by">ygra</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40129123">parent</a><span>|</span><a href="#40128834">next</a><span>|</span><label class="collapse" for="c-40129570">[-]</label><label class="expand" for="c-40129570">[2 more]</label></div><br/><div class="children"><div class="content">No, I meant that we&#x27;ve written a compiler, based on Roslyn, whose runtime for compiling the code has improved by 20 % when switching to .NET 6.<p>And indeed, on the C# -&gt; IL side there&#x27;s little that&#x27;s being actually optimized. Besides collection literals there&#x27;s also switch statements&#x2F;expressions over strings, along with certain pattern matching constructs that get improved on that side.</div><br/><div id="40129585" class="c"><input type="checkbox" id="c-40129585" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40129570">parent</a><span>|</span><a href="#40128834">next</a><span>|</span><label class="collapse" for="c-40129585">[-]</label><label class="expand" for="c-40129585">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! (I was way off the mark, not reading carefully, ha)<p>Is it a public project?</div><br/></div></div></div></div></div></div></div></div><div id="40128834" class="c"><input type="checkbox" id="c-40128834" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40128327">parent</a><span>|</span><a href="#40128705">prev</a><span>|</span><a href="#40117566">next</a><span>|</span><label class="collapse" for="c-40128834">[-]</label><label class="expand" for="c-40128834">[1 more]</label></div><br/><div class="children"><div class="content">No. <i>Dynamic</i>PGO was first introduced in .NET 6 but was not mature and needed two releases worth of work to become enabled by default. It needs no user input and is similar to what OpenJDK Hotspot has been doing for some time and then a little more. It also is required for major features that were strictly not available previously: guarded devirtualization of virtual and interface calls and delegate inlining.<p>Also, IIS hosting through Http.sys is still an option that sees separate set of improvements, but that&#x27;s not relevant in most situations given the move to .NET 8 from Framework usually also involves replacing Windows Server host with a Linux container (though it works perfectly fine on Windows as well).<p>On Regex, compiled and now source generated automata has seen <i>a lot</i> of work in all recent releases, it is night and day to what it was before - just read the articles. Previously linear scans against heavy internal data structures (matching by hashset) and heavy transient allocations got replaced with bloom-filter style SIMD search and other state of the art text search algorithms[0], on a completely opposite end of a performance spectrum.<p>So when you have compiler improvements multiplied by changes to CoreLib internals multiplied by changes to frameworks built on top - it&#x27;s achievable with relative ease. .NET Framework, while performing adequately, was still <i>that</i> slow compared to what we got today.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;tree&#x2F;main&#x2F;src&#x2F;libraries&#x2F;System.Private.CoreLib&#x2F;src&#x2F;System&#x2F;SearchValues&#x2F;Strings&#x2F;Helpers">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;tree&#x2F;main&#x2F;src&#x2F;libraries&#x2F;Sy...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40117566" class="c"><input type="checkbox" id="c-40117566" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40118212">prev</a><span>|</span><a href="#40117587">next</a><span>|</span><label class="collapse" for="c-40117566">[-]</label><label class="expand" for="c-40117566">[20 more]</label></div><br/><div class="children"><div class="content">In my opinion, the only things that really matter are algorithmic complexity and readability.  And even algorithmic complexity is usually only an issue a certain scales.  Whether or not an &#x27;if&#x27; is faster than a &#x27;switch&#x27; is the micro of micro optimizations -- you better have a good reason to care.  The question I would have for you is was your bunch of ifs more readable than a switch would be.</div><br/><div id="40129931" class="c"><input type="checkbox" id="c-40129931" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117566">parent</a><span>|</span><a href="#40117773">next</a><span>|</span><label class="collapse" for="c-40129931">[-]</label><label class="expand" for="c-40129931">[1 more]</label></div><br/><div class="children"><div class="content">... really matter are algorithmic complexity ...<p>This is not entirely true either... Measure. There are many cases where the optimiser will vectorise a certian algorithm but not another... In many cases On^2 vectorised may be significantly faster than On or Onlogn even for very large datasets depending on your data...<p>Make your algorithms generic and it won&#x27;t matter which one you use, if you find that one is slower swap it for the quicker one. Depending on CPU arch and compiler optimisations the fastest algorithm may actually change multiple times in a codebases lifetime even if the usage pattern doesn&#x27;t change at all.</div><br/></div></div><div id="40117773" class="c"><input type="checkbox" id="c-40117773" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117566">parent</a><span>|</span><a href="#40129931">prev</a><span>|</span><a href="#40117620">next</a><span>|</span><label class="collapse" for="c-40117773">[-]</label><label class="expand" for="c-40117773">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and it&#x27;s not like I didn&#x27;t know how to do the stuff I was doing with a switch, I just don&#x27;t like switches because I&#x27;ve forgotten to add break statements and had code that appeared correct but actually a month down the line. I&#x27;ve also seen other people make the same mistakes. ifs, in my opinion at least, are a bit harder to screw up, so I will always prefer them.<p>But I agree, algorithmic complexity is generally the only thing I focus on, and even then it&#x27;s almost always a case of &quot;will that actually matter?&quot;  If I know that `n` is never going to be more than like `10`, I might not bother trying to optimize an O(n^2) operation.<p>What I feel often gets ignored in these conversations is latency; people obsess over some &quot;optimization&quot; they learned in college a decade ago, and ignore the 200 HTTP or Redis calls being made ten lines below, despite the fact that the latter will have a substantially higher impact on performance.</div><br/></div></div><div id="40117620" class="c"><input type="checkbox" id="c-40117620" checked=""/><div class="controls bullet"><span class="by">doctor_phil</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117566">parent</a><span>|</span><a href="#40117773">prev</a><span>|</span><a href="#40117587">next</a><span>|</span><label class="collapse" for="c-40117620">[-]</label><label class="expand" for="c-40117620">[17 more]</label></div><br/><div class="children"><div class="content">But a switch and an if-else *is* a matter of algorithmic complexity. (Well, at least could be for a naive compiler). A switch could be converted to a constant time jump, but the if-else would be trying each case linearly.</div><br/><div id="40119451" class="c"><input type="checkbox" id="c-40119451" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117620">parent</a><span>|</span><a href="#40117855">next</a><span>|</span><label class="collapse" for="c-40119451">[-]</label><label class="expand" for="c-40119451">[1 more]</label></div><br/><div class="children"><div class="content">But what if, and stick with me here, a compiler is capable of reading and processing your code and through simple scalar evolution of the conditionals and phi-reduction, it can&#x27;t tell the difference between a switch statement and a sequence of if statements by the time it finishes its single static analysis phase?<p>It turns out the algorithmic complexity of a switch statement and the equivalent series of if-statements is identical. The bijective mapping between them is close to the identity function. Does a naive compiler exist that doesn&#x27;t emit the same instructions for both, at least outside of toy hobby project compilers written by amateurs with no experience?</div><br/></div></div><div id="40117855" class="c"><input type="checkbox" id="c-40117855" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117620">parent</a><span>|</span><a href="#40119451">prev</a><span>|</span><a href="#40129650">next</a><span>|</span><label class="collapse" for="c-40117855">[-]</label><label class="expand" for="c-40117855">[1 more]</label></div><br/><div class="children"><div class="content">While I personally find the if statements harder to immediately mentally parse&#x2F;grok--as I have to prove to myself that they are all using the same variable and are all chained correctly in a way that is visually obvious for the switch statement--I don&#x27;t find &quot;but what if we use a naive compiler&quot; at all a useful argument to make as, well, we aren&#x27;t using a naive compiler, and, if we were, there are a ton of other things we are going to be sad about the performance of leading us down a path of re-implementing a number of other optimizations. The goal of the compiler is to shift computational complexity from runtime to compile time, and figuring out whether the switch table or the comparisons are the right approach seems like a legitimate use case (which maybe we have to sometimes disable, but probably only very rarely).</div><br/></div></div><div id="40129650" class="c"><input type="checkbox" id="c-40129650" checked=""/><div class="controls bullet"><span class="by">Gazoche</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117620">parent</a><span>|</span><a href="#40117855">prev</a><span>|</span><a href="#40128361">next</a><span>|</span><label class="collapse" for="c-40129650">[-]</label><label class="expand" for="c-40129650">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s linear with respect to the number of cases, not the size of inputs. It&#x27;s still O(1) in the sense of algorithmic complexity.</div><br/></div></div><div id="40128361" class="c"><input type="checkbox" id="c-40128361" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117620">parent</a><span>|</span><a href="#40129650">prev</a><span>|</span><a href="#40117749">next</a><span>|</span><label class="collapse" for="c-40128361">[-]</label><label class="expand" for="c-40128361">[1 more]</label></div><br/><div class="children"><div class="content">Both the switch and the if have O(1) instructions, so both are the same from an algorithmic complexity perspective.</div><br/></div></div><div id="40117749" class="c"><input type="checkbox" id="c-40117749" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117620">parent</a><span>|</span><a href="#40128361">prev</a><span>|</span><a href="#40128847">next</a><span>|</span><label class="collapse" for="c-40117749">[-]</label><label class="expand" for="c-40117749">[11 more]</label></div><br/><div class="children"><div class="content">Yup.<p>That said, the linear test is often faster due to CPU caches, which is why JITs will often convert switches to if&#x2F;elses.<p>IMO, switch is clearer in general and potentially faster (at very least the same speed) so it should be preferred when dealing with 3+ if&#x2F;elseif statements.</div><br/><div id="40117786" class="c"><input type="checkbox" id="c-40117786" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117749">parent</a><span>|</span><a href="#40118274">next</a><span>|</span><label class="collapse" for="c-40117786">[-]</label><label class="expand" for="c-40117786">[6 more]</label></div><br/><div class="children"><div class="content">Hard disagree that it&#x27;s &quot;clearer&quot;.  I have had to deal with a ton of bugs with people trying to be clever with the `break` logic, or forgetting to put `break` in there at all.<p>if statements are dumber, and maybe arguably uglier, but I feel like they&#x27;re also more clear, and people don&#x27;t try and be clever with them.</div><br/><div id="40117989" class="c"><input type="checkbox" id="c-40117989" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117786">parent</a><span>|</span><a href="#40118274">next</a><span>|</span><label class="collapse" for="c-40117989">[-]</label><label class="expand" for="c-40117989">[5 more]</label></div><br/><div class="children"><div class="content">Updates to languages (don&#x27;t know where C# is on this) have different types of switch statements that eliminate the `break` problem.<p>For example, with java there&#x27;s enhanced switch that looks like this<p><pre><code>    var val = switch(foo) {
     case 1, 2, 3 -&gt; bar;
     case 4 -&gt; baz;
     default -&gt; {
       yield bat();
     }
    }
</code></pre>
The C style switch break stuff is definitely a language mistake.</div><br/><div id="40118072" class="c"><input type="checkbox" id="c-40118072" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117989">parent</a><span>|</span><a href="#40118218">next</a><span>|</span><label class="collapse" for="c-40118072">[-]</label><label class="expand" for="c-40118072">[2 more]</label></div><br/><div class="children"><div class="content">C# has both switch expressions like this and also break statements are not optional in traditional switch statements so it actually solves both problems.  You can&#x27;t get too clever with switch statements in C#.<p>However most languages have pretty permissive switch statements just like C.</div><br/><div id="40118468" class="c"><input type="checkbox" id="c-40118468" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118072">parent</a><span>|</span><a href="#40118218">next</a><span>|</span><label class="collapse" for="c-40118468">[-]</label><label class="expand" for="c-40118468">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, fair, it&#x27;s been awhile since I&#x27;ve done any C#, so my memory is a bit hazy with the details.  I&#x27;ve been burned C with switch statements so I have a pretty strong distaste for them.</div><br/></div></div></div></div><div id="40118218" class="c"><input type="checkbox" id="c-40118218" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117989">parent</a><span>|</span><a href="#40118072">prev</a><span>|</span><a href="#40123378">next</a><span>|</span><label class="collapse" for="c-40118218">[-]</label><label class="expand" for="c-40118218">[1 more]</label></div><br/><div class="children"><div class="content">C# has switch statements which are C&#x2F;C++ style switches and switch expressions which are like Rust&#x27;s match except no control flow statements inside:<p><pre><code>    var len = slice switch
    {
        null =&gt; 0,
        &quot;Hello&quot; or &quot;World&quot; =&gt; 1,
        [&#x27;@&#x27;, ..var tags] =&gt; tags.Length,
        [&#x27;{&#x27;, ..var body, &#x27;}&#x27;] =&gt; body.Length,
        _ =&gt; slice.Length,
    };
</code></pre>
(it supports a lot more patterns but that wouldn&#x27;t fit)</div><br/></div></div><div id="40123378" class="c"><input type="checkbox" id="c-40123378" checked=""/><div class="controls bullet"><span class="by">gloryjulio</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117989">parent</a><span>|</span><a href="#40118218">prev</a><span>|</span><a href="#40118274">next</a><span>|</span><label class="collapse" for="c-40123378">[-]</label><label class="expand" for="c-40123378">[1 more]</label></div><br/><div class="children"><div class="content">This is just forcing return value. You either have to break or return at the branches. To me they all look equivalent</div><br/></div></div></div></div></div></div><div id="40118274" class="c"><input type="checkbox" id="c-40118274" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117749">parent</a><span>|</span><a href="#40117786">prev</a><span>|</span><a href="#40128847">next</a><span>|</span><label class="collapse" for="c-40118274">[-]</label><label class="expand" for="c-40118274">[4 more]</label></div><br/><div class="children"><div class="content">Any sufficiently advanced compiler will rewrite those arbitrarily depending on its heuristics. What authors usually forget is that there is defined behavior and specification which the compiler abides by, but it is otherwise free to produce any codegen that preserves the defined program order. Branch reordering, generating jump tables, optimizing away or coalescing checks into branchless forms are all very common. When someone says &quot;oh I write C because it lets you tell CPU how exactly to execute the code&quot; is simply a sign that a person never actually looked at disassembly and has little to no idea how the tool they use works.</div><br/><div id="40118787" class="c"><input type="checkbox" id="c-40118787" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118274">parent</a><span>|</span><a href="#40128847">next</a><span>|</span><label class="collapse" for="c-40118787">[-]</label><label class="expand" for="c-40118787">[3 more]</label></div><br/><div class="children"><div class="content">A complier will definitely try this, but it&#x27;s important to note that if&#x2F;else blocks tell the compiler that &quot;you will run these evaluations in order&quot;.  Now, if the compiler can detect that the evaluations have no side effects (which, in this simple example with just integer checks, is fairly likely) then yeah I can see a jump table getting shoved in as an optimization.<p>However, the moment you add a side effect or something more complicated like a method call, it becomes really hard for the complier to know if that sort of optimization is safe to do.<p>The benefit of the switch statement is that it&#x27;s already well positioned for the compiler to optimize as it does not have the &quot;you must run these evaluations in order&quot; requirement.  It forces you to write code that is fairly compiler friendly.<p>All that said, probably a waste of time debating :D.  Ideally you have profiled your code and the profiler has told you &quot;this is the slow block&quot; before you get to the point of worrying about how to make it faster.</div><br/><div id="40119437" class="c"><input type="checkbox" id="c-40119437" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118787">parent</a><span>|</span><a href="#40128847">next</a><span>|</span><label class="collapse" for="c-40119437">[-]</label><label class="expand" for="c-40119437">[2 more]</label></div><br/><div class="children"><div class="content">I agree with what you said but in this particular case, it actually was a direct integer equality check, there was zero risk of hitting side effects and that was plainly obvious to me, the checker, and compiler.</div><br/><div id="40119664" class="c"><input type="checkbox" id="c-40119664" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40119437">parent</a><span>|</span><a href="#40128847">next</a><span>|</span><label class="collapse" for="c-40119664">[-]</label><label class="expand" for="c-40119664">[1 more]</label></div><br/><div class="children"><div class="content">And to your original comment, I think the reviewer was wrong to reject the PR over that.  Performance has to be measured before you can use it to reject (or create...) a PR.   If someone hasn&#x27;t done that then unless it&#x27;s something obvious like &quot;You are making a ton of tiny heap allocations in a tight loop&quot; then I think nitpicking these sorts of things is just wrong.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40128847" class="c"><input type="checkbox" id="c-40128847" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117620">parent</a><span>|</span><a href="#40117749">prev</a><span>|</span><a href="#40117587">next</a><span>|</span><label class="collapse" for="c-40128847">[-]</label><label class="expand" for="c-40128847">[1 more]</label></div><br/><div class="children"><div class="content">Unless the number of &quot;else if&quot; statements somehow grows e.g. linearly with the size of your input, which isn&#x27;t plausible, the &quot;else if&quot; statements also execute in O(1) time.</div><br/></div></div></div></div></div></div><div id="40117587" class="c"><input type="checkbox" id="c-40117587" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40117566">prev</a><span>|</span><a href="#40117562">next</a><span>|</span><label class="collapse" for="c-40117587">[-]</label><label class="expand" for="c-40117587">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But there&#x27;s tons of this stuff like this in CS<p>Reminds me of the classic <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;24848359&#x2F;which-is-faster-while1-or-while2" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;24848359&#x2F;which-is-faster...</a></div><br/><div id="40117823" class="c"><input type="checkbox" id="c-40117823" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117587">parent</a><span>|</span><a href="#40117562">next</a><span>|</span><label class="collapse" for="c-40117823">[-]</label><label class="expand" for="c-40117823">[1 more]</label></div><br/><div class="children"><div class="content">Never saw that before, that is indeed a classic.</div><br/></div></div></div></div><div id="40117562" class="c"><input type="checkbox" id="c-40117562" checked=""/><div class="controls bullet"><span class="by">BurningFrog</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40117587">prev</a><span>|</span><a href="#40119643">next</a><span>|</span><label class="collapse" for="c-40117562">[-]</label><label class="expand" for="c-40117562">[13 more]</label></div><br/><div class="children"><div class="content">Even if one of these constructs is faster <i>it doesn&#x27;t matter</i> 99% of the time.<p>Writing well structured readable code is typically far more important than making it twice as fast. And those times can rarely be predicted beforehand, so you should mostly not worry about it until you see real performance problems.</div><br/><div id="40117722" class="c"><input type="checkbox" id="c-40117722" checked=""/><div class="controls bullet"><span class="by">apantel</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117562">parent</a><span>|</span><a href="#40117692">next</a><span>|</span><label class="collapse" for="c-40117722">[-]</label><label class="expand" for="c-40117722">[9 more]</label></div><br/><div class="children"><div class="content">The counter-argument to this is if you are building something that is in the critical path of an application (for example, parsing HTTP in a web server), you need to be performance-minded from the beginning because design decisions lead to design decisions.  If you are building something in the critical path of the application, the best thing to do is build it from the ground up measuring the performance of what you have as you go.  This way, each time you add something you will see the performance impact and usually thereâs a more performant way of doing something that isnât more obscure.  If you do this as you build, early choices become constraints, but because you chose the most performant thing at every stage, the whole process takes you in the direction of a highly-performant implementation.<p>Why should you care about performance?<p>I can give you my personal experience: Iâve been working on a Java web&#x2F;application server for the past 15 years and a typical request (only reading, not writing to the db) would take maybe 4-5 ms to execute.  That includes HTTP request parsing, JSON parsing, session validation, method execution, JSON serialization, and HTTP response dispatch.  Over the past 9 months I have refactored the entire application for performance and a typical request now takes about 0.25 ms or 250 microseconds.  The computer is doing so much less work to accomplish the same tasks, itâs almost silly how much work it was doing before.  And the result is the machine can handle 20x more requests in the same amount of time.  If it could handle 200 requests per second per core before, now it can handle 4000.  That means the need to scale is felt 20x less intensely, which means less complexity around scaling.<p>High performance means reduced scaling requirements.</div><br/><div id="40117844" class="c"><input type="checkbox" id="c-40117844" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117722">parent</a><span>|</span><a href="#40118567">next</a><span>|</span><label class="collapse" for="c-40117844">[-]</label><label class="expand" for="c-40117844">[6 more]</label></div><br/><div class="children"><div class="content">But even that sort of depends right?  Hardware is often pretty cheap in comparison to dev-time. I really depends on the project, what kind of servers you&#x27;re using, the nature of the application etc, but I think a lot of the time it might be cheaper to just pay for 20x the servers than it would be to pay a human to go find a critical path.<p>I&#x27;m not saying you completely throw caution to the wind, I&#x27;m just saying that there&#x27;s a finite amount of human resources and it can really vary how you want to allocate them.  Sometimes the better path is to just throw money at the problem.<p>It really depends.</div><br/><div id="40118961" class="c"><input type="checkbox" id="c-40118961" checked=""/><div class="controls bullet"><span class="by">apantel</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117844">parent</a><span>|</span><a href="#40120781">next</a><span>|</span><label class="collapse" for="c-40118961">[-]</label><label class="expand" for="c-40118961">[4 more]</label></div><br/><div class="children"><div class="content">I think it depends on what youâre building and whoâs building it.  Weâre all benefitting from the fact that the designers of NGINX made performance a priority.  We like using things that were designed to be performant.  We like high-FPS games.  We like fast internet.<p>I personally donât like the idea of throwing compute at a slow solution.  I like when the extra effort has been put into something.  The good feeling I get from interacting with something that is optimal or excellent is an end in itself and one of the things I live for.</div><br/><div id="40119287" class="c"><input type="checkbox" id="c-40119287" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118961">parent</a><span>|</span><a href="#40120781">next</a><span>|</span><label class="collapse" for="c-40119287">[-]</label><label class="expand" for="c-40119287">[3 more]</label></div><br/><div class="children"><div class="content">Sure, though I&#x27;ve mentioned a few times in this thread now that the thing that bothers me more than CPU optimizations is not taking into account latency, particularly when hitting the network, and I think focusing on that will generally pay higher dividends than trying to optimize for processing.<p>CPUs are ridiculously fast now, and compilers are really really good now too.  I&#x27;m not going to say that processing speed is a &quot;solved&quot; problem, but I am going to say that in a lot of performance-related cases the CPU processing is probably not your problem.  I will admit that this kind of pokes holes in my previous response, because introducing more machines into the mix will almost certainly increase latency, but I think it more or less holds depending on context.<p>But I think it really is a matter of nuance, which you hinted at.  If I&#x27;m making an admin screen that&#x27;s going to have like a dozen users max, then a slow, crappy solution is probably fine; the requests will be served fast enough to where no one will notice anyway, and you can probably even get away with the cheapest machine&#x2F;VM.  If I&#x27;m making an FPS game that has 100,000 concurrent users, then it almost certainly will be beneficial to squeeze out as much performance out of the machine as possible, both CPU <i>and</i> latency-wise.<p>But as I keep repeating everywhere, you have to measure. You cannot assume that your intuition is going to be right, particularly at-scale.</div><br/><div id="40119491" class="c"><input type="checkbox" id="c-40119491" checked=""/><div class="controls bullet"><span class="by">apantel</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40119287">parent</a><span>|</span><a href="#40119482">next</a><span>|</span><label class="collapse" for="c-40119491">[-]</label><label class="expand" for="c-40119491">[1 more]</label></div><br/><div class="children"><div class="content">I absolutely agree that latency is the real thing to optimize for.  In my case, I only leave the application to access the db, and my applications tend not to be write-heavy.  So in my case latency-per-request == how much work the computer has to do, which is constrained to one core because the overhead of parallelizing any part of the pipeline is greater than the work required.  See, in that sense, weâre already close to the performance ceiling for per-request processing because clock speeds arenât going up.  You canât make the processing of a given request faster by throwing more hardware at it.  You can only make it faster by creating less work for the hardware to do.<p>(Ironically, HN is buckling under load right now, or some other issue.)</div><br/></div></div></div></div></div></div><div id="40120781" class="c"><input type="checkbox" id="c-40120781" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117844">parent</a><span>|</span><a href="#40118961">prev</a><span>|</span><a href="#40118567">next</a><span>|</span><label class="collapse" for="c-40120781">[-]</label><label class="expand" for="c-40120781">[1 more]</label></div><br/><div class="children"><div class="content">It almost certainly would require more than 20x servers because setting up horizontal scaling will have some sort of overhead. Not only that, there is the significant engineering effort to develop and maintain the code to scale.<p>If your problem can fit on one server, it can massively reduce engineering and infrastructure costs.</div><br/></div></div></div></div><div id="40118567" class="c"><input type="checkbox" id="c-40118567" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117722">parent</a><span>|</span><a href="#40117844">prev</a><span>|</span><a href="#40117692">next</a><span>|</span><label class="collapse" for="c-40118567">[-]</label><label class="expand" for="c-40118567">[2 more]</label></div><br/><div class="children"><div class="content">Please accept a high five from a fellow &quot;it does so little work it must have sub-millisecond request latency&quot; aficionado (though I must admit I&#x27;m guilty of abusing memory caches to achieve this).</div><br/><div id="40119889" class="c"><input type="checkbox" id="c-40119889" checked=""/><div class="controls bullet"><span class="by">apantel</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118567">parent</a><span>|</span><a href="#40117692">next</a><span>|</span><label class="collapse" for="c-40119889">[-]</label><label class="expand" for="c-40119889">[1 more]</label></div><br/><div class="children"><div class="content">Caches, precomputed values, lookup tables â itâs all good as long as itâs well-organized and maintainable.</div><br/></div></div></div></div></div></div><div id="40117692" class="c"><input type="checkbox" id="c-40117692" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117562">parent</a><span>|</span><a href="#40117722">prev</a><span>|</span><a href="#40118001">next</a><span>|</span><label class="collapse" for="c-40117692">[-]</label><label class="expand" for="c-40117692">[1 more]</label></div><br/><div class="children"><div class="content">I mostly focus on &quot;using stuff that won&#x27;t break&quot;, and yeah &quot;if it actually matters&quot;.<p>For example, much to the annoyance of a lot of people, I don&#x27;t typically use floating point numbers when I start out.  I will use the &quot;decimal&quot; or &quot;money&quot; types of the language, or GMP if I&#x27;m using C.  When I do that, I can be sure that I won&#x27;t have to worry about any kind of funky overflow issues or bizarre rounding problems.  There <i>might</i> be a performance overhead associated with it, but then I have to ask myself &quot;how often is this actually called?&quot;<p>If the answer is &quot;a billion times&quot; or &quot;once in every iteration of the event loop&quot; or something, then I will probably eventually go back and figure out if I can use a float or convert it to an integer-based thing, but in a lot of cases the answer is &quot;like ten or twenty times&quot;, and at that point I&#x27;m not even 100% sure it would be even measurable to change to the &quot;faster&quot; implementations.<p>What annoys me is that people will act like they really care about speed, do all these annoying micro-optimizations, and then forget that pretty much all of them get wiped out immediately upon hitting the network, since the latency associated with that is obscene.</div><br/></div></div><div id="40118001" class="c"><input type="checkbox" id="c-40118001" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117562">parent</a><span>|</span><a href="#40117692">prev</a><span>|</span><a href="#40119643">next</a><span>|</span><label class="collapse" for="c-40118001">[-]</label><label class="expand" for="c-40118001">[2 more]</label></div><br/><div class="children"><div class="content">This attitude is part of the problem. Another part of the problem is having no idea which things actually end up costing performance and how much.<p>It is why many language ecosystems suffered from performance issues for a really long time even if completely unwarranted.<p>Is changing ifs to switch or vice versa, as outlined in the post above, a waste of time? Yes, unless you are writing some encoding algorithm or a parser, it will not matter. The compiler will lower trivial statements to the same codegen and it will not impact the resulting performance anyway even if there was difference given a problem the code was solving.<p>However, there are things that <i>do</i> cost like interface spam, abusing lambdas writing needlessly complex wokflow-style patterns (which are also less readable and worse in 8 out of 10 instances), not caching objects that always have the same value, etc.<p>These kinds of issues, for example, plagued .NET ecosystem until more recent culture shift where it started to be cool once again to focus on performance. It wasn&#x27;t being helped by the notion of &quot;well-structured code&quot; being just idiotic &quot;clean architecture&quot; and &quot;GoF patterns&quot; style dogma applied to smallest applications and simplest of business domains.<p>(it is also the reason why picking slow languages in general is a really bad idea - <i>everything</i> costs more and you have way less leeway for no productivity win - Ruby and Python, and JS with Node.js are less productive to write in than C#&#x2F;F#, Kotlin&#x2F;Java or Go(under some conditions))</div><br/><div id="40118962" class="c"><input type="checkbox" id="c-40118962" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40118001">parent</a><span>|</span><a href="#40119643">next</a><span>|</span><label class="collapse" for="c-40118962">[-]</label><label class="expand" for="c-40118962">[1 more]</label></div><br/><div class="children"><div class="content">I mean, that&#x27;s kind of why I tried to emphasize measuring things yourself instead of depending on tribal knowledge.<p>There are plenty of cases where even the &quot;slow&quot; implementation is more than fast enough, and there are also plenty of cases where the &quot;correct&quot; solution (from a big-O or intuition perspective) is actually slower than the dumb case.  Intuition <i>helps</i>, you <i>have</i> to measure and&#x2F;or look at the compiled results if you want to ensure correct numbers.<p>An example that really annoys me is how every whiteboard interview ends up being &quot;interesting ways to use a hashmap&quot;, which isn&#x27;t inherently an issue, but they will usually be so small-scoped that an iterative &quot;array of pairs&quot; might actually be cheaper than paying the up-front cost of hashing and potentially dealing with collisions. Interviews almost always ignore constant factors, and that&#x27;s fair enough, but in reality constant factors <i>can</i> matter, and we&#x27;re training future employees to ignore that.<p>I&#x27;ll say it again: as far as I can tell, you <i>have</i> to measure if you want to know if your result is &quot;faster&quot;. &quot;Measuring&quot; might involve memory profilers, or dumb timers, or a mixture of both.  Gut instincts are often wrong.</div><br/></div></div></div></div></div></div><div id="40119643" class="c"><input type="checkbox" id="c-40119643" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40117562">prev</a><span>|</span><a href="#40117564">next</a><span>|</span><label class="collapse" for="c-40119643">[-]</label><label class="expand" for="c-40119643">[4 more]</label></div><br/><div class="children"><div class="content">&gt; A large part of becoming a decent engineer [2] for me was learning to stop trusting what professors taught me in college<p>When I was taught about performance, it was all about benchmarking and profiling.  I never needed to trust what my professors taught, because they taught me to dig in and find the truth for myself.  This was taught alongside the big-O stuff, with several examples where &quot;fast&quot; algorithms are slower on small inputs.</div><br/><div id="40119718" class="c"><input type="checkbox" id="c-40119718" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40119643">parent</a><span>|</span><a href="#40117564">next</a><span>|</span><label class="collapse" for="c-40119718">[-]</label><label class="expand" for="c-40119718">[3 more]</label></div><br/><div class="children"><div class="content">How do you even get meaningful profiling out of most modern langs? It seems the vast majority of time and calls gets spent inside tiny anonymous functions, GC allocations, and stuff like that.</div><br/><div id="40120880" class="c"><input type="checkbox" id="c-40120880" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40119718">parent</a><span>|</span><a href="#40123459">next</a><span>|</span><label class="collapse" for="c-40120880">[-]</label><label class="expand" for="c-40120880">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use most modern langs!  And especially if I&#x27;m doing work where performance is critical, I won&#x27;t kneecap myself by using a language that I can&#x27;t reasonably profile.</div><br/></div></div><div id="40123459" class="c"><input type="checkbox" id="c-40123459" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40119718">parent</a><span>|</span><a href="#40120880">prev</a><span>|</span><a href="#40117564">next</a><span>|</span><label class="collapse" for="c-40123459">[-]</label><label class="expand" for="c-40123459">[1 more]</label></div><br/><div class="children"><div class="content">This is easy in most modern programming languages.<p>JVM ecosystem has IntelliJ Idea profiler and similar advanced tools (AFAIK).<p>.NET has VS&#x2F;Rider&#x2F;dotnet-trace profilers (they are very detailed) to produce flamegraphs.<p>Then there are native profilers which can work with any AOT compiled language that produces canonically symbolicated binaries: Rust, C#&#x2F;F#(AOT mode), Go, Swift, C++, etc.<p>For example, you can do `samply record .&#x2F;some_binary`[0] and then explore multi-threaded flamegraph once completed (I use it to profile C#, it&#x27;s more convenient than dotTrace for preliminary perf work and is usually more than sufficient).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;mstange&#x2F;samply">https:&#x2F;&#x2F;github.com&#x2F;mstange&#x2F;samply</a></div><br/></div></div></div></div></div></div><div id="40117564" class="c"><input type="checkbox" id="c-40117564" checked=""/><div class="controls bullet"><span class="by">leetcrew</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40119643">prev</a><span>|</span><a href="#40117660">next</a><span>|</span><label class="collapse" for="c-40117564">[-]</label><label class="expand" for="c-40117564">[1 more]</label></div><br/><div class="children"><div class="content">agreed, especially in cases like this. final is primarily a way to prohibit overriding methods and extending classes, and it indicates to the reader that they should not be doing this. use it when it makes conceptual sense.<p>that said, c++ is usually a language you use when you care about performance, at least to an extent. it&#x27;s worth understanding features like nrvo and rewriting functions to allow the compiler to pick the optimization if it doesn&#x27;t hurt readability too much.</div><br/></div></div><div id="40117660" class="c"><input type="checkbox" id="c-40117660" checked=""/><div class="controls bullet"><span class="by">jollyllama</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40117564">prev</a><span>|</span><a href="#40121250">next</a><span>|</span><label class="collapse" for="c-40117660">[-]</label><label class="expand" for="c-40117660">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve encountered similar situations before. It&#x27;s insane to me when people hold up PRs over that kind of thing.</div><br/></div></div><div id="40121250" class="c"><input type="checkbox" id="c-40121250" checked=""/><div class="controls bullet"><span class="by">zmj</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40117660">prev</a><span>|</span><a href="#40120062">next</a><span>|</span><label class="collapse" for="c-40121250">[-]</label><label class="expand" for="c-40121250">[1 more]</label></div><br/><div class="children"><div class="content">.NET is a little smarter about switch code generation these days: <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;roslyn&#x2F;pull&#x2F;66081">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;roslyn&#x2F;pull&#x2F;66081</a></div><br/></div></div><div id="40120062" class="c"><input type="checkbox" id="c-40120062" checked=""/><div class="controls bullet"><span class="by">trueismywork</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40121250">prev</a><span>|</span><a href="#40127794">next</a><span>|</span><label class="collapse" for="c-40120062">[-]</label><label class="expand" for="c-40120062">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s not yet a culture of writing reproducible benchmarks to gage these effects.</div><br/></div></div><div id="40127794" class="c"><input type="checkbox" id="c-40127794" checked=""/><div class="controls bullet"><span class="by">mynameisnoone</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40120062">prev</a><span>|</span><a href="#40126968">next</a><span>|</span><label class="collapse" for="c-40127794">[-]</label><label class="expand" for="c-40127794">[2 more]</label></div><br/><div class="children"><div class="content">Yep. &quot;Profiling or it didn&#x27;t happen.&quot; The issue is that it&#x27;s essentially impossible for even the most neckbeard of us to predict with a high degree of accuracy and precision the performance on modern systems impact of change A vs. change B due to the unpredictable nature of the many variables that are difficult to control including compiler optimization passes, architecture gotchas (caches, branch misses), and interplay of quirks on various platforms. Therefore, irreducible and necessary work to profile the differences become the primary viable path to resolving engineering decision points. Hopefully, LLMs now and in the future will be able to help build out boilerplate roughly in the direct of creating such profiling benchmarks and fixtures.<p>PS: I&#x27;m presently revisiting C++14 because it&#x27;s the most universal statically-compiled language to quickly answer interview problems. It would be unfair to impose Rust, Go, Elixir, or Haskell on an interviewer software engineer.</div><br/><div id="40129351" class="c"><input type="checkbox" id="c-40129351" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40127794">parent</a><span>|</span><a href="#40126968">next</a><span>|</span><label class="collapse" for="c-40129351">[-]</label><label class="expand" for="c-40129351">[1 more]</label></div><br/><div class="children"><div class="content">I would say it would be safer to go up to C++17, and there are some goodies there, specially for better compile time stuff.</div><br/></div></div></div></div><div id="40126968" class="c"><input type="checkbox" id="c-40126968" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40127794">prev</a><span>|</span><a href="#40117770">next</a><span>|</span><label class="collapse" for="c-40126968">[-]</label><label class="expand" for="c-40126968">[1 more]</label></div><br/><div class="children"><div class="content">&gt; `if(x==1) elseif(x==2)...` because switch was &quot;faster&quot; and rejected my PR<p>Yeah, that&#x27;s never been true. Old compilers would often compile a switch to __slower__ code because they&#x27;d tend to always go to a jump table implementation.<p>A better reason to use the switch is because it&#x27;s better style in C-like languages. Using an if statement for that sort of thing looks like Python; it makes the code harder to maintain.</div><br/></div></div><div id="40117770" class="c"><input type="checkbox" id="c-40117770" checked=""/><div class="controls bullet"><span class="by">dosshell</span><span>|</span><a href="#40117389">parent</a><span>|</span><a href="#40126968">prev</a><span>|</span><a href="#40116940">next</a><span>|</span><label class="collapse" for="c-40117770">[-]</label><label class="expand" for="c-40117770">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I can get away with a smaller sized float<p>When talking about not assuming optimizations...<p>32bit float is slower than 64bit float on reasonable modern x86-64.<p>The reason is that 32bit float is emulated by using 64bit.<p>Of course if you have several floats you need to optimize against cache.</div><br/><div id="40119928" class="c"><input type="checkbox" id="c-40119928" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117770">parent</a><span>|</span><a href="#40117796">next</a><span>|</span><label class="collapse" for="c-40119928">[-]</label><label class="expand" for="c-40119928">[2 more]</label></div><br/><div class="children"><div class="content">Um... no. This is 100% completely and totally wrong.<p>x86-64 requires the hardware to support SSE2, which has native single-precision and double-precision instructions for floating-point (e.g., scalar multiply is MULSS and MULSD, respectively). Both the single precision and the double precision instructions will take the same time, except for DIVSS&#x2F;DIVSD, where the 32-bit float version is slightly faster (about 2 cycles latency faster, and reciprocal throughput of 3 versus 5 per Agner&#x27;s tables).<p>You might be thinking of x87 floating-point units, where all arithmetic is done internally using 80-bit floating-point types. But all x86 chips in like the last 20 years have had SSE units--which are faster anyways. Even in the days when it was the major floating-point units, it wasn&#x27;t any slower, since all floating-point operations took the same time independent of format. It might be slower if you insisted that code compilation strictly follow IEEE 754 rules, but the solution everybody did was to <i>not</i> do that and that&#x27;s why things like Java&#x27;s strictfp or C&#x27;s FLT_EVAL_METHOD were born. Even in <i>that</i> case, however, 32-bit floats would likely be faster than 64-bit for the simple fact that 32-bit floats can safely be emulated in 80-bit without fear of double rounding but 64-bit floats cannot.</div><br/><div id="40120639" class="c"><input type="checkbox" id="c-40120639" checked=""/><div class="controls bullet"><span class="by">dosshell</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40119928">parent</a><span>|</span><a href="#40117796">next</a><span>|</span><label class="collapse" for="c-40120639">[-]</label><label class="expand" for="c-40120639">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you. It should take the same time when thinking more about it. I remember learning this in ~2016 and I did performance test on Skylake which confirmed (Windows VS2015). I think I remember that i only tested with addsd&#x2F;addss. Definitely not x87. But as always, if the result can not be reproduced... I stand corrected until then.</div><br/></div></div></div></div><div id="40117796" class="c"><input type="checkbox" id="c-40117796" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117770">parent</a><span>|</span><a href="#40119928">prev</a><span>|</span><a href="#40117840">next</a><span>|</span><label class="collapse" for="c-40117796">[-]</label><label class="expand" for="c-40117796">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I clarified this in a sibling comment, but I kind of meant that I will use the slower &quot;money&quot; or &quot;decimal&quot; types by default.  Usually those are more accurate and less error-prone, and then if it actually matters I might go back to a floating point or integer-based solution.</div><br/></div></div><div id="40117840" class="c"><input type="checkbox" id="c-40117840" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117770">parent</a><span>|</span><a href="#40117796">prev</a><span>|</span><a href="#40116940">next</a><span>|</span><label class="collapse" for="c-40117840">[-]</label><label class="expand" for="c-40117840">[2 more]</label></div><br/><div class="children"><div class="content">I think this is only true if using x87 floating point, which anything computationally intensive is generally avoiding these days in favor of SSE&#x2F;AVX floats. In the latter case, for a given vector width, the cpu can process twice as many 32 bit floats as 64 bit floats per clock cycle.</div><br/><div id="40118179" class="c"><input type="checkbox" id="c-40118179" checked=""/><div class="controls bullet"><span class="by">dosshell</span><span>|</span><a href="#40117389">root</a><span>|</span><a href="#40117840">parent</a><span>|</span><a href="#40116940">next</a><span>|</span><label class="collapse" for="c-40118179">[-]</label><label class="expand" for="c-40118179">[1 more]</label></div><br/><div class="children"><div class="content">Yes, as I wrote, it is only true for one float value.<p>SIMD&#x2F;MIMD will benefit of working on smaller width. This is not only true because they do more work per clock but because memory is slow. Super slow compared to the cpu. Optimization is alot about cache misses optimization.<p>(But remember that the cache line is 64 bytes, so reading a single value smaller than that will take the same time. So it does not matter in theory when comparing one f32 against one f64)</div><br/></div></div></div></div></div></div></div></div><div id="40116940" class="c"><input type="checkbox" id="c-40116940" checked=""/><div class="controls bullet"><span class="by">andrewla</span><span>|</span><a href="#40117389">prev</a><span>|</span><a href="#40117631">next</a><span>|</span><label class="collapse" for="c-40116940">[-]</label><label class="expand" for="c-40116940">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised that it has any impact on performance at all, and I&#x27;d love to see the codegen differences between the applications.<p>Mostly the `final` keyword serves as a compile-time assertion. The compiler (sometimes linker) is perfectly capable of seeing that a class has no derived classes, but what `final` assures is that if you attempt to derive from such a class, you will raise a compile-time error.<p>This is similar to how `inline` works in practice -- rather than providing a useful hint to the compiler (though the compiler is free to treat it that way) it provides an assertion that if you do non-inlinable operations (e.g. non-tail recursion) then the compiler can flag that.<p>All of this is to say that `final` can speed up runtimes -- but it does so by forcing you to organize your code such that the guarantees apply. By using `final` classes, in places where dynamic dispatch can be reduced to static dispatch, you force the developer to not introduce patterns that would prevent static dispatch.</div><br/><div id="40129170" class="c"><input type="checkbox" id="c-40129170" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#40116940">parent</a><span>|</span><a href="#40117171">next</a><span>|</span><label class="collapse" for="c-40129170">[-]</label><label class="expand" for="c-40129170">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d love to see the codegen differences between the applications<p>There are two applications, dynamic calls and dynamic casts.<p>Dynamic casts to final classes dont require to check the whole inheritance chain. Recently done this in styx [0]. The gain may appear marginal, e.g 3 or 4 dereferences saved but in programs based on OOP you can easily have *Billions* of dynamic casts saved.<p>[0]: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;styx-lang&#x2F;styx&#x2F;-&#x2F;commit&#x2F;62c48e004d5485d4fce8e6a327ea0b67ba134b6c" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;styx-lang&#x2F;styx&#x2F;-&#x2F;commit&#x2F;62c48e004d5485d4f...</a>.</div><br/></div></div><div id="40117171" class="c"><input type="checkbox" id="c-40117171" checked=""/><div class="controls bullet"><span class="by">bgirard</span><span>|</span><a href="#40116940">parent</a><span>|</span><a href="#40129170">prev</a><span>|</span><a href="#40117277">next</a><span>|</span><label class="collapse" for="c-40117171">[-]</label><label class="expand" for="c-40117171">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The compiler (sometimes linker) is perfectly capable of seeing that a class has no derived classes<p>How? The compiler doesn&#x27;t see the full program.<p>The linker I&#x27;m less sure about. If the class isn&#x27;t guaranteed to be fully private wouldn&#x27;t an optimizing linker have to be conservative in case you inject a derived class?</div><br/></div></div><div id="40117277" class="c"><input type="checkbox" id="c-40117277" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#40116940">parent</a><span>|</span><a href="#40117171">prev</a><span>|</span><a href="#40117891">next</a><span>|</span><label class="collapse" for="c-40117277">[-]</label><label class="expand" for="c-40117277">[10 more]</label></div><br/><div class="children"><div class="content">&quot;inline&quot; is confusing in C++, as it is not really about inlining. Its purpose is to allow multiple definitions of the same function. It is useful when you have a function defined in a header file, because if included in several source files, it will be present in multiple object files, and without &quot;inline&quot; the linker will complain of multiple definitions.<p>It is also an optimization hint, but AFAIK, modern compiler ignore it.</div><br/><div id="40117580" class="c"><input type="checkbox" id="c-40117580" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40117277">parent</a><span>|</span><a href="#40128712">next</a><span>|</span><label class="collapse" for="c-40117580">[-]</label><label class="expand" for="c-40117580">[1 more]</label></div><br/><div class="children"><div class="content">GCC does not ignore inline for inlining purposes:<p>Need a way to make inlining heuristics ignore whether a function is inline 
<a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=93008" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=93008</a><p>(Bug saw a few updates recently, that&#x27;s how I remembered.)<p>As a workaround, if you need the linkage aspect of the inline keyword, you currently have to write fake templates instead. Not great.</div><br/></div></div><div id="40128712" class="c"><input type="checkbox" id="c-40128712" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40117277">parent</a><span>|</span><a href="#40117580">prev</a><span>|</span><a href="#40118207">next</a><span>|</span><label class="collapse" for="c-40128712">[-]</label><label class="expand" for="c-40128712">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  It is useful when you have a function defined in a header file, because if included in several source files, it will be present in multiple object files, and without &quot;inline&quot; the linker will complain of multiple definitions.<p>Traditionally you&#x27;d use `static` for that use case, wouldn&#x27;t you?<p>After all, `inline` can be ignored, `static` can&#x27;t.</div><br/><div id="40129358" class="c"><input type="checkbox" id="c-40129358" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40128712">parent</a><span>|</span><a href="#40118207">next</a><span>|</span><label class="collapse" for="c-40129358">[-]</label><label class="expand" for="c-40129358">[3 more]</label></div><br/><div class="children"><div class="content">No, because that would make it internal to each object file, while what you want is for all object files to see the same memory location.</div><br/><div id="40129574" class="c"><input type="checkbox" id="c-40129574" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40129358">parent</a><span>|</span><a href="#40118207">next</a><span>|</span><label class="collapse" for="c-40129574">[-]</label><label class="expand" for="c-40129574">[2 more]</label></div><br/><div class="children"><div class="content">&gt; No, because that would make it internal to each object file, while what you want is for all object files to see the same memory location.<p>I can see exactly one use for an effect like that: static variables within the function.<p>Are there any other uses?</div><br/><div id="40129701" class="c"><input type="checkbox" id="c-40129701" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40129574">parent</a><span>|</span><a href="#40118207">next</a><span>|</span><label class="collapse" for="c-40129701">[-]</label><label class="expand" for="c-40129701">[1 more]</label></div><br/><div class="children"><div class="content">Global variables and the magic of a build system based on C semantics.</div><br/></div></div></div></div></div></div></div></div><div id="40118207" class="c"><input type="checkbox" id="c-40118207" checked=""/><div class="controls bullet"><span class="by">jacoblambda</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40117277">parent</a><span>|</span><a href="#40128712">prev</a><span>|</span><a href="#40127628">next</a><span>|</span><label class="collapse" for="c-40118207">[-]</label><label class="expand" for="c-40118207">[1 more]</label></div><br/><div class="children"><div class="content">The thing with `inline` as an optimisation is that it&#x27;s not about optimising by inlining directly. It&#x27;s a promise about how you intend to use the function.<p>It&#x27;s not just &quot;you can have multiple definitions of the same function&quot; but rather a promise that the function doesn&#x27;t need to be address&#x2F;pointer equivalent between translation units. This is arguably more important than inlining directly because it means the compiler can fully deduce how the function may be used without any LTO or other cross translation unit optimisation techniques.<p>Of course you could still technically expose a pointer to the function outside a TU but doing so would be obvious to the compiler and it can fall back to generating a strictly conformant version of the function. Otherwise however it can potentially deduce that some branches in said function are unreachable and eliminate them or otherwise specialise the code for the specific use cases in that TU. So it potentially opens up alternative optimisations even if there&#x27;s still a function call and it&#x27;s not inlined directly.</div><br/></div></div><div id="40127628" class="c"><input type="checkbox" id="c-40127628" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40117277">parent</a><span>|</span><a href="#40118207">prev</a><span>|</span><a href="#40117818">next</a><span>|</span><label class="collapse" for="c-40127628">[-]</label><label class="expand" for="c-40127628">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;inline&quot; is confusing in C++, as it is not really about inlining. Its purpose is to allow multiple definitions of the same function.<p>No, its purpose was and is still to specify a preference for inlining. The C++ standard itself says this:<p>&gt; The inline specifier indicates to the implementation that inline substitution of the function body at the point of call is to be preferred to the usual function call mechanism.<p><a href="https:&#x2F;&#x2F;eel.is&#x2F;c++draft&#x2F;dcl.inline" rel="nofollow">https:&#x2F;&#x2F;eel.is&#x2F;c++draft&#x2F;dcl.inline</a></div><br/></div></div><div id="40117818" class="c"><input type="checkbox" id="c-40117818" checked=""/><div class="controls bullet"><span class="by">lqr</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40117277">parent</a><span>|</span><a href="#40127628">prev</a><span>|</span><a href="#40117398">next</a><span>|</span><label class="collapse" for="c-40117818">[-]</label><label class="expand" for="c-40117818">[1 more]</label></div><br/><div class="children"><div class="content">10 years ago it was already folklore that compilers ignore the &quot;inline&quot; keyword when optimizing, but that was false for clang&#x2F;llvm: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;27042935&#x2F;are-the-inline-keyword-and-inlining-optimization-separate-concepts&#x2F;27044943#27044943" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;27042935&#x2F;are-the-inline-...</a></div><br/></div></div><div id="40117398" class="c"><input type="checkbox" id="c-40117398" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#40116940">root</a><span>|</span><a href="#40117277">parent</a><span>|</span><a href="#40117818">prev</a><span>|</span><a href="#40117891">next</a><span>|</span><label class="collapse" for="c-40117398">[-]</label><label class="expand" for="c-40117398">[1 more]</label></div><br/><div class="children"><div class="content">I believe the wording Iâve seen is that compilers may not respect the inline keyword, not that it is ignored.</div><br/></div></div></div></div><div id="40117891" class="c"><input type="checkbox" id="c-40117891" checked=""/><div class="controls bullet"><span class="by">lanza</span><span>|</span><a href="#40116940">parent</a><span>|</span><a href="#40117277">prev</a><span>|</span><a href="#40117411">next</a><span>|</span><label class="collapse" for="c-40117891">[-]</label><label class="expand" for="c-40117891">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Mostly the `final` keyword serves as a compile-time assertion. The compiler (sometimes linker) is perfectly capable of seeing that a class has no derived classes<p>That&#x27;s incorrect. The optimizer has to assume everything escapes the current optimization unit unless explicitly told otherwise. It needs explicit guarantees about the visibility to figure out the extent of the derivations allowed.</div><br/></div></div><div id="40117411" class="c"><input type="checkbox" id="c-40117411" checked=""/><div class="controls bullet"><span class="by">wheybags</span><span>|</span><a href="#40116940">parent</a><span>|</span><a href="#40117891">prev</a><span>|</span><a href="#40117063">next</a><span>|</span><label class="collapse" for="c-40117411">[-]</label><label class="expand" for="c-40117411">[1 more]</label></div><br/><div class="children"><div class="content">What if I dlopen a shared object that contains a derived class, then instantiate it. You cannot statically verify that I won&#x27;t. Or you could swap out a normally linked shared object for one that creates a subclass. Etc etc. This kind of stuff is why I think shared object boundaries should be limited to the lowest common denominator (basically c abi). Dynamic linking high level languages was a mistake. The only winning move is not to play.</div><br/></div></div></div></div><div id="40117631" class="c"><input type="checkbox" id="c-40117631" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#40116940">prev</a><span>|</span><a href="#40124054">next</a><span>|</span><label class="collapse" for="c-40117631">[-]</label><label class="expand" for="c-40117631">[4 more]</label></div><br/><div class="children"><div class="content">The main case where I use final and where I would expect benefits (not covered well by the article) is when you are using an external library with pure virtual interfaces that you implement.<p>For example, the AWS C++ SDK uses virtual functions for everything. When you subclass their classes, marking your classes as final allows the compiler to devirtualize your own calls to your own functions (GCC does this reliably).<p>I&#x27;m curious to understand better how clang is producing worse code in these cases. The code used for the blog post is a bit too complicated for me to look at, but I would love to see some microbenchmarks. My guess is that there is some kind of icache or code side problem. where inlining more produces worse code.</div><br/><div id="40117721" class="c"><input type="checkbox" id="c-40117721" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40117631">parent</a><span>|</span><a href="#40129689">next</a><span>|</span><label class="collapse" for="c-40117721">[-]</label><label class="expand" for="c-40117721">[1 more]</label></div><br/><div class="children"><div class="content">Could easily just be a bad optimization pathway.<p>`final` tells the compiler that nothing extends this class.  That means the compiler can theoretically do things like inlining class methods and eliminate virtual method calls (perhaps duplicating the method)?<p>However, it&#x27;s quite possible that one of those optimizations makes the code bigger or misaligns things with the cache in unexpected ways.  Sometimes, a method call can bet faster than inlining.  Especially with hot loops.<p>All this being said, I&#x27;d expect final to offer very little benefit over PGO.  Its main value is the constraint it imposes and not the optimization it might enable.</div><br/></div></div><div id="40129689" class="c"><input type="checkbox" id="c-40129689" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#40117631">parent</a><span>|</span><a href="#40117721">prev</a><span>|</span><a href="#40124054">next</a><span>|</span><label class="collapse" for="c-40129689">[-]</label><label class="expand" for="c-40129689">[2 more]</label></div><br/><div class="children"><div class="content">&gt; For example, the AWS C++ SDK uses virtual functions for everything. When you subclass their classes, marking your classes as final allows the compiler to devirtualize your own calls to your own functions (GCC does this reliably).<p>I want to ask, and I sincerely mean no snark, what is the point?<p>When working with AWS through an SDK your code will spend most of the time waiting on network calls.<p>What is the point of devirtualizing your function calls to save an indirection when you will be spending several orders of magnitude more time just waiting for the RPC to resolve?<p>It just doesn&#x27;t seem like something even worth thinking about at all.</div><br/><div id="40129780" class="c"><input type="checkbox" id="c-40129780" checked=""/><div class="controls bullet"><span class="by">mgraczyk</span><span>|</span><a href="#40117631">root</a><span>|</span><a href="#40129689">parent</a><span>|</span><a href="#40124054">next</a><span>|</span><label class="collapse" for="c-40129780">[-]</label><label class="expand" for="c-40129780">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s was just the first public C++ library with this pattern that popped into my head. I just make all my classes final out of habit and don&#x27;t think about it. I remove final if I want to subclass, but that almost never happens.</div><br/></div></div></div></div></div></div><div id="40124054" class="c"><input type="checkbox" id="c-40124054" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#40117631">prev</a><span>|</span><a href="#40116992">next</a><span>|</span><label class="collapse" for="c-40124054">[-]</label><label class="expand" for="c-40124054">[6 more]</label></div><br/><div class="children"><div class="content">I would expect &quot;final&quot; to have no effect on this type of code at all. That it does in some cases cause measurable differences I put down to randomly hitting internal compiler thresholds (perhaps one of the inlining heuristics is &quot;Don&#x27;t inline a function with more than 100 tokens&quot;, and the &quot;final&quot; keyword pushes a couple of functions to 101).<p>Why would I expect no performance difference? I haven&#x27;t looked at the code, but I would expect that for each pixel, it iterates through an array&#x2F;vector&#x2F;list etc. of objects that implement some common interface, and calls one or more methods (probably something called intersectRay() or similar) on that interface. <i>By design, that interface cannot be made final, and that&#x27;s what counts.</i> Whether the concrete derived classes are final or not makes no difference.<p>In order to make this a good test of &quot;final&quot;, the pointer type of that container should be constrained to a concrete object type, like Sphere. Of course, this means the scene is limited to spheres.<p>The only case where final can make a difference, by devirtualising a call that couldn&#x27;t otherwise be devirtualised, is when you hold a pointer to that type, <i>and</i> the object it points at was allocated &quot;uncertainly&quot;, e.g., by the caller. (If the object was allocated in the same basic block where the method call later occurs, the compiler already knows its runtime type and will devirtualise the call anyway, even without &quot;final&quot;.)</div><br/><div id="40125337" class="c"><input type="checkbox" id="c-40125337" checked=""/><div class="controls bullet"><span class="by">koyote</span><span>|</span><a href="#40124054">parent</a><span>|</span><a href="#40129182">next</a><span>|</span><label class="collapse" for="c-40125337">[-]</label><label class="expand" for="c-40125337">[4 more]</label></div><br/><div class="children"><div class="content">&gt; (perhaps one of the inlining heuristics is &quot;Don&#x27;t inline a function with more than 100 tokens&quot;, and the &quot;final&quot; keyword pushes a couple of functions to 101).<p>That definitely is one of the heuristics in MSVC++.<p>We have some performance critical code and at one point we noticed a slowdown of around ~4% in a couple of our performance tests.  
I investigated but the only change to that code base involved fixing up an error message (i.e. no logic difference and not even on the direct code path of the test as it would not hit that error).<p>Turns out that:<p><pre><code>    int some_func() {
      if (bad)
        throw std::exception(&quot;Error&quot;);
    
      return some_int;
    }
</code></pre>
Inlined just fine, but after adding more text to the exception error message it no longer inlined, causing the slow-down.  
You could either fix it with __forceinline or by moving the exception to a function call.</div><br/><div id="40125887" class="c"><input type="checkbox" id="c-40125887" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40124054">root</a><span>|</span><a href="#40125337">parent</a><span>|</span><a href="#40129182">next</a><span>|</span><label class="collapse" for="c-40125887">[-]</label><label class="expand" for="c-40125887">[3 more]</label></div><br/><div class="children"><div class="content">Since the inlining is performed in MSVC&#x27;s backend, as opposed to its frontend, and hence operates strictly on MSVC&#x27;s intermediate representation which lacks information about tokens or the AST, it&#x27;s unlikely due to tokens.<p>std::exception does not take a string in its constructor, so most likely you used std::runtime_error. std::runtime_error has a pretty complex constructor if you pass into it a long string. If it&#x27;s a small string then there&#x27;s no issue because it stores its contents in an internal buffer, but if it&#x27;s a longer string then it has to use a reference counting scheme to allow for its copy constructor to be noexcept.<p>That is why you can see different behavior if you use a long string versus a short string. You can also see vastly different codegen with plain std::string as well depending on whether you pass it a short string literal or a long string literal.</div><br/><div id="40126897" class="c"><input type="checkbox" id="c-40126897" checked=""/><div class="controls bullet"><span class="by">koyote</span><span>|</span><a href="#40124054">root</a><span>|</span><a href="#40125887">parent</a><span>|</span><a href="#40126919">next</a><span>|</span><label class="collapse" for="c-40126897">[-]</label><label class="expand" for="c-40126897">[1 more]</label></div><br/><div class="children"><div class="content">&gt; std::exception does not take a string in its constructor<p>You&#x27;re right, I used it as a short-hand for our internal exception function, forgetting that the std one does not take a string. 
Our error handling function is a simple static function that takes an std::string and throws a newly constructed object with that string as a field.<p>But yes, it could very well have been that the string surpassed the short string optimisation threshold or something similar.  
I did verify the assembly before and after and the function definitely inlined before and no longer inlined after. Moving the &#x27;throw&#x27; (and, importantly, the string literal) into a separate function that was called from the same spot ensured it inlined again and the performance was back to normal.</div><br/></div></div><div id="40126919" class="c"><input type="checkbox" id="c-40126919" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#40124054">root</a><span>|</span><a href="#40125887">parent</a><span>|</span><a href="#40126897">prev</a><span>|</span><a href="#40129182">next</a><span>|</span><label class="collapse" for="c-40126919">[-]</label><label class="expand" for="c-40126919">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I had no idea. And I thought I knew about most of C++&#x27;s weirdnesses.</div><br/></div></div></div></div></div></div><div id="40129182" class="c"><input type="checkbox" id="c-40129182" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#40124054">parent</a><span>|</span><a href="#40125337">prev</a><span>|</span><a href="#40116992">next</a><span>|</span><label class="collapse" for="c-40129182">[-]</label><label class="expand" for="c-40129182">[1 more]</label></div><br/><div class="children"><div class="content">Actually, the compiler can only implicitly devirtualize under very specific circumstances. For example, it cannot devirtualize if there was previously a non-inlined call through the same pointer.<p>The reason is placement new. It is legal (given that certain invariants are upheld) in C++ to say `new(this) DerivedClass`, and compilers must assume that each method could potentially have done this, changing the vtable pointer of the object.<p>The `final` keyword somewhat counteracts this, but even GCC still only opportunistically honors it - i.e. it inserts a check if the vtable is the expected value before calling the devirtualized function, falling back on the indirect call.</div><br/></div></div></div></div><div id="40116992" class="c"><input type="checkbox" id="c-40116992" checked=""/><div class="controls bullet"><span class="by">ein0p</span><span>|</span><a href="#40124054">prev</a><span>|</span><a href="#40125240">next</a><span>|</span><label class="collapse" for="c-40116992">[-]</label><label class="expand" for="c-40116992">[8 more]</label></div><br/><div class="children"><div class="content">You should use final to express design intent. In fact Iâd rather it were the default in C++, and there was some sort of an opposite (âderivableâ?) keyword instead, but that ship has sailed long time ago. Any measurable negative perf impact should be filed as a bug and fixed.</div><br/><div id="40117537" class="c"><input type="checkbox" id="c-40117537" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40116992">parent</a><span>|</span><a href="#40117427">next</a><span>|</span><label class="collapse" for="c-40117537">[-]</label><label class="expand" for="c-40117537">[3 more]</label></div><br/><div class="children"><div class="content">C++ doesn&#x27;t have the fragile base problem, as members aren&#x27;t virtual my default. The only concern with unintended inheritance is with polymorhpic deletion. &quot;final&quot; on class definition disables some tricks thag you can do with private inheritance.<p>Having said that &quot;final&quot; on member functions is great, and I like to see that instead of &quot;override&quot;.</div><br/><div id="40129371" class="c"><input type="checkbox" id="c-40129371" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40116992">root</a><span>|</span><a href="#40117537">parent</a><span>|</span><a href="#40129629">next</a><span>|</span><label class="collapse" for="c-40129371">[-]</label><label class="expand" for="c-40129371">[1 more]</label></div><br/><div class="children"><div class="content">All OOP languages have it, the issue is related to changing the behaviour of the base class, and the change introducing unforceen consequences on the inheritance tree.<p>Changing an existing method way of calling (regular, virtual, static), changing visibility, overloading, introducing a name that clashes downstream, introducing a virtual destructor, making a data member non-copyable,...</div><br/></div></div><div id="40129629" class="c"><input type="checkbox" id="c-40129629" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40116992">root</a><span>|</span><a href="#40117537">parent</a><span>|</span><a href="#40129371">prev</a><span>|</span><a href="#40117427">next</a><span>|</span><label class="collapse" for="c-40129629">[-]</label><label class="expand" for="c-40129629">[1 more]</label></div><br/><div class="children"><div class="content">Now try a regular function, you will be blown away. No need to type &quot;final&quot;...</div><br/></div></div></div></div><div id="40117427" class="c"><input type="checkbox" id="c-40117427" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#40116992">parent</a><span>|</span><a href="#40117537">prev</a><span>|</span><a href="#40117361">next</a><span>|</span><label class="collapse" for="c-40117427">[-]</label><label class="expand" for="c-40117427">[1 more]</label></div><br/><div class="children"><div class="content">Intent is nice and all that, but I would like a &quot;nonwithstanding&quot; keyword instead that just lets me bypass that kind of &quot;intent&quot; without having to copy paste the entire implementation just to remove a pointless keyword or make a destructor public when I need it.</div><br/></div></div><div id="40117361" class="c"><input type="checkbox" id="c-40117361" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#40116992">parent</a><span>|</span><a href="#40117427">prev</a><span>|</span><a href="#40117536">next</a><span>|</span><label class="collapse" for="c-40117361">[-]</label><label class="expand" for="c-40117361">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In fact Iâd rather it were the default in C++, and there was some sort of an opposite (âderivableâ?) keyword instead<p>Kotlin (which uses the equivalent of the Java &quot;final&quot; keyword by default) uses the &quot;open&quot; keyword for that purpose.</div><br/></div></div><div id="40117536" class="c"><input type="checkbox" id="c-40117536" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#40116992">parent</a><span>|</span><a href="#40117361">prev</a><span>|</span><a href="#40117133">next</a><span>|</span><label class="collapse" for="c-40117536">[-]</label><label class="expand" for="c-40117536">[1 more]</label></div><br/><div class="children"><div class="content">In general, I think things should be strict by default. Way easier to optimize and less error prone.</div><br/></div></div></div></div><div id="40125240" class="c"><input type="checkbox" id="c-40125240" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#40116992">prev</a><span>|</span><a href="#40129643">next</a><span>|</span><label class="collapse" for="c-40125240">[-]</label><label class="expand" for="c-40125240">[1 more]</label></div><br/><div class="children"><div class="content">As an LLVM developer, I really wish the author filed a bug report and waited for some analysis BEFORE publishing an article (that may never get amended) that recommends not using this keyword with clang for performance reasons. I suspect there&#x27;s just a bug in clang.</div><br/></div></div><div id="40129643" class="c"><input type="checkbox" id="c-40129643" checked=""/><div class="controls bullet"><span class="by">juliangmp</span><span>|</span><a href="#40125240">prev</a><span>|</span><a href="#40128532">next</a><span>|</span><label class="collapse" for="c-40129643">[-]</label><label class="expand" for="c-40129643">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Personally, I&#x27;m not turning it on. And would in fact, avoid using it. It doesn&#x27;t seem consistent.<p>I feel like we&#x27;d have to repeat these tests quite a few times to get to a decent conclusion. Hell small variations in performance could be caused by all sorts of things outside the actual program.</div><br/><div id="40129758" class="c"><input type="checkbox" id="c-40129758" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#40129643">parent</a><span>|</span><a href="#40128532">next</a><span>|</span><label class="collapse" for="c-40129758">[-]</label><label class="expand" for="c-40129758">[1 more]</label></div><br/><div class="children"><div class="content">AFAIU, these tests were ran 30 times each and apparently some took minutes to run, so it&#x27;s unlikely that you&#x27;ll get any different conclusions.</div><br/></div></div></div></div><div id="40128532" class="c"><input type="checkbox" id="c-40128532" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#40129643">prev</a><span>|</span><a href="#40127052">next</a><span>|</span><label class="collapse" for="c-40128532">[-]</label><label class="expand" for="c-40128532">[1 more]</label></div><br/><div class="children"><div class="content">One thing that wasn&#x27;t mentioned in the article that I wished it did was the size of the compiled binary with and without final. Only reason I would expect the final version to be slower is that we are emitting more code because of inlining and that is resulting in a larger portion of instruction cache misses.<p>Also, now that I think of it, they should have run the code under perf and compared the stats.</div><br/></div></div><div id="40127052" class="c"><input type="checkbox" id="c-40127052" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#40128532">prev</a><span>|</span><a href="#40122174">next</a><span>|</span><label class="collapse" for="c-40127052">[-]</label><label class="expand" for="c-40127052">[2 more]</label></div><br/><div class="children"><div class="content">I think it was Chandler Carruth who said &quot;If you&#x27;re not measuring, then you don&#x27;t care about performance.&quot;  I agree, and by that measure, nobody I&#x27;ve ever worked with cares about performance.<p>The best I&#x27;ll see is somebody who cooked up a naive microbenchmark to show that style 1 takes fewer wall nanoseconds than style 2 on his laptop.<p>People I&#x27;ve worked with don&#x27;t use profilers, claiming that they can&#x27;t trust it.  Really they just can&#x27;t be bothered to run it and interpret the output.<p>The truth is, most of us don&#x27;t write C++ because of performance; we write C++ because that&#x27;s the language the code is written in.<p>The performance gained by different C++ techniques seldom matters, and when it does you have to measure.  Profiler reports almost always surprise me the first few times -- your mental model of what&#x27;s going on and what matters is probably wrong.</div><br/><div id="40127146" class="c"><input type="checkbox" id="c-40127146" checked=""/><div class="controls bullet"><span class="by">scottLobster</span><span>|</span><a href="#40127052">parent</a><span>|</span><a href="#40122174">next</a><span>|</span><label class="collapse" for="c-40127146">[-]</label><label class="expand" for="c-40127146">[1 more]</label></div><br/><div class="children"><div class="content">It matters to some degree.  If it&#x27;s just a simple technique you can file away and repeat as muscle memory, well that means your code is that much better.<p>From a user perspective it could be the difference between software that&#x27;s pleasant to use and software that&#x27;s annoying to use.  From a philosophical perspective it&#x27;s the difference between software that functions vs software that works well.<p>Of course it depends on your context as to whether this is valued, but I wouldn&#x27;t dismiss it.  Once person&#x27;s micro-optimization is another person&#x27;s polish.</div><br/></div></div></div></div><div id="40122174" class="c"><input type="checkbox" id="c-40122174" checked=""/><div class="controls bullet"><span class="by">mastax</span><span>|</span><a href="#40127052">prev</a><span>|</span><a href="#40116948">next</a><span>|</span><label class="collapse" for="c-40122174">[-]</label><label class="expand" for="c-40122174">[1 more]</label></div><br/><div class="children"><div class="content">Changes in the layout of the binary can have large impacts on the program performance [0] so it&#x27;s possible that the unexpected performance decrease is caused by unpredictable changes in the layout of the binary between compilations. I think there is some tool which helps ensure layout is consistent for benchmarking, but I can&#x27;t remember what it&#x27;s called.<p>[0]: <a href="https:&#x2F;&#x2F;research.facebook.com&#x2F;publications&#x2F;bolt-a-practical-binary-optimizer-for-data-centers-and-beyond&#x2F;" rel="nofollow">https:&#x2F;&#x2F;research.facebook.com&#x2F;publications&#x2F;bolt-a-practical-...</a></div><br/></div></div><div id="40116948" class="c"><input type="checkbox" id="c-40116948" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40122174">prev</a><span>|</span><a href="#40127041">next</a><span>|</span><label class="collapse" for="c-40116948">[-]</label><label class="expand" for="c-40116948">[1 more]</label></div><br/><div class="children"><div class="content">I use final more for communication. Don&#x27;t look for deeper derived classes as there are none. that it results in slower code is an annoying surprise.</div><br/></div></div><div id="40127041" class="c"><input type="checkbox" id="c-40127041" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#40116948">prev</a><span>|</span><a href="#40119861">next</a><span>|</span><label class="collapse" for="c-40127041">[-]</label><label class="expand" for="c-40127041">[1 more]</label></div><br/><div class="children"><div class="content">Mildly related programming language trivia:<p>Fortran has virtual functions (&quot;type bound procedures&quot;), and supports a NON_OVERRIDABLE attribute on them that is basically &quot;final&quot;.  (FINAL exists but means something else.). But it also has a means for localizing the non-overridable property.<p>If a type bound procedure is declared in a module, and is PRIVATE, then overrides in subtypes (&quot;extended derived types&quot;) work as usual for subtypes in the same module, but can&#x27;t be affected by overrides that appear in other modules.  This allows a compiler to notice when a type has no subtypes in the same module, and basically infer that it is non-overridable locally, and thus resolve calls at compilation time.<p>Or it would, if compilers implemented this feature correctly.  It&#x27;s not well described in the standard, and only half of the Fortran compilers in the wild actually support it.  So like too many things in the Fortran world, it might be useful, but it&#x27;s not portable.</div><br/></div></div><div id="40119861" class="c"><input type="checkbox" id="c-40119861" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40127041">prev</a><span>|</span><a href="#40117556">next</a><span>|</span><label class="collapse" for="c-40119861">[-]</label><label class="expand" for="c-40119861">[1 more]</label></div><br/><div class="children"><div class="content">This is the gist of the difference in code generation when final is involved:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;7xKj6qTcj" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;7xKj6qTcj</a><p>edit:
And a case involving inlining:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;E9qrb3hKM" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;E9qrb3hKM</a></div><br/></div></div><div id="40117556" class="c"><input type="checkbox" id="c-40117556" checked=""/><div class="controls bullet"><span class="by">JackYoustra</span><span>|</span><a href="#40119861">prev</a><span>|</span><a href="#40129238">next</a><span>|</span><label class="collapse" for="c-40117556">[-]</label><label class="expand" for="c-40117556">[2 more]</label></div><br/><div class="children"><div class="content">I really wish he&#x27;d listed all the flags he used. To add on to the flags already listed by some other commenters, `-mcpu` and related flags are really crucial in these microbenchmarks: over such a small change and such a small set of tight loops, you could just be regression on coincidences in the microarchitecture scheduler vs higher level assumptions.</div><br/><div id="40123011" class="c"><input type="checkbox" id="c-40123011" checked=""/><div class="controls bullet"><span class="by">j_not_j</span><span>|</span><a href="#40117556">parent</a><span>|</span><a href="#40129238">next</a><span>|</span><label class="collapse" for="c-40123011">[-]</label><label class="expand" for="c-40123011">[1 more]</label></div><br/><div class="children"><div class="content">And he didn&#x27;t repeat each test case 5 or 9 times, and take the median (or even an average).<p>There will be operating system noise that can be in the multi-percent range.  This is defined as various OS services that run &quot;in the background&quot; taking up cpu time, emptying cache lines (which may be most important), and flushing a few translate lookaside entries.<p>Once you recognize the variability from run to run, claiming &quot;1%&quot; becomes less credible.  Depending on the noise level, of course.<p>Linux benchmarks like SPECcpu tend to be run in &quot;single-user mode&quot; meaning almost no background processes are running.</div><br/></div></div></div></div><div id="40129238" class="c"><input type="checkbox" id="c-40129238" checked=""/><div class="controls bullet"><span class="by">teeuwen</span><span>|</span><a href="#40117556">prev</a><span>|</span><a href="#40117089">next</a><span>|</span><label class="collapse" for="c-40129238">[-]</label><label class="expand" for="c-40129238">[3 more]</label></div><br/><div class="children"><div class="content">I do not see how the final keyword would make a difference in performance at all in this case. The compiler should be able to build an inheritance tree and determine by itself which classes are to be treated as final.<p>Now for libraries, this is a different story. There I can imagine final keyword could have an impact.</div><br/><div id="40129303" class="c"><input type="checkbox" id="c-40129303" checked=""/><div class="controls bullet"><span class="by">connicpu</span><span>|</span><a href="#40129238">parent</a><span>|</span><a href="#40129364">next</a><span>|</span><label class="collapse" for="c-40129303">[-]</label><label class="expand" for="c-40129303">[1 more]</label></div><br/><div class="children"><div class="content">But dynamically loaded libraries exist, so even if it knows the class is the most derived version out of all classes that exist in all of the statically-linked code through LTO or something, unless it can see the instantiation site it won&#x27;t be able to devirtualize the function calls without the class being marked as final.</div><br/></div></div><div id="40129364" class="c"><input type="checkbox" id="c-40129364" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40129238">parent</a><span>|</span><a href="#40129303">prev</a><span>|</span><a href="#40117089">next</a><span>|</span><label class="collapse" for="c-40129364">[-]</label><label class="expand" for="c-40129364">[1 more]</label></div><br/><div class="children"><div class="content">Only if the complete source code is available to the compiler.</div><br/></div></div></div></div><div id="40117089" class="c"><input type="checkbox" id="c-40117089" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40129238">prev</a><span>|</span><a href="#40118229">next</a><span>|</span><label class="collapse" for="c-40117089">[-]</label><label class="expand" for="c-40117089">[1 more]</label></div><br/><div class="children"><div class="content">1% is nothing to scoff of. But I suspect that the variability of compilation (specifically quirks of instruction selection, register allocation and function alignment) more than mask any gains.<p>The clang regression might be explainable by final allowing some additional inlining and clang making an hash of it.</div><br/></div></div><div id="40118229" class="c"><input type="checkbox" id="c-40118229" checked=""/><div class="controls bullet"><span class="by">lanza</span><span>|</span><a href="#40117089">prev</a><span>|</span><a href="#40121093">next</a><span>|</span><label class="collapse" for="c-40118229">[-]</label><label class="expand" for="c-40118229">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re measuring a compiler you need to post the flags and version used. Otherwise the entire experiment is in the noise.</div><br/></div></div><div id="40121093" class="c"><input type="checkbox" id="c-40121093" checked=""/><div class="controls bullet"><span class="by">fransje26</span><span>|</span><a href="#40118229">prev</a><span>|</span><a href="#40117241">next</a><span>|</span><label class="collapse" for="c-40121093">[-]</label><label class="expand" for="c-40121093">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually more worried about Clang being close to 100% slower than GCC on Linux. That doesn&#x27;t seem right.<p>I am prepared to believe that there is some performance difference between the two, varying per case, but I would expect a few percent difference, not twice the run time..</div><br/></div></div><div id="40117241" class="c"><input type="checkbox" id="c-40117241" checked=""/><div class="controls bullet"><span class="by">sfink</span><span>|</span><a href="#40121093">prev</a><span>|</span><a href="#40119605">next</a><span>|</span><label class="collapse" for="c-40117241">[-]</label><label class="expand" for="c-40117241">[4 more]</label></div><br/><div class="children"><div class="content">tldr: sprinkled a keyword around in the hopes that it &quot;does something&quot; to speed things up, tested it, got noisy results but no miraculous speedup.<p>I started skimming this article after a while, because it seemed to be going into the weeds of performance comparison without ever backing up to look at what the change might be doing. Which meant that I couldn&#x27;t tell if I was going to be looking at the usual random noise of performance testing or something real.<p>For `final`, I&#x27;d want to at least see if it changing the generated code by replacing indirect vtable calls with direct or inlined calls. It might be that the compiler is already figuring it out and the keyword isn&#x27;t doing anything. It might be that the compiler <i>is</i> changing code, but the target address was already well-predicted and it&#x27;s perturbing code layout enough that it gets slower (or faster). There could be something interesting here, but I can&#x27;t tell without at least a little assembly output (or perhaps a relevant portion of some intermediate representation, not that I would know which one to look at).<p>If it&#x27;s not changing anything, then perhaps there could be an interesting investigation into the variance of performance testing in this scenario. If it&#x27;s changing something, then there could be an interesting investigation into when that makes things faster vs slower. As it is, I can&#x27;t tell what I should be looking for.</div><br/><div id="40124667" class="c"><input type="checkbox" id="c-40124667" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#40117241">parent</a><span>|</span><a href="#40117294">next</a><span>|</span><label class="collapse" for="c-40124667">[-]</label><label class="expand" for="c-40124667">[1 more]</label></div><br/><div class="children"><div class="content">&gt;changing the generated code by replacing indirect vtable calls with direct or inlined calls<p>It can&#x27;t possibly be doing this, if the raytracing code is like any other raytracer I&#x27;ve ever seen -- since it must be looping through a list of concrete objects that implement some shared interface, calling intersectRay() on each one, and the existence of those derived concrete object types means that that shared interface <i>can&#x27;t</i> be made final, and that&#x27;s the only thing that would enable devirtualisation -- it makes no difference whether the concrete derived types themselves are final or not.</div><br/></div></div><div id="40117294" class="c"><input type="checkbox" id="c-40117294" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#40117241">parent</a><span>|</span><a href="#40124667">prev</a><span>|</span><a href="#40127838">next</a><span>|</span><label class="collapse" for="c-40117294">[-]</label><label class="expand" for="c-40117294">[1 more]</label></div><br/><div class="children"><div class="content">This is what I was waiting for too. Especially with the large regression on Clang&#x2F;Ubuntu. Maybe he uncovered a Clang&#x2F;LLVM codegen bug, but youâd need to compare the generated assembly to know.</div><br/></div></div><div id="40127838" class="c"><input type="checkbox" id="c-40127838" checked=""/><div class="controls bullet"><span class="by">drivebycomment</span><span>|</span><a href="#40117241">parent</a><span>|</span><a href="#40117294">prev</a><span>|</span><a href="#40119605">next</a><span>|</span><label class="collapse" for="c-40127838">[-]</label><label class="expand" for="c-40127838">[1 more]</label></div><br/><div class="children"><div class="content">+1. On modern hardware and software systems, performance is effectively stochastic to some degree, as small random perturbations to the input (code, data, environments, etc) can have arbitrary effects for the performance. This means you can&#x27;t draw a direct causal chain &#x2F; mechanism from what you changed to the performance change - when it matters, you do need to do a deeper analysis and investigation to find the actual and full causal chain. I.e. a correlation is not a causation, and especially more so on modern hardware and software systems.</div><br/></div></div></div></div><div id="40119605" class="c"><input type="checkbox" id="c-40119605" checked=""/><div class="controls bullet"><span class="by">magnat</span><span>|</span><a href="#40117241">prev</a><span>|</span><a href="#40128839">next</a><span>|</span><label class="collapse" for="c-40119605">[-]</label><label class="expand" for="c-40119605">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I created a &quot;large test suite&quot; to be more intensive. On my dev machine it needed to run for 8 hours.<p>During such long and compute-intensive tests, how are thermal considerations mitigated? Not saying that this was case here, but I can see how after saturating all cores for 8 hours, the whole PC might get hot to the point CPU starts throttling, so when you reboot to next OS or start another batch, overall performance could be a bit lower.</div><br/><div id="40119822" class="c"><input type="checkbox" id="c-40119822" checked=""/><div class="controls bullet"><span class="by">lastgeniusua</span><span>|</span><a href="#40119605">parent</a><span>|</span><a href="#40128839">next</a><span>|</span><label class="collapse" for="c-40119822">[-]</label><label class="expand" for="c-40119822">[1 more]</label></div><br/><div class="children"><div class="content">having recently done similar day-and-night long suites of benchmarks (on a laptop in heat dissipation conditions worse than on any decent desktop), I&#x27;ve found that there is no correlation between the order the benchmarks are run in and their performance (or energy consumption!). i would therefore assume that a non-overclocked processor would not exhibit the patterns you are thinking of here</div><br/></div></div></div></div><div id="40128839" class="c"><input type="checkbox" id="c-40128839" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#40119605">prev</a><span>|</span><a href="#40117169">next</a><span>|</span><label class="collapse" for="c-40128839">[-]</label><label class="expand" for="c-40128839">[3 more]</label></div><br/><div class="children"><div class="content">&gt; And probably, that reason is performance.<p>That&#x27;s the first problem I see with the article. C++ isn&#x27;t a fast language, as it is. There are far too many issues with e.g. aliasing rules, lack of proper vectorization (for the runtime arch), etc.<p>If you wish to have a relatively good performance for your code, try ISPC, which still allows you to get great performance with vectorization up to AVX-512, without turning to intrisics.</div><br/><div id="40128898" class="c"><input type="checkbox" id="c-40128898" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40128839">parent</a><span>|</span><a href="#40117169">next</a><span>|</span><label class="collapse" for="c-40128898">[-]</label><label class="expand" for="c-40128898">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s the first problem I see with the article. C++ isn&#x27;t a fast language, as it is. There are far too many issues with e.g. aliasing rules, lack of proper vectorization (for the runtime arch), etc.<p>That&#x27;s a bold statement due to the way it heavily contrasts with reality.<p>C++ is ever present in high performance benchmarks as either the highest performing language or second only to C. It&#x27;s weird seeing someone claim with a straight face that &quot;C++ isn&#x27;t a fast language, as it is&quot;.<p>To make matters worse, you go on confusing what a programming language is, and confusing implementation details with language features. It&#x27;s like claiming that C++ isn&#x27;t a language for computational graphics just because no C++ standard dedicates a chapter to it.<p>Just like every engineering domain,you need to have deep knowledge on details to milk the last drop of performance improvements out of a program. Low-latency C++ is a testament of how the smallest details can be critical of performance. But you need to be completely detached from reality to claim that C++ isn&#x27;t a fast language.</div><br/><div id="40129261" class="c"><input type="checkbox" id="c-40129261" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#40128839">root</a><span>|</span><a href="#40128898">parent</a><span>|</span><a href="#40117169">next</a><span>|</span><label class="collapse" for="c-40129261">[-]</label><label class="expand" for="c-40129261">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s a bold statement due to the way it heavily contrasts with reality.<p>I&#x27;m ready to back this up. And no, I&#x27;m not confusing things - I work in HPC (realtime computer vision) and in reality the only thing we&#x27;d use C++ for is &quot;glue&quot;, i.e. binding implementations of the actual algorithms implemented in other languages together.<p>Implementations could be e.g. in CUDA, ISPC, neural-inference via TensorRT, etc.</div><br/></div></div></div></div></div></div><div id="40117169" class="c"><input type="checkbox" id="c-40117169" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#40128839">prev</a><span>|</span><a href="#40128274">next</a><span>|</span><label class="collapse" for="c-40117169">[-]</label><label class="expand" for="c-40117169">[1 more]</label></div><br/><div class="children"><div class="content">If it does have a noticeable impact, that would be surprising, a bit like going back to the days when &#x27;inline&#x27; was supposed to tell the compiler to inline the designated functions (no longer its main use case nowadays).</div><br/></div></div><div id="40128274" class="c"><input type="checkbox" id="c-40128274" checked=""/><div class="controls bullet"><span class="by">headline</span><span>|</span><a href="#40117169">prev</a><span>|</span><a href="#40117092">next</a><span>|</span><label class="collapse" for="c-40128274">[-]</label><label class="expand" for="c-40128274">[1 more]</label></div><br/><div class="children"><div class="content">re: final macro<p>&gt; I would never do this in an actual product<p>what, why?</div><br/></div></div><div id="40117092" class="c"><input type="checkbox" id="c-40117092" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40128274">prev</a><span>|</span><a href="#40117087">next</a><span>|</span><label class="collapse" for="c-40117092">[-]</label><label class="expand" for="c-40117092">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting. Maybe final enabled more inlining, and clang is being too aggressive about it for the icache sizes in play here? I&#x27;d love to see a comparison of the generated code.<p>I&#x27;m disappointed the author&#x27;s conclusion is &quot;don&#x27;t use final&quot;, not &quot;something is wrong with clang&quot;.</div><br/><div id="40117213" class="c"><input type="checkbox" id="c-40117213" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#40117092">parent</a><span>|</span><a href="#40117087">next</a><span>|</span><label class="collapse" for="c-40117213">[-]</label><label class="expand" for="c-40117213">[1 more]</label></div><br/><div class="children"><div class="content">Or &quot;something is wrong with my benchmark setup&quot;, which is also a possibility :)<p>Without a comparison of generated code, it could be anything.</div><br/></div></div></div></div><div id="40117087" class="c"><input type="checkbox" id="c-40117087" checked=""/><div class="controls bullet"><span class="by">pineapple_sauce</span><span>|</span><a href="#40117092">prev</a><span>|</span><a href="#40116989">next</a><span>|</span><label class="collapse" for="c-40117087">[-]</label><label class="expand" for="c-40117087">[8 more]</label></div><br/><div class="children"><div class="content">What should be evaluated is removing indirection and tightly packing your data. I&#x27;m sure you&#x27;ll gain a better performance improvement. virtual calls and shared_ptr are littered in the codebase.<p>In this way: you can avoid the need for the `final` keyword and do the optimization the keyword enables (de-virtualize calls).<p>&gt;Yes, it is very hacky and I am disgusted by this myself. I would never do this in an actual product<p>Why? What&#x27;s with the C++ community and their disgust for macros without any underlying reasoning? It reminds me of everyone blindly saying &quot;Don&#x27;t use goto; it creates spaghetti code&quot;.<p>Sure, if macros are overly used: it can be hard to read and maintain. But, for something simple like this, you shouldn&#x27;t be thinking &quot;I would never do this in an actual product&quot;.</div><br/><div id="40117335" class="c"><input type="checkbox" id="c-40117335" checked=""/><div class="controls bullet"><span class="by">sfink</span><span>|</span><a href="#40117087">parent</a><span>|</span><a href="#40119554">next</a><span>|</span><label class="collapse" for="c-40117335">[-]</label><label class="expand" for="c-40117335">[1 more]</label></div><br/><div class="children"><div class="content">Macros that are giving you some value can be ok. In this case, once the performance conclusion is reached, the only reason to continue using a macro is if you really need the `final`ity to vary between builds. Otherwise, just delete it or use the actual keyword.<p>(But I&#x27;m worse than the author; if I&#x27;m just comparing performance, I&#x27;d probably put `final` everywhere applicable and then do separate compiles with `-Dfinal=` and `-Dfinal=final`... I&#x27;d be making the assumption that it&#x27;s something I either always or never want eventually, though.)</div><br/></div></div><div id="40119554" class="c"><input type="checkbox" id="c-40119554" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40117087">parent</a><span>|</span><a href="#40117335">prev</a><span>|</span><a href="#40117503">next</a><span>|</span><label class="collapse" for="c-40119554">[-]</label><label class="expand" for="c-40119554">[3 more]</label></div><br/><div class="children"><div class="content">In modern C++, macros are a viewed as a code smell because they are strictly worse than alternatives in almost all situations. It is a cultural norm; it is a bit like using &quot;unsafe&quot; in Rust if not strictly required for some trivial case. The C++ language has made a concerted effort to eliminate virtually all use cases for macros since C++11 and replace them with type-safe first-class features in the language. It is a bit of a legacy thing at this point, there are large modern C++ codebases with no macros at all, not even for things like logging. While macros aren&#x27;t going away, especially in older code, the cultural norm in modern C++ has tended toward macros being a legacy foot-gun and best avoided if at all possible.<p>The main remaining use case for the old C macro facility I still see in new code is to support conditional compilation of architecture-specific code e.g. ARM vs x86 assembly routines or intrinsics.</div><br/><div id="40123621" class="c"><input type="checkbox" id="c-40123621" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#40117087">root</a><span>|</span><a href="#40119554">parent</a><span>|</span><a href="#40117503">next</a><span>|</span><label class="collapse" for="c-40123621">[-]</label><label class="expand" for="c-40123621">[2 more]</label></div><br/><div class="children"><div class="content">But how would one conditionally enable or disable the âfinalâ keyword on class members without a preprocessor macro, even in C++23?</div><br/><div id="40125822" class="c"><input type="checkbox" id="c-40125822" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40117087">root</a><span>|</span><a href="#40123621">parent</a><span>|</span><a href="#40117503">next</a><span>|</span><label class="collapse" for="c-40125822">[-]</label><label class="expand" for="c-40125822">[1 more]</label></div><br/><div class="children"><div class="content">Macros are still useful for conditional compilation, as in this case. They&#x27;ve been sunsetted for anything that looks like code generation, which this isn&#x27;t. I was more commenting on the reflexive &quot;ick&quot; reaction of the author to the use of macros (even when appropriate) because avoiding them has become so engrained in C++ culture. I&#x27;m a macro minimalist but I would use them here.<p>Many people have a similar reaction to the use of &quot;goto&quot;, even though it is absolutely the right choice in some contexts.</div><br/></div></div></div></div></div></div><div id="40117503" class="c"><input type="checkbox" id="c-40117503" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40117087">parent</a><span>|</span><a href="#40119554">prev</a><span>|</span><a href="#40116989">next</a><span>|</span><label class="collapse" for="c-40117503">[-]</label><label class="expand" for="c-40117503">[3 more]</label></div><br/><div class="children"><div class="content">Macros in C are a text replace and so it is hard to see from a debugger how th code got like that.</div><br/><div id="40118071" class="c"><input type="checkbox" id="c-40118071" checked=""/><div class="controls bullet"><span class="by">pineapple_sauce</span><span>|</span><a href="#40117087">root</a><span>|</span><a href="#40117503">parent</a><span>|</span><a href="#40116989">next</a><span>|</span><label class="collapse" for="c-40118071">[-]</label><label class="expand" for="c-40118071">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;m well aware of the definition of a macro in C and C++. Macros are simpler than templates. You can expand them with a compiler flag.</div><br/><div id="40123297" class="c"><input type="checkbox" id="c-40123297" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40117087">root</a><span>|</span><a href="#40118071">parent</a><span>|</span><a href="#40116989">next</a><span>|</span><label class="collapse" for="c-40123297">[-]</label><label class="expand" for="c-40123297">[1 more]</label></div><br/><div class="children"><div class="content">when things get complex templete error messages are easier to follow. nobody makes complex macros but if you tried. (template error messeges are legendary for a reason. nested macros are worse)</div><br/></div></div></div></div></div></div></div></div><div id="40116989" class="c"><input type="checkbox" id="c-40116989" checked=""/><div class="controls bullet"><span class="by">p0w3n3d</span><span>|</span><a href="#40117087">prev</a><span>|</span><a href="#40117052">next</a><span>|</span><label class="collapse" for="c-40116989">[-]</label><label class="expand" for="c-40116989">[5 more]</label></div><br/><div class="children"><div class="content">I would say the most performance impact would give `constexpr` followed by `const`. I wouldn&#x27;t bet any money on `final` which in C++ is a guard of inheritance, and C++ function invocation address is resolved the `vtable` hence final wouldn&#x27;t change anything. Maybe the author was mistaken with `final` keyword in Java</div><br/><div id="40117050" class="c"><input type="checkbox" id="c-40117050" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40116989">parent</a><span>|</span><a href="#40117052">next</a><span>|</span><label class="collapse" for="c-40117050">[-]</label><label class="expand" for="c-40117050">[4 more]</label></div><br/><div class="children"><div class="content">In my experience the compiler is pretty good at figuring out what is constant so adding const is more documentation for humans, especially in C++, where const is more of a hint than a hard boundary. Devirtualization, as can happen when you add a final, or the optimizations enabled by adding a restrict to a pointer, are on the other hand often essential for performance in hot code.</div><br/><div id="40128765" class="c"><input type="checkbox" id="c-40128765" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40116989">root</a><span>|</span><a href="#40117050">parent</a><span>|</span><a href="#40118213">next</a><span>|</span><label class="collapse" for="c-40128765">[-]</label><label class="expand" for="c-40128765">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience the compiler is pretty good at figuring out what is constant so adding const is more documentation for humans,<p>In the same TU, sure. But across TU boundaries the compiler really can&#x27;t figure out what should be const and what should not, so `const` in parameter or return values allows the compiler to tell the human <i>&quot;You are attempting to make a modification to a value that some other TU put into RO memory.&quot;</i>, or issue similar diagnostics.</div><br/></div></div><div id="40118213" class="c"><input type="checkbox" id="c-40118213" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#40116989">root</a><span>|</span><a href="#40117050">parent</a><span>|</span><a href="#40128765">prev</a><span>|</span><a href="#40117052">next</a><span>|</span><label class="collapse" for="c-40118213">[-]</label><label class="expand" for="c-40118213">[2 more]</label></div><br/><div class="children"><div class="content">Since &quot;const&quot; makes things read-only, being const correct makes sure that you don&#x27;t do funny things with the data you shouldn&#x27;t mutate, which in turn eliminates tons of data bugs out of the gate.<p>So, it&#x27;s an opt-in security feature first, and a compiler hint second.</div><br/><div id="40129766" class="c"><input type="checkbox" id="c-40129766" checked=""/><div class="controls bullet"><span class="by">Lockal</span><span>|</span><a href="#40116989">root</a><span>|</span><a href="#40118213">parent</a><span>|</span><a href="#40117052">next</a><span>|</span><label class="collapse" for="c-40129766">[-]</label><label class="expand" for="c-40129766">[1 more]</label></div><br/><div class="children"><div class="content">How does const affects code generation in C&#x2F;C++? Last time I checked, const was purely informational. Compilers can&#x27;t eliminate reads for const pointer data, because const_cast exists. Compilers can&#x27;t eliminate double calls to const methods, because inside function definition such functions can still legally modify mutable variables (and have many side effects).<p>What actually may help is __attribute__((pure)) and __attribute__((const)), but I don&#x27;t see them often in real code (unfortunately).</div><br/></div></div></div></div></div></div></div></div><div id="40117052" class="c"><input type="checkbox" id="c-40117052" checked=""/><div class="controls bullet"><span class="by">jey</span><span>|</span><a href="#40116989">prev</a><span>|</span><a href="#40117658">next</a><span>|</span><label class="collapse" for="c-40117052">[-]</label><label class="expand" for="c-40117052">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if LTO was turned on when using Clang? Might lead to a performance improvement.</div><br/></div></div><div id="40117658" class="c"><input type="checkbox" id="c-40117658" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#40117052">prev</a><span>|</span><a href="#40128535">next</a><span>|</span><label class="collapse" for="c-40117658">[-]</label><label class="expand" for="c-40117658">[6 more]</label></div><br/><div class="children"><div class="content">I profiled this project and there are abundant opportunities for devirtualization. The virtual interface `IHittable` is the hot one. However, the WITH_FINAL define is not sufficient, because the hot call is still virtual. At `hit_object |= _objects[node-&gt;object_index()]-&gt;hit` I am still seeing ` mov     (%rdi),%rax; call    *0x18(%rax)` so the application of final here was not sufficient to do the job. Whatever differences are being measures are caused by bogons.</div><br/><div id="40125099" class="c"><input type="checkbox" id="c-40125099" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#40117658">parent</a><span>|</span><a href="#40118116">next</a><span>|</span><label class="collapse" for="c-40125099">[-]</label><label class="expand" for="c-40125099">[1 more]</label></div><br/><div class="children"><div class="content">An interface, like IHittable, can&#x27;t possibly be made final since its whole <i>purpose</i> is to enable multiple different concrete subclasses that implement it.<p>As you say, that&#x27;s the hot one -- and making the concrete subclasses themselves &quot;final&quot; enables no devirtualisations since there are no opportunities for it.</div><br/></div></div><div id="40118116" class="c"><input type="checkbox" id="c-40118116" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40117658">parent</a><span>|</span><a href="#40125099">prev</a><span>|</span><a href="#40128535">next</a><span>|</span><label class="collapse" for="c-40118116">[-]</label><label class="expand" for="c-40118116">[4 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t looked at the code, but if you have multiple leaves, even marking all of them as final won&#x27;t help if the call is through a base class.</div><br/><div id="40118768" class="c"><input type="checkbox" id="c-40118768" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#40117658">root</a><span>|</span><a href="#40118116">parent</a><span>|</span><a href="#40128535">next</a><span>|</span><label class="collapse" for="c-40118768">[-]</label><label class="expand" for="c-40118768">[3 more]</label></div><br/><div class="children"><div class="content">Yeah the practical cases for devirtualization are when you have a base class, a derived class that you actually use, and another derived class that you use in tests. For your release binary the tests aren&#x27;t visible so that can all be devirtualized.<p>In cases where you have Dog and Goose that both derive from Animal and then you have std::vector&lt;Animal&gt;, what is the compiler supposed to do?</div><br/><div id="40127753" class="c"><input type="checkbox" id="c-40127753" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40117658">root</a><span>|</span><a href="#40118768">parent</a><span>|</span><a href="#40128535">next</a><span>|</span><label class="collapse" for="c-40127753">[-]</label><label class="expand" for="c-40127753">[2 more]</label></div><br/><div class="children"><div class="content">The compiler simply knows that the actual dynamic type is Animal because it is not a pointer. You need Animal* to trigger all the fun virtual dispatch stuff.</div><br/><div id="40128806" class="c"><input type="checkbox" id="c-40128806" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#40117658">root</a><span>|</span><a href="#40127753">parent</a><span>|</span><a href="#40128535">next</a><span>|</span><label class="collapse" for="c-40128806">[-]</label><label class="expand" for="c-40128806">[1 more]</label></div><br/><div class="children"><div class="content">I intuit vector&lt;Animal*&gt; is what was meant...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40128535" class="c"><input type="checkbox" id="c-40128535" checked=""/><div class="controls bullet"><span class="by">kasajian</span><span>|</span><a href="#40117658">prev</a><span>|</span><label class="collapse" for="c-40128535">[-]</label><label class="expand" for="c-40128535">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised by this article.   the author genuinely believes that a language construct to benefit performance was added to the language without anyone ever running any metrics to verify.   &quot;just trust me bro&quot;, is the quote.<p>It&#x27;s is an insane level of ignorance about how these things are decided by the standards committee.</div><br/><div id="40129773" class="c"><input type="checkbox" id="c-40129773" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#40128535">parent</a><span>|</span><label class="collapse" for="c-40129773">[-]</label><label class="expand" for="c-40129773">[1 more]</label></div><br/><div class="children"><div class="content">And yet, results from current compilers show that results are mixed, in summary not making programs faster.</div><br/></div></div></div></div></div></div></div></div></div></body></html>