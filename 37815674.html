<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696842083411" as="style"/><link rel="stylesheet" href="styles.css?v=1696842083411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nullprogram.com/blog/2023/10/08/">My personal C coding style as of late 2023</a> <span class="domain">(<a href="https://nullprogram.com">nullprogram.com</a>)</span></div><div class="subtext"><span>zdw</span> | <span>160 comments</span></div><br/><div><div id="37816474" class="c"><input type="checkbox" id="c-37816474" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#37816047">next</a><span>|</span><label class="collapse" for="c-37816474">[-]</label><label class="expand" for="c-37816474">[37 more]</label></div><br/><div class="children"><div class="content">IMO, defining your own types is one step too far. Now everyone who is already familiar with C types has to learn your own quirky system to understand one program. I think it does probably make sense to be specific about the sizes though e.g. using uint32_t over just uint (and expecting to receive some architecture-dependent size you might not get with uint.) These types should be defined in the right header (I think it depends on compiler?) It&#x27;s been a while since I wrote any amount of C so my apologizes if this isn&#x27;t correct.</div><br/><div id="37817473" class="c"><input type="checkbox" id="c-37817473" checked=""/><div class="controls bullet"><span class="by">rkagerer</span><span>|</span><a href="#37816474">parent</a><span>|</span><a href="#37817818">next</a><span>|</span><label class="collapse" for="c-37817473">[-]</label><label class="expand" for="c-37817473">[13 more]</label></div><br/><div class="children"><div class="content">The author <i>did</i> qualify it with <i>personal</i> coding style.  Frankly the standard types are too verbose and I wish this guy&#x27;s elegant and clear list had been the one that was adopted way back when.</div><br/><div id="37817876" class="c"><input type="checkbox" id="c-37817876" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817473">parent</a><span>|</span><a href="#37817934">next</a><span>|</span><label class="collapse" for="c-37817876">[-]</label><label class="expand" for="c-37817876">[1 more]</label></div><br/><div class="children"><div class="content">That ship has sailed ages ago. There are some things you should just accept about C, or any programming language really. Just because you <i>can</i> do something doesn&#x27;t mean you <i>should</i> do something. I don&#x27;t know how many years of experience in C this guy has, but this is a &quot;been there, done that&quot; case for me. I stick to stdint and stdbool today, and even if only half the code&#x2F;libs I interface with do that, it&#x27;s already worth the extra _t-typing all the time. Just the fact that they use the i prefix for signed, and s for string has a high chance that his s8 string type gets confused with an 8-bit signed int.<p>But as you say, it&#x27;s a personal style, and the author seems to be aware of that:<p>&gt; I’m not saying everyone should write C this way, and when I contribute code to a project I follow their local style.<p>Because that&#x27;s by far the most important rule to follow in <i>any</i> language.<p>I think the rest is less controversial, the 0 vs. NULL thing has been going on forever; I didn&#x27;t check recently but I&#x27;d assume &quot;const somestruct *foo&quot; would still sometimes help out the compiler to optimize vs. the non-const version.</div><br/></div></div><div id="37817934" class="c"><input type="checkbox" id="c-37817934" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817473">parent</a><span>|</span><a href="#37817876">prev</a><span>|</span><a href="#37817763">next</a><span>|</span><label class="collapse" for="c-37817934">[-]</label><label class="expand" for="c-37817934">[1 more]</label></div><br/><div class="children"><div class="content">In case of winapi you can actually generate your own headers following the style you want, see for example <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;cppwin32">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;cppwin32</a></div><br/></div></div><div id="37817763" class="c"><input type="checkbox" id="c-37817763" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817473">parent</a><span>|</span><a href="#37817934">prev</a><span>|</span><a href="#37817818">next</a><span>|</span><label class="collapse" for="c-37817763">[-]</label><label class="expand" for="c-37817763">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The author did qualify it with personal coding style. Frankly the standard types are too verbose and I wish this guy&#x27;s elegant and clear list had been the one that was adopted way back when.<p>They didn&#x27;t adopt it for the same reason that it is a bad idea now - too many programs already contained at least one variable named after his types.<p>If the standard had adopted his convention, too many programs will break, which is why his convention is currently unsuitable for any existing project.</div><br/><div id="37817840" class="c"><input type="checkbox" id="c-37817840" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817763">parent</a><span>|</span><a href="#37817818">next</a><span>|</span><label class="collapse" for="c-37817840">[-]</label><label class="expand" for="c-37817840">[9 more]</label></div><br/><div class="children"><div class="content">Wouldn’t existing programs just continue working? What the author did was adding new types, not modifying or removing existing ones.</div><br/><div id="37817885" class="c"><input type="checkbox" id="c-37817885" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817840">parent</a><span>|</span><a href="#37817933">next</a><span>|</span><label class="collapse" for="c-37817885">[-]</label><label class="expand" for="c-37817885">[1 more]</label></div><br/><div class="children"><div class="content">Because those existing programs surely don&#x27;t use the same identifiers for other stuff? Certainly there is no code out there using s8 for &quot;signed char&quot; instead of &quot;utf8 string&quot;? :-)</div><br/></div></div><div id="37817933" class="c"><input type="checkbox" id="c-37817933" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817840">parent</a><span>|</span><a href="#37817885">prev</a><span>|</span><a href="#37817818">next</a><span>|</span><label class="collapse" for="c-37817933">[-]</label><label class="expand" for="c-37817933">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Wouldn’t existing programs just continue working?<p>Only ones which don&#x27;t have variables named `i8` or `b32` (which is common, but not for booleans).<p>I&#x27;ve seen many projects which used the pattern [a-z][1-9]+ as variables. Those programs with a variable called `i8` won&#x27;t compile if the standard made a type called `i8`.<p>In particular, the standard reserves entire patterns to itself, so it cannot reserve the pattern of [a-z][0-9]+. They could, and did, reserve the pattern *int*_t for themselves.</div><br/><div id="37818164" class="c"><input type="checkbox" id="c-37818164" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817933">parent</a><span>|</span><a href="#37818201">next</a><span>|</span><label class="collapse" for="c-37818164">[-]</label><label class="expand" for="c-37818164">[2 more]</label></div><br/><div class="children"><div class="content">But that problem exists for any C project that uses an external library. If the library defines something that the project already uses, then the project will not work.<p>In my mind that&#x27;s not a problem with the decisions taken by the author of the article, it&#x27;s more of a symptom of C&#x27;s limitations.</div><br/><div id="37818206" class="c"><input type="checkbox" id="c-37818206" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37818164">parent</a><span>|</span><a href="#37818201">next</a><span>|</span><label class="collapse" for="c-37818206">[-]</label><label class="expand" for="c-37818206">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But that problem exists for any C project that uses an external library. If the library defines something that the project already uses, then the project will not work.<p>For libraries, yes, but we&#x27;re talking about why the <i>standard</i> didn&#x27;t do it.<p>The standard <i>did not want</i>[1] to reserve keywords that current programs were already using.<p>A library that conflicts on keywords will only break with those programs that use it. A standard that conflicts on keywords breaks all programs in that language.<p>&gt; In my mind that&#x27;s not a problem with the decisions taken by the author of the article, it&#x27;s more of a symptom of C&#x27;s limitations.<p>One of the constraints of taking decisions is to work within the limits existing framework - if you&#x27;re avoiding the alternatives <i>that don&#x27;t break</i>, then it&#x27;s the decision-makers bug, not the frameworks.<p>The framework has limitations, widely published and known. You make decisions within those limitations.<p>[1] Although, they do do it, it&#x27;s only with relectance, not on a whim to avoid typing a few characters)</div><br/></div></div></div></div><div id="37818201" class="c"><input type="checkbox" id="c-37818201" checked=""/><div class="controls bullet"><span class="by">Communitivity</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817933">parent</a><span>|</span><a href="#37818164">prev</a><span>|</span><a href="#37818218">next</a><span>|</span><label class="collapse" for="c-37818201">[-]</label><label class="expand" for="c-37818201">[2 more]</label></div><br/><div class="children"><div class="content">No program should every have variables names according to [a-z][1-9]+ pattern, except perhaps loop indices - and not even then.</div><br/><div id="37818213" class="c"><input type="checkbox" id="c-37818213" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37818201">parent</a><span>|</span><a href="#37818218">next</a><span>|</span><label class="collapse" for="c-37818213">[-]</label><label class="expand" for="c-37818213">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No program should every have variables names according to [a-z][1-9]+ pattern, except perhaps loop indices - and not even then.<p>What&#x27;s that got to do with not breaking existing programs?</div><br/></div></div></div></div><div id="37818218" class="c"><input type="checkbox" id="c-37818218" checked=""/><div class="controls bullet"><span class="by">gdprrrr</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817933">parent</a><span>|</span><a href="#37818201">prev</a><span>|</span><a href="#37817818">next</a><span>|</span><label class="collapse" for="c-37818218">[-]</label><label class="expand" for="c-37818218">[2 more]</label></div><br/><div class="children"><div class="content">Typedefs and variable namens don&#x27;t live in them same namespace, do they?</div><br/><div id="37818278" class="c"><input type="checkbox" id="c-37818278" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37818218">parent</a><span>|</span><a href="#37817818">next</a><span>|</span><label class="collapse" for="c-37818278">[-]</label><label class="expand" for="c-37818278">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Typedefs and variable namens don&#x27;t live in them same namespace, do they?<p>Depends. See this snippet: <a href="https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;5T5jz47q4" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;5T5jz47q4</a><p>Cannot declare a variable called `u8` when there is a typedef of `u8`.<p>And even when you <i>can</i> declare a variable called (for example) `int`, that effectively &quot;breaks&quot; the program by not being even a tiny bit readable anymore.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37817818" class="c"><input type="checkbox" id="c-37817818" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#37816474">parent</a><span>|</span><a href="#37817473">prev</a><span>|</span><a href="#37816539">next</a><span>|</span><label class="collapse" for="c-37817818">[-]</label><label class="expand" for="c-37817818">[2 more]</label></div><br/><div class="children"><div class="content">The reality is that C `int` is 32 bits in size.<p>Sure, that&#x27;s not true for 16 bit targets. But are you really going to port a 5Mb program to 16 bits? It&#x27;s not worth worrying about. Your code is highly unlikely to be portable to 16 bits anyway.<p>The problem is with `long`, which is 32 bits on some machines and 64 bits on others. This is just madness. Fortunately, `long long` is always 64 bits, so it makes sense to just abandon `long`.<p>So there it is:<p><pre><code>    char - 8 bits
    short - 16 bits
    int - 32 bits
    long long - 64 bits
</code></pre>
Done!<p>(Sheesh, all the endless hours wasted on the size of an `int` in C.)</div><br/><div id="37817935" class="c"><input type="checkbox" id="c-37817935" checked=""/><div class="controls bullet"><span class="by">consp</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817818">parent</a><span>|</span><a href="#37816539">next</a><span>|</span><label class="collapse" for="c-37817935">[-]</label><label class="expand" for="c-37817935">[1 more]</label></div><br/><div class="children"><div class="content">Which are minima, but in practice they represent the width.</div><br/></div></div></div></div><div id="37816539" class="c"><input type="checkbox" id="c-37816539" checked=""/><div class="controls bullet"><span class="by">colejhudson</span><span>|</span><a href="#37816474">parent</a><span>|</span><a href="#37817818">prev</a><span>|</span><a href="#37817056">next</a><span>|</span><label class="collapse" for="c-37816539">[-]</label><label class="expand" for="c-37816539">[7 more]</label></div><br/><div class="children"><div class="content">I mean, being a bit glib here, but a lot of programming is dealing with someone else&#x27;s type system.<p>Moreover, for those of us who write C fairly often, the mnemonics here are familiar.<p>Actually, as custom type systems go, this one is pretty elegant. Reminds me of Rust.</div><br/><div id="37817224" class="c"><input type="checkbox" id="c-37817224" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37816539">parent</a><span>|</span><a href="#37817025">next</a><span>|</span><label class="collapse" for="c-37817224">[-]</label><label class="expand" for="c-37817224">[2 more]</label></div><br/><div class="children"><div class="content">Yeah but not for basic types. Also, most code mingles sooner or later with other code. Than this is just ugly.</div><br/><div id="37818122" class="c"><input type="checkbox" id="c-37818122" checked=""/><div class="controls bullet"><span class="by">circuit10</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817224">parent</a><span>|</span><a href="#37817025">next</a><span>|</span><label class="collapse" for="c-37818122">[-]</label><label class="expand" for="c-37818122">[1 more]</label></div><br/><div class="children"><div class="content">It’s better than dealing with needlessly long type names like uint32_t though</div><br/></div></div></div></div><div id="37817025" class="c"><input type="checkbox" id="c-37817025" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37816539">parent</a><span>|</span><a href="#37817224">prev</a><span>|</span><a href="#37817056">next</a><span>|</span><label class="collapse" for="c-37817025">[-]</label><label class="expand" for="c-37817025">[4 more]</label></div><br/><div class="children"><div class="content">Speaking of type systems, I read glib as g-lib a few times and tried to understand how you were talking about the GNU lib in that sentence.</div><br/><div id="37817528" class="c"><input type="checkbox" id="c-37817528" checked=""/><div class="controls bullet"><span class="by">zombot</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817025">parent</a><span>|</span><a href="#37817056">next</a><span>|</span><label class="collapse" for="c-37817528">[-]</label><label class="expand" for="c-37817528">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t that have to be `glibc`?</div><br/><div id="37818028" class="c"><input type="checkbox" id="c-37818028" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817528">parent</a><span>|</span><a href="#37817809">next</a><span>|</span><label class="collapse" for="c-37818028">[-]</label><label class="expand" for="c-37818028">[1 more]</label></div><br/><div class="children"><div class="content">It is unfortunate that the two have such similar names because there&#x27;s a lot of room for confusion. It doesn&#x27;t help that they have somewhat adjacent functionality almost.</div><br/></div></div><div id="37817809" class="c"><input type="checkbox" id="c-37817809" checked=""/><div class="controls bullet"><span class="by">slondr</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817528">parent</a><span>|</span><a href="#37818028">prev</a><span>|</span><a href="#37817056">next</a><span>|</span><label class="collapse" for="c-37817809">[-]</label><label class="expand" for="c-37817809">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;GLib?wprov=sfti1" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;GLib?wprov=sfti1</a></div><br/></div></div></div></div></div></div></div></div><div id="37817056" class="c"><input type="checkbox" id="c-37817056" checked=""/><div class="controls bullet"><span class="by">petabytes</span><span>|</span><a href="#37816474">parent</a><span>|</span><a href="#37816539">prev</a><span>|</span><a href="#37818162">next</a><span>|</span><label class="collapse" for="c-37817056">[-]</label><label class="expand" for="c-37817056">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty much the same types you see in Rust or Zig, and I think Linux even uses some of the same types.</div><br/><div id="37817226" class="c"><input type="checkbox" id="c-37817226" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817056">parent</a><span>|</span><a href="#37818162">next</a><span>|</span><label class="collapse" for="c-37817226">[-]</label><label class="expand" for="c-37817226">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and C&#x2F;C++ has these since three times the age of Rust. I also find them beautiful but not consistent.</div><br/></div></div></div></div><div id="37818162" class="c"><input type="checkbox" id="c-37818162" checked=""/><div class="controls bullet"><span class="by">Nursie</span><span>|</span><a href="#37816474">parent</a><span>|</span><a href="#37817056">prev</a><span>|</span><a href="#37816492">next</a><span>|</span><label class="collapse" for="c-37818162">[-]</label><label class="expand" for="c-37818162">[1 more]</label></div><br/><div class="children"><div class="content">&gt; These types should be defined in the right header<p>stdint.h<p>It&#x27;s always been amazing to me how many different projects I&#x27;ve worked on (not that I&#x27;ve been in professional C for about 7 years now)) that include their own painstaking recreation of this file.<p>Reusing them and effectively translating them just to your own name is just annoying to the reader IMHO. I am reminded of a C++ project I worked on, where I questioned the extensive use of typedefs around collections of things, various forms of references and compound objects etc. I was informed by one of the more experienced C++ folks that it made the code easier to comprehend.<p>Later I saw the typedef cheat-sheet sellotaped to the side of his monitor...</div><br/></div></div><div id="37816492" class="c"><input type="checkbox" id="c-37816492" checked=""/><div class="controls bullet"><span class="by">voxl</span><span>|</span><a href="#37816474">parent</a><span>|</span><a href="#37818162">prev</a><span>|</span><a href="#37816047">next</a><span>|</span><label class="collapse" for="c-37816492">[-]</label><label class="expand" for="c-37816492">[11 more]</label></div><br/><div class="children"><div class="content">they&#x27;re not quirky types in the least...</div><br/><div id="37817156" class="c"><input type="checkbox" id="c-37817156" checked=""/><div class="controls bullet"><span class="by">outsomnia</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37816492">parent</a><span>|</span><a href="#37817795">next</a><span>|</span><label class="collapse" for="c-37817156">[-]</label><label class="expand" for="c-37817156">[3 more]</label></div><br/><div class="children"><div class="content">In isolation, they&#x27;re not crazy.<p>But much C code is bringing in library headers which contain their author&#x27;s own pet choices for these, which inevitably are not the same and the result is extremely confusing when you have that in play as well as the stdint.h ones.<p>The kernel contains a mixture of &quot;pet&quot; types like u32 and stdint ones, it&#x27;s already confusing.<p>He also does make a &quot;crazy&quot; choice later to call his string class &quot;s8&quot; which clashes with his nomenclature here.</div><br/><div id="37817609" class="c"><input type="checkbox" id="c-37817609" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817156">parent</a><span>|</span><a href="#37817795">next</a><span>|</span><label class="collapse" for="c-37817609">[-]</label><label class="expand" for="c-37817609">[2 more]</label></div><br/><div class="children"><div class="content">&gt; which clashes with his nomenclature here.<p>How?</div><br/><div id="37817911" class="c"><input type="checkbox" id="c-37817911" checked=""/><div class="controls bullet"><span class="by">asalahli</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817609">parent</a><span>|</span><a href="#37817795">next</a><span>|</span><label class="collapse" for="c-37817911">[-]</label><label class="expand" for="c-37817911">[1 more]</label></div><br/><div class="children"><div class="content">Because it can be mistaken for 8-bit signed integer.</div><br/></div></div></div></div></div></div><div id="37817795" class="c"><input type="checkbox" id="c-37817795" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37816492">parent</a><span>|</span><a href="#37817156">prev</a><span>|</span><a href="#37816627">next</a><span>|</span><label class="collapse" for="c-37817795">[-]</label><label class="expand" for="c-37817795">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they&#x27;re not quirky types in the least...<p>But they <i>are</i> buggy (correct code cannot depend on the sign of `char`), which is usually the result of typedefing primitive types to save typing 3 characters on each use.</div><br/></div></div><div id="37816627" class="c"><input type="checkbox" id="c-37816627" checked=""/><div class="controls bullet"><span class="by">guidoism</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37816492">parent</a><span>|</span><a href="#37817795">prev</a><span>|</span><a href="#37816047">next</a><span>|</span><label class="collapse" for="c-37816627">[-]</label><label class="expand" for="c-37816627">[6 more]</label></div><br/><div class="children"><div class="content">I agree. A lot of languages have settled on those same names or something similar. We don’t live in a world with a single word size anymore so carrying bit length in the name is critical, and so is keeping identifier names short. His trade off is exactly the one I would make.</div><br/><div id="37817836" class="c"><input type="checkbox" id="c-37817836" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37816627">parent</a><span>|</span><a href="#37816047">next</a><span>|</span><label class="collapse" for="c-37817836">[-]</label><label class="expand" for="c-37817836">[5 more]</label></div><br/><div class="children"><div class="content">&gt; carrying bit length in the name is critical<p>I beg to disagree. In D:<p><pre><code>    byte - 8 bits
    short - 16 bits
    int - 32 bits
    long - 64 bits
</code></pre>
absolutely nobody is confused about this.</div><br/><div id="37817932" class="c"><input type="checkbox" id="c-37817932" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817836">parent</a><span>|</span><a href="#37818191">next</a><span>|</span><label class="collapse" for="c-37817932">[-]</label><label class="expand" for="c-37817932">[3 more]</label></div><br/><div class="children"><div class="content">Because we&#x27;ve used those names since forever, but that&#x27;s archaic random crap really. Nothing apart from maybe &quot;byte&quot; makes sense here, the rest is completely arbitrary historic cruft. Could as well have called the rest timmy, britney and hulk.</div><br/><div id="37818178" class="c"><input type="checkbox" id="c-37818178" checked=""/><div class="controls bullet"><span class="by">runiq</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817932">parent</a><span>|</span><a href="#37818234">next</a><span>|</span><label class="collapse" for="c-37818178">[-]</label><label class="expand" for="c-37818178">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nothing apart from maybe &quot;byte&quot; makes sense here<p>Lest we forget: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20170403130829&#x2F;http:&#x2F;&#x2F;www.bobbemer.com&#x2F;BYTE.HTM" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20170403130829&#x2F;http:&#x2F;&#x2F;www.bobbem...</a></div><br/></div></div><div id="37818234" class="c"><input type="checkbox" id="c-37818234" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817932">parent</a><span>|</span><a href="#37818178">prev</a><span>|</span><a href="#37818191">next</a><span>|</span><label class="collapse" for="c-37818234">[-]</label><label class="expand" for="c-37818234">[1 more]</label></div><br/><div class="children"><div class="content">Java uses exactly the same, and has a huge developer mindshare. While rooted in historic accidents, it&#x27;s well-established.</div><br/></div></div></div></div><div id="37818191" class="c"><input type="checkbox" id="c-37818191" checked=""/><div class="controls bullet"><span class="by">another2another</span><span>|</span><a href="#37816474">root</a><span>|</span><a href="#37817836">parent</a><span>|</span><a href="#37817932">prev</a><span>|</span><a href="#37816047">next</a><span>|</span><label class="collapse" for="c-37818191">[-]</label><label class="expand" for="c-37818191">[1 more]</label></div><br/><div class="children"><div class="content">In that case D should probably start to have an internal conversation about what they&#x27;re going to call 128 bits then, &#x27;cause its going to become a thing sooner or later.<p>stdint already has that covered though: (u)int128_t</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37816047" class="c"><input type="checkbox" id="c-37816047" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37816474">prev</a><span>|</span><a href="#37816764">next</a><span>|</span><label class="collapse" for="c-37816047">[-]</label><label class="expand" for="c-37816047">[10 more]</label></div><br/><div class="children"><div class="content">&gt; #define sizeof(x)    (size)sizeof(x)<p>I&#x27;m guessing this is lacking an outer pair of parentheses (i.e. it&#x27;s not `((size)sizeof(x))`) on the grounds that they&#x27;re unnecessary.  In terms of operator precedence, casting binds tightly, so if you write e.g. `sizeof(x) * 3`, it expands to `(size)sizeof(x) * 3`, which is equivalent to `((size)sizeof(x)) * 3`: the cast happens before the multiplication.  Indeed, casting binds more tightly than anything that could appear on the right of sizeof(x) – with one exception which is completely trivial.<p>But just for fun, I&#x27;ll point out the exception.  It&#x27;s this:<p><pre><code>    (size)sizeof(x)[y]
</code></pre>
Indexing binds more tightly than casting, so the indexing happens before the cast. 
 In other words, it&#x27;s equivalent to `(size)(sizeof(x)[y])`, not `((size)sizeof(x))[y]`.<p>But you would never see that in a real program, since the size of something is not a pointer or array that can be indexed.  Except that technically, C allows you to write integer[pointer], with the same meaning as pointer[integer].  Not that anyone ever writes code like that intentionally.  But you could.  And if you do, it will compile and do the wrong thing, thanks to the macro lacking the extra parentheses.<p>…On a more substantive note, I quite disagree with the claim that signed sizes are better.  If you click through to the previous arena allocator post, the author says that unsigned sizes are a &quot;source of defects&quot; and in particular the code he presents would have a defect if you changed the signed types to unsigned.  Which is true – but the code as presented <i>also</i> has a bug!  Namely, it will corrupt memory if `count` is negative.  You could argue that the code is correct as long as the arguments are valid, but it&#x27;s very easy for overflow elsewhere in the code to make something accidentally go negative, so it&#x27;s better for an allocator not to exacerbate the issue.<p>With unsigned integers, a negative count is not even representable, and a similar overflow elsewhere in the program would instead give you an extremely high positive count, which the code already checks for.<p>Personally I prefer to use unsigned integers but do as much as possible with bounds-checked wrappers that abort on overflow.  Rarely does the performance difference actually matter.</div><br/><div id="37816236" class="c"><input type="checkbox" id="c-37816236" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37816047">parent</a><span>|</span><a href="#37818212">next</a><span>|</span><label class="collapse" for="c-37816236">[-]</label><label class="expand" for="c-37816236">[6 more]</label></div><br/><div class="children"><div class="content">(self-reply) One more thing.<p>&gt; I could use _Bool, but I’d rather stick to a natural word size and stay away from its weird semantics.<p>This is even more subjective, but personally I like _Bool&#x27;s semantics.  They mean that if an expression works in an `if` statement:<p><pre><code>    if (flags &amp; FLAG_ALLOCATED)
</code></pre>
then you can extract that same expression into a boolean variable:<p><pre><code>    _Bool need_free = flags &amp; FLAG_ALLOCATED;
</code></pre>
The issue is that `flags &amp; FLAG_ALLOCATED` doesn&#x27;t equal &#x27;0 if unset, 1 if set&#x27;, but &#x27;0 if unset, some arbitrary nonzero value if set&#x27;.  (Specifically it equals FLAG_ALLOCATED if set, which might be 1 by coincidence, but usually isn&#x27;t.)  This kind of punning is fine in an `if` statement, since any nonzero value will make the check pass.  And it&#x27;s fine as written with `_Bool`, since any nonzero integer will be converted to 1 when the expression is implicitly converted to `_Bool`.  But if you replace `_Bool` with `int`, then this neither-0-nor-1 value will just stick around in the variable.  Which can cause strange consequences.  It means that<p><pre><code>    if (need_free)
</code></pre>
will pass, but<p><pre><code>    if (need_free == true)
</code></pre>
will fail.  And if you have another pseudo-bool, then<p><pre><code>    if (need_free == some_other_bool)
</code></pre>
might fail even if both variables are considered &#x27;true&#x27; (i.e. nonzero), if they happen to have different values.<p>_Bool solves this problem.  Admittedly, the implicitness has downsides.  If you&#x27;re refactoring the code and you decide you don&#x27;t really need a separate variable, you might try to replace all uses of `need_free` with its definition, not realizing that the implicit conversion to _Bool was doing useful work.  So you might end up with incorrect code like:<p><pre><code>    if ((flags &amp; FLAG_ALLOCATED) == true)
</code></pre>
Also, if you are reading a struct from disk or otherwise stuffing it with arbitrary bytes, and the struct has a _Bool, then you risk undefined behavior if the corresponding byte becomes something other than 0 or 1 – because the compiler assumes that the implicit conversion to 0 or 1 has been done already.</div><br/><div id="37816844" class="c"><input type="checkbox" id="c-37816844" checked=""/><div class="controls bullet"><span class="by">billforsternz</span><span>|</span><a href="#37816047">root</a><span>|</span><a href="#37816236">parent</a><span>|</span><a href="#37816706">next</a><span>|</span><label class="collapse" for="c-37816844">[-]</label><label class="expand" for="c-37816844">[4 more]</label></div><br/><div class="children"><div class="content">This is all very good and very, ahem, true. But (and it&#x27;s a big butt);<p>if (need_free == true)<p>Is such a horrible code smell to me. You have a perfectly good boolean. Why compare it to a second boolean to get a third boolean?<p>if (need_free)<p>or<p>if (!need_free)<p>for the opposite case is so much better.<p>I will admit that in my world this leaves<p>if (need_free == some_other_bool)<p>as something I don&#x27;t have a particularly comfortable way of doing safely.</div><br/><div id="37818370" class="c"><input type="checkbox" id="c-37818370" checked=""/><div class="controls bullet"><span class="by">hun3</span><span>|</span><a href="#37816047">root</a><span>|</span><a href="#37816844">parent</a><span>|</span><a href="#37817446">next</a><span>|</span><label class="collapse" for="c-37818370">[-]</label><label class="expand" for="c-37818370">[1 more]</label></div><br/><div class="children"><div class="content">Better example:<p><pre><code>  #define FLAG_63 (1ULL &lt;&lt; 63)
  long long flags = FLAG_63;
</code></pre>
In this case,<p><pre><code>  if (flags &amp; FLAG_63) pass();
</code></pre>
will pass, but<p><pre><code>  typedef int BOOL;
  BOOL set = flags &amp; FLAG_63;
  if (set) pass();
</code></pre>
won&#x27;t pass, due to truncation.<p>Question: Would you argue that a datatype that holds the <i>smallest</i> (1-bit) datum should be as wide as the largest integer type <i>just</i> to handle such cases?<p>If so, that would be highly inefficient for storage purposes. Note that Win32 has 32-bit BOOL type, but internally NT uses 8-bit BOOLEAN type to store bools in structures.</div><br/></div></div><div id="37817446" class="c"><input type="checkbox" id="c-37817446" checked=""/><div class="controls bullet"><span class="by">MilanTodorovic</span><span>|</span><a href="#37816047">root</a><span>|</span><a href="#37816844">parent</a><span>|</span><a href="#37818370">prev</a><span>|</span><a href="#37816706">next</a><span>|</span><label class="collapse" for="c-37817446">[-]</label><label class="expand" for="c-37817446">[2 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t we do it like (!need_free == !some_other_bool)?</div><br/><div id="37818137" class="c"><input type="checkbox" id="c-37818137" checked=""/><div class="controls bullet"><span class="by">mariusor</span><span>|</span><a href="#37816047">root</a><span>|</span><a href="#37817446">parent</a><span>|</span><a href="#37816706">next</a><span>|</span><label class="collapse" for="c-37818137">[-]</label><label class="expand" for="c-37818137">[1 more]</label></div><br/><div class="children"><div class="content">You can go the php way and do if (!!need_free)</div><br/></div></div></div></div></div></div><div id="37816706" class="c"><input type="checkbox" id="c-37816706" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#37816047">root</a><span>|</span><a href="#37816236">parent</a><span>|</span><a href="#37816844">prev</a><span>|</span><a href="#37818212">next</a><span>|</span><label class="collapse" for="c-37816706">[-]</label><label class="expand" for="c-37816706">[1 more]</label></div><br/><div class="children"><div class="content">I always just use !! for this case.</div><br/></div></div></div></div><div id="37818212" class="c"><input type="checkbox" id="c-37818212" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37816047">parent</a><span>|</span><a href="#37816236">prev</a><span>|</span><a href="#37816164">next</a><span>|</span><label class="collapse" for="c-37818212">[-]</label><label class="expand" for="c-37818212">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (size)(sizeof(x)[y])<p>Actually, and this is probably surprising to many, this is equivalent to<p><pre><code>    (size)(sizeof ((x)[y]))
</code></pre>
sizeof is not a function but a unary operator, and indexing (as well as function calling...) binds stronger than the sizeof operator. It is not a function, not even syntactically! Hence why I strongly prefer putting a space after the sizeof keyword, and to not use parens for the operand unless needed.<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;operator_precedence" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;operator_precedence</a><p>So the &quot;correct&quot; way to define the macro is<p>#define sizeof(x) ((size)(sizeof (x)))</div><br/></div></div><div id="37816164" class="c"><input type="checkbox" id="c-37816164" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#37816047">parent</a><span>|</span><a href="#37818212">prev</a><span>|</span><a href="#37816764">next</a><span>|</span><label class="collapse" for="c-37816164">[-]</label><label class="expand" for="c-37816164">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good catch. The moral of the story is that unless your macro definition expands to a single token (e.g #define X 123) you should always, always, always surround it with parenthesis. Because C&#x27;s precedence rules are damn complicated.</div><br/><div id="37818217" class="c"><input type="checkbox" id="c-37818217" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#37816047">root</a><span>|</span><a href="#37816164">parent</a><span>|</span><a href="#37816764">next</a><span>|</span><label class="collapse" for="c-37818217">[-]</label><label class="expand" for="c-37818217">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because C&#x27;s precedence rules are damn complicated.<p>This particular part is not actually complicated: postfix operator bind the most tightly, then the prefix ones, then the infix ones. (The last part is quite messy, though.)<p>So (int)x[y] parses the same way as, for example, *p++, which should be familliar to a C programmer.</div><br/></div></div></div></div></div></div><div id="37816764" class="c"><input type="checkbox" id="c-37816764" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#37816047">prev</a><span>|</span><a href="#37818030">next</a><span>|</span><label class="collapse" for="c-37816764">[-]</label><label class="expand" for="c-37816764">[7 more]</label></div><br/><div class="children"><div class="content">I wrote and still maintain an open source C project for 20+ years. Once a year I get a new guy coming in and telling me I am doing it wrong: you should typedef all data types, you should stop using const, and so on. It stopped being funny after the first couple times.</div><br/><div id="37816901" class="c"><input type="checkbox" id="c-37816901" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#37816764">parent</a><span>|</span><a href="#37818270">next</a><span>|</span><label class="collapse" for="c-37816901">[-]</label><label class="expand" for="c-37816901">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m getting an &quot;I don&#x27;t use const, and here&#x27;s my view on it&quot; vibe from the author much more than &quot;you shouldn&#x27;t use const&quot;. I&#x27;m really not getting any demand that you change your coding style, just someone reflecting on their work and explaining it to others. And... Whether I agree with their choices or not, I find that very cool and informative.</div><br/><div id="37816980" class="c"><input type="checkbox" id="c-37816980" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#37816764">root</a><span>|</span><a href="#37816901">parent</a><span>|</span><a href="#37817166">next</a><span>|</span><label class="collapse" for="c-37816980">[-]</label><label class="expand" for="c-37816980">[1 more]</label></div><br/><div class="children"><div class="content">And, he also says &quot;I’m not saying everyone should write C this way, and when I contribute code to a project I follow their local style.&quot;</div><br/></div></div><div id="37817166" class="c"><input type="checkbox" id="c-37817166" checked=""/><div class="controls bullet"><span class="by">outsomnia</span><span>|</span><a href="#37816764">root</a><span>|</span><a href="#37816901">parent</a><span>|</span><a href="#37816980">prev</a><span>|</span><a href="#37818270">next</a><span>|</span><label class="collapse" for="c-37817166">[-]</label><label class="expand" for="c-37817166">[2 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t clear to me if he&#x27;s talking about const as a variable declaration qualifier - I never used it - or const in pointer types, which is very useful.</div><br/><div id="37818286" class="c"><input type="checkbox" id="c-37818286" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37816764">root</a><span>|</span><a href="#37817166">parent</a><span>|</span><a href="#37818270">next</a><span>|</span><label class="collapse" for="c-37818286">[-]</label><label class="expand" for="c-37818286">[1 more]</label></div><br/><div class="children"><div class="content">For me it&#x27;s the other way around -- I use const for global variables because it makes a real difference, the data will be put in a .ro section.<p>Pointer-to-const on the other hand (as in &quot;const Foo *x&quot;) is a bit of a fluff and it spreads like cancer. I agree with the author that const is a waste of time. And it breaks in situations like showcased by <i>strstr()</i>.<p>I use pointer-to-const in function parameter lists though (most of the time it does not actually break like in strstr()): as documentation, and to be compatible with code that zealously attaches const everywhere where there (currently) is no need to mutate.<p>But overall my use of const is very very little and I generally do not waste my time (anymore) with it. I almost never have to use &quot;const casts&quot; so I suppose I can manage to keep it in check. In C++ it is a bit worse, when implementing interfaces, like const_iterator etc. That requires annotating constness much more religiously, and that can lead to quite a bit of cruft and repetition.</div><br/></div></div></div></div></div></div><div id="37818270" class="c"><input type="checkbox" id="c-37818270" checked=""/><div class="controls bullet"><span class="by">rewgs</span><span>|</span><a href="#37816764">parent</a><span>|</span><a href="#37816901">prev</a><span>|</span><a href="#37818030">next</a><span>|</span><label class="collapse" for="c-37818270">[-]</label><label class="expand" for="c-37818270">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a C developer, so I have to ask: why in the world would you not use const?</div><br/><div id="37818351" class="c"><input type="checkbox" id="c-37818351" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37816764">root</a><span>|</span><a href="#37818270">parent</a><span>|</span><a href="#37818030">next</a><span>|</span><label class="collapse" for="c-37818351">[-]</label><label class="expand" for="c-37818351">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more work. Not only to put all the annotations correctly, but only because it causes some real headaches. It&#x27;s easy (implicit) to transition from non-const to const 1 pointer level deep. But the other way around -- it&#x27;s really awkward to &quot;remove&quot; a const.<p>The strstr() signature is probably the shortest example &#x2F; explanation why. To implement strstr(), you have to hack the const away to create the return value. Alternatively, create a mutable_strstr() variant that does the exact same thing. This is the kind of boilerplate that we don&#x27;t want in C (and that C is bad at generating automatically).<p>Think about it this way: Real const data doesn&#x27;t exist. It always gets created (written) somewhere, and usually removed later. One way where this works cleanly is where the data is created at compile time, so the data can be &quot;truly&quot; const, and be put in .ro section, and automatically destroyed when the process terminates. But often, we have situations where some part of the code needs to mutate the data that is only consumed as read only by other parts of the code. One man&#x27;s const data is another man&#x27;s mutable data.<p>In C, the support for making this transition work fluently is just very limited (but I think it&#x27;s not great in most other languages, either).</div><br/></div></div></div></div></div></div><div id="37818030" class="c"><input type="checkbox" id="c-37818030" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#37816764">prev</a><span>|</span><a href="#37815841">next</a><span>|</span><label class="collapse" for="c-37818030">[-]</label><label class="expand" for="c-37818030">[1 more]</label></div><br/><div class="children"><div class="content">The notion of &quot;personal style&quot; is problematic, even for hobby projects, because (good) programming is ultimately a social activity.<p>Even Linux started as a personal project, but because of its quality and the need it met it quickly spread. So please write your code in such a way that experienced other C programmers can read it easily.<p>In isolation, I like some of his ideas, but some issues with C remain, and he is perhaps just to comfortable with C to jump ship and embrace Rust, which has many things he likes and more (e.g. no buffer overflows by design).</div><br/></div></div><div id="37815841" class="c"><input type="checkbox" id="c-37815841" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#37818030">prev</a><span>|</span><a href="#37815744">next</a><span>|</span><label class="collapse" for="c-37815841">[-]</label><label class="expand" for="c-37815841">[22 more]</label></div><br/><div class="children"><div class="content">&gt; To beginners it might seem like “wasting memory” by using a 32-bit boolean<p>Maybe I&#x27;m a beginner then. He lists a few cases where it&#x27;s not worse than sticking to 8-bit bools, but no cases where it&#x27;s actually an improvement. It still wastes memory sometimes, e.g. if you have adjacent booleans in a struct, or boolean variables in a function that spill out of registers onto the stack. Sure it&#x27;s only a few bytes here and there, but why pessimize? What do you gain from using a larger size?</div><br/><div id="37815931" class="c"><input type="checkbox" id="c-37815931" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#37815841">parent</a><span>|</span><a href="#37815956">next</a><span>|</span><label class="collapse" for="c-37815931">[-]</label><label class="expand" for="c-37815931">[16 more]</label></div><br/><div class="children"><div class="content">It depends <i>entirely</i> on the architectures | CPUs, that said the obvious case from past experience is numeric processsing jobs where (say) you flow data into &quot;per cycle&quot; structs that lead with some conditionals and fill out with (say) 512 | 1024 | 2048 sample points for that cycle (32 or 64 bit ints or floats) .. the &#x27;meat&#x27; of the per cycle job.<p>My specific bug bear here was a junior who <i>insisted</i> &quot;saving space&quot; by packing the structs and using a single 8 bit byte for the conditionals.<p>Their &#x27;improved&#x27; code ground throughput on intel chips by a factor of 10 or so and generated BUS ERRORs on SPARC RISC architectures.<p>By packing the header of the structs they misaligned the array of data values such that the intel chips were silently fetching two 32 bit words (say) to get half a word from each to splice together to form a 32 bit data value (that was passed straddling a word boundary) to pipe into the ALU and then do something similar to repack on the other end - SPARC&#x27;s quite sensibly were throwing a fit at non aligned data.<p>Point being - <i>sometimes</i> it makes sense to fit data to the architecture and not pack data to &quot;save&quot; space (this is all for throughput piped calculations not long term file storage in any case)</div><br/><div id="37815974" class="c"><input type="checkbox" id="c-37815974" checked=""/><div class="controls bullet"><span class="by">xvedejas</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37815931">parent</a><span>|</span><a href="#37817750">next</a><span>|</span><label class="collapse" for="c-37815974">[-]</label><label class="expand" for="c-37815974">[11 more]</label></div><br/><div class="children"><div class="content">This is the use case for `uint_fast8_t` (part of the C99 standard); it should use whatever width of unsigned integer is enough to store a byte, but fastest for the platform. You always know that the type can be serialized as 8 bits, but it might be larger in memory. So long as you don&#x27;t assume too much about your struct sizes across platforms, it should be a good choice for this. Although, if alignment is an issue, it might be a bit more complicated depending on platform.</div><br/><div id="37816308" class="c"><input type="checkbox" id="c-37816308" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37815974">parent</a><span>|</span><a href="#37817750">next</a><span>|</span><label class="collapse" for="c-37816308">[-]</label><label class="expand" for="c-37816308">[10 more]</label></div><br/><div class="children"><div class="content">10 years ago when ATmegas were still around and your 32 bit variable was generating 3 instructions for addition I would say „right on“ but now everything is a 32 bit Cortex-M and please stop polluting your code with this nonsense</div><br/><div id="37816532" class="c"><input type="checkbox" id="c-37816532" checked=""/><div class="controls bullet"><span class="by">xvedejas</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816308">parent</a><span>|</span><a href="#37816651">next</a><span>|</span><label class="collapse" for="c-37816532">[-]</label><label class="expand" for="c-37816532">[7 more]</label></div><br/><div class="children"><div class="content">Please understand, I am still in a position where I am writing new code for a platform which only has one compiler, a proprietary fork of GCC from nearly 20 years ago. I assume other C programmers might have similar situations.</div><br/><div id="37816714" class="c"><input type="checkbox" id="c-37816714" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816532">parent</a><span>|</span><a href="#37816651">next</a><span>|</span><label class="collapse" for="c-37816714">[-]</label><label class="expand" for="c-37816714">[6 more]</label></div><br/><div class="children"><div class="content">&gt; a proprietary fork of GCC<p>A what now?</div><br/><div id="37816806" class="c"><input type="checkbox" id="c-37816806" checked=""/><div class="controls bullet"><span class="by">CapsAdmin</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816714">parent</a><span>|</span><a href="#37817065">next</a><span>|</span><label class="collapse" for="c-37816806">[-]</label><label class="expand" for="c-37816806">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s not a GPL violation if you keep the fork non-public.<p>Though I&#x27;m entirely sure not when something is considered private or public. You can obviously make changes to a GPL repo, compile it and run the executable yourself and just never release the source code.<p>But what happens when you start sharing the executable with your friends, or confine it to a company?<p>&quot;I made this GCC fork with some awesome features. You can contact me at joe@gmail.com if you&#x27;re intere$ted ;)&quot;</div><br/><div id="37817590" class="c"><input type="checkbox" id="c-37817590" checked=""/><div class="controls bullet"><span class="by">rowyourboat</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816806">parent</a><span>|</span><a href="#37816967">next</a><span>|</span><label class="collapse" for="c-37817590">[-]</label><label class="expand" for="c-37817590">[1 more]</label></div><br/><div class="children"><div class="content">All the GPL says on source code access is that you need to make the source code available to whoever you distributed your program to. If the program never leaves a closed circle of people, neither does the source code.</div><br/></div></div><div id="37816967" class="c"><input type="checkbox" id="c-37816967" checked=""/><div class="controls bullet"><span class="by">bdw5204</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816806">parent</a><span>|</span><a href="#37817590">prev</a><span>|</span><a href="#37817567">next</a><span>|</span><label class="collapse" for="c-37816967">[-]</label><label class="expand" for="c-37816967">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that the GPL only requires the source code to be made available <i>on request</i> for at least 3 years (or as long as you support the software, if more than 3 years). If you want to require people who want the source to write to you via the Post Office and pay shipping+handling+cost of a disc to receive the source code, I believe this is permitted by the GPL as long as you don&#x27;t profit off of the cost.<p>Of course, for almost all practical cases, the source code for a GPLed program is made available as a download off the Internet because the mail order disc route seems really archaic these days and probably would be removed altogether in a GPL version 4 if some prominent company used this loophole to evade the spirit of the GPL. Either that or somebody would jump through your hoops to get the source and just stick it on a public GitHub repo. If you then DMCA that repo, you&#x27;d be in violation of the GPL.<p>If you share an GPLed executable with your friends or with other people at a  company, then they&#x27;d presumably be able to request the source code. But if you run a Cloud GCC service with your fork, you could get away with keeping your source code proprietary because GCC isn&#x27;t under AGPL.</div><br/></div></div><div id="37817567" class="c"><input type="checkbox" id="c-37817567" checked=""/><div class="controls bullet"><span class="by">rags2riches</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816806">parent</a><span>|</span><a href="#37816967">prev</a><span>|</span><a href="#37817065">next</a><span>|</span><label class="collapse" for="c-37817567">[-]</label><label class="expand" for="c-37817567">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is the violation happens when you share the binary without the license and sources, or information on how to request the sources.</div><br/></div></div></div></div><div id="37817065" class="c"><input type="checkbox" id="c-37817065" checked=""/><div class="controls bullet"><span class="by">Cerium</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816714">parent</a><span>|</span><a href="#37816806">prev</a><span>|</span><a href="#37816651">next</a><span>|</span><label class="collapse" for="c-37817065">[-]</label><label class="expand" for="c-37817065">[1 more]</label></div><br/><div class="children"><div class="content">For example, Microchip XC16 [1]. It is GCC with changes to support their PIC processors. Some of the changes introduce bugs, for example (at least as of v1.31) the linker would copy the input linker script to a temporary location while handling includes or other pre-processor macros in the linker script. Of course if you happen to run two instances at exactly the same time one of them fails.<p>As far as the licensing part goes they give you the source code, but last time I tried I could not get it to compile. Kind of lame and sketchy in my opinion.<p>[1] <a href="https:&#x2F;&#x2F;www.microchip.com&#x2F;en-us&#x2F;tools-resources&#x2F;develop&#x2F;mplab-xc-compilers" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microchip.com&#x2F;en-us&#x2F;tools-resources&#x2F;develop&#x2F;mpla...</a></div><br/></div></div></div></div></div></div><div id="37816651" class="c"><input type="checkbox" id="c-37816651" checked=""/><div class="controls bullet"><span class="by">seabird</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816308">parent</a><span>|</span><a href="#37816532">prev</a><span>|</span><a href="#37816416">next</a><span>|</span><label class="collapse" for="c-37816651">[-]</label><label class="expand" for="c-37816651">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Everything is 32-bit Cortex-M&quot; isn&#x27;t true and it&#x27;s not even close.</div><br/></div></div><div id="37816416" class="c"><input type="checkbox" id="c-37816416" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816308">parent</a><span>|</span><a href="#37816651">prev</a><span>|</span><a href="#37817750">next</a><span>|</span><label class="collapse" for="c-37816416">[-]</label><label class="expand" for="c-37816416">[1 more]</label></div><br/><div class="children"><div class="content">IDK it seems semantically right</div><br/></div></div></div></div></div></div><div id="37817750" class="c"><input type="checkbox" id="c-37817750" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37815931">parent</a><span>|</span><a href="#37815974">prev</a><span>|</span><a href="#37816059">next</a><span>|</span><label class="collapse" for="c-37817750">[-]</label><label class="expand" for="c-37817750">[1 more]</label></div><br/><div class="children"><div class="content">At one point a loooooong time ago we said &quot;let&#x27;s give every struct its own page&quot; as a joke but... holy crap, it was so much faster.</div><br/></div></div><div id="37816059" class="c"><input type="checkbox" id="c-37816059" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37815931">parent</a><span>|</span><a href="#37817750">prev</a><span>|</span><a href="#37815956">next</a><span>|</span><label class="collapse" for="c-37816059">[-]</label><label class="expand" for="c-37816059">[3 more]</label></div><br/><div class="children"><div class="content">But if you don&#x27;t use packed attributes, then the compiler will still add padding as necessary to avoid misalignment, while not wasting space when that&#x27;s not necessary.</div><br/><div id="37816181" class="c"><input type="checkbox" id="c-37816181" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816059">parent</a><span>|</span><a href="#37817477">next</a><span>|</span><label class="collapse" for="c-37816181">[-]</label><label class="expand" for="c-37816181">[1 more]</label></div><br/><div class="children"><div class="content">The key part (for myself) of ForkMeOnTinder&#x27;s comment was:<p>&gt; Maybe I&#x27;m a beginner then. He lists a few cases where it&#x27;s not worse than sticking to 8-bit bools, but no cases where it&#x27;s actually an improvement. It still wastes memory sometimes<p>They key part of my response is <i>sometimes</i> &quot;wasting memory&quot; (to gain alignment) is a good thing.<p>If someone, a beginner, is concerned about percieved wasted memory then of course they will use &quot;packed&quot;.<p>As for the guts of your comment, I agree with your sentiment but would exercise caution about <i>expecting</i> a compiler to do what you expect in practice - <i>especially</i> for cross architectural projects that are intended to be robust for a decade and more - code will be put through muliple compilers across multiple architectures and potentially many many flags will be appied that may conflict in unforseen ways with each other.<p>In general I supported the notion of sanity check routines that double check assumptions at runtime, if you want data aligned, require data to be big endian or small endian etc then have some runtime sanity checks that can verify this for specific executables on the target platform</div><br/></div></div><div id="37817477" class="c"><input type="checkbox" id="c-37817477" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37816059">parent</a><span>|</span><a href="#37816181">prev</a><span>|</span><a href="#37815956">next</a><span>|</span><label class="collapse" for="c-37817477">[-]</label><label class="expand" for="c-37817477">[1 more]</label></div><br/><div class="children"><div class="content">If you have three chars next to each other in a struct, there&#x27;s a good chance they&#x27;ll take 4 bytes of memory due to padding. 4 32-bit bools guarantee it&#x27;ll take 12 at least, if not 16.</div><br/></div></div></div></div></div></div><div id="37815956" class="c"><input type="checkbox" id="c-37815956" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#37815841">parent</a><span>|</span><a href="#37815931">prev</a><span>|</span><a href="#37815897">next</a><span>|</span><label class="collapse" for="c-37815956">[-]</label><label class="expand" for="c-37815956">[1 more]</label></div><br/><div class="children"><div class="content">Most of the time an easy optimization is to pad fields of your struct to a 32 bit boundary. Almost any compiler will do this for you (look up &quot;struct alignment &#x2F; padding&quot;). If the compiler is going to do this anyway, might as well use the memory yourself instead of letting it be empty space. If it doesn&#x27;t happen, you leave performance on the table, so doing this raises the chance that your struct&#x2F;fields will be aligned.<p>Nuance is that each field should be at an address divisible by the fields size or wordline size, not some magic 32 constant. The entire struct should also be padded to a multiple of the largest fields size. In practice this usually means 32 bit alignment.<p>Ref <a href="http:&#x2F;&#x2F;www.catb.org&#x2F;esr&#x2F;structure-packing&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.catb.org&#x2F;esr&#x2F;structure-packing&#x2F;</a></div><br/></div></div><div id="37815897" class="c"><input type="checkbox" id="c-37815897" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#37815841">parent</a><span>|</span><a href="#37815956">prev</a><span>|</span><a href="#37815888">next</a><span>|</span><label class="collapse" for="c-37815897">[-]</label><label class="expand" for="c-37815897">[1 more]</label></div><br/><div class="children"><div class="content">And to add to that, if you use an actual bool type, sanitizers will warn you if they are ever any value other than false (0) or true (1).</div><br/></div></div><div id="37815888" class="c"><input type="checkbox" id="c-37815888" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#37815841">parent</a><span>|</span><a href="#37815897">prev</a><span>|</span><a href="#37815895">next</a><span>|</span><label class="collapse" for="c-37815888">[-]</label><label class="expand" for="c-37815888">[2 more]</label></div><br/><div class="children"><div class="content">Computer architecture is optimized for 32+ bit <i>aligned</i> access to most things. The gain is (usually, but not always!) performance.</div><br/><div id="37815943" class="c"><input type="checkbox" id="c-37815943" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#37815841">root</a><span>|</span><a href="#37815888">parent</a><span>|</span><a href="#37815895">next</a><span>|</span><label class="collapse" for="c-37815943">[-]</label><label class="expand" for="c-37815943">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m afraid you are only slightly correct.<p>Architectures are generally optimized for aligned access (or disallow unaligned access), but what counts as &quot;aligned&quot; is different for each type.<p>A char type that is used for a bool can be accessed on any byte boundary because the alignment of a char is 1. The alignment of a 32-bit value is 4.<p>However, architectures are generally more optimized for 32-bit operations <i>in registers</i>. If you&#x27;re dealing with a char in a register, the compiler will generally treat it as a 32-bit value, clearing the top bits. (This is one of those places where C&#x27;s UB can bite you.)<p>However, there are architectures where 32-bit access <i>is</i> optimized.</div><br/></div></div></div></div><div id="37815895" class="c"><input type="checkbox" id="c-37815895" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37815841">parent</a><span>|</span><a href="#37815888">prev</a><span>|</span><a href="#37815744">next</a><span>|</span><label class="collapse" for="c-37815895">[-]</label><label class="expand" for="c-37815895">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s an example of a function where a boolean variable spills to the stack and the 3 bytes are important?</div><br/></div></div></div></div><div id="37815744" class="c"><input type="checkbox" id="c-37815744" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#37815841">prev</a><span>|</span><a href="#37818076">next</a><span>|</span><label class="collapse" for="c-37815744">[-]</label><label class="expand" for="c-37815744">[2 more]</label></div><br/><div class="children"><div class="content">I disagree about the structs vs out-parameters thing. I’ve found it makes functions that could return an error much harder to compose and leads to a proliferation of types all over the place. In practice almost all functions can fail (assuming you are handling OOM), so having a predictable style of returning errors is more important.</div><br/><div id="37817982" class="c"><input type="checkbox" id="c-37817982" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#37815744">parent</a><span>|</span><a href="#37818076">next</a><span>|</span><label class="collapse" for="c-37817982">[-]</label><label class="expand" for="c-37817982">[1 more]</label></div><br/><div class="children"><div class="content">&gt; assuming you are handling OOM<p>Which almost noone ever does. It&#x27;s very hard and almost never has any benefit. At that point you have way different problems than programming style choices...</div><br/></div></div></div></div><div id="37818076" class="c"><input type="checkbox" id="c-37818076" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#37815744">prev</a><span>|</span><a href="#37817312">next</a><span>|</span><label class="collapse" for="c-37818076">[-]</label><label class="expand" for="c-37818076">[2 more]</label></div><br/><div class="children"><div class="content">&gt; No const.<p>I stopped reading there. I wish this guy a happy coding (and non-coding) life, but I hope we never work together.</div><br/><div id="37818345" class="c"><input type="checkbox" id="c-37818345" checked=""/><div class="controls bullet"><span class="by">cryo</span><span>|</span><a href="#37818076">parent</a><span>|</span><a href="#37817312">next</a><span>|</span><label class="collapse" for="c-37818345">[-]</label><label class="expand" for="c-37818345">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to have him in a team. He truly cares exactly how code works and analyzes&#x2F;fuzzes the hell out of everything.<p>I don&#x27;t agree with all stylistic choices in his code, but the level of experience and skills are far above most C developers.</div><br/></div></div></div></div><div id="37817312" class="c"><input type="checkbox" id="c-37817312" checked=""/><div class="controls bullet"><span class="by">Lockal</span><span>|</span><a href="#37818076">prev</a><span>|</span><a href="#37818358">next</a><span>|</span><label class="collapse" for="c-37817312">[-]</label><label class="expand" for="c-37817312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; typedef ptrdiff_t size;<p>This reminds me of &quot;#define max ...&quot; in Windows.h. Not as bad, but if you autoreplace `sizeof(ptrdiff_t)` with `sizeof(size)`, good luck, because it will output size of type of size variable, if it exists in the scope.</div><br/></div></div><div id="37818358" class="c"><input type="checkbox" id="c-37818358" checked=""/><div class="controls bullet"><span class="by">Luker88</span><span>|</span><a href="#37817312">prev</a><span>|</span><a href="#37816035">next</a><span>|</span><label class="collapse" for="c-37818358">[-]</label><label class="expand" for="c-37818358">[1 more]</label></div><br/><div class="children"><div class="content">More than a few of these look like what you will find in Rust by default<p>Nice to see some evolutive convergence in C programmers, too</div><br/></div></div><div id="37816035" class="c"><input type="checkbox" id="c-37816035" checked=""/><div class="controls bullet"><span class="by">hyc_symas</span><span>|</span><a href="#37818358">prev</a><span>|</span><a href="#37816753">next</a><span>|</span><label class="collapse" for="c-37816035">[-]</label><label class="expand" for="c-37816035">[3 more]</label></div><br/><div class="children"><div class="content">typedef all structs - yes, helps with conciseness. Use typedefs liberally, I say. But only typedef the things themselves, not pointers to the things. You can always use (type *) when you need a pointer. In particular, for function pointers, typedef the function, not the function pointer. Then you can use the function typedef for function declarations too, which gives you parameter type checking without needing to fix declarations everywhere if you change a function signature. I see most C codebases get this one wrong, typedef&#x27;ing the function pointer and still needing to manually write out all function declarations for that pointer definition.<p>I&#x27;m not sold on the structs as return types thing. I prefer just a numeric error code as a return value, and out parameters for any other returns.</div><br/><div id="37816342" class="c"><input type="checkbox" id="c-37816342" checked=""/><div class="controls bullet"><span class="by">jpcfl</span><span>|</span><a href="#37816035">parent</a><span>|</span><a href="#37816753">next</a><span>|</span><label class="collapse" for="c-37816342">[-]</label><label class="expand" for="c-37816342">[2 more]</label></div><br/><div class="children"><div class="content">I prefer to use typedef&#x27;s for opaque structs to emulate classes with all private fields, and use &#x27;struct&#x27; for plain ol&#x27; data structures. Classes should only be accessed via functions, while structs can be accessed directly.<p>I think this is more-or-less a C&#x2F;POSIX standard convention. E.g., `pthread_t` vs. `struct stat`.</div><br/><div id="37817849" class="c"><input type="checkbox" id="c-37817849" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816035">root</a><span>|</span><a href="#37816342">parent</a><span>|</span><a href="#37816753">next</a><span>|</span><label class="collapse" for="c-37817849">[-]</label><label class="expand" for="c-37817849">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I prefer to use typedef&#x27;s for opaque structs to emulate classes with all private fields, and use &#x27;struct&#x27; for plain ol&#x27; data structures. Classes should only be accessed via functions, while structs can be accessed directly.<p>Totally agree, I even wrote this as a blog post: <a href="https:&#x2F;&#x2F;www.lelanthran.com&#x2F;chap9&#x2F;content.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.lelanthran.com&#x2F;chap9&#x2F;content.html</a></div><br/></div></div></div></div></div></div><div id="37816753" class="c"><input type="checkbox" id="c-37816753" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37816035">prev</a><span>|</span><a href="#37818265">next</a><span>|</span><label class="collapse" for="c-37816753">[-]</label><label class="expand" for="c-37816753">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>#define sizeof(x)    (size)sizeof(x)</i><p>That breaks any macro that uses sizeof in its expansion, and subtly changes any code snippet you might bring into the code that uses sizeof, even if those macro are defined first.<p>Speaking of which, if you define a macro for a C keyword <i>before</i> including any standard header, the behavior is undefined.<p>It&#x27;s an unparenthesized unary expression, which has a lower precedence than postfix.  sizeof(x)[ptr] will turn into (size)sizeof(x)[ptr] which parses as (size) ( sizeof(x)[ptr] ).</div><br/></div></div><div id="37818265" class="c"><input type="checkbox" id="c-37818265" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37816753">prev</a><span>|</span><a href="#37815823">next</a><span>|</span><label class="collapse" for="c-37818265">[-]</label><label class="expand" for="c-37818265">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t defining byte = char a bit wrong? char may be signed or unsigned, and may be more or less than 1 byte, right? So why that?</div><br/></div></div><div id="37815823" class="c"><input type="checkbox" id="c-37815823" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#37818265">prev</a><span>|</span><a href="#37816203">next</a><span>|</span><label class="collapse" for="c-37815823">[-]</label><label class="expand" for="c-37815823">[7 more]</label></div><br/><div class="children"><div class="content">A lot of this makes sense to me.<p>I’ve started writing a bare metal OS for Arm64. It’s very early but I’ve done some similar things. I’m using pascal strings, I’ve also renamed the types (though I’m using “int8” style, not “i8”).<p>I quickly decided that I never intend to port real software to it, so I really don’t have to conform to standard C library functions or conventions. That’s given me more freedom to play around. C is old enough to have a lot of baggage from when every byte was precious, even in function names.<p>It’s nice to get away from that. Much like the contents of this post, that plus other small renamed just ended up feeling like a nice cleanup.</div><br/><div id="37816725" class="c"><input type="checkbox" id="c-37816725" checked=""/><div class="controls bullet"><span class="by">vdqtp3</span><span>|</span><a href="#37815823">parent</a><span>|</span><a href="#37815942">next</a><span>|</span><label class="collapse" for="c-37816725">[-]</label><label class="expand" for="c-37816725">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I never intend to port real software to it, so I really don’t have to conform to standard C library functions or conventions.<p>So you&#x27;re just building it as just a hobby, won’t be big and professional like gnu?</div><br/><div id="37817780" class="c"><input type="checkbox" id="c-37817780" checked=""/><div class="controls bullet"><span class="by">1f60c</span><span>|</span><a href="#37815823">root</a><span>|</span><a href="#37816725">parent</a><span>|</span><a href="#37815942">next</a><span>|</span><label class="collapse" for="c-37817780">[-]</label><label class="expand" for="c-37817780">[1 more]</label></div><br/><div class="children"><div class="content">Context: Linus Torvalds&#x27; announcement of Linux to comp.os.minix: <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~awb&#x2F;linux.history.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~awb&#x2F;linux.history.html</a></div><br/></div></div></div></div><div id="37815942" class="c"><input type="checkbox" id="c-37815942" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#37815823">parent</a><span>|</span><a href="#37816725">prev</a><span>|</span><a href="#37816203">next</a><span>|</span><label class="collapse" for="c-37815942">[-]</label><label class="expand" for="c-37815942">[4 more]</label></div><br/><div class="children"><div class="content">i never thought about that, saving bytes even in symbols</div><br/><div id="37816564" class="c"><input type="checkbox" id="c-37816564" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#37815823">root</a><span>|</span><a href="#37815942">parent</a><span>|</span><a href="#37815986">next</a><span>|</span><label class="collapse" for="c-37816564">[-]</label><label class="expand" for="c-37816564">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, old C compilers would only look at the first 6 characters of a name, and the rest were insignificant. That&#x27;s how you get nanrs like &quot;strcpy&quot; and &quot;malloc&quot; instead of something like &quot;string_copy&quot; or &quot;mem_allocate&quot; (I still think &quot;memory_allocate&quot; would be long enough to be annoying to type).</div><br/><div id="37817085" class="c"><input type="checkbox" id="c-37817085" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37815823">root</a><span>|</span><a href="#37816564">parent</a><span>|</span><a href="#37815986">next</a><span>|</span><label class="collapse" for="c-37817085">[-]</label><label class="expand" for="c-37817085">[1 more]</label></div><br/><div class="children"><div class="content">One of last vestiges of this fact AFAIK was libjpeg, which had a macro NEED_SHORT_EXTERNAL_NAMES that shortens all public identifiers to have unique 6-letter-long prefixes. Libjpeg-turbo nowadays has removed them though [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;libjpeg-turbo&#x2F;libjpeg-turbo&#x2F;commit&#x2F;52ded8768022ab7e9e7670ddea0ba89e2890b837">https:&#x2F;&#x2F;github.com&#x2F;libjpeg-turbo&#x2F;libjpeg-turbo&#x2F;commit&#x2F;52ded8...</a></div><br/></div></div></div></div><div id="37815986" class="c"><input type="checkbox" id="c-37815986" checked=""/><div class="controls bullet"><span class="by">Eggsellence</span><span>|</span><a href="#37815823">root</a><span>|</span><a href="#37815942">parent</a><span>|</span><a href="#37816564">prev</a><span>|</span><a href="#37816203">next</a><span>|</span><label class="collapse" for="c-37815986">[-]</label><label class="expand" for="c-37815986">[1 more]</label></div><br/><div class="children"><div class="content">I think he is suggesting the opposite - use more verbose names for clarity.</div><br/></div></div></div></div></div></div><div id="37816203" class="c"><input type="checkbox" id="c-37816203" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#37815823">prev</a><span>|</span><a href="#37818013">next</a><span>|</span><label class="collapse" for="c-37816203">[-]</label><label class="expand" for="c-37816203">[3 more]</label></div><br/><div class="children"><div class="content">Interesting how my experience has led me in a different direction:<p><a href="https:&#x2F;&#x2F;dlang.org&#x2F;blog&#x2F;2023&#x2F;10&#x2F;02&#x2F;crafting-self-evident-code-with-d&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dlang.org&#x2F;blog&#x2F;2023&#x2F;10&#x2F;02&#x2F;crafting-self-evident-code...</a><p>(The article is crafted around D, but the principles apply to C as well.)</div><br/><div id="37816868" class="c"><input type="checkbox" id="c-37816868" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#37816203">parent</a><span>|</span><a href="#37818013">next</a><span>|</span><label class="collapse" for="c-37816868">[-]</label><label class="expand" for="c-37816868">[2 more]</label></div><br/><div class="children"><div class="content">Fun read.<p><pre><code>    What happened to the conditional expressions? Move them to the interiors of doX() and doZ().
</code></pre>
That was an interesting point. Not sure that it&#x27;s always valid but I guess it depends where you want the abstraction to lay, and how it affects the mental construct around the code.<p>e.g.<p><pre><code>    deleteRecords();
</code></pre>
is not better than<p><pre><code>    if let x = deadRecords()
       deleteRecords(x);
</code></pre>
Sure, it looks messier but there is value is showing upfront that you&#x27;re pruning and not wiping.<p>If the author wisely renames his function e.g. pruneDeadProjects(), yes. But merely moving the the condition within the function can be dangerous for context and be a leaky abstraction.</div><br/><div id="37817102" class="c"><input type="checkbox" id="c-37817102" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#37816203">root</a><span>|</span><a href="#37816868">parent</a><span>|</span><a href="#37818013">next</a><span>|</span><label class="collapse" for="c-37817102">[-]</label><label class="expand" for="c-37817102">[1 more]</label></div><br/><div class="children"><div class="content">Finding the right abstraction isn&#x27;t always easy. Sometimes if I just put it down and let it slosh around in my brain for a few days, it comes to me.<p>Like your idea of pruneDeadProjects()!</div><br/></div></div></div></div></div></div><div id="37818013" class="c"><input type="checkbox" id="c-37818013" checked=""/><div class="controls bullet"><span class="by">quelsolaar</span><span>|</span><a href="#37816203">prev</a><span>|</span><a href="#37816392">next</a><span>|</span><label class="collapse" for="c-37818013">[-]</label><label class="expand" for="c-37818013">[1 more]</label></div><br/><div class="children"><div class="content">You can declare flexible array member strings with literals like this:<p>#define DECLARE_STRING(variable_name, string) struct{size_t allocated; size_t used; char string[sizeof(c_string)];} variable_name ## internal = {.allocated = sizeof(c_string) - 1, .used = sizeof(c_string) - 1, .string = c_string}; MyString *variable_name = &amp;variable_name ## internal<p>Its a lot of C99 magic, so it may not be what you want but it is possible.</div><br/></div></div><div id="37816392" class="c"><input type="checkbox" id="c-37816392" checked=""/><div class="controls bullet"><span class="by">jpcfl</span><span>|</span><a href="#37818013">prev</a><span>|</span><a href="#37816183">next</a><span>|</span><label class="collapse" for="c-37816392">[-]</label><label class="expand" for="c-37816392">[15 more]</label></div><br/><div class="children"><div class="content"><i>Parameters and functions</i><p><i>No const.</i><p>Please don&#x27;t. `const` is incredibly valuable, not only to the reader, but to the compiler.<p>Take for example:<p><pre><code>  int Foo_bar(Foo const* self);
</code></pre>
Just looking at this signature, I know that calling `bar()` will not modify the state of the object. This is incredibly valuable information to the reader.<p>Furthermore, if I want to create a `Foo` constant, I can only call this function if it is `const`.<p><pre><code>  static Foo const a_foo = FOO_INIT(&amp;some_params);
  return Foo_bar(&amp;a_foo); &#x2F;&#x2F; Will not compile without &#x27;const&#x27; in function
</code></pre>
`const` is valuable to the compiler, since `a_foo` can be placed into ROM on some platforms like MCUs, saving precious RAM.</div><br/><div id="37816446" class="c"><input type="checkbox" id="c-37816446" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#37816392">parent</a><span>|</span><a href="#37816411">next</a><span>|</span><label class="collapse" for="c-37816446">[-]</label><label class="expand" for="c-37816446">[2 more]</label></div><br/><div class="children"><div class="content">You only know there are no mutations if Foo itself does not contain any indirections. Additionally, the compiler generally cannot assume that Foo_bar does not modify Foo as it is legal to cast away const as long as it is not originally a variable declared as const (so in your static Foo example it would be UB to cast away const).<p>static + const is valuable, but const parameters are merely a convention, there is no actual enforcement around them and due to aliasing the compiler generally can’t assume the parameter doesn’t actually change anyway.</div><br/><div id="37817861" class="c"><input type="checkbox" id="c-37817861" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37816446">parent</a><span>|</span><a href="#37816411">next</a><span>|</span><label class="collapse" for="c-37817861">[-]</label><label class="expand" for="c-37817861">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Additionally, the compiler generally cannot assume that Foo_bar does not modify Foo as it is legal to cast away const<p>No, but <i>it can warn you!</i><p>The type is meant to capture programmer intention, and if you use `const` the compiler can warn you that your intention does not match the intention of the existing code (like, the intention of the author who wrote Foo_Bar).</div><br/></div></div></div></div><div id="37816411" class="c"><input type="checkbox" id="c-37816411" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37816392">parent</a><span>|</span><a href="#37816446">prev</a><span>|</span><a href="#37816485">next</a><span>|</span><label class="collapse" for="c-37816411">[-]</label><label class="expand" for="c-37816411">[6 more]</label></div><br/><div class="children"><div class="content">Agreed; const is one of those features that is so good I wish a lot of other languages (e.g. java) had it.</div><br/><div id="37816608" class="c"><input type="checkbox" id="c-37816608" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37816411">parent</a><span>|</span><a href="#37816917">next</a><span>|</span><label class="collapse" for="c-37816608">[-]</label><label class="expand" for="c-37816608">[1 more]</label></div><br/><div class="children"><div class="content">const in C and C++ are an abomination. On a pointer they don’t tell the compiler to do shit, because they can’t.<p>That I can agree with TFA. However I agree with the GP that dismissing it entirely is a little misplaced. It serves as a hint&#x2F;documentation and I think the article undersells the value of rodata (not the pointer use of const which is basically shit).<p>I mean I have seen at least a few SIGSEGV&#x2F;aborts due to attempted writes to ro memory. Also like, one of the few modern justifications for C, embedded, const still has important link time meaning.</div><br/></div></div><div id="37816917" class="c"><input type="checkbox" id="c-37816917" checked=""/><div class="controls bullet"><span class="by">skovati</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37816411">parent</a><span>|</span><a href="#37816608">prev</a><span>|</span><a href="#37816485">next</a><span>|</span><label class="collapse" for="c-37816917">[-]</label><label class="expand" for="c-37816917">[4 more]</label></div><br/><div class="children"><div class="content">FWIW, Java does have the &quot;final&quot; keyword.</div><br/><div id="37817636" class="c"><input type="checkbox" id="c-37817636" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37816917">parent</a><span>|</span><a href="#37816485">next</a><span>|</span><label class="collapse" for="c-37817636">[-]</label><label class="expand" for="c-37817636">[3 more]</label></div><br/><div class="children"><div class="content">Final only protects the variable from being assigned a new reference (similar to a const pointer). It doesn’t protect any of the underlying data held by the object from being changed, unless the entire hierarchy has every field declared final as well. I still use final heavily in all of my Java code, but it doesnt convey the full intent I would like it to.</div><br/><div id="37818029" class="c"><input type="checkbox" id="c-37818029" checked=""/><div class="controls bullet"><span class="by">_old_dude_</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37817636">parent</a><span>|</span><a href="#37816485">next</a><span>|</span><label class="collapse" for="c-37818029">[-]</label><label class="expand" for="c-37818029">[2 more]</label></div><br/><div class="children"><div class="content">I remember James Gosling saying, a long time ago, that the whole class should be either mutable or not so you do not need to tag some methods with const.<p>The consequence is that you may define two classes, one non-mutable and one mutable like String&#x2F;StringBuilder.</div><br/><div id="37818329" class="c"><input type="checkbox" id="c-37818329" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37818029">parent</a><span>|</span><a href="#37816485">next</a><span>|</span><label class="collapse" for="c-37818329">[-]</label><label class="expand" for="c-37818329">[1 more]</label></div><br/><div class="children"><div class="content">It means you have to triplicate each mutable class, because besides the immutable variant you also need the common interface (e.g. CharSequence), in order to pass mutable instances to read-only functions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37816485" class="c"><input type="checkbox" id="c-37816485" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#37816392">parent</a><span>|</span><a href="#37816411">prev</a><span>|</span><a href="#37816760">next</a><span>|</span><label class="collapse" for="c-37816485">[-]</label><label class="expand" for="c-37816485">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m afraid you are mistaken. In particular for pointers, const does not guarantee that the memory at the location pointed to won&#x27;t change. Const only guarantees that the address itself doesn&#x27;t change.</div><br/><div id="37816534" class="c"><input type="checkbox" id="c-37816534" checked=""/><div class="controls bullet"><span class="by">kibibu</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37816485">parent</a><span>|</span><a href="#37816760">next</a><span>|</span><label class="collapse" for="c-37816534">[-]</label><label class="expand" for="c-37816534">[4 more]</label></div><br/><div class="children"><div class="content">Should perhaps be<p><pre><code>    int Foo_bar(const Foo * self);</code></pre></div><br/><div id="37817101" class="c"><input type="checkbox" id="c-37817101" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37816534">parent</a><span>|</span><a href="#37816615">next</a><span>|</span><label class="collapse" for="c-37817101">[-]</label><label class="expand" for="c-37817101">[2 more]</label></div><br/><div class="children"><div class="content">`const Foo*` and `Foo const*` are exactly the same and just a question of style (east-const vs. west-const)<p>Not to be confused with `Foo *const`</div><br/><div id="37817974" class="c"><input type="checkbox" id="c-37817974" checked=""/><div class="controls bullet"><span class="by">PennRobotics</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37817101">parent</a><span>|</span><a href="#37816615">next</a><span>|</span><label class="collapse" for="c-37817974">[-]</label><label class="expand" for="c-37817974">[1 more]</label></div><br/><div class="children"><div class="content">For anyone thinking, &quot;wtf const pointer order??&quot; fall back on the spiral rule:<p><a href="https:&#x2F;&#x2F;c-faq.com&#x2F;decl&#x2F;spiral.anderson.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;c-faq.com&#x2F;decl&#x2F;spiral.anderson.html</a></div><br/></div></div></div></div><div id="37816615" class="c"><input type="checkbox" id="c-37816615" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#37816392">root</a><span>|</span><a href="#37816534">parent</a><span>|</span><a href="#37817101">prev</a><span>|</span><a href="#37816760">next</a><span>|</span><label class="collapse" for="c-37816615">[-]</label><label class="expand" for="c-37816615">[1 more]</label></div><br/><div class="children"><div class="content">Even then, some other function can change the memory at the address of self while this one is executing, especially in concurrent systems. Additionally, any other pointer pointing to the same address can also modify self&#x27;s memory. const in this case is really just &quot;scout&#x27;s honour&quot;.</div><br/></div></div></div></div></div></div><div id="37816760" class="c"><input type="checkbox" id="c-37816760" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#37816392">parent</a><span>|</span><a href="#37816485">prev</a><span>|</span><a href="#37816183">next</a><span>|</span><label class="collapse" for="c-37816760">[-]</label><label class="expand" for="c-37816760">[1 more]</label></div><br/><div class="children"><div class="content">Sorry for going off topic, but something fun I&#x27;ve learned lately is that in Nim (which compiles to C) changing:<p>let x = foo()<p>... to ...<p>const x = foo()<p>...runs foo at compile time to get the value.  I dunno I just thought it was neat.</div><br/></div></div></div></div><div id="37816183" class="c"><input type="checkbox" id="c-37816183" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#37816392">prev</a><span>|</span><a href="#37818344">next</a><span>|</span><label class="collapse" for="c-37816183">[-]</label><label class="expand" for="c-37816183">[9 more]</label></div><br/><div class="children"><div class="content">While there are a few disagreeable points, I like the article.<p>I&#x27;ve always felt that C is unfairly maligned. Yes, it&#x27;s very low level, it&#x27;s meant to be. Yes, it lets you shoot yourself in the foot, but what language doesn&#x27;t?<p>Most of the problems with C are really issues with the standard library, the Unix (now Posix) interfaces, and the string type.<p>None of these are actually part of C, but are part of how C is normally used. So those problems can be avoided, and use C for what it&#x27;s good at.</div><br/><div id="37816279" class="c"><input type="checkbox" id="c-37816279" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#37816183">parent</a><span>|</span><a href="#37816250">next</a><span>|</span><label class="collapse" for="c-37816279">[-]</label><label class="expand" for="c-37816279">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not unfairly maligned, it&#x27;s just that everyone remembers their college&#x2F;university &#x27;learning experience&#x27; which made no distinction between C&#x2F;C++, they were told to use the Borland compiler, and when trying to learn printing &quot;hello world&quot; they only got a `segmentation fault` error instead of a stack trace. When they asked why it&#x27;s so hard, they were told C&#x2F;C++ is hard - so they dropped the class.<p>Then they picked up a JS or Python class, were told high-level languages are easy and viola! they started to understand programming.<p>That&#x27;s the reason people are spiteful of it. They had a terrible learning experience right out the gate.</div><br/><div id="37816889" class="c"><input type="checkbox" id="c-37816889" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#37816183">root</a><span>|</span><a href="#37816279">parent</a><span>|</span><a href="#37816250">next</a><span>|</span><label class="collapse" for="c-37816889">[-]</label><label class="expand" for="c-37816889">[2 more]</label></div><br/><div class="children"><div class="content">do compilers like gcc support stack traces now?</div><br/><div id="37817038" class="c"><input type="checkbox" id="c-37817038" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#37816183">root</a><span>|</span><a href="#37816889">parent</a><span>|</span><a href="#37816250">next</a><span>|</span><label class="collapse" for="c-37817038">[-]</label><label class="expand" for="c-37817038">[1 more]</label></div><br/><div class="children"><div class="content">No; it&#x27;s up to the program author to link against a library that provided back-traces (and maybe install a signal handler to call into that unwinder).  Even then, some kind of information needs to be retained in the binary that&#x27;s normally not (-gmlt comes to mind).<p>Usually folks attach a debugger to capture a stack trace.  Usually the debugger uses debug info to determine where the program is, and it&#x27;s stack trace. Or it can walk frame pointers. Depends on if either are even used, which is a compile time decision.</div><br/></div></div></div></div></div></div><div id="37816250" class="c"><input type="checkbox" id="c-37816250" checked=""/><div class="controls bullet"><span class="by">eldenring</span><span>|</span><a href="#37816183">parent</a><span>|</span><a href="#37816279">prev</a><span>|</span><a href="#37816216">next</a><span>|</span><label class="collapse" for="c-37816250">[-]</label><label class="expand" for="c-37816250">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, it lets you shoot yourself in the foot, but what language doesn&#x27;t?<p>Good lord.</div><br/><div id="37816554" class="c"><input type="checkbox" id="c-37816554" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#37816183">root</a><span>|</span><a href="#37816250">parent</a><span>|</span><a href="#37816216">next</a><span>|</span><label class="collapse" for="c-37816554">[-]</label><label class="expand" for="c-37816554">[3 more]</label></div><br/><div class="children"><div class="content">Well ... Name a language is which you categorically cannot &quot;shoot yourself in the foot&quot;!</div><br/><div id="37816603" class="c"><input type="checkbox" id="c-37816603" checked=""/><div class="controls bullet"><span class="by">jcrites</span><span>|</span><a href="#37816183">root</a><span>|</span><a href="#37816554">parent</a><span>|</span><a href="#37816216">next</a><span>|</span><label class="collapse" for="c-37816603">[-]</label><label class="expand" for="c-37816603">[2 more]</label></div><br/><div class="children"><div class="content">The issue is that it&#x27;s a spectrum: how easily you can shoot yourself in the foot, especially on accident, without awareness of the risks. And perhaps what the consequences are when you do. Risk and consequence. C is high risk and also high consequence.<p>In higher level languages, you can&#x27;t shoot yourself in the foot nearly as easily in such a way as to trivially create a correctness problem and security vulnerability (like a buffer under&#x2F;overflow). Languages like Java and C# make it pretty difficult to shoot yourself in the foot this way (though you still can in other ways, like with incorrect concurrency). Rust makes it a lot harder to shoot yourself in the foot across the board, especially on accident (i.e., without being aware that you&#x27;re something dangerous and low-level, viz. `unsafe`).</div><br/><div id="37816708" class="c"><input type="checkbox" id="c-37816708" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#37816183">root</a><span>|</span><a href="#37816603">parent</a><span>|</span><a href="#37816216">next</a><span>|</span><label class="collapse" for="c-37816708">[-]</label><label class="expand" for="c-37816708">[1 more]</label></div><br/><div class="children"><div class="content">And even in Rust, the unsafe code guidelines and UB are extremely hotly debated and well-defined whenever possible.</div><br/></div></div></div></div></div></div></div></div><div id="37816216" class="c"><input type="checkbox" id="c-37816216" checked=""/><div class="controls bullet"><span class="by">edvinbesic</span><span>|</span><a href="#37816183">parent</a><span>|</span><a href="#37816250">prev</a><span>|</span><a href="#37818344">next</a><span>|</span><label class="collapse" for="c-37816216">[-]</label><label class="expand" for="c-37816216">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve always felt that C is unfairly maligned. Yes, it&#x27;s very low level, it&#x27;s meant to be. Yes, it lets you shoot yourself in the foot, but what language doesn&#x27;t<p>Isn’t it a beauty of lower level languages that creating higher level abstractions provides more value?<p>edit: typo</div><br/></div></div></div></div><div id="37818344" class="c"><input type="checkbox" id="c-37818344" checked=""/><div class="controls bullet"><span class="by">nspattak</span><span>|</span><a href="#37816183">prev</a><span>|</span><a href="#37815842">next</a><span>|</span><label class="collapse" for="c-37818344">[-]</label><label class="expand" for="c-37818344">[2 more]</label></div><br/><div class="children"><div class="content">i love this blog, i hold Chris Wellons to a very high estime  BUT i utterly disapprove the usage of macros so much, especially to wrap cstd types, functions, etc.</div><br/><div id="37818376" class="c"><input type="checkbox" id="c-37818376" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#37818344">parent</a><span>|</span><a href="#37815842">next</a><span>|</span><label class="collapse" for="c-37818376">[-]</label><label class="expand" for="c-37818376">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently on a C++ (mostly C with C++ compiler) trip. It does make some things easier and some things harder. It makes it easier to work with C++ developers :-). I sometimes use the more involved C++ features but often regret it after because of complications.<p>But one thing that makes it worth it is the removal of the struct tag space. I have a strong dislike for the struct tag boilerplate in C, but the alternative -- typedef boilerplate -- in C is unbearable to the point that I have a macro to define structs in C that does this automatically.<p><pre><code>    #define STRUCT(name) typedef struct name name; struct name

    STRUCT(Foo) {
        int x;
        int y;
    };
</code></pre>
But macros often come with disadvantages. In this case it&#x27;s that many IDEs have trouble finding the struct definitions from a usage site.</div><br/></div></div></div></div><div id="37817848" class="c"><input type="checkbox" id="c-37817848" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#37815842">prev</a><span>|</span><a href="#37816907">next</a><span>|</span><label class="collapse" for="c-37817848">[-]</label><label class="expand" for="c-37817848">[1 more]</label></div><br/><div class="children"><div class="content">I think C really needs an update to the standard library that includes these shorter types. Seems like a fine list though.<p>Some of my own style changes this year:<p>I try really hard to write functional code. Mainly try to keep functions pure, and write declarative code. I find that this makes the code easier to write(not necessarily read), and I&#x27;m less scared of bugs.<p>I also avoid malloc unless I absolutely need it. You can usually preallocate space on the stack or use a fixed length buffer, which pretty much avoids all fears of memory leaks or use after free type bugs. You will sometimes waste memory by allocating more than you need, but it&#x27;s a lot more predictable.</div><br/></div></div><div id="37816907" class="c"><input type="checkbox" id="c-37816907" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#37817848">prev</a><span>|</span><a href="#37818204">next</a><span>|</span><label class="collapse" for="c-37816907">[-]</label><label class="expand" for="c-37816907">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much agree with most of this. My own personal evolved style is pretty similar. I&#x27;m suspect this kind of pragmatic style offends the theoretic and the academic. That can be intimidating. I&#x27;m glad at least one other person out there is like me.</div><br/></div></div><div id="37818204" class="c"><input type="checkbox" id="c-37818204" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#37816907">prev</a><span>|</span><a href="#37816099">next</a><span>|</span><label class="collapse" for="c-37818204">[-]</label><label class="expand" for="c-37818204">[4 more]</label></div><br/><div class="children"><div class="content">Why would anyone care what the favorite whatever style of some dude on the Internet is?<p>I like petunias! Now what? How does that help anyone?</div><br/><div id="37818405" class="c"><input type="checkbox" id="c-37818405" checked=""/><div class="controls bullet"><span class="by">forgotpwd16</span><span>|</span><a href="#37818204">parent</a><span>|</span><a href="#37818349">next</a><span>|</span><label class="collapse" for="c-37818405">[-]</label><label class="expand" for="c-37818405">[1 more]</label></div><br/><div class="children"><div class="content">Your preference doesn&#x27;t help anyone. That&#x27;s true. But coding styles may improve its reader&#x27;s programming.</div><br/></div></div><div id="37818349" class="c"><input type="checkbox" id="c-37818349" checked=""/><div class="controls bullet"><span class="by">fredrb</span><span>|</span><a href="#37818204">parent</a><span>|</span><a href="#37818405">prev</a><span>|</span><a href="#37818293">next</a><span>|</span><label class="collapse" for="c-37818349">[-]</label><label class="expand" for="c-37818349">[1 more]</label></div><br/><div class="children"><div class="content">Sharing preferences and opinions on code ergonomics certainly has value for me, and I bet it has to other people too. This is, after all, a developer&#x27;s forum.<p>I&#x27;m certain your opinion on petunias and your possible distaste for orchids will be welcomed in a flower-news type orange site. :-)</div><br/></div></div><div id="37818293" class="c"><input type="checkbox" id="c-37818293" checked=""/><div class="controls bullet"><span class="by">awestroke</span><span>|</span><a href="#37818204">parent</a><span>|</span><a href="#37818349">prev</a><span>|</span><a href="#37816099">next</a><span>|</span><label class="collapse" for="c-37818293">[-]</label><label class="expand" for="c-37818293">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll probably copy everything in the post for my next C project. Super nice stuff.</div><br/></div></div></div></div><div id="37816099" class="c"><input type="checkbox" id="c-37816099" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#37818204">prev</a><span>|</span><a href="#37815877">next</a><span>|</span><label class="collapse" for="c-37816099">[-]</label><label class="expand" for="c-37816099">[3 more]</label></div><br/><div class="children"><div class="content">I like it a lot. Especially the part about ditching const
qualifiers. They clutter function declarations, don&#x27;t make the intent
any clear, and almost never improve performance. Restrict, on the
other hand, I&#x27;ve found makes the compilers emit better code in many
cases.<p>But I don&#x27;t like using 1 and 0 instead of booleans. Many standard C
functions (fclose for example), return 0 on success. Better to be
explicit here.</div><br/><div id="37816175" class="c"><input type="checkbox" id="c-37816175" checked=""/><div class="controls bullet"><span class="by">pylua</span><span>|</span><a href="#37816099">parent</a><span>|</span><a href="#37816322">next</a><span>|</span><label class="collapse" for="c-37816175">[-]</label><label class="expand" for="c-37816175">[1 more]</label></div><br/><div class="children"><div class="content">I like using the const keyword, and believe it serves a real purpose with readability. I feel like most things are read access by default which is why it seems cluttered. I believe rust gets immutable by default correct .</div><br/></div></div><div id="37816322" class="c"><input type="checkbox" id="c-37816322" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#37816099">parent</a><span>|</span><a href="#37816175">prev</a><span>|</span><a href="#37815877">next</a><span>|</span><label class="collapse" for="c-37816322">[-]</label><label class="expand" for="c-37816322">[1 more]</label></div><br/><div class="children"><div class="content">I use an exitint typedef to signify &quot;0 is success, non-0 is failure&quot; and boolint equivalent to his b32. Not typesafe of course, so it&#x27;s just info for fallible humans.</div><br/></div></div></div></div><div id="37815877" class="c"><input type="checkbox" id="c-37815877" checked=""/><div class="controls bullet"><span class="by">cshenton</span><span>|</span><a href="#37816099">prev</a><span>|</span><a href="#37816315">next</a><span>|</span><label class="collapse" for="c-37815877">[-]</label><label class="expand" for="c-37815877">[1 more]</label></div><br/><div class="children"><div class="content">Really lovely. A lot here reminds me of design in Odin lang. Short integral types, no const, composite returns over out params. Big fan of the approach of designing for a single translation unit and exploiting the optimisations that provides from RVO etc.</div><br/></div></div><div id="37816315" class="c"><input type="checkbox" id="c-37816315" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#37815877">prev</a><span>|</span><a href="#37817749">next</a><span>|</span><label class="collapse" for="c-37816315">[-]</label><label class="expand" for="c-37816315">[2 more]</label></div><br/><div class="children"><div class="content">How do you not use const for arguments of data types that are too costly to pass by value?</div><br/><div id="37817064" class="c"><input type="checkbox" id="c-37817064" checked=""/><div class="controls bullet"><span class="by">progfix</span><span>|</span><a href="#37816315">parent</a><span>|</span><a href="#37817749">next</a><span>|</span><label class="collapse" for="c-37817064">[-]</label><label class="expand" for="c-37817064">[1 more]</label></div><br/><div class="children"><div class="content">Usually if it is too costly, then you pass it via a pointer.</div><br/></div></div></div></div><div id="37817749" class="c"><input type="checkbox" id="c-37817749" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37816315">prev</a><span>|</span><a href="#37815810">next</a><span>|</span><label class="collapse" for="c-37817749">[-]</label><label class="expand" for="c-37817749">[1 more]</label></div><br/><div class="children"><div class="content">In general, the style the author has adopted is to introduce brevity where he can, and use wrappers over what would have been standard and idiomatic C code. In most situations, these conventions aren&#x27;t good in a non-solo project, because they simply aren&#x27;t as obvious to the programmer.<p>He says so himself:<p>&gt; I don’t intend to use these names in isolation, such as in code snippets (outside of this article). If I did, examples would require the typedefs to give readers the complete context. That’s not worth extra explanation. Even in the most recent articles I’ve used ptrdiff_t instead of size.<p>You require extra work to understand his basic types before reading even a short snippet, so he doesn&#x27;t use it when he wants people to read short snippets.<p>Introducing additional stuff the programmer must remember that does not add any safety is pointless busywork.<p>A non-complete summary of his conventions:<p>1. typedef standard typenames to 3-char symbols,<p>2. remove qualifiers like const,<p>3. use macros to reduce the amount of typing the programmer does,<p>4. typedef all structs (and enums too, I assume)<p>5. A macro-ized string-typed with prefixed-length.<p>&gt; Starting with the fundamentals, I’ve been using short names for primitive types. The resulting clarity was more than I had expected,<p>This <i>isn&#x27;t</i> clear: `int8_t` is a lot clearer to a C programmer than `i8`, because a C programmer has already internalised the pattern of the stdint.h types. This is going to lead to subtle bugs as well: quick, according to his convention, what is the % specifier for `byte`?<p>You can use %c, but that gives you an ascii character (which is not what we think of when we say &#x27;byte&#x27;).<p>If you use PRIu8 the compiler might give warnings because `char` might be signed. The best option is to just not use `byte` and use `uint8_t` instead (or, in his system, `u8`).<p>Same with `b32` vs `i32` - it&#x27;s a distinction without a difference and mixing these types won&#x27;t give compiler warnings, while it is almost certainly an error on the part of the developer. Use `bool` if you don&#x27;t like `_Bool`.<p>In general I try to take advantage of whatever typing C provides; I don&#x27;t try to subvert it because I <i>want</i> the compiler to warn me when my intention doesn&#x27;t match the code I wrote.<p>&gt; No const. It serves no practical role in optimization, and I cannot recall an instance where it caught, or would have caught, a mistake.<p>I disagree with dropping `const`.<p>1. It&#x27;s useful as an indicator to the caller that the returned value must&#x2F;must not be freed. It&#x27;s a convention I use that makes it easy to visually spot memory leaks.<p>Of the two functions below, it&#x27;s clear to me which one needs the returned value `free()`ed and which one doesn&#x27;t.<p><pre><code>     const char *replace_substring (const char *src, const char *pat, const char *replacement);
     char *replace_substring (const char *src, const char *pat, const char *replacement);

</code></pre>
2. It actually <i>does</i> catch a lot of problems, because the compiler warns me when I attempt to modify a value that some other code I wrote never intended to be modified. It&#x27;s about intention, and when I <i>know</i> it is safe to modify the `const` value, then I have to explicitly cast away the const to compile my program. Anyone reading the program will <i>know</i> that the modification of the const-qualifed value is intentional, and therefore safe.<p>&gt; #define s8(s) (s8){(u8 *)s, lengthof(s)}<p>This is interesting. I will try this out in my next project. I do think that there&#x27;ll be quite a few compiler warnings for sign-mismatch though. This is the second &quot;I wonder what the sign is&quot; question for programmers reading his code - it means that his code has to compile with the flags that he compiles it with (I assume he&#x27;s passing a flag to force chars to a particular sign). You can&#x27;t simply compile his code in another project unless you copy his flags, and those flags may conflict with the new projects flags.<p>I also wish that he&#x27;d showed a few examples of how having the length helps - what is presented in the post doesn&#x27;t show any additional string safety over using nul-terminated strings. All those macros, including the one that creates the struct, could be written to operate on null-terminated strings. In essence, the length can be simply unused for everything! Where&#x27;s the safety!?<p>&gt; It’s also led to a style of defining a zero-initialized return value at the top of the function, i.e. ok is false, and then use it for all return statements. On error, it can bail out with an immediate return.<p>I use a similar pattern, but I use `goto cleanup` on all errors; you can&#x27;t, as a general pattern, return early in a non-trivial C function without leaking resources. You can, as a general pattern, `goto cleanup` in every C function to clean up resources. I prefer the general pattern that I use everywhere rather than having to ensure that all resources acquired <i>up to that particular return statement</i> are released.<p>&gt;  rather than include windows.h, write the prototypes out by hand using custom types.<p>I think this is a very bad idea: you can&#x27;t depend on the headers not changing after a compiler or library update. Sure, <i>maybe</i> in practice, all the Windows types and declarations don&#x27;t change all that much, but I wouldn&#x27;t want to be the developer trying to hunt down a bug because the interface to some function has changed and the compiler isn&#x27;t giving me errors.<p>All in all, I dunno if I would look forward to working on a team with these conventions - the code is harder to read, doesn&#x27;t work in isolation, needs custom flags, and introduces a string type without introducing any string safety with it.</div><br/></div></div><div id="37815810" class="c"><input type="checkbox" id="c-37815810" checked=""/><div class="controls bullet"><span class="by">antiquark</span><span>|</span><a href="#37817749">prev</a><span>|</span><a href="#37815866">next</a><span>|</span><label class="collapse" for="c-37815810">[-]</label><label class="expand" for="c-37815810">[16 more]</label></div><br/><div class="children"><div class="content">&gt; #define sizeof(x)    (size)sizeof(x)<p>Technically, it&#x27;s illegal to #define over a language keyword.</div><br/><div id="37816188" class="c"><input type="checkbox" id="c-37816188" checked=""/><div class="controls bullet"><span class="by">wannacboatmovie</span><span>|</span><a href="#37815810">parent</a><span>|</span><a href="#37817020">next</a><span>|</span><label class="collapse" for="c-37816188">[-]</label><label class="expand" for="c-37816188">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re dead set on doing this, the correct way would be to name the macro in all caps e.g. #define SIZEOF(x) as C is case sensitive. It is somewhat self-documenting to the next guy that SIZEOF() != sizeof().</div><br/><div id="37816349" class="c"><input type="checkbox" id="c-37816349" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37816188">parent</a><span>|</span><a href="#37817020">next</a><span>|</span><label class="collapse" for="c-37816349">[-]</label><label class="expand" for="c-37816349">[1 more]</label></div><br/><div class="children"><div class="content">Any name is fine, as long as it isn&#x27;t literally &quot;sizeof&quot;.</div><br/></div></div></div></div><div id="37817020" class="c"><input type="checkbox" id="c-37817020" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#37815810">parent</a><span>|</span><a href="#37816188">prev</a><span>|</span><a href="#37815890">next</a><span>|</span><label class="collapse" for="c-37817020">[-]</label><label class="expand" for="c-37817020">[1 more]</label></div><br/><div class="children"><div class="content">Considering &#x27;#defines&#x27; are done in a textual pre-precessing by the C pre-processor, they don&#x27;t know much at all about the C language. You can define out int, long, struct or anything.<p>I have seen many people redefine &#x27;for&#x27; and &#x27;while&#x27;. These people often argue that it is an improvement.<p><pre><code>  cpp
  #define sizeof(x) (size)sizeof(x)
  sizeof(UU)</code></pre>
^D<p><pre><code>  # 1 &quot;&lt;stdin&gt;&quot;
  # 1 &quot;&lt;built-in&gt;&quot;
  # 1 &quot;&lt;command-line&gt;&quot;
  # 31 &quot;&lt;command-line&gt;&quot;
  # 1 &quot;&#x2F;usr&#x2F;include&#x2F;stdc-predef.h&quot; 1 3 4
  # 32 &quot;&lt;command-line&gt;&quot; 2
  # 1 &quot;&lt;stdin&gt;&quot;
  (size)sizeof(UU)</code></pre></div><br/></div></div><div id="37815890" class="c"><input type="checkbox" id="c-37815890" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#37815810">parent</a><span>|</span><a href="#37817020">prev</a><span>|</span><a href="#37816110">next</a><span>|</span><label class="collapse" for="c-37815890">[-]</label><label class="expand" for="c-37815890">[4 more]</label></div><br/><div class="children"><div class="content">really? then how do you #define things like types like `int` and `char`?</div><br/><div id="37815990" class="c"><input type="checkbox" id="c-37815990" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37815890">parent</a><span>|</span><a href="#37815917">next</a><span>|</span><label class="collapse" for="c-37815990">[-]</label><label class="expand" for="c-37815990">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t.</div><br/></div></div><div id="37815917" class="c"><input type="checkbox" id="c-37815917" checked=""/><div class="controls bullet"><span class="by">antiquark</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37815890">parent</a><span>|</span><a href="#37815990">prev</a><span>|</span><a href="#37816110">next</a><span>|</span><label class="collapse" for="c-37815917">[-]</label><label class="expand" for="c-37815917">[2 more]</label></div><br/><div class="children"><div class="content">For example, it would be illegal to do the following:<p>&gt; #define int long<p>Because you&#x27;re replacing the int keyword with something else.<p>The standard says:<p>&gt; 17.6.4.3.1 [macro.names] paragraph 2: A translation unit shall not #define or #undef names lexically identical to keywords, to the identifiers listed in Table 3, or to the attribute-tokens described in 7.6.</div><br/><div id="37817277" class="c"><input type="checkbox" id="c-37817277" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37815917">parent</a><span>|</span><a href="#37816110">next</a><span>|</span><label class="collapse" for="c-37817277">[-]</label><label class="expand" for="c-37817277">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s C++.
But I couldn&#x27;t find the same restriction in C. In fact it seems that C allows it as long as you don&#x27;t include any of the standard C header.<p>&gt; 7.1.2 &quot;Standard headers&quot; §5 [...] The program shall not have any
macros with names lexically identical to keywords currently defined prior to the inclusion of the
header or when any macro defined in the header is expanded.</div><br/></div></div></div></div></div></div><div id="37816110" class="c"><input type="checkbox" id="c-37816110" checked=""/><div class="controls bullet"><span class="by">oh_sigh</span><span>|</span><a href="#37815810">parent</a><span>|</span><a href="#37815890">prev</a><span>|</span><a href="#37815866">next</a><span>|</span><label class="collapse" for="c-37816110">[-]</label><label class="expand" for="c-37816110">[8 more]</label></div><br/><div class="children"><div class="content">Also, `#define countof(a)   (sizeof(a) &#x2F; sizeof(*(a)))` is unsafe since the arg is evaluated twice.</div><br/><div id="37816340" class="c"><input type="checkbox" id="c-37816340" checked=""/><div class="controls bullet"><span class="by">f33d5173</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37816110">parent</a><span>|</span><a href="#37816161">next</a><span>|</span><label class="collapse" for="c-37816340">[-]</label><label class="expand" for="c-37816340">[4 more]</label></div><br/><div class="children"><div class="content">The arg is expanded twice but evaluated zero times, since sizeof gives the size of its argument type without executing anything.</div><br/><div id="37816881" class="c"><input type="checkbox" id="c-37816881" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37816340">parent</a><span>|</span><a href="#37816161">next</a><span>|</span><label class="collapse" for="c-37816881">[-]</label><label class="expand" for="c-37816881">[3 more]</label></div><br/><div class="children"><div class="content">countof(foo()) looks like foo() is only called once, but would actually be called twice.  That&#x27;s what GP is talking about, it&#x27;s evaluated twice after the expansion when the code is actually running, not during the expansion.</div><br/><div id="37817414" class="c"><input type="checkbox" id="c-37817414" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37816881">parent</a><span>|</span><a href="#37817113">next</a><span>|</span><label class="collapse" for="c-37817414">[-]</label><label class="expand" for="c-37817414">[1 more]</label></div><br/><div class="children"><div class="content">It is not evaluated for regular arrays. It is evaluated for arrays with variable size, you need to be careful a bit. But this is rarely happens to be a problem.<p>The general rule for sizeof is to apply it only to variable names or directly to typenames.</div><br/></div></div></div></div></div></div><div id="37816161" class="c"><input type="checkbox" id="c-37816161" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37816110">parent</a><span>|</span><a href="#37816340">prev</a><span>|</span><a href="#37816333">next</a><span>|</span><label class="collapse" for="c-37816161">[-]</label><label class="expand" for="c-37816161">[1 more]</label></div><br/><div class="children"><div class="content">This is a very common macro to get static array lengths and i&#x27;m not sure there is any other way to do the same thing (i.e. give a static array, get back the number of items in it) in any other way.</div><br/></div></div><div id="37816333" class="c"><input type="checkbox" id="c-37816333" checked=""/><div class="controls bullet"><span class="by">david2ndaccount</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37816110">parent</a><span>|</span><a href="#37816161">prev</a><span>|</span><a href="#37815866">next</a><span>|</span><label class="collapse" for="c-37816333">[-]</label><label class="expand" for="c-37816333">[2 more]</label></div><br/><div class="children"><div class="content">Arguments to sizeof aren’t actually evaluated (except for variably-modified-types, AKA VLAs, but don’t use those).</div><br/><div id="37817108" class="c"><input type="checkbox" id="c-37817108" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#37815810">root</a><span>|</span><a href="#37816333">parent</a><span>|</span><a href="#37815866">next</a><span>|</span><label class="collapse" for="c-37817108">[-]</label><label class="expand" for="c-37817108">[1 more]</label></div><br/><div class="children"><div class="content">Please use those. They are useful, make code clearer, improve bounds checking, ...<p>Don&#x27;t let attackers influence the size of a buffer (neither for VLAs nor for heap allocations).</div><br/></div></div></div></div></div></div></div></div><div id="37818109" class="c"><input type="checkbox" id="c-37818109" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#37815866">prev</a><span>|</span><a href="#37816642">next</a><span>|</span><label class="collapse" for="c-37818109">[-]</label><label class="expand" for="c-37818109">[2 more]</label></div><br/><div class="children"><div class="content">&gt; #define countof(a)   (sizeof(a) &#x2F; sizeof(*(a)))<p>&gt; #define lengthof(s)  (countof(s) - 1)<p>It makes no sense to use the word &quot;length&quot; to mean one less than the number of items. You could call it maxindexof perhaps.<p>There may be good arguments for zero based indexing, but we have to also accept that there are downsides. One is that your code has to feature an artificial quantity obtained by subtracting one from a meaningful quantity.</div><br/><div id="37818400" class="c"><input type="checkbox" id="c-37818400" checked=""/><div class="controls bullet"><span class="by">abareplace</span><span>|</span><a href="#37818109">parent</a><span>|</span><a href="#37816642">next</a><span>|</span><label class="collapse" for="c-37818400">[-]</label><label class="expand" for="c-37818400">[1 more]</label></div><br/><div class="children"><div class="content">This is length of a null-terminated string, e.g. lengthof(&quot;abc&quot;).</div><br/></div></div></div></div><div id="37816642" class="c"><input type="checkbox" id="c-37816642" checked=""/><div class="controls bullet"><span class="by">EPWN3D</span><span>|</span><a href="#37818109">prev</a><span>|</span><label class="collapse" for="c-37816642">[-]</label><label class="expand" for="c-37816642">[1 more]</label></div><br/><div class="children"><div class="content">lol &quot;no const&quot;. This is really groundbreaking stuff. Let&#x27;s take a memory-unsafe language and make it even less safe.</div><br/></div></div></div></div></div></div></div></body></html>