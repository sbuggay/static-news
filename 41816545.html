<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728810068115" as="style"/><link rel="stylesheet" href="styles.css?v=1728810068115"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www-ps.informatik.uni-kiel.de/~mh/papers/WLP24.pdf">Can logic programming be liberated from predicates and backtracking? [pdf]</a>Â <span class="domain">(<a href="https://www-ps.informatik.uni-kiel.de">www-ps.informatik.uni-kiel.de</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>13 comments</span></div><br/><div><div id="41825355" class="c"><input type="checkbox" id="c-41825355" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#41826106">next</a><span>|</span><label class="collapse" for="c-41825355">[-]</label><label class="expand" for="c-41825355">[3 more]</label></div><br/><div class="children"><div class="content">Man, lately, I feel like this stuff has been following me around. I&#x27;d really like to deep-dive into logic programming and related paradigms. Just recently came across Answer Set Programming[0] (via Potassco&#x27;s clingo[1]), and it has made me realize just how ignorant I am of the design space that&#x27;s being explored here.<p>More personally, I recently spent enough time with first Scheme and then APL that the paradigms clicked for me, and the effect that had on the entirety of my outlook on work was dramatically changed as a result. For whatever reason, I feel like breaking down my ingrained technical paradigms has allowed me to integrate and strengthen my soft skills.<p>Plus, mind-expanding experiences are just plain fun. Looking for more of that juice!<p>[0]:<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Answer_set_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Answer_set_programming</a><p>[1]:<a href="https:&#x2F;&#x2F;potassco.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;potassco.org&#x2F;</a></div><br/><div id="41825966" class="c"><input type="checkbox" id="c-41825966" checked=""/><div class="controls bullet"><span class="by">gnulinux</span><span>|</span><a href="#41825355">parent</a><span>|</span><a href="#41826083">next</a><span>|</span><label class="collapse" for="c-41825966">[-]</label><label class="expand" for="c-41825966">[1 more]</label></div><br/><div class="children"><div class="content">I strongly recommend checking Souffle programming language. It&#x27;s a dialect of Datalog that can output bulk CSV data that can be easily imported into other databases (like Duckdb or Excel etc). It creates an extremely intuitive framework for logical programming. I.e. you can visualize logical programming as each relation being a giant table of elements, &quot;or&quot; operation being akin to SQL `union all`, &quot;and&quot; operation being akin to SQL `join`, &quot;not&quot; operation being akin to `outer join ... where joined isnull` etc...</div><br/></div></div><div id="41826083" class="c"><input type="checkbox" id="c-41826083" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#41825355">parent</a><span>|</span><a href="#41825966">prev</a><span>|</span><a href="#41826106">next</a><span>|</span><label class="collapse" for="c-41826083">[-]</label><label class="expand" for="c-41826083">[1 more]</label></div><br/><div class="children"><div class="content">Could have been an LSD trip description</div><br/></div></div></div></div><div id="41826106" class="c"><input type="checkbox" id="c-41826106" checked=""/><div class="controls bullet"><span class="by">woolion</span><span>|</span><a href="#41825355">prev</a><span>|</span><a href="#41825460">next</a><span>|</span><label class="collapse" for="c-41826106">[-]</label><label class="expand" for="c-41826106">[1 more]</label></div><br/><div class="children"><div class="content">This is a reference to the &quot;Can programming be liberated from the von Neumann style?&quot; from 1977.
It argues for functional programming, making the point that the imperative style is more common for efficiency reasons, as the programming model is close to the computer architecture.
It aims to be a general thought framework inviting to step a step back on some notions that have been (hastily?) accepted in the programming world.<p>It makes the same analogy that Prolog (or logic programming languages in general) have been strongly influenced by the resolution algorithm. In practice that means that if you write a non-trivial program, if performance is not right you&#x27;ll need to understand the execution model and adapt to it, mainly with the pruning operator (!). So while the promise is to &quot;declare&quot; values and not think about the implementation details, you&#x27;re railroaded to think in a very specific way.<p>I personally found that frustrating to find good solutions essentially unworkable because of this, in comparison with either imperative or functional paradigms that are significantly more flexible.
As a result, Prolog-style programming feels limited to the small problems for which it is readily a good fit, to be integrated into a general program using a general-purpose language.
I may be wrong on this, but of the 50 people that learned Prolog around the same time as me, none kept up with it. Meanwhile, other niche languages like Ocaml, Haskell and Scheme had good success.<p>Rethinking the language foundation could remove these barriers to give the language a broader user base.</div><br/></div></div><div id="41825460" class="c"><input type="checkbox" id="c-41825460" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#41826106">prev</a><span>|</span><a href="#41826158">next</a><span>|</span><label class="collapse" for="c-41825460">[-]</label><label class="expand" for="c-41825460">[1 more]</label></div><br/><div class="children"><div class="content">The Curry language (<a href="https:&#x2F;&#x2F;www.curry-language.org" rel="nofollow">https:&#x2F;&#x2F;www.curry-language.org</a>) does look interesting.  Does anybody have practical experience with it?</div><br/></div></div><div id="41826158" class="c"><input type="checkbox" id="c-41826158" checked=""/><div class="controls bullet"><span class="by">amboo7</span><span>|</span><a href="#41825460">prev</a><span>|</span><a href="#41825316">next</a><span>|</span><label class="collapse" for="c-41826158">[-]</label><label class="expand" for="c-41826158">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;icfp24.sigplan.org&#x2F;home&#x2F;minikanren-2024#event-overview" rel="nofollow">https:&#x2F;&#x2F;icfp24.sigplan.org&#x2F;home&#x2F;minikanren-2024#event-overvi...</a>
is related. There has been work on turning slow bidirectional code into faster functional code (in 2023, reachable from this url).</div><br/></div></div><div id="41825316" class="c"><input type="checkbox" id="c-41825316" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#41826158">prev</a><span>|</span><a href="#41825878">next</a><span>|</span><label class="collapse" for="c-41825316">[-]</label><label class="expand" for="c-41825316">[4 more]</label></div><br/><div class="children"><div class="content"><i>Abstract</i>. Logic programming has a long history. The representative of
logic programming in practice, the language Prolog, has been introduced
more than 50 years ago. The main features of Prolog are still present
today: a Prolog program is a set of predicate definitions executed by
resolution steps with a backtracking search strategy. The use of back-
tracking was justified by efficiency reasons when Prolog was invented.
However, its incompleteness destroys the elegant connection of logic pro-
gramming and the underlying Horn clause logic and causes difficulties to
teach logic programming. Moreover, the restriction to predicates hinders
an adequate modeling of real world problems, which are often functions
from input to output data, and leads to unnecessarily inefficient exe-
cutions. In this paper we show a way to overcome these problems. By
transforming predicates and goals into functions and nested expressions,
one can evaluate them with a demand-driven strategy which might re-
duce the number of computation steps and avoid infinite search spaces.
Replacing backtracking by complete search strategies with new imple-
mentation techniques closes the gap between the theory and practice of
logic programming. In this way, we can keep the ideas of logic program-
ming in future programming systems.</div><br/><div id="41825579" class="c"><input type="checkbox" id="c-41825579" checked=""/><div class="controls bullet"><span class="by">bradley13</span><span>|</span><a href="#41825316">parent</a><span>|</span><a href="#41826079">next</a><span>|</span><label class="collapse" for="c-41825579">[-]</label><label class="expand" for="c-41825579">[2 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t read past the abstract, but it sounds like they are just transforming logic-based programs into function-based programs. But: if I wanted functional programming, I wouldn&#x27;t be writing in Prolog.<p>What would be interesting, would be to replace depth-first search while remaining in the world of predicates and Horn clauses.</div><br/><div id="41825877" class="c"><input type="checkbox" id="c-41825877" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#41825316">root</a><span>|</span><a href="#41825579">parent</a><span>|</span><a href="#41826079">next</a><span>|</span><label class="collapse" for="c-41825877">[-]</label><label class="expand" for="c-41825877">[1 more]</label></div><br/><div class="children"><div class="content">functional logic programming is not equivalent to functional programming.</div><br/></div></div></div></div><div id="41826079" class="c"><input type="checkbox" id="c-41826079" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#41825316">parent</a><span>|</span><a href="#41825579">prev</a><span>|</span><a href="#41825878">next</a><span>|</span><label class="collapse" for="c-41826079">[-]</label><label class="expand" for="c-41826079">[1 more]</label></div><br/><div class="children"><div class="content">isn&#x27;t backtracking a complete search strategy?</div><br/></div></div></div></div><div id="41825781" class="c"><input type="checkbox" id="c-41825781" checked=""/><div class="controls bullet"><span class="by">HeralFacker</span><span>|</span><a href="#41825878">prev</a><span>|</span><label class="collapse" for="c-41825781">[-]</label><label class="expand" for="c-41825781">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s called functional programming and it&#x27;s been around for a while</div><br/></div></div></div></div></div></div></div></body></html>