<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703840466035" as="style"/><link rel="stylesheet" href="styles.css?v=1703840466035"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dubroy.com/blog/cold-blooded-software/">Cold-blooded software</a> <span class="domain">(<a href="https://dubroy.com">dubroy.com</a>)</span></div><div class="subtext"><span>arbesman</span> | <span>147 comments</span></div><br/><div><div id="38799483" class="c"><input type="checkbox" id="c-38799483" checked=""/><div class="controls bullet"><span class="by">__natty__</span><span>|</span><a href="#38797403">next</a><span>|</span><label class="collapse" for="c-38799483">[-]</label><label class="expand" for="c-38799483">[3 more]</label></div><br/><div class="children"><div class="content">In the Node &amp; JavaScript ecosystem, there is the web framework Express. The current major version 4.x.x branch is over 10 years old [1]. And yet it powers so many apps in the ecosystem (over 17M downloads every week [2]). It lacks some features and is not the most performant [3]. But me and coworkers I talked with, like it because it allows for quick, stable development and long-term planning without worrying about drastic API changes and lack of security patches for older versions. Even better stability is provided with Go where we can run over 10-year-old programs thanks to a mix of wide stdlib and the promise of compatibility. [4]<p>[1] <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;express?activeTab=versions" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;express?activeTab=versions</a><p>[2] <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;express" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;express</a><p>[3] <a href="https:&#x2F;&#x2F;fastify.dev&#x2F;benchmarks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fastify.dev&#x2F;benchmarks&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1compat" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1compat</a></div><br/><div id="38801541" class="c"><input type="checkbox" id="c-38801541" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#38799483">parent</a><span>|</span><a href="#38801587">next</a><span>|</span><label class="collapse" for="c-38801541">[-]</label><label class="expand" for="c-38801541">[1 more]</label></div><br/><div class="children"><div class="content">This gave me a pleasant shock. I&#x27;d forgotten that Express has been around for 13 years now. It was considered a super shoddy, pretend-programmer piece of junk by many when it first arrived (largely by virtue of being written in JavaScript). Since then I&#x27;ve helped a lot of companies build cool stuff that made real money with it. It&#x27;s probably serving a crazy number of requests these days.<p>I write a lot of things with Go now instead, but I&#x27;m still totally content to build things with Express. It&#x27;s good software, generally speaking.</div><br/></div></div><div id="38801587" class="c"><input type="checkbox" id="c-38801587" checked=""/><div class="controls bullet"><span class="by">rareitem</span><span>|</span><a href="#38799483">parent</a><span>|</span><a href="#38801541">prev</a><span>|</span><a href="#38797403">next</a><span>|</span><label class="collapse" for="c-38801587">[-]</label><label class="expand" for="c-38801587">[1 more]</label></div><br/><div class="children"><div class="content">Express v5 is <i>allegedly</i> coming out in the near future (<a href="https:&#x2F;&#x2F;github.com&#x2F;expressjs&#x2F;express&#x2F;issues&#x2F;4920">https:&#x2F;&#x2F;github.com&#x2F;expressjs&#x2F;express&#x2F;issues&#x2F;4920</a>)</div><br/></div></div></div></div><div id="38797403" class="c"><input type="checkbox" id="c-38797403" checked=""/><div class="controls bullet"><span class="by">imran-iq</span><span>|</span><a href="#38799483">prev</a><span>|</span><a href="#38801917">next</a><span>|</span><label class="collapse" for="c-38797403">[-]</label><label class="expand" for="c-38797403">[38 more]</label></div><br/><div class="children"><div class="content">Python is a really bad example of cold blooded software. There is constant breaking changes with it (both runtime and tooling). So much so that the author still has to use python2 which has been EOL&#x27;d for quite a while.<p>A much better example would be something like go or java where 10 year old code still runs fine with their modern tooling. Or an even better example, perl, where 30 year old code still runs fine to this day</div><br/><div id="38801534" class="c"><input type="checkbox" id="c-38801534" checked=""/><div class="controls bullet"><span class="by">wmorgan</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38799813">next</a><span>|</span><label class="collapse" for="c-38801534">[-]</label><label class="expand" for="c-38801534">[2 more]</label></div><br/><div class="children"><div class="content">Very true!<p>As an author of software, sometimes you make mistakes, and those mistakes are often of the form, &quot;I permitted the user to do something which I didn&#x27;t intend.&quot; How do you correct something like that? In the Java world, the answer is &quot;add newer &amp; safer &amp; more intentional capabilities, and encourage the user to migrate.&quot;<p>In the Python world, this answer is the same, but it also goes further to add, &quot;... and turn off the old capability, SOON,&quot; which is something that Java doesn&#x27;t do. In the Java world, you continue to support the old thing, basically forever, or until you have no other choice. See, for example, the equals method of java.net.URL: known to be broken, strongly discouraged, but still supported after 20+ years.<p>Here&#x27;s an example of the difference which I&#x27;m talking about: Python Airflow has an operator which does nothing -- an empty operator. Up through a certain version, they supported calling this the DummyOperator, after an ordinary definition for &quot;dummy.&quot; But also -- the word &quot;dummy&quot; has been used, historically &amp; in certain cultures &amp; situations, as a slur. So the Airflow maintainers said, &quot;that&#x27;s it! No more users of our software are permitted to call their operators DummyOperator -- they now must call it EmptyOperator instead!&quot; So if you tried to upgrade, you would get an error at the time your code was loaded, until you renamed your references.<p>This decision has its own internal consistency, I suppose. (I personally would not break my users in this way). But in the Java world it wouldn&#x27;t even be a question -- you&#x27;d support the thing until you couldn&#x27;t. If the breakage in question is basically just a renaming, well, the one thing computers are good at is text substitution.<p>So overall &amp; in my opinion anyway, yes, it&#x27;s very much true that you can upgrade Java &amp; Java library dependencies much more freely than you can do the same sorts of things with Python.</div><br/><div id="38801640" class="c"><input type="checkbox" id="c-38801640" checked=""/><div class="controls bullet"><span class="by">matt123456789</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801534">parent</a><span>|</span><a href="#38799813">next</a><span>|</span><label class="collapse" for="c-38801640">[-]</label><label class="expand" for="c-38801640">[1 more]</label></div><br/><div class="children"><div class="content">Not to detract from your point (which I agree with), but rather as a side note, Airflow&#x27;s developers publish top-notch migration and upgrade documentation and tools which hold your hand through the process of updating your DAGs when upgrading Airflow. Which IMO is the next best thing to do when you break backwards compatibility.</div><br/></div></div></div></div><div id="38799813" class="c"><input type="checkbox" id="c-38799813" checked=""/><div class="controls bullet"><span class="by">hmottestad</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38801534">prev</a><span>|</span><a href="#38802719">next</a><span>|</span><label class="collapse" for="c-38799813">[-]</label><label class="expand" for="c-38799813">[1 more]</label></div><br/><div class="children"><div class="content">Maven is fantastic. As long as you stick to an LTS Java version and pick good dependencies you can always get things up and running. With Python I remember a ML class I took where one of the dependencies had introduced breaking API changes overnight and the lecturer hadn’t noticed because he was just using whatever version was available a few weeks ago when he first started prepping for the class.</div><br/></div></div><div id="38802719" class="c"><input type="checkbox" id="c-38802719" checked=""/><div class="controls bullet"><span class="by">fliggertiggy</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38799813">prev</a><span>|</span><a href="#38800707">next</a><span>|</span><label class="collapse" for="c-38802719">[-]</label><label class="expand" for="c-38802719">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had good luck with sveltekit (a framework for js sites). They&#x27;ll break something with a new version but provide you with very helpful compile errors pointing to a migration script to re-write any old code.<p>C# has been pretty good as well.<p>But at some point you&#x27;re going to need data for your app and that&#x27;s where you&#x27;ll get surprised. That Yahoo currency data you used to get for free or Wikipedia&#x27;s mobile API? Gone ten years later.</div><br/><div id="38802778" class="c"><input type="checkbox" id="c-38802778" checked=""/><div class="controls bullet"><span class="by">zx8080</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38802719">parent</a><span>|</span><a href="#38800707">next</a><span>|</span><label class="collapse" for="c-38802778">[-]</label><label class="expand" for="c-38802778">[2 more]</label></div><br/><div class="children"><div class="content">C# with AWS lambda can easily become a trap. Once a dotnet version comes EoL on lambda, good luck with a DB schema (specifically, EF).</div><br/><div id="38802934" class="c"><input type="checkbox" id="c-38802934" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38802778">parent</a><span>|</span><a href="#38800707">next</a><span>|</span><label class="collapse" for="c-38802934">[-]</label><label class="expand" for="c-38802934">[1 more]</label></div><br/><div class="children"><div class="content">What? You can just update EF Core without ever having to do a migration of the schema. It just works. Also, the versions that are EoL today are a really poor choice for Lambda anyway because you really do want to be using Native AOT + Dapper AOT with it instead.</div><br/></div></div></div></div></div></div><div id="38800707" class="c"><input type="checkbox" id="c-38800707" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38802719">prev</a><span>|</span><a href="#38799687">next</a><span>|</span><label class="collapse" for="c-38800707">[-]</label><label class="expand" for="c-38800707">[10 more]</label></div><br/><div class="children"><div class="content"><i>&gt; There is constant breaking changes with it (both runtime and tooling).</i><p>I&#x27;m not sure what you mean. Python 2 to 3 was a breaking change, but that was just one change, not &quot;constant breaking changes&quot;.<p>If you stick with one major version no old code breaks with a new minor version (e.g., you can run old 2.x code under 2.7 just fine, and you can run old 3.x code under 3.12 just fine). The minor version changes can add new features that your old code won&#x27;t make use of (for example, old 3.x code won&#x27;t use the &quot;async&quot; keyword or type annotations), but that doesn&#x27;t make the old code break.</div><br/><div id="38802887" class="c"><input type="checkbox" id="c-38802887" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38800707">parent</a><span>|</span><a href="#38800944">next</a><span>|</span><label class="collapse" for="c-38802887">[-]</label><label class="expand" for="c-38802887">[1 more]</label></div><br/><div class="children"><div class="content">The problem is `requirements.txt` doesn&#x27;t do anything with downstream dependencies. There&#x27;s nothing like a shinkwrap&#x2F;lockfile in python. Even if you pin dependencies to exact versions, if you check your project out in a new environment and run pip install -r requirements.txt, you can end up with different, broken downstream dependencies.<p>This happens <i>a lot</i> for me.</div><br/></div></div><div id="38800944" class="c"><input type="checkbox" id="c-38800944" checked=""/><div class="controls bullet"><span class="by">bryancoxwell</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38800707">parent</a><span>|</span><a href="#38802887">prev</a><span>|</span><a href="#38801074">next</a><span>|</span><label class="collapse" for="c-38800944">[-]</label><label class="expand" for="c-38800944">[3 more]</label></div><br/><div class="children"><div class="content">The Python 3.11 release notes have a pretty lengthy list of removed or changed Python and C APIs followed by guidance on porting to 3.11, which implies potentially breaking changes to me.</div><br/><div id="38801113" class="c"><input type="checkbox" id="c-38801113" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38800944">parent</a><span>|</span><a href="#38801074">next</a><span>|</span><label class="collapse" for="c-38801113">[-]</label><label class="expand" for="c-38801113">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a fair point that Python minor version changes can and do involve removal of previously deprecated APIs, which would break old code that used those APIs.<p>That said, when I look through the 3.11 release notes you refer to, I see basically three categories of such changes:<p>- Items that were deprecated very early in Python 3 development (3.2, for example). Since 3.3 was the first basically usable Python 3 version, I doubt there is much legacy Python 3 code that will be broken by these changes.<p>- Items related to early versions of new APIs introduced in Python 3 (for example, deprecating early versions of the async APIs now that async development has settled on later ones that were found to work better). These sorts of breaking changes can be avoided by not using APIs that are basically experimental and are declared to be so (as the early async APIs were).<p>- Items related to supporting old OSs or data formats that nobody really uses any more.<p>So, while these are, strictly speaking, breaking changes, I still don&#x27;t think that &quot;constant breaking changes&quot; is a good description of the general state of Python development.</div><br/><div id="38801753" class="c"><input type="checkbox" id="c-38801753" checked=""/><div class="controls bullet"><span class="by">jujube3</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801113">parent</a><span>|</span><a href="#38801074">next</a><span>|</span><label class="collapse" for="c-38801753">[-]</label><label class="expand" for="c-38801753">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s changes between releases are not limited to removing deprecated APIs. Sometimes semantics changes in breaking ways, or new reserved words crop up, etc. etc. It certainly is Russian roulette trying to run python code on any version other than the one it was written for.</div><br/></div></div></div></div></div></div><div id="38801074" class="c"><input type="checkbox" id="c-38801074" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38800707">parent</a><span>|</span><a href="#38800944">prev</a><span>|</span><a href="#38799687">next</a><span>|</span><label class="collapse" for="c-38801074">[-]</label><label class="expand" for="c-38801074">[5 more]</label></div><br/><div class="children"><div class="content">&gt; you can run old 2.x code under 2.7 just fine<p>No you can&#x27;t lol. There were major breaking changes from 2.4 -&gt; 2.5, and smaller but still breaking ones for 2.5 -&gt; 2.6.</div><br/><div id="38801127" class="c"><input type="checkbox" id="c-38801127" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801074">parent</a><span>|</span><a href="#38799687">next</a><span>|</span><label class="collapse" for="c-38801127">[-]</label><label class="expand" for="c-38801127">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; There were major breaking changes from 2.4 -&gt; 2.5, and smaller but still breaking ones for 2.5 -&gt; 2.6.</i><p>Such as?</div><br/><div id="38801401" class="c"><input type="checkbox" id="c-38801401" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801127">parent</a><span>|</span><a href="#38799687">next</a><span>|</span><label class="collapse" for="c-38801401">[-]</label><label class="expand" for="c-38801401">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t remember the specifics, but I spent at least a few weeks early in my career fixing a Python 2.3 codebase to run on 2.4.</div><br/><div id="38801570" class="c"><input type="checkbox" id="c-38801570" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801401">parent</a><span>|</span><a href="#38799687">next</a><span>|</span><label class="collapse" for="c-38801570">[-]</label><label class="expand" for="c-38801570">[2 more]</label></div><br/><div class="children"><div class="content">In the GP you said 2.5 and 2.6, not 2.4.<p>That said, I remember all three of those transitions (2.3 to 2.4, 2.4 to 2.5, and 2.5 to 2.6), and I remember changing Python code to make use of new features introduced in those transitions (for example, using with statements and context managers in 2.5), but those aren&#x27;t breaking changes; the old code still worked, it just wasn&#x27;t as robust as using the new features.</div><br/><div id="38801675" class="c"><input type="checkbox" id="c-38801675" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801570">parent</a><span>|</span><a href="#38799687">next</a><span>|</span><label class="collapse" for="c-38801675">[-]</label><label class="expand" for="c-38801675">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the GP you said 2.5 and 2.6, not 2.4.<p>Sorry, yes, fixing a 2.4 codebase to run on 2.5. It was a while ago.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38799687" class="c"><input type="checkbox" id="c-38799687" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38800707">prev</a><span>|</span><a href="#38799586">next</a><span>|</span><label class="collapse" for="c-38799687">[-]</label><label class="expand" for="c-38799687">[7 more]</label></div><br/><div class="children"><div class="content">&gt; java where 10 year old code still runs fine with their modern tooling<p>I don’t know about you. But even when I try to run 3 year old Java code with a new SDK it’s always broken <i>somehow</i>.</div><br/><div id="38799833" class="c"><input type="checkbox" id="c-38799833" checked=""/><div class="controls bullet"><span class="by">hmottestad</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799687">parent</a><span>|</span><a href="#38801749">next</a><span>|</span><label class="collapse" for="c-38799833">[-]</label><label class="expand" for="c-38799833">[1 more]</label></div><br/><div class="children"><div class="content">I maintain Eclipse RDF4J and I noticed this too between Java 9 and 11, after that there haven’t been any breaking things except for having to bump a maven plugin dependency. We make sure to stay compatible with both Java 11 and whatever is the newest version by running our CI on both Java versions.</div><br/></div></div><div id="38801749" class="c"><input type="checkbox" id="c-38801749" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799687">parent</a><span>|</span><a href="#38799833">prev</a><span>|</span><a href="#38799788">next</a><span>|</span><label class="collapse" for="c-38801749">[-]</label><label class="expand" for="c-38801749">[1 more]</label></div><br/><div class="children"><div class="content">I write Java for 15 years and I&#x27;ve yet to encounter a single JVM bug or incompatibility. It&#x27;s always application to blame.<p>The only exception is Java 9 which removed some Java EE dependencies from JDK, but that&#x27;s easily solved.<p>Just an example: I&#x27;m running application on Java 21 which uses Oracle 9i driver that was compiled for Java 1.4 and it works fine.</div><br/></div></div><div id="38799788" class="c"><input type="checkbox" id="c-38799788" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799687">parent</a><span>|</span><a href="#38801749">prev</a><span>|</span><a href="#38801083">next</a><span>|</span><label class="collapse" for="c-38799788">[-]</label><label class="expand" for="c-38799788">[1 more]</label></div><br/><div class="children"><div class="content">Years? After one year, something amongst the hundreds of deps will have a horrible security vulnerability and updating means breaking changes.</div><br/></div></div><div id="38801083" class="c"><input type="checkbox" id="c-38801083" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799687">parent</a><span>|</span><a href="#38799788">prev</a><span>|</span><a href="#38799586">next</a><span>|</span><label class="collapse" for="c-38801083">[-]</label><label class="expand" for="c-38801083">[3 more]</label></div><br/><div class="children"><div class="content">Any examples? Actual Java code works all the way back to 1996 IME, the only thing that breaks is reflection nonsense, usually Spring.</div><br/><div id="38801748" class="c"><input type="checkbox" id="c-38801748" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801083">parent</a><span>|</span><a href="#38801611">next</a><span>|</span><label class="collapse" for="c-38801748">[-]</label><label class="expand" for="c-38801748">[1 more]</label></div><br/><div class="children"><div class="content">I had major issues running Bitcoin Armory after a few years, which was rather problematic.</div><br/></div></div><div id="38801611" class="c"><input type="checkbox" id="c-38801611" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801083">parent</a><span>|</span><a href="#38801748">prev</a><span>|</span><a href="#38799586">next</a><span>|</span><label class="collapse" for="c-38801611">[-]</label><label class="expand" for="c-38801611">[1 more]</label></div><br/><div class="children"><div class="content">You can run Minecraft 1.7.10 and mods on Java21 with surprisingly few changes needed.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;GTNewHorizons&#x2F;lwjgl3ify">https:&#x2F;&#x2F;github.com&#x2F;GTNewHorizons&#x2F;lwjgl3ify</a></div><br/></div></div></div></div></div></div><div id="38799586" class="c"><input type="checkbox" id="c-38799586" checked=""/><div class="controls bullet"><span class="by">blakesley</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38799687">prev</a><span>|</span><a href="#38798792">next</a><span>|</span><label class="collapse" for="c-38799586">[-]</label><label class="expand" for="c-38799586">[2 more]</label></div><br/><div class="children"><div class="content">Regarding Python: Really? Obviously v2-to-v3 was an absolute fiasco, but since then, it&#x27;s been great in my personal experience.<p>Don&#x27;t get me wrong: Python hasn&#x27;t overcome its tooling problem, so there&#x27;s still that barrier. But once your team agrees on a standardized tool set, you should be able to coast A-OK.</div><br/><div id="38800158" class="c"><input type="checkbox" id="c-38800158" checked=""/><div class="controls bullet"><span class="by">toasted-subs</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799586">parent</a><span>|</span><a href="#38798792">next</a><span>|</span><label class="collapse" for="c-38800158">[-]</label><label class="expand" for="c-38800158">[1 more]</label></div><br/><div class="children"><div class="content">Yeah but that&#x27;s expected given it went from a fancy scripting language to one that supports modern features of other programming languages.<p>I had a similar problem moving apps from earlier versions of Java a decade ago.</div><br/></div></div></div></div><div id="38798792" class="c"><input type="checkbox" id="c-38798792" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38799586">prev</a><span>|</span><a href="#38799415">next</a><span>|</span><label class="collapse" for="c-38798792">[-]</label><label class="expand" for="c-38798792">[6 more]</label></div><br/><div class="children"><div class="content">Agreed. This is one of the reasons why I avoid using Python whenever possible. Python code I write today is unlikely to be functional years from now, and I consider that a pretty huge problem.</div><br/><div id="38800716" class="c"><input type="checkbox" id="c-38800716" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38798792">parent</a><span>|</span><a href="#38799161">next</a><span>|</span><label class="collapse" for="c-38800716">[-]</label><label class="expand" for="c-38800716">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Python code I write today is unlikely to be functional years from now</i><p>I don&#x27;t see why not. I have been writing Python for close to 20 years now, and I still have code from my early days with it that runs just fine today.</div><br/></div></div><div id="38799161" class="c"><input type="checkbox" id="c-38799161" checked=""/><div class="controls bullet"><span class="by">heurist</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38798792">parent</a><span>|</span><a href="#38800716">prev</a><span>|</span><a href="#38800151">next</a><span>|</span><label class="collapse" for="c-38799161">[-]</label><label class="expand" for="c-38799161">[3 more]</label></div><br/><div class="children"><div class="content">This really depends on your environment. I&#x27;ve been running legacy Python servers continuously for 4+ years without breaking them or extensively modifying them because I invested in the environment and tooling around it (which I would do for any app I deploy). I can&#x27;t say I want to bring all of them entirely up to date with dependencies, but they&#x27;re still perfectly functional. Python is pretty great, honestly. I rarely need to venture into anything else (for the kind of work I do).</div><br/><div id="38799229" class="c"><input type="checkbox" id="c-38799229" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799161">parent</a><span>|</span><a href="#38800151">next</a><span>|</span><label class="collapse" for="c-38799229">[-]</label><label class="expand" for="c-38799229">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been running legacy Python servers continuously for 4+ years<p>That seems like a large amount of effort to make up for a large language deficiency. My (heartfelt) kudos to you!<p>I might have been willing to do the same if I used Python heavily (I don&#x27;t because there are a number of other things that makes it very much &quot;not for me&quot;) -- but it would still represent effort that shouldn&#x27;t need to be engaged in.</div><br/><div id="38801075" class="c"><input type="checkbox" id="c-38801075" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799229">parent</a><span>|</span><a href="#38800151">next</a><span>|</span><label class="collapse" for="c-38801075">[-]</label><label class="expand" for="c-38801075">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends on which bits of the Python ecosystem you&#x27;re interacting with. The numerical&#x2F;scientific parts have been quite stable for at least the past 10 years (new features have been added, but only small amounts of removal), compared with the more &quot;AI&quot; focused parts where I wouldn&#x27;t trust the code to be working in 6 months. Similarly, some web frameworks are more stable than others. I think also over the last 5 or so years, there&#x27;s been a change in maintainers of some larger projects, and the new maintainers have introduced more breaking changes than their predecessors.<p>None of this is implied by the language, I think it&#x27;s much more driven by culture (though I think the final dropping of support for Python 2 did give some maintainers an excuse to do more breaking changes than was maybe required).</div><br/></div></div></div></div></div></div><div id="38800151" class="c"><input type="checkbox" id="c-38800151" checked=""/><div class="controls bullet"><span class="by">toasted-subs</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38798792">parent</a><span>|</span><a href="#38799161">prev</a><span>|</span><a href="#38799415">next</a><span>|</span><label class="collapse" for="c-38800151">[-]</label><label class="expand" for="c-38800151">[1 more]</label></div><br/><div class="children"><div class="content">Any problem you have with python could be used describe Amy nodejs application.<p>Your just trying to get people to use languages which are less useful in practice (other than Java).</div><br/></div></div></div></div><div id="38799415" class="c"><input type="checkbox" id="c-38799415" checked=""/><div class="controls bullet"><span class="by">frizlab</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38798792">prev</a><span>|</span><a href="#38799592">next</a><span>|</span><label class="collapse" for="c-38799415">[-]</label><label class="expand" for="c-38799415">[3 more]</label></div><br/><div class="children"><div class="content">Go is not a good example either. Some times ago we tried compiling a code a few years after it was made, it did not work. Someone who actually knew the language and tooling tried and said there was a migration to be done and it was complicated. I have not followed the subject up close but in the end they just abandoned IIRC.</div><br/><div id="38801721" class="c"><input type="checkbox" id="c-38801721" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38799415">parent</a><span>|</span><a href="#38799592">next</a><span>|</span><label class="collapse" for="c-38801721">[-]</label><label class="expand" for="c-38801721">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I had go code that didn&#x27;t last a year before it couldn&#x27;t be compiled.</div><br/><div id="38802081" class="c"><input type="checkbox" id="c-38802081" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#38797403">root</a><span>|</span><a href="#38801721">parent</a><span>|</span><a href="#38799592">next</a><span>|</span><label class="collapse" for="c-38802081">[-]</label><label class="expand" for="c-38802081">[1 more]</label></div><br/><div class="children"><div class="content">Curious to me as backwards compatibility has been one of the strengths I hear Go proponents cheer.<p>Any idea what were the APIs that were likely to cause problems?</div><br/></div></div></div></div></div></div><div id="38799592" class="c"><input type="checkbox" id="c-38799592" checked=""/><div class="controls bullet"><span class="by">TheNewAndy</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38799415">prev</a><span>|</span><a href="#38800053">next</a><span>|</span><label class="collapse" for="c-38799592">[-]</label><label class="expand" for="c-38799592">[1 more]</label></div><br/><div class="children"><div class="content">Depends if you mean python the interpreter or python the language. e.g. pypy still supports python2 and has &quot;indefinite support&quot; or something along those lines.<p>Even the cpython2 interpreter is no longer supported by the original authors, but that doesn&#x27;t stop someone else from supporting it.</div><br/></div></div><div id="38800053" class="c"><input type="checkbox" id="c-38800053" checked=""/><div class="controls bullet"><span class="by">toasted-subs</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38799592">prev</a><span>|</span><a href="#38797489">next</a><span>|</span><label class="collapse" for="c-38800053">[-]</label><label class="expand" for="c-38800053">[1 more]</label></div><br/><div class="children"><div class="content">I have yet to have a python versioning issue, but with java I&#x27;ve had tons.<p>Worst of all, it&#x27;s always a clear &quot;use the latest version and it will work&quot;. With python using the latest version almost always works, and you can import the previous functions if you really want to use the new interpreter on old code.<p>Maybe this is because most of the time with python you barely have external libraries. Similar to Java, but in Node.js it&#x27;s like asking for trouble.</div><br/></div></div><div id="38797489" class="c"><input type="checkbox" id="c-38797489" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38797403">parent</a><span>|</span><a href="#38800053">prev</a><span>|</span><a href="#38801917">next</a><span>|</span><label class="collapse" for="c-38797489">[-]</label><label class="expand" for="c-38797489">[1 more]</label></div><br/><div class="children"><div class="content">2 and 3 don&#x27;t really differ that much; true cold-blooded software doesn&#x27;t care which it&#x27;s being run with.</div><br/></div></div></div></div><div id="38801917" class="c"><input type="checkbox" id="c-38801917" checked=""/><div class="controls bullet"><span class="by">ranger207</span><span>|</span><a href="#38797403">prev</a><span>|</span><a href="#38799748">next</a><span>|</span><label class="collapse" for="c-38801917">[-]</label><label class="expand" for="c-38801917">[1 more]</label></div><br/><div class="children"><div class="content">The only software that can go without updates is software that gets it right the first time If you&#x27;re building software for yourself, this is relatively easy. Your tastes probably won&#x27;t change that much even after a decade. You can probably ignore minor problems like using an O(n^2) function where there exists an O(n) because n is small. If you&#x27;re writing software that other people will use, then that&#x27;s where the problems come in. Other people don&#x27;t have the same requirements as you, and may have a large enough N that the O(n) function makes it worth it, for example.<p>But regardless of if you&#x27;re writing for yourself or someone else, sometimes you just can&#x27;t foresee problems. Maybe it crashes processing files larger than a gig, but because you&#x27;ve only ever used files &lt;100KB it&#x27;s never mattered to you. Then you go in to fix the crash and it turns out you&#x27;re going to have to rewrite half the thing.<p>This is, I think, the biggest argument against the idea that software that doesn&#x27;t change is inherently better than software that changes frequently[0]: it may be that unchanging software was perfect from the first line, or it may be that there&#x27;s terrors lurking in the deep, and a priori it can be difficult to tell which a particular project is.<p>[0] This is not to say that rapidly updating software is inherently better than slowly updating software either. There&#x27;s many factors other than just update speed</div><br/></div></div><div id="38799748" class="c"><input type="checkbox" id="c-38799748" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#38801917">prev</a><span>|</span><a href="#38795409">next</a><span>|</span><label class="collapse" for="c-38799748">[-]</label><label class="expand" for="c-38799748">[3 more]</label></div><br/><div class="children"><div class="content">I work on IBM mainframe (z&#x2F;OS). Nothing else I know comes as close in maintaining backwards compatibility as IBM. Microsoft (Windows) is the 2nd, I think. Linux (kernel) ABI has the 3rd place, but that&#x27;s only a small portion of Linux ecosystem.<p>Almost everything else, it&#x27;s just churn. In OSS this is common, I guess nobody wants to spend time on backward compatibility as a hobby. From an economic perspective, it looks like a prisoner&#x27;s dilemma - everybody externalizes the cost of maintaining compatibility onto others, collectively creating more useless work for everybody.</div><br/><div id="38800279" class="c"><input type="checkbox" id="c-38800279" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38799748">parent</a><span>|</span><a href="#38801424">next</a><span>|</span><label class="collapse" for="c-38800279">[-]</label><label class="expand" for="c-38800279">[1 more]</label></div><br/><div class="children"><div class="content"><i>In OSS this is common, I guess nobody wants to spend time on backward compatibility as a hobby.</i><p>There&#x27;s a lot of chasing new and shiny in OSS but I wouldn&#x27;t say that applies to everyone... just look at the entire retrocomputing community, for example. Writing drivers for newer hardware to work on older OSes is not unheard of.</div><br/></div></div><div id="38801424" class="c"><input type="checkbox" id="c-38801424" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38799748">parent</a><span>|</span><a href="#38800279">prev</a><span>|</span><a href="#38795409">next</a><span>|</span><label class="collapse" for="c-38801424">[-]</label><label class="expand" for="c-38801424">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I guess nobody wants to spend time on backward compatibility as a hobby.<p>Getting paid to maintain something <i>certainly</i> goes a long way. Without payment, I suppose it comes down to how much one cares about the platform being built. I deliberately chose to target the Linux kernel directly via system calls because of their proven commitment to ABI stability.<p>On the other hand, I made my own programming language and I really want to make it as &quot;perfect&quot; as possible, to get it just right... So I put a notice in the README that explains it&#x27;s in early stages of development and unstable, just in case someone&#x27;s crazy enough to use it. I have no doubt the people who work on languages like Ruby and Python feel the same way... The languages are probably like a baby to them, they want people to like it, they want it to succeed, they just generally care a lot about it. And that&#x27;s why mistakes like print being a keyword just <i>have</i> to be fixed.</div><br/></div></div></div></div><div id="38795409" class="c"><input type="checkbox" id="c-38795409" checked=""/><div class="controls bullet"><span class="by">vrnvu</span><span>|</span><a href="#38799748">prev</a><span>|</span><a href="#38799343">next</a><span>|</span><label class="collapse" for="c-38795409">[-]</label><label class="expand" for="c-38795409">[40 more]</label></div><br/><div class="children"><div class="content">one thing I’ve noticed is that many engineers, when they’re looking for a library on Github, they check the last commit time. They think that the more recent the last commit is, the better supported the library is.<p>But what about an archived project that does exactly what you need it to do, has 0 bugs, and has been stable for years? That’s like finding a hidden gem in a thrift store!<p>Most engineers I see nowadays will automatically discard a library that is not &quot;constantly&quot; updated... Implying it&#x27;s a good thing :)</div><br/><div id="38795674" class="c"><input type="checkbox" id="c-38795674" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38802805">next</a><span>|</span><label class="collapse" for="c-38795674">[-]</label><label class="expand" for="c-38795674">[14 more]</label></div><br/><div class="children"><div class="content">A library can only stay static if the environment it&#x27;s used in is also static. And many of the environments in which modern software is developed are anything but static, web frontends are one example where things change quite often.<p>A library that can stand entirely on its own might be fine if it&#x27;s never updated. But e.g. a library that depends on a web frontend framework will cause trouble if it is not updated to adapt to changes in the ecosystem.</div><br/><div id="38799478" class="c"><input type="checkbox" id="c-38799478" checked=""/><div class="controls bullet"><span class="by">LeifCarrotson</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38795674">parent</a><span>|</span><a href="#38796022">next</a><span>|</span><label class="collapse" for="c-38799478">[-]</label><label class="expand" for="c-38799478">[1 more]</label></div><br/><div class="children"><div class="content">Even if the environment it&#x27;s used in is not static, the world it lives in is not static.<p>I work in industrial automation, which is a slow-moving behemoth full of $20M equipment that get commissioned once and then run for decades. There&#x27;s a lot of it still controlled with Windows 98 PCs and VB6 messes and PXI cards from the 90s, even more that uses SLC500 PLCs.<p>But when retrofitting these machines or building new ones, I&#x27;ll still consider the newness of a tool or library. Modern technology is often lots more performant, and manufacturers typically support products for date-on-market plus 10 years.<p>There&#x27;s definitely something to be said for sticking with known good products, but even in static environments you may want something new-ish.</div><br/></div></div><div id="38796022" class="c"><input type="checkbox" id="c-38796022" checked=""/><div class="controls bullet"><span class="by">adonovan</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38795674">parent</a><span>|</span><a href="#38799478">prev</a><span>|</span><a href="#38798558">next</a><span>|</span><label class="collapse" for="c-38796022">[-]</label><label class="expand" for="c-38796022">[5 more]</label></div><br/><div class="children"><div class="content">Also, even a very stable project that is &quot;done&quot; will receive a trickle of minor tweak PRs (often docs, tests, and cleanups) proportional to the number of its users, so the rate of change never falls to zero until the code stops being useful.</div><br/><div id="38797796" class="c"><input type="checkbox" id="c-38797796" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38796022">parent</a><span>|</span><a href="#38798031">next</a><span>|</span><label class="collapse" for="c-38797796">[-]</label><label class="expand" for="c-38797796">[1 more]</label></div><br/><div class="children"><div class="content">I think this is also in inverse proportion to the arcane-ness of the intended use of the code, though.<p>Your average MVC web framework gets tons of these minor contributors, because it&#x27;s easy to understand MVC well enough to write docs or tests for it, or to clean up the code in a way that doesn&#x27;t break it.<p>Your average piece of system software gets some. The Linux kernel gets a few.<p>But ain&#x27;t nobody&#x27;s submitting docs&#x2F;tests&#x2F;cleanups for an encryption or hashing algorithm implementation. (In fact, AFAICT, these are often implemented <i>exactly once</i>, as a reference implementation that does things in the same weird way — using procedural abstract assembler-like code, or transpiled functional code, or whatever — that the journal paper describing the algorithm did; and then not a hair of that code is ever touched again. Not to introduce comments; not to make the code more testable; <i>definitely</i> not to refactor things. Nobody ever reads the paper except the original implementor, so nobody ever truly understands what parts of the code are critical to its functioning &#x2F; hardening against various attacks, so nobody can make real improvements. So it just sits there.)</div><br/></div></div><div id="38798031" class="c"><input type="checkbox" id="c-38798031" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38796022">parent</a><span>|</span><a href="#38797796">prev</a><span>|</span><a href="#38796256">next</a><span>|</span><label class="collapse" for="c-38798031">[-]</label><label class="expand" for="c-38798031">[2 more]</label></div><br/><div class="children"><div class="content">I disagree. Tiny libraries can be fine indefinitely. For example this little library which inverts a promise in JavaScript.<p>I haven’t touched this in years and it still works fine. I could come in and update the version of the dependencies but I don’t need to, and that’s a good thing.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;josephg&#x2F;resolvable">https:&#x2F;&#x2F;github.com&#x2F;josephg&#x2F;resolvable</a></div><br/><div id="38798093" class="c"><input type="checkbox" id="c-38798093" checked=""/><div class="controls bullet"><span class="by">xmprt</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38798031">parent</a><span>|</span><a href="#38796256">next</a><span>|</span><label class="collapse" for="c-38798093">[-]</label><label class="expand" for="c-38798093">[1 more]</label></div><br/><div class="children"><div class="content">I think total number of commits is probably a good metric too. If the project only has 7 commits to begin with then it&#x27;s unlikely to get any more updates after it&#x27;s &quot;done&quot;. But a 10 year old project with 1000 commits where the last commit was 3 years ago is a little more worrying.</div><br/></div></div></div></div><div id="38796256" class="c"><input type="checkbox" id="c-38796256" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38796022">parent</a><span>|</span><a href="#38798031">prev</a><span>|</span><a href="#38798558">next</a><span>|</span><label class="collapse" for="c-38796256">[-]</label><label class="expand" for="c-38796256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; so the rate of change never falls to zero until the code stops being useful<p>Non-useful software changes all the time ;) Also, Useful software stands still all the time, without any proposed changes.</div><br/></div></div></div></div><div id="38798558" class="c"><input type="checkbox" id="c-38798558" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38795674">parent</a><span>|</span><a href="#38796022">prev</a><span>|</span><a href="#38798066">next</a><span>|</span><label class="collapse" for="c-38798558">[-]</label><label class="expand" for="c-38798558">[5 more]</label></div><br/><div class="children"><div class="content">This is a very strange example. Browsers have fantastic backwards compatibility. You can use the same libraries and framework you used ten years ago to make a site and, with very few exceptions, it will work perfectly fine in a modern browser.</div><br/><div id="38799305" class="c"><input type="checkbox" id="c-38799305" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38798558">parent</a><span>|</span><a href="#38800311">next</a><span>|</span><label class="collapse" for="c-38799305">[-]</label><label class="expand" for="c-38799305">[1 more]</label></div><br/><div class="children"><div class="content">Browsers themselves aren&#x27;t usually the problem. While sometimes they make changes, like what APIs are available without HTTPS, I think you&#x27;re right about their solid backwards compatibility.<p>What people really mean when they talk about the frontend is the build system that gets your (modern, TypeScript) source code into (potentially Safari) browsers.<p>Chrome is highly backwards compatible. Webpack, not so much.<p>This build system churn goes hand-in-hand with framework churn (e.g. going from Vue 2 to 3, while the team have put heaps of effort into backwards compatibility, is not issue-free), and more recently, the rise of TypeScript and the way the CJS to ESM transition has been handled by tools (especially Node).</div><br/></div></div><div id="38800311" class="c"><input type="checkbox" id="c-38800311" checked=""/><div class="controls bullet"><span class="by">ferbivore</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38798558">parent</a><span>|</span><a href="#38799305">prev</a><span>|</span><a href="#38798690">next</a><span>|</span><label class="collapse" for="c-38800311">[-]</label><label class="expand" for="c-38800311">[1 more]</label></div><br/><div class="children"><div class="content">Browsers have decent backwards compatibility for regular webpages, but there’s a steady stream of breakage when it comes to more complex content, like games. The autoplay policy changes from 2017-2018, the SharedArrayBuffer trainwreck, gating more and more stuff behind secure contexts, COOP&#x2F;COEP or other arbitrary nonsense... all this stuff broke actual games out in the wild. If you made one with tools from 10 years ago you would run into at least a couple of these.</div><br/></div></div><div id="38798690" class="c"><input type="checkbox" id="c-38798690" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38798558">parent</a><span>|</span><a href="#38800311">prev</a><span>|</span><a href="#38798765">next</a><span>|</span><label class="collapse" for="c-38798690">[-]</label><label class="expand" for="c-38798690">[1 more]</label></div><br/><div class="children"><div class="content">The problem arises when you&#x27;re not using old libraries and frameworks. You&#x27;re using new stuff, and come across an old, unmaintained library you&#x27;d like to use.<p>Hey, it uses the same frameworks you&#x27;re using --- except, oh, ten years ago.<p>Before you can use it, you have to get it working with the versions of those frameworks you&#x27;re using today.<p>Someone did that already before you. They sent their patch to the dead project, but didn&#x27;t get a reply, so nobody knows about it.</div><br/></div></div><div id="38798765" class="c"><input type="checkbox" id="c-38798765" checked=""/><div class="controls bullet"><span class="by">hiatus</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38798558">parent</a><span>|</span><a href="#38798690">prev</a><span>|</span><a href="#38798066">next</a><span>|</span><label class="collapse" for="c-38798765">[-]</label><label class="expand" for="c-38798765">[1 more]</label></div><br/><div class="children"><div class="content">You absolutely can do that, but it is likely the final output will have numerous exploitable vulnerabilities.</div><br/></div></div></div></div><div id="38798066" class="c"><input type="checkbox" id="c-38798066" checked=""/><div class="controls bullet"><span class="by">xmprt</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38795674">parent</a><span>|</span><a href="#38798558">prev</a><span>|</span><a href="#38797263">next</a><span>|</span><label class="collapse" for="c-38798066">[-]</label><label class="expand" for="c-38798066">[1 more]</label></div><br/><div class="children"><div class="content">As someone who migrated a somewhat old project to one which uses a newer framework, I agree with this. The amount of time I spent trying to figure out why and old module was broken before realizing that one of it&#x27;s dependencies was using ESM even though it was still using CJS... I don&#x27;t even want to think about it. Better to just make sure that a module was written or updated within the last 3 years because that will almost certainly work.</div><br/></div></div><div id="38797263" class="c"><input type="checkbox" id="c-38797263" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38795674">parent</a><span>|</span><a href="#38798066">prev</a><span>|</span><a href="#38802805">next</a><span>|</span><label class="collapse" for="c-38797263">[-]</label><label class="expand" for="c-38797263">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; web frontends are one example where things change quite often.<p>There is a world of difference between linux adding USB support and how web front ends have evolved. One of them feels like they are chasing the latest shiny object...</div><br/></div></div></div></div><div id="38802805" class="c"><input type="checkbox" id="c-38802805" checked=""/><div class="controls bullet"><span class="by">hw</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38795674">prev</a><span>|</span><a href="#38795494">next</a><span>|</span><label class="collapse" for="c-38802805">[-]</label><label class="expand" for="c-38802805">[1 more]</label></div><br/><div class="children"><div class="content">It’s extremely rare to have projects be considered stable for years without any updates. Unless there are no external dependencies, uses very primitive or core language constructs, there’s always updates to be had - security updates, EOLs are common examples. What works in Python 2 might not work in Python 3<p>Software needs to be maintained. It is ever evolving. I am one of those that will not use a library that has not been updated in the last year, as I do not want to be stuck upgrading it to be compatible with Node 20 when Node 18 EOLs</div><br/></div></div><div id="38795494" class="c"><input type="checkbox" id="c-38795494" checked=""/><div class="controls bullet"><span class="by">pmichaud</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38802805">prev</a><span>|</span><a href="#38802775">next</a><span>|</span><label class="collapse" for="c-38795494">[-]</label><label class="expand" for="c-38795494">[1 more]</label></div><br/><div class="children"><div class="content">Even though it’s not strictly true, checking for recent updates is an excellent heuristic. I don’t know the real numbers, but I feel confident that in the overwhelming majority of cases, no recent activity means “abandoned”, not “complete and bug free”.</div><br/></div></div><div id="38802775" class="c"><input type="checkbox" id="c-38802775" checked=""/><div class="controls bullet"><span class="by">EnigmaFlare</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38795494">prev</a><span>|</span><a href="#38797541">next</a><span>|</span><label class="collapse" for="c-38802775">[-]</label><label class="expand" for="c-38802775">[1 more]</label></div><br/><div class="children"><div class="content">I chose a .Net library (Zedgraph) about 10 years ago, partly for the opposite reason. It was already known to be &quot;finished&quot;, what you might call dead. It reliably does what I want so I don&#x27;t care about updates. I&#x27;m still using the same version today and never had to even think about updating or breakages or anything. It just keeps on working.<p>Mind you, it&#x27;s a desktop application not exposed to the internet, so security is a little lower priority than normal.</div><br/></div></div><div id="38797541" class="c"><input type="checkbox" id="c-38797541" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38802775">prev</a><span>|</span><a href="#38796229">next</a><span>|</span><label class="collapse" for="c-38797541">[-]</label><label class="expand" for="c-38797541">[6 more]</label></div><br/><div class="children"><div class="content">&gt; But what about an archived project that does exactly what you need it to do, has 0 bugs, and has been stable for years? That’s like finding a hidden gem in a thrift store!<p>Either the library is so trivial to implement myself that I just do that anyway, which doesn&#x27;t have issues w.r.t maintenance or licensing, or it&#x27;s unmaintained and there are bugs that won&#x27;t be fixed because it&#x27;s unmaintained and now I need to fork and fix it, taking on a legal burden with licensing in addition to maintenance.<p>Bugs happen all the time for mundane reasons. A transitive dependency updated and now an API has a breaking change but the upstream has security fixes. Compilers updated and now a weird combination of preprocessor flags causes a build failure. And so on.<p>The idea that a piece of software that works today will work tomorrow is a myth for anything non-trivial, which is why checking the history is a useful smell test.</div><br/><div id="38797852" class="c"><input type="checkbox" id="c-38797852" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38797541">parent</a><span>|</span><a href="#38800767">next</a><span>|</span><label class="collapse" for="c-38797852">[-]</label><label class="expand" for="c-38797852">[3 more]</label></div><br/><div class="children"><div class="content">Consider an at-the-time novel hashing algorithm, e.g. Keccak.<p>• It&#x27;s decidedly non-trivial — you&#x27;d have to 1. be a mathematician&#x2F;cryptographer, and then 2. read the paper describing the algorithm and <i>really</i> understand it, before you could implement it.<p>• But also, it&#x27;s usually just one file with a few hundred lines of C that just manipulates stack variables to turn a block of memory into another block of memory. Nothing that changes with new versions of the language. Nothing that rots. Uses so few language features it would have compiled the same 40 years ago.<p>Someone writes such code once; nobody ever modifies it again. No bugs, unless they&#x27;re bugs in the algorithm described by the paper. Almost all libraries in HLLs are FFI wrappers for the same one core low-level reference implementation.</div><br/><div id="38797905" class="c"><input type="checkbox" id="c-38797905" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38797852">parent</a><span>|</span><a href="#38798593">next</a><span>|</span><label class="collapse" for="c-38797905">[-]</label><label class="expand" for="c-38797905">[1 more]</label></div><br/><div class="children"><div class="content">In practice, this code will use a variety of target-specific optimizations or compiler intrinsics blocked behind #ifdefs that need to be periodically updated or added for new targets and toolchains. If it refers to any kind of OS-specific APIs  (like RNG) then it will also need to be updated from time to time as those APIs change.<p>That&#x27;s not to say that code can&#x27;t change slowly, just the idea that it <i>never</i> changes is extremely rare in practice.</div><br/></div></div><div id="38798593" class="c"><input type="checkbox" id="c-38798593" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38797852">parent</a><span>|</span><a href="#38797905">prev</a><span>|</span><a href="#38800767">next</a><span>|</span><label class="collapse" for="c-38798593">[-]</label><label class="expand" for="c-38798593">[1 more]</label></div><br/><div class="children"><div class="content">Keccak is perhaps not the best example to pick. <a href="https:&#x2F;&#x2F;mouha.be&#x2F;sha-3-buffer-overflow&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mouha.be&#x2F;sha-3-buffer-overflow&#x2F;</a></div><br/></div></div></div></div><div id="38800767" class="c"><input type="checkbox" id="c-38800767" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38797541">parent</a><span>|</span><a href="#38797852">prev</a><span>|</span><a href="#38797778">next</a><span>|</span><label class="collapse" for="c-38800767">[-]</label><label class="expand" for="c-38800767">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m checking the zlib changes file [1] and there are regular gaps of years between versions (but there are times where there are a few months between versions).  zlib is a very stable library and I doubt the API has changed all that much in 30 years.<p>[1] <a href="https:&#x2F;&#x2F;www.zlib.net&#x2F;ChangeLog.txt" rel="nofollow">https:&#x2F;&#x2F;www.zlib.net&#x2F;ChangeLog.txt</a></div><br/></div></div><div id="38797778" class="c"><input type="checkbox" id="c-38797778" checked=""/><div class="controls bullet"><span class="by">QuadmasterXLII</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38797541">parent</a><span>|</span><a href="#38800767">prev</a><span>|</span><a href="#38796229">next</a><span>|</span><label class="collapse" for="c-38797778">[-]</label><label class="expand" for="c-38797778">[1 more]</label></div><br/><div class="children"><div class="content">I submit math.JS and numeric.JS. Math.JS has an incredibly active community and all sorts of commits numeric. JS is one file of JavaScript and hasn’t had an update in eight years if you want to multiply 2 30 by 30 matrices, numeric.JS works just fine in 2023 and is literally 20 times faster.</div><br/></div></div></div></div><div id="38796229" class="c"><input type="checkbox" id="c-38796229" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38797541">prev</a><span>|</span><a href="#38797704">next</a><span>|</span><label class="collapse" for="c-38796229">[-]</label><label class="expand" for="c-38796229">[1 more]</label></div><br/><div class="children"><div class="content">I remember seeing a bunch of graphs which showed how programming languages have changed over time, and how much of the original code is still there.<p>It showed that some languages were basically nothing like the 1.0 versions, while others had retained most of the code written and only stuff on top.<p>In the end, it seems to also be reflected in the community and ecosystem. I remember Clojure being close&#x2F;at the top of the list as the language hardly does breaking changes anymore, so libraries that last changed 5 years ago, still run perfectly well in the current version of the language.<p>I guess it helps that it&#x27;s lisp-like as you can extend the core of the language without changing it upstream, which of course also comes with its own warts.<p>But one great change it did to me, is stop thinking that &quot;freshness&quot; equals &quot;greatness&quot;. It&#x27;s probably more common I use libraries today that basically stopped changed since some years ago, than I use libraries that were created in the last year. And without major issues.</div><br/></div></div><div id="38797704" class="c"><input type="checkbox" id="c-38797704" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38796229">prev</a><span>|</span><a href="#38796252">next</a><span>|</span><label class="collapse" for="c-38797704">[-]</label><label class="expand" for="c-38797704">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the language.<p>Some languages have releases every year or two where they will introduce some new, elegant syntax (or maybe a new stdlib ADT, etc) to replace some pattern that was frequent yet clumsy in code written in that language. The developer communities for these languages then usually pretty-much-instantly consider use of the new syntax to be &quot;idiomatic&quot;, and any code that still does things the old, clumsy way to need fixing.<p>The argument for making the change to any particular codebase is often that, relative to the new syntax, the old approach makes things more opaque and harder to maintain &#x2F; code-review. If the new syntax existed from the start, nobody would think the old approach was good code. So, <i>for the sake of legibility to new developers, and to lower the barrier to entry to code contributions</i>, the code should be updated to use the new syntax.<p>If a library is implemented in such a language, and yet it hasn&#x27;t been updated in 3+ years, that&#x27;s often a bad sign — a sign that the developer isn&#x27;t &quot;plugged into&quot; the language&#x27;s community enough to keep the library up-to-date as idiomatic code that other developers (many of whom might have just learned the language in its latest form from a modern resource) can easily read. And therefore that the developer maybe isn&#x27;t <i>interested</i> in receiving external PRs.</div><br/></div></div><div id="38796252" class="c"><input type="checkbox" id="c-38796252" checked=""/><div class="controls bullet"><span class="by">Uehreka</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38797704">prev</a><span>|</span><a href="#38800988">next</a><span>|</span><label class="collapse" for="c-38796252">[-]</label><label class="expand" for="c-38796252">[2 more]</label></div><br/><div class="children"><div class="content">By zero bugs do you mean zero GitHub issues? Because zero GitHub issues could mean that there are security vulnerabilities but no one is reporting them because the project is marked as abandoned.</div><br/><div id="38796265" class="c"><input type="checkbox" id="c-38796265" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38796252">parent</a><span>|</span><a href="#38800988">next</a><span>|</span><label class="collapse" for="c-38796265">[-]</label><label class="expand" for="c-38796265">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By zero bugs do you mean zero GitHub issues?<p>Or, the library just have zero bugs. It&#x27;s possible, although probably pretty uncommon :)</div><br/></div></div></div></div><div id="38800988" class="c"><input type="checkbox" id="c-38800988" checked=""/><div class="controls bullet"><span class="by">dr_kiszonka</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38796252">prev</a><span>|</span><a href="#38796371">next</a><span>|</span><label class="collapse" for="c-38800988">[-]</label><label class="expand" for="c-38800988">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s good insight.<p>One disadvantage of archived repos is that you can&#x27;t submit issues. For this reason it is hard to assess how bug free the package is. My favorite assessment metric is how long it takes the maintainer(s) to address issues and PRs (or at least post a reply). Sure, it is not perfect and we shouldn&#x27;t expect all maintainers to be super responsive, but it usually works for me.</div><br/></div></div><div id="38796371" class="c"><input type="checkbox" id="c-38796371" checked=""/><div class="controls bullet"><span class="by">bratbag</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38800988">prev</a><span>|</span><a href="#38797233">next</a><span>|</span><label class="collapse" for="c-38796371">[-]</label><label class="expand" for="c-38796371">[2 more]</label></div><br/><div class="children"><div class="content">Most engineers have probably been bitten in the ass by versioned dependencies conflicting with each other.</div><br/><div id="38797756" class="c"><input type="checkbox" id="c-38797756" checked=""/><div class="controls bullet"><span class="by">wccrawford</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38796371">parent</a><span>|</span><a href="#38797233">next</a><span>|</span><label class="collapse" for="c-38797756">[-]</label><label class="expand" for="c-38797756">[1 more]</label></div><br/><div class="children"><div class="content">And the other way, too, with the underlying language&#x27;s changes making the library stop working.<p>It&#x27;s just really unlikely that a project stays working without somewhat-frequent updates.</div><br/></div></div></div></div><div id="38797233" class="c"><input type="checkbox" id="c-38797233" checked=""/><div class="controls bullet"><span class="by">pizzafeelsright</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38796371">prev</a><span>|</span><a href="#38796170">next</a><span>|</span><label class="collapse" for="c-38797233">[-]</label><label class="expand" for="c-38797233">[1 more]</label></div><br/><div class="children"><div class="content">Good point.  I have also seen Great Endeavor 0.7.1 stay there because the author gave up or graduated or got hired and the repo sits incomplete, lacking love and explanation for dismissal.</div><br/></div></div><div id="38796170" class="c"><input type="checkbox" id="c-38796170" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38797233">prev</a><span>|</span><a href="#38799139">next</a><span>|</span><label class="collapse" for="c-38796170">[-]</label><label class="expand" for="c-38796170">[2 more]</label></div><br/><div class="children"><div class="content">The Haskell community has a lot of these kinds of libraries. It comes with the territory to some extent.</div><br/><div id="38797528" class="c"><input type="checkbox" id="c-38797528" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38796170">parent</a><span>|</span><a href="#38799139">next</a><span>|</span><label class="collapse" for="c-38797528">[-]</label><label class="expand" for="c-38797528">[1 more]</label></div><br/><div class="children"><div class="content">The GHC project churns out changes at a quite high rate though. The changes are quite small by themselves, but they add up and an abandoned Haskell project is unlikely to be compilable years later.</div><br/></div></div></div></div><div id="38799139" class="c"><input type="checkbox" id="c-38799139" checked=""/><div class="controls bullet"><span class="by">RhodesianHunter</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38796170">prev</a><span>|</span><a href="#38797829">next</a><span>|</span><label class="collapse" for="c-38799139">[-]</label><label class="expand" for="c-38799139">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only true for libraries with zero transitive dependencies.<p>Otherwise you&#x27;re almost guaranteed to be pulling in un-patched vulnerabilities.</div><br/></div></div><div id="38797829" class="c"><input type="checkbox" id="c-38797829" checked=""/><div class="controls bullet"><span class="by">NanoYohaneTSU</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38799139">prev</a><span>|</span><a href="#38796806">next</a><span>|</span><label class="collapse" for="c-38797829">[-]</label><label class="expand" for="c-38797829">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sort of confused on where your comment is coming from. In the modern world (2023 in case your calendar is stuck in the 90s) we have a massive system of APIs and services that get changed all the time internally.<p>If a library is not constantly updated then there is a high likely hood (99%) that it just won&#x27;t work. Many issues raised in git are that something changed and now the package is broken. That&#x27;s reality sis.</div><br/><div id="38798552" class="c"><input type="checkbox" id="c-38798552" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38795409">root</a><span>|</span><a href="#38797829">parent</a><span>|</span><a href="#38796806">next</a><span>|</span><label class="collapse" for="c-38798552">[-]</label><label class="expand" for="c-38798552">[1 more]</label></div><br/><div class="children"><div class="content">Are you suggesting that all we need to do is use 30 year old languages to free ourselves from this treadmill? That seems like an easy choice!</div><br/></div></div></div></div><div id="38796806" class="c"><input type="checkbox" id="c-38796806" checked=""/><div class="controls bullet"><span class="by">troupe</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38797829">prev</a><span>|</span><a href="#38795562">next</a><span>|</span><label class="collapse" for="c-38796806">[-]</label><label class="expand" for="c-38796806">[1 more]</label></div><br/><div class="children"><div class="content">If you are asking yourself, &quot;will this do what it says it will do?&quot; and you are comparing a project that hasn&#x27;t had any updates in the last 3 years vs one that has seen a constant stream of updates over the last 3 years, which one do you think has a greater probability of doing what it needs to do?<p>Now I do get your point. There is probably a better metric to use. Like for example, how many people are adding this library  to their project and not removing it. But if you don&#x27;t have that, the number of recent updates to a project that has been around for a long time is probably going to steer you in the right direction more often than not.</div><br/></div></div><div id="38795562" class="c"><input type="checkbox" id="c-38795562" checked=""/><div class="controls bullet"><span class="by">scruple</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38796806">prev</a><span>|</span><a href="#38801578">next</a><span>|</span><label class="collapse" for="c-38795562">[-]</label><label class="expand" for="c-38795562">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m generally doing that to check for version compatibility across a much broader spectrum than the level of a single library.</div><br/></div></div><div id="38801578" class="c"><input type="checkbox" id="c-38801578" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38795409">parent</a><span>|</span><a href="#38795562">prev</a><span>|</span><a href="#38799343">next</a><span>|</span><label class="collapse" for="c-38801578">[-]</label><label class="expand" for="c-38801578">[1 more]</label></div><br/><div class="children"><div class="content">Last commit time is a pretty good indicator that the project has <i>someone</i> who still cares enough to regularly maintain it.<p>I have some projects I consider finished because they already do what I need them to do. If I <i>really</i> cared I&#x27;m sure I could find lots of things to improve. Last commit time being years ago is a pretty good indicator that I stopped caring and moved on. That&#x27;s exactly what happened: my itch&#x27;s already been scratched and I decided to work on something else because time is short.<p>I was once surprised to discover a laptop keyboard LED driver I published on GitHub years ago somehow acquired users. Another developer even built a GUI around it which is <i>awesome</i>. The truth is I just wanted to turn the lights off because when I turn the laptop on they default to extremely bright blue. I reverse engineered everything I could but as far as I&#x27;m concerned the project&#x27;s finished. Last commit 4 years ago speaks volumes.</div><br/></div></div></div></div><div id="38799343" class="c"><input type="checkbox" id="c-38799343" checked=""/><div class="controls bullet"><span class="by">kugelblitz</span><span>|</span><a href="#38795409">prev</a><span>|</span><a href="#38795423">next</a><span>|</span><label class="collapse" for="c-38799343">[-]</label><label class="expand" for="c-38799343">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been maintaining my own side project. It started 12-13 years ago, with vanilla php, later rewritten with Laravel, later rewritten again with Symfony in 2017-ish. Since then I&#x27;ve had phases from 6-18 months where I had a total of 2-3 tiny commits (I was working full time as a freelancer, so I didn&#x27;t have energy to work on my side project). But then when I had time, I would focus on it, add features, upgrade and just experiment and learn.<p>This was super valuable to me to learn how to maintain projects long-term: Update dependencies, remove stuff you don&#x27;t need, check for security updates, find chances to simplify (e.g. from Vagrant to Docker... or from Vue + Axios + Webpack + other stuff to Htmx). And what to avoid... for me it was to avoid freshly developed dependencies, microservices, complexified infrastructure such as Kubernetes.<p>And now I just developed a bunch of features, upgraded to PHP 8.2 and Symfony 7 (released a month ago), integrated some ChatGPT-based features and can hopefully relax for 1-3 years if I wanted to.<p>In the last 4-5 years the project has made about the same revenue as an average freelance year&#x27;s revenue, so it&#x27;s not some dormant unknown side project.</div><br/><div id="38799710" class="c"><input type="checkbox" id="c-38799710" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#38799343">parent</a><span>|</span><a href="#38800323">next</a><span>|</span><label class="collapse" for="c-38799710">[-]</label><label class="expand" for="c-38799710">[2 more]</label></div><br/><div class="children"><div class="content">I think PHP, as horrible as it feels to go back, is one example of something that’s truly backwards compatible even to its own detriment.<p>Haven’t worked with it for years, went back to find that the horrible image manipulation functions are still the same mess that I left behind 8 years ago.</div><br/><div id="38800283" class="c"><input type="checkbox" id="c-38800283" checked=""/><div class="controls bullet"><span class="by">kugelblitz</span><span>|</span><a href="#38799343">root</a><span>|</span><a href="#38799710">parent</a><span>|</span><a href="#38800323">next</a><span>|</span><label class="collapse" for="c-38800283">[-]</label><label class="expand" for="c-38800283">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, some things are still a mess, but many things I use constantly have improved so much. Here is an excerpt of a function that shows many of the updates that I use regularly:<p><pre><code>  #[AsMessageHandler]
  readonly class JobEditedHandler
  {
      public function __construct(
          private Environment $twig,
          private EmailService $mailer,
          private string $vatRate,
      ) {}

      public function __invoke(JobEdited $jobEdited): void
      {
          $this-&gt;sendNotificationToJobPublisher($jobEdited);
      }
</code></pre>
You have attributes, much better type-hinting, constructor property promotion, read-only properties &#x2F; classes. Additionally you have native Enums, named arguments and also smaller things such as match expressions (instead of case switch), array spread operator, null coalescing assignment operator, etc, etc.<p>Especially in a CRUD-heavy setting like mine (I run a niche jobboard) it reduces so much boilerplate and increases type-safety, thus makes it way less error-prone. Combined with new static analyzers (phpstan, php-cs-fixer, psalm - take your pick), you find possible errors way earlier now.<p>I think it gets a lot of inspiration from Java. Symfony gets lots of inspiration from Spring Boot. The Twig templating language is heavily related to the Django templating language. So many of the tools and concepts are somewhat battle-tested.<p>And this is on top of the huge performance improvements in the last years.<p>So yeah, there&#x27;s many things that are still fixable. But the improvements have been staggering.</div><br/></div></div></div></div><div id="38800323" class="c"><input type="checkbox" id="c-38800323" checked=""/><div class="controls bullet"><span class="by">punkybr3wster</span><span>|</span><a href="#38799343">parent</a><span>|</span><a href="#38799710">prev</a><span>|</span><a href="#38795423">next</a><span>|</span><label class="collapse" for="c-38800323">[-]</label><label class="expand" for="c-38800323">[2 more]</label></div><br/><div class="children"><div class="content">As a person who’s considered learning more native symphony, can I ask - what was your reason moving to it from something like laravel?</div><br/><div id="38800880" class="c"><input type="checkbox" id="c-38800880" checked=""/><div class="controls bullet"><span class="by">kugelblitz</span><span>|</span><a href="#38799343">root</a><span>|</span><a href="#38800323">parent</a><span>|</span><a href="#38795423">next</a><span>|</span><label class="collapse" for="c-38800880">[-]</label><label class="expand" for="c-38800880">[1 more]</label></div><br/><div class="children"><div class="content">Laravel was easier to get into but once you strayed from &quot;The Laravel Way&quot;, it gets quite messy.<p>I got into Symfony by &quot;accident&quot;, because a freelance colleague put me on projects that used Symfony. So for a couple of years I used Laravel and Symfony in parallel, but after a few years I decided to go full Symfony.<p>Some of the things that were better for my use case:<p>Many of the Laravel components are &quot;Laravel only&quot;. Whereas in Symfony, you can just pick and choose the components you need - it&#x27;s very modular and extendible without forcing your hand. You don&#x27;t even need the Symfony framework and just choose the components you want.<p>That&#x27;s how Laravel can depend on Symfony modules; but Symfony can&#x27;t depend on Laravel modules.<p>Entities vs. Models (Data Mapper vs. Active Record):
The entities in Symfony (equivalent to Models in Laravel) were just simple PHP objects. I can see what properties an entity has, I can configure directly there in a simple way. I can add my own functions, edit the constructor, etc, etc. Also: You create the properties, and the migrations were generated based on that. In Laravel, you create the migrations, and the actual model is based on going through the migration steps. This just feels odd to me.<p>In Laravel, the Models extend the Eloquent Model class and it feels &quot;heavier&quot; and I had more trouble re-configuring some things. Plus without using an additional &quot;auto-complete&quot; generator, I couldn&#x27;t just see what the properties &#x2F; columns of the model &#x2F; table was.<p>I also don&#x27;t like Facades (because they hide too much stuff and I have trouble figuring out the service that it actually represents).<p>Templating:
I also like that Twig is more restrictive, it forces me to think more about separating logic and the view, whereas Blade allows way more things. You don&#x27;t have to use it, but I reckon since it&#x27;s allowed, people will do so.<p>One thing I still envy from Laravel, though, is the testing suite.<p>This is pretty neat:<p><pre><code>    $response = $this-&gt;getJson(&#x27;&#x2F;users&#x2F;1&#x27;);
 
    $response
        -&gt;assertJson(fn (AssertableJson $json) =&gt;
            $json-&gt;where(&#x27;id&#x27;, 1)
                 -&gt;where(&#x27;name&#x27;, &#x27;Victoria Faith&#x27;)
                 -&gt;where(&#x27;email&#x27;, fn (string $email) =&gt; str($email)-&gt;is(&#x27;victoria@gmail.com&#x27;))
                 -&gt;whereNot(&#x27;status&#x27;, &#x27;pending&#x27;)
                 -&gt;missing(&#x27;password&#x27;)
                 -&gt;etc()
        );
</code></pre>
I tried integrating it in Symfony, but it was quite messy and somewhat incompatible. That shows the above point, that it&#x27;s &quot;Laravel only&quot;. It&#x27;s really nice, but not enough for me to advocate for Laravel over Symfony.</div><br/></div></div></div></div></div></div><div id="38795423" class="c"><input type="checkbox" id="c-38795423" checked=""/><div class="controls bullet"><span class="by">tlhunter</span><span>|</span><a href="#38799343">prev</a><span>|</span><a href="#38799644">next</a><span>|</span><label class="collapse" for="c-38795423">[-]</label><label class="expand" for="c-38795423">[6 more]</label></div><br/><div class="children"><div class="content">I love the sentiment of this post. I absolutely hate that my recent mobile apps from only a couple years ago l now require a dozen hours to patch them up and submit updates.<p>The author&#x27;s final point is interesting wherein they refer to their own static site generator as being cold-blooded and that it runs on Python 2. Python 2 is getting harder to install recently and will eventually make it a warm blooded project.</div><br/><div id="38795669" class="c"><input type="checkbox" id="c-38795669" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#38795423">parent</a><span>|</span><a href="#38799644">next</a><span>|</span><label class="collapse" for="c-38795669">[-]</label><label class="expand" for="c-38795669">[5 more]</label></div><br/><div class="children"><div class="content">I have a little hobby project (iOS and macOS) that I don&#x27;t regularly develop anymore, but I use it quite often as a user, and I like to keep it compiling and running on the latest OSes. It&#x27;s aggravating (and should be totally unacceptable) that every time I upgrade Xcode, I have a few odds and ends that need to be fixed in order for the project to compile cleanly and work. My recent git history comments are <i>all</i> variations of &quot;Get project working on latest Xcode&quot;.<p>I could almost understand if these underlying SDK and OS changes had to be made due to security threats, but that&#x27;s almost never the case. It&#x27;s just stupid things like deprecating this API and adding that warning by default and &quot;oh, now you need to use this framework instead of that one&quot;. Platforms and frameworks need to stop deliberately being moving targets, especially operating systems that are now very stable and reliable.<p>I should be able to pull a 10 year old project out of the freezer and have it compile cleanly and run just as it ran 10 years ago. These OS vendors are trillion dollar companies. I don&#x27;t want to hear excuses about boo hoo how much engineering effort backward compatibility is.</div><br/><div id="38797015" class="c"><input type="checkbox" id="c-38797015" checked=""/><div class="controls bullet"><span class="by">angra_mainyu</span><span>|</span><a href="#38795423">root</a><span>|</span><a href="#38795669">parent</a><span>|</span><a href="#38796194">next</a><span>|</span><label class="collapse" for="c-38797015">[-]</label><label class="expand" for="c-38797015">[1 more]</label></div><br/><div class="children"><div class="content">Apple is notoriously bad when it comes to this.<p>I used to work on a cross-platform product and Windows was relatively stable across versions, as was Linux.<p>Macs on the other hand required a lot of branching for each version.</div><br/></div></div><div id="38796194" class="c"><input type="checkbox" id="c-38796194" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#38795423">root</a><span>|</span><a href="#38795669">parent</a><span>|</span><a href="#38797015">prev</a><span>|</span><a href="#38799644">next</a><span>|</span><label class="collapse" for="c-38796194">[-]</label><label class="expand" for="c-38796194">[3 more]</label></div><br/><div class="children"><div class="content">Hardware changes over 10 years.<p>Macs don’t even run on the same CPU architecture or support OpenGL.<p>Sometimes things just need to change.</div><br/><div id="38796237" class="c"><input type="checkbox" id="c-38796237" checked=""/><div class="controls bullet"><span class="by">beambot</span><span>|</span><a href="#38795423">root</a><span>|</span><a href="#38796194">parent</a><span>|</span><a href="#38799644">next</a><span>|</span><label class="collapse" for="c-38796237">[-]</label><label class="expand" for="c-38796237">[2 more]</label></div><br/><div class="children"><div class="content">The worst is when your virtualization environments intended to provide long-term support don&#x27;t even accomodate the &quot;new&quot; mainline hardware.  Most frustrating example: Virtualbox doesn&#x27;t work on Apple M1 or M2 chipsets.</div><br/><div id="38800967" class="c"><input type="checkbox" id="c-38800967" checked=""/><div class="controls bullet"><span class="by">genewitch</span><span>|</span><a href="#38795423">root</a><span>|</span><a href="#38796237">parent</a><span>|</span><a href="#38799644">next</a><span>|</span><label class="collapse" for="c-38800967">[-]</label><label class="expand" for="c-38800967">[1 more]</label></div><br/><div class="children"><div class="content">why would it, though? Qemu (probably) works on &quot;M&quot; macs. 
Virtualbox is linked intimately with the underlying hardware, it&#x27;s a translation layer - even though it can do emulation, it&#x27;s x86 emulating x86.<p>i always thought i was one of the few people that used virtualbox instead of the more popular ones; i tend to forget that there&#x27;s probably a subset of developers that still use it for the orchestration software that can use it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38799644" class="c"><input type="checkbox" id="c-38799644" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#38795423">prev</a><span>|</span><a href="#38797037">next</a><span>|</span><label class="collapse" for="c-38799644">[-]</label><label class="expand" for="c-38799644">[1 more]</label></div><br/><div class="children"><div class="content">I wrote an SDK, in 1994-95, that was still in use, when I left the company, in 2017.<p>It was a device control interface layer, and was written in vanilla ANSI C. Back when I wrote it, there wasn&#x27;t a common linker, so the only way to have a binary interface, was to use simple C.<p>I have written stuff in PHP (5), that still works great, in PHP 8.2. Some of that stuff is actually fairly ambitious.<p>But it&#x27;s boring, and has a low buzzword index.</div><br/></div></div><div id="38797037" class="c"><input type="checkbox" id="c-38797037" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#38799644">prev</a><span>|</span><a href="#38802371">next</a><span>|</span><label class="collapse" for="c-38797037">[-]</label><label class="expand" for="c-38797037">[1 more]</label></div><br/><div class="children"><div class="content">Besides what is stated in the article, it is also important to have an inherently secure threat model. For example, full websites are inherently warm-blooded since you are constantly dealing with attackers, spam bots, etc. However, static pages like Tiddlywiki are a lot better since you can avoid putting it on the web at all and browsers are incredibly stable platforms.</div><br/></div></div><div id="38802371" class="c"><input type="checkbox" id="c-38802371" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#38797037">prev</a><span>|</span><a href="#38794233">next</a><span>|</span><label class="collapse" for="c-38802371">[-]</label><label class="expand" for="c-38802371">[1 more]</label></div><br/><div class="children"><div class="content">I had to read this article a couple of times before I got it. I guess dependencies can make an app warm blooded, but Docker or containerization can also paper over some of these issues. However, whenever I choose libraries for a project I do alot of research to make sure that the libraries themselves are &quot;cold blooded&quot; too, as even one badly chosen library can cause your project to fail in 10 years time</div><br/></div></div><div id="38794233" class="c"><input type="checkbox" id="c-38794233" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38802371">prev</a><span>|</span><a href="#38802819">next</a><span>|</span><label class="collapse" for="c-38794233">[-]</label><label class="expand" for="c-38794233">[5 more]</label></div><br/><div class="children"><div class="content">I suspect our differences in preferences for cold- vs warm-blooded projects may be related to the &quot;Buxton Index&quot; as mentioned in <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD11xx&#x2F;EWD1175.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD11xx&#x2F;E...</a></div><br/><div id="38795292" class="c"><input type="checkbox" id="c-38795292" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#38794233">parent</a><span>|</span><a href="#38802819">next</a><span>|</span><label class="collapse" for="c-38795292">[-]</label><label class="expand" for="c-38795292">[4 more]</label></div><br/><div class="children"><div class="content">Curious, I read the linked transcript to find:<p>&quot;My third remark introduces you to the Buxton Index, so named after its inventor, Professor John Buxton, at the time at Warwick University. The Buxton Index of an entity, i.e. person or organization, is defined as the length of the period, measured in years, over which the entity makes its plans. For the little grocery shop around the corner it is about 1&#x2F;2,for the true Christian it is infinity, and for most other entities it is in between: about 4 for the average politician who aims at his re-election, slightly more for most industries, but much less for the managers who have to write quarterly reports. The Buxton Index is an important concept because close co-operation between entities with very different Buxton Indices invariably fails and leads to moral complaints about the partner. The party with the smaller Buxton Index is accused of being superficial and short-sighted, while the party with the larger Buxton Index is accused of neglect of duty, of backing out of its responsibility, of freewheeling, etc.. In addition, each party accuses the other one of being stupid. The great advantage of the Buxton Index is that, as a simple numerical notion, it is morally neutral and lifts the difference above the plane of moral concerns. The Buxton Index is important to bear in mind when considering academic&#x2F;industrial co-operation.&quot;</div><br/><div id="38796329" class="c"><input type="checkbox" id="c-38796329" checked=""/><div class="controls bullet"><span class="by">apantel</span><span>|</span><a href="#38794233">root</a><span>|</span><a href="#38795292">parent</a><span>|</span><a href="#38795468">next</a><span>|</span><label class="collapse" for="c-38796329">[-]</label><label class="expand" for="c-38796329">[2 more]</label></div><br/><div class="children"><div class="content">Great concept, but isn’t it just “time horizon”?  Everyone knows “time horizon”.</div><br/><div id="38796520" class="c"><input type="checkbox" id="c-38796520" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38794233">root</a><span>|</span><a href="#38796329">parent</a><span>|</span><a href="#38795468">next</a><span>|</span><label class="collapse" for="c-38796520">[-]</label><label class="expand" for="c-38796520">[1 more]</label></div><br/><div class="children"><div class="content">Not everyone knows it, strangely, many of the (senior or junior) project management-types I work with have to be introduced to the term and concept (and if they listen it can at least resolve confusion, if not conflict, about the different priorities and behaviors of all the parties involved). But yes, they describe the same thing.</div><br/></div></div></div></div><div id="38795468" class="c"><input type="checkbox" id="c-38795468" checked=""/><div class="controls bullet"><span class="by">salawat</span><span>|</span><a href="#38794233">root</a><span>|</span><a href="#38795292">parent</a><span>|</span><a href="#38796329">prev</a><span>|</span><a href="#38802819">next</a><span>|</span><label class="collapse" for="c-38795468">[-]</label><label class="expand" for="c-38795468">[1 more]</label></div><br/><div class="children"><div class="content">Holy shit. I am so using this as a communication clarifying tool. Nice concept.</div><br/></div></div></div></div></div></div><div id="38802819" class="c"><input type="checkbox" id="c-38802819" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#38794233">prev</a><span>|</span><a href="#38793751">next</a><span>|</span><label class="collapse" for="c-38802819">[-]</label><label class="expand" for="c-38802819">[1 more]</label></div><br/><div class="children"><div class="content">Cold blooded: random utility written in C 40 years ago.<p>Warm blooded: random app using random Javascript framework, written 6 months ago.</div><br/></div></div><div id="38793751" class="c"><input type="checkbox" id="c-38793751" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#38802819">prev</a><span>|</span><a href="#38796357">next</a><span>|</span><label class="collapse" for="c-38793751">[-]</label><label class="expand" for="c-38793751">[3 more]</label></div><br/><div class="children"><div class="content">Counterpoint: some types of software aren’t meant to last long. Even if it still builds and can be worked on later, the usecase itself may have changed or disappeared, or someone has probably come up with a new better version, so that it’s no longer worth it to continue.<p>This probably doesn’t apply to many types of software over 6 months, but in a couple years or a couple decades. Some online services like CI or package managers will almost certainly provide backwards-compatible service until then.<p>Another possibility is that developer efficiency improves so much that the code written 10 years ago is easier to completely rewrite today, than it is to maintain and extend.<p>This is why I’m hesitant to think about software lasting decades, because tech changes so fast it’s hard to know what the next decade will look like. My hope is that in a few years, LLMs and&#x2F;or better developer tools will make code more flexible, so that it’s very easy to upgrade legacy code and fix imperfect code.</div><br/><div id="38795876" class="c"><input type="checkbox" id="c-38795876" checked=""/><div class="controls bullet"><span class="by">iamthepieman</span><span>|</span><a href="#38793751">parent</a><span>|</span><a href="#38796357">next</a><span>|</span><label class="collapse" for="c-38795876">[-]</label><label class="expand" for="c-38795876">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Another possibility is that developer efficiency improves so much that the code written 10 years ago is easier to completely rewrite today, than it is to maintain and extend.&quot;<p>This seems completely false to me and I&#x27;m curious what has caused you to believe this as I&#x27;m a fairly imaginative and creative person yet I cannot imagine a set of circumstance that would lead someone to this conclusion.<p>In other words, I disagree so very strongly with that statement that I wanted to engage rather than just downvote. (I didn&#x27;t btw).<p>I agree with your first statement though and I don&#x27;t think the op is saying only make cold-blooded projects.</div><br/><div id="38796335" class="c"><input type="checkbox" id="c-38796335" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#38793751">root</a><span>|</span><a href="#38795876">parent</a><span>|</span><a href="#38796357">next</a><span>|</span><label class="collapse" for="c-38796335">[-]</label><label class="expand" for="c-38796335">[1 more]</label></div><br/><div class="children"><div class="content">Well. I don’t know if I agree or not, but felt like playing devils advocate.<p>take the example of game development. Trying to maintain, say, the hobbit game from the early 2000s to today would almost certainly take more work than just making a new one from scratch today (GPUs have changed drastically over the past 20 years and making simple 3d platformers with unreal is so easy, “asset flips” are a new kind of scam)<p>Or a tool which lets people visually communicate over vast distances without specialized hardware.<p>That was a huge lift in the 2000s when Skype was the only major player, but you can find tutorials for it now using webrtc.</div><br/></div></div></div></div></div></div><div id="38796357" class="c"><input type="checkbox" id="c-38796357" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#38793751">prev</a><span>|</span><a href="#38799825">next</a><span>|</span><label class="collapse" for="c-38796357">[-]</label><label class="expand" for="c-38796357">[1 more]</label></div><br/><div class="children"><div class="content">Most of the software I write is at least somewhat cold-blooded by this definition. My program to find the dictionary forms of Finnish words is an <i>okay</i> example:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hiAndrewQuinn&#x2F;finstem">https:&#x2F;&#x2F;github.com&#x2F;hiAndrewQuinn&#x2F;finstem</a><p>I wrote the initial draft in an afternoon almost a year ago, and from then on endeavored to only make changes which I know play nicely with my local software ecology. I usually have `fzf` installed, so an interactive mode comes as a shell script. I usually have `csvkit`, `jq`, and if all else fails `awk` installed, so my last major update was to include flags for CSV, JSON, and TSV output respectively. Etc, etc.<p>The build instructions intentionally eschew anything like Poetry and just gives you the shell commands I would run on a fresh Ubuntu VirtualBox VM. I hand test it every couple of months in this environment. If the need to Dockerize it ever arose I&#x27;m sure it would be straightforward, in part because the shell commands themselves are straightforward.<p>I don&#x27;t call it a great example because the CLI library I use could potentially change. Still, I&#x27;ve endeavored to stick to only relatively mature offerings.</div><br/></div></div><div id="38799825" class="c"><input type="checkbox" id="c-38799825" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#38796357">prev</a><span>|</span><a href="#38794320">next</a><span>|</span><label class="collapse" for="c-38799825">[-]</label><label class="expand" for="c-38799825">[1 more]</label></div><br/><div class="children"><div class="content">Worth mentioning the Hare language, designed to be  stable for 100 years. After they release 1.0 they don&#x27;t plan to change it beyond fixes. It&#x27;s Drew DeVault&#x27;s project.<p><a href="https:&#x2F;&#x2F;harelang.org&#x2F;roadmap&#x2F;" rel="nofollow">https:&#x2F;&#x2F;harelang.org&#x2F;roadmap&#x2F;</a></div><br/></div></div><div id="38794320" class="c"><input type="checkbox" id="c-38794320" checked=""/><div class="controls bullet"><span class="by">jollyllama</span><span>|</span><a href="#38799825">prev</a><span>|</span><a href="#38795795">next</a><span>|</span><label class="collapse" for="c-38794320">[-]</label><label class="expand" for="c-38794320">[13 more]</label></div><br/><div class="children"><div class="content">This is why I am trying to switch as many projects I&#x27;m on as possible to HTMX. The churn involved with all of the frontend frameworks means that there&#x27;s far too much update work needed after letting a project sit for N quarters.</div><br/><div id="38795776" class="c"><input type="checkbox" id="c-38795776" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#38794320">parent</a><span>|</span><a href="#38795795">next</a><span>|</span><label class="collapse" for="c-38795776">[-]</label><label class="expand" for="c-38795776">[12 more]</label></div><br/><div class="children"><div class="content">I googled HTMX, all excited that maybe, just maybe, the browser people got their shit together and came up with a framework we can all live with, something native to the browser with a few new tags, and no other batteries required....<p>and was disappointed to find it&#x27;s just a pile of other libraries 8(</div><br/><div id="38796261" class="c"><input type="checkbox" id="c-38796261" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38795776">parent</a><span>|</span><a href="#38796961">next</a><span>|</span><label class="collapse" for="c-38796261">[-]</label><label class="expand" for="c-38796261">[7 more]</label></div><br/><div class="children"><div class="content">Everything is a pile of libraries.<p>It’s a pile of someone else’s code all the way down.</div><br/><div id="38796317" class="c"><input type="checkbox" id="c-38796317" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38796261">parent</a><span>|</span><a href="#38800077">next</a><span>|</span><label class="collapse" for="c-38796317">[-]</label><label class="expand" for="c-38796317">[5 more]</label></div><br/><div class="children"><div class="content">You can also use the web platform straight up without transpilation, build tools, post-css compilation and all that jazz.<p>Just vanilla JavaScript, CSS, HTML, some sprinkles of WebComponents. And you can be pretty sure that you won&#x27;t have to update that for a decade or more, as compatibility won&#x27;t be broken in browsers.<p>Heck, I have vanilla JS projects I wrote 15 years ago that still render and work exactly like how they rendered&#x2F;worked when I wrote them.</div><br/><div id="38797014" class="c"><input type="checkbox" id="c-38797014" checked=""/><div class="controls bullet"><span class="by">jollyllama</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38796317">parent</a><span>|</span><a href="#38800077">next</a><span>|</span><label class="collapse" for="c-38797014">[-]</label><label class="expand" for="c-38797014">[4 more]</label></div><br/><div class="children"><div class="content">Indeed, that baggage is all that I avoid by using HTMX.</div><br/><div id="38797468" class="c"><input type="checkbox" id="c-38797468" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38797014">parent</a><span>|</span><a href="#38800077">next</a><span>|</span><label class="collapse" for="c-38797468">[-]</label><label class="expand" for="c-38797468">[3 more]</label></div><br/><div class="children"><div class="content">You do you. It&#x27;s worth knowing though that using HTMX is not vanilla JS&#x2F;HTML&#x2F;CSS, it&#x27;s literally the opposite of that.</div><br/><div id="38801035" class="c"><input type="checkbox" id="c-38801035" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38797468">parent</a><span>|</span><a href="#38799215">next</a><span>|</span><label class="collapse" for="c-38801035">[-]</label><label class="expand" for="c-38801035">[1 more]</label></div><br/><div class="children"><div class="content">Have you ever worked with just raw js?<p>Anything more than a todo list becomes unwieldy almost instantly.<p>Taking a small dependency to avoid that is well worth it.<p>Taking a whole “virtual dom” may be overkill though (looking at you, react)</div><br/></div></div><div id="38799215" class="c"><input type="checkbox" id="c-38799215" checked=""/><div class="controls bullet"><span class="by">kugelblitz</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38797468">parent</a><span>|</span><a href="#38801035">prev</a><span>|</span><a href="#38800077">next</a><span>|</span><label class="collapse" for="c-38799215">[-]</label><label class="expand" for="c-38799215">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s one small dependency. Worst case, you write the library yourself.<p>You send a request to the backend, it then sends you HTML back (all rendered in the backend using a templating language such as Django templating engine, Twig or Liquid), you insert it into a div or so.<p>Htmx was Intercooler, worst case you create your own. But no additional scripts needed.<p>I&#x27;ve been able to kick out Vue out because Htmx covers my use case.</div><br/></div></div></div></div></div></div></div></div><div id="38800077" class="c"><input type="checkbox" id="c-38800077" checked=""/><div class="controls bullet"><span class="by">Tao3300</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38796261">parent</a><span>|</span><a href="#38796317">prev</a><span>|</span><a href="#38796961">next</a><span>|</span><label class="collapse" for="c-38800077">[-]</label><label class="expand" for="c-38800077">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;2347&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;2347&#x2F;</a><p>And don&#x27;t forget the alt-text</div><br/></div></div></div></div><div id="38796961" class="c"><input type="checkbox" id="c-38796961" checked=""/><div class="controls bullet"><span class="by">replwoacause</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38795776">parent</a><span>|</span><a href="#38796261">prev</a><span>|</span><a href="#38795795">next</a><span>|</span><label class="collapse" for="c-38796961">[-]</label><label class="expand" for="c-38796961">[4 more]</label></div><br/><div class="children"><div class="content">Nothing to be disappointed in here AFAICT, however, it’s shocking that you had to Google HTMX, seeing as it shows up on HN a few times a month at least.</div><br/><div id="38797548" class="c"><input type="checkbox" id="c-38797548" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38796961">parent</a><span>|</span><a href="#38795795">next</a><span>|</span><label class="collapse" for="c-38797548">[-]</label><label class="expand" for="c-38797548">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing the disappointing feeling come from parent saying &quot;Pff, I&#x27;m so tired of all these libraries that eventually update their APIs in a breaking way, so now I&#x27;m using X&quot; while X is just another library exactly like all the rest, and will surely introduce a breaking change or two down the line.</div><br/><div id="38798094" class="c"><input type="checkbox" id="c-38798094" checked=""/><div class="controls bullet"><span class="by">jollyllama</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38797548">parent</a><span>|</span><a href="#38795795">next</a><span>|</span><label class="collapse" for="c-38798094">[-]</label><label class="expand" for="c-38798094">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re arguing from the abstract point of view, rather than the practical. The point is that it takes an order of magnitude more time to clone, say, a Vue project from three years ago that nobody has touched since then and try to download your dependencies and build on a new machine, as compared to an HTMX project.</div><br/><div id="38799835" class="c"><input type="checkbox" id="c-38799835" checked=""/><div class="controls bullet"><span class="by">uxp8u61q</span><span>|</span><a href="#38794320">root</a><span>|</span><a href="#38798094">parent</a><span>|</span><a href="#38795795">next</a><span>|</span><label class="collapse" for="c-38799835">[-]</label><label class="expand" for="c-38799835">[1 more]</label></div><br/><div class="children"><div class="content">As if &quot;npm&#x2F;yarn install&quot; wouldn&#x27;t work for the hypothetical Vue project? A charitable interpretation of what you&#x27;re saying is that you cannot clone a vue project from three years ago, <i>update all dependencies to the latest version</i>, and expect that to work. But then, how is it different for HTMX, other than for the fact that 1. it&#x27;s younger 2. you don&#x27;t have the ecosystem around it to update - but that also means you&#x27;re doing less or redoing everything yourself.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38795795" class="c"><input type="checkbox" id="c-38795795" checked=""/><div class="controls bullet"><span class="by">coreyp_1</span><span>|</span><a href="#38794320">prev</a><span>|</span><a href="#38801842">next</a><span>|</span><label class="collapse" for="c-38795795">[-]</label><label class="expand" for="c-38795795">[6 more]</label></div><br/><div class="children"><div class="content">This.  This, so very much!<p>I built my websites on Drupal 7 and have enjoyed a decade of stability.  Now, with D7 approaching EOL in 1 year, I&#x27;m looking for a solution that will last another decade.  There&#x27;s no reason for the EOL, either, other than people wanting to force everyone to move on to a newer version.  It undoubtedly means more business for some people, as they will be able to reach out to their clients and say, &quot;Your website is about to be a security risk, so you have to pay to update it!&quot;  Unfortunately, it means more work for me to support my personal projects.<p>And why?  Because someone somewhere has decided that I should move on to something newer and more exciting.  But I don&#x27;t want new and exciting... I want rock solid!<p>I&#x27;m on vacation this week.  Am I learning a new hot language like Rust, Zig, Go, etc.?<p>Nope.<p>I have no desire to.  I don&#x27;t trust them to be the same in a decade, anyway.<p>I&#x27;m focusing on C.  It&#x27;s far more enjoyable, and it&#x27;s stable.</div><br/><div id="38802856" class="c"><input type="checkbox" id="c-38802856" checked=""/><div class="controls bullet"><span class="by">edg5000</span><span>|</span><a href="#38795795">parent</a><span>|</span><a href="#38802839">next</a><span>|</span><label class="collapse" for="c-38802856">[-]</label><label class="expand" for="c-38802856">[1 more]</label></div><br/><div class="children"><div class="content">How much interaction do your sites have? If you ran a little program locally that took the sitemap, and generated a static site, then you will be immune for life for those security and maintenance arguments.<p>You can probaly pin the PHP, SQL, and webserver versions, compile them from source so that you will always have the binaries at hand. Then it will last another 1000 years.<p>However, if you need user interaction, then you are stuck in an eternal rat race of security updates and deprecation, leading to major upgrades, leading to more security updates!</div><br/></div></div><div id="38802839" class="c"><input type="checkbox" id="c-38802839" checked=""/><div class="controls bullet"><span class="by">pxtail</span><span>|</span><a href="#38795795">parent</a><span>|</span><a href="#38802856">prev</a><span>|</span><a href="#38796247">next</a><span>|</span><label class="collapse" for="c-38802839">[-]</label><label class="expand" for="c-38802839">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why? Because someone somewhere has decided that I should move on to something newer and more exciting. But I don&#x27;t want new and exciting... I want rock solid!<p>Well, it also could be because someone else decided to move on to something newer and more exciting instead of dutifully maintaining 10y old free software because someone WANTS to have peace of mind on their vacation.</div><br/></div></div><div id="38796247" class="c"><input type="checkbox" id="c-38796247" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#38795795">parent</a><span>|</span><a href="#38802839">prev</a><span>|</span><a href="#38799194">next</a><span>|</span><label class="collapse" for="c-38796247">[-]</label><label class="expand" for="c-38796247">[2 more]</label></div><br/><div class="children"><div class="content">Enjoyable is subjective.
I can’t think of anything less enjoyable than hunting for segfaults in C.<p>I’d call Go pretty rock solid at this point.
Modern go vs decade old go isn’t very different. Maybe just the packages tools had 1 major changed.<p>You’d get the same thing in C if your hardware significantly changes in the 10 years too.</div><br/><div id="38797445" class="c"><input type="checkbox" id="c-38797445" checked=""/><div class="controls bullet"><span class="by">coreyp_1</span><span>|</span><a href="#38795795">root</a><span>|</span><a href="#38796247">parent</a><span>|</span><a href="#38799194">next</a><span>|</span><label class="collapse" for="c-38797445">[-]</label><label class="expand" for="c-38797445">[1 more]</label></div><br/><div class="children"><div class="content">Haha... I agree about it being subjective!  I find that I enjoy the process as much as the result.  It&#x27;s like bringing order to a chaotic universe. :)<p>The thing is, I don&#x27;t have many segfaults in C, and I find C much easier to debug and hunt down issues in than even C++ (which I also enjoy).  Also, because C uses very little &quot;magic&quot;, and I also know exactly what I&#x27;m getting with my code, I find it much easier to reason about.<p>I heard a quote the other day while watching a presentation &quot;When you&#x27;re young you want results, when you&#x27;re old you want control.&quot;  I think I&#x27;m on the old side now.<p>As for Go, I genuinely don&#x27;t have anything against it, but I don&#x27;t see why I need it either.  I don&#x27;t doubt that others have stellar use cases and impressive results with Go, and that&#x27;s fine, too, but I don&#x27;t sense any lack which prompts me to investigate further.  I would love to learn more about it, but most of what I see online is either over-the-top (and therefore vomit-inducing) fanboyism, or otherwise unspectacular, which makes me ask &quot;why bother?&quot;</div><br/></div></div></div></div><div id="38799194" class="c"><input type="checkbox" id="c-38799194" checked=""/><div class="controls bullet"><span class="by">flir</span><span>|</span><a href="#38795795">parent</a><span>|</span><a href="#38796247">prev</a><span>|</span><a href="#38801842">next</a><span>|</span><label class="collapse" for="c-38799194">[-]</label><label class="expand" for="c-38799194">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;backdropcms.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;backdropcms.org&#x2F;</a> ? D7 fork. If you want to stay there.</div><br/></div></div></div></div><div id="38801842" class="c"><input type="checkbox" id="c-38801842" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#38795795">prev</a><span>|</span><a href="#38801152">next</a><span>|</span><label class="collapse" for="c-38801842">[-]</label><label class="expand" for="c-38801842">[2 more]</label></div><br/><div class="children"><div class="content">I’ve got a similar one, yet to be written, about “cold computing”. How do you compute if you’re on a limited solar+battery installation? what if your CPU wakes up and you have only a couple of hours of runtime? What if you only can turn on wifi for 20 minutes a day?</div><br/><div id="38802078" class="c"><input type="checkbox" id="c-38802078" checked=""/><div class="controls bullet"><span class="by">g8oz</span><span>|</span><a href="#38801842">parent</a><span>|</span><a href="#38801152">next</a><span>|</span><label class="collapse" for="c-38802078">[-]</label><label class="expand" for="c-38802078">[1 more]</label></div><br/><div class="children"><div class="content">This sounds very interesting, please do write it up.</div><br/></div></div></div></div><div id="38801152" class="c"><input type="checkbox" id="c-38801152" checked=""/><div class="controls bullet"><span class="by">synack</span><span>|</span><a href="#38801842">prev</a><span>|</span><a href="#38800872">next</a><span>|</span><label class="collapse" for="c-38801152">[-]</label><label class="expand" for="c-38801152">[1 more]</label></div><br/><div class="children"><div class="content">If you limit your dependencies to what’s available in your distro’s LTS or stable release breaking changes are much less common. Living on the bleeding edge has a cost.</div><br/></div></div><div id="38800872" class="c"><input type="checkbox" id="c-38800872" checked=""/><div class="controls bullet"><span class="by">johnnyworker</span><span>|</span><a href="#38801152">prev</a><span>|</span><a href="#38799454">next</a><span>|</span><label class="collapse" for="c-38800872">[-]</label><label class="expand" for="c-38800872">[1 more]</label></div><br/><div class="children"><div class="content">I kept making CMS as a hobby, starting with flat files and PHP, moving to MySQL.. simple things. I did it precisely because I figured if I modify and write plugins for Wordpress, I would have to keep updating them on their schedule. Especially since even back then I really liked <i>removing</i> things I don&#x27;t want, and while carrying over <i>additions</i> I created over to new versions might be easy enough, maintaining a stripped down version of something like Wordpress (even 20 years ago..) would have been impossible.<p>I felt like a stubborn dumb ass in the early 2000s (and there was also this constant mockery of &quot;NIH syndrome&quot; in the air) but by now, I&#x27;m so glad I basically disregarded a lot of stuff and just made my own things out of the basics. And coincidentally, the last one I made has also lasted me over 12 years by now. I still love it actually, it&#x27;s just the code that is terrible. So I started a new one, to fix all the mistakes of the previous one, which mostly is cutting less corners because now I know that I&#x27;ll use this for <i>way</i> longer than I can reasonably estimate right now, so I try to be kind(er) to future me.<p>(But I&#x27;ll also make fascinating new mistakes, because I decided to de-duplicate more or less everything at the DB level, on a whim, without prior experience or reading up on it. And then I&#x27;ll write some monstrosity to pipe 12 years of content from the old CMS into the new one, and I will not break a single link even though nobody would really care. Just because I can.)</div><br/></div></div><div id="38799454" class="c"><input type="checkbox" id="c-38799454" checked=""/><div class="controls bullet"><span class="by">oooyay</span><span>|</span><a href="#38800872">prev</a><span>|</span><a href="#38797743">next</a><span>|</span><label class="collapse" for="c-38799454">[-]</label><label class="expand" for="c-38799454">[1 more]</label></div><br/><div class="children"><div class="content">This got me thinking if any of my side projects or work projects that are in maintenance mode could qualify as &quot;cold blooded&quot;. Conceptually, they can - I have many projects written in Go, Typescript, and Python where I could cache my dependencies (or at least the SHAs) and do what this is implying. The problem is that it stops being useful beyond proving the concept. In reality, all my projects have a slow churn that usually has to do with vulnerability updates. Maybe more aptly put, &quot;Can I take this Go repository off the shelf, rebuild the binary, and let it run?&quot;; the answer is of course - assuming HTML and web standards haven&#x27;t changed too much. The problem is that then some old vulnerability could be immediately used against it. The assumption I also made, that HTML and web standards haven&#x27;t changed too much, will almost assuredly be falsey. They may have not have changed enough to be breaking, but they&#x27;ll have certainly changed to some degree; the same can be said for anyone that&#x27;s developed desktop applications for any OS. The one constant is change. Either side of that coin seems to be a losing proposition.</div><br/></div></div><div id="38797743" class="c"><input type="checkbox" id="c-38797743" checked=""/><div class="controls bullet"><span class="by">aranchelk</span><span>|</span><a href="#38799454">prev</a><span>|</span><a href="#38795062">next</a><span>|</span><label class="collapse" for="c-38797743">[-]</label><label class="expand" for="c-38797743">[1 more]</label></div><br/><div class="children"><div class="content">In my mind this is a lot more about tooling and platform than language, library, architecture, etc.<p>I have a project that’s quite complicated and built on fast-moving tech, but with every element of the build locked down and committed in SCM: Dockerfiles, package sets, etc.<p>Alternatively, one of my older projects uses very stable slow-moving tech. I never took the time to containerize and codify the dependencies. It runs as an appliance and is such a mess that it’s cheaper to buy duplicates of the original machine that it ran on and clone the old hard drive rather than do fresh installs.</div><br/></div></div><div id="38795062" class="c"><input type="checkbox" id="c-38795062" checked=""/><div class="controls bullet"><span class="by">ryanar</span><span>|</span><a href="#38797743">prev</a><span>|</span><a href="#38798635">next</a><span>|</span><label class="collapse" for="c-38795062">[-]</label><label class="expand" for="c-38795062">[1 more]</label></div><br/><div class="children"><div class="content">I really appreciate this idea after rewriting my blog engine three times because the frameworks I was using (Next, Remix) had fundamental changes after a year and I was multiple major versions behind. Though it depends on what you are after. If the goal is to be able to blog, time spent upgrading and rewriting code because the framework is evolving is wasted time unless you want to stay up to date with that framework. Think about how we view physical goods today, they aren’t built to last. In certain situations, like a personal blog, you want reliable software that works for years without the need to change. It also helps to have software that uses common data formats that are exportable to another system, like a blog based in markdown files, rather than JSX.</div><br/></div></div><div id="38798635" class="c"><input type="checkbox" id="c-38798635" checked=""/><div class="controls bullet"><span class="by">aeternum</span><span>|</span><a href="#38795062">prev</a><span>|</span><a href="#38795591">next</a><span>|</span><label class="collapse" for="c-38798635">[-]</label><label class="expand" for="c-38798635">[2 more]</label></div><br/><div class="children"><div class="content">What a terrible name for this.  Cold blooded animals are highly dependent on their environment whereas the body of warm-blooded animals eliminate the dependency on external temperature via metabolism.<p>In any case, it&#x27;s unnecessarily ambiguous.  Why not simply say &#x27;software without external dependencies&#x27; and eliminate the paragraphs of meandering explanation?</div><br/><div id="38802409" class="c"><input type="checkbox" id="c-38802409" checked=""/><div class="controls bullet"><span class="by">littleroot</span><span>|</span><a href="#38798635">parent</a><span>|</span><a href="#38795591">next</a><span>|</span><label class="collapse" for="c-38802409">[-]</label><label class="expand" for="c-38802409">[1 more]</label></div><br/><div class="children"><div class="content">This is literally the only reply that hit the core of the article&#x27;s problem and of course no one on this site upvoted it lol.
The only thing I dislike more than software development posts that use inappropriate analogy from nature to shallowly jump to conclusion, is software development posts that use inappropriate analogy from nature to shallowly jump to conclusion with absolutely flawed understanding of the supposedly analogous natural phenomenon.<p>And of course, painted turtles (among a few other species) can survive being frozen not because of their cold-bloodedness, but thanks to special antifreeze protein they have. Other lizards (and cold blooded animals for that matter) would just rupture their own tissues upon thawing.</div><br/></div></div></div></div><div id="38795591" class="c"><input type="checkbox" id="c-38795591" checked=""/><div class="controls bullet"><span class="by">sowbug</span><span>|</span><a href="#38798635">prev</a><span>|</span><a href="#38800310">next</a><span>|</span><label class="collapse" for="c-38795591">[-]</label><label class="expand" for="c-38795591">[2 more]</label></div><br/><div class="children"><div class="content">A link to this article would be an effective curt reply to the &quot;is this project dead?&quot; GitHub issues that have been known to enrage and discourage cold-blooded project owners.</div><br/><div id="38798630" class="c"><input type="checkbox" id="c-38798630" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38795591">parent</a><span>|</span><a href="#38800310">next</a><span>|</span><label class="collapse" for="c-38798630">[-]</label><label class="expand" for="c-38798630">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if GitHub is a bad fit for cold blooded projects? It has social media elements, I’d expect lots of extra chatter and “engagement.”</div><br/></div></div></div></div><div id="38800310" class="c"><input type="checkbox" id="c-38800310" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38795591">prev</a><span>|</span><a href="#38798029">next</a><span>|</span><label class="collapse" for="c-38800310">[-]</label><label class="expand" for="c-38800310">[1 more]</label></div><br/><div class="children"><div class="content">I have some Windows binaries from the mid 90s that I still use today. Mainly small utilities for various calculations&#x2F;conversions, filesystem organisation, and the like.</div><br/></div></div><div id="38798029" class="c"><input type="checkbox" id="c-38798029" checked=""/><div class="controls bullet"><span class="by">blastbking</span><span>|</span><a href="#38800310">prev</a><span>|</span><a href="#38797507">next</a><span>|</span><label class="collapse" for="c-38798029">[-]</label><label class="expand" for="c-38798029">[2 more]</label></div><br/><div class="children"><div class="content">I had this experience making an iOS game. After a few years of making the game, I went back to it, and found that I was unable to get it to compile. I guess iOS games are very warm blooded. Perhaps if I had stuck with a desktop platform or web it would have remained fine? Not entirely sure.</div><br/><div id="38798157" class="c"><input type="checkbox" id="c-38798157" checked=""/><div class="controls bullet"><span class="by">yellow_lead</span><span>|</span><a href="#38798029">parent</a><span>|</span><a href="#38797507">next</a><span>|</span><label class="collapse" for="c-38798157">[-]</label><label class="expand" for="c-38798157">[1 more]</label></div><br/><div class="children"><div class="content">Mobile in general is this way. For instance, on Android, if your app isn&#x27;t targeting a high enough sdk version, Google will remove it after some time. If you have to upgrade your target sdk, you may find many libraries are broken (or not supported), and it also can lead to other cascades of upgrades, like having to upgrade gradle or the NDK if you use it.</div><br/></div></div></div></div><div id="38797507" class="c"><input type="checkbox" id="c-38797507" checked=""/><div class="controls bullet"><span class="by">ganzuul</span><span>|</span><a href="#38798029">prev</a><span>|</span><a href="#38799669">next</a><span>|</span><label class="collapse" for="c-38797507">[-]</label><label class="expand" for="c-38797507">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unix_philosophy" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unix_philosophy</a><p>Seems related. Tools built like this which still need constant updating must have a foundation of sand.</div><br/></div></div><div id="38799669" class="c"><input type="checkbox" id="c-38799669" checked=""/><div class="controls bullet"><span class="by">d_burfoot</span><span>|</span><a href="#38797507">prev</a><span>|</span><a href="#38801351">next</a><span>|</span><label class="collapse" for="c-38799669">[-]</label><label class="expand" for="c-38799669">[1 more]</label></div><br/><div class="children"><div class="content">This essay showcased an excellent writing technique: at the outset, I had no idea what the title meant. But at the conclusion, it made perfect sense.</div><br/></div></div><div id="38801351" class="c"><input type="checkbox" id="c-38801351" checked=""/><div class="controls bullet"><span class="by">talentedcoin</span><span>|</span><a href="#38799669">prev</a><span>|</span><label class="collapse" for="c-38801351">[-]</label><label class="expand" for="c-38801351">[1 more]</label></div><br/><div class="children"><div class="content">Using Python 2 in 2023 for a new project is a crime</div><br/></div></div></div></div></div></div></div></body></html>