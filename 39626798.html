<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709974863926" as="style"/><link rel="stylesheet" href="styles.css?v=1709974863926"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://stevana.github.io/towards_zero-downtime_upgrades_of_stateful_systems.html">Towards zero-downtime upgrades of stateful systems</a> <span class="domain">(<a href="https://stevana.github.io">stevana.github.io</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>8 comments</span></div><br/><div><div id="39649316" class="c"><input type="checkbox" id="c-39649316" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39649395">next</a><span>|</span><label class="collapse" for="c-39649316">[-]</label><label class="expand" for="c-39649316">[5 more]</label></div><br/><div class="children"><div class="content">This seems like a problem you can’t solve generically and you always end up making trade offs. The two main challenges I can think of:<p>* State in old system isn’t representable in new system (not a backwards compatible upgrade or more likely a bug exists in handling the new state)<p>* There’s state outside of the program that’s impossible to transition gracefully (e.g. dirtied IO socket where you don’t know what it’s state is &amp; it’s a resource owned outside of your program)<p>* Transitioning state means there’s a possibility of failure because the program never reaches a graceful transition point to snapshot the state. So you either have to choose between running the old program forever or abandoning the graceful state transition anyway.<p>Distributed systems I’ve observed pick one of two strategies:<p>1. Using the load balancer strategy of migrating off the old version &amp; then terminating it after some grace period.<p>2. Use a formal distributed state system like CockroachDB, Yuggabyte, DynamoDB, S3, etc etc.<p>This is probably a big reason why most programs use external storage solutions even if they’re less efficient - it centralizes maintenance of state onto a system that has well defined semantics and can handle repair transparently.</div><br/><div id="39650436" class="c"><input type="checkbox" id="c-39650436" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#39649316">parent</a><span>|</span><a href="#39650277">next</a><span>|</span><label class="collapse" for="c-39650436">[-]</label><label class="expand" for="c-39650436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; * State in old system isn’t representable in new system (not a backwards compatible upgrade or more likely a bug exists in handling the new state)<p>New system starts in a backwards compatible mode where it accepted all state that was representable in old system. Transition is achieved after the upgrade, with flag variables.</div><br/></div></div><div id="39650277" class="c"><input type="checkbox" id="c-39650277" checked=""/><div class="controls bullet"><span class="by">stevan</span><span>|</span><a href="#39649316">parent</a><span>|</span><a href="#39650436">prev</a><span>|</span><a href="#39649472">next</a><span>|</span><label class="collapse" for="c-39650277">[-]</label><label class="expand" for="c-39650277">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This seems like a problem you can’t solve generically and you always end up making trade offs.<p>That shouldn&#x27;t stop us from solving the problem in the cases where it&#x27;s possible though? We can tackle the corner cases separately with manual overrides.<p>&gt; This is probably a big reason why most programs use external storage solutions even if they’re less efficient - it centralizes maintenance of state onto a system that has well defined semantics and can handle repair transparently.<p>This is certainly the case today, what I&#x27;m asking is: does it always have to be like that in the future?</div><br/><div id="39650293" class="c"><input type="checkbox" id="c-39650293" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39649316">root</a><span>|</span><a href="#39650277">parent</a><span>|</span><a href="#39649472">next</a><span>|</span><label class="collapse" for="c-39650293">[-]</label><label class="expand" for="c-39650293">[1 more]</label></div><br/><div class="children"><div class="content">I suspect that it’s impossible in the sense that the “possible” space will look like a distributed storage solution and the rest will look similar to graceful handoff of new connections to new version + shutdown of old version after some time (with forceful disconnect of sessions hanging around).</div><br/></div></div></div></div><div id="39649472" class="c"><input type="checkbox" id="c-39649472" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39649316">parent</a><span>|</span><a href="#39650277">prev</a><span>|</span><a href="#39649395">next</a><span>|</span><label class="collapse" for="c-39649472">[-]</label><label class="expand" for="c-39649472">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is probably a big reason why most programs use external storage solutions even if they’re less efficient - it centralizes maintenance of state onto a system that has well defined semantics and can handle repair transparently.<p>Indeed, now contrast with the article on HN discussing orthogonal persistence.</div><br/></div></div></div></div><div id="39649395" class="c"><input type="checkbox" id="c-39649395" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#39649316">prev</a><span>|</span><a href="#39649218">next</a><span>|</span><label class="collapse" for="c-39649395">[-]</label><label class="expand" for="c-39649395">[1 more]</label></div><br/><div class="children"><div class="content">I love this and often think about how we can write more robust systems without having to rewrite the whole thing when the implementation of just one part changes. State has a way of becoming a global variable which all modules depend on</div><br/></div></div><div id="39649218" class="c"><input type="checkbox" id="c-39649218" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39649395">prev</a><span>|</span><label class="collapse" for="c-39649218">[-]</label><label class="expand" for="c-39649218">[1 more]</label></div><br/><div class="children"><div class="content">Use cassandra?</div><br/></div></div></div></div></div></div></div></body></html>