<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704445253794" as="style"/><link rel="stylesheet" href="styles.css?v=1704445253794"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://concerningquality.com/txn-isolation-testing/">Does your test suite account for weak transaction isolation?</a> <span class="domain">(<a href="https://concerningquality.com">concerningquality.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>41 comments</span></div><br/><div><div id="38875456" class="c"><input type="checkbox" id="c-38875456" checked=""/><div class="controls bullet"><span class="by">defaultcompany</span><span>|</span><a href="#38870225">next</a><span>|</span><label class="collapse" for="c-38875456">[-]</label><label class="expand" for="c-38875456">[1 more]</label></div><br/><div class="children"><div class="content">I made a little project called Concurrency Runner a while ago to attempt to test these kinds of scenarios: <a href="https:&#x2F;&#x2F;github.com&#x2F;weinberg&#x2F;concurrencyRunner">https:&#x2F;&#x2F;github.com&#x2F;weinberg&#x2F;concurrencyRunner</a>. It does so by running multiple copies of your process in debug mode with breakpoints set to allow specific interleaved execution paths to be explored. This allows you to trigger concurrency scenarios which are difficult to analyze because they otherwise would rely on random timing. That repo has examples which demonstrate  &quot;read skew&quot;, &quot;write skew&quot; and &quot;read modify write&quot; concurrency scenarios. I was hoping I could make it into something you could run in CI to actively test for these things. Ultimately it was more of a research project than anything else but maybe someone will find it useful or interesting.</div><br/></div></div><div id="38870225" class="c"><input type="checkbox" id="c-38870225" checked=""/><div class="controls bullet"><span class="by">nick__m</span><span>|</span><a href="#38875456">prev</a><span>|</span><a href="#38872165">next</a><span>|</span><label class="collapse" for="c-38870225">[-]</label><label class="expand" for="c-38870225">[10 more]</label></div><br/><div class="children"><div class="content">Why optimistic locking is never considered in those articles ? Adding a version column and checking the affected numbers of row scales a lot better that a select for update...</div><br/><div id="38870330" class="c"><input type="checkbox" id="c-38870330" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#38870225">parent</a><span>|</span><a href="#38870513">next</a><span>|</span><label class="collapse" for="c-38870330">[-]</label><label class="expand" for="c-38870330">[3 more]</label></div><br/><div class="children"><div class="content">Probably because it’s more work, and it’s logic that you have to write and get correct. Whereas “for update” pretty much just works.<p>But there are definitely many valid solutions, including just setting the specific transaction to serializable and handling transaction retries.</div><br/><div id="38871836" class="c"><input type="checkbox" id="c-38871836" checked=""/><div class="controls bullet"><span class="by">gav</span><span>|</span><a href="#38870225">root</a><span>|</span><a href="#38870330">parent</a><span>|</span><a href="#38871412">next</a><span>|</span><label class="collapse" for="c-38871836">[-]</label><label class="expand" for="c-38871836">[1 more]</label></div><br/><div class="children"><div class="content">Optimistic locking is a great solution to avoid holding a lock for an indeterminate period of time as you wait for a user or external system to provide updates.</div><br/></div></div><div id="38871412" class="c"><input type="checkbox" id="c-38871412" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#38870225">root</a><span>|</span><a href="#38870330">parent</a><span>|</span><a href="#38871836">prev</a><span>|</span><a href="#38870513">next</a><span>|</span><label class="collapse" for="c-38871412">[-]</label><label class="expand" for="c-38871412">[1 more]</label></div><br/><div class="children"><div class="content"><i>and handling retries</i> is something I almost never see, and more infrequently see done right.</div><br/></div></div></div></div><div id="38870513" class="c"><input type="checkbox" id="c-38870513" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38870225">parent</a><span>|</span><a href="#38870330">prev</a><span>|</span><a href="#38871518">next</a><span>|</span><label class="collapse" for="c-38870513">[-]</label><label class="expand" for="c-38870513">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know about databases but I’ve done similar with testing interactive web apps and it works quite well. When your architecture supports it, at least.<p>Essentially a hidden field on the page that tracks interactions and outstanding Ajax calls. When you assert that a field on the page hasn’t changed, you need to know that it’s not still in the process of painting. And just waiting “long enough” makes for very slow testing overall.</div><br/></div></div><div id="38871518" class="c"><input type="checkbox" id="c-38871518" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38870225">parent</a><span>|</span><a href="#38870513">prev</a><span>|</span><a href="#38872165">next</a><span>|</span><label class="collapse" for="c-38871518">[-]</label><label class="expand" for="c-38871518">[5 more]</label></div><br/><div class="children"><div class="content">because row version does not make it possible to update more than 1 row atomically.</div><br/><div id="38871941" class="c"><input type="checkbox" id="c-38871941" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#38870225">root</a><span>|</span><a href="#38871518">parent</a><span>|</span><a href="#38872165">next</a><span>|</span><label class="collapse" for="c-38871941">[-]</label><label class="expand" for="c-38871941">[4 more]</label></div><br/><div class="children"><div class="content">Yes it does. UPDATE foo = &#x27;abc&#x27; WHERE (id, version) IN ((123, 1), (234, 2))</div><br/><div id="38872142" class="c"><input type="checkbox" id="c-38872142" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38870225">root</a><span>|</span><a href="#38871941">parent</a><span>|</span><a href="#38872165">next</a><span>|</span><label class="collapse" for="c-38872142">[-]</label><label class="expand" for="c-38872142">[3 more]</label></div><br/><div class="children"><div class="content">while true this is not what I mean.<p>if your goal is to transfer 10 dollars for account A to account B
but only if account A balance is larger than 10 dollars.<p>You have to update account A to be 10 dollars less<p>and<p>you have to update account B to be 10 dollars more.<p>you can read both account a keep track of current version number for each.<p>then do<p>&quot;UPDATE Accounts SET Balance = CASE AccountID WHEN 1 THEN Balance - 10 WHEN 2 THEN Balance + 10 END WHERE (AccountID, version) IN ((1,v1), (2,v2))&quot;<p>But if using Read Uncommited isolation level I am not sure this UPDATE would actually lock both row until commit.</div><br/><div id="38872274" class="c"><input type="checkbox" id="c-38872274" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38870225">root</a><span>|</span><a href="#38872142">parent</a><span>|</span><a href="#38872165">next</a><span>|</span><label class="collapse" for="c-38872274">[-]</label><label class="expand" for="c-38872274">[2 more]</label></div><br/><div class="children"><div class="content">you still have to do<p>IF @@ROWCOUNT = 2
    BEGIN
        COMMIT TRANSACTION;
    END
    ELSE
    BEGIN
        ROLLBACK TRANSACTION;
    END<p>to make sure both rows have been updated.
so its a lot simpler to explicitly take a lock on the rows.</div><br/><div id="38872398" class="c"><input type="checkbox" id="c-38872398" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#38870225">root</a><span>|</span><a href="#38872274">parent</a><span>|</span><a href="#38872165">next</a><span>|</span><label class="collapse" for="c-38872398">[-]</label><label class="expand" for="c-38872398">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. Locking the rows or using serializable isolation would be required to achieve an atomic operation if and only if both accounts are in the pristine state before it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38872165" class="c"><input type="checkbox" id="c-38872165" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#38870225">prev</a><span>|</span><a href="#38874366">next</a><span>|</span><label class="collapse" for="c-38872165">[-]</label><label class="expand" for="c-38872165">[8 more]</label></div><br/><div class="children"><div class="content">Generally, for a lot of application usage patterns, <i>read committed</i> is the default for a reason.<p>From the Postgres docs:<p>&gt; <i>The partial transaction isolation provided by Read Committed level is adequate for many applications, and this level is fast and simple to use. However, for applications that do complex queries and updates, it may be necessary to guarantee a more rigorously consistent view of the database than the Read Committed level provides.</i><p>Also, consider storing the transactions that change the balances (credits, debits, etc) in a ledger and calculate the balance. You can avoid the complex update logic and keep your accountants and auditors happy.<p>Stricter isolation levels are useful but have a lot of trade-offs to be aware of.<p>Sometimes restructuring your data is a lot more effective than trying to reason about locks and concurrency. The more locks you have to more points of contention, dead locks, etc you have to be concerned about. Humans and general rules&#x2F;folklore are alright at avoiding some mistakes but these systems get complicated quickly and can hide a surprising number of errors.<p>As for testing these things, I&#x27;ve gotten a lot of good mileage out of model checking. TLA+ and Alloy are better at finding concurrency errors than I am at avoiding them.</div><br/><div id="38872801" class="c"><input type="checkbox" id="c-38872801" checked=""/><div class="controls bullet"><span class="by">karamanolev</span><span>|</span><a href="#38872165">parent</a><span>|</span><a href="#38873040">next</a><span>|</span><label class="collapse" for="c-38872801">[-]</label><label class="expand" for="c-38872801">[3 more]</label></div><br/><div class="children"><div class="content">Can you recommended a good article that goes over the ledger pattern (the easy part) and the performant calculation of balances as the ledger grows? I&#x27;m going to start working on a warehouse management system in the coming months and that would come in handy.</div><br/><div id="38872993" class="c"><input type="checkbox" id="c-38872993" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#38872165">root</a><span>|</span><a href="#38872801">parent</a><span>|</span><a href="#38876362">next</a><span>|</span><label class="collapse" for="c-38872993">[-]</label><label class="expand" for="c-38872993">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a link but when I&#x27;ve implemented systems with a &quot;ledger&quot; of changes I would have a field that indicated whether the ledger item had been &quot;posted&quot; to the the affected account(s) and therefore the balance was just the account balance +&#x2F;- any unposted ledger items.<p>I&#x27;ve had ledgers that were posted once a day, or more often, up to nearly real-time.<p>But once a ledger item is posted, it should never be changed. If an error is discovered, make a new ledger entry to correct it.</div><br/></div></div><div id="38876362" class="c"><input type="checkbox" id="c-38876362" checked=""/><div class="controls bullet"><span class="by">moring</span><span>|</span><a href="#38872165">root</a><span>|</span><a href="#38872801">parent</a><span>|</span><a href="#38872993">prev</a><span>|</span><a href="#38873040">next</a><span>|</span><label class="collapse" for="c-38876362">[-]</label><label class="expand" for="c-38876362">[1 more]</label></div><br/><div class="children"><div class="content">The pattern in general is called &quot;event sourcing&quot;, but unfortunately it&#x27;s popular enough to make a lot of bad articles appear, and I can&#x27;t recommend a good one.</div><br/></div></div></div></div><div id="38873040" class="c"><input type="checkbox" id="c-38873040" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#38872165">parent</a><span>|</span><a href="#38872801">prev</a><span>|</span><a href="#38874366">next</a><span>|</span><label class="collapse" for="c-38873040">[-]</label><label class="expand" for="c-38873040">[4 more]</label></div><br/><div class="children"><div class="content">How can you store ledger operations without locking on the balance? The race condition still exists - you can&#x27;t accept a withdrawal if the user doesn&#x27;t have enough funds.</div><br/><div id="38876877" class="c"><input type="checkbox" id="c-38876877" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#38872165">root</a><span>|</span><a href="#38873040">parent</a><span>|</span><a href="#38873157">next</a><span>|</span><label class="collapse" for="c-38876877">[-]</label><label class="expand" for="c-38876877">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can&#x27;t accept a withdrawal if the user doesn&#x27;t have enough funds.<p>You can.<p>ATMs around the country aren&#x27;t doing account-level locking.  If you overdraw, you overdraw.<p>If you store the ledger operations (reliably! no half-writing them and then throwing an exception!), then your system <i>knows what happened</i>.<p>Having a ledger which you&#x27;re confident about is more important than trying to use exceptions to prevent &#x27;bad&#x27; ledger messages being written.</div><br/></div></div><div id="38873157" class="c"><input type="checkbox" id="c-38873157" checked=""/><div class="controls bullet"><span class="by">stetrain</span><span>|</span><a href="#38872165">root</a><span>|</span><a href="#38873040">parent</a><span>|</span><a href="#38876877">prev</a><span>|</span><a href="#38874366">next</a><span>|</span><label class="collapse" for="c-38873157">[-]</label><label class="expand" for="c-38873157">[2 more]</label></div><br/><div class="children"><div class="content">You can use some sort of concurrency index on the ledger.<p>For example you read the ledger entries for Account Id X<p>Those ledger entries are numbered sequentially up to the current index Y<p>You calculate the current balance, approve the withdrawal, and try to insert the next ledger entry as Y + 1<p>If another operation has already inserted a Y + 1 your insert fails and you throw an error or try again, starting with the new ledger state and balance.<p>Basically optimistic concurrency but knowing that you are always appending to the ledger and that the index is always incrementing.</div><br/><div id="38874705" class="c"><input type="checkbox" id="c-38874705" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#38872165">root</a><span>|</span><a href="#38873157">parent</a><span>|</span><a href="#38874366">next</a><span>|</span><label class="collapse" for="c-38874705">[-]</label><label class="expand" for="c-38874705">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, consider storing the transactions that change the balances (credits, debits, etc) in a ledger and calculate the balance. You can avoid the complex update logic and keep your accountants and auditors happy.<p>This was written (to me) as if using a ledger alone would get rid of the race conditions caused by the read committed isolation level.<p>But what you described is manually implementing locking, which requires additional schema and application logic.</div><br/></div></div></div></div></div></div></div></div><div id="38874366" class="c"><input type="checkbox" id="c-38874366" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38872165">prev</a><span>|</span><a href="#38870132">next</a><span>|</span><label class="collapse" for="c-38874366">[-]</label><label class="expand" for="c-38874366">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that thinking about testing this isn&#x27;t really worthwhile. Just change isolation level. It&#x27;s not terribly slow. Your work is now much easier.</div><br/><div id="38876752" class="c"><input type="checkbox" id="c-38876752" checked=""/><div class="controls bullet"><span class="by">emergie</span><span>|</span><a href="#38874366">parent</a><span>|</span><a href="#38870132">next</a><span>|</span><label class="collapse" for="c-38876752">[-]</label><label class="expand" for="c-38876752">[1 more]</label></div><br/><div class="children"><div class="content">Serialized usually is prohibitively slow in case where there are more than few concurrent users.</div><br/></div></div></div></div><div id="38870132" class="c"><input type="checkbox" id="c-38870132" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38874366">prev</a><span>|</span><a href="#38870545">next</a><span>|</span><label class="collapse" for="c-38870132">[-]</label><label class="expand" for="c-38870132">[9 more]</label></div><br/><div class="children"><div class="content">I knew of this issue for some time (default DB isolation is less than SERIALIZABLE on most DB).<p>But assuming you do not want to change the default isolation for your transaction or for the whole DB. 
How do you write unit-test that check your code will work correctly because it&#x27;s using &quot;select balance from accounts FOR UPDATE&quot;?<p>It seem to me the only way to really validate this is using tool like TLA+.
Or something like <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote</a></div><br/><div id="38870777" class="c"><input type="checkbox" id="c-38870777" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#38870132">parent</a><span>|</span><a href="#38871122">next</a><span>|</span><label class="collapse" for="c-38870777">[-]</label><label class="expand" for="c-38870777">[4 more]</label></div><br/><div class="children"><div class="content">The issue is that the race condition exists in the database, not in any application code. So you can either simulate the race, or you need to integration test, and that&#x27;s outside the scope of TLA+ and model checking.<p>I haven&#x27;t heard of Coyote (it&#x27;s still amazing how many tools are out there). It&#x27;s good that it operates on the actual code level, but I&#x27;m still not sure that would reproduce concurrency non-determinism at the database level.</div><br/><div id="38870994" class="c"><input type="checkbox" id="c-38870994" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38870132">root</a><span>|</span><a href="#38870777">parent</a><span>|</span><a href="#38871122">next</a><span>|</span><label class="collapse" for="c-38870994">[-]</label><label class="expand" for="c-38870994">[3 more]</label></div><br/><div class="children"><div class="content">yes if your test are using a mock of the db
ex: <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote&#x2F;blob&#x2F;main&#x2F;Samples&#x2F;AccountManager&#x2F;AccountManager&#x2F;InMemoryDbCollection.cs">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote&#x2F;blob&#x2F;main&#x2F;Samples&#x2F;Accoun...</a>
you can simulate the races.<p>The problem is your mock need to implement the same isolation level as your real DB  and support transaction ...<p>You could use SQLITE in memory DB to run your test but that would make your test a lot slower I assume.</div><br/><div id="38876413" class="c"><input type="checkbox" id="c-38876413" checked=""/><div class="controls bullet"><span class="by">sophiabits</span><span>|</span><a href="#38870132">root</a><span>|</span><a href="#38870994">parent</a><span>|</span><a href="#38871049">next</a><span>|</span><label class="collapse" for="c-38876413">[-]</label><label class="expand" for="c-38876413">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that you don’t really know if your mock accurately implements the behavior of the database. The only way you could verify the mock behaves correctly would be to run the mock and a real database instance through a set of tests to verify they both implement different isolation levels identically.<p>At that point—why bother with the mock at all? Cutting out the intermediary and running integration tests of your application against a real database will be faster.<p>You can’t use SQLite here either because all SQLite isolation levels are serializable anyway, which is _very_ different from how PostgreSQL works. Testing against SQLite could end up giving you a false sense of security that your code is safe against race conditions, whereas in reality it’s vulnerable when connected to a PostgreSQL server because of the difference in default isolation levels<p>At this level of testing detail the only real option is to test against a real database that matches what you’re running in production. Otherwise you’re just testing a mock.</div><br/></div></div><div id="38871049" class="c"><input type="checkbox" id="c-38871049" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#38870132">root</a><span>|</span><a href="#38870994">parent</a><span>|</span><a href="#38876413">prev</a><span>|</span><a href="#38871122">next</a><span>|</span><label class="collapse" for="c-38871049">[-]</label><label class="expand" for="c-38871049">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, it&#x27;s a tricky problem. Implementing all transaction isolation levels in a mock is quite an ambitious endeavor.</div><br/></div></div></div></div></div></div><div id="38871122" class="c"><input type="checkbox" id="c-38871122" checked=""/><div class="controls bullet"><span class="by">mrloba</span><span>|</span><a href="#38870132">parent</a><span>|</span><a href="#38870777">prev</a><span>|</span><a href="#38870156">next</a><span>|</span><label class="collapse" for="c-38871122">[-]</label><label class="expand" for="c-38871122">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not perfect, but I have had success running postgres in Docker and running integration tests against that. Usually you can trigger the problem by running a handful of queries in parallel.</div><br/><div id="38871207" class="c"><input type="checkbox" id="c-38871207" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#38870132">root</a><span>|</span><a href="#38871122">parent</a><span>|</span><a href="#38871499">next</a><span>|</span><label class="collapse" for="c-38871207">[-]</label><label class="expand" for="c-38871207">[1 more]</label></div><br/><div class="children"><div class="content">Yes exactly. That&#x27;s the approach taken here. The main downside is that it can require sleeps to properly reproduce race conditions.</div><br/></div></div><div id="38871499" class="c"><input type="checkbox" id="c-38871499" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38870132">root</a><span>|</span><a href="#38871122">parent</a><span>|</span><a href="#38871207">prev</a><span>|</span><a href="#38870156">next</a><span>|</span><label class="collapse" for="c-38871499">[-]</label><label class="expand" for="c-38871499">[1 more]</label></div><br/><div class="children"><div class="content">this is the current setup we use in my team but I am trying to move away for this to something more systematic.</div><br/></div></div></div></div><div id="38870156" class="c"><input type="checkbox" id="c-38870156" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38870132">parent</a><span>|</span><a href="#38871122">prev</a><span>|</span><a href="#38870545">next</a><span>|</span><label class="collapse" for="c-38870156">[-]</label><label class="expand" for="c-38870156">[1 more]</label></div><br/><div class="children"><div class="content">Even using tool like this it seem to be a combinatorial explosion issue.<p>If your app contain 10 distinct transactions.<p>you have to test what happen if 2 instances of  tx #1 run concurrently.<p>But also  if tx #1 and tx #2 run concurrently.<p>And also what if tx #1 and tx #3 run concurrently ....</div><br/></div></div></div></div><div id="38870545" class="c"><input type="checkbox" id="c-38870545" checked=""/><div class="controls bullet"><span class="by">trhway</span><span>|</span><a href="#38870132">prev</a><span>|</span><label class="collapse" for="c-38870545">[-]</label><label class="expand" for="c-38870545">[10 more]</label></div><br/><div class="children"><div class="content">&gt;Hopefully it’s clear why this is an issue. If you have an important column value, say a user’s account balance, you might query multiple different values in the same transaction<p>and that is a feature, not a bug. During your transaction user withdrew money from his account. If you wanna see the same value, i.e. block that user from withdrawals while you process his current balance, you take a lock on that row. Similar in many ways to the concurrent programming with threads.</div><br/><div id="38870592" class="c"><input type="checkbox" id="c-38870592" checked=""/><div class="controls bullet"><span class="by">aphyr</span><span>|</span><a href="#38870545">parent</a><span>|</span><a href="#38871726">next</a><span>|</span><label class="collapse" for="c-38870592">[-]</label><label class="expand" for="c-38870592">[3 more]</label></div><br/><div class="children"><div class="content">The point of isolation levels is that the database manages those locks (or other concurrency control mechanisms) for you.</div><br/><div id="38870742" class="c"><input type="checkbox" id="c-38870742" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#38870545">root</a><span>|</span><a href="#38870592">parent</a><span>|</span><a href="#38870902">next</a><span>|</span><label class="collapse" for="c-38870742">[-]</label><label class="expand" for="c-38870742">[1 more]</label></div><br/><div class="children"><div class="content">Bearing in mind that “handling” the locks may mean a deadlock is detected and the transaction is aborted by the DB, which the application has to handle by retrying in a correct manner. (Which is another point often missed in naive application code.)</div><br/></div></div><div id="38870902" class="c"><input type="checkbox" id="c-38870902" checked=""/><div class="controls bullet"><span class="by">trhway</span><span>|</span><a href="#38870545">root</a><span>|</span><a href="#38870592">parent</a><span>|</span><a href="#38870742">prev</a><span>|</span><a href="#38871726">next</a><span>|</span><label class="collapse" for="c-38870902">[-]</label><label class="expand" for="c-38870902">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly - the database doesn&#x27;t know whether you want to block that account update or not. So, speaking very roughly, it allows you to choose general level of such a blocking behavior. It manages those locks, very coarse, at serializable and some of those locks at repeatable read. At read committed it manages basically only small set of locks just to avoid dirty reads (plus of course all the WAL&#x2F;rollback&#x2F;etc. which is the main features and the point of the database with the isolation levels being just the icing on that cake). Isolation levels is a tool, and you choose what is needed and suitable.<p>The serializable actually is a pain in the neck for any meaningfully serious large enterprise application. The decreased concurrency kills overall performance, and I haven&#x27;t seen any such application running in serializable (and for example at my current job our customers are running our application on  servers with low tens of TB RAM (largest so far was 40TB RAM) per single machine with high hundreds of cores with thousands of users - in serializable that would slow to a crawl as it wouldn&#x27;t allow to achieve the concurrency the database on those machines is otherwise capable of). While not precise illustration it still communicates my point - the serializable against read committed is like the global Python lock against the fine grained locks in normal languages.</div><br/></div></div></div></div><div id="38871726" class="c"><input type="checkbox" id="c-38871726" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#38870545">parent</a><span>|</span><a href="#38870592">prev</a><span>|</span><label class="collapse" for="c-38871726">[-]</label><label class="expand" for="c-38871726">[6 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re storing a balance, rather than a ledger of the transactions which caused that balance to be the case, you&#x27;re probably already off to a bad start when it comes to design.<p>Just imagine if you called your bank and asked them why my balance was $500, and they said &quot;I don&#x27;t know, hit F5 and see if it changes&quot;...</div><br/><div id="38872512" class="c"><input type="checkbox" id="c-38872512" checked=""/><div class="controls bullet"><span class="by">allknowingfrog</span><span>|</span><a href="#38870545">root</a><span>|</span><a href="#38871726">parent</a><span>|</span><a href="#38871956">next</a><span>|</span><label class="collapse" for="c-38872512">[-]</label><label class="expand" for="c-38872512">[3 more]</label></div><br/><div class="children"><div class="content">I briefly dabbled in financial ledgers in a previous job. We made plans to do what you seem to be describing, which is to store the transactions themselves and calculate a balance as needed, but we frankly lacked expertise. I always wondered what would happen if we scaled to millions of transactions in that system.<p>Is there a standard strategy for optimizing balance queries against a series of transactions? I assumed that we would eventually have to cache some kind of snapshot for each account to avoid the overhead of totaling every transaction on every balance check.</div><br/><div id="38876927" class="c"><input type="checkbox" id="c-38876927" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#38870545">root</a><span>|</span><a href="#38872512">parent</a><span>|</span><a href="#38875034">next</a><span>|</span><label class="collapse" for="c-38876927">[-]</label><label class="expand" for="c-38876927">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there a standard strategy for optimizing balance queries against a series of transactions?<p>Nope!<p>But it&#x27;s not terribly hard to design something.<p>I demote the DB down to a caching layer, and promote the ledger as the source of truth.  All writes are appended to the ledger.  Something listens to the ledger and updates the DB.  Reads are against the DB.</div><br/></div></div><div id="38875034" class="c"><input type="checkbox" id="c-38875034" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#38870545">root</a><span>|</span><a href="#38872512">parent</a><span>|</span><a href="#38876927">prev</a><span>|</span><a href="#38871956">next</a><span>|</span><label class="collapse" for="c-38875034">[-]</label><label class="expand" for="c-38875034">[1 more]</label></div><br/><div class="children"><div class="content">There are quite a few standards - &quot;closing the books&quot; on some period (monthly, daily, hourly, depending on volume&#x2F;regulatory requirements) is usually the way.<p>There&#x27;s also a good, sadly now out of print, book named &quot;Analysis Patterns&quot; by Martin Fowler which has a large section about account representation strategies from an object modelling perspective which also translates reasonably well to functional programming.<p>It&#x27;s annoying it&#x27;s out of print, since it contains timeless information rather than the fad-du-jour!</div><br/></div></div></div></div><div id="38871956" class="c"><input type="checkbox" id="c-38871956" checked=""/><div class="controls bullet"><span class="by">gav</span><span>|</span><a href="#38870545">root</a><span>|</span><a href="#38871726">parent</a><span>|</span><a href="#38872512">prev</a><span>|</span><label class="collapse" for="c-38871956">[-]</label><label class="expand" for="c-38871956">[2 more]</label></div><br/><div class="children"><div class="content">When it comes to this topic, almost all examples don&#x27;t match how things work in the real world where they are eventually consistent.<p>For example, my bank lets me go negative and then if I don&#x27;t settle by the end of the day, overdraft protection will kick in for a little more than that negative amount.</div><br/><div id="38875050" class="c"><input type="checkbox" id="c-38875050" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#38870545">root</a><span>|</span><a href="#38871956">parent</a><span>|</span><label class="collapse" for="c-38875050">[-]</label><label class="expand" for="c-38875050">[1 more]</label></div><br/><div class="children"><div class="content">Indeed - seeing account balance used as an example of database transactions is a red flag to me, and would absolutely cause me to dig deeper into whether the author&#x2F;speaker understands how banking actually works.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>