<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689757254306" as="style"/><link rel="stylesheet" href="styles.css?v=1689757254306"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.val-lang.dev/">Val, a high-level systems programming language</a> <span class="domain">(<a href="https://www.val-lang.dev">www.val-lang.dev</a>)</span></div><div class="subtext"><span>cpeterso</span> | <span>203 comments</span></div><br/><div><div id="36779119" class="c"><input type="checkbox" id="c-36779119" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#36780663">next</a><span>|</span><label class="collapse" for="c-36779119">[-]</label><label class="expand" for="c-36779119">[55 more]</label></div><br/><div class="children"><div class="content">I might actually be more excited about Val as a C++ successor than I am about Herb Sutter&#x27;s excellent CppFront...  Admittedly, all I know about it is from the two presentations below. But, from what I can tell...<p>Statically compiled. Statically typed. Interops with C++. Memory safe. Typesafe. Data-race-free.<p>The elevator pitch I give when describing it goes like this:  Imagine you were starting a new C++ project and didn&#x27;t really care about performance (spoiler: perf comes back in the end). So, you decide to not bother using pointers or references anywhere.  You just pass by value, return by value everywhere, all day long.  If you ignored the obvious perf problems of passing around maps of vectors of objects by value, wouldn&#x27;t it be nice?  you don&#x27;t have to worry about side effects or data races or anything. And yet, the data is not immutable. You can go ahead and mutate it all you want worry-free because the data is all completely local to your function.<p>Well, turns out the Val folks have figured out that by eliminating pointers and references from the language, the can get the compiler to automatically pass-by-const-reference and return-value-optimization under the hood such that it preserves both the performance and the semantics that you want at the same time.<p>Val: A Safe Language to Interoperate with C++ - Dimitri Racordon - CppCon 2022 <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ws-Z8xKbP4w">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ws-Z8xKbP4w</a><p><a href="https:&#x2F;&#x2F;cppcast.com&#x2F;val-and-mutable-value-semantics&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;cppcast.com&#x2F;val-and-mutable-value-semantics&#x2F;</a></div><br/><div id="36782080" class="c"><input type="checkbox" id="c-36782080" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36779165">next</a><span>|</span><label class="collapse" for="c-36782080">[-]</label><label class="expand" for="c-36782080">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Interops with C++<p>Doubt. I simply don&#x27;t believe any other language out there is capable of interoperating with C++. Even C++ compilers have broken binary compatibility, different versions of the same compiler even.</div><br/></div></div><div id="36779165" class="c"><input type="checkbox" id="c-36779165" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36782080">prev</a><span>|</span><a href="#36779540">next</a><span>|</span><label class="collapse" for="c-36779165">[-]</label><label class="expand" for="c-36779165">[1 more]</label></div><br/><div class="children"><div class="content">Listen to the last two episodes of ADSP Podcast with Sean Parent, regarding Val.<p>Adobe Research labs is seriously sponsoring its development.<p><a href="https:&#x2F;&#x2F;adspthepodcast.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;adspthepodcast.com&#x2F;</a></div><br/></div></div><div id="36779540" class="c"><input type="checkbox" id="c-36779540" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36779165">prev</a><span>|</span><a href="#36780477">next</a><span>|</span><label class="collapse" for="c-36779540">[-]</label><label class="expand" for="c-36779540">[15 more]</label></div><br/><div class="children"><div class="content">Sounds like we&#x27;re trusting a lot to the compiler. Will this lead to me making a small change which breaks an optimization in some distant code and ruins performance?</div><br/><div id="36779747" class="c"><input type="checkbox" id="c-36779747" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779540">parent</a><span>|</span><a href="#36779678">next</a><span>|</span><label class="collapse" for="c-36779747">[-]</label><label class="expand" for="c-36779747">[11 more]</label></div><br/><div class="children"><div class="content">Maybe we should tell the compiler somehow that we don&#x27;t want to pass a value, but a reference. For example we could use a * or a &amp; symbol.</div><br/><div id="36780334" class="c"><input type="checkbox" id="c-36780334" checked=""/><div class="controls bullet"><span class="by">havnagiggle</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779747">parent</a><span>|</span><a href="#36779678">next</a><span>|</span><label class="collapse" for="c-36780334">[-]</label><label class="expand" for="c-36780334">[10 more]</label></div><br/><div class="children"><div class="content">Wait for the blog post on how beautiful Val++ is.</div><br/><div id="36780687" class="c"><input type="checkbox" id="c-36780687" checked=""/><div class="controls bullet"><span class="by">zen_1</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780334">parent</a><span>|</span><a href="#36779678">next</a><span>|</span><label class="collapse" for="c-36780687">[-]</label><label class="expand" for="c-36780687">[9 more]</label></div><br/><div class="children"><div class="content">Val&lt;&lt;&gt;&gt; when they inevitably introduce templates and stringstreams</div><br/><div id="36782485" class="c"><input type="checkbox" id="c-36782485" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780687">parent</a><span>|</span><a href="#36781063">next</a><span>|</span><label class="collapse" for="c-36782485">[-]</label><label class="expand" for="c-36782485">[1 more]</label></div><br/><div class="children"><div class="content">Better write it like `Val&lt; &lt;&gt; &gt;` otherwise the parser will get confused.</div><br/></div></div><div id="36781063" class="c"><input type="checkbox" id="c-36781063" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780687">parent</a><span>|</span><a href="#36782485">prev</a><span>|</span><a href="#36779678">next</a><span>|</span><label class="collapse" for="c-36781063">[-]</label><label class="expand" for="c-36781063">[7 more]</label></div><br/><div class="children"><div class="content">In 2028, when we revive the One True Programming Paradigm (for Enterprise Software)™, we&#x27;ll have bestowed upon us the glorious Objective-Val</div><br/><div id="36781542" class="c"><input type="checkbox" id="c-36781542" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781063">parent</a><span>|</span><a href="#36781109">next</a><span>|</span><label class="collapse" for="c-36781542">[-]</label><label class="expand" for="c-36781542">[5 more]</label></div><br/><div class="children"><div class="content">In 2028, we will still be writing code in C and Fortran. And there will be all these new languages X++ that would be promising to replace either or both ;) ;) ;)</div><br/><div id="36782455" class="c"><input type="checkbox" id="c-36782455" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781542">parent</a><span>|</span><a href="#36781109">next</a><span>|</span><label class="collapse" for="c-36782455">[-]</label><label class="expand" for="c-36782455">[4 more]</label></div><br/><div class="children"><div class="content">X++ already exists, better pick another name.<p>EDIT: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dynamicsax-2012&#x2F;developer&#x2F;x-language-programming-guide" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dynamicsax-2012&#x2F;developer&#x2F;...</a></div><br/><div id="36782653" class="c"><input type="checkbox" id="c-36782653" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36782455">parent</a><span>|</span><a href="#36781109">next</a><span>|</span><label class="collapse" for="c-36782653">[-]</label><label class="expand" for="c-36782653">[3 more]</label></div><br/><div class="children"><div class="content">Swift++, or Swifttt.</div><br/><div id="36783501" class="c"><input type="checkbox" id="c-36783501" checked=""/><div class="controls bullet"><span class="by">vogon_laureate</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36782653">parent</a><span>|</span><a href="#36782917">next</a><span>|</span><label class="collapse" for="c-36783501">[-]</label><label class="expand" for="c-36783501">[1 more]</label></div><br/><div class="children"><div class="content">Taylor Swift’s subject-oriented programming language – Swifties.<p>It would have:
  • garbage collection (<i>Shake It Off</i>)
  • error correction (<i>Bad Blood</i>)
  • closures (<i>Closure</i>)
  • optionals (<i>Would’ve, Could’ve, Should’ve</i>)
  • automatic reference counting (<i>Right Where You Left Me</i>)
  • REPL (<i>I Knew You Were Trouble</i>)
  • variable mutability (<i>Everything Has Changed</i> and <i>Evermore</i>)
  • guard condition (<i>Eyes Open</i>)
  • strict typing (<i>You Belong With Me</i>)<p>After compiling run the binary by issuing the command: <i>Run</i> {filename}<p>To debug: <i>Tell Me Why</i> {filename}</div><br/></div></div><div id="36782917" class="c"><input type="checkbox" id="c-36782917" checked=""/><div class="controls bullet"><span class="by">phatskat</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36782653">parent</a><span>|</span><a href="#36783501">prev</a><span>|</span><a href="#36781109">next</a><span>|</span><label class="collapse" for="c-36782917">[-]</label><label class="expand" for="c-36782917">[1 more]</label></div><br/><div class="children"><div class="content">Petition to change all languages with “+” to repeat the last character for each plus. Going down the list of languages on Wikipedia[0]<p>A+ becomes AA
C++ = CCC
Clik++ never mind this was a bad call. 
JJJ
RRR
Visual JJJ
XXX (nice)
xBaseee
ZZZ<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_programming_languages" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_programming_languages</a></div><br/></div></div></div></div></div></div></div></div><div id="36781109" class="c"><input type="checkbox" id="c-36781109" checked=""/><div class="controls bullet"><span class="by">cellularmitosis</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781063">parent</a><span>|</span><a href="#36781542">prev</a><span>|</span><a href="#36779678">next</a><span>|</span><label class="collapse" for="c-36781109">[-]</label><label class="expand" for="c-36781109">[1 more]</label></div><br/><div class="children"><div class="content">Might have a future in mobile.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36779678" class="c"><input type="checkbox" id="c-36779678" checked=""/><div class="controls bullet"><span class="by">swsieber</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779540">parent</a><span>|</span><a href="#36779747">prev</a><span>|</span><a href="#36780477">next</a><span>|</span><label class="collapse" for="c-36779678">[-]</label><label class="expand" for="c-36779678">[3 more]</label></div><br/><div class="children"><div class="content">I believe rust is sort of similar in that apart from the references, it&#x27;s very heavy on the move semantics. And IIRC, sometimes it&#x27;s doing extra memcpys. But I don&#x27;t know if Rust is explicitly targeting const reference passing.<p>That said, if you&#x27;re all in on it I imagine that the front-end could pretty aggressively target that, much like how rust uses no alias.</div><br/><div id="36780841" class="c"><input type="checkbox" id="c-36780841" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779678">parent</a><span>|</span><a href="#36780477">next</a><span>|</span><label class="collapse" for="c-36780841">[-]</label><label class="expand" for="c-36780841">[2 more]</label></div><br/><div class="children"><div class="content">By default, non-references in Rust are passed by move, although you can derive `Clone` on types composed of all `Clone` types and then explicitly call the `.clone()` method to copy things. The only types that will be copied by default are the ones that implement `Copy` in addition to `Clone`, which in the standard library is on primitives like integers and characters but overall is used fairly sparingly.<p>References need to be specified as mutable if mutation is needed (i.e. `&amp;mut T` instead of just `&amp;T`). Using immutable references is also encouraged from the borrow checking rules; having a second reference (either mutable or immutable) alive at the same time as a mutable one is a compiler error, but using multiple immutable references at the same time is fine. (Pointers are the same way, but not really used much outside of bridging with unsafe Rust, since they can be null and therefore can&#x27;t be dereferenced outside of `unsafe` blocks).</div><br/><div id="36782692" class="c"><input type="checkbox" id="c-36782692" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780841">parent</a><span>|</span><a href="#36780477">next</a><span>|</span><label class="collapse" for="c-36782692">[-]</label><label class="expand" for="c-36782692">[1 more]</label></div><br/><div class="children"><div class="content">I think OP was referring to the fact that implementation of moves can sometime (more often than desired I would add) do memcpys. e.g. if you have a struct of ~100 bytes and you move it, it will probably emit a memcpy to write it in the receiving function&#x27;s stack. AFAIK this happens because addresses are kinda considered observable, and not doing these copies could thus be observable and potentially break some weird code. I don&#x27;t think Val would have the exact same problem because it doesn&#x27;t have the concept of addresses&#x2F;pointers.</div><br/></div></div></div></div></div></div></div></div><div id="36780477" class="c"><input type="checkbox" id="c-36780477" checked=""/><div class="controls bullet"><span class="by">yeputons</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36779540">prev</a><span>|</span><a href="#36779335">next</a><span>|</span><label class="collapse" for="c-36780477">[-]</label><label class="expand" for="c-36780477">[7 more]</label></div><br/><div class="children"><div class="content">&gt; You just pass by value, return by value everywhere, all day long.<p>I cannot efficiently mutate or even store references in structs anymore. That seems to be a show-stopper if you want to have any non-trivial or non-standard data structures in the program. Granted, they are hard to get right, so maybe it&#x27;s a feature.</div><br/><div id="36781085" class="c"><input type="checkbox" id="c-36781085" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780477">parent</a><span>|</span><a href="#36780603">next</a><span>|</span><label class="collapse" for="c-36781085">[-]</label><label class="expand" for="c-36781085">[4 more]</label></div><br/><div class="children"><div class="content">I just learned about Val today, but Rust has similar constraints. To write to a particular variable requires having ownership or a mutable reference, which only one part of the program can have at once. Since you can&#x27;t have two mutable references in different parts of the program or in different threads, you need some sort of atomic encapsulating data structure to mediate access. Something like a mutex.<p>Newbies to Rust have a lot of trouble learning how to get the borrow-checker to accept their code, but what these restrictions are doing is syntactically ensuring there are no deadlocks or data races. It is presumably a similar story with Val.<p>If Val actually handles this differently, I&#x27;d love to know.</div><br/><div id="36782800" class="c"><input type="checkbox" id="c-36782800" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781085">parent</a><span>|</span><a href="#36782413">next</a><span>|</span><label class="collapse" for="c-36782800">[-]</label><label class="expand" for="c-36782800">[2 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s borrow checker can prevent data races, but it can&#x27;t prevent deadlocks.<p>The Pony language has something analogous to Rust&#x27;s ownership system (there it&#x27;s called reference capabilities [0]), but in addition to that Pony prevents deadlocks too [1]. It does so by not providing locks, but only providing actors with message passing (channels). Now, Pony is a much higher level language and unsuitable for some of the low level stuff that Rust does.<p>If you restrict your Rust program to not use locks, but just send messages through channels between threads [2], you won&#x27;t have deadlocks either. But that&#x27;s quite a handicap for a low level systems language, so Rust in general can&#x27;t commit to that.<p>[0] <a href="https:&#x2F;&#x2F;tutorial.ponylang.io&#x2F;reference-capabilities&#x2F;reference-capabilities.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;tutorial.ponylang.io&#x2F;reference-capabilities&#x2F;referenc...</a><p>[1] <a href="https:&#x2F;&#x2F;www.ponylang.io&#x2F;discover&#x2F;#what-makes-pony-different" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ponylang.io&#x2F;discover&#x2F;#what-makes-pony-different</a><p>[2] If you would rather prefer to write async code, there are async channels too, but to be deadlock-free you need to always guarantee that your futures are polled <a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;wg-async&#x2F;vision&#x2F;submitted_stories&#x2F;status_quo&#x2F;aws_engineer&#x2F;solving_a_deadlock.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;wg-async&#x2F;vision&#x2F;submitted_storie...</a> which is maybe a strange requirement that&#x27;s alien to most languages</div><br/><div id="36783195" class="c"><input type="checkbox" id="c-36783195" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36782800">parent</a><span>|</span><a href="#36782413">next</a><span>|</span><label class="collapse" for="c-36783195">[-]</label><label class="expand" for="c-36783195">[1 more]</label></div><br/><div class="children"><div class="content">You can trivially deadlock just with queues and messaging.</div><br/></div></div></div></div><div id="36782413" class="c"><input type="checkbox" id="c-36782413" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781085">parent</a><span>|</span><a href="#36782800">prev</a><span>|</span><a href="#36780603">next</a><span>|</span><label class="collapse" for="c-36782413">[-]</label><label class="expand" for="c-36782413">[1 more]</label></div><br/><div class="children"><div class="content">Rust can prevent races, but generally speaking it cannot catch deadlocks.</div><br/></div></div></div></div><div id="36780603" class="c"><input type="checkbox" id="c-36780603" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780477">parent</a><span>|</span><a href="#36781085">prev</a><span>|</span><a href="#36779335">next</a><span>|</span><label class="collapse" for="c-36780603">[-]</label><label class="expand" for="c-36780603">[2 more]</label></div><br/><div class="children"><div class="content">It seems you would have to use the `unsafe` escape hatch for data structures such as linked lists, and externally verify that the implementation is correct. Which is better than the status quo of C++ where you are always in needed of externally verifying safety.<p>As for the safety mechanisms discouraging non-standard data structures, the language designers probably would consider that a feature, rather than a bug.<p>I am curious whether the use of a broken unsafe construct can break the safety guarantees of safe constructs, or if the unsafety is contained no matter what.</div><br/><div id="36782422" class="c"><input type="checkbox" id="c-36782422" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780603">parent</a><span>|</span><a href="#36779335">next</a><span>|</span><label class="collapse" for="c-36782422">[-]</label><label class="expand" for="c-36782422">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;safe-unsafe-meaning.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;safe-unsafe-meaning.html</a></div><br/></div></div></div></div></div></div><div id="36779335" class="c"><input type="checkbox" id="c-36779335" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36780477">prev</a><span>|</span><a href="#36779204">next</a><span>|</span><label class="collapse" for="c-36779335">[-]</label><label class="expand" for="c-36779335">[8 more]</label></div><br/><div class="children"><div class="content">c++ interop always seems like some sort of magic power, given how few languages achieve it.</div><br/><div id="36780874" class="c"><input type="checkbox" id="c-36780874" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779335">parent</a><span>|</span><a href="#36781291">next</a><span>|</span><label class="collapse" for="c-36780874">[-]</label><label class="expand" for="c-36780874">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, I don&#x27;t think even C++ is very good at C++ interop.</div><br/></div></div><div id="36781291" class="c"><input type="checkbox" id="c-36781291" checked=""/><div class="controls bullet"><span class="by">Scarbutt</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779335">parent</a><span>|</span><a href="#36780874">prev</a><span>|</span><a href="#36779204">next</a><span>|</span><label class="collapse" for="c-36781291">[-]</label><label class="expand" for="c-36781291">[6 more]</label></div><br/><div class="children"><div class="content">What language has C++ interop?</div><br/><div id="36781431" class="c"><input type="checkbox" id="c-36781431" checked=""/><div class="controls bullet"><span class="by">nicwilson</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781291">parent</a><span>|</span><a href="#36781661">next</a><span>|</span><label class="collapse" for="c-36781431">[-]</label><label class="expand" for="c-36781431">[1 more]</label></div><br/><div class="children"><div class="content">D does. Not source compatible, but mangling and ABI for linking. And D can generate headers for `extern(C++)` declarations defined in D</div><br/></div></div><div id="36781661" class="c"><input type="checkbox" id="c-36781661" checked=""/><div class="controls bullet"><span class="by">macshome</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781291">parent</a><span>|</span><a href="#36781431">prev</a><span>|</span><a href="#36781636">next</a><span>|</span><label class="collapse" for="c-36781661">[-]</label><label class="expand" for="c-36781661">[1 more]</label></div><br/><div class="children"><div class="content">Swift just added C++ interop in version 5.9. <a href="https:&#x2F;&#x2F;forums.swift.org&#x2F;t&#x2F;c-interoperability-in-swift-5-9&#x2F;65369" rel="nofollow noreferrer">https:&#x2F;&#x2F;forums.swift.org&#x2F;t&#x2F;c-interoperability-in-swift-5-9&#x2F;6...</a></div><br/></div></div><div id="36781636" class="c"><input type="checkbox" id="c-36781636" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781291">parent</a><span>|</span><a href="#36781661">prev</a><span>|</span><a href="#36781485">next</a><span>|</span><label class="collapse" for="c-36781636">[-]</label><label class="expand" for="c-36781636">[1 more]</label></div><br/><div class="children"><div class="content">Nim does as well. You can use the C++ backend and wrap a decent bit of C++. The imports aren’t automatic so you need to define the FFI, but you can call templates, implement virtual methods, call constructors, etc.<p>NimForUE takes advantage of this: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;Cdr4-cOsAWA" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;Cdr4-cOsAWA</a></div><br/></div></div><div id="36781485" class="c"><input type="checkbox" id="c-36781485" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781291">parent</a><span>|</span><a href="#36781636">prev</a><span>|</span><a href="#36782462">next</a><span>|</span><label class="collapse" for="c-36781485">[-]</label><label class="expand" for="c-36781485">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;ve come across carbon (google&#x27;s c++-next language), clasp (common lisp with an llvm backend), felix (compiler generates c++), and maybe a couple of others i&#x27;m forgetting.<p>also some languages have packages that deal with c++ interop to varying extents - see this discussion: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;huhy8i&#x2F;is_there_a_programming_language_that_can_use_c&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;huhy8...</a></div><br/></div></div><div id="36782462" class="c"><input type="checkbox" id="c-36782462" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781291">parent</a><span>|</span><a href="#36781485">prev</a><span>|</span><a href="#36779204">next</a><span>|</span><label class="collapse" for="c-36782462">[-]</label><label class="expand" for="c-36782462">[1 more]</label></div><br/><div class="children"><div class="content">Besides all other answers, .NET ecosystem, and IBM i TIMI, by having a C++ compiler as well.</div><br/></div></div></div></div></div></div><div id="36779204" class="c"><input type="checkbox" id="c-36779204" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36779335">prev</a><span>|</span><a href="#36780321">next</a><span>|</span><label class="collapse" for="c-36779204">[-]</label><label class="expand" for="c-36779204">[12 more]</label></div><br/><div class="children"><div class="content">&gt; Statically compiled. Statically typed. Interops with C++. Memory safe. Typesafe. Data-race-free.<p>So it is for C++ what rust is for C?</div><br/><div id="36779404" class="c"><input type="checkbox" id="c-36779404" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779204">parent</a><span>|</span><a href="#36781231">next</a><span>|</span><label class="collapse" for="c-36779404">[-]</label><label class="expand" for="c-36779404">[9 more]</label></div><br/><div class="children"><div class="content">Val has a similar but different strategy to the big problem as Rust. In Rust the reference semantics are lifetime checked (hence all the talk about a &quot;borrow checker&quot;) but in Val there are no reference semantics.<p>In Rust there are some things you can&#x27;t (safely) do because the checker can&#x27;t see why they&#x27;re ok. Val guesses that, with appropriate language features in place, you can extend that to everything and still have a useful language but now you don&#x27;t need to teach this complicated and difficult feature.<p>Because Val is young it&#x27;s not yet obvious whether this is basically always better, or whether it&#x27;s too limited.</div><br/><div id="36782963" class="c"><input type="checkbox" id="c-36782963" checked=""/><div class="controls bullet"><span class="by">phatskat</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779404">parent</a><span>|</span><a href="#36780088">next</a><span>|</span><label class="collapse" for="c-36782963">[-]</label><label class="expand" for="c-36782963">[2 more]</label></div><br/><div class="children"><div class="content">As someone generally not in the loop on these kinds of languages, what is the “big problem”?</div><br/><div id="36783560" class="c"><input type="checkbox" id="c-36783560" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36782963">parent</a><span>|</span><a href="#36780088">next</a><span>|</span><label class="collapse" for="c-36783560">[-]</label><label class="expand" for="c-36783560">[1 more]</label></div><br/><div class="children"><div class="content">If another function &#x2F; sub-routine &#x2F; thread &#x2F; whatever alters this Thing <i>while</i> I&#x27;m looking at it, lots of nasty surprises await. For example maybe the Thing is a container of Objects and I was looping over it, taking out one object at a time and sometimes calling unrelated_function() but for some reason unrelated_function destroys the Thing occasionally and then... Boom, use-after-free.<p>It turns out that although we&#x27;ve often thought of this as a variety of different hard problems, including &quot;data races&quot; and &quot;use after free&quot;, they&#x27;re actually all one big problem, that of mutating something while somebody else used it. Solving this effectively solves all of those hard problems, at least in a subset of your language where you are able to address it.<p>In a language like C or C++ it&#x27;s easy to make one or more references to a Thing, and then give away the references, or the Thing, or both, and then the programmer loses track (or maybe never knew they were related) and this nasty surprise is their reward.<p>In Rust, their borrowing &#x2F; lending metaphor prevents the surprise. If you lend a mutable reference to the Thing, the borrower can&#x27;t destroy it, that&#x27;s not what &quot;lending&quot; means, and you can&#x27;t even use it until they&#x27;ve stopped borrowing it. If you lend immutable references, nobody can destroy it, or mutate it at all, until all those references are given back. But this does make the language more complicated because of the new metaphor.<p>In Val, you can&#x27;t have any references, so unrelated_function couldn&#x27;t destroy Thing, you&#x27;ve got Thing, so unrelated_function doesn&#x27;t have Thing and can&#x27;t destroy it. No surprises.</div><br/></div></div></div></div><div id="36780088" class="c"><input type="checkbox" id="c-36780088" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779404">parent</a><span>|</span><a href="#36782963">prev</a><span>|</span><a href="#36780543">next</a><span>|</span><label class="collapse" for="c-36780088">[-]</label><label class="expand" for="c-36780088">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because Val is young it&#x27;s not yet obvious whether this is basically always better, or whether it&#x27;s too limited.<p>This is sound wisdom.  It&#x27;s not always obvious at the beginning what the limitations are going to be, and what the opportunities are going to be.  If it&#x27;s a promising direction, pursue it, even though it won&#x27;t always work out.</div><br/></div></div><div id="36780543" class="c"><input type="checkbox" id="c-36780543" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779404">parent</a><span>|</span><a href="#36780088">prev</a><span>|</span><a href="#36779619">next</a><span>|</span><label class="collapse" for="c-36780543">[-]</label><label class="expand" for="c-36780543">[1 more]</label></div><br/><div class="children"><div class="content">Since Val seems to be liable to infer more about the actual data flow, I wonder how does it reflect on compile times.</div><br/></div></div><div id="36779619" class="c"><input type="checkbox" id="c-36779619" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779404">parent</a><span>|</span><a href="#36780543">prev</a><span>|</span><a href="#36781231">next</a><span>|</span><label class="collapse" for="c-36779619">[-]</label><label class="expand" for="c-36779619">[4 more]</label></div><br/><div class="children"><div class="content">The a typing feature[1] in the language Eiffel was based on the assumption of the author that the typing holes it apparently introduced could be statically detected. It turned out he was wrong after the language was released IIRC. I guess you have to be pretty certain of something before basing a language around it.<p>On top of that being a generally shite language doomed Eiffel.<p>[1] IIRC again, you could cancel features in subtypes, so &quot;all birds can fly&quot; but &quot;penguins are birds but can&#x27;t fly&quot;. That would break the Liskov Substitution Principle, which Bertrand Meyer thought he could deal with but apparently couldn&#x27;t.</div><br/><div id="36782469" class="c"><input type="checkbox" id="c-36782469" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779619">parent</a><span>|</span><a href="#36781231">next</a><span>|</span><label class="collapse" for="c-36782469">[-]</label><label class="expand" for="c-36782469">[3 more]</label></div><br/><div class="children"><div class="content">May many languages be as successful as Eiffel is.<p>Eiffel Software is still in business, whereas many others hardly reach any audience.</div><br/><div id="36783397" class="c"><input type="checkbox" id="c-36783397" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36782469">parent</a><span>|</span><a href="#36782926">next</a><span>|</span><label class="collapse" for="c-36783397">[-]</label><label class="expand" for="c-36783397">[1 more]</label></div><br/><div class="children"><div class="content">I know it is used in education in some parts of Europe. But now I&#x27;m wondering, is it used in production? Or rather, does it have a niche or an industry where it is more widely used? I&#x27;d be curious to know what software is written in Eiffel! (Mainly to get an idea of what Eiffel source code looks like, beyond toy examples)</div><br/></div></div><div id="36782926" class="c"><input type="checkbox" id="c-36782926" checked=""/><div class="controls bullet"><span class="by">Tozen</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36782469">parent</a><span>|</span><a href="#36783397">prev</a><span>|</span><a href="#36781231">next</a><span>|</span><label class="collapse" for="c-36782926">[-]</label><label class="expand" for="c-36782926">[1 more]</label></div><br/><div class="children"><div class="content">Very true.  So many languages people haven&#x27;t heard of.  It&#x27;s like if not in the top 10 or 20, some think they don&#x27;t matter.<p>In regards to Eiffel, always felt that hindrance to wider adoption was more about the licensing.  Still, they are in business and in use.</div><br/></div></div></div></div></div></div></div></div><div id="36781231" class="c"><input type="checkbox" id="c-36781231" checked=""/><div class="controls bullet"><span class="by">sharts</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36779204">parent</a><span>|</span><a href="#36779404">prev</a><span>|</span><a href="#36780649">next</a><span>|</span><label class="collapse" for="c-36781231">[-]</label><label class="expand" for="c-36781231">[1 more]</label></div><br/><div class="children"><div class="content">I thought it was that Go is to C what Rust is to C++?
This seems like another animal altogether.</div><br/></div></div></div></div><div id="36780321" class="c"><input type="checkbox" id="c-36780321" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36779204">prev</a><span>|</span><a href="#36781624">next</a><span>|</span><label class="collapse" for="c-36780321">[-]</label><label class="expand" for="c-36780321">[3 more]</label></div><br/><div class="children"><div class="content">&gt; ...interops with C++...<p>Does it? With what qualifications? Requires C++ that uses clang modules or something?</div><br/><div id="36780351" class="c"><input type="checkbox" id="c-36780351" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780321">parent</a><span>|</span><a href="#36781624">next</a><span>|</span><label class="collapse" for="c-36780351">[-]</label><label class="expand" for="c-36780351">[2 more]</label></div><br/><div class="children"><div class="content">What are you quoting?<p>EDIT: I assume you meant to copy &quot;ìnterops with C++&quot;. The answer is that it basically doesn&#x27;t right now, but they intend for it to in the future somehow.<p><a href="https:&#x2F;&#x2F;accu.org&#x2F;journals&#x2F;overload&#x2F;30&#x2F;172&#x2F;teodorescu&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;accu.org&#x2F;journals&#x2F;overload&#x2F;30&#x2F;172&#x2F;teodorescu&#x2F;</a></div><br/><div id="36780619" class="c"><input type="checkbox" id="c-36780619" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780351">parent</a><span>|</span><a href="#36781624">next</a><span>|</span><label class="collapse" for="c-36780619">[-]</label><label class="expand" for="c-36780619">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, yeah. Autocorrect. I fixed it.<p>And if that&#x27;s a goal, fine, but if there isn&#x27;t interop yet, we should be hesitant to describe Val as having C++ interop. Especially since C++ interop probably requires some compromises, such as requiring modular C++ in some form.</div><br/></div></div></div></div></div></div><div id="36781624" class="c"><input type="checkbox" id="c-36781624" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36780321">prev</a><span>|</span><a href="#36782235">next</a><span>|</span><label class="collapse" for="c-36781624">[-]</label><label class="expand" for="c-36781624">[2 more]</label></div><br/><div class="children"><div class="content">In a lot of cases won&#x27;t the C++ compiler just inline methods and remove the copies anyway...?</div><br/><div id="36783628" class="c"><input type="checkbox" id="c-36783628" checked=""/><div class="controls bullet"><span class="by">fractalb</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36781624">parent</a><span>|</span><a href="#36782235">next</a><span>|</span><label class="collapse" for="c-36783628">[-]</label><label class="expand" for="c-36783628">[1 more]</label></div><br/><div class="children"><div class="content">Inlining functions and copy elision are two different things. If you inline a function without copying it&#x27;s args, then it&#x27;ll change the value of the original argument: Copy semantics lost!</div><br/></div></div></div></div><div id="36782235" class="c"><input type="checkbox" id="c-36782235" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36781624">prev</a><span>|</span><a href="#36781718">next</a><span>|</span><label class="collapse" for="c-36782235">[-]</label><label class="expand" for="c-36782235">[1 more]</label></div><br/><div class="children"><div class="content">cross platform build tools similar to cargo or go build are important to me.<p>battery included stdlib that also has network and gui is super attractive too</div><br/></div></div><div id="36781718" class="c"><input type="checkbox" id="c-36781718" checked=""/><div class="controls bullet"><span class="by">TOGoS</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36782235">prev</a><span>|</span><a href="#36780110">next</a><span>|</span><label class="collapse" for="c-36781718">[-]</label><label class="expand" for="c-36781718">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  You just pass by value, return by value everywhere, all day long<p>This is actually how I&#x27;ve been writing PHP programs for years, passing arrays around like I just don&#x27;t care.[3]<p>I <i>think</i> the PHP interpreter is smart enough to actually only copy-on-write, but I admit I&#x27;ve never profiled these programs.  But anecdotally, I&#x27;ve done some pretty complex stuff[1] this way and it never caused noticeable performance problems.<p>[1] Complex as in &#x27;wow I sure am making the computer process a lot of data, parse some DSL character-by-character, dynamically generate SQL and massage the results into some arbitrary structure for EACH PAGE LOAD, geez&#x27;.  Not as in &#x27;print hello world, but using Laravel&#x27;, which somehow manages to be about 30x as computationally expensive[2].<p>[2] quip about how &#x27;web artisans&#x27; spend the time between page loads brewing coffee using their CPU as a heating source while thinking deep thoughts.  But I digress.<p>[3] Back in the PHP 4 days, objects, too, acted as if stored in variables rather than just pointed-to by them.  Not that anyone expected language design excellence from Rasmus et al, but strikes me as a missed opportunity when they changed object variables to having reference semantics to have &#x27;value, variable reference, or pointer-to-value&#x27; be a property of variables orthogonal to the type of value they store&#x2F;reference.  e.g.<p><pre><code>  $a =  $b; &#x2F;&#x2F; Copy $b&#x27;s value into $a
  $a = &amp;$b; &#x2F;&#x2F; $a and $b are now the same variable
  $a = *$b; &#x2F;&#x2F; $a points to the same object as $b, but unlike $a = &amp;$b, the variables themselves are not linked</code></pre></div><br/></div></div><div id="36780110" class="c"><input type="checkbox" id="c-36780110" checked=""/><div class="controls bullet"><span class="by">moonchrome</span><span>|</span><a href="#36779119">parent</a><span>|</span><a href="#36781718">prev</a><span>|</span><a href="#36780663">next</a><span>|</span><label class="collapse" for="c-36780110">[-]</label><label class="expand" for="c-36780110">[3 more]</label></div><br/><div class="children"><div class="content">does this mean your object tree is acyclic since you can&#x27;t have references ?</div><br/><div id="36780264" class="c"><input type="checkbox" id="c-36780264" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780110">parent</a><span>|</span><a href="#36780663">next</a><span>|</span><label class="collapse" for="c-36780264">[-]</label><label class="expand" for="c-36780264">[2 more]</label></div><br/><div class="children"><div class="content">Val will have statement level unsafe annotations (not even full unsafe blocks), according to the podcast linked in a nearby comment. Linked lists will be tricky or impossible to do safely, like in Rust.</div><br/><div id="36781060" class="c"><input type="checkbox" id="c-36781060" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#36779119">root</a><span>|</span><a href="#36780264">parent</a><span>|</span><a href="#36780663">next</a><span>|</span><label class="collapse" for="c-36781060">[-]</label><label class="expand" for="c-36781060">[1 more]</label></div><br/><div class="children"><div class="content">I’ll have to see about this, but I don’t really like that.<p>Yes, you can replace a block of unsafe calls with a bunch of individually unsafe-annotated lines. But a good model of unsafe to follow is that whatever unsafety you expose within a block should be brought back within safety requirements when you exit the block. Put differently, an unsafe block should act as unit-safe and not leak unsafety.<p>If all you get is statement-level unsafety, you have no way to indicate at what point you’ve re-upheld safety guarantees.</div><br/></div></div></div></div></div></div></div></div><div id="36780663" class="c"><input type="checkbox" id="c-36780663" checked=""/><div class="controls bullet"><span class="by">Tozen</span><span>|</span><a href="#36779119">prev</a><span>|</span><a href="#36778854">next</a><span>|</span><label class="collapse" for="c-36780663">[-]</label><label class="expand" for="c-36780663">[15 more]</label></div><br/><div class="children"><div class="content">How things can go down on HN strikes me as odd, and this seems to be an example.  &quot;People&quot; suddenly seem to be quite supportive of: 1) Has not released an alpha yet and after a year. 2) Website that promises a lot (like 2-way C++ interoperability). 3) Clearly telling people it will have trouble supporting the Windows OS.  4) Has relatively limited stars and contributors on GitHub. 5) Wishlists and promises are suddenly fine by them.<p>Then for other languages its media blackout, hate, and an avalanche of trolling.  I suppose the hidden machinery and utility accounts don&#x27;t come out, unless &quot;they&quot; perceive an actual threat to its position.<p>Don&#x27;t get me wrong, love new languages and seeing more competition.  People should follow their dreams.  Just weirds me out, as to how reactions and perception goes.</div><br/><div id="36780845" class="c"><input type="checkbox" id="c-36780845" checked=""/><div class="controls bullet"><span class="by">mbStavola</span><span>|</span><a href="#36780663">parent</a><span>|</span><a href="#36781017">next</a><span>|</span><label class="collapse" for="c-36780845">[-]</label><label class="expand" for="c-36780845">[7 more]</label></div><br/><div class="children"><div class="content">People were rightfully critical of V for over promising and under delivering as well as misrepresenting the capabilities of the language.<p>Val has promised a lot and hasn&#x27;t delivered <i>anything</i>, so I think it&#x27;s fine to be interested&#x2F; excited but have a heavy dose of scepticism as well.</div><br/><div id="36783375" class="c"><input type="checkbox" id="c-36783375" checked=""/><div class="controls bullet"><span class="by">pepa65</span><span>|</span><a href="#36780663">root</a><span>|</span><a href="#36780845">parent</a><span>|</span><a href="#36783549">next</a><span>|</span><label class="collapse" for="c-36783375">[-]</label><label class="expand" for="c-36783375">[1 more]</label></div><br/><div class="children"><div class="content">It seems V is now delivering quite well.</div><br/></div></div><div id="36783549" class="c"><input type="checkbox" id="c-36783549" checked=""/><div class="controls bullet"><span class="by">amedvednikov</span><span>|</span><a href="#36780663">root</a><span>|</span><a href="#36780845">parent</a><span>|</span><a href="#36783375">prev</a><span>|</span><a href="#36781390">next</a><span>|</span><label class="collapse" for="c-36783549">[-]</label><label class="expand" for="c-36783549">[1 more]</label></div><br/><div class="children"><div class="content">Can you please list here examples of under delivering and misrepresenting?</div><br/></div></div></div></div><div id="36781017" class="c"><input type="checkbox" id="c-36781017" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#36780663">parent</a><span>|</span><a href="#36780845">prev</a><span>|</span><a href="#36780767">next</a><span>|</span><label class="collapse" for="c-36781017">[-]</label><label class="expand" for="c-36781017">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Then for other languages its media blackout, hate, and an avalanche of trolling [...]
&gt; Just weirds me out, as to how reactions and perception goes.<p>The prog lang world is a massive circle jerk, with plenty of toxicity, extreme fanboy-ism and haters.</div><br/><div id="36781358" class="c"><input type="checkbox" id="c-36781358" checked=""/><div class="controls bullet"><span class="by">Tozen</span><span>|</span><a href="#36780663">root</a><span>|</span><a href="#36781017">parent</a><span>|</span><a href="#36780767">next</a><span>|</span><label class="collapse" for="c-36781358">[-]</label><label class="expand" for="c-36781358">[1 more]</label></div><br/><div class="children"><div class="content">Hard to argue against the truth or the reality of it.</div><br/></div></div></div></div><div id="36780767" class="c"><input type="checkbox" id="c-36780767" checked=""/><div class="controls bullet"><span class="by">aetimmes</span><span>|</span><a href="#36780663">parent</a><span>|</span><a href="#36781017">prev</a><span>|</span><a href="#36781837">next</a><span>|</span><label class="collapse" for="c-36780767">[-]</label><label class="expand" for="c-36780767">[1 more]</label></div><br/><div class="children"><div class="content">Communities aren&#x27;t monoliths.<p>The groups of people who criticize real tangible languages and people who have the skills to critique the design of abstract language design don&#x27;t necessarily overlap.</div><br/></div></div><div id="36781837" class="c"><input type="checkbox" id="c-36781837" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#36780663">parent</a><span>|</span><a href="#36780767">prev</a><span>|</span><a href="#36782095">next</a><span>|</span><label class="collapse" for="c-36781837">[-]</label><label class="expand" for="c-36781837">[1 more]</label></div><br/><div class="children"><div class="content">This seems like a kneejerk reaction to the topmost comment not being critical. There&#x27;s plenty of critique and skepticism if you read past the top, be it the name, parts of the docs, whether their mutable value semantics work, etc.</div><br/></div></div><div id="36782480" class="c"><input type="checkbox" id="c-36782480" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36780663">parent</a><span>|</span><a href="#36782095">prev</a><span>|</span><a href="#36780748">next</a><span>|</span><label class="collapse" for="c-36782480">[-]</label><label class="expand" for="c-36782480">[1 more]</label></div><br/><div class="children"><div class="content">Being supported by Adobe, having Dave Abrahms and Sean Parent, kind of gives it bonus points.<p>This is not a random language.</div><br/></div></div><div id="36780748" class="c"><input type="checkbox" id="c-36780748" checked=""/><div class="controls bullet"><span class="by">pertymcpert</span><span>|</span><a href="#36780663">parent</a><span>|</span><a href="#36782480">prev</a><span>|</span><a href="#36778854">next</a><span>|</span><label class="collapse" for="c-36780748">[-]</label><label class="expand" for="c-36780748">[1 more]</label></div><br/><div class="children"><div class="content">It seems to be a coin flip. Whichever comment gets upvoted early on continues to be upvoted and becomes the consensus.</div><br/></div></div></div></div><div id="36778854" class="c"><input type="checkbox" id="c-36778854" checked=""/><div class="controls bullet"><span class="by">kubota</span><span>|</span><a href="#36780663">prev</a><span>|</span><a href="#36779403">next</a><span>|</span><label class="collapse" for="c-36778854">[-]</label><label class="expand" for="c-36778854">[34 more]</label></div><br/><div class="children"><div class="content">Part of me loves the advent of so many zero-cost-abstraction languages. The other part wishes the systems programmers would pick a winner already so that the already small community of systems programmers do not end up multifurcated into even smaller communities of Rust, Zig, Val, etc developers. I hope the systems language wars end soon in other words.</div><br/><div id="36778889" class="c"><input type="checkbox" id="c-36778889" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#36778854">parent</a><span>|</span><a href="#36779731">next</a><span>|</span><label class="collapse" for="c-36778889">[-]</label><label class="expand" for="c-36778889">[8 more]</label></div><br/><div class="children"><div class="content">Maybe we picked one too early and didn’t have enough innovation in this area for too long. Bring the war :)</div><br/><div id="36779255" class="c"><input type="checkbox" id="c-36779255" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36778889">parent</a><span>|</span><a href="#36781618">next</a><span>|</span><label class="collapse" for="c-36779255">[-]</label><label class="expand" for="c-36779255">[1 more]</label></div><br/><div class="children"><div class="content">Not even a war, right tools for the job. I don&#x27;t think it&#x27;s possible for one language to rule them all. Options are good.</div><br/></div></div><div id="36781618" class="c"><input type="checkbox" id="c-36781618" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36778889">parent</a><span>|</span><a href="#36779255">prev</a><span>|</span><a href="#36779731">next</a><span>|</span><label class="collapse" for="c-36781618">[-]</label><label class="expand" for="c-36781618">[6 more]</label></div><br/><div class="children"><div class="content">I like Rust, but damn is it complicated and very heavy. I really just want C with namespaces, actual enums (tagged unions are a bonus), a &quot;modern&quot; type system, and proper package management. They all have their place, IMO it&#x27;s not that hard to switch between languages.</div><br/><div id="36782452" class="c"><input type="checkbox" id="c-36782452" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36781618">parent</a><span>|</span><a href="#36782500">next</a><span>|</span><label class="collapse" for="c-36782452">[-]</label><label class="expand" for="c-36782452">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ziglang.org&#x2F;</a> ?</div><br/></div></div><div id="36782500" class="c"><input type="checkbox" id="c-36782500" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36781618">parent</a><span>|</span><a href="#36782452">prev</a><span>|</span><a href="#36779731">next</a><span>|</span><label class="collapse" for="c-36782500">[-]</label><label class="expand" for="c-36782500">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re in luck, C++ covers that.</div><br/><div id="36783194" class="c"><input type="checkbox" id="c-36783194" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36782500">parent</a><span>|</span><a href="#36782661">next</a><span>|</span><label class="collapse" for="c-36783194">[-]</label><label class="expand" for="c-36783194">[1 more]</label></div><br/><div class="children"><div class="content">I think when someone says „I want a C that’s cleaner and has some simple, generally loved features“ they don’t think of C++?</div><br/></div></div><div id="36782661" class="c"><input type="checkbox" id="c-36782661" checked=""/><div class="controls bullet"><span class="by">csjh</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36782500">parent</a><span>|</span><a href="#36783194">prev</a><span>|</span><a href="#36779731">next</a><span>|</span><label class="collapse" for="c-36782661">[-]</label><label class="expand" for="c-36782661">[2 more]</label></div><br/><div class="children"><div class="content">C++ has proper package management?</div><br/><div id="36782865" class="c"><input type="checkbox" id="c-36782865" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36782661">parent</a><span>|</span><a href="#36779731">next</a><span>|</span><label class="collapse" for="c-36782865">[-]</label><label class="expand" for="c-36782865">[1 more]</label></div><br/><div class="children"><div class="content">vcpkg and conan nowadays.<p>Not using one of them is making oneselfs live difficult on purpose.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36779731" class="c"><input type="checkbox" id="c-36779731" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#36778854">parent</a><span>|</span><a href="#36778889">prev</a><span>|</span><a href="#36779159">next</a><span>|</span><label class="collapse" for="c-36779731">[-]</label><label class="expand" for="c-36779731">[17 more]</label></div><br/><div class="children"><div class="content">I think at this point Rust is the winner just because it&#x27;s already overcome the incredible hurdles of being shipped in the Linux and Windows kernels themselves.  In that regard,  I doubt there&#x27;s room for any more of these new systems languages now.</div><br/><div id="36779835" class="c"><input type="checkbox" id="c-36779835" checked=""/><div class="controls bullet"><span class="by">bsaul</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36779731">parent</a><span>|</span><a href="#36780337">next</a><span>|</span><label class="collapse" for="c-36779835">[-]</label><label class="expand" for="c-36779835">[15 more]</label></div><br/><div class="children"><div class="content">I have the intuition that rust can’t possibly be the winner, it really feels too crude regarding the way it manages lifetimes. It really feels like the clumsy grandparent of the language that will indeed solve those problems elegantly.</div><br/><div id="36780047" class="c"><input type="checkbox" id="c-36780047" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36779835">parent</a><span>|</span><a href="#36780010">next</a><span>|</span><label class="collapse" for="c-36780047">[-]</label><label class="expand" for="c-36780047">[13 more]</label></div><br/><div class="children"><div class="content">But we made do with C for how many years? OP&#x27;s question isn&#x27;t whether Rust is as good as systems languages will get, the question is whether any successor language stands a chance of being included in the kernels.<p>The bad ergonomics of C were never enough to get another language into the Linux kernel, it took a language that solves the number one class of security bugs. It&#x27;s unclear that any successor to Rust will be able to show as clear a need.</div><br/><div id="36780111" class="c"><input type="checkbox" id="c-36780111" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780047">parent</a><span>|</span><a href="#36780725">next</a><span>|</span><label class="collapse" for="c-36780111">[-]</label><label class="expand" for="c-36780111">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not how I read OP&#x27;s question. OP was wondering whether a lang besides Rust can be &quot;the winner&quot; (unqualified) given that Rust has already passed the hurdle of being included in the kernel. It didn&#x27;t sound like at all like their question was limited to whether there&#x27;s room for another lang in the kernel.</div><br/></div></div><div id="36780725" class="c"><input type="checkbox" id="c-36780725" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780047">parent</a><span>|</span><a href="#36780111">prev</a><span>|</span><a href="#36782514">next</a><span>|</span><label class="collapse" for="c-36780725">[-]</label><label class="expand" for="c-36780725">[2 more]</label></div><br/><div class="children"><div class="content">But isn&#x27;t it worth spending a few years poking around before we lock ourselves into fifty more years of bad ergonomics, now that things have clearly reached the point where there&#x27;s credible motion towards a C alternative?</div><br/><div id="36781232" class="c"><input type="checkbox" id="c-36781232" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780725">parent</a><span>|</span><a href="#36782514">next</a><span>|</span><label class="collapse" for="c-36781232">[-]</label><label class="expand" for="c-36781232">[1 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s lifetimes have a steep (un)learning curve, but once you know what you&#x27;re doing, they&#x27;re fine. Really. IMHO Rust has ergonomic problems around effects or generic numeric code, but not memory management.<p>AFAIK no silver bullet has been discovered yet that would be an improvement over Rust that doesn&#x27;t have some other trade-off. Val&#x27;s mutable value semantics is more local and limited. It &quot;solves&quot; the problem of ugly lifetime annotations by not supporting complex zero-cost lifetimes at all. That doesn&#x27;t mean Val can&#x27;t be successful — it can be easier to use by supporting simpler constructs and focusing less on zero-cost abstractions, like Swift, but its ideas aren&#x27;t stop-the-presses for Rust.<p>We&#x27;re already overdue for having a more modern, practical replacement for C. Waiting for a hypothetical better-than-Rust language will only mean staying with C for even longer.</div><br/></div></div></div></div><div id="36782514" class="c"><input type="checkbox" id="c-36782514" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780047">parent</a><span>|</span><a href="#36780725">prev</a><span>|</span><a href="#36780802">next</a><span>|</span><label class="collapse" for="c-36782514">[-]</label><label class="expand" for="c-36782514">[1 more]</label></div><br/><div class="children"><div class="content">Ada already existed, politics and a free beer compiler ecosystem also helped.</div><br/></div></div><div id="36780802" class="c"><input type="checkbox" id="c-36780802" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780047">parent</a><span>|</span><a href="#36782514">prev</a><span>|</span><a href="#36780385">next</a><span>|</span><label class="collapse" for="c-36780802">[-]</label><label class="expand" for="c-36780802">[7 more]</label></div><br/><div class="children"><div class="content">&gt; the question is whether any successor language stands a chance of being included in the kernels<p>Uhh no. No that is not “the question”.<p>My question is “what language will I use to write video games”. C++ sucks and Rust isn’t a great fit.</div><br/><div id="36782774" class="c"><input type="checkbox" id="c-36782774" checked=""/><div class="controls bullet"><span class="by">omgmajk</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780802">parent</a><span>|</span><a href="#36781151">next</a><span>|</span><label class="collapse" for="c-36782774">[-]</label><label class="expand" for="c-36782774">[3 more]</label></div><br/><div class="children"><div class="content">I guess Jai aims to move into the gamedev space of this, but the language has a terrible presence online<p><a href="https:&#x2F;&#x2F;inductive.no&#x2F;jai&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;inductive.no&#x2F;jai&#x2F;</a></div><br/><div id="36782973" class="c"><input type="checkbox" id="c-36782973" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36782774">parent</a><span>|</span><a href="#36781151">next</a><span>|</span><label class="collapse" for="c-36782973">[-]</label><label class="expand" for="c-36782973">[2 more]</label></div><br/><div class="children"><div class="content">I wrote a large blog post about Jai. <a href="https:&#x2F;&#x2F;www.forrestthewoods.com&#x2F;blog&#x2F;learning-jai-via-advent-of-code&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.forrestthewoods.com&#x2F;blog&#x2F;learning-jai-via-advent...</a><p>It’s a very interesting language that does a lot of things “very right”. But it’s also a long ways from being broadly available.</div><br/><div id="36783086" class="c"><input type="checkbox" id="c-36783086" checked=""/><div class="controls bullet"><span class="by">omgmajk</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36782973">parent</a><span>|</span><a href="#36781151">next</a><span>|</span><label class="collapse" for="c-36783086">[-]</label><label class="expand" for="c-36783086">[1 more]</label></div><br/><div class="children"><div class="content">I like your style of writing :) - I watched a bunch of youtubers use it to do various things and was impressed but really I just want them to have a website and a way to sign up for beta easily so I can play with it too.</div><br/></div></div></div></div></div></div><div id="36781151" class="c"><input type="checkbox" id="c-36781151" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780802">parent</a><span>|</span><a href="#36782774">prev</a><span>|</span><a href="#36780385">next</a><span>|</span><label class="collapse" for="c-36781151">[-]</label><label class="expand" for="c-36781151">[3 more]</label></div><br/><div class="children"><div class="content">Rust is fine in an ecs engine like Bevy. Absolutely awful in traditional oop setups though.</div><br/><div id="36783087" class="c"><input type="checkbox" id="c-36783087" checked=""/><div class="controls bullet"><span class="by">aldanor</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36781151">parent</a><span>|</span><a href="#36781227">next</a><span>|</span><label class="collapse" for="c-36783087">[-]</label><label class="expand" for="c-36783087">[1 more]</label></div><br/><div class="children"><div class="content">Not sure what you mean by &quot;traditional oop setups&quot; and why anyone should care about it, that&#x27;s more of an outdated design pattern and a bad choice of the past than a desired language feature.</div><br/></div></div><div id="36781227" class="c"><input type="checkbox" id="c-36781227" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36781151">parent</a><span>|</span><a href="#36783087">prev</a><span>|</span><a href="#36780385">next</a><span>|</span><label class="collapse" for="c-36781227">[-]</label><label class="expand" for="c-36781227">[1 more]</label></div><br/><div class="children"><div class="content">Bevy is very cool and I follow it closely. It has yet to ship a meaningful project.</div><br/></div></div></div></div></div></div><div id="36780385" class="c"><input type="checkbox" id="c-36780385" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780047">parent</a><span>|</span><a href="#36780802">prev</a><span>|</span><a href="#36780010">next</a><span>|</span><label class="collapse" for="c-36780385">[-]</label><label class="expand" for="c-36780385">[1 more]</label></div><br/><div class="children"><div class="content"><i>But we made do with C for how many years?</i><p>K&amp;R C was, what, 1972...and it&#x27;s 2023 now.  So that&#x27;s 51 years with no definitive end of &#x27;making do&#x27; in sight.</div><br/></div></div></div></div><div id="36780010" class="c"><input type="checkbox" id="c-36780010" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36779835">parent</a><span>|</span><a href="#36780047">prev</a><span>|</span><a href="#36780337">next</a><span>|</span><label class="collapse" for="c-36780010">[-]</label><label class="expand" for="c-36780010">[1 more]</label></div><br/><div class="children"><div class="content">Same opinion here. Let us look at Val and Vale.<p>There is also Carbon and CppFront but those are more of C++ evolution than new-born things.</div><br/></div></div></div></div><div id="36780337" class="c"><input type="checkbox" id="c-36780337" checked=""/><div class="controls bullet"><span class="by">tormeh</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36779731">parent</a><span>|</span><a href="#36779835">prev</a><span>|</span><a href="#36779159">next</a><span>|</span><label class="collapse" for="c-36780337">[-]</label><label class="expand" for="c-36780337">[1 more]</label></div><br/><div class="children"><div class="content">Like what happened with Java. Once a language has accumulated enough popularity it’s extremely hard to depose it, due to network effects. The switching costs are enormous.</div><br/></div></div></div></div><div id="36779159" class="c"><input type="checkbox" id="c-36779159" checked=""/><div class="controls bullet"><span class="by">chrisco255</span><span>|</span><a href="#36778854">parent</a><span>|</span><a href="#36779731">prev</a><span>|</span><a href="#36779403">next</a><span>|</span><label class="collapse" for="c-36779159">[-]</label><label class="expand" for="c-36779159">[8 more]</label></div><br/><div class="children"><div class="content">Won&#x27;t happen. But all the more reason to expand wasm + wasi support everywhere.</div><br/><div id="36779426" class="c"><input type="checkbox" id="c-36779426" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36779159">parent</a><span>|</span><a href="#36779403">next</a><span>|</span><label class="collapse" for="c-36779426">[-]</label><label class="expand" for="c-36779426">[7 more]</label></div><br/><div class="children"><div class="content">Are those languages able to do low-level hardware things?</div><br/><div id="36780223" class="c"><input type="checkbox" id="c-36780223" checked=""/><div class="controls bullet"><span class="by">chrisco255</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36779426">parent</a><span>|</span><a href="#36779854">next</a><span>|</span><label class="collapse" for="c-36780223">[-]</label><label class="expand" for="c-36780223">[4 more]</label></div><br/><div class="children"><div class="content">Wasm is WebAssembly, which has a nice compact set of instructions to compile to and network effects from being the 4th language of the web to ensure its staying power. WASI is a WASM system interface for connecting with hardware and other systems:<p><a href="https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2019&#x2F;03&#x2F;standardizing-wasi-a-webassembly-system-interface&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2019&#x2F;03&#x2F;standardizing-wasi-a-webas...</a></div><br/><div id="36780497" class="c"><input type="checkbox" id="c-36780497" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780223">parent</a><span>|</span><a href="#36779854">next</a><span>|</span><label class="collapse" for="c-36780497">[-]</label><label class="expand" for="c-36780497">[3 more]</label></div><br/><div class="children"><div class="content">It rather looks like WASI interfaces to code <i>which is written in one of the other system programming languages</i> that are the topic in this thread, so I guess the answer to the parent commenter&#x27;s question is &quot;no&quot;? Am I misinterpreting this?</div><br/><div id="36780666" class="c"><input type="checkbox" id="c-36780666" checked=""/><div class="controls bullet"><span class="by">chrisco255</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780497">parent</a><span>|</span><a href="#36779854">next</a><span>|</span><label class="collapse" for="c-36780666">[-]</label><label class="expand" for="c-36780666">[2 more]</label></div><br/><div class="children"><div class="content">If you want to be pedantic, sure. The point is whether those interfaces are written in C or Go or Rust that they are interoperable, and a dev can write their core logic with a wasm compilation target in Zig, Val, or whatever other language comes up. Hardware and OS devs can write WASI modules in whatever language they prefer so that others can consume.</div><br/><div id="36780723" class="c"><input type="checkbox" id="c-36780723" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36780666">parent</a><span>|</span><a href="#36779854">next</a><span>|</span><label class="collapse" for="c-36780723">[-]</label><label class="expand" for="c-36780723">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is being pedantic. We here talk about languages like Rust, Val, and also C (which we attempt to replace) as languages to interface directly with the <i>bare metal</i>. Think device driver or a kernel itself.<p>To me it initially looks like WASI does not let you use WASM as a bare metal language (I don&#x27;t know enough about WASM to judge whether that&#x27;s even really sensible). Instead, you have a layer on the bare metal (or even several layers above) implemented otherwise, and then you can use WASM still further above, to interface to that layer.<p>But again, maybe I misunderstood.</div><br/></div></div></div></div></div></div></div></div><div id="36779854" class="c"><input type="checkbox" id="c-36779854" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#36778854">root</a><span>|</span><a href="#36779426">parent</a><span>|</span><a href="#36780223">prev</a><span>|</span><a href="#36779767">next</a><span>|</span><label class="collapse" for="c-36779854">[-]</label><label class="expand" for="c-36779854">[1 more]</label></div><br/><div class="children"><div class="content">Not really, unless some future hardware supports such a beast, could be an interesting approach for AI&#x2F;WebGPU interfaces.<p>It&#x27;s more for service-oriented applications currently... you pass stuff in, get stuff out.</div><br/></div></div></div></div></div></div></div></div><div id="36779403" class="c"><input type="checkbox" id="c-36779403" checked=""/><div class="controls bullet"><span class="by">cloudmike</span><span>|</span><a href="#36778854">prev</a><span>|</span><a href="#36781118">next</a><span>|</span><label class="collapse" for="c-36779403">[-]</label><label class="expand" for="c-36779403">[3 more]</label></div><br/><div class="children"><div class="content">My emotional journey with Val having just learned about it today:<p>Oh neat, a new systems language, probably nothing but let&#x27;s take a peek. Docs look legit. Hmm some thoughtful ideas in here around ownership. Syntax makes sense. But is it different enough to justify its own existence? Who makes it?<p>Oooh, Dave Abrahams is working on it. We crossed paths at Apple and I remember his Crusty talk about Swift [1]. It was great, loved the strong opinions, but Apple sadly removed it years later because it had some outdated advice. Wait, he&#x27;s at Adobe now? So is this an Adobe language?<p>Conclusion: keep an eye on it, will watch the linked talks, wait and see.<p>[1] edit: I found the Crusty talk! &quot;I don&#x27;t do Object Oriented!&quot; <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=p3zo4ptMBiQ">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=p3zo4ptMBiQ</a></div><br/><div id="36780403" class="c"><input type="checkbox" id="c-36780403" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36779403">parent</a><span>|</span><a href="#36780346">next</a><span>|</span><label class="collapse" for="c-36780403">[-]</label><label class="expand" for="c-36780403">[1 more]</label></div><br/><div class="children"><div class="content">Before his time at Apple, David Abrahams was very prominent Boost contributor, a member of the C++ committee and a strong proponent of Stepanov-style generic programming.<p>He ending up in the Val project is not surprising!</div><br/></div></div><div id="36780346" class="c"><input type="checkbox" id="c-36780346" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#36779403">parent</a><span>|</span><a href="#36780403">prev</a><span>|</span><a href="#36781118">next</a><span>|</span><label class="collapse" for="c-36780346">[-]</label><label class="expand" for="c-36780346">[1 more]</label></div><br/><div class="children"><div class="content">Ha, I really loved this style of describing the journey. More people should write like this :)</div><br/></div></div></div></div><div id="36781118" class="c"><input type="checkbox" id="c-36781118" checked=""/><div class="controls bullet"><span class="by">aslilac</span><span>|</span><a href="#36779403">prev</a><span>|</span><a href="#36780989">next</a><span>|</span><label class="collapse" for="c-36781118">[-]</label><label class="expand" for="c-36781118">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had &quot;playing with val&quot; on the back-burner for a while. Finally tried to today, only to learn that even after 4,000 commits it&#x27;s still a long shot from usable. Most of the examples from the language tour don&#x27;t compile, even seemingly simple ones.<p>Carbon has yet to deliver on anything yet, even as Sean Baxter has been making lots of progress on the Circle compiler (including implementing lots of the good bits from Carbon).<p>Hard to be a successor when you can&#x27;t really be considered a language yet.</div><br/></div></div><div id="36780989" class="c"><input type="checkbox" id="c-36780989" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#36781118">prev</a><span>|</span><a href="#36781551">next</a><span>|</span><label class="collapse" for="c-36780989">[-]</label><label class="expand" for="c-36780989">[5 more]</label></div><br/><div class="children"><div class="content">As a compiler developper (yeah _I&#x27;m something of a_ ...) I&#x27;m shoked to see<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;val-lang&#x2F;val&#x2F;issues&#x2F;758">https:&#x2F;&#x2F;github.com&#x2F;val-lang&#x2F;val&#x2F;issues&#x2F;758</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;val-lang&#x2F;val&#x2F;issues&#x2F;711">https:&#x2F;&#x2F;github.com&#x2F;val-lang&#x2F;val&#x2F;issues&#x2F;711</a><p>That smells bad implementation. You should self-host ASAP guys, you&#x27;ll find more basic bugs like that. Yet 500+ stars !</div><br/><div id="36782619" class="c"><input type="checkbox" id="c-36782619" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#36780989">parent</a><span>|</span><a href="#36782070">next</a><span>|</span><label class="collapse" for="c-36782619">[-]</label><label class="expand" for="c-36782619">[2 more]</label></div><br/><div class="children"><div class="content">Swift itself still doesn’t self host and is approaching a version 6 release. I’m not a compiler developer but the outcome of all the discussions around this topic in the Swift community was that it wasn’t worthwhile yet.</div><br/><div id="36783413" class="c"><input type="checkbox" id="c-36783413" checked=""/><div class="controls bullet"><span class="by">dcgudeman</span><span>|</span><a href="#36780989">root</a><span>|</span><a href="#36782619">parent</a><span>|</span><a href="#36782070">next</a><span>|</span><label class="collapse" for="c-36783413">[-]</label><label class="expand" for="c-36783413">[1 more]</label></div><br/><div class="children"><div class="content">Where was that discussion held? I&#x27;d like to read what people were thinking.</div><br/></div></div></div></div><div id="36782070" class="c"><input type="checkbox" id="c-36782070" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36780989">parent</a><span>|</span><a href="#36782619">prev</a><span>|</span><a href="#36783034">next</a><span>|</span><label class="collapse" for="c-36782070">[-]</label><label class="expand" for="c-36782070">[1 more]</label></div><br/><div class="children"><div class="content">As another compiler developer, there are few mistakes more damaging than self-hosting too soon. A language will be a net benefit for small and medium programs long, long before it&#x27;s a net benefit for (and has the tooling for) a project as big as a compiler. I&#x27;m glad they&#x27;re not rushing it.</div><br/></div></div><div id="36783034" class="c"><input type="checkbox" id="c-36783034" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#36780989">parent</a><span>|</span><a href="#36782070">prev</a><span>|</span><a href="#36781551">next</a><span>|</span><label class="collapse" for="c-36783034">[-]</label><label class="expand" for="c-36783034">[1 more]</label></div><br/><div class="children"><div class="content">Bugs like that in a production compiler could be worrying. In a compiler for a language still being defined, not so much. Compare Rust 1.0 vs 1.71 to see how much of a gulf there is between &quot;first stable release&quot; and &quot;compiler of a stable language with lots of real world usage&quot;.<p>Self hosting is also not the be-all and end-all. It is a symbolic milestone, more than anything. Achieving it is something to celebrate, but not something to hold against the language until much later on their development cycle, if at all.</div><br/></div></div></div></div><div id="36781551" class="c"><input type="checkbox" id="c-36781551" checked=""/><div class="controls bullet"><span class="by">ezekiel68</span><span>|</span><a href="#36780989">prev</a><span>|</span><a href="#36779614">next</a><span>|</span><label class="collapse" for="c-36781551">[-]</label><label class="expand" for="c-36781551">[4 more]</label></div><br/><div class="children"><div class="content">From the example on their home page:<p><pre><code>    ...no unnecessary allocation occurs.  The result of *longer_of* is a projection of the longer argument, so the mutation of z by *emphasize* occurs directly on the value of y. The value is neither copied, nor moved, and yet it is not being passed by reference to emphasize
</code></pre>
I&#x27;m not sure how to read this.  A string arg is supplied to a function and a character is (or characters are) appended to it.  How can this happen without a new copy of y, since that string must have had an initial lengh (and therefore, a specific place and size on the stack)?  Do they create strings with extra padding at the end, just in case someone might append to them?  (If so, how much padding and why isn&#x27;t that generally less efficient overall?)<p>Edit: I didn&#x27;t realize that asterisk bolding didn&#x27;t work in quotes.  Decided to leave it in anyway.</div><br/><div id="36783260" class="c"><input type="checkbox" id="c-36783260" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#36781551">parent</a><span>|</span><a href="#36782527">next</a><span>|</span><label class="collapse" for="c-36783260">[-]</label><label class="expand" for="c-36783260">[1 more]</label></div><br/><div class="children"><div class="content">The four space prefix is for code&#x2F;monospaced blocks, not really for quotes.<p>Generally on HN people (myself included) seem to use the &#x27;&gt; &#x27; tradition for quoting, which the parser doesn&#x27;t treat specially but works out fine.</div><br/></div></div><div id="36782527" class="c"><input type="checkbox" id="c-36782527" checked=""/><div class="controls bullet"><span class="by">zupa-hu</span><span>|</span><a href="#36781551">parent</a><span>|</span><a href="#36783260">prev</a><span>|</span><a href="#36781829">next</a><span>|</span><label class="collapse" for="c-36782527">[-]</label><label class="expand" for="c-36782527">[1 more]</label></div><br/><div class="children"><div class="content">Just because it is an immutable value doesn’t mean it needs to live on the stack.<p>That said, I was wondering about a similar thing: what if I modify a 1GB string? Is it copy-on-write?<p>I feel like it can be optimized away 99% of the time only to leave you with 1% of cases that result in very-hard-to-find performance degradations.</div><br/></div></div><div id="36781829" class="c"><input type="checkbox" id="c-36781829" checked=""/><div class="controls bullet"><span class="by">pmulard</span><span>|</span><a href="#36781551">parent</a><span>|</span><a href="#36782527">prev</a><span>|</span><a href="#36779614">next</a><span>|</span><label class="collapse" for="c-36781829">[-]</label><label class="expand" for="c-36781829">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s more of an explanation further down:<p><pre><code>   To better understand, notice that longer_of is not a function; it’s a subscript. A subscript does not return a value, it projects one, granting the caller temporary read and&#x2F;or write access to it.
</code></pre>
I&#x27;m not really sure how this doesn&#x27;t fall under a move? Regarding the string, they could also place it on the heap to allow for the variable sizing, which is what Rust does.</div><br/></div></div></div></div><div id="36779614" class="c"><input type="checkbox" id="c-36779614" checked=""/><div class="controls bullet"><span class="by">Narishma</span><span>|</span><a href="#36781551">prev</a><span>|</span><a href="#36780463">next</a><span>|</span><label class="collapse" for="c-36779614">[-]</label><label class="expand" for="c-36779614">[17 more]</label></div><br/><div class="children"><div class="content">So now we have V, Val, Vala, Vale. Any other language I&#x27;m forgetting?</div><br/><div id="36779990" class="c"><input type="checkbox" id="c-36779990" checked=""/><div class="controls bullet"><span class="by">porcoda</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36779662">next</a><span>|</span><label class="collapse" for="c-36779990">[-]</label><label class="expand" for="c-36779990">[2 more]</label></div><br/><div class="children"><div class="content">There’s also VAL, one of the 80s era languages that influenced Haskell (via SISAL).  Alas, outside the parallel languages community I don’t think many people are familiar with that VAL.</div><br/><div id="36780131" class="c"><input type="checkbox" id="c-36780131" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36779990">parent</a><span>|</span><a href="#36779662">next</a><span>|</span><label class="collapse" for="c-36780131">[-]</label><label class="expand" for="c-36780131">[1 more]</label></div><br/><div class="children"><div class="content">Variable Assembly Language!</div><br/></div></div></div></div><div id="36779662" class="c"><input type="checkbox" id="c-36779662" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36779990">prev</a><span>|</span><a href="#36781976">next</a><span>|</span><label class="collapse" for="c-36779662">[-]</label><label class="expand" for="c-36779662">[3 more]</label></div><br/><div class="children"><div class="content">It will work to their advantage. Anyone learning one of these language is looking for &quot;the new hotness&quot;, and will probably become aware of the other similarly named languages in the process, and will thus look them up. JavaScript did it, how did that turn out for them?</div><br/><div id="36779993" class="c"><input type="checkbox" id="c-36779993" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36779662">parent</a><span>|</span><a href="#36781976">next</a><span>|</span><label class="collapse" for="c-36779993">[-]</label><label class="expand" for="c-36779993">[2 more]</label></div><br/><div class="children"><div class="content">Javascript was the only game in town in the browser for cross-browser support.<p>The name didn&#x27;t matter at all, it could have been named Fooscript and still be popular.</div><br/><div id="36782540" class="c"><input type="checkbox" id="c-36782540" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36779993">parent</a><span>|</span><a href="#36781976">next</a><span>|</span><label class="collapse" for="c-36782540">[-]</label><label class="expand" for="c-36782540">[1 more]</label></div><br/><div class="children"><div class="content">Coulda named it after a skin disease!</div><br/></div></div></div></div></div></div><div id="36781976" class="c"><input type="checkbox" id="c-36781976" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36779662">prev</a><span>|</span><a href="#36779788">next</a><span>|</span><label class="collapse" for="c-36781976">[-]</label><label class="expand" for="c-36781976">[2 more]</label></div><br/><div class="children"><div class="content">V isn&#x27;t anything serious so you can take that off the list, at least</div><br/><div id="36783577" class="c"><input type="checkbox" id="c-36783577" checked=""/><div class="controls bullet"><span class="by">amedvednikov</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36781976">parent</a><span>|</span><a href="#36779788">next</a><span>|</span><label class="collapse" for="c-36783577">[-]</label><label class="expand" for="c-36783577">[1 more]</label></div><br/><div class="children"><div class="content">Why?<p>e.g. Here&#x27;s DOOM running in V (translated from C). Seems pretty serious.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6oXrz3oRoEg">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6oXrz3oRoEg</a></div><br/></div></div></div></div><div id="36779788" class="c"><input type="checkbox" id="c-36779788" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36781976">prev</a><span>|</span><a href="#36782799">next</a><span>|</span><label class="collapse" for="c-36779788">[-]</label><label class="expand" for="c-36779788">[4 more]</label></div><br/><div class="children"><div class="content">I legitimately thought this was Vale. Rather unfortunate collision in naming</div><br/><div id="36780027" class="c"><input type="checkbox" id="c-36780027" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36779788">parent</a><span>|</span><a href="#36781810">next</a><span>|</span><label class="collapse" for="c-36780027">[-]</label><label class="expand" for="c-36780027">[2 more]</label></div><br/><div class="children"><div class="content">They are trying to concentrate safe systems programming in permutations of V +{a,l,e}</div><br/><div id="36780253" class="c"><input type="checkbox" id="c-36780253" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36780027">parent</a><span>|</span><a href="#36781810">next</a><span>|</span><label class="collapse" for="c-36780253">[-]</label><label class="expand" for="c-36780253">[1 more]</label></div><br/><div class="children"><div class="content">There is a Beef programming language ... what about Veal?</div><br/></div></div></div></div><div id="36781810" class="c"><input type="checkbox" id="c-36781810" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36779788">parent</a><span>|</span><a href="#36780027">prev</a><span>|</span><a href="#36782799">next</a><span>|</span><label class="collapse" for="c-36781810">[-]</label><label class="expand" for="c-36781810">[1 more]</label></div><br/><div class="children"><div class="content">We all just have similarly good taste in naming =) party on this end of the alphabet!</div><br/></div></div></div></div><div id="36782799" class="c"><input type="checkbox" id="c-36782799" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36779788">prev</a><span>|</span><a href="#36779808">next</a><span>|</span><label class="collapse" for="c-36782799">[-]</label><label class="expand" for="c-36782799">[2 more]</label></div><br/><div class="children"><div class="content">Vau comes to mind.</div><br/><div id="36783269" class="c"><input type="checkbox" id="c-36783269" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#36779614">root</a><span>|</span><a href="#36782799">parent</a><span>|</span><a href="#36779808">next</a><span>|</span><label class="collapse" for="c-36783269">[-]</label><label class="expand" for="c-36783269">[1 more]</label></div><br/><div class="children"><div class="content">Only allowed if it&#x27;s fexpr based though.</div><br/></div></div></div></div><div id="36779808" class="c"><input type="checkbox" id="c-36779808" checked=""/><div class="controls bullet"><span class="by">TiredGuy</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36782799">prev</a><span>|</span><a href="#36780947">next</a><span>|</span><label class="collapse" for="c-36779808">[-]</label><label class="expand" for="c-36779808">[1 more]</label></div><br/><div class="children"><div class="content">and you can code with them inside vi or vim!</div><br/></div></div><div id="36780947" class="c"><input type="checkbox" id="c-36780947" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36779808">prev</a><span>|</span><a href="#36779892">next</a><span>|</span><label class="collapse" for="c-36780947">[-]</label><label class="expand" for="c-36780947">[1 more]</label></div><br/><div class="children"><div class="content">Volt</div><br/></div></div><div id="36779892" class="c"><input type="checkbox" id="c-36779892" checked=""/><div class="controls bullet"><span class="by">bibanez</span><span>|</span><a href="#36779614">parent</a><span>|</span><a href="#36780947">prev</a><span>|</span><a href="#36780463">next</a><span>|</span><label class="collapse" for="c-36779892">[-]</label><label class="expand" for="c-36779892">[1 more]</label></div><br/><div class="children"><div class="content">Valtown</div><br/></div></div></div></div><div id="36780463" class="c"><input type="checkbox" id="c-36780463" checked=""/><div class="controls bullet"><span class="by">yeputons</span><span>|</span><a href="#36779614">prev</a><span>|</span><a href="#36779378">next</a><span>|</span><label class="collapse" for="c-36780463">[-]</label><label class="expand" for="c-36780463">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve skimmed through the &quot;mutable value semantics&quot; paper: do I understand correctly that authors suggest replacing references and pointers with either: a) nested structs (with some indirection via `Any` with runtime-checks); b) array indices?<p>The following phrases got my eye: &quot;It is reasonable to ask, then, how we can use mutable value types to represent self-referential data structures, such as
doubly linked lists and directed graphs. In fact, any arbitrary graph can be represented as an adjacency list. For example, a vertex set might be represented as an array, each element of which contains an array of outgoing
edge destination indices.&quot;.  I don&#x27;t see how one can reasonably implement doubly-linked list without re-inventing memory heap and some kind of garbage collection in the implementation.<p>UPD: found some discussion at <a href="https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;val-lang&#x2F;discussions&#x2F;736">https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;val-lang&#x2F;discussions&#x2F;736</a> , seems that there will be some escape hatches akin to Rust&#x27;s `unsafe`. That resolves all issues, and &quot;whether the safe subset of Val is enough for reasonable application&quot; question is open to long years of debate.</div><br/><div id="36780580" class="c"><input type="checkbox" id="c-36780580" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36780463">parent</a><span>|</span><a href="#36779378">next</a><span>|</span><label class="collapse" for="c-36780580">[-]</label><label class="expand" for="c-36780580">[2 more]</label></div><br/><div class="children"><div class="content">Indeed, you can reinvent memory by using arrays, and using array indices instead of pointers.<p>It&#x27;s much less silly than one could think, because these indices are locked to your particular data structure (doubly-linked list, graph, etc) and cannot be manipulated to access anything else in the program, at least not easily. This applies bot to the compiler checking that, and to the attempts to crack the program.</div><br/><div id="36780672" class="c"><input type="checkbox" id="c-36780672" checked=""/><div class="controls bullet"><span class="by">yeputons</span><span>|</span><a href="#36780463">root</a><span>|</span><a href="#36780580">parent</a><span>|</span><a href="#36779378">next</a><span>|</span><label class="collapse" for="c-36780672">[-]</label><label class="expand" for="c-36780672">[1 more]</label></div><br/><div class="children"><div class="content">&gt; these indices are locked to your particular data structure<p>Are they, though? Consider I have a linked list (or a map&#x2F;dictionary, or any data structure that allows removal of arbitrary elements). I add elements with indices 1, 2, 3, 4, 5. I remove elements with indices 2 and 4. I&#x27;d like to make memory consumed by these elements available again. At the same time I don&#x27;t want to change indexing scheme of the whole data structure. So I have to keep &quot;holes&quot; with indices 2 and 4 at the very least. After few million operations that may become very inefficient.<p>In a typical language, that would be resolved by having a global allocator that allows indices 2 and 4 to be reused in neighboring data structures. If I don&#x27;t implement a global allocator that shares indices between objects (as that kills the whole point), I consume more memory than needed and rely on my own clunky implementation of garbage collection&#x2F;defragmentation, don&#x27;t I?</div><br/></div></div></div></div></div></div><div id="36779378" class="c"><input type="checkbox" id="c-36779378" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#36780463">prev</a><span>|</span><a href="#36779176">next</a><span>|</span><label class="collapse" for="c-36779378">[-]</label><label class="expand" for="c-36779378">[4 more]</label></div><br/><div class="children"><div class="content">It’s brought up every time, but the only thing I don’t like about Val is that Vale and V are two other systems languages that are also new.  Those three can so easily be mixed up because of naming.</div><br/><div id="36779511" class="c"><input type="checkbox" id="c-36779511" checked=""/><div class="controls bullet"><span class="by">jgilias</span><span>|</span><a href="#36779378">parent</a><span>|</span><a href="#36780718">next</a><span>|</span><label class="collapse" for="c-36779511">[-]</label><label class="expand" for="c-36779511">[1 more]</label></div><br/><div class="children"><div class="content">There’s also Vala. A somewhat different niche, but one more similarly named language.</div><br/></div></div><div id="36780718" class="c"><input type="checkbox" id="c-36780718" checked=""/><div class="controls bullet"><span class="by">khaledh</span><span>|</span><a href="#36779378">parent</a><span>|</span><a href="#36779511">prev</a><span>|</span><a href="#36779572">next</a><span>|</span><label class="collapse" for="c-36780718">[-]</label><label class="expand" for="c-36780718">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also VAL: Variable Assembly Language <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Variable_Assembly_Language" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Variable_Assembly_Language</a></div><br/></div></div><div id="36779572" class="c"><input type="checkbox" id="c-36779572" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#36779378">parent</a><span>|</span><a href="#36780718">prev</a><span>|</span><a href="#36779176">next</a><span>|</span><label class="collapse" for="c-36779572">[-]</label><label class="expand" for="c-36779572">[1 more]</label></div><br/><div class="children"><div class="content">Had to go to the link to confirm whether this was the projection language or the region language.</div><br/></div></div></div></div><div id="36779176" class="c"><input type="checkbox" id="c-36779176" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36779378">prev</a><span>|</span><a href="#36781899">next</a><span>|</span><label class="collapse" for="c-36779176">[-]</label><label class="expand" for="c-36779176">[1 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>Val, a new programing language inspired by Swift and Rust</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31788527">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31788527</a> - June 2022 (19 comments)</div><br/></div></div><div id="36781899" class="c"><input type="checkbox" id="c-36781899" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#36779176">prev</a><span>|</span><a href="#36782805">next</a><span>|</span><label class="collapse" for="c-36781899">[-]</label><label class="expand" for="c-36781899">[2 more]</label></div><br/><div class="children"><div class="content">The thing I haven’t seen yet that makes me raise my eyebrows is sharing one allocation between two data structure. That’s where things get really gnarly with Rust references. The borrow checker is extremely easy to deal with until you start trying to store references in structs, yet the examples I’ve seen with Val don’t show that.<p>Maybe these cases can be simplified, but I’m very skeptical. It’s a fundamentally difficult problem domain considering that these cases are also very difficult to reason about in C&#x2F;C++. Questions like: will this request last longer than the current thread?</div><br/><div id="36782035" class="c"><input type="checkbox" id="c-36782035" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36781899">parent</a><span>|</span><a href="#36782805">next</a><span>|</span><label class="collapse" for="c-36782035">[-]</label><label class="expand" for="c-36782035">[1 more]</label></div><br/><div class="children"><div class="content">Unless  I got mixed up, from what I remember of previous article it’s because that’s not possible. Val’s references are not first-class, you can’t return or store them.</div><br/></div></div></div></div><div id="36782805" class="c"><input type="checkbox" id="c-36782805" checked=""/><div class="controls bullet"><span class="by">ofrzeta</span><span>|</span><a href="#36781899">prev</a><span>|</span><a href="#36782387">next</a><span>|</span><label class="collapse" for="c-36782805">[-]</label><label class="expand" for="c-36782805">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Our goals overlap substantially with that of Rust and other commendable efforts, such as Zig or Vale&quot; - oh well, but not with Vala, I guess?</div><br/><div id="36783291" class="c"><input type="checkbox" id="c-36783291" checked=""/><div class="controls bullet"><span class="by">EspressoGPT</span><span>|</span><a href="#36782805">parent</a><span>|</span><a href="#36782387">next</a><span>|</span><label class="collapse" for="c-36783291">[-]</label><label class="expand" for="c-36783291">[1 more]</label></div><br/><div class="children"><div class="content">Val overlaps with Vale but not with V and Vala. :D</div><br/></div></div></div></div><div id="36782387" class="c"><input type="checkbox" id="c-36782387" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#36782805">prev</a><span>|</span><a href="#36780384">next</a><span>|</span><label class="collapse" for="c-36782387">[-]</label><label class="expand" for="c-36782387">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Integer numbers are typically represented by the type Int, which represents a machine-size integer (usually 64 bits on modern computers).<p>I&#x27;m not a systems programmer, but I thought there was a consensus these days that this was a Bad Idea™? Are the benefits of marginally better performance on certain platforms really worth having your program break due to an overflow when you run it on a different platform?</div><br/><div id="36782429" class="c"><input type="checkbox" id="c-36782429" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#36782387">parent</a><span>|</span><a href="#36780384">next</a><span>|</span><label class="collapse" for="c-36782429">[-]</label><label class="expand" for="c-36782429">[1 more]</label></div><br/><div class="children"><div class="content">Zig has both fixed size types and a native-pointer-sized type. I think it&#x27;s the right approach, in general you need both.</div><br/></div></div></div></div><div id="36780384" class="c"><input type="checkbox" id="c-36780384" checked=""/><div class="controls bullet"><span class="by">Jenz</span><span>|</span><a href="#36782387">prev</a><span>|</span><a href="#36779506">next</a><span>|</span><label class="collapse" for="c-36780384">[-]</label><label class="expand" for="c-36780384">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The result of `longer_of` is a <i>projection</i> of the longer argument, so the mutation of `z` by `emphasize` occurs directly on the value of `y`. The value is neither copied, nor moved, and yet it is not being passed by reference to `emphasize`. The body of `emphasize` <i>owns</i> `z` in exactly the same way as it owns `strength`, which is passed by value: `z` is an independent value that can only be touched by `emphasize`.<p>This evasive phrasing, which continuoes after this excerpt too, has me highly skeptical of their good intentions… Any good reason they are not more explicit?</div><br/><div id="36781142" class="c"><input type="checkbox" id="c-36781142" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36780384">parent</a><span>|</span><a href="#36779506">next</a><span>|</span><label class="collapse" for="c-36781142">[-]</label><label class="expand" for="c-36781142">[1 more]</label></div><br/><div class="children"><div class="content">What evasiveness? To me it is very clear what is going on.</div><br/></div></div></div></div><div id="36779506" class="c"><input type="checkbox" id="c-36779506" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36780384">prev</a><span>|</span><a href="#36780654">next</a><span>|</span><label class="collapse" for="c-36779506">[-]</label><label class="expand" for="c-36779506">[19 more]</label></div><br/><div class="children"><div class="content">edit: these comments are general, not directed at Val.<p>A humble suggestion to anyone coming up with a new language.<p><i>Please</i> make it as familiar as possible.<p>For example, do you really need to come up with some new syntax for defining a function, or specifying types and returns?<p>If you want people to use your new language, reduce the cognitive load - do things the same as other languages and be different only where you must.<p>Every time you come up with some completely alien programming construct, you have set a barrier to learning.  Coming up with a new language should, for the most part, be an exercise in copying the best of how other <i>extremely popular</i> languages do things, and on top of that build in the necessary differences that make your language special.<p>Also, less is more.  For example, one of the reasons Rust is so complex and intimidating is it has six sublanguages <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;brendanzab&#x2F;d41c3ae485d66c07178749eaeeb9e5f7" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;brendanzab&#x2F;d41c3ae485d66c07178749eae...</a><p><pre><code>    the expression language
        unsafe runtime language
        safe runtime language
        compile time language
    the type language
    the trait language
    the macro language
    the attribute language
</code></pre>
Whereas Zig goes the other direction and attempts to make everything programmable in the one core language, even ditching macros entirely. <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;overview&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;overview&#x2F;</a>. In Zig you can write compile time code in the same language and same code base.<p>I put forward these suggestions not as a language edxpert - I am far from it - instead I put them forward as a frustrated learner wanting to do new things and looking at new languages and thinking &quot;shit, I already work with three of four languages plus any number of subtechnologies on a given system, I just don&#x27;t have time&#x2F;headspace to learn a programming language with six sub languages&quot;.</div><br/><div id="36779575" class="c"><input type="checkbox" id="c-36779575" checked=""/><div class="controls bullet"><span class="by">pkkm</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779578">next</a><span>|</span><label class="collapse" for="c-36779575">[-]</label><label class="expand" for="c-36779575">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. Syntax is the thing everyone loves to comment on because of the bikeshed effect, but it&#x27;s probably the quickest aspect of a new language to learn. If you&#x27;re already creating a new language and have the opportunity to fix some things that make older languages harder to remember, parse, or type, why not take it?</div><br/></div></div><div id="36779578" class="c"><input type="checkbox" id="c-36779578" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779575">prev</a><span>|</span><a href="#36779642">next</a><span>|</span><label class="collapse" for="c-36779578">[-]</label><label class="expand" for="c-36779578">[3 more]</label></div><br/><div class="children"><div class="content">Alternatively, where the semantics are different to existing languages, try to make the syntax different too. Languages which look the same as existing ones and behave differently are pretty rough going for newcomers and anyone programming in multiple languages.</div><br/><div id="36780080" class="c"><input type="checkbox" id="c-36780080" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36779578">parent</a><span>|</span><a href="#36779640">next</a><span>|</span><label class="collapse" for="c-36780080">[-]</label><label class="expand" for="c-36780080">[1 more]</label></div><br/><div class="children"><div class="content">One reason I prefer Erlang to Elixir is that I appreciate the fact that Erlang syntax is very different, and I feel like it helps me <i>think</i> in Erlang. I don’t think about Python or Ruby.</div><br/></div></div><div id="36779640" class="c"><input type="checkbox" id="c-36779640" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36779578">parent</a><span>|</span><a href="#36780080">prev</a><span>|</span><a href="#36779642">next</a><span>|</span><label class="collapse" for="c-36779640">[-]</label><label class="expand" for="c-36779640">[1 more]</label></div><br/><div class="children"><div class="content">I probably should have said &quot;did you really need the syntax <i>and the behavior</i> to be different?&quot;<p>My point is not so much about syntax, it is about <i>unnecessarily</i> doing things in a conceptually different way.<p>If different behavior at a given point is core to what makes your language special then sure thing, make it behave different, but implementing some different behavior without a significant payoff only makes your new language harder to grasp.<p>Presumably you are making a language because you have some core concepts or beliefs you want to bring to life - all I&#x27;m saying is - make that happen, and make the rest as familiar as possible for most programmers.</div><br/></div></div></div></div><div id="36779642" class="c"><input type="checkbox" id="c-36779642" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779578">prev</a><span>|</span><a href="#36779729">next</a><span>|</span><label class="collapse" for="c-36779642">[-]</label><label class="expand" for="c-36779642">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of Bjarne Stroustrup talking about how every time they add a new feature to the language, it&#x27;s unfamiliar to anyone so everyone wants it to be REALLY LOUD AND OBVIOUS.  &quot;Stand back! I&#x27;m going to use a LAMBDA here!&quot;  But, after a short time, the new features are so common and familiar that everyone starts complaining about how loud they are. &quot;Why is the syntax for lambdas so noisy! [](){}! Gah!  Can we at least make the () optional to quiet it down a bit??&quot;</div><br/></div></div><div id="36779729" class="c"><input type="checkbox" id="c-36779729" checked=""/><div class="controls bullet"><span class="by">jgilias</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779642">prev</a><span>|</span><a href="#36779566">next</a><span>|</span><label class="collapse" for="c-36779729">[-]</label><label class="expand" for="c-36779729">[1 more]</label></div><br/><div class="children"><div class="content">They do have a good reason to do what they do though. They explicitly say that they’re going for a language where you can pretend there are no references and things are just mutable values. And you can’t really do this without coming up with new names. Because of course there are references under the hood.<p>If Rust goes the explicit modifier route, e.g. something can be &amp; and also mut, and you need to know what these are, Val goes the implied behavior route where a ‘set’ parameter can be set, while a ‘let’ parameter can’t.<p>If they didn’t come up with new semantics, they’d just be making a Rust clone. I for one am very looking forward to how Val develops. Currently it seems like it can offer similar guarantees to Rust while using a simpler mental model to deal with.<p>I’m curious to see how they are going to tackle concurrency. Their roadmap outlines that as one of the trickier parts given the semantics that they’re going for.</div><br/></div></div><div id="36779566" class="c"><input type="checkbox" id="c-36779566" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779729">prev</a><span>|</span><a href="#36779728">next</a><span>|</span><label class="collapse" for="c-36779566">[-]</label><label class="expand" for="c-36779566">[5 more]</label></div><br/><div class="children"><div class="content">This syntax looks almost exactly like Swift, which is also where it borrows its semantics from.</div><br/><div id="36780485" class="c"><input type="checkbox" id="c-36780485" checked=""/><div class="controls bullet"><span class="by">turnsout</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36779566">parent</a><span>|</span><a href="#36779728">next</a><span>|</span><label class="collapse" for="c-36780485">[-]</label><label class="expand" for="c-36780485">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, it feels like Swift with lifetimes (which are coming to Swift). Other than the abstract benefits of mutable value semantics for generics, I wonder what would make one reach for Val over Swift (or going the other way, Rust)</div><br/><div id="36782559" class="c"><input type="checkbox" id="c-36782559" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36780485">parent</a><span>|</span><a href="#36779728">next</a><span>|</span><label class="collapse" for="c-36782559">[-]</label><label class="expand" for="c-36782559">[3 more]</label></div><br/><div class="children"><div class="content">Adobe likes Swift, but doesn&#x27;t think it will ever strive outside Apple&#x27;s ecosystem, as it was it Objective-C as well.<p>Additionally Dave Abrahms would like to have another go at designing Swift.</div><br/><div id="36782574" class="c"><input type="checkbox" id="c-36782574" checked=""/><div class="controls bullet"><span class="by">Apocryphon</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36782559">parent</a><span>|</span><a href="#36779728">next</a><span>|</span><label class="collapse" for="c-36782574">[-]</label><label class="expand" for="c-36782574">[2 more]</label></div><br/><div class="children"><div class="content">Wait a second, isn’t Mojo supposed to be the Swift but better language- there’s another one already?<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36281245">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36281245</a></div><br/><div id="36782585" class="c"><input type="checkbox" id="c-36782585" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36782574">parent</a><span>|</span><a href="#36779728">next</a><span>|</span><label class="collapse" for="c-36782585">[-]</label><label class="expand" for="c-36782585">[1 more]</label></div><br/><div class="children"><div class="content">Surprise it turns out various Swift designers have different points of view.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36779728" class="c"><input type="checkbox" id="c-36779728" checked=""/><div class="controls bullet"><span class="by">adamwk</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779566">prev</a><span>|</span><a href="#36781098">next</a><span>|</span><label class="collapse" for="c-36779728">[-]</label><label class="expand" for="c-36779728">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s unfamiliar about Val? It looks very similar to most languages released in the past 10 years with minor changes.</div><br/></div></div><div id="36781098" class="c"><input type="checkbox" id="c-36781098" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779728">prev</a><span>|</span><a href="#36779633">next</a><span>|</span><label class="collapse" for="c-36781098">[-]</label><label class="expand" for="c-36781098">[1 more]</label></div><br/><div class="children"><div class="content">I disagree with this a lot.<p>I think most programmers have been trained to think that C like syntax and semantics is fundamental to programming languages, as if languages are just inherently C like, and that C is just what programming is, but this is not true.<p>Programming language theory is an entire field of study on it&#x27;s own, and there are a lot more possibilities than just rehashing C for the nth time.</div><br/></div></div><div id="36779633" class="c"><input type="checkbox" id="c-36779633" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36781098">prev</a><span>|</span><a href="#36780481">next</a><span>|</span><label class="collapse" for="c-36779633">[-]</label><label class="expand" for="c-36779633">[2 more]</label></div><br/><div class="children"><div class="content">I never get this argument. The syntax is important for consistency, but in another sense is trivial. It&#x27;s the smallest thing about a new language that you have to learn, I don&#x27;t understand why people get hung up on it.</div><br/><div id="36779999" class="c"><input type="checkbox" id="c-36779999" checked=""/><div class="controls bullet"><span class="by">stusmall</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36779633">parent</a><span>|</span><a href="#36780481">next</a><span>|</span><label class="collapse" for="c-36779999">[-]</label><label class="expand" for="c-36779999">[1 more]</label></div><br/><div class="children"><div class="content">I often find people get very hung up on it because they don&#x27;t have much else to talk about.  The look and feel of the syntax is the least important part of a language but its also the easiest to complain about.</div><br/></div></div></div></div><div id="36780481" class="c"><input type="checkbox" id="c-36780481" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#36779506">parent</a><span>|</span><a href="#36779633">prev</a><span>|</span><a href="#36780654">next</a><span>|</span><label class="collapse" for="c-36780481">[-]</label><label class="expand" for="c-36780481">[2 more]</label></div><br/><div class="children"><div class="content">Clearly, this is why Rust has been unsuccessful. &#x2F;s<p>But seriously, if you aren&#x27;t doing something really different, why bother.  If you find Popular Language X (PLX) too limiting, there&#x27;s probably a dozen or two &quot;it&#x27;s just like PLX, but with a sprinkling of things from Y, which is pretty much like PLX, but sweeter sugar, and that makes it <i>perfect</i>&quot;.  As others have pointed out, syntax is trivia[1].<p>[1] Unless, of course, you think a BEGIN..END language is nifty, and then you&#x27;re a heretic and someone is coming with torches and pitchforks. :-)</div><br/><div id="36780525" class="c"><input type="checkbox" id="c-36780525" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#36779506">root</a><span>|</span><a href="#36780481">parent</a><span>|</span><a href="#36780654">next</a><span>|</span><label class="collapse" for="c-36780525">[-]</label><label class="expand" for="c-36780525">[1 more]</label></div><br/><div class="children"><div class="content">P.S. - I&#x27;m not talking about PL&#x2F;X, which is a thing, because of course it is.  PL&#x2F;I with some PL.8 and PL&#x2F;S, and probably some PL&#x2F;M.  Nope...not joking.</div><br/></div></div></div></div></div></div><div id="36780654" class="c"><input type="checkbox" id="c-36780654" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#36779506">prev</a><span>|</span><a href="#36782795">next</a><span>|</span><label class="collapse" for="c-36780654">[-]</label><label class="expand" for="c-36780654">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very happy to see continued investment into mutable value semantics. When I was writing Swift, it felt absolutely magical to have most of the guarantees of functional programming without the performance penalty and intermittent awkwardness.<p>Val just doubles down on the ideas in Swift and goes so far as to remove references altogether. This is a really interesting space.</div><br/></div></div><div id="36782795" class="c"><input type="checkbox" id="c-36782795" checked=""/><div class="controls bullet"><span class="by">asimpletune</span><span>|</span><a href="#36780654">prev</a><span>|</span><a href="#36779798">next</a><span>|</span><label class="collapse" for="c-36782795">[-]</label><label class="expand" for="c-36782795">[2 more]</label></div><br/><div class="children"><div class="content">Basic question, but if there are no references and it’s all values all day long, then how do strings, arrays, and other types where the size unknown at compile time work?<p>I saw the example they gave, which is cool, but they were with string literals. So, per my question above, how would the same program work if the strings came from user input?</div><br/><div id="36782804" class="c"><input type="checkbox" id="c-36782804" checked=""/><div class="controls bullet"><span class="by">superlopuh</span><span>|</span><a href="#36782795">parent</a><span>|</span><a href="#36779798">next</a><span>|</span><label class="collapse" for="c-36782804">[-]</label><label class="expand" for="c-36782804">[1 more]</label></div><br/><div class="children"><div class="content">In my understanding, there are still pointers under the hood, they&#x27;re just not exposed as such in the type system. If you can&#x27;t copy a pointer you can&#x27;t alias, so they&#x27;re indistinguishable from the value itself in practice.</div><br/></div></div></div></div><div id="36779798" class="c"><input type="checkbox" id="c-36779798" checked=""/><div class="controls bullet"><span class="by">bsaul</span><span>|</span><a href="#36782795">prev</a><span>|</span><a href="#36782249">next</a><span>|</span><label class="collapse" for="c-36779798">[-]</label><label class="expand" for="c-36779798">[4 more]</label></div><br/><div class="children"><div class="content">How come this page reaches top of HN ? Has anything new happened to this language ?<p>I was hoping there was because i liked the idea when it was announced a year ago, but the page doesn’t seem to show anything new.</div><br/><div id="36779807" class="c"><input type="checkbox" id="c-36779807" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#36779798">parent</a><span>|</span><a href="#36782567">next</a><span>|</span><label class="collapse" for="c-36779807">[-]</label><label class="expand" for="c-36779807">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like the second-hand clothing store in my town that used to be called &quot;New to you&quot;.</div><br/></div></div><div id="36782567" class="c"><input type="checkbox" id="c-36782567" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779798">parent</a><span>|</span><a href="#36779807">prev</a><span>|</span><a href="#36780730">next</a><span>|</span><label class="collapse" for="c-36782567">[-]</label><label class="expand" for="c-36782567">[1 more]</label></div><br/><div class="children"><div class="content">Now it has official backing from Adobe, if you listen to ADSP Podcast.</div><br/></div></div></div></div><div id="36782249" class="c"><input type="checkbox" id="c-36782249" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#36779798">prev</a><span>|</span><a href="#36778938">next</a><span>|</span><label class="collapse" for="c-36782249">[-]</label><label class="expand" for="c-36782249">[1 more]</label></div><br/><div class="children"><div class="content">In addition to Val and Vale, there is also Vala: <a href="https:&#x2F;&#x2F;vala.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;vala.dev&#x2F;</a></div><br/></div></div><div id="36778938" class="c"><input type="checkbox" id="c-36778938" checked=""/><div class="controls bullet"><span class="by">xmonkee</span><span>|</span><a href="#36782249">prev</a><span>|</span><a href="#36781959">next</a><span>|</span><label class="collapse" for="c-36778938">[-]</label><label class="expand" for="c-36778938">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the better (and better looking) landing pages I have seen for a programming language. Very good copywriting too.</div><br/></div></div><div id="36781959" class="c"><input type="checkbox" id="c-36781959" checked=""/><div class="controls bullet"><span class="by">1732050</span><span>|</span><a href="#36778938">prev</a><span>|</span><a href="#36782365">next</a><span>|</span><label class="collapse" for="c-36781959">[-]</label><label class="expand" for="c-36781959">[1 more]</label></div><br/><div class="children"><div class="content">For me I&#x27;m interested in the type system provided by a language.<p>For Val, I was a little hesitant when I saw the docs say &quot;Two or more types can form a union type, also known as a sum type.&quot; since a union type and a sum type are similar but distinct concepts.<p>For a language, it is very important to understand the differences between these because I think they will greatly impact the design of the language.</div><br/></div></div><div id="36782365" class="c"><input type="checkbox" id="c-36782365" checked=""/><div class="controls bullet"><span class="by">ram_rar</span><span>|</span><a href="#36781959">prev</a><span>|</span><a href="#36779671">next</a><span>|</span><label class="collapse" for="c-36782365">[-]</label><label class="expand" for="c-36782365">[1 more]</label></div><br/><div class="children"><div class="content">I often contemplate whether programming language designers consider the developer experience during the design process. Merely perusing the sample code on their web page causes discomfort in my eyes.</div><br/></div></div><div id="36779671" class="c"><input type="checkbox" id="c-36779671" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#36782365">prev</a><span>|</span><a href="#36779405">next</a><span>|</span><label class="collapse" for="c-36779671">[-]</label><label class="expand" for="c-36779671">[3 more]</label></div><br/><div class="children"><div class="content">Really interesting concepts here, especially subscripts (which neatly solve an issue that RAAI semantics or lambdas are usually hacked into solving).<p>Is my reading of overloads correct? Identically-named methods are supported, but only for different argument labels and&#x2F;or calling conventions?<p>Rust convinced me that dispatching based on argument types is a poor idea, because Vec::new(10) could only be understood by reading the documentation at least once - whereas Vec::with_capacity(10) is abundantly clear. Val seems to gain these benefits (assuming that it doesn&#x27;t dispatch based on type) without the drawbacks.</div><br/><div id="36779746" class="c"><input type="checkbox" id="c-36779746" checked=""/><div class="controls bullet"><span class="by">adamwk</span><span>|</span><a href="#36779671">parent</a><span>|</span><a href="#36780108">next</a><span>|</span><label class="collapse" for="c-36779746">[-]</label><label class="expand" for="c-36779746">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re correct; Since argument labels are really part of the function name, you can say all function names must be unique</div><br/></div></div><div id="36780108" class="c"><input type="checkbox" id="c-36780108" checked=""/><div class="controls bullet"><span class="by">germandiago</span><span>|</span><a href="#36779671">parent</a><span>|</span><a href="#36779746">prev</a><span>|</span><a href="#36779405">next</a><span>|</span><label class="collapse" for="c-36780108">[-]</label><label class="expand" for="c-36780108">[1 more]</label></div><br/><div class="children"><div class="content">What about generic code?</div><br/></div></div></div></div><div id="36779405" class="c"><input type="checkbox" id="c-36779405" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36779671">prev</a><span>|</span><a href="#36780147">next</a><span>|</span><label class="collapse" for="c-36779405">[-]</label><label class="expand" for="c-36779405">[3 more]</label></div><br/><div class="children"><div class="content">Anyone got an opinion on Embedded C++, a C++ subset&#x2F;dialect?<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Embedded_C%2B%2B" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Embedded_C%2B%2B</a></div><br/><div id="36779454" class="c"><input type="checkbox" id="c-36779454" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36779405">parent</a><span>|</span><a href="#36780147">next</a><span>|</span><label class="collapse" for="c-36779454">[-]</label><label class="expand" for="c-36779454">[2 more]</label></div><br/><div class="children"><div class="content">Ah yes, the languages that eschews namespaces and static,reinterpret_cast, major sources of issues on embedded platforms.</div><br/><div id="36782442" class="c"><input type="checkbox" id="c-36782442" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36779405">root</a><span>|</span><a href="#36779454">parent</a><span>|</span><a href="#36780147">next</a><span>|</span><label class="collapse" for="c-36782442">[-]</label><label class="expand" for="c-36782442">[1 more]</label></div><br/><div class="children"><div class="content">Still better than plain old C, and used as inspiration for IO Kit allowed subset.</div><br/></div></div></div></div></div></div><div id="36780147" class="c"><input type="checkbox" id="c-36780147" checked=""/><div class="controls bullet"><span class="by">hcarvalhoalves</span><span>|</span><a href="#36779405">prev</a><span>|</span><a href="#36781104">next</a><span>|</span><label class="collapse" for="c-36780147">[-]</label><label class="expand" for="c-36780147">[5 more]</label></div><br/><div class="children"><div class="content">Do these terms (“subscript”, “projection”) have a deeper meaning - maybe from another discipline - or are these  terms arbitrarily chosen to explain the abstractions of the language?</div><br/><div id="36780256" class="c"><input type="checkbox" id="c-36780256" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#36780147">parent</a><span>|</span><a href="#36781170">next</a><span>|</span><label class="collapse" for="c-36780256">[-]</label><label class="expand" for="c-36780256">[3 more]</label></div><br/><div class="children"><div class="content">“Projection” is often used in functional programming to mean a function that picks a value out of a tuple, e.g. `fst (x,y)` returns x (the first element of the tuple) which is like projecting a vector onto an axis.</div><br/><div id="36780431" class="c"><input type="checkbox" id="c-36780431" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36780147">root</a><span>|</span><a href="#36780256">parent</a><span>|</span><a href="#36781170">next</a><span>|</span><label class="collapse" for="c-36780431">[-]</label><label class="expand" for="c-36780431">[2 more]</label></div><br/><div class="children"><div class="content">Projection is also a similar (but more general) operation in relational algebra (i.e. SELECT in SQL).</div><br/><div id="36781562" class="c"><input type="checkbox" id="c-36781562" checked=""/><div class="controls bullet"><span class="by">ufogigf</span><span>|</span><a href="#36780147">root</a><span>|</span><a href="#36780431">parent</a><span>|</span><a href="#36781170">next</a><span>|</span><label class="collapse" for="c-36781562">[-]</label><label class="expand" for="c-36781562">[1 more]</label></div><br/><div class="children"><div class="content">Very straightforwardly: the two terms come from mathematics.<p>&quot;Subscripts are often used to refer to members of a mathematical sequence or set or elements of a vector. For example, in the sequence O = (45, −2, 800), O₃ refers to the third member of sequence O, which is 800.&quot; (Wikipedia)<p>As fanf2 said, projection in software typically refers to selecting one element of a tuple.<p>&quot;[Projection is] An operation typified by the jth projection map, written projⱼ, that takes an element x = (x₁, ..., x ⱼ , ..., xₙ) of the Cartesian product X₁ × ⋯ × Xⱼ × ⋯ × Xₙ to the value projⱼ(x) = xⱼ&quot; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Projection_(mathematics)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Projection_(mathematics)</a></div><br/></div></div></div></div></div></div><div id="36781170" class="c"><input type="checkbox" id="c-36781170" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36780147">parent</a><span>|</span><a href="#36780256">prev</a><span>|</span><a href="#36781104">next</a><span>|</span><label class="collapse" for="c-36781170">[-]</label><label class="expand" for="c-36781170">[1 more]</label></div><br/><div class="children"><div class="content">They are meant to be evocative, but it is best to consider them as arbitrary tokens. There is no close analog in other languages.</div><br/></div></div></div></div><div id="36781104" class="c"><input type="checkbox" id="c-36781104" checked=""/><div class="controls bullet"><span class="by">tobinfricke</span><span>|</span><a href="#36780147">prev</a><span>|</span><a href="#36779934">next</a><span>|</span><label class="collapse" for="c-36781104">[-]</label><label class="expand" for="c-36781104">[5 more]</label></div><br/><div class="children"><div class="content">Not to be confused with <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Vala_(programming_language)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Vala_(programming_language)</a></div><br/><div id="36781110" class="c"><input type="checkbox" id="c-36781110" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#36781104">parent</a><span>|</span><a href="#36779934">next</a><span>|</span><label class="collapse" for="c-36781110">[-]</label><label class="expand" for="c-36781110">[4 more]</label></div><br/><div class="children"><div class="content">Or Vale <a href="https:&#x2F;&#x2F;vale.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;vale.dev&#x2F;</a></div><br/><div id="36781226" class="c"><input type="checkbox" id="c-36781226" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#36781104">root</a><span>|</span><a href="#36781110">parent</a><span>|</span><a href="#36782771">next</a><span>|</span><label class="collapse" for="c-36781226">[-]</label><label class="expand" for="c-36781226">[2 more]</label></div><br/><div class="children"><div class="content">Or the other Vale! <a href="https:&#x2F;&#x2F;vale.sh&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;vale.sh&#x2F;</a></div><br/><div id="36781595" class="c"><input type="checkbox" id="c-36781595" checked=""/><div class="controls bullet"><span class="by">ezekiel68</span><span>|</span><a href="#36781104">root</a><span>|</span><a href="#36781226">parent</a><span>|</span><a href="#36782771">next</a><span>|</span><label class="collapse" for="c-36781595">[-]</label><label class="expand" for="c-36781595">[1 more]</label></div><br/><div class="children"><div class="content">Nor with Valgrind <a href="https:&#x2F;&#x2F;valgrind.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;valgrind.org&#x2F;</a></div><br/></div></div></div></div><div id="36782771" class="c"><input type="checkbox" id="c-36782771" checked=""/><div class="controls bullet"><span class="by">hoseja</span><span>|</span><a href="#36781104">root</a><span>|</span><a href="#36781110">parent</a><span>|</span><a href="#36781226">prev</a><span>|</span><a href="#36779934">next</a><span>|</span><label class="collapse" for="c-36782771">[-]</label><label class="expand" for="c-36782771">[1 more]</label></div><br/><div class="children"><div class="content">Yup, this one has me seriously confused. They even both seem sort of similar in scope...</div><br/></div></div></div></div></div></div><div id="36779934" class="c"><input type="checkbox" id="c-36779934" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#36781104">prev</a><span>|</span><a href="#36780138">next</a><span>|</span><label class="collapse" for="c-36779934">[-]</label><label class="expand" for="c-36779934">[2 more]</label></div><br/><div class="children"><div class="content">This part is exremely confusing: <a href="https:&#x2F;&#x2F;tour.val-lang.dev&#x2F;bindings#lifetime" rel="nofollow noreferrer">https:&#x2F;&#x2F;tour.val-lang.dev&#x2F;bindings#lifetime</a>
Why a value declared with `let` has a lifetime? Is it because they want to avoid copying objects and data structures?</div><br/><div id="36783690" class="c"><input type="checkbox" id="c-36783690" checked=""/><div class="controls bullet"><span class="by">zupa-hu</span><span>|</span><a href="#36779934">parent</a><span>|</span><a href="#36780138">next</a><span>|</span><label class="collapse" for="c-36783690">[-]</label><label class="expand" for="c-36783690">[1 more]</label></div><br/><div class="children"><div class="content">To avoid shared mutable state, you either need copy-on-write (hence shared but not mutable) or mutable but not shared.<p>I understand this is the second approach.</div><br/></div></div></div></div><div id="36780138" class="c"><input type="checkbox" id="c-36780138" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#36779934">prev</a><span>|</span><a href="#36780914">next</a><span>|</span><label class="collapse" for="c-36780138">[-]</label><label class="expand" for="c-36780138">[1 more]</label></div><br/><div class="children"><div class="content">Can you really have a systems programming language where the runtime cost is not apparent from the code and stable?<p>Having some code suddenly gain a gigantic copy in an inner loop because of a far away change seems like a risk in val.</div><br/></div></div><div id="36780914" class="c"><input type="checkbox" id="c-36780914" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#36780138">prev</a><span>|</span><label class="collapse" for="c-36780914">[-]</label><label class="expand" for="c-36780914">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Val is compiled ahead-of-time to machine code<p>... to which architecture(s)?</div><br/><div id="36781160" class="c"><input type="checkbox" id="c-36781160" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36780914">parent</a><span>|</span><label class="collapse" for="c-36781160">[-]</label><label class="expand" for="c-36781160">[1 more]</label></div><br/><div class="children"><div class="content">Val is using LLVM.</div><br/></div></div></div></div></div></div></div></div></div></body></html>