<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707037268693" as="style"/><link rel="stylesheet" href="styles.css?v=1707037268693"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/anfractuosity/ramrecovery">Show HN: Simple demo of a cold boot attack using a Raspberry Pi</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>anfractuosity</span> | <span>32 comments</span></div><br/><div><div id="39245300" class="c"><input type="checkbox" id="c-39245300" checked=""/><div class="controls bullet"><span class="by">mjg59</span><span>|</span><a href="#39243272">next</a><span>|</span><label class="collapse" for="c-39245300">[-]</label><label class="expand" for="c-39245300">[2 more]</label></div><br/><div class="children"><div class="content">This is mitigated by a Trusted Computing Group feature - at boot, the OS sets a non-volatile flag, and clears it again on clean shutdown after wiping any sensitive material from RAM. If the system boots with the flag set then the firmware wipes the RAM before booting anything. This doesn&#x27;t protect you against someone pulling the RAM out of the system and dumping it there, but that&#x27;s a much harder attack.</div><br/><div id="39246575" class="c"><input type="checkbox" id="c-39246575" checked=""/><div class="controls bullet"><span class="by">goriloser</span><span>|</span><a href="#39245300">parent</a><span>|</span><a href="#39243272">next</a><span>|</span><label class="collapse" for="c-39246575">[-]</label><label class="expand" for="c-39246575">[1 more]</label></div><br/><div class="children"><div class="content">There is an actual solution - full memory encryption on recent Intel&#x2F;AMD CPUs.</div><br/></div></div></div></div><div id="39243272" class="c"><input type="checkbox" id="c-39243272" checked=""/><div class="controls bullet"><span class="by">Cheer2171</span><span>|</span><a href="#39245300">prev</a><span>|</span><a href="#39244401">next</a><span>|</span><label class="collapse" for="c-39243272">[-]</label><label class="expand" for="c-39243272">[6 more]</label></div><br/><div class="children"><div class="content">It is important to note they could access an image in the memory up to 0.75 seconds after cutting power, but after 1.0 seconds everything had completely decayed. This sounds less like a &quot;cold boot&quot; attack and more like the residual power is still flowing on the substrate for 0.75 seconds.</div><br/><div id="39243301" class="c"><input type="checkbox" id="c-39243301" checked=""/><div class="controls bullet"><span class="by">anfractuosity</span><span>|</span><a href="#39243272">parent</a><span>|</span><a href="#39243353">next</a><span>|</span><label class="collapse" for="c-39243301">[-]</label><label class="expand" for="c-39243301">[4 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t able to automate the use of the freeze spray alas, but I believe that did let me access data after more significant durations.<p>With the freeze spray I did also manage to unplug the power cable completely and switch SD cards manually.<p>Edit: In &quot;Cold Boot Attacks are Still Hot:
Security Analysis of Memory Scramblers in Modern Processors&quot;
they say &quot;To assess the feasibility of cold boot attacks on today’s denser and smaller
components, we measured the retention time of ﬁve DDR3 and two DDR4 modules from various manufacturers. At
normal operating temperatures, a signiﬁcant fraction of the data is lost within 3 seconds of losing power.&quot;<p>The Pi 4 I used makes use of DDR4 from what I recall.</div><br/><div id="39243407" class="c"><input type="checkbox" id="c-39243407" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#39243272">root</a><span>|</span><a href="#39243301">parent</a><span>|</span><a href="#39243353">next</a><span>|</span><label class="collapse" for="c-39243407">[-]</label><label class="expand" for="c-39243407">[3 more]</label></div><br/><div class="children"><div class="content">What results would you expect to get if you simply put the whole setup in a regular freezer? Or if you just tried it during winter</div><br/><div id="39243830" class="c"><input type="checkbox" id="c-39243830" checked=""/><div class="controls bullet"><span class="by">anfractuosity</span><span>|</span><a href="#39243272">root</a><span>|</span><a href="#39243407">parent</a><span>|</span><a href="#39243353">next</a><span>|</span><label class="collapse" for="c-39243830">[-]</label><label class="expand" for="c-39243830">[2 more]</label></div><br/><div class="children"><div class="content">It sounds like a typical freezer cools to around -20C, I think the freezer spray I used directly on DDR chip, claims to chill to around -50C, but not sure how much the surface temperature decreases after spraying and how fast it warms up again.</div><br/><div id="39248680" class="c"><input type="checkbox" id="c-39248680" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#39243272">root</a><span>|</span><a href="#39243830">parent</a><span>|</span><a href="#39243353">next</a><span>|</span><label class="collapse" for="c-39248680">[-]</label><label class="expand" for="c-39248680">[1 more]</label></div><br/><div class="children"><div class="content">Industrial freezers will go to -45, lab freezers to -85 before getting into really exotic stuff.</div><br/></div></div></div></div></div></div></div></div><div id="39243353" class="c"><input type="checkbox" id="c-39243353" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#39243272">parent</a><span>|</span><a href="#39243301">prev</a><span>|</span><a href="#39244401">next</a><span>|</span><label class="collapse" for="c-39243353">[-]</label><label class="expand" for="c-39243353">[1 more]</label></div><br/><div class="children"><div class="content">0.75 seconds without cooling.<p>I would not expect &quot;residual power&quot; to last for 0.75 seconds. Even if it did, RAM has to actively be refreshed by the memory controller. (DDR self-refresh is only enabled during sleep and I dunno if the Pi even supports that)</div><br/></div></div></div></div><div id="39244401" class="c"><input type="checkbox" id="c-39244401" checked=""/><div class="controls bullet"><span class="by">oskarw85</span><span>|</span><a href="#39243272">prev</a><span>|</span><a href="#39243393">next</a><span>|</span><label class="collapse" for="c-39244401">[-]</label><label class="expand" for="c-39244401">[12 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice to recover an image but encryption keys are not that. One bit flip and it&#x27;s game over. This experiment is more useful for human-readable document forensics than anything else.</div><br/><div id="39245231" class="c"><input type="checkbox" id="c-39245231" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#39244401">parent</a><span>|</span><a href="#39244628">next</a><span>|</span><label class="collapse" for="c-39245231">[-]</label><label class="expand" for="c-39245231">[4 more]</label></div><br/><div class="children"><div class="content">Alright let&#x27;s test this hypothesis. Load up a bitcoin wallet and post the private key here with 1 random bit flip :)</div><br/><div id="39245856" class="c"><input type="checkbox" id="c-39245856" checked=""/><div class="controls bullet"><span class="by">Cheer2171</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39245231">parent</a><span>|</span><a href="#39248155">next</a><span>|</span><label class="collapse" for="c-39245856">[-]</label><label class="expand" for="c-39245856">[2 more]</label></div><br/><div class="children"><div class="content">You might think you&#x27;re being clever, but specifying exactly 1 random bit flip makes it a completely different scenario.</div><br/><div id="39248681" class="c"><input type="checkbox" id="c-39248681" checked=""/><div class="controls bullet"><span class="by">krab</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39245856">parent</a><span>|</span><a href="#39248155">next</a><span>|</span><label class="collapse" for="c-39248681">[-]</label><label class="expand" for="c-39248681">[1 more]</label></div><br/><div class="children"><div class="content">If you can reliably find the key in memory, even if it&#x27;s partially damaged, it may practically possible to recover it. You can try keys sorted by edit distance from the recovered material. Maybe there are better methods taking into account the actual cryptography.</div><br/></div></div></div></div><div id="39248155" class="c"><input type="checkbox" id="c-39248155" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39245231">parent</a><span>|</span><a href="#39245856">prev</a><span>|</span><a href="#39244628">next</a><span>|</span><label class="collapse" for="c-39248155">[-]</label><label class="expand" for="c-39248155">[1 more]</label></div><br/><div class="children"><div class="content">If you just recovered a secret key, you have no idea how many bits were flipped or their positions or if they were flipped at all or even it if it&#x27;s actually a key rather than random garbage data. Key strength is therefore maintained.<p>Posting a secret key here and specifying &quot;exactly one bit was flipped&quot; reduces the problem to N guesses where N is the key length since you know all the other N - 1 bits are correct. Leaking just a few bits has catastrophic consequences, in your example all bits except one are leaked.</div><br/></div></div></div></div><div id="39244628" class="c"><input type="checkbox" id="c-39244628" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#39244401">parent</a><span>|</span><a href="#39245231">prev</a><span>|</span><a href="#39244586">next</a><span>|</span><label class="collapse" for="c-39244628">[-]</label><label class="expand" for="c-39244628">[6 more]</label></div><br/><div class="children"><div class="content">If from a 128 bit key 120 are correct, it&#x27;s trivial to figure out the others, even if you don&#x27;t know which bits are the flipped ones.<p>Cryptographers worry even when a few key bits are leaked.</div><br/><div id="39245968" class="c"><input type="checkbox" id="c-39245968" checked=""/><div class="controls bullet"><span class="by">tczMUFlmoNk</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39244628">parent</a><span>|</span><a href="#39244586">next</a><span>|</span><label class="collapse" for="c-39245968">[-]</label><label class="expand" for="c-39245968">[5 more]</label></div><br/><div class="children"><div class="content">&gt; If from a 128 bit key 120 are correct, it&#x27;s trivial to figure out the others, even if you don&#x27;t know which bits are the flipped ones.<p>Can you elaborate a bit? Off the top of my head, I feel like that scenario would leave 128-choose-8 possibilities open, or about 1.4 trillion. Are we calling that &quot;trivial&quot; or am I misunderstanding the attack?<p>(If you&#x27;re calling that &quot;trivial&quot;, I think that could be reasonable in a cryptography context where you&#x27;re considering attackers with a lot of resources. It&#x27;s just different from how I usually use that word. I don&#x27;t disagree with your conclusion that leakage of even a few bits is worth worrying about.)</div><br/><div id="39246138" class="c"><input type="checkbox" id="c-39246138" checked=""/><div class="controls bullet"><span class="by">IanCal</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39245968">parent</a><span>|</span><a href="#39246943">next</a><span>|</span><label class="collapse" for="c-39246138">[-]</label><label class="expand" for="c-39246138">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s 1.4T it depends on what you&#x27;re using it for. Someone on SO has a verify speed for 512 bit rsa keys at 350k&#x2F;second which would leave it at I think a month and a half to run 1.4T. That&#x27;s a random user and a single machine. ECDSA 128 bit verify maybe 6k&#x2F;s on a single core of a not-great CPU. That puts you about a month or two of a moderate machine assuming there&#x27;s no fancy gpu things for doing it.</div><br/><div id="39246299" class="c"><input type="checkbox" id="c-39246299" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39246138">parent</a><span>|</span><a href="#39246943">next</a><span>|</span><label class="collapse" for="c-39246299">[-]</label><label class="expand" for="c-39246299">[1 more]</label></div><br/><div class="children"><div class="content">These are symmetric keys - AES, not ECDSA. Much faster to test.</div><br/></div></div></div></div><div id="39246943" class="c"><input type="checkbox" id="c-39246943" checked=""/><div class="controls bullet"><span class="by">cloudbonsai</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39245968">parent</a><span>|</span><a href="#39246138">prev</a><span>|</span><a href="#39246381">next</a><span>|</span><label class="collapse" for="c-39246943">[-]</label><label class="expand" for="c-39246943">[1 more]</label></div><br/><div class="children"><div class="content">&gt; scenario would leave 128-choice-8 possibilities open<p>That only amounts to log2(C(128, 8)) ~= 40.3.<p>Your encryption key is now just 40-bit strength.</div><br/></div></div><div id="39246381" class="c"><input type="checkbox" id="c-39246381" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#39244401">root</a><span>|</span><a href="#39245968">parent</a><span>|</span><a href="#39246943">prev</a><span>|</span><a href="#39244586">next</a><span>|</span><label class="collapse" for="c-39246381">[-]</label><label class="expand" for="c-39246381">[1 more]</label></div><br/><div class="children"><div class="content">A NVIDIA 3090 with HashCat can do 3 billion AES decryptions per second. That would test all 1.4 trillion in less than an hour.</div><br/></div></div></div></div></div></div><div id="39244586" class="c"><input type="checkbox" id="c-39244586" checked=""/><div class="controls bullet"><span class="by">PrimeMcFly</span><span>|</span><a href="#39244401">parent</a><span>|</span><a href="#39244628">prev</a><span>|</span><a href="#39243393">next</a><span>|</span><label class="collapse" for="c-39244586">[-]</label><label class="expand" for="c-39244586">[1 more]</label></div><br/><div class="children"><div class="content">a passphrase is much shorter than a key and may be in memory multiple times.</div><br/></div></div></div></div><div id="39243393" class="c"><input type="checkbox" id="c-39243393" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#39244401">prev</a><span>|</span><a href="#39243037">next</a><span>|</span><label class="collapse" for="c-39243393">[-]</label><label class="expand" for="c-39243393">[2 more]</label></div><br/><div class="children"><div class="content">It would be interesting to do this with different delays to see how the noise level increases as the delay increases, then once you have a bunch of images recovered, make an animation of the image getting more and more noisy as the time increases, would also be interesting to compare the results for different ambient temperatures, how much more feasable would this be during January in Norway vs August in Texas?</div><br/><div id="39243427" class="c"><input type="checkbox" id="c-39243427" checked=""/><div class="controls bullet"><span class="by">anfractuosity</span><span>|</span><a href="#39243393">parent</a><span>|</span><a href="#39243037">next</a><span>|</span><label class="collapse" for="c-39243427">[-]</label><label class="expand" for="c-39243427">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s something they did in one of the original papers - &quot;Lest We Remember: Cold Boot Attacks on Encryption Keys&quot; by Halderman et al, with an earlier version of DDR, think it was DDR2.<p>It&#x27;s something I&#x27;d like to try too.  Good point re. the temperature also, I bought a PT100 temperature probe I need to use to measure the surface temperature of the RAM chip too.</div><br/></div></div></div></div><div id="39243037" class="c"><input type="checkbox" id="c-39243037" checked=""/><div class="controls bullet"><span class="by">alana314</span><span>|</span><a href="#39243393">prev</a><span>|</span><a href="#39244385">next</a><span>|</span><label class="collapse" for="c-39243037">[-]</label><label class="expand" for="c-39243037">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;d never even heard of cold boot attacks. Is there any prevention of this?</div><br/><div id="39243315" class="c"><input type="checkbox" id="c-39243315" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#39243037">parent</a><span>|</span><a href="#39243050">next</a><span>|</span><label class="collapse" for="c-39243315">[-]</label><label class="expand" for="c-39243315">[1 more]</label></div><br/><div class="children"><div class="content">* Hardware memory encryption &#x2F; bus encryption. If implemented correctly, keys never touch RAM and will be discarded instantly across any power disruption.<p>* Control physical access: don’t allow an attacker access to the DRAM chips.<p>* Control logical access: use trusted boot systems which don’t allow an attacker to dump arbitrary memory, combined with physical access control so they can’t directly address memory externally.</div><br/></div></div><div id="39243050" class="c"><input type="checkbox" id="c-39243050" checked=""/><div class="controls bullet"><span class="by">anfractuosity</span><span>|</span><a href="#39243037">parent</a><span>|</span><a href="#39243315">prev</a><span>|</span><a href="#39244103">next</a><span>|</span><label class="collapse" for="c-39243050">[-]</label><label class="expand" for="c-39243050">[2 more]</label></div><br/><div class="children"><div class="content">I believe both recent Intel and AMD processors enable you to encrypt memory, such as Intel Total Memory Encryption.</div><br/><div id="39243131" class="c"><input type="checkbox" id="c-39243131" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#39243037">root</a><span>|</span><a href="#39243050">parent</a><span>|</span><a href="#39244103">next</a><span>|</span><label class="collapse" for="c-39243131">[-]</label><label class="expand" for="c-39243131">[1 more]</label></div><br/><div class="children"><div class="content">That is correct, AMD Zen4 (Ryzen 7000) supports transparent full memory encryption. It also supports more granular memory encryption, for example to prevent the host accessing VM guest memory.</div><br/></div></div></div></div><div id="39243087" class="c"><input type="checkbox" id="c-39243087" checked=""/><div class="controls bullet"><span class="by">Wool2662</span><span>|</span><a href="#39243037">parent</a><span>|</span><a href="#39244103">prev</a><span>|</span><a href="#39245799">next</a><span>|</span><label class="collapse" for="c-39243087">[-]</label><label class="expand" for="c-39243087">[1 more]</label></div><br/><div class="children"><div class="content">Yes, control physical access to the hardware. You can also achieve some mitigation by using encrypted ram.</div><br/></div></div><div id="39245799" class="c"><input type="checkbox" id="c-39245799" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#39243037">parent</a><span>|</span><a href="#39243087">prev</a><span>|</span><a href="#39244385">next</a><span>|</span><label class="collapse" for="c-39245799">[-]</label><label class="expand" for="c-39245799">[1 more]</label></div><br/><div class="children"><div class="content">Keeping secrets out of main memory, either with registers, encrypted memory, or use of a secure enclave (which in turn uses encrypted memory) for sensitive operations.</div><br/></div></div></div></div><div id="39244385" class="c"><input type="checkbox" id="c-39244385" checked=""/><div class="controls bullet"><span class="by">badrabbit</span><span>|</span><a href="#39243037">prev</a><span>|</span><a href="#39244145">next</a><span>|</span><label class="collapse" for="c-39244385">[-]</label><label class="expand" for="c-39244385">[1 more]</label></div><br/><div class="children"><div class="content">Nice work. There is TME for intel, does anyone know its implementation state and if something similar exists for arm? <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;news&#x2F;runtime-encryption-of-memory-with-intel-tme-mk.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;n...</a></div><br/></div></div><div id="39244145" class="c"><input type="checkbox" id="c-39244145" checked=""/><div class="controls bullet"><span class="by">RecycledEle</span><span>|</span><a href="#39244385">prev</a><span>|</span><label class="collapse" for="c-39244145">[-]</label><label class="expand" for="c-39244145">[1 more]</label></div><br/><div class="children"><div class="content">I hope this leads to NVRAM one day.</div><br/></div></div></div></div></div></div></div></body></html>