<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690189249069" as="style"/><link rel="stylesheet" href="styles.css?v=1690189249069"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/nats-io/nats-server">High-Performance server for NATS.io, the cloud and edge native messaging system</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>Kinrany</span> | <span>49 comments</span></div><br/><div><div id="36842852" class="c"><input type="checkbox" id="c-36842852" checked=""/><div class="controls bullet"><span class="by">protochron</span><span>|</span><a href="#36844504">next</a><span>|</span><label class="collapse" for="c-36842852">[-]</label><label class="expand" for="c-36842852">[1 more]</label></div><br/><div class="children"><div class="content">I work quite a bit with CNCF wasmCloud (<a href="https:&#x2F;&#x2F;wasmcloud.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;wasmcloud.com&#x2F;</a>) and that project wouldn&#x27;t exist without NATS. You can think of wasmCloud as a distributed compute lattice using WebAssembly on the server for providing the compute and NATS to provide the interconnectivity between your various WebAssembly modules.<p>NATS certainly has its quirks, but I can&#x27;t recommend it highly enough if you need any sort of pub&#x2F;sub or stream processing. It even has built-in key-value and object storage for when you need to store larger messages or content. I definitely prefer Jetstream to Kafka in pretty much every use case I can think of. At my current employer (<a href="https:&#x2F;&#x2F;cosmonic.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;cosmonic.com</a>) we use NATS not only for wasmCloud, but we also stream log data and metrics and it keeps up with everything we throw at it with a very low footprint. Auth is kind of counterintuitive until you&#x27;ve spent some time with it, but NATS provides you with a ton of flexibility (docs here: <a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;running-a-nats-service&#x2F;configuration&#x2F;securing_nats&#x2F;auth_intro&#x2F;jwt" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;running-a-nats-service&#x2F;configuration&#x2F;se...</a>).<p><a href="https:&#x2F;&#x2F;natsbyexample.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;natsbyexample.com&#x2F;</a> is a great resource, and can do a better job than I can in illustrating the various ways NATS can be used along with different deployment topologies.</div><br/></div></div><div id="36844504" class="c"><input type="checkbox" id="c-36844504" checked=""/><div class="controls bullet"><span class="by">evnix</span><span>|</span><a href="#36842852">prev</a><span>|</span><a href="#36844672">next</a><span>|</span><label class="collapse" for="c-36844504">[-]</label><label class="expand" for="c-36844504">[1 more]</label></div><br/><div class="children"><div class="content">We have had pretty bad experience with NATS. Apart from core NATS which is just in memory, you need their sub modules to build any kind of serious business on top of it.<p>We initially built our code around NATSStreaming, they then went ahead and deprecated that.<p>But since we saw so many big companies using NATS, they thought it might be a good idea to stick with it and we did a year long migration to their shiny new NATSJetstream Push based approach, but from what I see now in the conversations they are going to deprecate that too in favour of Pull based approach which is architecturally very different, now we will have to somehow convince management for another rewrite. I am not sure if we should even rewrite or just move to another product at this point.<p>Dear NATS, please stop throwing away and rewriting protocols and products. Or make it such that the end client libraries would handle that upgrade automatically with a library upgrade.<p>We should have just stuck with the more traditional Kafka or RabbitMQ.<p>What I have also learnt is that when companies put big brand logos on their websites, it just means some random Dev from that company is using it for their side project or experimental mini project.</div><br/></div></div><div id="36844672" class="c"><input type="checkbox" id="c-36844672" checked=""/><div class="controls bullet"><span class="by">jonathanstrange</span><span>|</span><a href="#36844504">prev</a><span>|</span><a href="#36839071">next</a><span>|</span><label class="collapse" for="c-36844672">[-]</label><label class="expand" for="c-36844672">[1 more]</label></div><br/><div class="children"><div class="content">Can someone tell me which transport protocols and ports this uses or can be configured to use? Moreover, do clients have NAT traversal capabilities (no pun intended)?<p>This is always so hard to figure out for B2B libraries.</div><br/></div></div><div id="36839071" class="c"><input type="checkbox" id="c-36839071" checked=""/><div class="controls bullet"><span class="by">pnpnp</span><span>|</span><a href="#36844672">prev</a><span>|</span><a href="#36843387">next</a><span>|</span><label class="collapse" for="c-36839071">[-]</label><label class="expand" for="c-36839071">[7 more]</label></div><br/><div class="children"><div class="content">I have been a huge advocate of NATS.<p>For anyone looking to support multiple message patterns on one message bus, this is what you want to check out.<p>In AWS terms, it’s like SNS&#x2F;SQS&#x2F;Kinesis all rolled into one bus &amp; very intuitive to work with.</div><br/><div id="36839903" class="c"><input type="checkbox" id="c-36839903" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#36839071">parent</a><span>|</span><a href="#36843387">next</a><span>|</span><label class="collapse" for="c-36839903">[-]</label><label class="expand" for="c-36839903">[6 more]</label></div><br/><div class="children"><div class="content">Any thoughts on NATS&#x27; JetStream? Looks quite compelling, to me.<p><a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;using-nats&#x2F;developer&#x2F;develop_jetstream" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;using-nats&#x2F;developer&#x2F;develop_jetstream</a></div><br/><div id="36840969" class="c"><input type="checkbox" id="c-36840969" checked=""/><div class="controls bullet"><span class="by">protochron</span><span>|</span><a href="#36839071">root</a><span>|</span><a href="#36839903">parent</a><span>|</span><a href="#36843387">next</a><span>|</span><label class="collapse" for="c-36840969">[-]</label><label class="expand" for="c-36840969">[5 more]</label></div><br/><div class="children"><div class="content">Jetstream is the Kafka or Kinesis bit built out on top of the NATS core protocol. It&#x27;s much easier to work with than either of them in my experience</div><br/><div id="36842235" class="c"><input type="checkbox" id="c-36842235" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#36839071">root</a><span>|</span><a href="#36840969">parent</a><span>|</span><a href="#36843387">next</a><span>|</span><label class="collapse" for="c-36842235">[-]</label><label class="expand" for="c-36842235">[4 more]</label></div><br/><div class="children"><div class="content">Thanks, do you know if it&#x27;s a good idea to use JetStream&#x27;s KV or Object stores to implement a join? I&#x27;m thinking of &quot;fan-in&quot;, where multiple streams carrying different pieces of data about the same object all meet in the same place, and the output is a unified object carrying all those bits of data. Seems the store could be used by the joining consumer to hold onto the various pieces of data related to an object until it has the full set, then emit the object into the next stream?</div><br/><div id="36842799" class="c"><input type="checkbox" id="c-36842799" checked=""/><div class="controls bullet"><span class="by">protochron</span><span>|</span><a href="#36839071">root</a><span>|</span><a href="#36842235">parent</a><span>|</span><a href="#36842395">next</a><span>|</span><label class="collapse" for="c-36842799">[-]</label><label class="expand" for="c-36842799">[1 more]</label></div><br/><div class="children"><div class="content">You could do something in that vein, but it might be easier to have those streams all actually deliver to a set of consumers and write a bit of code to join them back together. <a href="https:&#x2F;&#x2F;natsbyexample.com&#x2F;examples&#x2F;jetstream&#x2F;multi-stream-consumption&#x2F;go" rel="nofollow noreferrer">https:&#x2F;&#x2F;natsbyexample.com&#x2F;examples&#x2F;jetstream&#x2F;multi-stream-co...</a> has an example (also a <i>great</i> resource for learning about NATS use cases!)</div><br/></div></div><div id="36842395" class="c"><input type="checkbox" id="c-36842395" checked=""/><div class="controls bullet"><span class="by">yes29922</span><span>|</span><a href="#36839071">root</a><span>|</span><a href="#36842235">parent</a><span>|</span><a href="#36842799">prev</a><span>|</span><a href="#36843387">next</a><span>|</span><label class="collapse" for="c-36842395">[-]</label><label class="expand" for="c-36842395">[2 more]</label></div><br/><div class="children"><div class="content">At this point, where you are doing KSQL level stuff, isn&#x27;t it better to just use Kafka, NATS is very appealing for it&#x27;s simplicity but if I reach a point of re-implementing KSQL or spending 3 hours setting up zookeeper and understanding how to do Kafka distributed for a devops point then Im choosing the latter</div><br/><div id="36844243" class="c"><input type="checkbox" id="c-36844243" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#36839071">root</a><span>|</span><a href="#36842395">parent</a><span>|</span><a href="#36843387">next</a><span>|</span><label class="collapse" for="c-36844243">[-]</label><label class="expand" for="c-36844243">[1 more]</label></div><br/><div class="children"><div class="content">Yes you may well be right, that&#x27;s kind of what I&#x27;m wondering (not using either Kafka or NATS today). Correct me if I&#x27;m wrong, but Kafka itself doesn&#x27;t do joins either, right? I would need something like Flink&#x27;s Window Join?<p><a href="https:&#x2F;&#x2F;nightlies.apache.org&#x2F;flink&#x2F;flink-docs-master&#x2F;docs&#x2F;dev&#x2F;table&#x2F;sql&#x2F;queries&#x2F;window-join&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nightlies.apache.org&#x2F;flink&#x2F;flink-docs-master&#x2F;docs&#x2F;de...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36843387" class="c"><input type="checkbox" id="c-36843387" checked=""/><div class="controls bullet"><span class="by">jensneuse</span><span>|</span><a href="#36839071">prev</a><span>|</span><a href="#36839279">next</a><span>|</span><label class="collapse" for="c-36843387">[-]</label><label class="expand" for="c-36843387">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve recently built an adapter for NATS KV so you can easily expose it through an HTTP-based GraphQL API. (<a href="https:&#x2F;&#x2F;docs.wundergraph.com&#x2F;docs&#x2F;databases&#x2F;kv" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.wundergraph.com&#x2F;docs&#x2F;databases&#x2F;kv</a>) We&#x27;re also looking at supporting streams in the future.<p>What&#x27;s great is that NATS is written in go and we can easily embed it for testing and dev purposes. Furthermore, Synadia makes it super easy to run NATS across multiple regions.</div><br/></div></div><div id="36839279" class="c"><input type="checkbox" id="c-36839279" checked=""/><div class="controls bullet"><span class="by">clumsysmurf</span><span>|</span><a href="#36843387">prev</a><span>|</span><a href="#36843145">next</a><span>|</span><label class="collapse" for="c-36839279">[-]</label><label class="expand" for="c-36839279">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious how this compares with MQTT, there seems to be some overlap.<p>I was looking to stream sensor data from a mobile device using MQTT, but the Eclipse Paho Java client (1.2.5) hasn&#x27;t seen a release in 3 years and I found it to be pretty buggy. There are lots of open issues on the GitHub page.</div><br/><div id="36840236" class="c"><input type="checkbox" id="c-36840236" checked=""/><div class="controls bullet"><span class="by">ozarker</span><span>|</span><a href="#36839279">parent</a><span>|</span><a href="#36843145">next</a><span>|</span><label class="collapse" for="c-36840236">[-]</label><label class="expand" for="c-36840236">[1 more]</label></div><br/><div class="children"><div class="content">MQTT is a protocol. Nats is a server that supports MQTT among other things</div><br/></div></div></div></div><div id="36843145" class="c"><input type="checkbox" id="c-36843145" checked=""/><div class="controls bullet"><span class="by">no_circuit</span><span>|</span><a href="#36839279">prev</a><span>|</span><a href="#36844110">next</a><span>|</span><label class="collapse" for="c-36843145">[-]</label><label class="expand" for="c-36843145">[3 more]</label></div><br/><div class="children"><div class="content">TIBCO Rednezvous, <a href="https:&#x2F;&#x2F;www.tibco.com&#x2F;products&#x2F;tibco-rendezvous" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.tibco.com&#x2F;products&#x2F;tibco-rendezvous</a>, is the first thing that came to my mind from previous experience in the financial industry working with real-time market data. Although I&#x27;m not sure if it has built-in KV support for dealing with large payloads like NATS does, TIBCO RV and their related software packages are worth checking out to see what an long time established commercial product offers. Which leads me to...<p>... the protocol is text-based like HTTP with CR LF for field both for the client, <a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;reference&#x2F;reference-protocols&#x2F;nats-protocol#client-protocol" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;reference&#x2F;reference-protocols&#x2F;nats-prot...</a>,  and cluster protocols, <a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;reference&#x2F;reference-protocols&#x2F;nats-server-protocol" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;reference&#x2F;reference-protocols&#x2F;nats-serv...</a> -- which means encoding overhead if your payloads are binary. So depending on your definition of performance, ymmv.<p>I really do not see how implementing an API across multiple languages is easier by making a new linefeed-based protocol, <a href="https:&#x2F;&#x2F;github.com&#x2F;nats-io&#x2F;nats-server&#x2F;blob&#x2F;0421c65c888bf38125b7e8aac006d6e00d7a8359&#x2F;server&#x2F;parser.go">https:&#x2F;&#x2F;github.com&#x2F;nats-io&#x2F;nats-server&#x2F;blob&#x2F;0421c65c888bf381...</a>,  than just using code-generated JSON or gRPC (Protobuf or Flatbuffers). One could then write subscriptions&#x2F;clustering algorithms in a protocol-neutral library.</div><br/><div id="36843242" class="c"><input type="checkbox" id="c-36843242" checked=""/><div class="controls bullet"><span class="by">c-cube</span><span>|</span><a href="#36843145">parent</a><span>|</span><a href="#36844110">next</a><span>|</span><label class="collapse" for="c-36843242">[-]</label><label class="expand" for="c-36843242">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there&#x27;s encoding overhead. It&#x27;s like http, like you said, but just like http body encoding it seems that actual payloads are preceded with their length so that you just read n followed by n bytes. Look at the docs for `pub` for example. Json would be less efficient; gRPC adds tons of complexity and overhead.</div><br/><div id="36843364" class="c"><input type="checkbox" id="c-36843364" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36843145">root</a><span>|</span><a href="#36843242">parent</a><span>|</span><a href="#36844110">next</a><span>|</span><label class="collapse" for="c-36843364">[-]</label><label class="expand" for="c-36843364">[1 more]</label></div><br/><div class="children"><div class="content">Correct. Text based is more than fine these days, as long as you use length prefix so you can avoid escaping. But you do still need to parse lines which can be tricky in bare or poorly tooled environments. It’s the best trade off today, because debugging binary formats is a serious obstacle.<p>&gt; Json would be less efficient; gRPC adds tons of complexity and overhead.<p>Indeed. There aren’t many suitable specs around, and this protocol, albeit custom, is very easy to implement. Which is proven by the fact that there are well maintained Nats clients in many different languages.</div><br/></div></div></div></div></div></div><div id="36844110" class="c"><input type="checkbox" id="c-36844110" checked=""/><div class="controls bullet"><span class="by">ensocode</span><span>|</span><a href="#36843145">prev</a><span>|</span><a href="#36841229">next</a><span>|</span><label class="collapse" for="c-36844110">[-]</label><label class="expand" for="c-36844110">[1 more]</label></div><br/><div class="children"><div class="content">What are good resources to learn about this new trend of using messaging? We already had this stuff MoM (message oriented middle ware). Pretty interesting.</div><br/></div></div><div id="36841229" class="c"><input type="checkbox" id="c-36841229" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#36844110">prev</a><span>|</span><a href="#36844044">next</a><span>|</span><label class="collapse" for="c-36841229">[-]</label><label class="expand" for="c-36841229">[9 more]</label></div><br/><div class="children"><div class="content">Struggling to figure out what &quot;cloud native&quot; actually means. Unfortunately their own web site doesn&#x27;t say and the CNCF web site they link to leaves me none the wiser.<p>At a guess they are talking about applications being built from the ground up to dynamically allocate resources using cloud providers APIs directly rather than relying on an assumption fixed resources are already provisioned and the application runs within them.<p>I wonder if I&#x27;m right ...</div><br/><div id="36843889" class="c"><input type="checkbox" id="c-36843889" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36841229">parent</a><span>|</span><a href="#36844225">next</a><span>|</span><label class="collapse" for="c-36843889">[-]</label><label class="expand" for="c-36843889">[1 more]</label></div><br/><div class="children"><div class="content">&gt; applications being built from the ground up to dynamically allocate resources using cloud providers APIs directly<p>If that indeed is what cloud native means, it sounds interesting. But the problem is that all these APIs and especially &quot;managed&quot; services are super proprietary and you&#x27;ll vendor lock yourself pretty hard. But I suppose that ship has sailed a long time ago.</div><br/></div></div><div id="36844225" class="c"><input type="checkbox" id="c-36844225" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36841229">parent</a><span>|</span><a href="#36843889">prev</a><span>|</span><a href="#36841670">next</a><span>|</span><label class="collapse" for="c-36844225">[-]</label><label class="expand" for="c-36844225">[1 more]</label></div><br/><div class="children"><div class="content">Cloud native usually means targeting the &quot;Cloud OSes&quot;, while being agnostic from the underlying OS, or legacy stuff like POSIX.<p>Or to put it more clear, applications written in modern language runtimes, packaged in containers that can be run on top of whatever orchestration is available, and using provider APIs and resources.</div><br/></div></div><div id="36841670" class="c"><input type="checkbox" id="c-36841670" checked=""/><div class="controls bullet"><span class="by">jerrygenser</span><span>|</span><a href="#36841229">parent</a><span>|</span><a href="#36844225">prev</a><span>|</span><a href="#36841558">next</a><span>|</span><label class="collapse" for="c-36841670">[-]</label><label class="expand" for="c-36841670">[1 more]</label></div><br/><div class="children"><div class="content">There are a bunch of OSS that solve problems when running distributed scale out workloads in &quot;the cloud&quot;. For example prometheus is a metric db for storing monitoring data.<p>Ceph is a storage backend. Most of them tend to be built for or work well with kubernetes.</div><br/></div></div><div id="36842451" class="c"><input type="checkbox" id="c-36842451" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#36841229">parent</a><span>|</span><a href="#36841558">prev</a><span>|</span><a href="#36844044">next</a><span>|</span><label class="collapse" for="c-36842451">[-]</label><label class="expand" for="c-36842451">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Struggling to figure out what &quot;cloud native&quot; actually means.<p>- very fast startup<p>- low memory<p>- can be easily distributed or is stateless</div><br/><div id="36842976" class="c"><input type="checkbox" id="c-36842976" checked=""/><div class="controls bullet"><span class="by">xuancanh</span><span>|</span><a href="#36841229">root</a><span>|</span><a href="#36842451">parent</a><span>|</span><a href="#36844044">next</a><span>|</span><label class="collapse" for="c-36842976">[-]</label><label class="expand" for="c-36842976">[3 more]</label></div><br/><div class="children"><div class="content">That is not what cloud native means. It is an overloaded term, but the basic idea is that the application is designed to operate in the cloud environment, utilizing cloud&#x27;s capabilities such as elastic and automated infrastructure management.</div><br/><div id="36843144" class="c"><input type="checkbox" id="c-36843144" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#36841229">root</a><span>|</span><a href="#36842976">parent</a><span>|</span><a href="#36844044">next</a><span>|</span><label class="collapse" for="c-36843144">[-]</label><label class="expand" for="c-36843144">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That is not what cloud native means.
&gt; utilizing cloud&#x27;s capabilities such as elastic and automated infrastructure management.<p>Contradictory perhaps? So it&#x27;s not what it means but it is what it means?<p>In order to achieve what you&#x27;ve said in vague terms you definitely do need to try to be stateless, have fast startup and reduce memory. Clear examples are things like lambda and fargate.<p>How can you be elastic if you have an application server that takes 10 minutes to start?</div><br/><div id="36844096" class="c"><input type="checkbox" id="c-36844096" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#36841229">root</a><span>|</span><a href="#36843144">parent</a><span>|</span><a href="#36844044">next</a><span>|</span><label class="collapse" for="c-36844096">[-]</label><label class="expand" for="c-36844096">[1 more]</label></div><br/><div class="children"><div class="content">It also means having instrumentation and observability as first class features. First party support for containerisation, the app needs to be robust and capable of handling shutdowns and multiple instances gracefully. In a cloud environment, when hardware fails or instances get resized, multiple containers may get spun up and everything is kept in sync through the database (or an external data store).<p>Authentication and integration with auth and secret providers are another distinguishing feature. I personally find &quot;cloud native&quot; software to be a pain to use locally because they usually come in the form of a docker-compose and kubernetes setup, and those absolutely gobble up ram and disk space.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36844044" class="c"><input type="checkbox" id="c-36844044" checked=""/><div class="controls bullet"><span class="by">debuggerpk</span><span>|</span><a href="#36841229">prev</a><span>|</span><a href="#36838909">next</a><span>|</span><label class="collapse" for="c-36844044">[-]</label><label class="expand" for="c-36844044">[1 more]</label></div><br/><div class="children"><div class="content">Big fan of nats, especially how they are doing tenant isolation and geo-distributed queue.</div><br/></div></div><div id="36838909" class="c"><input type="checkbox" id="c-36838909" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#36844044">prev</a><span>|</span><a href="#36843791">next</a><span>|</span><label class="collapse" for="c-36838909">[-]</label><label class="expand" for="c-36838909">[10 more]</label></div><br/><div class="children"><div class="content">With all the message queue whatever thingies, as an outside I’m quite confused about ideal use cases.<p>NATS vs MQTT vs Kafka vs Redis Queue vs Amazon SQS - how do they all stack up?</div><br/><div id="36839160" class="c"><input type="checkbox" id="c-36839160" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#36838909">parent</a><span>|</span><a href="#36839472">next</a><span>|</span><label class="collapse" for="c-36839160">[-]</label><label class="expand" for="c-36839160">[1 more]</label></div><br/><div class="children"><div class="content">MQTT is a protocol rather than an alternative to NATS; NATS supports MQTT (<a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;running-a-nats-service&#x2F;configuration&#x2F;mqtt" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;running-a-nats-service&#x2F;configuration&#x2F;mq...</a>)<p>As far as ideal use cases, we use NATS for <a href="https:&#x2F;&#x2F;plane.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;plane.dev</a> in two ways:<p>- As a message bus, it is a layer of abstraction on top of the network. Instead of each node needing to establish a connection to every node it needs to connect to, it just connects to a NATS cluster and messages are routed by subject. This is great for debugging because we can &quot;wiretap&quot; messages on a given subject pattern and verify what&#x27;s being sent. We even have a service that listens on NATS subjects and conditionally turns events into Slack messages.<p>- It has a built-in RAFT implementation (via JetStream), which we piggyback on when we need to create consensus among nodes.</div><br/></div></div><div id="36839472" class="c"><input type="checkbox" id="c-36839472" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#36838909">parent</a><span>|</span><a href="#36839160">prev</a><span>|</span><a href="#36844165">next</a><span>|</span><label class="collapse" for="c-36839472">[-]</label><label class="expand" for="c-36839472">[6 more]</label></div><br/><div class="children"><div class="content">NATS is not a queue. It&#x27;s distributed pub&#x2F;sub message broker for communicating between applications.<p>NATS&#x27;s only responsibility is to route messages in near-real-time from publishers to consumers. Messages are ephemeral and dropped immediately after delivery; if nobody is listening, the messages vanish. Messages are only queued temporarily in RAM if the consumer is busy, and they can get dropped if a consumer doesn&#x27;t handle them fast enough. In short, NATS is very lightweight and fast, and designed for things that are lightweight and fast. It&#x27;s like a kind of distributed socket mechanism, and works best as a communication primitive you build stuff on top of (like TCP or UDP) rather than a fully fledged system.<p>So it&#x27;s very different from Kafka and other types of queues that are durable and database-like. Kafka is good for &quot;fat pipes&quot; that centralize data from producers into a log which is then consumed by massively parallel sets of consumers, and you don&#x27;t constantly change this topology. NATS is good for networks of fast-changing producers and consumers that send small messages to each other, often one-on-one, although any fan-out topology works. It&#x27;s great for firehose-type routing. For example, imagine you want your app to produce lots of different kinds of telemetry. Your app just sends messages to a topic &quot;telemetry&quot; or maybe a dotted topic like &quot;telemetry.iostats&quot; or &quot;telemetry.errors&quot;. Then a client can &quot;tap&quot; into that topic by listening to it. If no client is listening, the firehose goes nowhere. But then a client can tap into &quot;telemetry.errors&quot; and get just the stream of error messages. Topics are just strings, so you can create unique topics for temporary things; an app can send a message to another app like &quot;hey, do some work and then send the result to my temporary topic foobar726373&quot;.<p>NATS is particularly notable for its &quot;just works&quot; design. The clustering, for example, ties together brokers with no effort. Clients typically don&#x27;t need any configuration at all, other than the name of a NATS server.<p>NATS <i>can</i> be used as a low-level component to build stateful stuff. NATS Jetstream is a Kafka-like solution that stores durable logs, and uses NATS as its communication protocol. Liftbridge is another one.</div><br/><div id="36842439" class="c"><input type="checkbox" id="c-36842439" checked=""/><div class="controls bullet"><span class="by">jadbox</span><span>|</span><a href="#36838909">root</a><span>|</span><a href="#36839472">parent</a><span>|</span><a href="#36840712">next</a><span>|</span><label class="collapse" for="c-36842439">[-]</label><label class="expand" for="c-36842439">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it a big problem if readers miss messages if either the topic readers go offline briefly or message throughout exceeds readers?</div><br/></div></div><div id="36840712" class="c"><input type="checkbox" id="c-36840712" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#36838909">root</a><span>|</span><a href="#36839472">parent</a><span>|</span><a href="#36842439">prev</a><span>|</span><a href="#36844165">next</a><span>|</span><label class="collapse" for="c-36840712">[-]</label><label class="expand" for="c-36840712">[4 more]</label></div><br/><div class="children"><div class="content">It is worth noting that the jetstream API (to me) (not that experienced) to lack some of the features of Kafka w.r.t. replayability - for instance I can’t easily say “go back and re-run messages from X point-in-time”. Instead it may be necessary to write custom handlers for replay or safeguard your systems to be very idempotent (a good pattern in event driven systems, but not one that is explicitly required by Kafkaesque messaging systems).</div><br/><div id="36843408" class="c"><input type="checkbox" id="c-36843408" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36838909">root</a><span>|</span><a href="#36840712">parent</a><span>|</span><a href="#36840913">next</a><span>|</span><label class="collapse" for="c-36843408">[-]</label><label class="expand" for="c-36843408">[1 more]</label></div><br/><div class="children"><div class="content">Jetstream has real time replay[1], and you can easily pick a starting time, and continue to stream new events as well.<p>But yes, to be able to replay without side effects you’ll want to make sure you’re setting up the consumers correctly. That may need some custom logic, but isn’t that necessary with any message queue?<p>[1]: <a href="https:&#x2F;&#x2F;docs.nats.io&#x2F;using-nats&#x2F;developer&#x2F;develop_jetstream" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.nats.io&#x2F;using-nats&#x2F;developer&#x2F;develop_jetstream</a></div><br/></div></div><div id="36840913" class="c"><input type="checkbox" id="c-36840913" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#36838909">root</a><span>|</span><a href="#36840712">parent</a><span>|</span><a href="#36843408">prev</a><span>|</span><a href="#36844165">next</a><span>|</span><label class="collapse" for="c-36840913">[-]</label><label class="expand" for="c-36840913">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I did not mean to suggest that Jetstream is equivalent to Kafka. It&#x27;s quite different.</div><br/><div id="36841158" class="c"><input type="checkbox" id="c-36841158" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#36838909">root</a><span>|</span><a href="#36840913">parent</a><span>|</span><a href="#36844165">next</a><span>|</span><label class="collapse" for="c-36841158">[-]</label><label class="expand" for="c-36841158">[1 more]</label></div><br/><div class="children"><div class="content">Yep, just clarifying for the reader. The use cases&#x2F;advantages&#x2F;disadvantages seem to be somewhat different</div><br/></div></div></div></div></div></div></div></div><div id="36844165" class="c"><input type="checkbox" id="c-36844165" checked=""/><div class="controls bullet"><span class="by">sofixa</span><span>|</span><a href="#36838909">parent</a><span>|</span><a href="#36839472">prev</a><span>|</span><a href="#36838989">next</a><span>|</span><label class="collapse" for="c-36844165">[-]</label><label class="expand" for="c-36844165">[1 more]</label></div><br/><div class="children"><div class="content">&gt; NATS vs MQTT vs Kafka vs Redis Queue vs Amazon SQS - how do they all stack up<p>I&#x27;m curious why are RabbitMQ and AMQP no longer part of such comparisons (not only your comment, nobody else on this thread has mentioned them).</div><br/></div></div><div id="36838989" class="c"><input type="checkbox" id="c-36838989" checked=""/><div class="controls bullet"><span class="by">Xeoncross</span><span>|</span><a href="#36838909">parent</a><span>|</span><a href="#36844165">prev</a><span>|</span><a href="#36843791">next</a><span>|</span><label class="collapse" for="c-36838989">[-]</label><label class="expand" for="c-36838989">[1 more]</label></div><br/><div class="children"><div class="content">Queues are often used for two reasons: as a way to throttle processing (just throw it into the queue and drain as you have time) and a way to avoid state loss (process the queue item and only ack&#x2F;clear it once you&#x27;ve done X, Y, &amp; Z. Of course there are more uses, but these are the two most common.<p>Depending on the throughput you need, the number of clients pulling&#x2F;putting into the queue, and other things you can rule out certain options. For example, Redis queue will be one of the fastest choices - but is very limited in capacity (memory size). SQS is basically unlimited capacity, but can often have 150ms or more of time elapse between when you put the item in and when it&#x27;s available.</div><br/></div></div></div></div><div id="36843791" class="c"><input type="checkbox" id="c-36843791" checked=""/><div class="controls bullet"><span class="by">throw14082020</span><span>|</span><a href="#36838909">prev</a><span>|</span><a href="#36841429">next</a><span>|</span><label class="collapse" for="c-36843791">[-]</label><label class="expand" for="c-36843791">[2 more]</label></div><br/><div class="children"><div class="content">Would it ever make sense for NATS to support UDP or SRTP?</div><br/><div id="36843810" class="c"><input type="checkbox" id="c-36843810" checked=""/><div class="controls bullet"><span class="by">throw14082020</span><span>|</span><a href="#36843791">parent</a><span>|</span><a href="#36841429">next</a><span>|</span><label class="collapse" for="c-36843810">[-]</label><label class="expand" for="c-36843810">[1 more]</label></div><br/><div class="children"><div class="content">Ahh, they may work on QUIC this year: <a href="https:&#x2F;&#x2F;github.com&#x2F;nats-io&#x2F;nats-server&#x2F;issues&#x2F;457">https:&#x2F;&#x2F;github.com&#x2F;nats-io&#x2F;nats-server&#x2F;issues&#x2F;457</a></div><br/></div></div></div></div><div id="36841429" class="c"><input type="checkbox" id="c-36841429" checked=""/><div class="controls bullet"><span class="by">npace12</span><span>|</span><a href="#36843791">prev</a><span>|</span><a href="#36840290">next</a><span>|</span><label class="collapse" for="c-36841429">[-]</label><label class="expand" for="c-36841429">[1 more]</label></div><br/><div class="children"><div class="content">nats is phenomenal. Libraries and docs are not great, but you won&#x27;t need them much as you just forget it&#x27;s even there.</div><br/></div></div><div id="36840290" class="c"><input type="checkbox" id="c-36840290" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36841429">prev</a><span>|</span><a href="#36841337">next</a><span>|</span><label class="collapse" for="c-36840290">[-]</label><label class="expand" for="c-36840290">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using this in production. So far it&#x27;s worked very well. Took a few hours to setup with certificates. Now it just works.</div><br/><div id="36840666" class="c"><input type="checkbox" id="c-36840666" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#36840290">parent</a><span>|</span><a href="#36841337">next</a><span>|</span><label class="collapse" for="c-36840666">[-]</label><label class="expand" for="c-36840666">[4 more]</label></div><br/><div class="children"><div class="content">What do you run it on?</div><br/><div id="36840896" class="c"><input type="checkbox" id="c-36840896" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36840290">root</a><span>|</span><a href="#36840666">parent</a><span>|</span><a href="#36841337">next</a><span>|</span><label class="collapse" for="c-36840896">[-]</label><label class="expand" for="c-36840896">[3 more]</label></div><br/><div class="children"><div class="content">We have a manufacturing operation with a public B2B ecommerce platform.<p>It&#x27;s just a dumb communications buss for us. It&#x27;s replaced most of our ETL needs with Realtime events. If an order is placed online an event is raised. Our accounting system can consume that event to create the sales order. Then the production system consume the same event to add the job to the next production batch. Each production step produces events that can be used to update other systems, including Realtime updates on the ecommerce system.<p>We use Jetstream so consumers don&#x27;t need to be awake when producers create events.<p>This system spans the cloud and 3 physical locations. But, to the consumers and producers it&#x27;s one buss that they only have to authenticate with once.</div><br/><div id="36841178" class="c"><input type="checkbox" id="c-36841178" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#36840290">root</a><span>|</span><a href="#36840896">parent</a><span>|</span><a href="#36841337">next</a><span>|</span><label class="collapse" for="c-36841178">[-]</label><label class="expand" for="c-36841178">[2 more]</label></div><br/><div class="children"><div class="content">I was just wondering if it was cloud hosted k8s, baremetal k8s, or another cloud offering</div><br/><div id="36841203" class="c"><input type="checkbox" id="c-36841203" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36840290">root</a><span>|</span><a href="#36841178">parent</a><span>|</span><a href="#36841337">next</a><span>|</span><label class="collapse" for="c-36841203">[-]</label><label class="expand" for="c-36841203">[1 more]</label></div><br/><div class="children"><div class="content">Oh the Nats server runs on one of our servers in our own rack on site. It&#x27;s a bit old fashioned but does the trick.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36841337" class="c"><input type="checkbox" id="c-36841337" checked=""/><div class="controls bullet"><span class="by">lakomen</span><span>|</span><a href="#36840290">prev</a><span>|</span><a href="#36841061">next</a><span>|</span><label class="collapse" for="c-36841337">[-]</label><label class="expand" for="c-36841337">[2 more]</label></div><br/><div class="children"><div class="content">I got into it again about 2 weeks ago.
Been doing a small project with the microservice api.<p>Compared to HTTP&#x2F;REST I miss the debugabilty of it.
Since all messages are sent over websocket and received, in binary form, since there is no support from Chrome or Firefox, one has to tediously manually extract the json payload and try to make sense of it.<p>Jetstream is still quite the mystery. It just doesn&#x27;t want to work the way I want it to, especially on the JS client side, blocking script execution and timing out.<p>Then there&#x27;s auth, after a few shutdowns and reboots I got locked out of my local installation.
Oidc subject to nats user mapping doesn&#x27;t exist and has to be done manually.<p>So TL;DR the core functionality is great. Everything else seems to be WIP.</div><br/><div id="36842627" class="c"><input type="checkbox" id="c-36842627" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#36841337">parent</a><span>|</span><a href="#36841061">next</a><span>|</span><label class="collapse" for="c-36842627">[-]</label><label class="expand" for="c-36842627">[1 more]</label></div><br/><div class="children"><div class="content">You can subscribe to all topics by using a *. Why not have a debug subscriber that listens to all messages and plays it in the terminal?<p>I agree that the auth system is cumbersome. I wanted to use it on the edge for IoT devices where the device only has the same permissions as the user who the device belongs to, but not very easy. Their auth isn’t very customizable.</div><br/></div></div></div></div><div id="36841061" class="c"><input type="checkbox" id="c-36841061" checked=""/><div class="controls bullet"><span class="by">gjvc</span><span>|</span><a href="#36841337">prev</a><span>|</span><label class="collapse" for="c-36841061">[-]</label><label class="expand" for="c-36841061">[1 more]</label></div><br/><div class="children"><div class="content">not to be confused with <a href="https:&#x2F;&#x2F;www.nats.aero&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nats.aero&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>