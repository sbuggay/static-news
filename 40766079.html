<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719219674315" as="style"/><link rel="stylesheet" href="styles.css?v=1719219674315"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://quic.video/blog/never-use-datagrams/">Timeliness without datagrams using QUIC</a> <span class="domain">(<a href="https://quic.video">quic.video</a>)</span></div><div class="subtext"><span>wofo</span> | <span>184 comments</span></div><br/><div><div id="40766251" class="c"><input type="checkbox" id="c-40766251" checked=""/><div class="controls bullet"><span class="by">promiseofbeans</span><span>|</span><a href="#40766691">next</a><span>|</span><label class="collapse" for="c-40766251">[-]</label><label class="expand" for="c-40766251">[11 more]</label></div><br/><div class="children"><div class="content">We use straight UDP datagrams for streaming high-frequency sensor data. One of our R&amp;D people built a new system that uses quic and solves most of our problems with out-of-order delivery. We still use datagrams over UDP for everything because we have to support some 3rd party sensors out of the box without adapters, and UDP is all they can do.</div><br/><div id="40766467" class="c"><input type="checkbox" id="c-40766467" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#40766251">parent</a><span>|</span><a href="#40772755">next</a><span>|</span><label class="collapse" for="c-40766467">[-]</label><label class="expand" for="c-40766467">[2 more]</label></div><br/><div class="children"><div class="content">Also pretty much every media art system in the world just uses OSC over UDP</div><br/><div id="40766500" class="c"><input type="checkbox" id="c-40766500" checked=""/><div class="controls bullet"><span class="by">jesprenj</span><span>|</span><a href="#40766251">root</a><span>|</span><a href="#40766467">parent</a><span>|</span><a href="#40772755">next</a><span>|</span><label class="collapse" for="c-40766500">[-]</label><label class="expand" for="c-40766500">[1 more]</label></div><br/><div class="children"><div class="content">And ArtNet also over UDP.</div><br/></div></div></div></div><div id="40772755" class="c"><input type="checkbox" id="c-40772755" checked=""/><div class="controls bullet"><span class="by">shaklee3</span><span>|</span><a href="#40766251">parent</a><span>|</span><a href="#40766467">prev</a><span>|</span><a href="#40770051">next</a><span>|</span><label class="collapse" for="c-40772755">[-]</label><label class="expand" for="c-40772755">[1 more]</label></div><br/><div class="children"><div class="content">You could have used RoCE for reliability over UDP</div><br/></div></div><div id="40770051" class="c"><input type="checkbox" id="c-40770051" checked=""/><div class="controls bullet"><span class="by">songbird23</span><span>|</span><a href="#40766251">parent</a><span>|</span><a href="#40772755">prev</a><span>|</span><a href="#40766529">next</a><span>|</span><label class="collapse" for="c-40770051">[-]</label><label class="expand" for="c-40770051">[2 more]</label></div><br/><div class="children"><div class="content">what language was the system build with? thats super cool!</div><br/><div id="40771962" class="c"><input type="checkbox" id="c-40771962" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40766251">root</a><span>|</span><a href="#40770051">parent</a><span>|</span><a href="#40766529">next</a><span>|</span><label class="collapse" for="c-40771962">[-]</label><label class="expand" for="c-40771962">[1 more]</label></div><br/><div class="children"><div class="content">hubris++<p>Thanks, I&#x27;ll see myself out... lol =)</div><br/></div></div></div></div><div id="40766529" class="c"><input type="checkbox" id="c-40766529" checked=""/><div class="controls bullet"><span class="by">Almondsetat</span><span>|</span><a href="#40766251">parent</a><span>|</span><a href="#40770051">prev</a><span>|</span><a href="#40771343">next</a><span>|</span><label class="collapse" for="c-40766529">[-]</label><label class="expand" for="c-40766529">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, high frequency sensor data was on my mind too. Do you have any figures on the power saved wrt TCP?</div><br/><div id="40771957" class="c"><input type="checkbox" id="c-40771957" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40766251">root</a><span>|</span><a href="#40766529">parent</a><span>|</span><a href="#40771343">next</a><span>|</span><label class="collapse" for="c-40771957">[-]</label><label class="expand" for="c-40771957">[1 more]</label></div><br/><div class="children"><div class="content">In general, the wireless handshake on G5&#x2F;LTE&#x2F;Wifi&#x2F;Starlink will dwarf the traffic of sensors for power use.   For old-style satellite mailboxes, the traffic is better batched in 45min chunks anyway (the 5W transmitters are usually only active for well under 20 seconds per message, and use a super-cap to handle the RF power draw spike.)<p>Naive UDP protocols have reachability problems in numerous scenarios, variable costs can balloon (concurrency with polling links is dumb), and can open a hole in your infrastructure at scale without special equipment mods.  Only if you have a tier 3 or better WAN trunk or cloud-center should you even consider something silly like QUIC.<p>YMMV, and I love the AstroTurf on YC... lol ;)</div><br/></div></div></div></div><div id="40771343" class="c"><input type="checkbox" id="c-40771343" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40766251">parent</a><span>|</span><a href="#40766529">prev</a><span>|</span><a href="#40766691">next</a><span>|</span><label class="collapse" for="c-40771343">[-]</label><label class="expand" for="c-40771343">[3 more]</label></div><br/><div class="children"><div class="content">&quot;solves most of our problems&quot;<p>Indeed, until the problems it creates begin to feature.<p>Have a great day =3</div><br/><div id="40772171" class="c"><input type="checkbox" id="c-40772171" checked=""/><div class="controls bullet"><span class="by">adolph</span><span>|</span><a href="#40766251">root</a><span>|</span><a href="#40771343">parent</a><span>|</span><a href="#40766691">next</a><span>|</span><label class="collapse" for="c-40772171">[-]</label><label class="expand" for="c-40772171">[2 more]</label></div><br/><div class="children"><div class="content">“Those are my problems and if you don’t like them . . . Well, I have others”<p>—G. Marx</div><br/><div id="40772200" class="c"><input type="checkbox" id="c-40772200" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40766251">root</a><span>|</span><a href="#40772171">parent</a><span>|</span><a href="#40766691">next</a><span>|</span><label class="collapse" for="c-40772200">[-]</label><label class="expand" for="c-40772200">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Law_of_holes" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Law_of_holes</a><p>;)</div><br/></div></div></div></div></div></div></div></div><div id="40766691" class="c"><input type="checkbox" id="c-40766691" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#40766251">prev</a><span>|</span><a href="#40766331">next</a><span>|</span><label class="collapse" for="c-40766691">[-]</label><label class="expand" for="c-40766691">[17 more]</label></div><br/><div class="children"><div class="content">Most of TCP woes comes from high-bandwith latency-sensitive stuff like HFT and video, but TCP isn&#x27;t particularly good for low-bandwidth high-latency networks either (e. g. NB-IoT with 10 seconds worst case RTT):<p>- TCP will waste roundtrips on handshakes. And then some extra on MTU discovery.<p>- TCP will keep trying to transmit data even if it&#x27;s no longer useful (same issue as with real-time multimedia).<p>- If you move into a location with worse coverage, your latency increases, but TCP will assume packet loss due to congestion and reduce bandwidth. And in general, loss-based congestion control just doesn&#x27;t work at this point.<p>- Load balancers and middleboxes (and HTTP servers, but that&#x27;s another story) may disconnect you randomly because hey, you haven&#x27;t responded for four seconds, you are probably no longer there anyway, right?<p>- You can&#x27;t interpret the data you&#x27;ve got until you have all of it - because TCP will split packets with no regards to data structure. Which is twice as sad when all of your data would actually fit in 1200 bytes.</div><br/><div id="40773017" class="c"><input type="checkbox" id="c-40773017" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40766691">parent</a><span>|</span><a href="#40767063">next</a><span>|</span><label class="collapse" for="c-40773017">[-]</label><label class="expand" for="c-40773017">[1 more]</label></div><br/><div class="children"><div class="content">&gt; TCP will waste roundtrips on handshakes. And then some extra on MTU discovery.<p>This is especially true when using TLS (which is at least a major use case nowadays if not the default assumption); the TCP handshake has to complete before the TLS handshake can occur, whereas QUIC has protocol-level support for doing TLS negotiation as part of the initial handshake. Having the network protocol and the encryption be composable rather than tightly coupled feels more elegant, it&#x27;s hard for me to convince myself that being able to save a round trip per connection isn&#x27;t a more practical benefit in a world where we now expect pretty much everything to be encrypted in transit.</div><br/></div></div><div id="40767063" class="c"><input type="checkbox" id="c-40767063" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766691">parent</a><span>|</span><a href="#40773017">prev</a><span>|</span><a href="#40767197">next</a><span>|</span><label class="collapse" for="c-40767063">[-]</label><label class="expand" for="c-40767063">[3 more]</label></div><br/><div class="children"><div class="content">And TCP wants to pretend that all your data arrives as a linear stream one after the other; and keeps you from seeing package n+1, if you haven&#x27;t received package n, yet.<p>That&#x27;s useful for some things, but often you can make use of package n+1, even when package n hasn&#x27;t arrived, yet.<p>For example, when you are transferring a large file, you could use erasure encoding to just automatically deal with 5% package loss.  (Or you could use a fountain code to deal with variable packet loss, and the sender just keeps sending until the receiver says &quot;I&#x27;m done&quot; for the whole file, instead of ack-ing individual packages.<p>Fountain codes are how deep space probes send their data back.  Latency is pretty terrible out to Jupiter or Mars.)</div><br/><div id="40767534" class="c"><input type="checkbox" id="c-40767534" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40767063">parent</a><span>|</span><a href="#40767197">next</a><span>|</span><label class="collapse" for="c-40767534">[-]</label><label class="expand" for="c-40767534">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And TCP wants to pretend that all your data arrives as a linear stream one after the other;<p>That’s one of the reasons people use TCP.<p>&gt; For example, when you are transferring a large file, you could use erasure encoding to just automatically deal with 5% package loss.<p>It’s never that simple. You can’t just add some erasure coding and have it automatically solve your problems. You now have to build an entire protocol around those packets to determine and track their order. You also need mechanisms to handle the case where packet loss exceeds what you can recover, which involves either restarting the transfer or a retransmission mechanism.<p>The number of little details you have to handle quickly explodes in complexity. Even in the best case scenario, you’d be paying a price to handle erasure coding on one end, the extra bandwidth of the overhead, and then decoding on the receiving end.<p>That’s a lot of complexity, engineering, debugging, and opportunities to introduce bugs, and for what gain? In the file transfer example, what would you actually gain by rolling your own entire transmission protocol with all this overhead?<p>&gt; Fountain codes are how deep space probes send their data back. Latency is pretty terrible out to Jupiter or Mars.)<p>Fountain codes and even general erasure codes are not the right tool for this job. The loss of a digital packetized channel across the internet is very different than a noisy analog channel sent through space.</div><br/><div id="40772845" class="c"><input type="checkbox" id="c-40772845" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40767534">parent</a><span>|</span><a href="#40767197">next</a><span>|</span><label class="collapse" for="c-40772845">[-]</label><label class="expand" for="c-40772845">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s never that simple. You can’t just add some erasure coding and have it automatically solve your problems. You now have to build an entire protocol around those packets to determine and track their order.<p>Yes, and you&#x27;d want to mostly build this extra protocol only once, and stick it into a library.<p>&gt; You also need mechanisms to handle the case where packet loss exceeds what you can recover, which involves either restarting the transfer or a retransmission mechanism.<p>Or you can use a fountain code, and just keep transmitting.<p>&gt; The number of little details you have to handle quickly explodes in complexity. Even in the best case scenario, you’d be paying a price to handle erasure coding on one end, the extra bandwidth of the overhead, and then decoding on the receiving end.<p>Well, you can also use a simpler mechanism: you transmit all the packages from A to B once, then at the end B tells A which packages get lost, and A sends those again.  Repeat until you have everything.<p>That way needs more back-and-forth communication, but doesn&#x27;t need any fancy error correcting code.<p>&gt; Fountain codes and even general erasure codes are not the right tool for this job. The loss of a digital packetized channel across the internet is very different than a noisy analog channel sent through space.<p>Yes, the loss model is different.  However you can eg interleave your bits to get something that close enough to work.<p>The main reason you don&#x27;t need to use error correcting codes, is that transmitting feedback to the sender is typically a lot cheaper on the internet than in outer space.  Not least because even bad latencies are typically measured in seconds at most, not minutes or hours.<p>(You could however use these codes when for some reason you have a very asymmetrical link.  Eg if you have internet via geo-stationary satellite, or if one sender is broadcast to lots and lots of different receivers, and doesn&#x27;t want to deal with each of them individually.)</div><br/></div></div></div></div></div></div><div id="40767197" class="c"><input type="checkbox" id="c-40767197" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#40766691">parent</a><span>|</span><a href="#40767063">prev</a><span>|</span><a href="#40771860">next</a><span>|</span><label class="collapse" for="c-40767197">[-]</label><label class="expand" for="c-40767197">[11 more]</label></div><br/><div class="children"><div class="content">Is NB-IoT actually being used these days? I remember it was hyped up but then the buzz disappeared.</div><br/><div id="40770360" class="c"><input type="checkbox" id="c-40770360" checked=""/><div class="controls bullet"><span class="by">jjoonathan</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40767197">parent</a><span>|</span><a href="#40767348">next</a><span>|</span><label class="collapse" for="c-40770360">[-]</label><label class="expand" for="c-40770360">[2 more]</label></div><br/><div class="children"><div class="content">In my corner of the world (electric&#x2F;water&#x2F;gas utilities), we had been using proprietary techniques that matched the &quot;NB-IoT&quot; description for 20 years, and they weren&#x27;t new then. It was fun to watch the public dialogue walk the same path for a while and rediscover some of the main tricks, but there were other important tricks left untouched (broadcast firmware downloads, highly compressed debug logs, low power clock synchronization so that you can do timeslots for ultra low power, mesh heuristics) probably because they were a massive pain in the rear and the people who would have risen to the occasion saw that the major ecological niches were already occupied by players who got in 30 years ago when this all became viable. (Disclaimer: I didn&#x27;t actively chase down NB-IoT talks so I might just have been missing these things.)<p>If your market is large enough that managing your own infrastructure is attractive (vs cellular), you were also able to afford a few EEs and RF guys 30 years ago, and your needs are already met by a competitive ecosystem of players who have been walking this path for a long time. It doesn&#x27;t leave much to compete on except price, and you don&#x27;t want to compete on price.</div><br/><div id="40771395" class="c"><input type="checkbox" id="c-40771395" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40770360">parent</a><span>|</span><a href="#40767348">next</a><span>|</span><label class="collapse" for="c-40771395">[-]</label><label class="expand" for="c-40771395">[1 more]</label></div><br/><div class="children"><div class="content">That makes me envious. I&#x27;ve figured out the debug log compression part myself, but the rest is beyond my reach.<p>&gt; If your market is large enough that managing your own infrastructure is attractive<p>This. I imagine proprietary is perfect when you are deploying in a single country with single RF plan. And your customer utility company that is willing to maintain a bit of extra infrastructure. But if you want to deploy on several sites scattered across all ITU regions, and each site is a huge plant with devices from maybe fifty different suppliers, it&#x27;s just a no-go.</div><br/></div></div></div></div><div id="40767348" class="c"><input type="checkbox" id="c-40767348" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40767197">parent</a><span>|</span><a href="#40770360">prev</a><span>|</span><a href="#40772139">next</a><span>|</span><label class="collapse" for="c-40767348">[-]</label><label class="expand" for="c-40767348">[5 more]</label></div><br/><div class="children"><div class="content">It definitely does, at least in Europe, not sure how things are on the other side of the pond. For the user equipment there is no real advantage over LTE-M, actually is LTE-M better for our case (send a single packet a day and go to sleep). But then I don&#x27;t see the picture from the operator side, maybe the radio savings actually matter for them. Some operators either don&#x27;t have LTE-M at all or don&#x27;t allow PSM on LTE-M because screw you that&#x27;s why. On NB-IoT PSM is mandatory at least.
And yes, LoRa&#x2F;Sigfox&#x2F;other non-cellular LPWAN might technically be better IF you provide the base stations. Nobody wants to do that. With cellular you can just mail the device and cross your fingers the operators haven&#x27;t misconfigured roaming.</div><br/><div id="40769678" class="c"><input type="checkbox" id="c-40769678" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40767348">parent</a><span>|</span><a href="#40772139">next</a><span>|</span><label class="collapse" for="c-40769678">[-]</label><label class="expand" for="c-40769678">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s quite interesting. And the promised battery lifespans of NB-IoT device, did it hold some truth? In the beginning we heard about 10 year life spans for simple well designed devices.</div><br/><div id="40771245" class="c"><input type="checkbox" id="c-40771245" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40769678">parent</a><span>|</span><a href="#40770543">next</a><span>|</span><label class="collapse" for="c-40771245">[-]</label><label class="expand" for="c-40771245">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll have to wait 10 years to see. But on paper it does (we aim for 15) and we have devices in field for some three years.<p>But for the &quot;simple well-designed&quot; - the problem is, the whole thing is a black box for application developer, and not a bugless one. So much of the &quot;well-designed&quot; part is to figure out when is the right time to pull modem&#x27;s proverbial power cord.  If you don&#x27;t, it&#x27;ll gladly eat up your battery in 48 hours after a cell handover goes wrong with no warning.</div><br/></div></div><div id="40770543" class="c"><input type="checkbox" id="c-40770543" checked=""/><div class="controls bullet"><span class="by">jjoonathan</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40769678">parent</a><span>|</span><a href="#40771245">prev</a><span>|</span><a href="#40772154">next</a><span>|</span><label class="collapse" for="c-40770543">[-]</label><label class="expand" for="c-40770543">[1 more]</label></div><br/><div class="children"><div class="content">We have millions of devices in the field older than that on the same D-cell LiSOCl2 battery they shipped with. Some of them even take magnetic measurements with powered excitation!</div><br/></div></div><div id="40772154" class="c"><input type="checkbox" id="c-40772154" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40769678">parent</a><span>|</span><a href="#40770543">prev</a><span>|</span><a href="#40772139">next</a><span>|</span><label class="collapse" for="c-40772154">[-]</label><label class="expand" for="c-40772154">[1 more]</label></div><br/><div class="children"><div class="content">No.  Because carriers are idiots.<p>The carriers require you to allow them to force a firmware upgrade on you.  This kills your battery dead long before anything you would do on the device will.<p>Technically, however, 10 year battery life is generally unreasonable.  Most batteries that exist self-discharge over 10 years.  5 years is doable, but requires quite solid engineering.  3 years is pretty reasonable for most things.<p>If you want 10 year lifetimes, I think you specifically need lithium thionyl chloride batteries.</div><br/></div></div></div></div></div></div><div id="40772139" class="c"><input type="checkbox" id="c-40772139" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40767197">parent</a><span>|</span><a href="#40767348">prev</a><span>|</span><a href="#40771860">next</a><span>|</span><label class="collapse" for="c-40772139">[-]</label><label class="expand" for="c-40772139">[3 more]</label></div><br/><div class="children"><div class="content">The biggest fucking problem with NB-IoT or LTE-M is the goddamn carriers--both managerial and technical.<p>1) Managerial--Just like back in the old days when the carriers stupidly fought the change from voice to data they are stupidly fighting the change from humans using the network to machines using the network.  And it&#x27;s just as stupid this time around and it will be just as stupidly profitable for them after the fact.<p>2) The carriers refuse to support older firmware so you have to be able to do multi-megabyte firmware updates every 3 months.  This is <i>anathema</i> to anything running on a battery as your firmware updates are like 2 to 4 orders of magnitude(not exaggerating) larger than the total <i>actual data</i> your device will transmit over its lifetime.<p>The carrier cranio-rectal impaction is why LoRA still continues to exist and expand.</div><br/><div id="40773459" class="c"><input type="checkbox" id="c-40773459" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40772139">parent</a><span>|</span><a href="#40773126">next</a><span>|</span><label class="collapse" for="c-40773459">[-]</label><label class="expand" for="c-40773459">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve used Sigfox with success but then they went almost bankrupt and I honestly didn&#x27;t check where they are now or if it&#x27;s safe to use them going forward. I still want devices to function 10 years from now.</div><br/></div></div><div id="40773126" class="c"><input type="checkbox" id="c-40773126" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40766691">root</a><span>|</span><a href="#40772139">parent</a><span>|</span><a href="#40773459">prev</a><span>|</span><a href="#40771860">next</a><span>|</span><label class="collapse" for="c-40773126">[-]</label><label class="expand" for="c-40773126">[1 more]</label></div><br/><div class="children"><div class="content">3) Certified firmware*<p>* the telecom can and does blacklist IMEI numbers for unsigned firmware<p>* it is illegal to fix bugs that cause eSIM hardware lock-ups<p>* You can catch g05t5 on the carrier VPN network sandbox hitting each client<p>Sometimes it is better to wipe the slate clean, and start again... LoRAWAN certainly does make sense in some use-case applications.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hMOwbNUpDQA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hMOwbNUpDQA</a></div><br/></div></div></div></div></div></div><div id="40771860" class="c"><input type="checkbox" id="c-40771860" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#40766691">parent</a><span>|</span><a href="#40767197">prev</a><span>|</span><a href="#40766331">next</a><span>|</span><label class="collapse" for="c-40771860">[-]</label><label class="expand" for="c-40771860">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  If you move into a location with worse coverage, your latency increases, but TCP will assume packet loss due to congestion and reduce bandwidth. And in general, loss-based congestion control just doesn&#x27;t work at this point.<p>Don&#x27;t lower levels of wifi below TCP now do often their own retransmit, even if it is just from weak&#x2F;noisy signal and not a sensed collision?</div><br/></div></div></div></div><div id="40766331" class="c"><input type="checkbox" id="c-40766331" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40766691">prev</a><span>|</span><a href="#40766488">next</a><span>|</span><label class="collapse" for="c-40766331">[-]</label><label class="expand" for="c-40766331">[12 more]</label></div><br/><div class="children"><div class="content">IMO stream abstractions make it too convenient to write fragile programs which are slow to recover from disconnections (if they do at all) and generally place too many restrictions on the transport layer. Congestion control is definitely needed but everything else seems questionable.<p>In a datagram-first world we would have no issue bonding any number of data links with very high efficiency or seamlessly roaming across network boundaries without dropping connections. Many types of applications can handle out-of-order frames with zero overhead and would work much faster if written for the UDP model.</div><br/><div id="40767977" class="c"><input type="checkbox" id="c-40767977" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#40766331">parent</a><span>|</span><a href="#40767080">next</a><span>|</span><label class="collapse" for="c-40767977">[-]</label><label class="expand" for="c-40767977">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In a datagram-first world we would have no issue bonding any number of data links with very high efficiency or seamlessly roaming across network boundaries without dropping connections. Many types of applications can handle out-of-order frames with zero overhead and would work much faster if written for the UDP model.<p>So your argument is that software isn’t written well because TCP is too convenient, but we’re supposed to believe that a substantially more complicated datagram-first world would have perfectly robust and efficient software?<p>In practice, moving to less reliable transports doesn’t make software automatically more reliable or more efficient. It actually introduces a huge number of failure modes and complexities that teams would have to deal with.</div><br/><div id="40772836" class="c"><input type="checkbox" id="c-40772836" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766331">root</a><span>|</span><a href="#40767977">parent</a><span>|</span><a href="#40768781">next</a><span>|</span><label class="collapse" for="c-40772836">[-]</label><label class="expand" for="c-40772836">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So your argument is that software isn’t written well because TCP is too convenient, but we’re supposed to believe that a substantially more complicated datagram-first world would have perfectly robust and efficient software?<p>I think you can make a better argument:<p>Your operating system should offer you something like UDP, but you can handle all the extra features you need on top of that to eg simulate something like TCP, at the level of an unprivileged library you link into your application.<p>That way is exactly as convenient for &#x27;normal&#x27; programmers as the current world: you get something like TCP by default.  But it&#x27;s also easy for people to innovate and to swap out a different implementation, without needing access to the privileged innards of your kernel.</div><br/></div></div><div id="40768781" class="c"><input type="checkbox" id="c-40768781" checked=""/><div class="controls bullet"><span class="by">sunk1st</span><span>|</span><a href="#40766331">root</a><span>|</span><a href="#40767977">parent</a><span>|</span><a href="#40772836">prev</a><span>|</span><a href="#40768739">next</a><span>|</span><label class="collapse" for="c-40768781">[-]</label><label class="expand" for="c-40768781">[1 more]</label></div><br/><div class="children"><div class="content">It’s true that a stream-oriented abstraction puts constraints on the communication channel that don’t exist for a datagram oriented protocol.</div><br/></div></div></div></div><div id="40767080" class="c"><input type="checkbox" id="c-40767080" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766331">parent</a><span>|</span><a href="#40767977">prev</a><span>|</span><a href="#40766539">next</a><span>|</span><label class="collapse" for="c-40767080">[-]</label><label class="expand" for="c-40767080">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Congestion control is definitely needed but everything else seems questionable.<p>Even congestion control can be optional for some applications with the right error correcting code.  (Though if you have a narrow bottleneck somewhere in your connection, I guess it doesn&#x27;t make too much sense to produce lots and lots more packages that will just be discarded at the bottleneck.)</div><br/><div id="40767765" class="c"><input type="checkbox" id="c-40767765" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#40766331">root</a><span>|</span><a href="#40767080">parent</a><span>|</span><a href="#40766539">next</a><span>|</span><label class="collapse" for="c-40767765">[-]</label><label class="expand" for="c-40767765">[2 more]</label></div><br/><div class="children"><div class="content">As mentioned in the article, this doesn&#x27;t handle the case of buffer bloat: packets all eventually arrive rather than being dropped, but increasingly late, and only backing off can help reduce the latency.</div><br/><div id="40772787" class="c"><input type="checkbox" id="c-40772787" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766331">root</a><span>|</span><a href="#40767765">parent</a><span>|</span><a href="#40766539">next</a><span>|</span><label class="collapse" for="c-40772787">[-]</label><label class="expand" for="c-40772787">[1 more]</label></div><br/><div class="children"><div class="content">Does UDP suffer from buffer bloat?  I thought it was only TCP?<p>Oh, it looks like UDP packages are also buffered?<p>Update: it looks like I learned something new today.  UDP can also suffer from bufferbloat.  (I thought UDP was done without buffers for some reason..)</div><br/></div></div></div></div></div></div><div id="40766539" class="c"><input type="checkbox" id="c-40766539" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40766331">parent</a><span>|</span><a href="#40767080">prev</a><span>|</span><a href="#40766488">next</a><span>|</span><label class="collapse" for="c-40766539">[-]</label><label class="expand" for="c-40766539">[4 more]</label></div><br/><div class="children"><div class="content">Out of interest, what kind of applications are you thinking of? What systems are common written using TCP, that could switch to UDP?<p>Clearly websites, audio and video generally don&#x27;t work with out-of-order frames -- most people don&#x27;t want dropped audio and video.<p>Some video games are happy to ignore missed packets, but when they can they are already written in UDP.</div><br/><div id="40766584" class="c"><input type="checkbox" id="c-40766584" checked=""/><div class="controls bullet"><span class="by">ansgri</span><span>|</span><a href="#40766331">root</a><span>|</span><a href="#40766539">parent</a><span>|</span><a href="#40766488">next</a><span>|</span><label class="collapse" for="c-40766584">[-]</label><label class="expand" for="c-40766584">[3 more]</label></div><br/><div class="children"><div class="content">Any data block that must be fully received before processing comes to mind (e.g. websites’ html), just request retransmission of parts that didn’t make it in first pass. Funnily enough it’s (realtime) video and audio that already uses UDP due to preferring timely data to complete data.<p>On the contrary, for me it’s hard to imagine video game with missed packets as the state can get out of sync too easily, you’ll need eventual consistency via retransmission or some clever data structures (I know least about this domain though)</div><br/><div id="40767018" class="c"><input type="checkbox" id="c-40767018" checked=""/><div class="controls bullet"><span class="by">smcameron</span><span>|</span><a href="#40766331">root</a><span>|</span><a href="#40766584">parent</a><span>|</span><a href="#40767074">next</a><span>|</span><label class="collapse" for="c-40767018">[-]</label><label class="expand" for="c-40767018">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not expert in this area, but my understanding is that for latency sensitive video games, on the client side, state is predicted between updates, e.g. the state may be updated via the network, at say, roughly 10Hz (probably faster, but probably less than 60Hz), but updated locally at 60Hz via interpolation, dead reckoning and other predictive&#x2F;smoothing heuristics, a few missed updates just means a bit more prediction is used.  &quot;State&quot; is not usually transmitted as one lump &quot;frame&quot; at a time, but rather per-game unit (per spaceship, asteroid, robot, or whatever is in the game) or per some-small-group of units. When some updates are delayed too long, you might get some visible artifacts, &quot;rubber-banding&quot;, &quot;teleportation&quot; or &quot;warping&quot;, etc. often lumped together by players under the umbrella term &quot;lag&quot;.  For out-of-order packets, older packets might be dropped as newer packets may already have been applied to the state of some game units (typically there&#x27;s some timestamps or monotonically increasing counter associated with state updates for each unit used by the prediction&#x2F;interpolation&#x2F;smoothing heuristics) and the state is usually represented in absolute terms rather than relative terms (e.g. (x,y) = (100,100), rather than x+=10, y+=10, so that any update may be applied in isolation.)</div><br/></div></div><div id="40767074" class="c"><input type="checkbox" id="c-40767074" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40766331">root</a><span>|</span><a href="#40766584">parent</a><span>|</span><a href="#40767018">prev</a><span>|</span><a href="#40766488">next</a><span>|</span><label class="collapse" for="c-40767074">[-]</label><label class="expand" for="c-40767074">[1 more]</label></div><br/><div class="children"><div class="content">Many video games just transmit the whole state the player should be able to see every tick. While some games send a diff of some kind, sometimes that turns out to not be worth it. This is particularly true in the games which care most about lag (think mario kart, or street fighter and friends).</div><br/></div></div></div></div></div></div></div></div><div id="40766488" class="c"><input type="checkbox" id="c-40766488" checked=""/><div class="controls bullet"><span class="by">adunk</span><span>|</span><a href="#40766331">prev</a><span>|</span><a href="#40766855">next</a><span>|</span><label class="collapse" for="c-40766488">[-]</label><label class="expand" for="c-40766488">[26 more]</label></div><br/><div class="children"><div class="content">This may seem like a minor nit, but I think there is a problem with using the term &quot;unreliable&quot; to describe UDP. The more commonly used term, and IMHO better term, is &quot;best-effort&quot; [1]. UDP makes its best effort to deliver the datagrams, but the datagrams may be dropped anyway. But it does not make UDP inherently unreliable.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Best-effort_delivery" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Best-effort_delivery</a></div><br/><div id="40766562" class="c"><input type="checkbox" id="c-40766562" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40766488">parent</a><span>|</span><a href="#40766717">next</a><span>|</span><label class="collapse" for="c-40766562">[-]</label><label class="expand" for="c-40766562">[8 more]</label></div><br/><div class="children"><div class="content">IMO &quot;best-effort&quot; is euphemistic and confusing to people outside of this space, even (especially?) to native English speakers. (I would probably have described UDP as &quot;reasonable effort&quot; and TCP as &quot;best effort&quot;, if not for the existing terminology.)<p>I recall my computer networking professor describing this as &quot;Best-effort means never having to say you&#x27;re sorry&quot;. In practice, best-effort does not mean you try your hardest to make sure the message gets from A to B, it means that you made <i>an</i> effort. Router in the path was congested? Link flap leading to blackholing on the order of 50ms before fast reroute kicks in? Oh well, we tried.<p>Meanwhile, TCP&#x27;s reliable delivery will retry several times and will present an in-order data stream to the application.<p>Reliable vs unreliable might be bad terminology, but I don&#x27;t think best-effort is any better.<p>My experience with unreliable systems is that they&#x27;re great something like 95% of the time, and they&#x27;re great for raw throughput, but there are many cases where that last 5% makes a huge difference.</div><br/><div id="40767033" class="c"><input type="checkbox" id="c-40767033" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766562">parent</a><span>|</span><a href="#40766717">next</a><span>|</span><label class="collapse" for="c-40767033">[-]</label><label class="expand" for="c-40767033">[7 more]</label></div><br/><div class="children"><div class="content">The question is &#x27;who deals with dropped packages&#x27;?  In TCP, the answer is: &#x27;the protocol&#x27;.  In UDP the answer is &#x27;the next layer of abstraction&#x27; (eg the app or some library).<p>You can build a &#x27;reliable&#x27; protocol on top of UDP, and still not get TCP.<p>Eg if you want to transfer a large file that you know up front, then TCP&#x27;s streaming mechanism doesn&#x27;t make too much sense.  You could use something like UDP to send the whole file from A to B in little chunks once, and at the end B can tell A what (numbered) chunks she&#x27;s missing.<p>There&#x27;s no reason to hold off on sending chunk n+1 of the file, just because chunk n hasn&#x27;t arrived yet.</div><br/><div id="40767855" class="c"><input type="checkbox" id="c-40767855" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40767033">parent</a><span>|</span><a href="#40767995">next</a><span>|</span><label class="collapse" for="c-40767855">[-]</label><label class="expand" for="c-40767855">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no reason to hold off on sending chunk n+1 of the file, just because chunk n hasn&#x27;t arrived yet.<p>Congestion control comes to mind -- you don&#x27;t necessarily know what rate the network supports if you don&#x27;t have a feedback mechanism to let you know when you&#x27;re sending too fast. Congestion control is one of those things where sure, you can individually cheat and possibly achieve better performance at everyone else&#x27;s expense, but if everyone does it, then you&#x27;ll run into congestive collapse.<p>&gt; You can build a &#x27;reliable&#x27; protocol on top of UDP, and still not get TCP.<p>I agree -- there are reliable protocols running on top of UDP (e.g. QUIC, SCTP) that do not behave exactly like TCP. You don&#x27;t need an in-order stream in the described use case of bulk file transfer. You certainly don&#x27;t need head-of-line blocking.<p>But there are many details and interactions that you and I wouldn&#x27;t realize or get right on the first try. I would rather not relearn all of those lessons from the past 50+ years.</div><br/><div id="40772870" class="c"><input type="checkbox" id="c-40772870" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40767855">parent</a><span>|</span><a href="#40767995">next</a><span>|</span><label class="collapse" for="c-40772870">[-]</label><label class="expand" for="c-40772870">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But there are many details and interactions that you and I wouldn&#x27;t realize or get right on the first try. I would rather not relearn all of those lessons from the past 50+ years.<p>Oh, the model I had in mind was not that everyone should write their network code from scratch all the time, but rather that everything that&#x27;s higher level than datagrams should be handled by unprivileged library code instead of privileged kernel level code.<p>If speed is an issue, modern Linux can do wonders with eBPF and io_uring, I guess?  I&#x27;m taking my inspiration from the exokernel folks who believed that abstractions have no place in the operating system kernel.</div><br/></div></div></div></div><div id="40767995" class="c"><input type="checkbox" id="c-40767995" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40767033">parent</a><span>|</span><a href="#40767855">prev</a><span>|</span><a href="#40767898">next</a><span>|</span><label class="collapse" for="c-40767995">[-]</label><label class="expand" for="c-40767995">[2 more]</label></div><br/><div class="children"><div class="content">Is there a popular protocol that uses this scheme today? I&#x27;ve often thought that this would be a superior way to transfer&#x2F;sync data. and have always wondered why it wasn&#x27;t common.<p>The closest I can think of is the old FSP protocol, which never really saw wide use. The client would request each individual chunk by offset, and if a chunk got lost, it could re-request it. But that&#x27;s not quite the same thing.</div><br/><div id="40771428" class="c"><input type="checkbox" id="c-40771428" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40767995">parent</a><span>|</span><a href="#40767898">next</a><span>|</span><label class="collapse" for="c-40771428">[-]</label><label class="expand" for="c-40771428">[1 more]</label></div><br/><div class="children"><div class="content">Bittorrent?</div><br/></div></div></div></div><div id="40767898" class="c"><input type="checkbox" id="c-40767898" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40767033">parent</a><span>|</span><a href="#40767995">prev</a><span>|</span><a href="#40766717">next</a><span>|</span><label class="collapse" for="c-40767898">[-]</label><label class="expand" for="c-40767898">[2 more]</label></div><br/><div class="children"><div class="content">TCP kind of supports that with selective acknowledgements these days, I think.</div><br/><div id="40767975" class="c"><input type="checkbox" id="c-40767975" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40767898">parent</a><span>|</span><a href="#40766717">next</a><span>|</span><label class="collapse" for="c-40767975">[-]</label><label class="expand" for="c-40767975">[1 more]</label></div><br/><div class="children"><div class="content">SACKs have been in TCP for 25-30 years now (Widely adopted as part of New Reno, although RFC 2018 proposed the TCP option and implementation back in 1996).<p>That said, the typical reason why TCP doesn&#x27;t send packet N+1 is because its congestion window is full.<p>There is a related problem known as head-of-line blocking where the application won&#x27;t receive packet N+1 from the kernel until packet N has been received, as a consequence of TCP delivering that in-order stream of bytes.</div><br/></div></div></div></div></div></div></div></div><div id="40766717" class="c"><input type="checkbox" id="c-40766717" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40766488">parent</a><span>|</span><a href="#40766562">prev</a><span>|</span><a href="#40766800">next</a><span>|</span><label class="collapse" for="c-40766717">[-]</label><label class="expand" for="c-40766717">[3 more]</label></div><br/><div class="children"><div class="content">The term &quot;best effort delivery&quot; in networking is a weasel term that is no better than &quot;unreliable&quot;. It should probably be burned.<p>&quot;Effort&quot; generally refers to some sort of persistence in the face of difficulty. Dropping a packet upon encountering a resource problem isn&#x27;t effort, let alone best effort.<p>The way &quot;best effort&quot; is used in networking is quite at odds with the &quot;best efforts&quot; legal&#x2F;business term, which denotes something short of a firm commitment, but not outright flaking off.<p>Separately from the delivery question, the checksums in UDP (and TCP!) also poorly assure integrity when datagrams <i>are</i> delivered. They only somewhat improve on the hardware.</div><br/><div id="40767931" class="c"><input type="checkbox" id="c-40767931" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766717">parent</a><span>|</span><a href="#40771462">next</a><span>|</span><label class="collapse" for="c-40767931">[-]</label><label class="expand" for="c-40767931">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Dropping a packet upon encountering a resource problem isn&#x27;t effort, let alone best effort<p>The dropping part isn’t the effort; the forwarding part is.<p>&gt; the checksums in UDP (and TCP!) also poorly assure integrity when datagrams are delivered.<p>That’s true, but it’s becoming less of a problem with ubiquitous encryption these days (at least on WAN connections).</div><br/></div></div><div id="40771462" class="c"><input type="checkbox" id="c-40771462" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766717">parent</a><span>|</span><a href="#40767931">prev</a><span>|</span><a href="#40766800">next</a><span>|</span><label class="collapse" for="c-40771462">[-]</label><label class="expand" for="c-40771462">[1 more]</label></div><br/><div class="children"><div class="content">Should be &quot;at most once&quot; and &quot;at least once&quot;, it&#x27;s already used in other distributed systems with the same kind of problem</div><br/></div></div></div></div><div id="40766800" class="c"><input type="checkbox" id="c-40766800" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#40766488">parent</a><span>|</span><a href="#40766717">prev</a><span>|</span><a href="#40766746">next</a><span>|</span><label class="collapse" for="c-40766800">[-]</label><label class="expand" for="c-40766800">[6 more]</label></div><br/><div class="children"><div class="content">We’ve been calling it “unreliable” transport since the 80’s, and that’s what it is. Want your packets to get there? TCP. Don’t care much? UDP.<p>Oversimplified.<p>Best effort is a dumb term. There’s no effort.</div><br/><div id="40767967" class="c"><input type="checkbox" id="c-40767967" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766800">parent</a><span>|</span><a href="#40766858">next</a><span>|</span><label class="collapse" for="c-40767967">[-]</label><label class="expand" for="c-40767967">[1 more]</label></div><br/><div class="children"><div class="content">In a way, TCP is just about as reliable as UDP, but at a different layer: TCP will either forward your entire stream of data in order and without gaps, or it won’t. UDP does the same, but on the per-datagram level.<p>Reliability is arguably more of a statement about the availability metrics of your underlying network; it doesn’t seem like a great summary for what TCP does. You can’t make an unreliable lower layer reliable with any protocol magic on top; you can just bundle the unreliability differently (e.g. by trading off an unreliability in delivery for an unreliability in timing).</div><br/></div></div><div id="40766858" class="c"><input type="checkbox" id="c-40766858" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766800">parent</a><span>|</span><a href="#40767967">prev</a><span>|</span><a href="#40767279">next</a><span>|</span><label class="collapse" for="c-40766858">[-]</label><label class="expand" for="c-40766858">[3 more]</label></div><br/><div class="children"><div class="content">TCP wont always deliver your packets anyway , but it does have a mechanism of timing out if a party believes the other party did not receive something. UDP just means that if one cares for their data to be received, they must verify it themselves.</div><br/><div id="40767045" class="c"><input type="checkbox" id="c-40767045" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766858">parent</a><span>|</span><a href="#40767075">next</a><span>|</span><label class="collapse" for="c-40767045">[-]</label><label class="expand" for="c-40767045">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s not so much &#x27;reliable&#x27; or &#x27;best effort&#x27;, rather the difference is &#x27;which part of your software stack should deal with dropped packages&#x27;?</div><br/></div></div><div id="40767075" class="c"><input type="checkbox" id="c-40767075" checked=""/><div class="controls bullet"><span class="by">13415</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766858">parent</a><span>|</span><a href="#40767045">prev</a><span>|</span><a href="#40767279">next</a><span>|</span><label class="collapse" for="c-40767075">[-]</label><label class="expand" for="c-40767075">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s in my opinion what reliable &#x2F; unrealiable mean in this context.<p>reliable = it either succeeds or you get an error after some time, unreliable = it may or may not succeed<p>I concur with the people who think &quot;best effort&quot; is not a good term. But perhaps TCP streams are not reliable enough for TCP to be rightly called a reliable stream protocol. As it turned out, it&#x27;s not really possible to use TCP without a control channel, message chunking, and similar mechanisms for transmitting arbitrary large files. If it <i>really</i> offered reliable streams that would its primary use case.</div><br/></div></div></div></div><div id="40767279" class="c"><input type="checkbox" id="c-40767279" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766800">parent</a><span>|</span><a href="#40766858">prev</a><span>|</span><a href="#40766746">next</a><span>|</span><label class="collapse" for="c-40767279">[-]</label><label class="expand" for="c-40767279">[1 more]</label></div><br/><div class="children"><div class="content">the designers of link layers and protocol implemntations, the army of operators who test signals, insteall repeaters, configure routers and hold conferences about how to manage the global routing system would disagree.<p>best effort implies &#x27;no, we&#x27;re not going to be climb that curve and get try to get to 100% reliability, because that would actually be counterproductive from an engineering perspective, but we&#x27;re going to go to pretty substantial lengths to deliver your packet&#x27;</div><br/></div></div></div></div><div id="40766746" class="c"><input type="checkbox" id="c-40766746" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40766488">parent</a><span>|</span><a href="#40766800">prev</a><span>|</span><a href="#40767092">next</a><span>|</span><label class="collapse" for="c-40766746">[-]</label><label class="expand" for="c-40766746">[5 more]</label></div><br/><div class="children"><div class="content">&gt; but the datagrams may be dropped anyway<p>That&#x27;s what I thought &quot;unreliable&quot; meant? I can&#x27;t really tell what misconception you are trying to avoid.</div><br/><div id="40767456" class="c"><input type="checkbox" id="c-40767456" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40766746">parent</a><span>|</span><a href="#40767092">next</a><span>|</span><label class="collapse" for="c-40767456">[-]</label><label class="expand" for="c-40767456">[4 more]</label></div><br/><div class="children"><div class="content">I think the issue is that there&#x27;s a stigma around UDP, largely borne from not using it effectively. I&#x27;m not sure this is the right way to address the stigma though.<p>Ultimately, TCP vs UDP per se is rarely the right question to ask. But that is often the only configuration knob available, or at least the only way to get away from TCP-based protocols and their overhead is to switch over to raw UDP as though it were an application protocol unto itself.<p>Such naive use of UDP contributes to the stigma. If you send a piece of data only once, there&#x27;s a nontrivial chance it won&#x27;t get to its destination. If you never do any verification that the other side is available, misconfiguration or infrastructure changes can lead to all your packets going to ground and the sender being completely unaware. I&#x27;ve seen this happen many times and of course the only solution (considered or even available in a pinch) is to ditch UDP and use TCP because at least the latter &quot;works&quot;. You can say &quot;well it&#x27;s UDP, what did you expect?&quot; but unfortunately while that may have been meant to spur some deeper thought, it often just leads to the person who hears it writing off UDP entirely.<p>Robust protocol design takes time and effort regardless of transport protocol chosen, but a lot of developers give it short shrift. Lacking care or deeper understanding, they blame UDP and eschew its use even when somebody comes along who does know how to use it effectively.</div><br/><div id="40768262" class="c"><input type="checkbox" id="c-40768262" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40767456">parent</a><span>|</span><a href="#40767092">next</a><span>|</span><label class="collapse" for="c-40768262">[-]</label><label class="expand" for="c-40768262">[3 more]</label></div><br/><div class="children"><div class="content">What kind of stigma is there around UDP? I have never heard of this and I have never seen anyone use UDP expecting it to be reliable.<p>I think the biggest mistake people make with UDP protocols is allowing traffic amplification attacks.</div><br/><div id="40772305" class="c"><input type="checkbox" id="c-40772305" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40768262">parent</a><span>|</span><a href="#40767092">next</a><span>|</span><label class="collapse" for="c-40772305">[-]</label><label class="expand" for="c-40772305">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone expects it to be reliable, they just don&#x27;t plan for packet loss properly.</div><br/><div id="40772765" class="c"><input type="checkbox" id="c-40772765" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40766488">root</a><span>|</span><a href="#40772305">parent</a><span>|</span><a href="#40767092">next</a><span>|</span><label class="collapse" for="c-40772765">[-]</label><label class="expand" for="c-40772765">[1 more]</label></div><br/><div class="children"><div class="content">Plan? Or implement?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40767092" class="c"><input type="checkbox" id="c-40767092" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40766488">parent</a><span>|</span><a href="#40766746">prev</a><span>|</span><a href="#40767301">next</a><span>|</span><label class="collapse" for="c-40767092">[-]</label><label class="expand" for="c-40767092">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like the problem is the term &quot;best-effort&quot; (hand wavy, what&#x27;s the measure of effort? What&#x27;s &quot;the best&quot; effort?).<p>In the end, best-effort is just saying &quot;unreliable&quot; in a fussier way.<p>&gt;<i>But it does not make UDP inherently unreliable.</i><p>Isn&#x27;t that exactly what it does make it?<p>If that&#x27;s not it, then what woud an actual &quot;inherently unreliable&quot; design for such a protocol be? Calling an RNG to randomly decide whether to send the next packet?</div><br/></div></div><div id="40767301" class="c"><input type="checkbox" id="c-40767301" checked=""/><div class="controls bullet"><span class="by">vince14</span><span>|</span><a href="#40766488">parent</a><span>|</span><a href="#40767092">prev</a><span>|</span><a href="#40768024">next</a><span>|</span><label class="collapse" for="c-40767301">[-]</label><label class="expand" for="c-40767301">[1 more]</label></div><br/><div class="children"><div class="content">Fire-and-forget?</div><br/></div></div><div id="40768024" class="c"><input type="checkbox" id="c-40768024" checked=""/><div class="controls bullet"><span class="by">justin66</span><span>|</span><a href="#40766488">parent</a><span>|</span><a href="#40767301">prev</a><span>|</span><a href="#40766855">next</a><span>|</span><label class="collapse" for="c-40768024">[-]</label><label class="expand" for="c-40768024">[1 more]</label></div><br/><div class="children"><div class="content">There’s nothing intuitive about what “best effort” means, but if you know anything about udp and tcp you know which is “reliable.”<p>&gt; UDP makes its best effort<p>TCP tries really hard, too, you know.</div><br/></div></div></div></div><div id="40766855" class="c"><input type="checkbox" id="c-40766855" checked=""/><div class="controls bullet"><span class="by">nyc_pizzadev</span><span>|</span><a href="#40766488">prev</a><span>|</span><a href="#40766628">next</a><span>|</span><label class="collapse" for="c-40766855">[-]</label><label class="expand" for="c-40766855">[1 more]</label></div><br/><div class="children"><div class="content">One thing not mentioned often is that a lot of networks will drop UDP packets first when encountering congestion. The thinking is that those packets will not re-transmit, so it’s an effective means to shed excess traffic. Given we now have protocols that aggressively re-transmit on UDP, I wonder how that has changed things. I do seem to remember QUIC having re-transmit issues (vs HTTP1&#x2F;2) years ago because of this.</div><br/></div></div><div id="40766628" class="c"><input type="checkbox" id="c-40766628" checked=""/><div class="controls bullet"><span class="by">mjw_byrne</span><span>|</span><a href="#40766855">prev</a><span>|</span><a href="#40766249">next</a><span>|</span><label class="collapse" for="c-40766628">[-]</label><label class="expand" for="c-40766628">[3 more]</label></div><br/><div class="children"><div class="content">Silly clickbait title, which the author even admits up front.<p>UDP and TCP have different behaviour and different tradeoffs, you have to understand them before choosing one for your use case. That&#x27;s basically it. No need for &quot;Never do X&quot; gatekeeping.</div><br/><div id="40766696" class="c"><input type="checkbox" id="c-40766696" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40766628">parent</a><span>|</span><a href="#40767694">next</a><span>|</span><label class="collapse" for="c-40766696">[-]</label><label class="expand" for="c-40766696">[1 more]</label></div><br/><div class="children"><div class="content">My apologies if the star in front of &quot;never&quot; was added to the title in the last ten minutes after you posted your comment. But that star is clearly there to indicate &quot;fine print ahead&quot;; in a title, it&#x27;s pretty obvious that it means that the article is <i>not</i> about to &quot;gatekeep&quot; people out of UDP. (In fact, at the end of the article, the author suggests to use QUIC which, you guessed it, is based on UDP.)</div><br/></div></div></div></div><div id="40766249" class="c"><input type="checkbox" id="c-40766249" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#40766628">prev</a><span>|</span><a href="#40770024">next</a><span>|</span><label class="collapse" for="c-40766249">[-]</label><label class="expand" for="c-40766249">[11 more]</label></div><br/><div class="children"><div class="content">What should be based on datagrams:<p>- Local discovery (DHCP, slaac, UPnP, mDNS, tinc, bittorrent)<p>- Broadcasts (Local network streaming)<p>- Package encapsulation (wireguard, IPSec, OpenVPN, vlan)</div><br/><div id="40766743" class="c"><input type="checkbox" id="c-40766743" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40766249">parent</a><span>|</span><a href="#40766264">next</a><span>|</span><label class="collapse" for="c-40766743">[-]</label><label class="expand" for="c-40766743">[2 more]</label></div><br/><div class="children"><div class="content">One missing from your list is real-time media. Retransmission, or even just buffering for reordering, adds latency so it&#x27;s better to take the hit of a loss with error correction or packet-loss-concealment</div><br/><div id="40771894" class="c"><input type="checkbox" id="c-40771894" checked=""/><div class="controls bullet"><span class="by">tfyoung</span><span>|</span><a href="#40766249">root</a><span>|</span><a href="#40766743">parent</a><span>|</span><a href="#40766264">next</a><span>|</span><label class="collapse" for="c-40771894">[-]</label><label class="expand" for="c-40771894">[1 more]</label></div><br/><div class="children"><div class="content">Yeah exactly. With realtime, a dropped packet is often too old by the time it&#x27;s re-transmitted. It&#x27;s actually harmful to wait for it when you&#x27;d rather just skip it and move on and stay as close to realtime as possible. It&#x27;s a very different usecase from most uses.<p>I do wish QUIC allowed carrying streams that were useful for realtime in conjunction with allowing reliable streams. Using MPEG-TS over SRT to have it just spam metadata to handle the unreliableness is janky. It would be far nicer to have a reliable stream for metadata, then an unreliable one for realtime streaming.</div><br/></div></div></div></div><div id="40766264" class="c"><input type="checkbox" id="c-40766264" checked=""/><div class="controls bullet"><span class="by">promiseofbeans</span><span>|</span><a href="#40766249">parent</a><span>|</span><a href="#40766743">prev</a><span>|</span><a href="#40766396">next</a><span>|</span><label class="collapse" for="c-40766264">[-]</label><label class="expand" for="c-40766264">[4 more]</label></div><br/><div class="children"><div class="content">Hey I&#x27;m sure you&#x27;re right, but as someone with less low-level networking expertise, I was wondering if you could explain why you&#x27;d want datagrams for these use-cases?</div><br/><div id="40766324" class="c"><input type="checkbox" id="c-40766324" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#40766249">root</a><span>|</span><a href="#40766264">parent</a><span>|</span><a href="#40766279">next</a><span>|</span><label class="collapse" for="c-40766324">[-]</label><label class="expand" for="c-40766324">[1 more]</label></div><br/><div class="children"><div class="content">TCP is a back &amp; forth between two hosts and thus cant do &quot;shouting blindly into the network&quot; things. That rules out local discovery and media broadcast.<p>Package encapsulation is bad over TCP because if the encapsulated data is TCP itself, you have congestion control twice. On congested networks, this results in extra slowdowns that can make the connection unusable.</div><br/></div></div><div id="40766279" class="c"><input type="checkbox" id="c-40766279" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766249">root</a><span>|</span><a href="#40766264">parent</a><span>|</span><a href="#40766324">prev</a><span>|</span><a href="#40766307">next</a><span>|</span><label class="collapse" for="c-40766279">[-]</label><label class="expand" for="c-40766279">[1 more]</label></div><br/><div class="children"><div class="content">Local discovery is itself based on broadcast&#x2F;multicast, both of which only work over UDP (TCP doesn&#x27;t provide any mechanism for broadcast streams).</div><br/></div></div></div></div><div id="40766484" class="c"><input type="checkbox" id="c-40766484" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#40766249">parent</a><span>|</span><a href="#40766396">prev</a><span>|</span><a href="#40770024">next</a><span>|</span><label class="collapse" for="c-40766484">[-]</label><label class="expand" for="c-40766484">[3 more]</label></div><br/><div class="children"><div class="content">And games.</div><br/><div id="40767030" class="c"><input type="checkbox" id="c-40767030" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766249">root</a><span>|</span><a href="#40766484">parent</a><span>|</span><a href="#40767095">next</a><span>|</span><label class="collapse" for="c-40767030">[-]</label><label class="expand" for="c-40767030">[1 more]</label></div><br/><div class="children"><div class="content">The whole point of the article is that you don&#x27;t <i>need</i> to go all the way down to raw datagrams to achieve the kind of low latency that is needed for things like games&#x2F;VOIP&#x2F;livestreaming</div><br/></div></div><div id="40767095" class="c"><input type="checkbox" id="c-40767095" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766249">root</a><span>|</span><a href="#40766484">parent</a><span>|</span><a href="#40767030">prev</a><span>|</span><a href="#40770024">next</a><span>|</span><label class="collapse" for="c-40767095">[-]</label><label class="expand" for="c-40767095">[1 more]</label></div><br/><div class="children"><div class="content">It totally depends on the kind of game.</div><br/></div></div></div></div></div></div><div id="40770024" class="c"><input type="checkbox" id="c-40770024" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40766249">prev</a><span>|</span><a href="#40766911">next</a><span>|</span><label class="collapse" for="c-40770024">[-]</label><label class="expand" for="c-40770024">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve attempted to replace the clickbait title* using terms from the article itself, but if someone can suggest a more representative phrase from the article, we can change it again.<p>(* in keeping with the HN&#x27;s title guideline: &quot;<i>Please use the original title, unless it is misleading or linkbait</i>&quot; - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a>)</div><br/></div></div><div id="40766911" class="c"><input type="checkbox" id="c-40766911" checked=""/><div class="controls bullet"><span class="by">cenriqueortiz</span><span>|</span><a href="#40770024">prev</a><span>|</span><a href="#40767068">next</a><span>|</span><label class="collapse" for="c-40766911">[-]</label><label class="expand" for="c-40766911">[2 more]</label></div><br/><div class="children"><div class="content">Nahhh. While most of the applications&#x2F;cases will be using session-based connections, there are uses for using datagrams directly — don’t be afraid. Yes, you will have to take care of many more details yourself. And as a side line, it is a great way of learning the low level aspects of networking.</div><br/><div id="40767011" class="c"><input type="checkbox" id="c-40767011" checked=""/><div class="controls bullet"><span class="by">ddtaylor</span><span>|</span><a href="#40766911">parent</a><span>|</span><a href="#40767068">next</a><span>|</span><label class="collapse" for="c-40767011">[-]</label><label class="expand" for="c-40767011">[1 more]</label></div><br/><div class="children"><div class="content">The SteamNetworkingMessages API for game development does a good job of making this available if you want it without caring about the internals for that use case.</div><br/></div></div></div></div><div id="40767068" class="c"><input type="checkbox" id="c-40767068" checked=""/><div class="controls bullet"><span class="by">TuringNYC</span><span>|</span><a href="#40766911">prev</a><span>|</span><a href="#40766627">next</a><span>|</span><label class="collapse" for="c-40767068">[-]</label><label class="expand" for="c-40767068">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The common wisdom is:
&gt;&gt; &gt;&gt; use TCP if you want reliable delivery
&gt;&gt; &gt;&gt; use UDP if you want unreliable delivery
&gt;&gt; What the *(&amp; does that mean? Who wants unreliability?<p>I dont agree with the premise of this article, UDP isnt for unreliability, it provides a tradeoff which trades speed and efficiency and provides best-efforts instead of guarantees.<p>It makes sense depending on your application. For example, if I have a real-time multi-player video game, and things fall behind, the items which fell behind no longer matter because the state of the game changed. Same thing for a high-speed trading application -- I only care about the most recent market data in some circumstances, not what happened 100ms ago.</div><br/><div id="40767122" class="c"><input type="checkbox" id="c-40767122" checked=""/><div class="controls bullet"><span class="by">opheliate</span><span>|</span><a href="#40767068">parent</a><span>|</span><a href="#40767114">next</a><span>|</span><label class="collapse" for="c-40767122">[-]</label><label class="expand" for="c-40767122">[1 more]</label></div><br/><div class="children"><div class="content">That isn’t the premise of the article, that is the “common wisdom” the author corrects as the article goes on. The author goes on to list video games as an example of where UDP makes sense, as well as live video.</div><br/></div></div><div id="40767114" class="c"><input type="checkbox" id="c-40767114" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#40767068">parent</a><span>|</span><a href="#40767122">prev</a><span>|</span><a href="#40766627">next</a><span>|</span><label class="collapse" for="c-40767114">[-]</label><label class="expand" for="c-40767114">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s basically what the article says if you keep on reading. It states the &quot;common wisdom&quot; at first to disagree with it.</div><br/></div></div></div></div><div id="40766627" class="c"><input type="checkbox" id="c-40766627" checked=""/><div class="controls bullet"><span class="by">thomashabets2</span><span>|</span><a href="#40767068">prev</a><span>|</span><a href="#40767150">next</a><span>|</span><label class="collapse" for="c-40766627">[-]</label><label class="expand" for="c-40766627">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The bytes within each stream are ordered, reliable, and can be any size; it’s nice and convenient. Each stream could be a video frame […] But you can tell the QUIC stack to focus on delivering important streams first. The low priority streams will be starved, and can be closed to avoid wasting bandwidth.<p>Is the author saying that with QUIC I can send a &quot;score update&quot; for my game (periodic update) on a short-lived stream, and prevent retransmissions? I&#x27;ll send an <i>updated</i> &quot;score update&quot; in a few seconds, so if the first one got lost, then I don&#x27;t want it to waste bandwidth retransmitting. Especially I don&#x27;t want it retransmitted <i>after</i> I&#x27;ve sent a newer update.</div><br/><div id="40766642" class="c"><input type="checkbox" id="c-40766642" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#40766627">parent</a><span>|</span><a href="#40767150">next</a><span>|</span><label class="collapse" for="c-40766642">[-]</label><label class="expand" for="c-40766642">[2 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re looking for RFC 9221, &quot;An Unreliable Datagram Extension to QUIC.&quot;</div><br/><div id="40767004" class="c"><input type="checkbox" id="c-40767004" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766627">root</a><span>|</span><a href="#40766642">parent</a><span>|</span><a href="#40767150">next</a><span>|</span><label class="collapse" for="c-40767004">[-]</label><label class="expand" for="c-40767004">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need datagrams for this. You can set the stream to discard itself as soon as packet loss is detected</div><br/></div></div></div></div></div></div><div id="40767150" class="c"><input type="checkbox" id="c-40767150" checked=""/><div class="controls bullet"><span class="by">dicroce</span><span>|</span><a href="#40766627">prev</a><span>|</span><a href="#40766329">next</a><span>|</span><label class="collapse" for="c-40767150">[-]</label><label class="expand" for="c-40767150">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if this guy thinks video GOPs should all be hundreds of frames long because P frames are so much smaller than I frames and since in his world we NEVER use an unreliable network you might as well.</div><br/></div></div><div id="40766329" class="c"><input type="checkbox" id="c-40766329" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#40767150">prev</a><span>|</span><a href="#40768348">next</a><span>|</span><label class="collapse" for="c-40766329">[-]</label><label class="expand" for="c-40766329">[3 more]</label></div><br/><div class="children"><div class="content">Quic is implemented over UDP. It&#x27;s literally running over datagrams.</div><br/><div id="40766356" class="c"><input type="checkbox" id="c-40766356" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#40766329">parent</a><span>|</span><a href="#40768348">next</a><span>|</span><label class="collapse" for="c-40766356">[-]</label><label class="expand" for="c-40766356">[2 more]</label></div><br/><div class="children"><div class="content">Everything at some layer has to run over datagrams, since that&#x27;s what IP is.<p>This is literally the point of the article: if you want to create a protocol over raw datagrams, you have to implement a lot of things that are very hard to get right, so you should just use QUIC instead, which does them for you.</div><br/><div id="40766430" class="c"><input type="checkbox" id="c-40766430" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#40766329">root</a><span>|</span><a href="#40766356">parent</a><span>|</span><a href="#40768348">next</a><span>|</span><label class="collapse" for="c-40766430">[-]</label><label class="expand" for="c-40766430">[1 more]</label></div><br/><div class="children"><div class="content">&quot;You&quot; is doing all the hard work. Apps should use reliable sessions and transport, almost all the time? No disagree. The exceptions are understood. But don&#x27;t pretend the substrate is that reliable data stream. &quot;We&quot; have to construct it almost always. We do reliable for you, over UDP.<p>I don&#x27;t do this stuff any more, but I worked on OSI transport and remote operations service mapped to UDP and other protocols back in the 80s</div><br/></div></div></div></div></div></div><div id="40768348" class="c"><input type="checkbox" id="c-40768348" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#40766329">prev</a><span>|</span><a href="#40770406">next</a><span>|</span><label class="collapse" for="c-40768348">[-]</label><label class="expand" for="c-40768348">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if the DiffServ[0] bits in IPv6 could be another way to prevent bufferbloat from affecting real-time datagrams? Or are they like IPv4&#x27;s ToS[1] bits, which I think were never implemented widely (or properly) enough for any software to bother with?<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Differentiated_services" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Differentiated_services</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_of_service" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_of_service</a></div><br/><div id="40772566" class="c"><input type="checkbox" id="c-40772566" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40768348">parent</a><span>|</span><a href="#40770406">next</a><span>|</span><label class="collapse" for="c-40772566">[-]</label><label class="expand" for="c-40772566">[1 more]</label></div><br/><div class="children"><div class="content">DSCP &#x2F; ToS is used for traffic classification within a network (which can be used to select router policy), but generally not across autonomous systems. You&#x27;d have to get everyone to agree on what various traffic markings mean, and, more critically, which traffic deserves to be marked in certain ways.<p>For instance, suppose that you wanted a special traffic class that&#x27;s prioritized over everything else. You really don&#x27;t want just anyone to be able to send you that kind of traffic, since a DoS attack can easily starve all the other queues.<p>Your best bet is usually to match traffic based on other characteristics, e.g. port × protocol.</div><br/></div></div></div></div><div id="40770406" class="c"><input type="checkbox" id="c-40770406" checked=""/><div class="controls bullet"><span class="by">kierank</span><span>|</span><a href="#40768348">prev</a><span>|</span><a href="#40767169">next</a><span>|</span><label class="collapse" for="c-40770406">[-]</label><label class="expand" for="c-40770406">[1 more]</label></div><br/><div class="children"><div class="content">Imagine Ethernet was designed like this and you had to implement mandatory congestion control and other cruft. The layer of the stack that has knowledge of the content should be implementing the congestion control.</div><br/></div></div><div id="40766744" class="c"><input type="checkbox" id="c-40766744" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#40767169">prev</a><span>|</span><a href="#40767300">next</a><span>|</span><label class="collapse" for="c-40766744">[-]</label><label class="expand" for="c-40766744">[1 more]</label></div><br/><div class="children"><div class="content">Great in depth article from what seems really a person who knows that stuff.</div><br/></div></div><div id="40767300" class="c"><input type="checkbox" id="c-40767300" checked=""/><div class="controls bullet"><span class="by">dragonfax</span><span>|</span><a href="#40766744">prev</a><span>|</span><a href="#40766257">next</a><span>|</span><label class="collapse" for="c-40767300">[-]</label><label class="expand" for="c-40767300">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen UDP used for great effect in video streaming. Especially timely video streaming such as cloud gaming. When waiting a late packet is no longer useful.</div><br/><div id="40771359" class="c"><input type="checkbox" id="c-40771359" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40767300">parent</a><span>|</span><a href="#40766257">next</a><span>|</span><label class="collapse" for="c-40771359">[-]</label><label class="expand" for="c-40771359">[1 more]</label></div><br/><div class="children"><div class="content">Not as popular as it once was, but it is still in use:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real-Time_Streaming_Protocol" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real-Time_Streaming_Protocol</a><p>Cheers =3</div><br/></div></div></div></div><div id="40766257" class="c"><input type="checkbox" id="c-40766257" checked=""/><div class="controls bullet"><span class="by">asdefghyk</span><span>|</span><a href="#40767300">prev</a><span>|</span><a href="#40767003">next</a><span>|</span><label class="collapse" for="c-40766257">[-]</label><label class="expand" for="c-40766257">[4 more]</label></div><br/><div class="children"><div class="content">Maybe ... never use on a congested network.<p>or Never use on a network where congestion is above a certain level<p>or Never us on a network where this parameter is above a certain level - like network latency<p>or only use on a LAN not a WAN ....?</div><br/><div id="40766383" class="c"><input type="checkbox" id="c-40766383" checked=""/><div class="controls bullet"><span class="by">ot</span><span>|</span><a href="#40766257">parent</a><span>|</span><a href="#40766320">next</a><span>|</span><label class="collapse" for="c-40766383">[-]</label><label class="expand" for="c-40766383">[1 more]</label></div><br/><div class="children"><div class="content">LAN can be oversubscribed too, even if your switches have sufficient capacity you can have short packet bursts that fill up the queues. You cannot assume reliable delivery.</div><br/></div></div><div id="40766320" class="c"><input type="checkbox" id="c-40766320" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766257">parent</a><span>|</span><a href="#40766383">prev</a><span>|</span><a href="#40767003">next</a><span>|</span><label class="collapse" for="c-40766320">[-]</label><label class="expand" for="c-40766320">[2 more]</label></div><br/><div class="children"><div class="content">Unless you are building software for a pre-established intranet, how do you predict ahead of time whether your software will run on congested networks?<p>Most end-user software ends up running on a variety of oversubscribed wifi and cell networks</div><br/><div id="40767276" class="c"><input type="checkbox" id="c-40767276" checked=""/><div class="controls bullet"><span class="by">smcameron</span><span>|</span><a href="#40766257">root</a><span>|</span><a href="#40766320">parent</a><span>|</span><a href="#40767003">next</a><span>|</span><label class="collapse" for="c-40767276">[-]</label><label class="expand" for="c-40767276">[1 more]</label></div><br/><div class="children"><div class="content">&gt; how do you predict ahead of time whether your software will run on congested networks?<p>One thing you can do is build in &quot;bad network emulation&quot; into your software, allowing the various pieces to drop packets, delay packets, reorder packets, etc. and make sure it still behaves reasonably with all this garbage turned up.</div><br/></div></div></div></div></div></div><div id="40767003" class="c"><input type="checkbox" id="c-40767003" checked=""/><div class="controls bullet"><span class="by">Anon_Admirer</span><span>|</span><a href="#40766257">prev</a><span>|</span><a href="#40766226">next</a><span>|</span><label class="collapse" for="c-40767003">[-]</label><label class="expand" for="c-40767003">[1 more]</label></div><br/><div class="children"><div class="content">Hope this one gets captured by quackernews - can’t wait to see its description.</div><br/></div></div><div id="40766226" class="c"><input type="checkbox" id="c-40766226" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40767003">prev</a><span>|</span><a href="#40768704">next</a><span>|</span><label class="collapse" for="c-40766226">[-]</label><label class="expand" for="c-40766226">[12 more]</label></div><br/><div class="children"><div class="content">It mentions that the video game industry uses UDP but then fails to  further address that use case. So, should competitive shooter video games switch to QUIC? Is that even supported across all the various gaming platforms?</div><br/><div id="40766269" class="c"><input type="checkbox" id="c-40766269" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766226">parent</a><span>|</span><a href="#40766473">next</a><span>|</span><label class="collapse" for="c-40766269">[-]</label><label class="expand" for="c-40766269">[9 more]</label></div><br/><div class="children"><div class="content">&gt; It mentions that the video game industry uses UDP but then fails to further address that use case<p>Video games tend to use UDP for the same reason everyone else mentioned does: timeliness. You want the most recent position of the various game objects <i>now</i>, and you don&#x27;t give a shit about where they were 100ms ago.<p>The proposed solution of segmenting data into QUIC streams and mucking with priorities should work just fine for a game.<p>&gt; Is that even supported across all the various gaming platforms?<p>QUIC itself is implemented in terms of datagrams, so if you have datagrams, you can have QUIC.</div><br/><div id="40766578" class="c"><input type="checkbox" id="c-40766578" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766269">parent</a><span>|</span><a href="#40766556">next</a><span>|</span><label class="collapse" for="c-40766578">[-]</label><label class="expand" for="c-40766578">[4 more]</label></div><br/><div class="children"><div class="content">But the proposed solution provides no value over datagrams, while it has plenty of downsides.<p>Let me rephrase the problem here for a simple FPS game:<p>The entire world state (or, the subset that the client is supposed to know about) is provided in each packet sent from the server. The last few actions with timestamps are in each packet sent from the client. You always want to have the latest of each, with lowest possible latency. Both sides send one packet per tick.<p>You do not want retransmission based on the knowledge that a packet was lost (the RTT is <i>way</i> too long for the information that a packet was lost to ever be useful, you just retransmit everything every tick), you do not want congestion control (total bandwidth is negligible, and if there is too much packet loss to maintain what is required, there is no possible solution to maintain sufficient performance and you shouldn&#x27;t even try), and none of the other features talked about in the post add anything of value, either.<p>It reads like someone really likes QUIC, it fit well into their problems, and they are a bit too enthusiastic about evangelizing it.</div><br/><div id="40766878" class="c"><input type="checkbox" id="c-40766878" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766578">parent</a><span>|</span><a href="#40766556">next</a><span>|</span><label class="collapse" for="c-40766878">[-]</label><label class="expand" for="c-40766878">[3 more]</label></div><br/><div class="children"><div class="content">In practice most games <i>also</i> need reliable side channels for control messages&#x2F;chat&#x2F;etc, and so they end up building optional reliable streams over UDP... and at the end of this path lies something that looks a lot like a (less thoroughly designed&#x2F;tested) version of QUIC</div><br/><div id="40770250" class="c"><input type="checkbox" id="c-40770250" checked=""/><div class="controls bullet"><span class="by">paradox460</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766878">parent</a><span>|</span><a href="#40769610">next</a><span>|</span><label class="collapse" for="c-40770250">[-]</label><label class="expand" for="c-40770250">[1 more]</label></div><br/><div class="children"><div class="content">Tribes, and various quake mods, used to use a TCP side channel for chat and control messages. Tribes famously used irc, and you could connect to a tribes server with any irc client to chat with your friends in game</div><br/></div></div><div id="40769610" class="c"><input type="checkbox" id="c-40769610" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766878">parent</a><span>|</span><a href="#40770250">prev</a><span>|</span><a href="#40766556">next</a><span>|</span><label class="collapse" for="c-40769610">[-]</label><label class="expand" for="c-40769610">[1 more]</label></div><br/><div class="children"><div class="content">My spidey sense is that almost all games used a custom UDP solution. I could be wrong! I made a Twitter poll to try and get info.<p>You’re right that a custom reliable UDP solution is going to wind up QUIC-like. On the other hand it’s what games have been doing for over 20 years. It’s not particularly difficult to write a custom layer that does exactly what a given project needs.<p>I don’t enough about QUIC to know if it adds unnecessary complexity or not.</div><br/></div></div></div></div></div></div><div id="40766556" class="c"><input type="checkbox" id="c-40766556" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766269">parent</a><span>|</span><a href="#40766578">prev</a><span>|</span><a href="#40766549">next</a><span>|</span><label class="collapse" for="c-40766556">[-]</label><label class="expand" for="c-40766556">[2 more]</label></div><br/><div class="children"><div class="content">I thought QUIC promised you get your data eventually? In that case it wouldn&#x27;t be great for games, because you usually don&#x27;t want packets that got dropped, as the next packet will replace it anyway?</div><br/><div id="40766866" class="c"><input type="checkbox" id="c-40766866" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766556">parent</a><span>|</span><a href="#40766549">next</a><span>|</span><label class="collapse" for="c-40766866">[-]</label><label class="expand" for="c-40766866">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I thought QUIC promised you get your data eventually?<p>QUIC optionally promises you that, you are free to opt out. For example, take a look at the QUIC_SEND_FLAG_CANCEL_ON_LOSS flag on Microsoft&#x27;s QUIC implementation.</div><br/></div></div></div></div><div id="40766549" class="c"><input type="checkbox" id="c-40766549" checked=""/><div class="controls bullet"><span class="by">chrisfarms</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766269">parent</a><span>|</span><a href="#40766556">prev</a><span>|</span><a href="#40766473">next</a><span>|</span><label class="collapse" for="c-40766549">[-]</label><label class="expand" for="c-40766549">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Video games tend to use UDP for the same reason everyone else mentioned does: timeliness. You want the most recent position of the various game objects now, and you don&#x27;t give a shit about where they were 100ms ago.<p>This is only true for games that can replicate their entire state in each packet.<p>There are many situations where this is infeasible and so you may be replicating diffs of the state, partial state, or even replicating the player inputs instead of any state at all.<p>In those cases the &quot;latest&quot; packet is not necessarily enough, the &quot;timliness&quot; property does not quite cover the requirements, and like with most things, it&#x27;s a &quot;it depends&quot;.</div><br/><div id="40766883" class="c"><input type="checkbox" id="c-40766883" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#40766226">root</a><span>|</span><a href="#40766549">parent</a><span>|</span><a href="#40766473">next</a><span>|</span><label class="collapse" for="c-40766883">[-]</label><label class="expand" for="c-40766883">[1 more]</label></div><br/><div class="children"><div class="content">With those requirements raw datagrams also don&#x27;t fit the bill, so you&#x27;ll need to build some sort of reliable stream abstraction over UDP (with optional unreliable delivery for the state which you can replicate quickly)... and now we&#x27;re closing in on QUIC territory</div><br/></div></div></div></div></div></div><div id="40766473" class="c"><input type="checkbox" id="c-40766473" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40766226">parent</a><span>|</span><a href="#40766269">prev</a><span>|</span><a href="#40766321">next</a><span>|</span><label class="collapse" for="c-40766473">[-]</label><label class="expand" for="c-40766473">[1 more]</label></div><br/><div class="children"><div class="content">QUIC is implemented in userspace, it doesn&#x27;t need platform support beyond the basic networking stack.</div><br/></div></div><div id="40766321" class="c"><input type="checkbox" id="c-40766321" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40766226">parent</a><span>|</span><a href="#40766473">prev</a><span>|</span><a href="#40768704">next</a><span>|</span><label class="collapse" for="c-40766321">[-]</label><label class="expand" for="c-40766321">[1 more]</label></div><br/><div class="children"><div class="content">No, QUIC is mostly for Google to enforce E2E advertisment.</div><br/></div></div></div></div><div id="40768704" class="c"><input type="checkbox" id="c-40768704" checked=""/><div class="controls bullet"><span class="by">ta1243</span><span>|</span><a href="#40766226">prev</a><span>|</span><a href="#40766450">next</a><span>|</span><label class="collapse" for="c-40768704">[-]</label><label class="expand" for="c-40768704">[1 more]</label></div><br/><div class="children"><div class="content">Used high numbers of UDP packets over intercontinental internet links for mission critical applications for 15 years. 20mbit of UDP carrying RTP. Loss on a given flow is quite rare, and the application helps (via duplication, or retransmits)<p>As time has progressed increased from nothing to fec to dual-streaming and offset-streaming to RIST and SRT depending on the criticality.<p>On the other hand I&#x27;ve seen people try to use TCP (with rtmp) and fail miserably. Never* use TCP.<p>Or you know, use the right tool for the right job.</div><br/></div></div><div id="40766450" class="c"><input type="checkbox" id="c-40766450" checked=""/><div class="controls bullet"><span class="by">bitcharmer</span><span>|</span><a href="#40768704">prev</a><span>|</span><a href="#40766558">next</a><span>|</span><label class="collapse" for="c-40766450">[-]</label><label class="expand" for="c-40766450">[3 more]</label></div><br/><div class="children"><div class="content">This is a narrow way of looking at UDP applications. The whole HFT, low-latency fintech world is built on top of datagrams. Using TCP would be pure the worst choice possible.</div><br/><div id="40769761" class="c"><input type="checkbox" id="c-40769761" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#40766450">parent</a><span>|</span><a href="#40766558">next</a><span>|</span><label class="collapse" for="c-40769761">[-]</label><label class="expand" for="c-40769761">[2 more]</label></div><br/><div class="children"><div class="content">Is that because they mostly use dedicated links and intranets?<p>A lot of Enterprise messaging is based on UDP, I think on the presumption that corporate networks are just simply going to be a lot more reliable</div><br/><div id="40773131" class="c"><input type="checkbox" id="c-40773131" checked=""/><div class="controls bullet"><span class="by">bitcharmer</span><span>|</span><a href="#40766450">root</a><span>|</span><a href="#40769761">parent</a><span>|</span><a href="#40766558">next</a><span>|</span><label class="collapse" for="c-40773131">[-]</label><label class="expand" for="c-40773131">[1 more]</label></div><br/><div class="children"><div class="content">You are correct, it&#x27;s either point-to-point, like direct cross-connects with the exchange or it&#x27;s a relatively small intranet.
Additionally, an overwhelming majority of packets flying around are market data. You don&#x27;t want to re-transmit lost ones because by the time you do, the data is already outdated.</div><br/></div></div></div></div></div></div><div id="40766558" class="c"><input type="checkbox" id="c-40766558" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#40766450">prev</a><span>|</span><a href="#40767120">next</a><span>|</span><label class="collapse" for="c-40766558">[-]</label><label class="expand" for="c-40766558">[1 more]</label></div><br/><div class="children"><div class="content">Network is nothing but datagrams.</div><br/></div></div><div id="40767120" class="c"><input type="checkbox" id="c-40767120" checked=""/><div class="controls bullet"><span class="by">20k</span><span>|</span><a href="#40766558">prev</a><span>|</span><a href="#40766615">next</a><span>|</span><label class="collapse" for="c-40767120">[-]</label><label class="expand" for="c-40767120">[3 more]</label></div><br/><div class="children"><div class="content">I feel like this article misses why people avoid TCP like the plague, and why people use UDP for many applications<p>1. Routers do all kinds of terrible things with TCP, causing high latency, and poor performance. Routers do not do this to nearly the same extent with UDP<p>2. Operating systems have a tendency to buffer for high lengths of time, resulting in very poor performance due to high latency. TCP is often seriously unusable for deployment on a random clients default setup. Getting caught out by Nagle is a classic mistake, its one of the first things to look for in a project suffering from tcp issues<p>3. TCP is stream based, which I don&#x27;t think has ever been what I want. You have to reimplement your own protocol on top of TCP anyway to introduce message frames<p>4. The model of network failures that TCP works well for is a bit naive, network failures tend to cluster together making the reliability guarantees not that useful a lot of the time. Failures don&#x27;t tend to be statistically independent, and your connection will drop requiring you to start again anyway<p>5. TCP&#x27;s backoff model on packet failures is both incredibly aggressive, and mismatched for a flaky physical layer. Even a tiny % of packet loss can make your performance unusable, to the point where the concept of using TCP is completely unworkable<p>Its also worth noting that people use &quot;unreliable&quot; to mean UDP for its promptness guarantees, because reliable = TCP, and unreliable = UDP<p>QUIC and TCP actively don&#x27;t meet the needs of certain applications - its worth examining a use case that&#x27;s kind of glossed over in the article: Videogames<p>I think this article misses the point strongly here by ignoring this kind of use case, because in many domains you have a performance and fault model that are simply not well matched by a protocol like TCP or QUIC. None of the features on the protocol list are things that you especially need or even can implement for videogames (you really want to encrypt player positions?). In a game, your update rate might be 1KB&#x2F;s - absolutely tiny. If more than N packets get dropped - under TCP <i>or</i> UDP (or quic) - because games are a hard realtime system you&#x27;re screwed, and there&#x27;s nothing you can do about it no matter what protocol you&#x27;re using. If you use QUIC, the server will attempt to send the packet again which.... is completely pointless, and now you&#x27;re stuck waiting for potentially a whole queue of packets to send if your network hiccups for a second, with presumably whatever congestion control QUIC implements, so your game lags even more once your network recovers. Ick! Should we have a separate queue for every packet?<p>Videogame networking protocols are built to tolerate the loss of a certain number of packets within a certain timeframe (eg 1 every 200ms), and this system has to be extremely tightly integrated into the game architecture to maintain your hard realtime guarantees. Adding quic is just overhead, because the reliability that QUIC provides, and the reliability that games need, are not the same kind of reliability<p>Congestion in a videogame with low bandwidths is <i>extremely</i> unlikely. The issue is that network protocols have no way to know if a dropped packet is because of congestion, or because of a flaky underlying connection. Videogames assume a priori that you do not have congestion (otherwise your game is unplayable), so all recoverable networking failures are 1 off transient network failures of less than a handful of packets by definition. When you drop a packet in a videogame, the server may <i>increase</i> its update rate to catch you up via time dilation, rather than in a protocol like TCP&#x2F;QUIC which will reduce its update rate. A well designed game built on UDP tolerates a slightly flakey connection. If you use TCP or QUIC, you&#x27;ll run into problems. QUIC isn&#x27;t terrible, but its not good for this kind of application, and we shouldn&#x27;t pretend its fine<p>For more information about a good game networking system, see this video: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=odSBJ49rzDo" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=odSBJ49rzDo</a>, and it goes over pretty in detail why you shouldn&#x27;t use something like QUIC</div><br/><div id="40773245" class="c"><input type="checkbox" id="c-40773245" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#40767120">parent</a><span>|</span><a href="#40768056">next</a><span>|</span><label class="collapse" for="c-40773245">[-]</label><label class="expand" for="c-40773245">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 3. TCP is stream based, which I don&#x27;t think has ever been what I want. You have to reimplement your own protocol on top of TCP anyway to introduce message frames<p>I&#x27;m always curious where frame proponents are going to buffer in-progress frames. OS? I have huge memory concerns. Also take note you want to drop in-order requirement and it means multiple in-progress frames. It&#x27;s a very nice DoS vector.</div><br/></div></div><div id="40768056" class="c"><input type="checkbox" id="c-40768056" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40767120">parent</a><span>|</span><a href="#40773245">prev</a><span>|</span><a href="#40766615">next</a><span>|</span><label class="collapse" for="c-40768056">[-]</label><label class="expand" for="c-40768056">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 1. Routers do all kinds of terrible things with TCP, causing high latency, and poor performance. Routers do not do this to nearly the same extent with UDP<p>What things are you thinking of here?<p>&gt; 2. Operating systems have a tendency to buffer for high lengths of time, resulting in very poor performance due to high latency.<p>Do they? I can only think of Nagle&#x27;s algorithm causing any potential buffering delay on the OS level, and you can deactivate that via TCP_NODELAY on most OSes.<p>&gt; 5. TCP&#x27;s backoff model on packet failures is both incredibly aggressive, and mismatched for a flaky physical layer. Even a tiny % of packet loss can make your performance unusable, to the point where the concept of using TCP is completely unworkable<p>That&#x27;s a property of your specific TCP implementation&#x27;s congestion control algorithm, nothing inherent to TCP. TCP BBR is quite resistant to non-congestion-induced packet loss, for example [1].<p>&gt; If you use QUIC, the server will attempt to send the packet again which.... is completely pointless<p>Isn&#x27;t one of QUIC&#x27;s features that you can cancel pending streams, which explicitly solves that issue? In your implementation, if you send update type x for frame n+1, you could just cancel all pending updates of type x if every update contains your complete new state.<p>[1] <a href="https:&#x2F;&#x2F;atoonk.medium.com&#x2F;tcp-bbr-exploring-tcp-congestion-control-84c9c11dc3a9" rel="nofollow">https:&#x2F;&#x2F;atoonk.medium.com&#x2F;tcp-bbr-exploring-tcp-congestion-c...</a></div><br/></div></div></div></div><div id="40766615" class="c"><input type="checkbox" id="c-40766615" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#40767120">prev</a><span>|</span><a href="#40767246">next</a><span>|</span><label class="collapse" for="c-40766615">[-]</label><label class="expand" for="c-40766615">[45 more]</label></div><br/><div class="children"><div class="content">IMO one of the worst mistakes made in IP development was not having made a standard protocol for the one thing that pretty much everyone seems to want:<p>A reliable, unlimited-length, message-based protocol.<p>With TCP there&#x27;s a million users that throw out the stream aspect and implement messages on top of it. And with UDP people implement reliability and the ability to transmit &gt;1 MTU.<p>So much time wasted reinventing the wheel.</div><br/><div id="40767103" class="c"><input type="checkbox" id="c-40767103" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766703">next</a><span>|</span><label class="collapse" for="c-40767103">[-]</label><label class="expand" for="c-40767103">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because TCP evolved as, essentially, abstraction of serial port.<p>And due to various political &amp; cultural &amp; industrial lobbying, more flexible but complex on their face approaches (OSI) were rejected.<p>TCP meant you could easily attach a serial terminal to a stream, a text protocol meant you could interact or debug a protocol by throwing together a sandwich, an undergrad, and a serial terminal (coffee too if they do a good job). You could also in theory use something like SMTP from a terminal attached over a TIP (which provided dial-in connection into ARPAnet where you told the TIP what host and what port you wanted).<p>If you look through some of the old protocol definitions you&#x27;ll note that a bunch of them actually refer to simplest mode of TELNET as base.<p>Then in extension of arguably the same behaviour that blocked GOSIP mandate we have pretty much reduced internet to TCP, UDP, and bits of ICMP, because you can&#x27;t depend on plain IP connectivity in a world of NAT and broken middleboxes.</div><br/></div></div><div id="40766703" class="c"><input type="checkbox" id="c-40766703" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40767103">prev</a><span>|</span><a href="#40773282">next</a><span>|</span><label class="collapse" for="c-40766703">[-]</label><label class="expand" for="c-40766703">[8 more]</label></div><br/><div class="children"><div class="content">Sorry for a useless comment but now I feel so stupid for never noticing that pretty much everything done on TCP is actually message exchange, not streams. The mismatch is indeed so unfortunate.</div><br/><div id="40767722" class="c"><input type="checkbox" id="c-40767722" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766703">parent</a><span>|</span><a href="#40766981">next</a><span>|</span><label class="collapse" for="c-40767722">[-]</label><label class="expand" for="c-40767722">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I feel so stupid for never noticing that pretty much everything done on TCP is actually message exchange, not streams.<p>This generalization isn’t true at all. Streaming data over TCP is extremely common in many applications.<p>When you download a large file, you’re streaming it to disk, for example.<p>I guess you could get pedantic and argue that an entire stream of something is actually one large message, but that’s really straining the definitions.</div><br/></div></div><div id="40766981" class="c"><input type="checkbox" id="c-40766981" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766703">parent</a><span>|</span><a href="#40767722">prev</a><span>|</span><a href="#40767067">next</a><span>|</span><label class="collapse" for="c-40766981">[-]</label><label class="expand" for="c-40766981">[2 more]</label></div><br/><div class="children"><div class="content">Well, you often have some dependency between messages.  Some re-orderings don&#x27;t matter, but some do.<p>If you just keep everything in the same order, then you never have to worry about any re-ordering.<p>I can see why people picked streams as the one-size-fits-all-(but-badly) abstraction.</div><br/><div id="40767225" class="c"><input type="checkbox" id="c-40767225" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766981">parent</a><span>|</span><a href="#40767067">next</a><span>|</span><label class="collapse" for="c-40767225">[-]</label><label class="expand" for="c-40767225">[1 more]</label></div><br/><div class="children"><div class="content">Because worse is better and if you try to be everything you (don&#x27;t) get OSI. Also because everyone loves serial ports and dialup modems and TCP just emulates a serial port over packet network. And it wasn&#x27;t supposed to be one-size-fits-all, rather «let us have telnet while we figuring out the rest» but then ossification happend.</div><br/></div></div></div></div><div id="40767067" class="c"><input type="checkbox" id="c-40767067" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766703">parent</a><span>|</span><a href="#40766981">prev</a><span>|</span><a href="#40773282">next</a><span>|</span><label class="collapse" for="c-40767067">[-]</label><label class="expand" for="c-40767067">[4 more]</label></div><br/><div class="children"><div class="content">Is it really that unfortunate? What’s the big downside?<p>There’s a bit of reinvention needed, sure, but adding a framing layer is about the easiest task in networking. If you want a standard way of doing it, these days you can use a WebSocket.<p><i>Edit to add:</i> oh, I see, you want reliable but unordered messages. That would definitely be useful sometimes, but other times you do want ordering. If you don’t need ordering, isn’t that pretty much what QUIC does?</div><br/><div id="40767112" class="c"><input type="checkbox" id="c-40767112" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767067">parent</a><span>|</span><a href="#40767493">next</a><span>|</span><label class="collapse" for="c-40767112">[-]</label><label class="expand" for="c-40767112">[1 more]</label></div><br/><div class="children"><div class="content">SCTP did both reliable&#x2F;unreliable and ordered&#x2F;unordered, with QUIC arguably being at least a bit inspired by it, but going over UDP because internet is broken.<p>EDIT: Internet being broken is also why there&#x27;s a grease extension for QUIC</div><br/></div></div><div id="40767493" class="c"><input type="checkbox" id="c-40767493" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767067">parent</a><span>|</span><a href="#40767112">prev</a><span>|</span><a href="#40773282">next</a><span>|</span><label class="collapse" for="c-40767493">[-]</label><label class="expand" for="c-40767493">[2 more]</label></div><br/><div class="children"><div class="content">What would ‘reliable but unordered’ even mean? What’s the difference between a dropped message and one that’s just late?</div><br/><div id="40767550" class="c"><input type="checkbox" id="c-40767550" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767493">parent</a><span>|</span><a href="#40773282">next</a><span>|</span><label class="collapse" for="c-40767550">[-]</label><label class="expand" for="c-40767550">[1 more]</label></div><br/><div class="children"><div class="content">The difference is whether you get to process the ones which came after first or you must wait for the retransmission of the earlier ones. FWIW, SCTP provides for this difference.</div><br/></div></div></div></div></div></div></div></div><div id="40773282" class="c"><input type="checkbox" id="c-40773282" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766703">prev</a><span>|</span><a href="#40766804">next</a><span>|</span><label class="collapse" for="c-40773282">[-]</label><label class="expand" for="c-40773282">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unlimited-length<p>Where to keep in-progress frame data? I case of TCP it&#x27;s an app and buffer for only a single frame or app even could make &quot;stream processing&quot; for in-progress frame.</div><br/></div></div><div id="40766804" class="c"><input type="checkbox" id="c-40766804" checked=""/><div class="controls bullet"><span class="by">jzwinck</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40773282">prev</a><span>|</span><a href="#40766826">next</a><span>|</span><label class="collapse" for="c-40766804">[-]</label><label class="expand" for="c-40766804">[4 more]</label></div><br/><div class="children"><div class="content">Here is a good message framing protocol built on TCP: <a href="https:&#x2F;&#x2F;www.nasdaq.com&#x2F;docs&#x2F;SoupBinTCP%204.0.pdf" rel="nofollow">https:&#x2F;&#x2F;www.nasdaq.com&#x2F;docs&#x2F;SoupBinTCP%204.0.pdf</a><p>If you want large messages just redefine the length from 16 to 32 bits.<p>It&#x27;s been used for millions of messages per day for 25 years and hasn&#x27;t been changed in a long time.<p>Admittedly it isn&#x27;t as common as TCP and that&#x27;s a shame. But it&#x27;s out there, it&#x27;s public, it&#x27;s minimal and it makes sense.</div><br/><div id="40766984" class="c"><input type="checkbox" id="c-40766984" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766804">parent</a><span>|</span><a href="#40766826">next</a><span>|</span><label class="collapse" for="c-40766984">[-]</label><label class="expand" for="c-40766984">[3 more]</label></div><br/><div class="children"><div class="content">&gt; SoupBinTCP guarantees that the client receives each
sequenced message generated by the server in the correct order, [...]<p>This protocol guarantees too much.  It&#x27;s still a stream.</div><br/><div id="40767391" class="c"><input type="checkbox" id="c-40767391" checked=""/><div class="controls bullet"><span class="by">jzwinck</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766984">parent</a><span>|</span><a href="#40766826">next</a><span>|</span><label class="collapse" for="c-40767391">[-]</label><label class="expand" for="c-40767391">[2 more]</label></div><br/><div class="children"><div class="content">You quoted the part about sequenced messages. Look at the part about unsequenced messages right after that. It has both.</div><br/><div id="40772891" class="c"><input type="checkbox" id="c-40772891" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767391">parent</a><span>|</span><a href="#40766826">next</a><span>|</span><label class="collapse" for="c-40772891">[-]</label><label class="expand" for="c-40772891">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div></div></div></div></div><div id="40766826" class="c"><input type="checkbox" id="c-40766826" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766804">prev</a><span>|</span><a href="#40766751">next</a><span>|</span><label class="collapse" for="c-40766826">[-]</label><label class="expand" for="c-40766826">[8 more]</label></div><br/><div class="children"><div class="content">Actually, the mistake in IP was in not encrypting the  next layer, so that networks can block transport protocol innovation by filtering anything other than TCP and UDP. This is the mistake that quic has fixed.</div><br/><div id="40766958" class="c"><input type="checkbox" id="c-40766958" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766826">parent</a><span>|</span><a href="#40767098">next</a><span>|</span><label class="collapse" for="c-40766958">[-]</label><label class="expand" for="c-40766958">[1 more]</label></div><br/><div class="children"><div class="content">I think that one can be forgiven for pure lack of processing power... We forget just how under powered even host machines were and how resource hungry encryption is...</div><br/></div></div><div id="40767098" class="c"><input type="checkbox" id="c-40767098" checked=""/><div class="controls bullet"><span class="by">d-z-m</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766826">parent</a><span>|</span><a href="#40766958">prev</a><span>|</span><a href="#40767265">next</a><span>|</span><label class="collapse" for="c-40767098">[-]</label><label class="expand" for="c-40767098">[4 more]</label></div><br/><div class="children"><div class="content">QUIC still runs over UDP.  Are you referring to MASQUE?</div><br/><div id="40767211" class="c"><input type="checkbox" id="c-40767211" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767098">parent</a><span>|</span><a href="#40767265">next</a><span>|</span><label class="collapse" for="c-40767211">[-]</label><label class="expand" for="c-40767211">[3 more]</label></div><br/><div class="children"><div class="content">I should perhaps have said &quot;works round&quot; rather than fixes - yes, it has to run over UDP but the quic team had an explicit goal of not allowing the network to interfere further : see sec 3.3 and 7.5 of <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3098822.3098842" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3098822.3098842</a><p>This now means that innovations based on Quic can occur</div><br/><div id="40767634" class="c"><input type="checkbox" id="c-40767634" checked=""/><div class="controls bullet"><span class="by">mycall</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767211">parent</a><span>|</span><a href="#40767265">next</a><span>|</span><label class="collapse" for="c-40767634">[-]</label><label class="expand" for="c-40767634">[2 more]</label></div><br/><div class="children"><div class="content">Since both QUIC and UDP are transport layers, does this mean that once switches and ISPs start supporting QUIC along side UDP and TCP, that a new version of QUIC can be released which doesn&#x27;t require UDP?</div><br/><div id="40769446" class="c"><input type="checkbox" id="c-40769446" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767634">parent</a><span>|</span><a href="#40767265">next</a><span>|</span><label class="collapse" for="c-40769446">[-]</label><label class="expand" for="c-40769446">[1 more]</label></div><br/><div class="children"><div class="content">Switches don&#x27;t need to change anything to support QUIC, precisely because it uses UDP. So, the deployment of QUIC doesn&#x27;t involve any <i>technical</i> changes that would enable a version of QUIC that worked directly over IP.  It&#x27;s possible that the defeat of middleboxes would change the <i>motivation</i> of ISPs to filter out alternate protocol numbers, meaning that there might be less resistance to getting them to allow that in the future - but doing so is still a big exercise.<p>Also, the overhead of a UDP packet is 8 bytes total, in 4 16-bit fields:<p>- source port<p>- dest port<p>- length<p>- checksum<p>So, we can save a max of 8 bytes per packet - how many of these can we practically save?  The initial connection requires source and dest ports, but also sets up other connection IDs so <i>theoretically</i> you could save them on subsequent packets (but that&#x27;s pure speculation, with zero due diligence on my part). It would require operational changes and would make any NATs tricky (so practically only for IPv6)
Length and checksum <i>maybe</i> you can save - QUIC has multiple frames per UDP datagram so there must be another length field there (anyway, IETF is busily inventing a UDP options format on the basis that the UDP length field is redundant to packet length, so can be used to point at an options trailer). QUIC has integrity protection but it doesn&#x27;t seem to apply to all packet types  - however I guess a checksum could be retained for those that don&#x27;t only.<p>So in sum maybe you could save up to 8 bytes per packet, but it would still be a lot of work to do so (removing port numbers especially)</div><br/></div></div></div></div></div></div></div></div><div id="40767265" class="c"><input type="checkbox" id="c-40767265" checked=""/><div class="controls bullet"><span class="by">DoneWithAllThat</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766826">parent</a><span>|</span><a href="#40767098">prev</a><span>|</span><a href="#40767460">next</a><span>|</span><label class="collapse" for="c-40767265">[-]</label><label class="expand" for="c-40767265">[1 more]</label></div><br/><div class="children"><div class="content">This was absolutely not feasible at the time IP was being developed. There simply wasn’t enough computational power available or good encryption algorithms invented yet. And you can make a reasonable argument that that’s not the responsibility of that layer of the stack.</div><br/></div></div><div id="40767460" class="c"><input type="checkbox" id="c-40767460" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766826">parent</a><span>|</span><a href="#40767265">prev</a><span>|</span><a href="#40766751">next</a><span>|</span><label class="collapse" for="c-40767460">[-]</label><label class="expand" for="c-40767460">[1 more]</label></div><br/><div class="children"><div class="content">Encryption without authentication is rather useless. Just slows things down for no advantage.</div><br/></div></div></div></div><div id="40766751" class="c"><input type="checkbox" id="c-40766751" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766826">prev</a><span>|</span><a href="#40766739">next</a><span>|</span><label class="collapse" for="c-40766751">[-]</label><label class="expand" for="c-40766751">[8 more]</label></div><br/><div class="children"><div class="content">Now I wonder. Do we have any actual streaming use of TCP, with purely streaming protocol.</div><br/><div id="40767002" class="c"><input type="checkbox" id="c-40767002" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766751">parent</a><span>|</span><a href="#40768050">next</a><span>|</span><label class="collapse" for="c-40767002">[-]</label><label class="expand" for="c-40767002">[3 more]</label></div><br/><div class="children"><div class="content">Yes.  When your messages need to be received and processed in the same order they are sent, then a stream is a good (or good enough) abstraction.<p>For most applications some re-orderings of messages don&#x27;t matter, and others would need special handling.  So as a one-size-fits-all-(but-badly) abstraction you can use a stream.<p>&gt; Do we have any actual streaming use of TCP, with purely streaming protocol.<p>But to give you a proper answer: the stream of keyboard inputs from the user to the server in Telnet (or SSH).</div><br/><div id="40767065" class="c"><input type="checkbox" id="c-40767065" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767002">parent</a><span>|</span><a href="#40768050">next</a><span>|</span><label class="collapse" for="c-40767065">[-]</label><label class="expand" for="c-40767065">[2 more]</label></div><br/><div class="children"><div class="content">Opens up the question that if you have &quot;messages&quot; are you a stream anymore? Can your stream of messages start mid message for example? Surely a stream can have this happen. Or are you instead messages send over a stream. In which case abstraction of stream instead of reliable message transportation is bit weird.<p>Wouldn&#x27;t each input be a single albeit too short message? But this level of granularity really makes little sense...</div><br/><div id="40772889" class="c"><input type="checkbox" id="c-40772889" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767065">parent</a><span>|</span><a href="#40768050">next</a><span>|</span><label class="collapse" for="c-40772889">[-]</label><label class="expand" for="c-40772889">[1 more]</label></div><br/><div class="children"><div class="content">If you have a reliable-byte-stream abstraction, you only need to add a way to serialise your messages into bytes, and you get a reliable-messages-in-order abstraction for &#x27;free&#x27;.  That&#x27;s convenient!  And you don&#x27;t need to teach your lower level protocols about where your higher level messages start and end.<p>You can also stick your higher level messages into a structure that&#x27;s more complicated than a stream, eg you can stick them into a tree.  Anything you can serialise, you can send.<p>Of course, the downside to this is that when you don&#x27;t need these strong guarantees, you are paying for stuff you don&#x27;t need.</div><br/></div></div></div></div></div></div><div id="40768050" class="c"><input type="checkbox" id="c-40768050" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766751">parent</a><span>|</span><a href="#40767002">prev</a><span>|</span><a href="#40767693">next</a><span>|</span><label class="collapse" for="c-40768050">[-]</label><label class="expand" for="c-40768050">[1 more]</label></div><br/><div class="children"><div class="content">Think about what the feature (potentially) buys you:<p>(1) zero-copy, zero-allocation request processing<p>(2) up to a 2x latency reduction by intermingling networking and actual work<p>(3) more cache friendliness<p>(4) better performance characteristics on composition (multiple stages which all have to batch their requests and responses will balloon perceived latency)<p>If you have a simple system (only a few layers of networking), low QPS (under a million), small requests (average under 1KB, max under 1MB), and reasonable latency requirements (no human user can tell a microsecond from a millisecond), just batch everything and be done with it. It&#x27;s not worth the engineering costs to do anything fancy when a mid-tier laptop can run your service with the dumb implementation.<p>As soon as those features start to matter, streaming starts to make more sense. I normally see it being used for cost reasons in very popular services, when every latency improvement matters for a given application, when you don&#x27;t have room to buffer the whole request, or to create very complicated networked systems.</div><br/></div></div><div id="40767693" class="c"><input type="checkbox" id="c-40767693" checked=""/><div class="controls bullet"><span class="by">nyc_pizzadev</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766751">parent</a><span>|</span><a href="#40768050">prev</a><span>|</span><a href="#40766739">next</a><span>|</span><label class="collapse" for="c-40767693">[-]</label><label class="expand" for="c-40767693">[3 more]</label></div><br/><div class="children"><div class="content">High quality VOD (ie streaming a 4K movie). HTTP block file systems, each block needs to be streamed reliably to fulfill the read() call plus read ahead.</div><br/><div id="40767816" class="c"><input type="checkbox" id="c-40767816" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767693">parent</a><span>|</span><a href="#40766739">next</a><span>|</span><label class="collapse" for="c-40767816">[-]</label><label class="expand" for="c-40767816">[2 more]</label></div><br/><div class="children"><div class="content">For VOD can I just open connection and send single message and then stream will continue forever? And HTTP is message oriented protocol. I can&#x27;t just send infinite length HTTP message. Which would be processed as it arrives or can I? Meaning can I upload something not that small like terabyte of video data over HTTP?</div><br/><div id="40769604" class="c"><input type="checkbox" id="c-40769604" checked=""/><div class="controls bullet"><span class="by">nyc_pizzadev</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767816">parent</a><span>|</span><a href="#40766739">next</a><span>|</span><label class="collapse" for="c-40769604">[-]</label><label class="expand" for="c-40769604">[1 more]</label></div><br/><div class="children"><div class="content">Yes for everything. In HTTP1 it’s a chunked response, in H2+ it’s just a bunch of data frames. This is how low latency HLS video works.</div><br/></div></div></div></div></div></div></div></div><div id="40766739" class="c"><input type="checkbox" id="c-40766739" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766751">prev</a><span>|</span><a href="#40767256">next</a><span>|</span><label class="collapse" for="c-40766739">[-]</label><label class="expand" for="c-40766739">[2 more]</label></div><br/><div class="children"><div class="content">You are looking for SCTP.</div><br/><div id="40767444" class="c"><input type="checkbox" id="c-40767444" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766739">parent</a><span>|</span><a href="#40767256">next</a><span>|</span><label class="collapse" for="c-40767444">[-]</label><label class="expand" for="c-40767444">[1 more]</label></div><br/><div class="children"><div class="content">Which you will absolutely not get past pretty much any middleboxes, unless you encapsulate it in UDP.</div><br/></div></div></div></div><div id="40767256" class="c"><input type="checkbox" id="c-40767256" checked=""/><div class="controls bullet"><span class="by">throwaway7ahgb</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766739">prev</a><span>|</span><a href="#40766698">next</a><span>|</span><label class="collapse" for="c-40767256">[-]</label><label class="expand" for="c-40767256">[3 more]</label></div><br/><div class="children"><div class="content">Correct on the reliable UDP.<p>I&#x27;ve seen a few implementations of a reliable UDP messaging stream (using multicast or broadcast).  It uses a sequencer to ensure all clients receive the correct message and order.<p>It can be extremely fast and reliable.</div><br/><div id="40767555" class="c"><input type="checkbox" id="c-40767555" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767256">parent</a><span>|</span><a href="#40766698">next</a><span>|</span><label class="collapse" for="c-40767555">[-]</label><label class="expand" for="c-40767555">[2 more]</label></div><br/><div class="children"><div class="content">If it guarantees delivery and preserves order, what’s the difference vs. TCP?</div><br/><div id="40767672" class="c"><input type="checkbox" id="c-40767672" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767555">parent</a><span>|</span><a href="#40766698">next</a><span>|</span><label class="collapse" for="c-40767672">[-]</label><label class="expand" for="c-40767672">[1 more]</label></div><br/><div class="children"><div class="content">Delimited messages vs. stream.</div><br/></div></div></div></div></div></div><div id="40766698" class="c"><input type="checkbox" id="c-40766698" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40767256">prev</a><span>|</span><a href="#40767716">next</a><span>|</span><label class="collapse" for="c-40766698">[-]</label><label class="expand" for="c-40766698">[1 more]</label></div><br/><div class="children"><div class="content">There’s Homa[1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;PlatformLab&#x2F;Homa">https:&#x2F;&#x2F;github.com&#x2F;PlatformLab&#x2F;Homa</a></div><br/></div></div><div id="40767716" class="c"><input type="checkbox" id="c-40767716" checked=""/><div class="controls bullet"><span class="by">_zoltan_</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766698">prev</a><span>|</span><a href="#40766939">next</a><span>|</span><label class="collapse" for="c-40767716">[-]</label><label class="expand" for="c-40767716">[1 more]</label></div><br/><div class="children"><div class="content">libfabric implements msg on top of TCP, among others. I love that I can just switch between TCP and RDMA without any code change.</div><br/></div></div><div id="40766939" class="c"><input type="checkbox" id="c-40766939" checked=""/><div class="controls bullet"><span class="by">jan_k_</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40767716">prev</a><span>|</span><a href="#40767368">next</a><span>|</span><label class="collapse" for="c-40766939">[-]</label><label class="expand" for="c-40766939">[5 more]</label></div><br/><div class="children"><div class="content">WebSocket?</div><br/><div id="40767168" class="c"><input type="checkbox" id="c-40767168" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40766939">parent</a><span>|</span><a href="#40767368">next</a><span>|</span><label class="collapse" for="c-40767168">[-]</label><label class="expand" for="c-40767168">[4 more]</label></div><br/><div class="children"><div class="content">WebSocket is over TCP, so still ordered. I think by message-based GP is talking not only about message framing (which WebSocket provides) but also reliable out-of-order delivery.</div><br/><div id="40767429" class="c"><input type="checkbox" id="c-40767429" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767168">parent</a><span>|</span><a href="#40767368">next</a><span>|</span><label class="collapse" for="c-40767429">[-]</label><label class="expand" for="c-40767429">[3 more]</label></div><br/><div class="children"><div class="content">When does a long out of order delay look like a packet loss?<p>Is it possible for an out of order packet to get delayed by a millisecond? A second? A minute? An hour?<p>Have you written code to be robust to this?</div><br/><div id="40767985" class="c"><input type="checkbox" id="c-40767985" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767429">parent</a><span>|</span><a href="#40767368">next</a><span>|</span><label class="collapse" for="c-40767985">[-]</label><label class="expand" for="c-40767985">[2 more]</label></div><br/><div class="children"><div class="content">Other people have probably thought about it more than I have, but the way I see it working is that a set of unacked messages are stored on each end of the connection. When a connection receives a message, it acks it by ID. When acks come out of the order the client sent them in (or after a timeout period), it re-sends the packet that may have dropped.<p>If every message is getting dropped, the set of unacked messages fills up and the connection stops accepting messages from the application, similar to TCP in that situation.<p>I mostly work with TCP so haven&#x27;t had to deal with unreliable channels generally, but I do use a similar approach at the application level for reliable delivery across reconnects.</div><br/><div id="40769345" class="c"><input type="checkbox" id="c-40769345" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#40766615">root</a><span>|</span><a href="#40767985">parent</a><span>|</span><a href="#40767368">next</a><span>|</span><label class="collapse" for="c-40769345">[-]</label><label class="expand" for="c-40769345">[1 more]</label></div><br/><div class="children"><div class="content">My point is that a lost message looks the same as an arbitrary delay.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40767368" class="c"><input type="checkbox" id="c-40767368" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#40766615">parent</a><span>|</span><a href="#40766939">prev</a><span>|</span><a href="#40767707">next</a><span>|</span><label class="collapse" for="c-40767368">[-]</label><label class="expand" for="c-40767368">[1 more]</label></div><br/><div class="children"><div class="content">I have implemented publish&#x2F;subscribe middleware in the 90s using UDP and reliable IP multicast. It was not too hard to do and had taken me about two month. Yes I did reinvent the wheel but it had numerous positive sides:<p><pre><code>  a) It added yet another area of expertise to my portfolio.
  b) I did it because it was needed to facilitate another product in the company where I worked. The alternative at the time would be paying $350,000 for middleware from Vendor-X. Not acceptable.
  c) Vendor-X people noticed us, loved what we did and made us a partner to resell their middleware and we&#x27;ve made a ton of money on deployment, configuring and consulting services.</code></pre></div><br/></div></div></div></div><div id="40767246" class="c"><input type="checkbox" id="c-40767246" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#40766615">prev</a><span>|</span><a href="#40767704">next</a><span>|</span><label class="collapse" for="c-40767246">[-]</label><label class="expand" for="c-40767246">[1 more]</label></div><br/><div class="children"><div class="content">TL;DR - use QUIC <i>(should have just looked at the domain name)</i></div><br/></div></div><div id="40766288" class="c"><input type="checkbox" id="c-40766288" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#40767704">prev</a><span>|</span><a href="#40766700">next</a><span>|</span><label class="collapse" for="c-40766288">[-]</label><label class="expand" for="c-40766288">[9 more]</label></div><br/><div class="children"><div class="content">I use UDP for my desktop game like software with clients all over the world to propagate anonymized state. It needs no encryption as the transmitted data has zero value to any third party. It needs no reliability since dropped packets would be handled by predictive filter with practical reliability that is way more than needed.<p>So why the F.. would I bother with anything else?</div><br/><div id="40767190" class="c"><input type="checkbox" id="c-40767190" checked=""/><div class="controls bullet"><span class="by">ralferoo</span><span>|</span><a href="#40766288">parent</a><span>|</span><a href="#40766442">next</a><span>|</span><label class="collapse" for="c-40767190">[-]</label><label class="expand" for="c-40767190">[4 more]</label></div><br/><div class="children"><div class="content">You might want some form of encryption or message signing to prevent spoofed packet injection. Just because the data might not have value to a third party, knowing that the data is legitimate has value to you.</div><br/><div id="40767285" class="c"><input type="checkbox" id="c-40767285" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#40766288">root</a><span>|</span><a href="#40767190">parent</a><span>|</span><a href="#40766442">next</a><span>|</span><label class="collapse" for="c-40767285">[-]</label><label class="expand" for="c-40767285">[3 more]</label></div><br/><div class="children"><div class="content">Arguments like this should have practical value for business. For my business the value is zilch. It is simply not worth it for the hacker to mess with my packet server. I&#x27;ve been running it for 10 years with 0 complaints. And the worst they can do is to temporarily annoy few people. And yes I implement simple proprietary form packet of signing. It took me whole few minutes to develop.</div><br/><div id="40767449" class="c"><input type="checkbox" id="c-40767449" checked=""/><div class="controls bullet"><span class="by">ralferoo</span><span>|</span><a href="#40766288">root</a><span>|</span><a href="#40767285">parent</a><span>|</span><a href="#40766442">next</a><span>|</span><label class="collapse" for="c-40767449">[-]</label><label class="expand" for="c-40767449">[2 more]</label></div><br/><div class="children"><div class="content">Many games are popular targets for griefers or DDOS attacks, not because the attacker gains anything of value from the attack (and many of them aren&#x27;t actually hackers, they just download the tools written by others), but instead they do it solely for the perverse happiness they get from knowing that they ruined someone else&#x27;s day &#x2F; hour &#x2F; minute.<p>Possibly you just haven&#x27;t seen this problem yet because your game isn&#x27;t high-profile enough for them to bother with and it doesn&#x27;t provide enough amusement for them to get a kick out of it.</div><br/><div id="40767753" class="c"><input type="checkbox" id="c-40767753" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#40766288">root</a><span>|</span><a href="#40767449">parent</a><span>|</span><a href="#40766442">next</a><span>|</span><label class="collapse" for="c-40767753">[-]</label><label class="expand" for="c-40767753">[1 more]</label></div><br/><div class="children"><div class="content">It is game like by tech used but is not really a game. Unlikely to be noticed. When IF it ever does I&#x27;ll worry about it the, Not too difficult as there are libs just for that. For now my simple signing works like a charm.</div><br/></div></div></div></div></div></div></div></div><div id="40766442" class="c"><input type="checkbox" id="c-40766442" checked=""/><div class="controls bullet"><span class="by">aarmot</span><span>|</span><a href="#40766288">parent</a><span>|</span><a href="#40767190">prev</a><span>|</span><a href="#40766700">next</a><span>|</span><label class="collapse" for="c-40766442">[-]</label><label class="expand" for="c-40766442">[4 more]</label></div><br/><div class="children"><div class="content">Because author of the article likes to be edgy and parrot the deep truth he learned yesterday - that TCP is &quot;reliable&quot; and UDP is not.<p>The reality, of course, is somewhat different and muddy. For example, if you have network outage following later by a software crash or a reboot, then all the TCP buffer worth of data (several kilobytes or upto some megabytes - depends on your tuning) is mercilessly dropped. And your application thinks that just because you used TCP the data must have been reliably delieved. To combat this you have to implement some kind of serializing and acking - but the article scoffs us that we are too dumb to implement anything besides basic stream &#x2F;s<p>I&#x27;m not arguing that TCP is useless, just that UDP has its place and we - mere mortals - can use is too. Where appropriate.</div><br/><div id="40766631" class="c"><input type="checkbox" id="c-40766631" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40766288">root</a><span>|</span><a href="#40766442">parent</a><span>|</span><a href="#40766569">next</a><span>|</span><label class="collapse" for="c-40766631">[-]</label><label class="expand" for="c-40766631">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because author of the article likes to be edgy and parrot the deep truth he learned yesterday<p>I will point out that &quot;author of the article&quot; is one of the core contributors in the IETF Media-over-QUIC working group (which is an effort to standardize how one might build these real-time applications over QUIC) and has been working in the real-time media protocols space for 10+ years.<p>The author recognizes that the title is clickbait, but the key point of the article is that you probably don&#x27;t want to use raw UDP in most cases. Not that UDP is inherently bad (otherwise he wouldn&#x27;t be working on improving QUIC).</div><br/></div></div><div id="40766569" class="c"><input type="checkbox" id="c-40766569" checked=""/><div class="controls bullet"><span class="by">ben0x539</span><span>|</span><a href="#40766288">root</a><span>|</span><a href="#40766442">parent</a><span>|</span><a href="#40766631">prev</a><span>|</span><a href="#40766568">next</a><span>|</span><label class="collapse" for="c-40766569">[-]</label><label class="expand" for="c-40766569">[1 more]</label></div><br/><div class="children"><div class="content">The author (disclaimer: former coworker) has likely learned about UDP before yesterday because he&#x27;s been complaining about TCP for years.</div><br/></div></div><div id="40766568" class="c"><input type="checkbox" id="c-40766568" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#40766288">root</a><span>|</span><a href="#40766442">parent</a><span>|</span><a href="#40766569">prev</a><span>|</span><a href="#40766700">next</a><span>|</span><label class="collapse" for="c-40766568">[-]</label><label class="expand" for="c-40766568">[1 more]</label></div><br/><div class="children"><div class="content">The thing is, when you need that low latency, you don&#x27;t want most of the features of more robust streams.<p>When you are using UDP the correct way to handle out of order delivery is to just ignore the older packet.  It&#x27;s old and consequently out of date.<p>Figuring out how to solve any mess caused by mistransmission necessarily has to be done at the application level because that&#x27;s where the most up to date data is.</div><br/></div></div></div></div></div></div><div id="40766700" class="c"><input type="checkbox" id="c-40766700" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#40766288">prev</a><span>|</span><label class="collapse" for="c-40766700">[-]</label><label class="expand" for="c-40766700">[1 more]</label></div><br/><div class="children"><div class="content">The choice is not UDP vs TCP.<p>UDP adds minimum over raw sockets so that you don&#x27;t need root privileges. Other protocols are  build on top of UDP.<p>It&#x27;s better to use existing not-TCP protocols instead of UDP when the need arises instead of making your own. Especially for streaming.</div><br/></div></div></div></div></div></div></div></body></html>