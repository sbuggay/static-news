<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721638876449" as="style"/><link rel="stylesheet" href="styles.css?v=1721638876449"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://without.boats/blog/pin/">Pin</a> <span class="domain">(<a href="https://without.boats">without.boats</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>34 comments</span></div><br/><div><div id="41032048" class="c"><input type="checkbox" id="c-41032048" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#41030470">next</a><span>|</span><label class="collapse" for="c-41032048">[-]</label><label class="expand" for="c-41032048">[1 more]</label></div><br/><div class="children"><div class="content">My take on why users find Pin difficult: by itself, <i>it has no meaning!</i> This is different from every other wrapper in the language (except maybe AssertUnwindSafe&lt;T&gt;, which basically no one uses for its original purpose). Given a Pin&lt;&amp;mut InnerType&gt;, there&#x27;s nothing about Pin in the language or standard library that tells you what you can and can&#x27;t do with it. (Unless the InnerType declares that it&#x27;s Unpin, which implies that you can do anything you can do with an ordinary pointer.)<p>Instead, it operates as more of a &quot;bring your own meaning&quot;, where the provider of the InnerType further creates any number of (internally unsafe) methods and APIs to manipulate a pinned object soundly. The only purpose of Pin&lt;P&gt; itself is to provide a pointer with fewer &quot;intrinsic capabilities&quot; (e.g., swapping &amp;muts, moving out of Boxes, etc.), so that the inner type can allow further capabilities on top of that.<p>I suspect it&#x27;s this nebulousness of meaning that confuses people the most. It certainly took me a fair while to figure it out. All the ideas about structural vs. non-structural fields are just to facilitate popular access patterns like &quot;this one field is just plain old data, but this other field contains an object that itself wants to be pinned&quot;.</div><br/></div></div><div id="41030470" class="c"><input type="checkbox" id="c-41030470" checked=""/><div class="controls bullet"><span class="by">alain_gilbert</span><span>|</span><a href="#41032048">prev</a><span>|</span><a href="#41030643">next</a><span>|</span><label class="collapse" for="c-41030470">[-]</label><label class="expand" for="c-41030470">[12 more]</label></div><br/><div class="children"><div class="content">Should add &quot;rust&quot; in the title, so that we know what the article is talking about.<p>If you&#x27;re one of the &quot;rust&#x2F;go in title&quot; haters... please go rage somewhere else.</div><br/><div id="41030561" class="c"><input type="checkbox" id="c-41030561" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#41030470">parent</a><span>|</span><a href="#41030745">next</a><span>|</span><label class="collapse" for="c-41030561">[-]</label><label class="expand" for="c-41030561">[3 more]</label></div><br/><div class="children"><div class="content">This is literally the worst post title I&#x27;ve ever seen on HN :D</div><br/><div id="41030928" class="c"><input type="checkbox" id="c-41030928" checked=""/><div class="controls bullet"><span class="by">solarkraft</span><span>|</span><a href="#41030470">root</a><span>|</span><a href="#41030561">parent</a><span>|</span><a href="#41030745">next</a><span>|</span><label class="collapse" for="c-41030928">[-]</label><label class="expand" for="c-41030928">[2 more]</label></div><br/><div class="children"><div class="content">The corresponding rule is worded so harshly that I’m not surprised the poster didn’t dare to change it ( <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a>).</div><br/><div id="41030957" class="c"><input type="checkbox" id="c-41030957" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41030470">root</a><span>|</span><a href="#41030928">parent</a><span>|</span><a href="#41030745">next</a><span>|</span><label class="collapse" for="c-41030957">[-]</label><label class="expand" for="c-41030957">[1 more]</label></div><br/><div class="children"><div class="content">Not merely worded but also enforced that way.</div><br/></div></div></div></div></div></div><div id="41030745" class="c"><input type="checkbox" id="c-41030745" checked=""/><div class="controls bullet"><span class="by">tyrust</span><span>|</span><a href="#41030470">parent</a><span>|</span><a href="#41030561">prev</a><span>|</span><a href="#41030922">next</a><span>|</span><label class="collapse" for="c-41030745">[-]</label><label class="expand" for="c-41030745">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The Pin type (and the concept of pinning in general) is a foundational building block on which the rest of the the Rust async ecosystem stands.<p>Was this not the first sentence of the article when you wrote this?</div><br/><div id="41031834" class="c"><input type="checkbox" id="c-41031834" checked=""/><div class="controls bullet"><span class="by">throwaway89336</span><span>|</span><a href="#41030470">root</a><span>|</span><a href="#41030745">parent</a><span>|</span><a href="#41030922">next</a><span>|</span><label class="collapse" for="c-41031834">[-]</label><label class="expand" for="c-41031834">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about beeing able to quickly scan titles and decide if it&#x27;s worth clicking on. If all titles were similar, we would spend a lot of time clicking each link to see if it is relevant.</div><br/></div></div></div></div><div id="41030922" class="c"><input type="checkbox" id="c-41030922" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41030470">parent</a><span>|</span><a href="#41030745">prev</a><span>|</span><a href="#41030923">next</a><span>|</span><label class="collapse" for="c-41030922">[-]</label><label class="expand" for="c-41030922">[4 more]</label></div><br/><div class="children"><div class="content">Why would anyone hate that?  It’s a good marker, like [video], that tells folks like me not to bother clicking.</div><br/><div id="41031539" class="c"><input type="checkbox" id="c-41031539" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#41030470">root</a><span>|</span><a href="#41030922">parent</a><span>|</span><a href="#41031224">next</a><span>|</span><label class="collapse" for="c-41031539">[-]</label><label class="expand" for="c-41031539">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen a decent amount of people that blacklist keywords like rust, blazingly, etc.</div><br/><div id="41031741" class="c"><input type="checkbox" id="c-41031741" checked=""/><div class="controls bullet"><span class="by">port19</span><span>|</span><a href="#41030470">root</a><span>|</span><a href="#41031539">parent</a><span>|</span><a href="#41031224">next</a><span>|</span><label class="collapse" for="c-41031741">[-]</label><label class="expand" for="c-41031741">[1 more]</label></div><br/><div class="children"><div class="content">Which makes some sense if rust is only of tangential concern...<p>&quot;I build cool thing X <i>in rust</i> <i>applause</i>&quot; sucks and is borderline spammy imo<p>But when discussing a language feature, a type, including the language name should be a given and not trigger any rust haters</div><br/></div></div></div></div><div id="41031224" class="c"><input type="checkbox" id="c-41031224" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#41030470">root</a><span>|</span><a href="#41030922">parent</a><span>|</span><a href="#41031539">prev</a><span>|</span><a href="#41030923">next</a><span>|</span><label class="collapse" for="c-41031224">[-]</label><label class="expand" for="c-41031224">[1 more]</label></div><br/><div class="children"><div class="content">It’s against the rules for one</div><br/></div></div></div></div><div id="41030923" class="c"><input type="checkbox" id="c-41030923" checked=""/><div class="controls bullet"><span class="by">perilunar</span><span>|</span><a href="#41030470">parent</a><span>|</span><a href="#41030922">prev</a><span>|</span><a href="#41030719">next</a><span>|</span><label class="collapse" for="c-41030923">[-]</label><label class="expand" for="c-41030923">[1 more]</label></div><br/><div class="children"><div class="content">It does indeed have nothing to do with boats.</div><br/></div></div></div></div><div id="41030643" class="c"><input type="checkbox" id="c-41030643" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#41030470">prev</a><span>|</span><a href="#41031041">next</a><span>|</span><label class="collapse" for="c-41030643">[-]</label><label class="expand" for="c-41030643">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The term “value identity” is not defined anywhere in this post, nor can I find it elsewhere in Mojo’s documentation, so I’m not clear on how Modular claims that Mojo solves the problem that Pin is meant to solve</i><p>I don&#x27;t claim to know the answer either, but it reminds me of a great talk from Dave Abrahams, who worked on the value semantics for Swift together with Chris Lattner (who started Mojo). The talk is &quot;Value Semantics: Safety, Independence, Projection, &amp; Future of Programming&quot; [0]<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QthAU-t3PQ4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QthAU-t3PQ4</a></div><br/></div></div><div id="41031041" class="c"><input type="checkbox" id="c-41031041" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#41030643">prev</a><span>|</span><a href="#41030401">next</a><span>|</span><label class="collapse" for="c-41031041">[-]</label><label class="expand" for="c-41031041">[4 more]</label></div><br/><div class="children"><div class="content">I can imagine a Rust-like language where we have move-constructors (in TFA), and every generated Future subtype is opaque and also heap allocated for us.<p>I <i>think</i> the need for Pin could then disappear, because the user would have no way to destroy it, since it&#x27;s opaque and elsewhere on the heap, and therefore no way to move it (because having move-constructors implies that moving is conceptually destroying then recreating things).</div><br/><div id="41031282" class="c"><input type="checkbox" id="c-41031282" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41031041">parent</a><span>|</span><a href="#41030401">next</a><span>|</span><label class="collapse" for="c-41031282">[-]</label><label class="expand" for="c-41031282">[3 more]</label></div><br/><div class="children"><div class="content">Yeah. I can guess how disruptive it would be, but I really wish rust bit the bullet and added a <i>Move</i> trait to std, baked into the language at a similar level as <i>Copy</i>. Move defines a function which moves a value from one address in memory to another. Structs without impl Move cannot be moved.<p>Almost all types would <i>#[derive(Move)]</i>, which implements a trivial move function that copies the bytes. But this opens the door to self-referential types, futures, and lots of other things that need more complex move behaviour. (Actually, it might make more sense to define two traits, mirroring the difference between Copy and Clone. One is a marker trait which tells the compiler that the bytes can just be moved. The other allows custom &quot;move constructor&quot; implementation.)<p>I want move because pin is so hard to understand. Its a complex idea wrapped in double- or sometimes triple negatives. fn&lt;X: !Unpin&gt;(...). Wat? I drop off at unsafe pin-projecting. When is that safe? When is it not? Blah I&#x27;m out.<p>Moving from rust-without-move to rust-with-move would be inconvenient, because basically every struct anyone has written to date with rust needs #[derive(Move)] to be added. Including in std. And all types in existing editions that aren&#x27;t pinned would need the compiler to infer a Move trait implementation. This should be possible to do mechanically. It would just be a lot of work.<p>Async rust is horrible. Especially compared to futures &#x2F; promises in almost any other language. At some point, someone will make a new rust-like systems language which has an improved version of rust&#x27;s memory safety model, a Move trait, and better futures. I&#x27;d personally also love comptime instead of rust&#x27;s macro system.<p>I love rust. I love all the work the team has put into it over the years. But the language I’m really looking forward to is the language that comes after rust. Same idea, but something that has learned from rust’s mistakes. And it’s increasingly becoming clear what that better rust-like language might potentially look like. I can&#x27;t wait.</div><br/><div id="41031948" class="c"><input type="checkbox" id="c-41031948" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#41031041">root</a><span>|</span><a href="#41031282">parent</a><span>|</span><a href="#41030401">next</a><span>|</span><label class="collapse" for="c-41031948">[-]</label><label class="expand" for="c-41031948">[2 more]</label></div><br/><div class="children"><div class="content">I very much disagree that Pin is as hard as everyone makes it out to be. Using the pin! macros, the pin-project crate, and enough as_mut() to get it to compile and it&#x27;s not hard at all to get a future impl working. It would be good to get this native (which is what boats wants) so it&#x27;s easier to discover but it&#x27;s not at all hard by any means<p>I think a lot of people think pin is confusing but don&#x27;t actually try to learn it. When I&#x27;ve sat with people and helped them they understand pretty quickly what pin solves and how it works.<p>I very strongly think move constructors would be even more complex than pin.</div><br/></div></div></div></div></div></div><div id="41030401" class="c"><input type="checkbox" id="c-41030401" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#41031041">prev</a><span>|</span><a href="#41030506">next</a><span>|</span><label class="collapse" for="c-41030401">[-]</label><label class="expand" for="c-41030401">[2 more]</label></div><br/><div class="children"><div class="content">The problem as I see it is that having a &amp;mut reference to something lets you move it via mem::swap&#x2F;replace (and maybe a few others?) -- but actually needing to do so is rare. It seems to me that if that weren&#x27;t allowed, taking a &amp;mut reference to a self-referential value would be perfectly safe.<p>Maybe there could have been a way to opt in to moving-via-reference for those rare cases when you need it. Or maybe this whole problem could have been avoided by making swap and replace unsafe? I&#x27;d love to see someone explore that design space.</div><br/><div id="41030664" class="c"><input type="checkbox" id="c-41030664" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#41030401">parent</a><span>|</span><a href="#41030506">next</a><span>|</span><label class="collapse" for="c-41030664">[-]</label><label class="expand" for="c-41030664">[1 more]</label></div><br/><div class="children"><div class="content">This just doesn&#x27;t scale and it would have been a non starter because it would break so much exiting code. Mem swap is just one of the ways to move via mutable references, there are many many others. Option::take is one that I use quite often and it would be super weird if that was unsafe.</div><br/></div></div></div></div><div id="41030506" class="c"><input type="checkbox" id="c-41030506" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41030401">prev</a><span>|</span><a href="#41030441">next</a><span>|</span><label class="collapse" for="c-41030506">[-]</label><label class="expand" for="c-41030506">[7 more]</label></div><br/><div class="children"><div class="content">Great seeing this backstory. WithoutBoats has had some super active discussions around very topical async iterators, poll, and pin topics already! <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=without.boats">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=without.boats</a><p>It feels like there&#x27;s very few communities that people going so in depth publically about the nitty gritty of their language, and it&#x27;s so cool to see.</div><br/><div id="41030648" class="c"><input type="checkbox" id="c-41030648" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#41030506">parent</a><span>|</span><a href="#41030441">next</a><span>|</span><label class="collapse" for="c-41030648">[-]</label><label class="expand" for="c-41030648">[6 more]</label></div><br/><div class="children"><div class="content">Its cool, but it also means the development of the language is very very slow. Async is still half backed and super complex, and I say that as a guy who has written rust code 40h&#x2F;week for the past 3 years.</div><br/><div id="41030710" class="c"><input type="checkbox" id="c-41030710" checked=""/><div class="controls bullet"><span class="by">tjf801</span><span>|</span><a href="#41030506">root</a><span>|</span><a href="#41030648">parent</a><span>|</span><a href="#41030441">next</a><span>|</span><label class="collapse" for="c-41030710">[-]</label><label class="expand" for="c-41030710">[5 more]</label></div><br/><div class="children"><div class="content">I fully agree. Sometimes it feels like so much effort is put into rust&#x27;s async side that the rest of the language ends up taking a back seat and suffering for it.</div><br/><div id="41031821" class="c"><input type="checkbox" id="c-41031821" checked=""/><div class="controls bullet"><span class="by">rjh29</span><span>|</span><a href="#41030506">root</a><span>|</span><a href="#41030710">parent</a><span>|</span><a href="#41031042">next</a><span>|</span><label class="collapse" for="c-41031821">[-]</label><label class="expand" for="c-41031821">[1 more]</label></div><br/><div class="children"><div class="content">It feels like async is popular and necessary but just not that good fit for rust. Having it is better than not having it I suppose....</div><br/></div></div><div id="41031042" class="c"><input type="checkbox" id="c-41031042" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41030506">root</a><span>|</span><a href="#41030710">parent</a><span>|</span><a href="#41031821">prev</a><span>|</span><a href="#41030441">next</a><span>|</span><label class="collapse" for="c-41031042">[-]</label><label class="expand" for="c-41031042">[3 more]</label></div><br/><div class="children"><div class="content">Rust dev team cares too much about async and webdev imho. Yes I know the web is where 95% of programming jobs live now. But as a C++ systems programmer I simply could not care less about the web. Rust is a systems language trying to get its foot in the web door. I&#x27;d selfishly rather it focus on being a superior C&#x2F;C++. Alas.</div><br/><div id="41031958" class="c"><input type="checkbox" id="c-41031958" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#41030506">root</a><span>|</span><a href="#41031042">parent</a><span>|</span><a href="#41031102">next</a><span>|</span><label class="collapse" for="c-41031958">[-]</label><label class="expand" for="c-41031958">[1 more]</label></div><br/><div class="children"><div class="content">The nature of open source is that people work on what they want to work on. People work on async because it interests them. But to the same level many people in the lang and libs team don&#x27;t know async that well. You may perceive it that everyone works only on async but this is just not true.</div><br/></div></div><div id="41031102" class="c"><input type="checkbox" id="c-41031102" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#41030506">root</a><span>|</span><a href="#41031042">parent</a><span>|</span><a href="#41031958">prev</a><span>|</span><a href="#41030441">next</a><span>|</span><label class="collapse" for="c-41031102">[-]</label><label class="expand" for="c-41031102">[1 more]</label></div><br/><div class="children"><div class="content">The usual complaint is that there has been little progress on async and webdev in Rust itself since 2018 so it&#x27;s odd to hear the reverse complaint.<p>Though I would add that Rust&#x27;s async is not just about webdev; it has had success in embedded contexts e.g. the popular <a href="https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy?tab=readme-ov-file#embassy">https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy?tab=readme-ov-file#emb...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41030441" class="c"><input type="checkbox" id="c-41030441" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41030506">prev</a><span>|</span><label class="collapse" for="c-41030441">[-]</label><label class="expand" for="c-41030441">[6 more]</label></div><br/><div class="children"><div class="content">Pinning&#x2F;!Move is useful for <i>so</i> many things outside of async&#x2F;await.<p>But because Rust fumbled it so badly, the usual answer is &quot;rewrite your program in a language other than Rust.&quot;<p>(aside: there are about 4 different ways to implement object moving, and an efficient language needs to be aware of several of them)</div><br/><div id="41030448" class="c"><input type="checkbox" id="c-41030448" checked=""/><div class="controls bullet"><span class="by">n3t</span><span>|</span><a href="#41030441">parent</a><span>|</span><a href="#41030804">next</a><span>|</span><label class="collapse" for="c-41030448">[-]</label><label class="expand" for="c-41030448">[2 more]</label></div><br/><div class="children"><div class="content">&gt; there are about 4 different ways to implement object moving<p>What are they?</div><br/><div id="41030981" class="c"><input type="checkbox" id="c-41030981" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41030441">root</a><span>|</span><a href="#41030448">parent</a><span>|</span><a href="#41030804">next</a><span>|</span><label class="collapse" for="c-41030981">[-]</label><label class="expand" for="c-41030981">[1 more]</label></div><br/><div class="children"><div class="content">0. no moves. This is very often needed for FFI callbacks, among others.<p>1. trivial copies. This is similar to 2, but means you do not have to do `swap`-like things in cases for non-destructive moves (which are, in fact, also important, they just shouldn&#x27;t be the <i>only</i> kind of move. Note that supporting destructive moves likely implies supporting destructuring).<p>2. trivial moves. You can just use `memcpy`, `realloc`, etc. This is the only kind of move supported by Rust. C++ can introspect for it but with severe limitations. Note that &quot;trivial&quot; does NOT mean &quot;cheap&quot;; memory can be large.<p>3. moves with retroactive fixup (old address considered dead). What you do here is call `realloc` or whatever, then pass the old address (or the delta?) to a fixup function so that it (possibly with offset) can be replaced with the new address. Great caution is required to avoid UB by C&#x27;s rules (the delta approach may be safer?). The compiler needs to be able to optimize this into the preceding when the fixup turns out to be empty (since generic wrapper classes may not know if their fields are trivially-movable or not).<p>4. full moves (both old and new address ranges are valid at the same time). C++ is the only language I know that supports this (though it is limited to non-destructive moves). One major use for this is maintaining &quot;peer pointers&quot; without forcing an extra allocation. Note that this <i>can</i> be simulated on top of &quot;no moves&quot; with some extra verbosity (C++98 anyone?).<p>Related to this, it really is essential for allocators to provide a &quot;reallocate in place if possible, else fail&quot; function, to avoid unnecessary move-constructor calls. Unfortunately, real-world allocators do not actually avoid copies if you use `malloc_usable_size` + `realloc`. If emitting C, note that you must <i>avoid</i> `__attribute__((malloc))` etc. to avoid setting off the bug-laden-piece-of-crap that is `__builtin_dynamic_object_size`.<p>Random reminder that &quot;conditionally insert and move my object(s) into a container (usually a map), but keep my object alive if an equal one was already there&quot; is important, and most languages do it pretty badly.<p>Linear types are related but it&#x27;s all Blub to me.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>