<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700989258610" as="style"/><link rel="stylesheet" href="styles.css?v=1700989258610"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/ambassador">The Ambassador Pattern</a> <span class="domain">(<a href="https://learn.microsoft.com">learn.microsoft.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>20 comments</span></div><br/><div><div id="38418947" class="c"><input type="checkbox" id="c-38418947" checked=""/><div class="controls bullet"><span class="by">timeagain</span><span>|</span><a href="#38420084">next</a><span>|</span><label class="collapse" for="c-38418947">[-]</label><label class="expand" for="c-38418947">[4 more]</label></div><br/><div class="children"><div class="content">I understand the need for such a thing, but the wild amount of indirection that is needed in microservices world is astounding.<p>Hmm, that request didn’t make it through! I wonder if it was dropped by the database, the business logic, the spring http-handling framework, the retry annotation, nginx reverse proxy, the authentication sidecar, the “ambassador service”, the SQS queue, the internal VPN, or cloudflare?<p>Just writing it out makes my brain hurt.</div><br/><div id="38419450" class="c"><input type="checkbox" id="c-38419450" checked=""/><div class="controls bullet"><span class="by">AYBABTME</span><span>|</span><a href="#38418947">parent</a><span>|</span><a href="#38419467">next</a><span>|</span><label class="collapse" for="c-38419450">[-]</label><label class="expand" for="c-38419450">[1 more]</label></div><br/><div class="children"><div class="content">This type of infra only makes sense when you have Scaling People Problems to solve using technical solutions. Say you&#x27;re MSFT and you need to let thousands of people of various skillset and skill levels, ship locally useful software at decent velocity, but while preserving important cross-cutting stuff like TLS, telemetry, wtv.  Or when dealing with legacy software.<p>But otherwise it&#x27;s not required.</div><br/></div></div><div id="38419467" class="c"><input type="checkbox" id="c-38419467" checked=""/><div class="controls bullet"><span class="by">notatoad</span><span>|</span><a href="#38418947">parent</a><span>|</span><a href="#38419450">prev</a><span>|</span><a href="#38418976">next</a><span>|</span><label class="collapse" for="c-38419467">[-]</label><label class="expand" for="c-38419467">[1 more]</label></div><br/><div class="children"><div class="content">i don&#x27;t think you can really say this is ever <i>necessary</i>.  or at least, not that microservices make it necessary.<p>this is a business thing.  you need this when you&#x27;re hiring a contractor to add some functionality, and you don&#x27;t want them to touch the service behind the ambassador.  probably because you&#x27;ve hired a different contractor to build the original service, nobody at your company knows how it works anymore, and making the new contractor figure it out is out of budget.</div><br/></div></div><div id="38418976" class="c"><input type="checkbox" id="c-38418976" checked=""/><div class="controls bullet"><span class="by">MPSimmons</span><span>|</span><a href="#38418947">parent</a><span>|</span><a href="#38419467">prev</a><span>|</span><a href="#38420084">next</a><span>|</span><label class="collapse" for="c-38418976">[-]</label><label class="expand" for="c-38418976">[1 more]</label></div><br/><div class="children"><div class="content">Infrastructure like this is overkill for the vast majority of cases. When you do need something like this, you&#x27;re probably using a service mesh that also provides introspection and observability into the pipeline to be able to help debug and diagnose issues.</div><br/></div></div></div></div><div id="38420084" class="c"><input type="checkbox" id="c-38420084" checked=""/><div class="controls bullet"><span class="by">rvdginste</span><span>|</span><a href="#38418947">prev</a><span>|</span><a href="#38420090">next</a><span>|</span><label class="collapse" for="c-38420084">[-]</label><label class="expand" for="c-38420084">[1 more]</label></div><br/><div class="children"><div class="content">I understand what this pattern does, but it makes me wonder how useful it is in practice. I am focusing specifically on the retry and circuit breaker functionality.<p>If the call is done in a synchronous context (for example original client executes a REST call), you are adding latency by inserting an extra service in between. When the remote service is not immediately available or responsive or fails, and you do a retry, in the end your call might take too long and the caller might cancel the request. I have seen this behavior in practice and it makes me wonder how useful this implementation is in a synchronous context. You add complexity (on the infra level) and you add latency in the happy path. When a retry is needed, most of the time 
(in my experience) the call to the remote service does not succeed in time, and the original call still fails.<p>If the call is done in an asynchronous context (for example the original client picks up a message from a queue and processes it), you are adding latency and complexity by inserting an extra service and extra logic. However, when the remote service is not immediately available, you can just let the processing of the message fail. The queue or bus should contain retry logic that could be finetuned based on the type of error you get. So, in that case, you should already have a retry mechanism out of the box, then is the added latency and complexity really worth it?<p>I understand about the circuit breaker, and I understand that might be useful, because it could prevent the remote service being overloaded with requests (well, at least if every caller to the remote service implements circuit breaker... but then, the ambassador service would better be placed on the side of the remote service and every client should be forced to pass through it, and then it might just be implemented inside the remote service instead of in a separate service adding extra latency&#x2F;complexity&#x2F;... basically, the remote service should protect itself against this).<p>Thoughts? Does it make sense what I am thinking?</div><br/></div></div><div id="38420090" class="c"><input type="checkbox" id="c-38420090" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#38420084">prev</a><span>|</span><a href="#38419742">next</a><span>|</span><label class="collapse" for="c-38420090">[-]</label><label class="expand" for="c-38420090">[1 more]</label></div><br/><div class="children"><div class="content">When I build some kind of API, I would usually also provide a library for the clients. This library would to an extent perform the function of &quot;ambassador&quot;. It captures my intended logic to handle certain situations that are not described by purely functional part of API contract.<p>And yes, this library usually also covers things like retries and handling errors and outages.<p>Maintaining an entire service to achieve the same seems like really expensive way to achieve this...</div><br/></div></div><div id="38419742" class="c"><input type="checkbox" id="c-38419742" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#38420090">prev</a><span>|</span><a href="#38419314">next</a><span>|</span><label class="collapse" for="c-38419742">[-]</label><label class="expand" for="c-38419742">[1 more]</label></div><br/><div class="children"><div class="content">Speaking of this has anyone had much experience with Dapr (<a href="https:&#x2F;&#x2F;dapr.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dapr.io&#x2F;</a>) before?<p>I always thought this was a particularly interesting approach from Microsoft where they use this pattern to essentially take the complexity of micro services and instead try and keep it as simple as a normal .NET application but (and I think this is the clever part) in both a vendor and language neutral way.<p>But all of a sudden it means you can start removing all kinds of cruft and random SDKs from your codebase and push almost all of your interactions with the outside world into something like this .</div><br/></div></div><div id="38419314" class="c"><input type="checkbox" id="c-38419314" checked=""/><div class="controls bullet"><span class="by">bzbz</span><span>|</span><a href="#38419742">prev</a><span>|</span><a href="#38419701">next</a><span>|</span><label class="collapse" for="c-38419314">[-]</label><label class="expand" for="c-38419314">[5 more]</label></div><br/><div class="children"><div class="content">&gt; An ambassador service can be thought of as an out-of-process proxy that is co-located with the client.<p>&gt; This pattern can be useful for offloading common client connectivity tasks such as monitoring, logging, routing, security (such as TLS), and resiliency patterns in a language agnostic way. It is often used with legacy applications, or other applications that are difficult to modify, in order to extend their networking capabilities. It can also enable a specialized team to implement those features.<p>Not surprised this is a Microsoft page, given their legacy of long lifetime support for their software products.<p>It’s not for microservices, but rather for software maintenance of systems that other vendors would consider past EOL.</div><br/><div id="38419802" class="c"><input type="checkbox" id="c-38419802" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#38419314">parent</a><span>|</span><a href="#38419489">next</a><span>|</span><label class="collapse" for="c-38419802">[-]</label><label class="expand" for="c-38419802">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s similar to a thick client, what Google does by eschewing language agnosticism. It&#x27;s a reasonable approach, really: thin clients of course work, and you have to provide them across popular languages, making them thicker adds value.</div><br/></div></div><div id="38419489" class="c"><input type="checkbox" id="c-38419489" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#38419314">parent</a><span>|</span><a href="#38419802">prev</a><span>|</span><a href="#38419701">next</a><span>|</span><label class="collapse" for="c-38419489">[-]</label><label class="expand" for="c-38419489">[3 more]</label></div><br/><div class="children"><div class="content">Unless you view systems that consist of microservices  as &quot;applications that are difficult to modify&quot;.</div><br/><div id="38419768" class="c"><input type="checkbox" id="c-38419768" checked=""/><div class="controls bullet"><span class="by">bzbz</span><span>|</span><a href="#38419314">root</a><span>|</span><a href="#38419489">parent</a><span>|</span><a href="#38419701">next</a><span>|</span><label class="collapse" for="c-38419768">[-]</label><label class="expand" for="c-38419768">[2 more]</label></div><br/><div class="children"><div class="content">If anything, an obfuscated microservice-based application is easier to understand than a monolithic version: network data transfer is easier for observers to understand than memory modification.</div><br/><div id="38419870" class="c"><input type="checkbox" id="c-38419870" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#38419314">root</a><span>|</span><a href="#38419768">parent</a><span>|</span><a href="#38419701">next</a><span>|</span><label class="collapse" for="c-38419870">[-]</label><label class="expand" for="c-38419870">[1 more]</label></div><br/><div class="children"><div class="content">This could be argued, but obfuscated apps are a land of their own.<p>(You could also argue that obfuscated monolithic programs are be easier to reverse engineer, breakpoint, replay, emulate, time-travel-debug, trace, etc because you can completely control them in your test bench and aren&#x27;t then working against a hostile distributed system)</div><br/></div></div></div></div></div></div></div></div><div id="38419701" class="c"><input type="checkbox" id="c-38419701" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#38419314">prev</a><span>|</span><a href="#38418973">next</a><span>|</span><label class="collapse" for="c-38419701">[-]</label><label class="expand" for="c-38419701">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s old is new again but in new clothes.<p>20 something years ago &quot;mobile objects&quot; and &quot;agent systems&quot; were a thing and one of the practical incarnations was Jini: <a href="https:&#x2F;&#x2F;jan.newmarch.name&#x2F;java&#x2F;jini&#x2F;tutorial&#x2F;Jini.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;jan.newmarch.name&#x2F;java&#x2F;jini&#x2F;tutorial&#x2F;Jini.html</a></div><br/></div></div><div id="38418973" class="c"><input type="checkbox" id="c-38418973" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#38419701">prev</a><span>|</span><a href="#38419413">next</a><span>|</span><label class="collapse" for="c-38418973">[-]</label><label class="expand" for="c-38418973">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help but think that, when past teams programmed mostly in assembly, a &quot;Function&quot; could be explained as a pattern.<p>Having such &quot;design patterns&quot; seem like a side effect of our current tools&#x27; limitations. Maybe new technologies like Wing[0] (no affiliation) will help pushing us to the next generation of tools.<p>[0] <a href="https:&#x2F;&#x2F;www.winglang.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.winglang.io&#x2F;</a></div><br/><div id="38419884" class="c"><input type="checkbox" id="c-38419884" checked=""/><div class="controls bullet"><span class="by">devbent</span><span>|</span><a href="#38418973">parent</a><span>|</span><a href="#38419238">next</a><span>|</span><label class="collapse" for="c-38419884">[-]</label><label class="expand" for="c-38419884">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can&#x27;t help but think that, when past teams programmed mostly in assembly, a &quot;Function&quot; could be explained as a pattern.<p>Actually it was an entire new paradigm.<p>Procedural programming!</div><br/></div></div><div id="38419238" class="c"><input type="checkbox" id="c-38419238" checked=""/><div class="controls bullet"><span class="by">bobbiechen</span><span>|</span><a href="#38418973">parent</a><span>|</span><a href="#38419884">prev</a><span>|</span><a href="#38419413">next</a><span>|</span><label class="collapse" for="c-38419238">[-]</label><label class="expand" for="c-38419238">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely. Take something like the Builder pattern in Java for handling large numbers of possibly-optional arguments - in Python rarely-if-ever used due to named keyword arguments.</div><br/></div></div></div></div><div id="38419413" class="c"><input type="checkbox" id="c-38419413" checked=""/><div class="controls bullet"><span class="by">er4hn</span><span>|</span><a href="#38418973">prev</a><span>|</span><a href="#38419366">next</a><span>|</span><label class="collapse" for="c-38419413">[-]</label><label class="expand" for="c-38419413">[1 more]</label></div><br/><div class="children"><div class="content">Is this what envoy (by Ambassador Labs?) is named after?<p><a href="https:&#x2F;&#x2F;www.getambassador.io&#x2F;learn&#x2F;envoy-proxy" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.getambassador.io&#x2F;learn&#x2F;envoy-proxy</a></div><br/></div></div><div id="38419366" class="c"><input type="checkbox" id="c-38419366" checked=""/><div class="controls bullet"><span class="by">kcb</span><span>|</span><a href="#38419413">prev</a><span>|</span><a href="#38418917">next</a><span>|</span><label class="collapse" for="c-38419366">[-]</label><label class="expand" for="c-38419366">[1 more]</label></div><br/><div class="children"><div class="content">Seems like something you can do with Istio External Services.</div><br/></div></div><div id="38418917" class="c"><input type="checkbox" id="c-38418917" checked=""/><div class="controls bullet"><span class="by">the_sleaze9</span><span>|</span><a href="#38419366">prev</a><span>|</span><label class="collapse" for="c-38418917">[-]</label><label class="expand" for="c-38418917">[1 more]</label></div><br/><div class="children"><div class="content">Wow - I had no idea Microsoft has put together such a deep learning resource. Fantastic.</div><br/></div></div></div></div></div></div></div></body></html>