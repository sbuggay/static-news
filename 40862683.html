<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719997253630" as="style"/><link rel="stylesheet" href="styles.css?v=1719997253630"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fzakaria.com/2024/07/02/reproducibility-in-disguise.html">Reproducibility in Disguise</a> <span class="domain">(<a href="https://fzakaria.com">fzakaria.com</a>)</span></div><div class="subtext"><span>setheron</span> | <span>21 comments</span></div><br/><div><div id="40862994" class="c"><input type="checkbox" id="c-40862994" checked=""/><div class="controls bullet"><span class="by">nrclark</span><span>|</span><a href="#40863580">next</a><span>|</span><label class="collapse" for="c-40862994">[-]</label><label class="expand" for="c-40862994">[7 more]</label></div><br/><div class="children"><div class="content">One other hidden Bazel trap that I&#x27;ve seen is for companies to migrate a large codebase to Bazel, but then to rely on OS-provided tools and libraries. Commonly, this gets paired with a glib answer like &quot;it&#x27;s fine, we build from inside of a Docker container&quot;. But I&#x27;ve never seen that Docker image linked into Bazel&#x27;s dependency resolver, or the compose scripts used to launch the container.<p>This has the following effects:<p><pre><code>    1. There are unexpressed package&#x2F;tool dependencies.
    2. Across a large organization, Bazel&#x27;s reproducibility guarantees go out the window.
    3. Developers can&#x27;t just clone the repo and start using Bazel. Instead, they have to pull down some pinned Docker image, or build it themselves and lose reproducibility.
    4. This effectively poisons the cache whenever the Docker image is updated or rebuilt. If using a shared remote cache, it can be a major issue.
</code></pre>
If an organization isn&#x27;t big enough to vendor every single tool dependency, shared library, etc (which basically requires building out an OS distribution in Bazel), what&#x27;s the right way to approach this problem?</div><br/><div id="40863368" class="c"><input type="checkbox" id="c-40863368" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#40862994">parent</a><span>|</span><a href="#40863254">next</a><span>|</span><label class="collapse" for="c-40863368">[-]</label><label class="expand" for="c-40863368">[3 more]</label></div><br/><div class="children"><div class="content">I will say that it&#x27;s _extremely easy_ to just list `Dockerfile` in your output dependencies if it matters enough for you to care.<p>Stuff from apt&#x2F;etc as well? put the install script in the dependencies.<p>Really care about the version numbers? Add a test that just calls `tool -v` and compares the output to some fixed number. Add a big comment.<p>Is it perfect? No! Is it hermetic! Hell no! But is it going to catch a hell of a lot of stuff and get you fast tests along the way? Yes!<p>The biggest point with all CI&#x2F;CD is to get as much value as you can from these systems, while introducing the least amount of friction. And velocity gained from these systems mean that if you find an issue, you can fix it quickly. It&#x27;s an amazing feedback loop, and leaning into that feedback loop is way more valuable than writing `gettext` compilation scripts.</div><br/><div id="40863539" class="c"><input type="checkbox" id="c-40863539" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#40862994">root</a><span>|</span><a href="#40863368">parent</a><span>|</span><a href="#40863254">next</a><span>|</span><label class="collapse" for="c-40863539">[-]</label><label class="expand" for="c-40863539">[2 more]</label></div><br/><div class="children"><div class="content">But what does installing things via apt have to do with reproducibility? Does apt have some way to specify lock files or hashsums of the packages it is supposed to install? Or do you mean to pin version numbers of system packages and rely on that? Otherwise apt would be the point where the guarantees go out of the window already.</div><br/><div id="40864100" class="c"><input type="checkbox" id="c-40864100" checked=""/><div class="controls bullet"><span class="by">seabass-labrax</span><span>|</span><a href="#40862994">root</a><span>|</span><a href="#40863539">parent</a><span>|</span><a href="#40863254">next</a><span>|</span><label class="collapse" for="c-40864100">[-]</label><label class="expand" for="c-40864100">[1 more]</label></div><br/><div class="children"><div class="content">Debian can pin packages to certain versions by their numbers (see dpkg(1), &#x27;--set-selections&#x27;) and it does verify package integrity. I can&#x27;t think of any way to pin a package to hash like with Bazel or Nix, but the expectation is that packages are not changed after publication in dpkg repositories - and for Debian itself, that expectation is a strictly-followed rule.<p>Therefore I would trust package pinning to work, but it&#x27;s not quite as straightforward for the end-user as unique package hashes as identifiers.</div><br/></div></div></div></div></div></div><div id="40863254" class="c"><input type="checkbox" id="c-40863254" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#40862994">parent</a><span>|</span><a href="#40863368">prev</a><span>|</span><a href="#40863041">next</a><span>|</span><label class="collapse" for="c-40863254">[-]</label><label class="expand" for="c-40863254">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If an organization isn&#x27;t big enough to vendor every single tool dependency, shared library, etc (which basically requires building out an OS distribution in Bazel), what&#x27;s the right way to approach this problem?<p>Here are some ways you can approach this problem:<p>If you have a bunch of shared tools &amp; libraries and you don’t want to vendor the whole packages, you can vendor the <i>artifacts</i>. You can do this piecemeal or as a big chunk. Basically, instead of a Docker image containing your compiler or whatever, you have a tarball. You make Bazel responsible for downloading the tarball. Or maybe it’s several tarballs, it doesn’t matter. Bazel is actually pretty good at this.<p>Another approach is to combine Bazel with something else reproducible, like Nix. For now, I’d suggest taking a very basic approach, the most simple approach, which is to create an environment using Nix (containing your toolchain, third-party libraries, and Bazel) and then building your code inside that environment using Bazel. You can use the local_repository() rule to access the Nix environment.<p>Bazel + Nix is a really good idea, but maybe now is not the time to dive into that. When I’ve investigated the Bazel + Nix combination, it looks like neither system is exactly stable &#x2F; mature enough yet. Bazel just recently launched bzlmod and the Bazel ecosystem is shifting to use bzlmod everywhere. Nix is shifting to flakes but there are some pains there too (especially around documentation, but there are also some things that don’t quite work with flakes yet). So in the future, you could do something kind of, well, <i>cursed</i>, where you have a Bazel and Nix lasagna. You use Nix to run Bazel, and then you use Nix packages as dependencies of your Bazel build. In theory, this could give you the best of both worlds—you get the wonderful fine-grained dependencies of Bazel, the rich build system, the super fast performance. And then you get access to reproducible builds of all sorts of third-party dependencies through Nix. In practice, you need to become something of an expert in both Bazel and Nix in order to do this.<p>As a <i>final</i> option, depending on the languages you are using, you may be happy with just plain bzlmod. Like, Go integration with Bazel is damn solid. You don’t need to vendor anything, you can just keep using go.mod, and Bazel will deal with it (with some help from Gazelle). Bazel will even download the Go compiler for you, without any additional setup. A lot of other languages work the same way—it’s just that C and C++ are notable exceptions, where Bazel just grabs the system compiler by default, and package management for C and C++ is complete chaos.</div><br/></div></div><div id="40863041" class="c"><input type="checkbox" id="c-40863041" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#40862994">parent</a><span>|</span><a href="#40863254">prev</a><span>|</span><a href="#40863580">next</a><span>|</span><label class="collapse" for="c-40863041">[-]</label><label class="expand" for="c-40863041">[2 more]</label></div><br/><div class="children"><div class="content">Docker did us wonders but also set us back in many ways (same view point about the proliferation of development on MacOS).<p>I&#x27;ve lately been thinking why isn&#x27;t there a public vendored third_party set to use.<p>If we can agree living at HEAD is preferred having a communal vendored third_party seems like a clear win.</div><br/><div id="40863126" class="c"><input type="checkbox" id="c-40863126" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#40862994">root</a><span>|</span><a href="#40863041">parent</a><span>|</span><a href="#40863580">next</a><span>|</span><label class="collapse" for="c-40863126">[-]</label><label class="expand" for="c-40863126">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If we can agree living at HEAD is preferred having a communal vendored third_party seems like a clear win.<p>“It has been 0 days since a minor version update in a third-party library has broken my code.”<p>This is just a fiendishly difficult problem to solve.</div><br/></div></div></div></div></div></div><div id="40863580" class="c"><input type="checkbox" id="c-40863580" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40862994">prev</a><span>|</span><a href="#40862873">next</a><span>|</span><label class="collapse" for="c-40863580">[-]</label><label class="expand" for="c-40863580">[1 more]</label></div><br/><div class="children"><div class="content">The gross hack is you import libbfoo1 and libfoo2 when breaking changes like that are involved</div><br/></div></div><div id="40862873" class="c"><input type="checkbox" id="c-40862873" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40863580">prev</a><span>|</span><a href="#40862899">next</a><span>|</span><label class="collapse" for="c-40862873">[-]</label><label class="expand" for="c-40862873">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing this problem might be language-specific. Does Bazel do better at importing external dependencies for Go?</div><br/><div id="40862995" class="c"><input type="checkbox" id="c-40862995" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#40862873">parent</a><span>|</span><a href="#40863047">next</a><span>|</span><label class="collapse" for="c-40862995">[-]</label><label class="expand" for="c-40862995">[5 more]</label></div><br/><div class="children"><div class="content">If you look at how cgo is linked, you&#x27;ll see it&#x27;s a magic comment in go source code: <a href="https:&#x2F;&#x2F;github.com&#x2F;xthexder&#x2F;go-jack&#x2F;blob&#x2F;bc8604043aba0b6af80dca4f355b8fb884646370&#x2F;jack.go#L4">https:&#x2F;&#x2F;github.com&#x2F;xthexder&#x2F;go-jack&#x2F;blob&#x2F;bc8604043aba0b6af80...</a><p>If bazel allows impurely using that dependency from the host, like bazel allows for python, then you&#x27;ll be able to run into similar issues.<p>Admittedly, you&#x27;ll usually get compilation errors for undefined references in compiled languages (modulo dlopen), so at least you&#x27;ll get a build error instead of a runtime error like you do in python.<p>The solution for both Go and Python is for bazel to also control the system dependencies, i.e. to force you to run all code in a container sandbox bazel controls, force you to specify all external dependencies from linux kernel version up to go compiler version, and build all of that itself.<p>In other words, bazel is a lacking implementation of NixOS.</div><br/><div id="40863086" class="c"><input type="checkbox" id="c-40863086" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#40862873">root</a><span>|</span><a href="#40862995">parent</a><span>|</span><a href="#40863047">next</a><span>|</span><label class="collapse" for="c-40863086">[-]</label><label class="expand" for="c-40863086">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If bazel allows impurely using that dependency from the host, like bazel allows for python, then you&#x27;ll be able to run into similar issues.<p>That’s not how Bazel + CGO works <i>at all</i>. It sounds like you are making some guesses here but those guesses turned out to be wrong, sorry.<p>Go has an internal build system as well as a compiler. The build system drives the compiler. When you use Bazel with Go, you’re bypassing the Go build system entirely. Bazel directly invokes the Go compiler. This means that any of those comments will also get ignored. (Generally, this is how Bazel works for other languages too. Bazel + Rust does not use Cargo. Bazel + Java does not use, like, Maven or Gradle.)<p>You have to specify the dependencies in your build file. Let&#x27;s say you have a Go library abc, with a C library xyz.<p><pre><code>  go_library(
    name = &quot;abc&quot;,
    srcs = [
      &quot;abc.go&quot;,
    ],
    cdeps = [
      &quot;&#x2F;&#x2F;path&#x2F;to&#x2F;xyz&quot;,
    ],
    cgo = True,
    importpath = &quot;path&#x2F;to&#x2F;abc&quot;,
  )
</code></pre>
&gt; In other words, bazel is a lacking implementation of NixOS.<p>Bazel and NixOS are both good tools for making reproducible builds.<p>They’re even a good match for each other—grab your compiler from NixPkgs, and build the rest of your project in Bazel. You get the benefit of Bazel’s fine-grained dependencies (Nix has very coarse dependency management), and you can get some specific version of GCC built for both Linux and macOS by tapping into NixPkgs. A marriage made in heaven. (Except for the fact that you are now using two tools which both have very steep learning curves.)<p>There are a lot of interesting similarities between Bazel and Nix, which is not surprising, since they are solving similar problems.</div><br/><div id="40863312" class="c"><input type="checkbox" id="c-40863312" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#40862873">root</a><span>|</span><a href="#40863086">parent</a><span>|</span><a href="#40863047">next</a><span>|</span><label class="collapse" for="c-40863312">[-]</label><label class="expand" for="c-40863312">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That’s not how Bazel + CGO works at all. It sounds like you are making some guesses here but those guesses turned out to be wrong, sorry.<p>&gt; This means that any of those comments will also get ignored<p>I cloned this example: <a href="https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;rules_go&#x2F;tree&#x2F;634fc283f8d84ea61253a62b99a61edb5509f5de&#x2F;examples&#x2F;basic-gazelle">https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;rules_go&#x2F;tree&#x2F;634fc283f8d84ea6...</a><p>And then ran &quot;go get github.com&#x2F;xthexder&#x2F;go-jack&quot; and added an &#x27;import _ &quot;github.com&#x2F;xthexder&#x2F;go-jack&quot;&#x27; to &#x27;cmd&#x2F;roll.go&#x27;.<p><pre><code>    $ bazel run &#x2F;&#x2F;:gazelle-update-repos
    $ bazel run &#x2F;&#x2F;:basic-gazelle roll
    __main__&#x2F;external&#x2F;com_github_xthexder_go_jack&#x2F;jack.go:11:10: fatal error: jack&#x2F;jack.h: No such file or directory
    compilation terminated.
    compilepkg: error running subcommand external&#x2F;go_sdk&#x2F;pkg&#x2F;tool&#x2F;linux_amd64&#x2F;cgo: exit status 2

    $ apt-get install libjack-dev
    $ bazel run &#x2F;&#x2F;:basic-gazelle roll
    Number rolled: 80

</code></pre>
Sure looks like you&#x27;re wrong. Bazel obviously didn&#x27;t ignore those comments because it errored out on trying to find the include. (And of course it didn&#x27;t ignore them, those comments are preprocessor instructions for the go compiler, which bazel runs under the hood).
It obviously didn&#x27;t need me to specify cdeps because it found the C dependency on my host when I installed it without changing a single bazel-related file.<p>It looks like your understanding might be wrong, sorry.</div><br/><div id="40863366" class="c"><input type="checkbox" id="c-40863366" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#40862873">root</a><span>|</span><a href="#40863312">parent</a><span>|</span><a href="#40863047">next</a><span>|</span><label class="collapse" for="c-40863366">[-]</label><label class="expand" for="c-40863366">[2 more]</label></div><br/><div class="children"><div class="content">You’re making a complaint about Gazelle. If you import third-party packages with c dependencies with Gazelle, obviously, the two choices are it breaks hermeticity or you vendor the C code.<p>Bazel does ignore those comments. Gazelle does not.</div><br/><div id="40863524" class="c"><input type="checkbox" id="c-40863524" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#40862873">root</a><span>|</span><a href="#40863366">parent</a><span>|</span><a href="#40863047">next</a><span>|</span><label class="collapse" for="c-40863524">[-]</label><label class="expand" for="c-40863524">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Bazel does ignore those comments. Gazelle does not.<p>I really don&#x27;t understand what you&#x27;re saying.<p>gazelle does not seem to do anything related to the c dependencies there. The full diff gazelle generated is just changing &quot;deps&quot; in &#x27;BUILD.bazel&#x27; files to include the library, and adding a &quot;go_repository&quot; to &quot;deps.bzl&quot;. Not that it would matter anyway, gazelle is part of bazel.<p>There&#x27;s no references to c dependencies anywhere in what gazelle produced. I could have hand-written those changes just as easily, without gazelle.<p>I&#x27;m only using gazelle here because that&#x27;s the only go example that upstream has in the repo.<p>The &quot;bazel build&quot; part is very clearly the part that is looking for these C files, and doing so in a non-hermetic way.<p>It&#x27;s possible to make it hermetic, sure, if you pay attention and vendor things or such, but it&#x27;s obviously not required.<p>That&#x27;s all I was saying, just like you can have python break hermeticity and depend on external C libraries, you can have go break hermeticity and depend on external c libraries. It&#x27;s possible to use bazel such that it&#x27;s hermetic, but it doesn&#x27;t stop you from doing it wrong.<p>That&#x27;s all this thread is about, is whether it&#x27;s also possible to make these non-hermetic references in languages other than python.<p>Like, if you go back and read my commend and your comment a few up, you&#x27;ll see that my original claim was just that you could impurely reference the host &quot;libjack-dev&quot;, which I have very clearly shown you can, and your claim was that it&#x27;s literally impossible to do that, which it very obviously is possible.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40863047" class="c"><input type="checkbox" id="c-40863047" checked=""/><div class="controls bullet"><span class="by">stitched2gethr</span><span>|</span><a href="#40862873">parent</a><span>|</span><a href="#40862995">prev</a><span>|</span><a href="#40862942">next</a><span>|</span><label class="collapse" for="c-40863047">[-]</label><label class="expand" for="c-40863047">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. It feels like shared dependencies are akin to globals in your language of choice. Sharing dependency instances among components creates problems. A uses b and c, both of which want to use different versions of d. The simple answer, which is understandably difficult for existing languages to solve, is to just keep 2 copies of d.</div><br/><div id="40863328" class="c"><input type="checkbox" id="c-40863328" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40862873">root</a><span>|</span><a href="#40863047">parent</a><span>|</span><a href="#40862942">next</a><span>|</span><label class="collapse" for="c-40863328">[-]</label><label class="expand" for="c-40863328">[1 more]</label></div><br/><div class="children"><div class="content">Go does keep both versions like that for major versions (which are treated like independent libraries), but not for smaller upgrades that are supposed to be compatible.</div><br/></div></div></div></div><div id="40862942" class="c"><input type="checkbox" id="c-40862942" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#40862873">parent</a><span>|</span><a href="#40863047">prev</a><span>|</span><a href="#40862899">next</a><span>|</span><label class="collapse" for="c-40862942">[-]</label><label class="expand" for="c-40862942">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d have the same problem with CGO or JNI for Java.  C&#x2F;C++ shared libraries are never part of the package versioning in language package managers (that&#x27;s the part we stick our heads in the sand about)</div><br/></div></div></div></div><div id="40862899" class="c"><input type="checkbox" id="c-40862899" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#40862873">prev</a><span>|</span><label class="collapse" for="c-40862899">[-]</label><label class="expand" for="c-40862899">[3 more]</label></div><br/><div class="children"><div class="content">edit: The previous title was &quot;Reproducibility in Disguise: Bazel, Dependencies, and the Versioning Lie&quot;<p>Eh... the real lie is the signal version policy in the first place. It can be broken, at least in Google, and <i>must</i> be often otherwise there&#x27;d be massive gridlock.<p>If you want to bring in a new third-party library that has a dependency that already exists in the monorepo, you&#x27;d better _pray_ that the version in the monorepo is already compatible. If not, you have to update that library and potentially every target that depends on it, maybe transitively. Trying to do that can sometimes take <i>years</i> - no joke.<p>So the single-version policy flexes, and exceptions are supposed to be temporary, but they&#x27;re not always.<p>In the end there are two competing sometimes good, sometimes bad goals:<p>- Libraries should be somewhat discouraged from making too many or too flippant breaking changes. By having to update clients, they feel the pain and take migration more into account.<p>- Libraries should be able to make real improvements, even if they are breaking changes, and having clients shouldn&#x27;t burden them with unbounded costs. They should be able to distribute reasonable costs of updating by letting clients update on their own time with versioning.<p>Vendored third party packages only highlight this tension, because the external world has largely settled on versioning as the approach which clearly conflicts with signle-versions, but it really existed anyway.</div><br/><div id="40863014" class="c"><input type="checkbox" id="c-40863014" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#40862899">parent</a><span>|</span><a href="#40863233">prev</a><span>|</span><label class="collapse" for="c-40863014">[-]</label><label class="expand" for="c-40863014">[1 more]</label></div><br/><div class="children"><div class="content">Single version policy doesn&#x27;t solve version conflicts but it does put it right in your face which is as good as we can do.<p>Without single versions, new packages to the SAT solver can introduce new duplicate shared objects secretly breaking your hermetic seal.<p>It doesn&#x27;t hide the complexity like package managers do by picking a language package by SemVer and crossing our fingers that the shared objects included will work too.</div><br/></div></div></div></div></div></div></div></div></div></body></html>