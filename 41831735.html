<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729242071367" as="style"/><link rel="stylesheet" href="styles.css?v=1729242071367"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://shchegrikovich.substack.com/p/use-prolog-to-improve-llms-reasoning">Use Prolog to improve LLM&#x27;s reasoning</a>Â <span class="domain">(<a href="https://shchegrikovich.substack.com">shchegrikovich.substack.com</a>)</span></div><div class="subtext"><span>shchegrikovich</span> | <span>85 comments</span></div><br/><div><div id="41873798" class="c"><input type="checkbox" id="c-41873798" checked=""/><div class="controls bullet"><span class="by">z5h</span><span>|</span><a href="#41874542">next</a><span>|</span><label class="collapse" for="c-41873798">[-]</label><label class="expand" for="c-41873798">[31 more]</label></div><br/><div class="children"><div class="content">i&#x27;ve come to appreciate, over the past 2 years of heavy Prolog use, that all coding should be (eventually) be done in Prolog.<p>It&#x27;s one of few languages that is simultaneously a standalone logical formalism, and a standalone representation of computation. (With caveats and exceptions, I know). So a Prolog program can stand in as a document of all facts, rules and relations that a person&#x2F;organization understands&#x2F;declares to be true. Even if AI writes code for us, we should expect to have it presented and manipulated as a logical formalism.<p>Now if someone cares to argue that some other language&#x2F;compiler is better at generating more performant code on certain architectures, then that person can declare their arguments in a logical formalism (Prolog) and we can use Prolog to translate between language representations, compile, optimize, etc.</div><br/><div id="41875236" class="c"><input type="checkbox" id="c-41875236" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41874985">next</a><span>|</span><label class="collapse" for="c-41875236">[-]</label><label class="expand" for="c-41875236">[5 more]</label></div><br/><div class="children"><div class="content">&gt; over the past 2 years of heavy Prolog use<p>Oh, cool. Mind if I pick your brain a bit?<p>Recently, there was an HN post[0] of a paper that makes a case against pure logic languages in favor of &quot;functional logic&quot; ones, which they exhibit with Curry[1]. The setup argument is that Prolog&#x27;s specs backtracking, which strongly downlimits it from full SLD resolution, causing fatally sharp edges in real world usage.<p>Being fairly naive to the paradigm, my interpretation is that writing real Prolog programs involves carefully thinking about and controlling the resolution algorithm, which feels very different than straight knowledge declaration. I believe cut&#x2F;0 is the go-to example. Is that your experience with Prolog in practice?<p>The real meat of the paper, however, is in its case that functional logic languages fully embed Prolog with almost 1-to-1 expressivity, while also providing more refined tools for externalizing knowledge about the intended search space of solutions.<p>Thoughts? How are you using Prolog, logic, or constraint programming? What languages and tooling in this arena do you reach for? What is some of your most hard-earned knowledge? Any lesser-known, but golden, websites, books, or materials you&#x27;d like to share?<p>Cheers!<p>[0]:<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41816545">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41816545</a><p>[1]:<a href="https:&#x2F;&#x2F;www.curry-language.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.curry-language.org&#x2F;</a></div><br/><div id="41875988" class="c"><input type="checkbox" id="c-41875988" checked=""/><div class="controls bullet"><span class="by">z5h</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875236">parent</a><span>|</span><a href="#41875855">next</a><span>|</span><label class="collapse" for="c-41875988">[-]</label><label class="expand" for="c-41875988">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What is some of your most hard-earned knowledge?<p>1. If you find yourself straying too often from coding in relations, and instead coding in instructive steps, you&#x27;re going to end up with problems.<p>2. Use DCGs to create a DSL for any high level operations performed on data structures. The bi-directionality of Prolog&#x27;s clauses means you can use this DSL to generate an audit trail of &quot;commands executed&quot; when Prolog solves a problem for you, but you can also use the audit trail and modify it to execute those commands on other data.</div><br/></div></div><div id="41875855" class="c"><input type="checkbox" id="c-41875855" checked=""/><div class="controls bullet"><span class="by">z5h</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875236">parent</a><span>|</span><a href="#41875988">prev</a><span>|</span><a href="#41874985">next</a><span>|</span><label class="collapse" for="c-41875855">[-]</label><label class="expand" for="c-41875855">[3 more]</label></div><br/><div class="children"><div class="content">So first, let&#x27;s keep in mind that with no execution model, Prolog is still a &quot;syntax&quot; for Horn clauses. It&#x27;s still a way to document knowledge. Add SLD resolution and we can compute.
The paper (intentionally I presume) orders clauses of a simple predicate to illustrate (cause) a problem in Prolog.<p>But what I actually find is the more time spent in Prolog, the more natural it is to express things in a way that is clear, logical and performant. As with any language&#x2F;paradigm, there are a few gotchas to be experienced. But generally speaking, SLD resolution has never once been an obstacle (in the past 2 years) of coding.<p>The general execution model of Prolog is pretty simple. The lack of functions actually makes meta-programming much clearer and simpler. A term is just data, unless it&#x27;s stated as a goal. It&#x27;s only a valid goal if you&#x27;ve already defined its meaning.<p>So I&#x27;d be concerned that Curry gives up the simplicity of Prolog&#x27;s execution model, and ease of meta-programming. I struggle with the lack of types in Prolog, but also know I can (at least in theory) use Prolog to solve correctness problems in Prolog code.<p>I&#x27;m currently using SWI-Prolog. Performance is excellent, it has excellent high-level concurrency primitives[0]  (when was the last time you pegged all your cores solving a problem?), and many libraries. I might be one of the few people who has committed to using the integrated editor (PceEmacs) despite being a Vim person. PceEmacs is just too good at syntax highlighting and error detection.<p>At the same time, I&#x27;m a huge fan of Markus Triska. His Youtube[1] stuff is mind-expanding (watch all of it, even if you never write Prolog). He has an excellent book online[2]. I admire the way he explains and advances pure monotonic Prolog, and I appreciate the push for ISO conformance and his support for Prologs that that do the same (SWI is not on that list).<p>If you want to learn Prolog, watch all of Markus Triska&#x27;s videos, read his book, and learn what Prolog could be in a perfect world. Then download SWI-Prolog, and maybe break some rules while getting things done at a blazing speed. Eventually you&#x27;ll gravitate to what makes sense for you.<p>The Art of Prolog is a classic &quot;must have&quot;. Clause and Effect is a good &quot;hit the ground running&quot; (on page 70 you&#x27;re into symbolic differentiation via term rewriting).<p>0 <a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=thread" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?section=thread</a><p>1 <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;@ThePowerOfProlog" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;@ThePowerOfProlog</a><p>2 <a href="https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog" rel="nofollow">https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog</a></div><br/><div id="41876690" class="c"><input type="checkbox" id="c-41876690" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875855">parent</a><span>|</span><a href="#41877405">next</a><span>|</span><label class="collapse" for="c-41876690">[-]</label><label class="expand" for="c-41876690">[1 more]</label></div><br/><div class="children"><div class="content"><i>I&#x27;m currently using SWI-Prolog.</i><p>Still checking every now and then if SICStus has open sourced. I used Prolog daily during my PhD and SICStus had such nice features. E.g. it could raise an exception when no more heap space can be allocated or when a &#x27;call&#x27; would not finish within a given time. These features made it much easier to use Prolog in real-world systems (this was a parsing system and when parsing a very large corpus, this was highly preferable over simply crashing the interpreter).<p>Maybe things have changed, but this wasn&#x27;t possible with SWI at the time. Even worse, most C extensions would use malloc directly, making it impossible to track allocations done by extensions.</div><br/></div></div><div id="41877405" class="c"><input type="checkbox" id="c-41877405" checked=""/><div class="controls bullet"><span class="by">fao_</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875855">parent</a><span>|</span><a href="#41876690">prev</a><span>|</span><a href="#41874985">next</a><span>|</span><label class="collapse" for="c-41877405">[-]</label><label class="expand" for="c-41877405">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The Art of Prolog is a classic &quot;must have&quot;.<p>I figured it would be a good introduction to prolog, but to date there doesn&#x27;t seem to be any prolog interpreter that lets me copy the things in the book to play with them?</div><br/></div></div></div></div></div></div><div id="41874985" class="c"><input type="checkbox" id="c-41874985" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41875236">prev</a><span>|</span><a href="#41875196">next</a><span>|</span><label class="collapse" for="c-41874985">[-]</label><label class="expand" for="c-41874985">[6 more]</label></div><br/><div class="children"><div class="content">Been shouting here and many places for quite a while that CoT and all similar stuff eventually leads to logic programming. So happy Iâm not crazy.</div><br/><div id="41876509" class="c"><input type="checkbox" id="c-41876509" checked=""/><div class="controls bullet"><span class="by">ianandrich</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874985">parent</a><span>|</span><a href="#41875037">next</a><span>|</span><label class="collapse" for="c-41876509">[-]</label><label class="expand" for="c-41876509">[1 more]</label></div><br/><div class="children"><div class="content">You are not crazy.  Logic programming is the future</div><br/></div></div><div id="41875037" class="c"><input type="checkbox" id="c-41875037" checked=""/><div class="controls bullet"><span class="by">burntcaramel</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874985">parent</a><span>|</span><a href="#41876509">prev</a><span>|</span><a href="#41875543">next</a><span>|</span><label class="collapse" for="c-41875037">[-]</label><label class="expand" for="c-41875037">[1 more]</label></div><br/><div class="children"><div class="content">COT = Chain-of-Thought<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2201.11903" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2201.11903</a></div><br/></div></div><div id="41875543" class="c"><input type="checkbox" id="c-41875543" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874985">parent</a><span>|</span><a href="#41875037">prev</a><span>|</span><a href="#41875196">next</a><span>|</span><label class="collapse" for="c-41875543">[-]</label><label class="expand" for="c-41875543">[3 more]</label></div><br/><div class="children"><div class="content">Youâre in good company â the most influential AI academic of all time, the cooky grandfather of AI who picked up right where (when!) Turing left off, the man hated by both camps yet somehow in charge of them, agrees with you. Iâm talking about Marvin Minsky, of course. See: <i>Logical vs. Analogical</i> (Minsky, 1991) <a href="https:&#x2F;&#x2F;ojs.aaai.org&#x2F;aimagazine&#x2F;index.php&#x2F;aimagazine&#x2F;article&#x2F;download&#x2F;894&#x2F;812" rel="nofollow">https:&#x2F;&#x2F;ojs.aaai.org&#x2F;aimagazine&#x2F;index.php&#x2F;aimagazine&#x2F;article...</a><p><pre><code>  â¦the limitations of current machine intelligence largely stem from seeking unified theories or trying to repair the deficiencies of theoretically neat but conceptually impoverished ideological positions. 
  Our purely numeric connectionist networks are inherently deficient in abilities to reason well; our purely symbolic logical systems are inherently deficient in abilities to represent the all-important heuristic connections between thingsâthe uncertain, approximate, and analogical links that we need for making new hypotheses. The versatility that we need can be found only in larger-scale architectures that can exploit and manage the advantages of several types of representations at the same time.
  Then, each can be used to overcome the deficiencies of the others. To accomplish this task, each formally neat type of knowledge representation or inference must be complemented with some scruffier kind of machinery that can embody the heuristic connections between the knowledge itself and what we hope to do with it.
</code></pre>
He phrases it backwards here in comparison to what youâre talking about (probably because no one in their right mind would have predicted the feasibility of LLMs), but I think the parallel argument should be clear. Talking about âhuman reasoningâ like Simon &amp; Newell or LeCun &amp; Hinton do in terms of one single paradigm is like talking about âhuman neuronsâ. Thereâs tons of different neuronal architectures at play in our brains, and only through the ad-hoc minimally-centralized combination of all of them do we find success.<p>Personally, Iâm a big booster of the term <i>Unified Artificial Intelligence</i> (UAI) for this paradigm; isnât it fetch? ;)</div><br/><div id="41875691" class="c"><input type="checkbox" id="c-41875691" checked=""/><div class="controls bullet"><span class="by">dleink</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875543">parent</a><span>|</span><a href="#41875196">next</a><span>|</span><label class="collapse" for="c-41875691">[-]</label><label class="expand" for="c-41875691">[2 more]</label></div><br/><div class="children"><div class="content">Just throwing this out there for someone, &quot;Scruffier Kind of Machinery&quot; is a good name for a book, company or band.</div><br/><div id="41876892" class="c"><input type="checkbox" id="c-41876892" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875691">parent</a><span>|</span><a href="#41875196">next</a><span>|</span><label class="collapse" for="c-41876892">[-]</label><label class="expand" for="c-41876892">[1 more]</label></div><br/><div class="children"><div class="content">Heh, well spotted. SSKOM will be overtaking KGATLW any day nowâ¦</div><br/></div></div></div></div></div></div></div></div><div id="41875196" class="c"><input type="checkbox" id="c-41875196" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41874985">prev</a><span>|</span><a href="#41876589">next</a><span>|</span><label class="collapse" for="c-41875196">[-]</label><label class="expand" for="c-41875196">[1 more]</label></div><br/><div class="children"><div class="content">Prolog was a neat exercise, but for practical programming you might want to combine both logical and functional programming.  I think &#x27;Curry&#x27; does that.</div><br/></div></div><div id="41876589" class="c"><input type="checkbox" id="c-41876589" checked=""/><div class="controls bullet"><span class="by">dmichulke</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41875196">prev</a><span>|</span><a href="#41876880">next</a><span>|</span><label class="collapse" for="c-41876589">[-]</label><label class="expand" for="c-41876589">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s one of few languages that is simultaneously a standalone logical formalism, and a standalone representation of computation. (With caveats and exceptions, I know).<p>Would you be able to formulate all those &quot;caveats and exceptions&quot; <i>in</i> Prolog?</div><br/></div></div><div id="41876880" class="c"><input type="checkbox" id="c-41876880" checked=""/><div class="controls bullet"><span class="by">shchegrikovich</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41876589">prev</a><span>|</span><a href="#41874594">next</a><span>|</span><label class="collapse" for="c-41876880">[-]</label><label class="expand" for="c-41876880">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried - <a href="https:&#x2F;&#x2F;www.minizinc.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.minizinc.org&#x2F;</a>?</div><br/></div></div><div id="41874594" class="c"><input type="checkbox" id="c-41874594" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41876880">prev</a><span>|</span><a href="#41876524">next</a><span>|</span><label class="collapse" for="c-41874594">[-]</label><label class="expand" for="c-41874594">[4 more]</label></div><br/><div class="children"><div class="content">Is it your thought that for the average programmer Prolog is easier to read and maintain than say Go, C#, or Java?</div><br/><div id="41875574" class="c"><input type="checkbox" id="c-41875574" checked=""/><div class="controls bullet"><span class="by">z5h</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874594">parent</a><span>|</span><a href="#41877315">next</a><span>|</span><label class="collapse" for="c-41875574">[-]</label><label class="expand" for="c-41875574">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised at how readable Prolog is.<p>I&#x27;ve played with and seriously used many languages in my career. My experience is that pure functional (done Elm style) is productive and scales well to a larger team. Dynamic stuff like Ruby&#x2F;Javascript always has more bugs than you think, even with &quot;full&quot; test coverage. I&#x27;m not smart enough to make sense of my own Scheme meta-programming when I revisit it months later. I have loads (but dated) experience with Java and it (and peers) are relatively easy to read and maintain.<p>Prolog is very surprising, because it is homoiconic and immensely powerful in metaprogramming, BUT ... the declarative style and execution model reigns in the complexity&#x2F;readability. A term is just a term. Nothing happens when you create a term. If&#x2F;when a term is a goal, then you match it with the head of an existing predicate (something you&#x27;ve already coded). So it never gets too messy. 
Now, the biggest problem with Prolog is that it&#x27;s so flexible, you&#x27;ll perpetually be realizing that you could have coded something much more cleanly. So you do that, have less, code, it&#x27;s nicer, etc. Doing this on a large team might not scale without effort.</div><br/></div></div><div id="41877315" class="c"><input type="checkbox" id="c-41877315" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874594">parent</a><span>|</span><a href="#41875574">prev</a><span>|</span><a href="#41875069">next</a><span>|</span><label class="collapse" for="c-41877315">[-]</label><label class="expand" for="c-41877315">[1 more]</label></div><br/><div class="children"><div class="content">As someone that went through a degree where Prolog and LP was cherisched, I would say yes, however LP might be even weirder to start into than even FP.<p>Many folks on our degree couldn&#x27;t be happier when they didn&#x27;t had to see Prolog ever again, while me and others went on to take our chances on the national LP challenge across universities.<p>Tarski&#x27;s World was a good way back then to dive into what LP is all about, without being programming language specific.<p><a href="https:&#x2F;&#x2F;www.gradegrinder.net&#x2F;Products&#x2F;tw-index.html" rel="nofollow">https:&#x2F;&#x2F;www.gradegrinder.net&#x2F;Products&#x2F;tw-index.html</a></div><br/></div></div><div id="41875069" class="c"><input type="checkbox" id="c-41875069" checked=""/><div class="controls bullet"><span class="by">nsxwolf</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874594">parent</a><span>|</span><a href="#41877315">prev</a><span>|</span><a href="#41876524">next</a><span>|</span><label class="collapse" for="c-41875069">[-]</label><label class="expand" for="c-41875069">[1 more]</label></div><br/><div class="children"><div class="content">I found it completely impenetrable in college for all but the simplest problems and I tried to re-read the textbook recently and I didnât do much better.</div><br/></div></div></div></div><div id="41876524" class="c"><input type="checkbox" id="c-41876524" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41874594">prev</a><span>|</span><a href="#41874164">next</a><span>|</span><label class="collapse" for="c-41876524">[-]</label><label class="expand" for="c-41876524">[1 more]</label></div><br/><div class="children"><div class="content">What is your explanation for Prolog&#x27;s lack of uptake so far?<p>It has been around for 52 years and got a lot of buzz about 40 years ago because of its usefulness in creating expert systems.</div><br/></div></div><div id="41874164" class="c"><input type="checkbox" id="c-41874164" checked=""/><div class="controls bullet"><span class="by">dmead</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41876524">prev</a><span>|</span><a href="#41874229">next</a><span>|</span><label class="collapse" for="c-41874164">[-]</label><label class="expand" for="c-41874164">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s taken ages for anything from functional programming to penetrate general use. Do you think uptake of logic stuff will be any faster?</div><br/><div id="41874609" class="c"><input type="checkbox" id="c-41874609" checked=""/><div class="controls bullet"><span class="by">johnnyjeans</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874164">parent</a><span>|</span><a href="#41874229">next</a><span>|</span><label class="collapse" for="c-41874609">[-]</label><label class="expand" for="c-41874609">[5 more]</label></div><br/><div class="children"><div class="content">Prolog (and logic programming in general) is much older than you think. In fact, if we take modern functional programming to have been born with John Backus&#x27; Turing Award presentation[1], then it even predates it.<p>Many advancements to functional programming were implemented on top of Prolog! Erlang&#x27;s early versions were built on top of a Prolog-derived language who&#x27;s name escapes me. It&#x27;s the source of Erlang&#x27;s unfamiliar syntax for more unlearned programmers. It&#x27;s very much like writing Prolog if you had return values and no cuts or complex terms.<p>As for penetrating general use, probably not without a major shift in the industry. But it&#x27;s a very popular language just on the periphery, even to this day.<p>[1] - <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;359576.359579" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;359576.359579</a></div><br/><div id="41877531" class="c"><input type="checkbox" id="c-41877531" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874609">parent</a><span>|</span><a href="#41875216">next</a><span>|</span><label class="collapse" for="c-41877531">[-]</label><label class="expand" for="c-41877531">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Erlang&#x27;s early versions were built on top of a Prolog-derived language who&#x27;s name escapes me.<p>AFAIK, Erlang was originally implemented in Prolog and the original VM was inspired by the Warren Abstract Machine targeted by some Prolog implementations. It was also inspired by PLEX, but PLEX wasn&#x27;t a Prolog derivative.</div><br/></div></div><div id="41875216" class="c"><input type="checkbox" id="c-41875216" checked=""/><div class="controls bullet"><span class="by">dmead</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874609">parent</a><span>|</span><a href="#41877531">prev</a><span>|</span><a href="#41874229">next</a><span>|</span><label class="collapse" for="c-41875216">[-]</label><label class="expand" for="c-41875216">[3 more]</label></div><br/><div class="children"><div class="content">Did you just answer me with chatgpt?</div><br/><div id="41877453" class="c"><input type="checkbox" id="c-41877453" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875216">parent</a><span>|</span><a href="#41875549">next</a><span>|</span><label class="collapse" for="c-41877453">[-]</label><label class="expand" for="c-41877453">[1 more]</label></div><br/><div class="children"><div class="content">&gt; top of a Prolog-derived language who&#x27;s name escapes me<p>are you saying we&#x27;ve made a huge leap in LLMs - that they can now admit when they don&#x27;t know something?</div><br/></div></div><div id="41875549" class="c"><input type="checkbox" id="c-41875549" checked=""/><div class="controls bullet"><span class="by">hydrolox</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41875216">parent</a><span>|</span><a href="#41877453">prev</a><span>|</span><a href="#41874229">next</a><span>|</span><label class="collapse" for="c-41875549">[-]</label><label class="expand" for="c-41875549">[1 more]</label></div><br/><div class="children"><div class="content">definitely not how chat gpt writes</div><br/></div></div></div></div></div></div></div></div><div id="41874229" class="c"><input type="checkbox" id="c-41874229" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#41873798">parent</a><span>|</span><a href="#41874164">prev</a><span>|</span><a href="#41874542">next</a><span>|</span><label class="collapse" for="c-41874229">[-]</label><label class="expand" for="c-41874229">[5 more]</label></div><br/><div class="children"><div class="content">So why Prolog in particular and not another logic language like Mercury or Oz&#x2F;Mozart etc?</div><br/><div id="41874708" class="c"><input type="checkbox" id="c-41874708" checked=""/><div class="controls bullet"><span class="by">jfengel</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874229">parent</a><span>|</span><a href="#41874625">next</a><span>|</span><label class="collapse" for="c-41874708">[-]</label><label class="expand" for="c-41874708">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Prolog&quot; is like Lisp, a wide array of superficially similar languages that actually are quite diverse.<p>Mind you, in that sense, Java and C# are more or less the same language, which has Prolog programmers nodding their heads and Java and C# developers screaming.</div><br/><div id="41877454" class="c"><input type="checkbox" id="c-41877454" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874708">parent</a><span>|</span><a href="#41874625">next</a><span>|</span><label class="collapse" for="c-41877454">[-]</label><label class="expand" for="c-41877454">[1 more]</label></div><br/><div class="children"><div class="content">Nope. Prolog is an ISO-standardized language since 1995 and the spec was updated in 2012. Where older &quot;legacy&quot; Prolog implementations such as SWI, YAP, and SICStus are deviating from the standard is generally pretty well-known to Prolog practitioners, and the convener of ISO 13211 actually can verify claims of ISO conformance; for example, [1] is a link to the ISO certification of Quantum Prolog (the web app at [2]).<p>It&#x27;s true however that people are quick to conflate Prolog with constraint-logic programming libs, &quot;expert systems&quot; (RETE-style forward-chainging systems and other &quot;rule engines&quot;), or random &quot;functional-logic&quot; programming languages. The misunderstanding of PROLOG and logic by Lisp programmers has been ongoing since the 1980s, probably because at one point Prolog and Lisp were seen as competing &quot;languages for AI&quot; for some reason even though they have very little in common.<p>[1]: <a href="http:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;quantum-prolog&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;ulrich&#x2F;quantum-prolog&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.net" rel="nofollow">https:&#x2F;&#x2F;quantumprolog.sgml.net</a></div><br/></div></div></div></div><div id="41874625" class="c"><input type="checkbox" id="c-41874625" checked=""/><div class="controls bullet"><span class="by">infradig</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874229">parent</a><span>|</span><a href="#41874708">prev</a><span>|</span><a href="#41875287">next</a><span>|</span><label class="collapse" for="c-41874625">[-]</label><label class="expand" for="c-41874625">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not meant to be taken literally, it refers to any language of logic programmingâ. Apologies to Monty Python.</div><br/></div></div><div id="41875287" class="c"><input type="checkbox" id="c-41875287" checked=""/><div class="controls bullet"><span class="by">Avshalom</span><span>|</span><a href="#41873798">root</a><span>|</span><a href="#41874229">parent</a><span>|</span><a href="#41874625">prev</a><span>|</span><a href="#41874542">next</a><span>|</span><label class="collapse" for="c-41875287">[-]</label><label class="expand" for="c-41875287">[1 more]</label></div><br/><div class="children"><div class="content">Probably because neither of them have much in the way or library or community support.</div><br/></div></div></div></div></div></div><div id="41874542" class="c"><input type="checkbox" id="c-41874542" checked=""/><div class="controls bullet"><span class="by">gorkempacaci</span><span>|</span><a href="#41873798">prev</a><span>|</span><a href="#41876941">next</a><span>|</span><label class="collapse" for="c-41874542">[-]</label><label class="expand" for="c-41874542">[3 more]</label></div><br/><div class="children"><div class="content">The generated programs are only technically Prolog programs. They use CLPFD, which makes these constraint programs. Prolog programs are quite a bit more tricky with termination issues. I wouldnât have nitpicked if it wasnât in the title.<p>Also, the experiment method has some flaws. Problems are hand-picked out of a random subset of the full set. Why not run the full set?</div><br/><div id="41875614" class="c"><input type="checkbox" id="c-41875614" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#41874542">parent</a><span>|</span><a href="#41876941">next</a><span>|</span><label class="collapse" for="c-41875614">[-]</label><label class="expand" for="c-41875614">[2 more]</label></div><br/><div class="children"><div class="content">Yeah Iâm a huge proponent of this general philosophy, but after being introduced to prolog itself for a third of a semester back in undergrad I decided to stay far, far away. The vision never quite came through as clearly as it did for the other wacky languages, namely the functional family (Lisp and Haskell in my case). I believe you on the fundamental termination issues, but just basic phrasing seemed unnecessarily convolutedâ¦<p>Since you seem like an expert: is there a better technology for logical&#x2F;constraint programming? I loved predicate calculus in school so it seems like there should be something out there for me, but so far no dice. This seems <i>kinda</i> related to the widely-discussed paradigm of âLinear Programmingâ, but Iâve also failed to find much of interest there behind all the talk of âManagement Theoryâ and detailed mathematical efficiency comparisons.<p>I guess Curry (from above) might be the go-to these days?</div><br/><div id="41876736" class="c"><input type="checkbox" id="c-41876736" checked=""/><div class="controls bullet"><span class="by">gorkempacaci</span><span>|</span><a href="#41874542">root</a><span>|</span><a href="#41875614">parent</a><span>|</span><a href="#41876941">next</a><span>|</span><label class="collapse" for="c-41876736">[-]</label><label class="expand" for="c-41876736">[1 more]</label></div><br/><div class="children"><div class="content">Curious to know what part of syntax you found convoluted. If you remember any examples Iâd appreciate it.  
Maybe you want a constraint programming environment instead. As example check out Conjure from St Andrews:
<a href="https:&#x2F;&#x2F;conjure.readthedocs.io&#x2F;en&#x2F;latest&#x2F;tutorials-notebook.html" rel="nofollow">https:&#x2F;&#x2F;conjure.readthedocs.io&#x2F;en&#x2F;latest&#x2F;tutorials-notebook....</a><p>More generally there are the theorem provers like Coq, etc., but their use cases are even more specific.</div><br/></div></div></div></div></div></div><div id="41876941" class="c"><input type="checkbox" id="c-41876941" checked=""/><div class="controls bullet"><span class="by">TyrianPurple</span><span>|</span><a href="#41874542">prev</a><span>|</span><a href="#41876298">next</a><span>|</span><label class="collapse" for="c-41876941">[-]</label><label class="expand" for="c-41876941">[1 more]</label></div><br/><div class="children"><div class="content">Ah Prolog. So the full circle back to expert systems is complete now, yeah?</div><br/></div></div><div id="41876298" class="c"><input type="checkbox" id="c-41876298" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41876941">prev</a><span>|</span><a href="#41874168">next</a><span>|</span><label class="collapse" for="c-41876298">[-]</label><label class="expand" for="c-41876298">[1 more]</label></div><br/><div class="children"><div class="content">Check out <a href="https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog">https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog</a>   <a href="https:&#x2F;&#x2F;www.scryer.pl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scryer.pl&#x2F;</a><p>If you are close to Vienna Nov 7th and 8th there is a community meeting <a href="https:&#x2F;&#x2F;www.digitalaustria.gv.at&#x2F;eng&#x2F;insights&#x2F;Digital-Austria-Events-EN&#x2F;Scryer-Prolog-Meetup-2024.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalaustria.gv.at&#x2F;eng&#x2F;insights&#x2F;Digital-Austri...</a></div><br/></div></div><div id="41874168" class="c"><input type="checkbox" id="c-41874168" checked=""/><div class="controls bullet"><span class="by">fsndz</span><span>|</span><a href="#41876298">prev</a><span>|</span><a href="#41872982">next</a><span>|</span><label class="collapse" for="c-41874168">[-]</label><label class="expand" for="c-41874168">[1 more]</label></div><br/><div class="children"><div class="content">This is basically the LLM modulo approach recommended by Prof. Subbarao Kambhampati. Interesting but only works mostly for problems that have some math&#x2F;first degree logic puzzle at their heart. Will fail at improving perf at ARC-AGI for example...
Difficult to mimic reasoning by basic trial and error then hoping for the best:
<a href="https:&#x2F;&#x2F;www.lycee.ai&#x2F;blog&#x2F;why-sam-altman-is-wrong" rel="nofollow">https:&#x2F;&#x2F;www.lycee.ai&#x2F;blog&#x2F;why-sam-altman-is-wrong</a></div><br/></div></div><div id="41872982" class="c"><input type="checkbox" id="c-41872982" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41874168">prev</a><span>|</span><a href="#41875836">next</a><span>|</span><label class="collapse" for="c-41872982">[-]</label><label class="expand" for="c-41872982">[10 more]</label></div><br/><div class="children"><div class="content">So we are back to Japanese Fifth Generation plan from 1980&#x27;s. :)</div><br/><div id="41874052" class="c"><input type="checkbox" id="c-41874052" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41872982">parent</a><span>|</span><a href="#41873253">next</a><span>|</span><label class="collapse" for="c-41874052">[-]</label><label class="expand" for="c-41874052">[1 more]</label></div><br/><div class="children"><div class="content">For the uninitiated (like me):<p><i>The Japanese Fifth Generation Project</i><p><a href="https:&#x2F;&#x2F;www.sjsu.edu&#x2F;faculty&#x2F;watkins&#x2F;5thgen.htm" rel="nofollow">https:&#x2F;&#x2F;www.sjsu.edu&#x2F;faculty&#x2F;watkins&#x2F;5thgen.htm</a></div><br/></div></div><div id="41873253" class="c"><input type="checkbox" id="c-41873253" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#41872982">parent</a><span>|</span><a href="#41874052">prev</a><span>|</span><a href="#41873890">next</a><span>|</span><label class="collapse" for="c-41873253">[-]</label><label class="expand" for="c-41873253">[2 more]</label></div><br/><div class="children"><div class="content">This time around we have all sorts of parallel processing capabilities in the form of GPUs.  If I recall correctly, the Fifth Generation project envisioned highly parallel machines performing symbolic AI.  From a hardware standpoint, those researchers were way ahead of their time.</div><br/><div id="41873372" class="c"><input type="checkbox" id="c-41873372" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#41872982">root</a><span>|</span><a href="#41873253">parent</a><span>|</span><a href="#41873890">next</a><span>|</span><label class="collapse" for="c-41873372">[-]</label><label class="expand" for="c-41873372">[1 more]</label></div><br/><div class="children"><div class="content">And they had a self-sustaining video game industry too... if only someone had had the wild thought of implementing perceptrons and tensor arithmetic on the same hardware!</div><br/></div></div></div></div><div id="41873890" class="c"><input type="checkbox" id="c-41873890" checked=""/><div class="controls bullet"><span class="by">postepowanieadm</span><span>|</span><a href="#41872982">parent</a><span>|</span><a href="#41873253">prev</a><span>|</span><a href="#41873178">next</a><span>|</span><label class="collapse" for="c-41873890">[-]</label><label class="expand" for="c-41873890">[1 more]</label></div><br/><div class="children"><div class="content">and winter is coming.</div><br/></div></div><div id="41873178" class="c"><input type="checkbox" id="c-41873178" checked=""/><div class="controls bullet"><span class="by">tokinonagare</span><span>|</span><a href="#41872982">parent</a><span>|</span><a href="#41873890">prev</a><span>|</span><a href="#41873176">next</a><span>|</span><label class="collapse" for="c-41873178">[-]</label><label class="expand" for="c-41873178">[4 more]</label></div><br/><div class="children"><div class="content">Missing some LISP but yeah it&#x27;s funny how old things are new again (same story with wasm, RISC archs, etc.)</div><br/><div id="41873328" class="c"><input type="checkbox" id="c-41873328" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#41872982">root</a><span>|</span><a href="#41873178">parent</a><span>|</span><a href="#41873176">next</a><span>|</span><label class="collapse" for="c-41873328">[-]</label><label class="expand" for="c-41873328">[3 more]</label></div><br/><div class="children"><div class="content">Lots of GOFAI being implemented again â decision trees, goal searching and planning, agent-based strategies... just not symbolic representations, and that might be the key. I figure you might get an interesting contribution out of skimming old AI laboratory publications and seeing whether you could find a way of implementing it through a single LLM, multiple LLM agents, methods of training, etc.</div><br/><div id="41874791" class="c"><input type="checkbox" id="c-41874791" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#41872982">root</a><span>|</span><a href="#41873328">parent</a><span>|</span><a href="#41873922">next</a><span>|</span><label class="collapse" for="c-41874791">[-]</label><label class="expand" for="c-41874791">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, modern ML has been a validation of (some of) GOFAI: <a href="https:&#x2F;&#x2F;neilmadden.blog&#x2F;2024&#x2F;06&#x2F;30&#x2F;machine-learning-and-the-triumph-of-gofai&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neilmadden.blog&#x2F;2024&#x2F;06&#x2F;30&#x2F;machine-learning-and-the-...</a></div><br/></div></div><div id="41873922" class="c"><input type="checkbox" id="c-41873922" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41872982">root</a><span>|</span><a href="#41873328">parent</a><span>|</span><a href="#41874791">prev</a><span>|</span><a href="#41873176">next</a><span>|</span><label class="collapse" for="c-41873922">[-]</label><label class="expand" for="c-41873922">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Constraint_satisfaction_problem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Constraint_satisfaction_prob...</a></div><br/></div></div></div></div></div></div><div id="41873176" class="c"><input type="checkbox" id="c-41873176" checked=""/><div class="controls bullet"><span class="by">thelastparadise</span><span>|</span><a href="#41872982">parent</a><span>|</span><a href="#41873178">prev</a><span>|</span><a href="#41875836">next</a><span>|</span><label class="collapse" for="c-41873176">[-]</label><label class="expand" for="c-41873176">[1 more]</label></div><br/><div class="children"><div class="content">Watson did it too, a while back.</div><br/></div></div></div></div><div id="41875836" class="c"><input type="checkbox" id="c-41875836" checked=""/><div class="controls bullet"><span class="by">luke_galea</span><span>|</span><a href="#41872982">prev</a><span>|</span><a href="#41873281">next</a><span>|</span><label class="collapse" for="c-41875836">[-]</label><label class="expand" for="c-41875836">[2 more]</label></div><br/><div class="children"><div class="content">Super cool. I dig generating rules from within the LLM, but I&#x27;m not sure Prolog is the right choice in 2024.<p>I love Prolog and had the opportunity to use it &quot;in anger&quot; years ago to handle temporal logic in a scheduling app. Great experience, but I&#x27;ve found that more modern rules engines like Drools (anything using the Rete algorithm) are a <i>MUCH</i> better fit for most use cases these days.<p>If you are into this stuff, you might like the talk I gave on rules engines, prolog and how it led to erlang &amp; elixir. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mDnntrhk-8g&amp;t=1s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mDnntrhk-8g&amp;t=1s</a></div><br/><div id="41876289" class="c"><input type="checkbox" id="c-41876289" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#41875836">parent</a><span>|</span><a href="#41873281">next</a><span>|</span><label class="collapse" for="c-41876289">[-]</label><label class="expand" for="c-41876289">[1 more]</label></div><br/><div class="children"><div class="content">The choice is limited to the languages that LLMs already know really well. Fwiw, here is GPT&#x27;s self-rating out of 10:<p>Python: 9, Prolog: 7, Datalog: 6, Mercury: 6, Curry: 5, Drools: 4<p>This is not even the full set of what the LLM might like to use. It may also like pyDatalog, SymPy, Haskell, Clingo ASP, ECLiPSe CLP, etc.</div><br/></div></div></div></div><div id="41873281" class="c"><input type="checkbox" id="c-41873281" checked=""/><div class="controls bullet"><span class="by">a1j9o94</span><span>|</span><a href="#41875836">prev</a><span>|</span><a href="#41874449">next</a><span>|</span><label class="collapse" for="c-41873281">[-]</label><label class="expand" for="c-41873281">[5 more]</label></div><br/><div class="children"><div class="content">I tried an experiment with this using a Prolog interpreter with GPT-4 to try to answer complex logic questions. I found that it was really difficult because the model didn&#x27;t seem to know Prolog well enough to write a description of any complexity.<p>It seems like you used an interpreter in the loop which is likely to help. I&#x27;d also be interested to see how o1 would do in a task like this or if it even makes sense to use something like prolog if the models can backtrack during the &quot;thinking&quot; phase</div><br/><div id="41873700" class="c"><input type="checkbox" id="c-41873700" checked=""/><div class="controls bullet"><span class="by">hendler</span><span>|</span><a href="#41873281">parent</a><span>|</span><a href="#41873561">next</a><span>|</span><label class="collapse" for="c-41873700">[-]</label><label class="expand" for="c-41873700">[2 more]</label></div><br/><div class="children"><div class="content">I also wrote wrote an LLM to Prolog interpreter for a hackathon called &quot;Logical&quot;.
With a few hours effort I&#x27;m sure it could be improved.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Hendler&#x2F;logical">https:&#x2F;&#x2F;github.com&#x2F;Hendler&#x2F;logical</a><p>I think while LLMs may approach completeness here, it&#x27;s good to have an interpretable system to audit&#x2F;verify and reproduce results.</div><br/><div id="41876898" class="c"><input type="checkbox" id="c-41876898" checked=""/><div class="controls bullet"><span class="by">shchegrikovich</span><span>|</span><a href="#41873281">root</a><span>|</span><a href="#41873700">parent</a><span>|</span><a href="#41873561">next</a><span>|</span><label class="collapse" for="c-41876898">[-]</label><label class="expand" for="c-41876898">[1 more]</label></div><br/><div class="children"><div class="content">This is really cool!</div><br/></div></div></div></div><div id="41873561" class="c"><input type="checkbox" id="c-41873561" checked=""/><div class="controls bullet"><span class="by">lukasb</span><span>|</span><a href="#41873281">parent</a><span>|</span><a href="#41873700">prev</a><span>|</span><a href="#41874449">next</a><span>|</span><label class="collapse" for="c-41873561">[-]</label><label class="expand" for="c-41873561">[2 more]</label></div><br/><div class="children"><div class="content">I bet one person could probably build a pretty good synthetic NL-&gt;Prolog dataset. ROI for paying that person would be high if you were building a foundation model (ie benefits beyond being able to output Prolog.)</div><br/><div id="41875620" class="c"><input type="checkbox" id="c-41875620" checked=""/><div class="controls bullet"><span class="by">mcswell</span><span>|</span><a href="#41873281">root</a><span>|</span><a href="#41873561">parent</a><span>|</span><a href="#41874449">next</a><span>|</span><label class="collapse" for="c-41875620">[-]</label><label class="expand" for="c-41875620">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not exactly sure what you&#x27;re referring to, but Fernando Pereira&#x27;s dissertation included a natural language (English) program for querying a &quot;database&quot;.  Both the NLP part and the database were written in Prolog.  Mid-1980s, I think.  Of course both parts were &quot;toy&quot; in the sense that they would need to be hugely expanded to be of real world use, but they did handle some interesting things (like quantifiers, graded adjectives etc.).</div><br/></div></div></div></div></div></div><div id="41874449" class="c"><input type="checkbox" id="c-41874449" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#41873281">prev</a><span>|</span><a href="#41874397">next</a><span>|</span><label class="collapse" for="c-41874449">[-]</label><label class="expand" for="c-41874449">[1 more]</label></div><br/><div class="children"><div class="content">I think this general idea is going to be the key to really making LLMs widely useful for solving real problems.<p>Iâve been playing with using GPT-4 together with the Wolfram Alpha plugin, and the combo of the two can reliably solve difficult quantitative problems that neither can individually by working together, much like a human using a calculator.</div><br/></div></div><div id="41874397" class="c"><input type="checkbox" id="c-41874397" checked=""/><div class="controls bullet"><span class="by">DeborahWrites</span><span>|</span><a href="#41874449">prev</a><span>|</span><a href="#41873658">next</a><span>|</span><label class="collapse" for="c-41874397">[-]</label><label class="expand" for="c-41874397">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re telling me the seemingly arbitrary 6 weeks of Prolog on my comp sci course 11yrs ago is suddenly about to be relevant? I did not see this one coming . . .</div><br/><div id="41876651" class="c"><input type="checkbox" id="c-41876651" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#41874397">parent</a><span>|</span><a href="#41874466">next</a><span>|</span><label class="collapse" for="c-41876651">[-]</label><label class="expand" for="c-41876651">[1 more]</label></div><br/><div class="children"><div class="content">I rolled my eyes when iterating a list meant splitting it into first and rest and recursing on the rest. I would do side projects in Scala a few years later of my own interest.</div><br/></div></div><div id="41874466" class="c"><input type="checkbox" id="c-41874466" checked=""/><div class="controls bullet"><span class="by">fullstackwife</span><span>|</span><a href="#41874397">parent</a><span>|</span><a href="#41876651">prev</a><span>|</span><a href="#41873658">next</a><span>|</span><label class="collapse" for="c-41874466">[-]</label><label class="expand" for="c-41874466">[1 more]</label></div><br/><div class="children"><div class="content">Is there any need to look at this generated Prolog code?</div><br/></div></div></div></div><div id="41873658" class="c"><input type="checkbox" id="c-41873658" checked=""/><div class="controls bullet"><span class="by">nonamepcbrand1</span><span>|</span><a href="#41874397">prev</a><span>|</span><a href="#41874467">next</a><span>|</span><label class="collapse" for="c-41873658">[-]</label><label class="expand" for="c-41873658">[1 more]</label></div><br/><div class="children"><div class="content">This is why GitHub CodeQL and Co-Pilot assistance is working better for everyone? basically codeql uses variant of Prolog (datalog) to query source code to generate better results.</div><br/></div></div><div id="41874467" class="c"><input type="checkbox" id="c-41874467" checked=""/><div class="controls bullet"><span class="by">de6u99er</span><span>|</span><a href="#41873658">prev</a><span>|</span><a href="#41876268">next</a><span>|</span><label class="collapse" for="c-41874467">[-]</label><label class="expand" for="c-41874467">[1 more]</label></div><br/><div class="children"><div class="content">I always thought that Prolog is great for reasoning in the semantic web. It doesn&#x27;t surprise me that LLM people stumble on it.</div><br/></div></div><div id="41876268" class="c"><input type="checkbox" id="c-41876268" checked=""/><div class="controls bullet"><span class="by">treetalker</span><span>|</span><a href="#41874467">prev</a><span>|</span><a href="#41873348">next</a><span>|</span><label class="collapse" for="c-41876268">[-]</label><label class="expand" for="c-41876268">[2 more]</label></div><br/><div class="children"><div class="content">Does anyone know why US attorneys and law firms are not using Prolog-based apps to automate the low-hanging fruit of issue-spotting?</div><br/><div id="41877024" class="c"><input type="checkbox" id="c-41877024" checked=""/><div class="controls bullet"><span class="by">shchegrikovich</span><span>|</span><a href="#41876268">parent</a><span>|</span><a href="#41873348">next</a><span>|</span><label class="collapse" for="c-41877024">[-]</label><label class="expand" for="c-41877024">[1 more]</label></div><br/><div class="children"><div class="content">Or something like Catala language - <a href="https:&#x2F;&#x2F;catala-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;catala-lang.org&#x2F;</a>? Catala: A Programming Language for the Law - <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2103.03198" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2103.03198</a></div><br/></div></div></div></div><div id="41873348" class="c"><input type="checkbox" id="c-41873348" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41876268">prev</a><span>|</span><a href="#41874651">next</a><span>|</span><label class="collapse" for="c-41873348">[-]</label><label class="expand" for="c-41873348">[1 more]</label></div><br/><div class="children"><div class="content">Patiently waiting for z3-guided generation, but this is a welcome, if obvious, development. Results are a bit surprising and sound too optimistic, though.</div><br/></div></div><div id="41874651" class="c"><input type="checkbox" id="c-41874651" checked=""/><div class="controls bullet"><span class="by">ianbicking</span><span>|</span><a href="#41873348">prev</a><span>|</span><a href="#41873249">next</a><span>|</span><label class="collapse" for="c-41874651">[-]</label><label class="expand" for="c-41874651">[3 more]</label></div><br/><div class="children"><div class="content">I made a pipeline using Z3 (another prover language) to get LLMs to solve very specific puzzle problems: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;UjSf0rA1blc" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;UjSf0rA1blc</a> (and a presentation: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;TUAmfi8Ws1g" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;TUAmfi8Ws1g</a>)<p>Some thoughts:<p>1. Getting an LLM to model a problem accurately is a significant prompting exercise. Bridging casual logical statements and formal logic is difficult. E.g., &quot;or&quot; statements in English usually mean &quot;xor&quot; in logic.<p>2. Domains usually have their own language expectations. I was doing Zebra puzzles (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zebra_Puzzle" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zebra_Puzzle</a>) and they have a very specific pattern and language. I don&#x27;t think it&#x27;s fair to really call it intuitive or even entirely unambiguous, it&#x27;s something you have to learn. The LLM has to learn it too. They have seen this kind of puzzle (and I think most can reproduce the original Zebra puzzle from memory), but they lack a really firm familiarity.<p>3. Arguably some of the familiarity is about contextualizing the problem, which is itself a prompting task. People don&#x27;t naturally solve Zebra puzzles that we find organically, it&#x27;s something we encounter in specific contexts (like a puzzle book) which is not so dissimilar from prompting.<p>4. Incidentally Claude Sonnet 3.5 has a substantial lead. And GPT o1 is not much better than GPT 4o. In some sense I think o1 is a kind of self-prompting, an attempt to create its own context; so if you already have a well-worded prompt with instructions then o1 isn&#x27;t that good at improving performance over 4o.<p>5. A lot of the prompting is really intended to slow down the LLM, to keep it from jumping to conclusions or solving a task too quickly (and incorrectly). Which again is a case of the prompt doing what o1 tries to do generally.<p>6. I&#x27;m not sure what tasks call for this kind of logical reasoning. Not that I don&#x27;t think they exist, I just don&#x27;t know how to recognize them. Planning tasks? Highly formalized and artificially constructed problems don&#x27;t seem all that interesting... and the whole point of adding an LLM to the process is to formalize the informal.<p>7. Perhaps it&#x27;s hard to see because real-world problems seldom have conveniently exact solutions. But that&#x27;s not a blocker... Prolog (and Z3) can take constraints as a form of elimination, providing lists of possible answers, and maybe just reducing the search space is enough to move forward on some kinds of problems.<p>8. For instance when I give my pipeline really hard Zebra problems it usually doesn&#x27;t succeed; one bug in one rule will kill the whole thing. Also I think the LLMs have a hard time keeping track of large problems; a context size problem, even though the problems don&#x27;t approach their formal context limits. But I can imagine building the pipeline so it also tries to mark low-confidence rules. Given that I can imagine removing those rules, sampling the resulting (non-unique, sometimes incorrect) answers and using that to revisit and perhaps correct some of those rules.<p>Really I&#x27;d be most interested to hear thoughts on where this logic programming might actually be applied... artificial puzzles are an interesting exercise, but I can&#x27;t really motivate myself to go too deep.</div><br/><div id="41874857" class="c"><input type="checkbox" id="c-41874857" checked=""/><div class="controls bullet"><span class="by">gbanfalvi</span><span>|</span><a href="#41874651">parent</a><span>|</span><a href="#41876921">next</a><span>|</span><label class="collapse" for="c-41874857">[-]</label><label class="expand" for="c-41874857">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 6. I&#x27;m not sure what tasks call for this kind of logical reasoning<p>Basically any tasks that fulfill legal or business requirements? Both companies and governments are rushing to put LLMs into anything they can to avoid paying people. Itâs vital to ascertain that, say, a benefits application is assessed properly and the LLM doesnât hallucinate its way into an incorrect decision.<p>Iâd question if we really need LLMs in many of the places weâre sticking them at all (or if itâll even be cheaper), but thatâs more flawed human decision.</div><br/></div></div><div id="41876921" class="c"><input type="checkbox" id="c-41876921" checked=""/><div class="controls bullet"><span class="by">shchegrikovich</span><span>|</span><a href="#41874651">parent</a><span>|</span><a href="#41874857">prev</a><span>|</span><a href="#41873249">next</a><span>|</span><label class="collapse" for="c-41876921">[-]</label><label class="expand" for="c-41876921">[1 more]</label></div><br/><div class="children"><div class="content">I think another problem which we can try to solve with this approach is factual verification.</div><br/></div></div></div></div><div id="41873249" class="c"><input type="checkbox" id="c-41873249" checked=""/><div class="controls bullet"><span class="by">sgt101</span><span>|</span><a href="#41874651">prev</a><span>|</span><a href="#41874339">next</a><span>|</span><label class="collapse" for="c-41873249">[-]</label><label class="expand" for="c-41873249">[1 more]</label></div><br/><div class="children"><div class="content">Building on this idea people have grounded LLM generated reasoning logic with perceptual information from other networks : <a href="https:&#x2F;&#x2F;web.stanford.edu&#x2F;~joycj&#x2F;projects&#x2F;left_neurips_2023" rel="nofollow">https:&#x2F;&#x2F;web.stanford.edu&#x2F;~joycj&#x2F;projects&#x2F;left_neurips_2023</a></div><br/></div></div><div id="41874339" class="c"><input type="checkbox" id="c-41874339" checked=""/><div class="controls bullet"><span class="by">arjun_khamkar</span><span>|</span><a href="#41873249">prev</a><span>|</span><a href="#41874497">next</a><span>|</span><label class="collapse" for="c-41874339">[-]</label><label class="expand" for="c-41874339">[2 more]</label></div><br/><div class="children"><div class="content">Would Creating a prolog dataset would be beneficial, so that future LLM&#x27;s can be trained on it and then they would be able to output prolog code.</div><br/><div id="41876931" class="c"><input type="checkbox" id="c-41876931" checked=""/><div class="controls bullet"><span class="by">shchegrikovich</span><span>|</span><a href="#41874339">parent</a><span>|</span><a href="#41874497">next</a><span>|</span><label class="collapse" for="c-41876931">[-]</label><label class="expand" for="c-41876931">[1 more]</label></div><br/><div class="children"><div class="content">I discussed this a few weeks back. The idea is to take a Python dataset, as Python is the most popular language, and write a transpiler to Prolog with the help of llms. So, creating this synthetic dataset is not a huge problem.</div><br/></div></div></div></div><div id="41874497" class="c"><input type="checkbox" id="c-41874497" checked=""/><div class="controls bullet"><span class="by">bytebach</span><span>|</span><a href="#41874339">prev</a><span>|</span><a href="#41876133">next</a><span>|</span><label class="collapse" for="c-41874497">[-]</label><label class="expand" for="c-41874497">[4 more]</label></div><br/><div class="children"><div class="content">An application I am developing for a customer needed to read constraints around clinical trials and essentially build a query from them. Constraints involve prior treatments, biomarkers, type of disease (cancers) etc.<p>Using just an LLM did not produce reliable queries, despite trying many many prompts, so being an old Prolog hacker I wondered if using it might impose more &#x27;logic&#x27; on the LLM. So we precede the textual description of the constraints with the following prompt:<p>-------------<p>Now consider the following Prolog predicates:<p>biomarker(Name, Status) where Status will be one of the following integers -<p>Wildtype = 0
 Mutated = 1
 Methylated = 2
 Unmethylated = 3
 Amplified = 4
 Deleted = 5
 Positive = 6
 Negative = 7<p>tumor(Name, Status) where Status will be one of the following integers if know else left unbound -<p>Newly diagnosed = 1
 Recurrence = 2
 Metastasized = 3
 Progression = 4<p>chemo(Name)<p>surgery(Name)  Where Name may be an unbound variable<p>other_treatment(Name)<p>radiation(Name) Where Name may be an unbound variable<p>Assume you are given predicate  atMost(T, N) where T is a compound term and N is an integer. 
It will return true if the number of &#x27;occurences&#x27; of T is less than or equal N else it will fail.<p>Assume you are given a predicate atLeastOneOf(L) where L is a list of compound terms. 
It will succeed if at least one of the compound terms, when executed as a predicate returns true.<p>Assume you are given a predicate age(Min, Max) which will return true if the patient&#x27;s age is in between Min and Max.<p>Assume you have a predicate not(T) which returns true if predicate T evaluates false and vice versa. 
i.e. rather than &#x27;\\+ A&#x27; use not(A).<p>Do not implement the above helper functions.<p>VERY IMPORTANT: Use &#x27;atLeastOneOf()&#x27; whenever you would otherwise use &#x27;;&#x27; to represent &#x27;OR&#x27;.  
i.e. rather than &#x27;A ; B&#x27; use atLeastOneOf([A, B]).<p>EXAMPLE INPUT: 
Patient must have recurrent GBM, methylated MGMT and wildtype EGFR. Patient must not have mutated KRAS.<p>EXAMPLE OUTPUT:
 tumor(&#x27;gbm&#x27;, 2),
 biomarker(&#x27;MGMT&#x27;, 2),
 biomarker(&#x27;EGFR&#x27;, 0),
 not(biomarker(&#x27;KRAS&#x27;, 1))<p>------------------<p>The Prolog predicates, when evaluated generate the required underlying query (of course the Prolog 
is itself a form of query).<p>Anyway - the upshot was a vast improvement in the accuracy of the generated query (I&#x27;ve yet to see a bad one). Somewhere in its bowels, being told to generate Prolog &#x27;focused&#x27; the LLM. Perhaps LLMs are happier with declarative languages rather than imperative ones (I know I am :) ).</div><br/><div id="41876420" class="c"><input type="checkbox" id="c-41876420" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41874497">parent</a><span>|</span><a href="#41876957">next</a><span>|</span><label class="collapse" for="c-41876420">[-]</label><label class="expand" for="c-41876420">[1 more]</label></div><br/><div class="children"><div class="content">I find that having GPT-4 write SQL queries to query the data source as needed to solve a complex task step-by-step also works pretty well (and you can give it the schema in form of CREATE TABLE). It&#x27;s not exactly good at writing <i>fast</i> queries, but it can do some hella complex ones with nesting and joins to get exactly what it needs in one go.</div><br/></div></div><div id="41876957" class="c"><input type="checkbox" id="c-41876957" checked=""/><div class="controls bullet"><span class="by">shchegrikovich</span><span>|</span><a href="#41874497">parent</a><span>|</span><a href="#41876420">prev</a><span>|</span><a href="#41877050">next</a><span>|</span><label class="collapse" for="c-41876957">[-]</label><label class="expand" for="c-41876957">[1 more]</label></div><br/><div class="children"><div class="content">I agree; we can do much more with LLMs if we focus on declarative-style languages.</div><br/></div></div><div id="41877050" class="c"><input type="checkbox" id="c-41877050" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#41874497">parent</a><span>|</span><a href="#41876957">prev</a><span>|</span><a href="#41876133">next</a><span>|</span><label class="collapse" for="c-41877050">[-]</label><label class="expand" for="c-41877050">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like a very important observation.</div><br/></div></div></div></div><div id="41876133" class="c"><input type="checkbox" id="c-41876133" checked=""/><div class="controls bullet"><span class="by">timonoko</span><span>|</span><a href="#41874497">prev</a><span>|</span><a href="#41874200">next</a><span>|</span><label class="collapse" for="c-41876133">[-]</label><label class="expand" for="c-41876133">[1 more]</label></div><br/><div class="children"><div class="content">Interest in Prolog always ends with the &quot;!&quot;. It is ugly and like smack in the head, &quot;you are thinking too much&quot;.</div><br/></div></div><div id="41874200" class="c"><input type="checkbox" id="c-41874200" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41876133">prev</a><span>|</span><a href="#41877053">next</a><span>|</span><label class="collapse" for="c-41874200">[-]</label><label class="expand" for="c-41874200">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not going to work. Garbage in - Garbage out is success-set equivalent to Garbage in - Prolog out.<p>Garbage is garbage and failure to reason is failure to reason no matter the language. If your LLM can&#x27;t translate your problem to a Prolog program that solves your problem- Prolog can&#x27;t solve your problem.</div><br/><div id="41874322" class="c"><input type="checkbox" id="c-41874322" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#41874200">parent</a><span>|</span><a href="#41876345">next</a><span>|</span><label class="collapse" for="c-41874322">[-]</label><label class="expand" for="c-41874322">[4 more]</label></div><br/><div class="children"><div class="content">This is a shallow critique that does not engage with the core idea. Specifying the problem is not the same as solving the problem.</div><br/><div id="41874902" class="c"><input type="checkbox" id="c-41874902" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#41874200">root</a><span>|</span><a href="#41874322">parent</a><span>|</span><a href="#41876345">next</a><span>|</span><label class="collapse" for="c-41874902">[-]</label><label class="expand" for="c-41874902">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve programmed in Prolog for ~13 years and my PhD thesis is in machine learning of Prolog programs. How <i>deep</i> would you like me to go?</div><br/><div id="41875047" class="c"><input type="checkbox" id="c-41875047" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#41874200">root</a><span>|</span><a href="#41874902">parent</a><span>|</span><a href="#41875563">next</a><span>|</span><label class="collapse" for="c-41875047">[-]</label><label class="expand" for="c-41875047">[1 more]</label></div><br/><div class="children"><div class="content">As deep as is required to actually make your argument!</div><br/></div></div><div id="41875563" class="c"><input type="checkbox" id="c-41875563" checked=""/><div class="controls bullet"><span class="by">MrLeap</span><span>|</span><a href="#41874200">root</a><span>|</span><a href="#41874902">parent</a><span>|</span><a href="#41875047">prev</a><span>|</span><a href="#41876345">next</a><span>|</span><label class="collapse" for="c-41875563">[-]</label><label class="expand" for="c-41875563">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m excited for the possibility of an escalation after reading this.</div><br/></div></div></div></div></div></div><div id="41876345" class="c"><input type="checkbox" id="c-41876345" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#41874200">parent</a><span>|</span><a href="#41874322">prev</a><span>|</span><a href="#41875551">next</a><span>|</span><label class="collapse" for="c-41876345">[-]</label><label class="expand" for="c-41876345">[1 more]</label></div><br/><div class="children"><div class="content">Why do you think that the LLM cannot translate the problem into a program? Granted, it has been said that the Curry or Mercury languages may be better than Prolog at times with their functional logic programming features. Ultimately it&#x27;s best if the LLM has the freedom to decide what&#x27;s best to use for the problem from what it knows.</div><br/></div></div><div id="41875551" class="c"><input type="checkbox" id="c-41875551" checked=""/><div class="controls bullet"><span class="by">mountainriver</span><span>|</span><a href="#41874200">parent</a><span>|</span><a href="#41876345">prev</a><span>|</span><a href="#41877053">next</a><span>|</span><label class="collapse" for="c-41875551">[-]</label><label class="expand" for="c-41875551">[1 more]</label></div><br/><div class="children"><div class="content">Agree, reasoning has to come from within the model. These are hacks that only work in specific use cases</div><br/></div></div></div></div><div id="41877053" class="c"><input type="checkbox" id="c-41877053" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#41874200">prev</a><span>|</span><a href="#41874133">next</a><span>|</span><label class="collapse" for="c-41877053">[-]</label><label class="expand" for="c-41877053">[1 more]</label></div><br/><div class="children"><div class="content">I implemented Prolog <i>and</i> Z3 as a function tool for my little OpenAI Assistants API client.  Z3 (SMT-LIB, actually) seemed even more promising.  The model speaks both languages.  However, I didn&#x27;t find any convincing use-cases yet.  But it seems a logical extension of the idea to provide a programming language via a function tool to solve problems.  So you start thinking &quot;What else has text input and output, and a powerful engine in between?&quot;</div><br/></div></div><div id="41874133" class="c"><input type="checkbox" id="c-41874133" checked=""/><div class="controls bullet"><span class="by">mise_en_place</span><span>|</span><a href="#41877053">prev</a><span>|</span><a href="#41873915">next</a><span>|</span><label class="collapse" for="c-41874133">[-]</label><label class="expand" for="c-41874133">[1 more]</label></div><br/><div class="children"><div class="content">I really enjoyed tinkering with languages like Prolog and Coq. Interactive theorem proving with LLMs would be awesome to try out, if possible.</div><br/></div></div><div id="41873915" class="c"><input type="checkbox" id="c-41873915" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41874133">prev</a><span>|</span><label class="collapse" for="c-41873915">[-]</label><label class="expand" for="c-41873915">[1 more]</label></div><br/><div class="children"><div class="content">Use Constraint Satisfaction Problem Solvers. It commes up with Common Lisp with ease.</div><br/></div></div></div></div></div></div></div></body></html>