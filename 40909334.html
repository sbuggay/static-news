<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720515672650" as="style"/><link rel="stylesheet" href="styles.css?v=1720515672650"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://deadlockempire.github.io">The Deadlock Empire: An Interactive Guide to Locks</a>Â <span class="domain">(<a href="https://deadlockempire.github.io">deadlockempire.github.io</a>)</span></div><div class="subtext"><span>neonsunset</span> | <span>19 comments</span></div><br/><div><div id="40913691" class="c"><input type="checkbox" id="c-40913691" checked=""/><div class="controls bullet"><span class="by">lordnacho</span><span>|</span><a href="#40911874">next</a><span>|</span><label class="collapse" for="c-40913691">[-]</label><label class="expand" for="c-40913691">[1 more]</label></div><br/><div class="children"><div class="content">This thing is great. The deeper lesson seems to be not to try any of these things in any kind of complicated program, you will fuck it up.<p>Imagine writing something with dozens of threads, each running different programs with various threading primitives sprinkled around. You would never be able to debug it, because just conjuring each case of &quot;if this thread gets to here and that thread gets to there&quot; in a test would be impossible.<p>If you&#x27;re going to use these, keep it simple.<p>What I really prefer is not to share the state at all, just have something like a ring buffer between threads that pass messages to each other. Each thread just sits there and takes things from its input buffers and puts things onto the message queues of other threads. The ring buffer itself uses atomics, or is well tested to ensure none of these weird locking scenarios happen. This way all your thinking is just single threaded, and if there&#x27;s a sync issue you know where to find it.</div><br/></div></div><div id="40911874" class="c"><input type="checkbox" id="c-40911874" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#40913691">prev</a><span>|</span><a href="#40912066">next</a><span>|</span><label class="collapse" for="c-40911874">[-]</label><label class="expand" for="c-40911874">[8 more]</label></div><br/><div class="children"><div class="content">My main takeaway from this <i>excellent</i> guide is that I suck at multithreaded reasoning and should stick to single threaded languages.<p>There go my dreams of being a C-slinging kernel ninja master.</div><br/><div id="40912512" class="c"><input type="checkbox" id="c-40912512" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40911874">parent</a><span>|</span><a href="#40912131">next</a><span>|</span><label class="collapse" for="c-40912512">[-]</label><label class="expand" for="c-40912512">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll give you one tip that covers a large portion of deadlocks I&#x27;ve seen in my career.<p>A lock should be used to lock a data structure, that&#x27;s it. Corollary: Never hold a lock while calling a function.<p>Most common deadlocking scenario is people taking a lock, calling a function, that they don&#x27;t know takes a different lock. If you can&#x27;t get by just taking a lock, touching some data structure (lightly), and releasing the lock then you need to look at your data structures.</div><br/></div></div><div id="40912131" class="c"><input type="checkbox" id="c-40912131" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40911874">parent</a><span>|</span><a href="#40912512">prev</a><span>|</span><a href="#40912872">next</a><span>|</span><label class="collapse" for="c-40912131">[-]</label><label class="expand" for="c-40912131">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that bad. It&#x27;s helpful to understand what&#x27;s happening down at the instruction, memory access, and fence level, but most code just uses some kind of scoped mutex. You don&#x27;t often have to think all this through.<p>The big win in Rust is that the mutexes are tied to the data they protect. The compiler won&#x27;t let you access data until it&#x27;s locked. You can still deadlock, though.</div><br/><div id="40913239" class="c"><input type="checkbox" id="c-40913239" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40911874">root</a><span>|</span><a href="#40912131">parent</a><span>|</span><a href="#40912872">next</a><span>|</span><label class="collapse" for="c-40913239">[-]</label><label class="expand" for="c-40913239">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The big win in Rust is that the mutexes are tied to the data they protect. The compiler won&#x27;t let you access data until it&#x27;s locked.<p>You can get this kind of behavior in C++ with, e.g., folly::Synchronized&lt;T&gt;.</div><br/><div id="40913589" class="c"><input type="checkbox" id="c-40913589" checked=""/><div class="controls bullet"><span class="by">4gotunameagain</span><span>|</span><a href="#40911874">root</a><span>|</span><a href="#40913239">parent</a><span>|</span><a href="#40912872">next</a><span>|</span><label class="collapse" for="c-40913589">[-]</label><label class="expand" for="c-40913589">[1 more]</label></div><br/><div class="children"><div class="content">I will play the devil&#x27;s advocate and say: You can get <i>any</i> behaviour in C++, but there are so many options almost nobody is using them, or using them the right way.<p>And this is coming from someone that has written a lot of C++ and no Rust at all..</div><br/></div></div></div></div></div></div><div id="40912872" class="c"><input type="checkbox" id="c-40912872" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40911874">parent</a><span>|</span><a href="#40912131">prev</a><span>|</span><a href="#40912289">next</a><span>|</span><label class="collapse" for="c-40912872">[-]</label><label class="expand" for="c-40912872">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s essentially three levels of reasoning about multithreaded code.<p>The lowest level is understanding things on the hardware memory model level--knowing how atomic operations work, and being able to build primitives based on these atomics. And quite frankly, there be real dragons here (weak memory models are mind-bending), but--like assembly programming--it&#x27;s not really necessary to resort to this level unless you really need to care about the performance, and the first rule of performance engineering applies [1].<p>The second level is the level of the standard multithreaded primitives: mutexes, condition variables, semaphores, barriers, etc. This level is important to learn because it&#x27;s generally the level of principles of how things work that matters most. But it&#x27;s kind of like a BASIC programming language: it&#x27;s certainly possible to write in it, but at scale, you get fatigue trying to keep all of the details straight, and it&#x27;s rapidly apparent that there are lots of common patterns that could be handled more simply.<p>The highest level of understanding is recognizing that there are a few basic common patterns of multithreading, and if you can just resort to appropriate libraries for those patterns, you generally don&#x27;t have to worry about the details at all. Chief among these is embarrassingly-parallel code, stuff that generally works with a fork-join model, or generally any sort of pattern that&#x27;s &quot;for each element in a large set&quot;, where the work to be done involves no shared mutable state.<p>Speaking of which, the most important thing to take away from any multithreaded programming is this: shared mutable state is inherently problematic. If you can avoid having any shared mutable state, that is ideal. The next-best option is to move all of the shared mutable state into a library that someone more competent than you has written (e.g., a database).<p>[1] Don&#x27;t optimize until you&#x27;ve measured to be sure you know what you need to optimize.</div><br/></div></div><div id="40912289" class="c"><input type="checkbox" id="c-40912289" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40911874">parent</a><span>|</span><a href="#40912872">prev</a><span>|</span><a href="#40912486">next</a><span>|</span><label class="collapse" for="c-40912289">[-]</label><label class="expand" for="c-40912289">[1 more]</label></div><br/><div class="children"><div class="content">You might find Curt Schimmel&#x27;s <i>UNIX Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers</i> useful.</div><br/></div></div><div id="40912486" class="c"><input type="checkbox" id="c-40912486" checked=""/><div class="controls bullet"><span class="by">Emjayen</span><span>|</span><a href="#40911874">parent</a><span>|</span><a href="#40912289">prev</a><span>|</span><a href="#40912066">next</a><span>|</span><label class="collapse" for="c-40912486">[-]</label><label class="expand" for="c-40912486">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s any consolation: the vast, <i>vast</i> majority programmers should stick to single-threaded design, as is evident from all the atrocious multithreaded software out there of which 99% of the time would be faster without multiple threads (and surely far less complex)<p>Unless you know what you&#x27;re doing, just pick the real low-hanging fruit, like throwing some threads at file block decompression.</div><br/></div></div></div></div><div id="40912066" class="c"><input type="checkbox" id="c-40912066" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40911874">prev</a><span>|</span><a href="#40913048">next</a><span>|</span><label class="collapse" for="c-40912066">[-]</label><label class="expand" for="c-40912066">[2 more]</label></div><br/><div class="children"><div class="content">Oh, that&#x27;s just precious.<p>It stops before the problems of lock congestion, infinite overtaking, and priority inversion, though.</div><br/><div id="40912540" class="c"><input type="checkbox" id="c-40912540" checked=""/><div class="controls bullet"><span class="by">gpuhacker</span><span>|</span><a href="#40912066">parent</a><span>|</span><a href="#40913048">next</a><span>|</span><label class="collapse" for="c-40912540">[-]</label><label class="expand" for="c-40912540">[1 more]</label></div><br/><div class="children"><div class="content">It also assumes all reads and writes are volatile. In the real world, threads can witness out-of-order execution in different threads.</div><br/></div></div></div></div><div id="40912366" class="c"><input type="checkbox" id="c-40912366" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#40913250">prev</a><span>|</span><label class="collapse" for="c-40912366">[-]</label><label class="expand" for="c-40912366">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s missing my favourite optimistic lock, the Delusional Lock.</div><br/><div id="40912868" class="c"><input type="checkbox" id="c-40912868" checked=""/><div class="controls bullet"><span class="by">dekibre</span><span>|</span><a href="#40912366">parent</a><span>|</span><a href="#40912929">next</a><span>|</span><label class="collapse" for="c-40912868">[-]</label><label class="expand" for="c-40912868">[1 more]</label></div><br/><div class="children"><div class="content">You can submit a feedback! <a href="https:&#x2F;&#x2F;docs.google.com&#x2F;forms&#x2F;d&#x2F;e&#x2F;1FAIpQLSf7XQBKbpjtOqzFi0jBTF6Fh2LQ84RmWqsxPqngoA6BPCksIQ&#x2F;viewform?c=0&amp;w=1" rel="nofollow">https:&#x2F;&#x2F;docs.google.com&#x2F;forms&#x2F;d&#x2F;e&#x2F;1FAIpQLSf7XQBKbpjtOqzFi0jB...</a></div><br/></div></div><div id="40912929" class="c"><input type="checkbox" id="c-40912929" checked=""/><div class="controls bullet"><span class="by">lock_enthusiast</span><span>|</span><a href="#40912366">parent</a><span>|</span><a href="#40912868">prev</a><span>|</span><label class="collapse" for="c-40912929">[-]</label><label class="expand" for="c-40912929">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m assuming it&#x27;s the &quot;I&#x27;m sure it&#x27;ll be fine to read&#x2F;write this unsynchronized, what&#x27;s the worst that could happen?&quot; locking strategy.</div><br/><div id="40913168" class="c"><input type="checkbox" id="c-40913168" checked=""/><div class="controls bullet"><span class="by">SeriousM</span><span>|</span><a href="#40912366">root</a><span>|</span><a href="#40912929">parent</a><span>|</span><label class="collapse" for="c-40913168">[-]</label><label class="expand" for="c-40913168">[2 more]</label></div><br/><div class="children"><div class="content">That just sounds like the &quot;read uncommitted&quot; transaction level.
Works as long as you know what to do :)</div><br/><div id="40913386" class="c"><input type="checkbox" id="c-40913386" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#40912366">root</a><span>|</span><a href="#40913168">parent</a><span>|</span><label class="collapse" for="c-40913386">[-]</label><label class="expand" for="c-40913386">[1 more]</label></div><br/><div class="children"><div class="content">Is that like accidentally pure functions?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>