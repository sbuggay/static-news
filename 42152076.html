<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731747659969" as="style"/><link rel="stylesheet" href="styles.css?v=1731747659969"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://labs.quansight.org/blog/dataframe-group-by">Non-elementary group-by aggregations in Polars vs pandas</a> <span class="domain">(<a href="https://labs.quansight.org">labs.quansight.org</a>)</span></div><div class="subtext"><span>rbanffy</span> | <span>64 comments</span></div><br/><div><div id="42152558" class="c"><input type="checkbox" id="c-42152558" checked=""/><div class="controls bullet"><span class="by">Nihilartikel</span><span>|</span><a href="#42155262">next</a><span>|</span><label class="collapse" for="c-42152558">[-]</label><label class="expand" for="c-42152558">[10 more]</label></div><br/><div class="children"><div class="content">I did non trivial work with apache spark dataframes and came to appreciate them before ever being exposed to Pandas. After spark, pandas just seemed frustrating and incomprehensible. Polars is much more like spark and I am very happy about that.<p>DuckDb even goes so far as to include a clone of the pyspark dataframe API, so somebody there must like it too.</div><br/><div id="42152963" class="c"><input type="checkbox" id="c-42152963" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#42152558">parent</a><span>|</span><a href="#42154570">next</a><span>|</span><label class="collapse" for="c-42152963">[-]</label><label class="expand" for="c-42152963">[3 more]</label></div><br/><div class="children"><div class="content">I had a similar experience with spark, especially in the Scala API it felt very expressive and concise once I got used to certain idioms.  Also +1 on duckdb which is excellent.<p>There are some frustrations in spark however, I remember getting stuck on Winsorizing over groups. Hilariously there are identical functions called `percentile_approx` and `approx_percentile` and it wasn&#x27;t clear from the docs they were the same or at least did the same thing.<p>Given all that, the ergonomics of Julia for general purpose data handling is really unmatched IMO. I&#x27;ve got a lot of clean and readable data pipeline and shaping code that I revisited a couple years later and could easily understand. And making updates with new more type-generic functions is a breeze. Very enjoyable.</div><br/><div id="42153323" class="c"><input type="checkbox" id="c-42153323" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#42152558">root</a><span>|</span><a href="#42152963">parent</a><span>|</span><a href="#42154570">next</a><span>|</span><label class="collapse" for="c-42153323">[-]</label><label class="expand" for="c-42153323">[2 more]</label></div><br/><div class="children"><div class="content">Spark docs are way too minimal for my taste, at least the API docs.</div><br/><div id="42153822" class="c"><input type="checkbox" id="c-42153822" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#42152558">root</a><span>|</span><a href="#42153323">parent</a><span>|</span><a href="#42154570">next</a><span>|</span><label class="collapse" for="c-42153822">[-]</label><label class="expand" for="c-42153822">[1 more]</label></div><br/><div class="children"><div class="content">yeah i couldnt get it done in spark api had to combine spark and spark sql bc the window function i needed was (probably) not available in spark. it was inelegant i thought.</div><br/></div></div></div></div></div></div><div id="42154570" class="c"><input type="checkbox" id="c-42154570" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#42152558">parent</a><span>|</span><a href="#42152963">prev</a><span>|</span><a href="#42153286">next</a><span>|</span><label class="collapse" for="c-42154570">[-]</label><label class="expand" for="c-42154570">[3 more]</label></div><br/><div class="children"><div class="content">I have not worked with Spark, but I have used Athena&#x2F;Trino and BigQuery extensively.<p>For me I don&#x27;t really understand the hype around Polars, other than that it fixes some annoying issues with the Pandas API by sacrificing backwards compatibility.<p>With a single node engine you have a ceiling how good it can get.<p>With Spark&#x2F;Athena&#x2F;BigQuery the sky is the limit. It is such a freedom to not be limited by available RAM or CPU. They just scale to what they need. Some queryies squeeze in CPU-days in just a few minutes.</div><br/><div id="42155217" class="c"><input type="checkbox" id="c-42155217" checked=""/><div class="controls bullet"><span class="by">simicd</span><span>|</span><a href="#42152558">root</a><span>|</span><a href="#42154570">parent</a><span>|</span><a href="#42155313">next</a><span>|</span><label class="collapse" for="c-42155217">[-]</label><label class="expand" for="c-42155217">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using both Spark and polars, to me the appeal of polars is additionally it is also much faster and easier to set up.<p>Spark is great if you have large datasets since you can easily scale as you said. But if the dataset is small-ish (&lt;50 million rows) you hit a lower bound in Spark in terms of how fast the job can run. Even if the job is super simple it take 1-2 minutes. Polars on the other hand is almost instantaneous (&lt; 1 second). Doesn&#x27;t sound like much but to me makes a huge difference when iterating on solutions.</div><br/></div></div><div id="42155313" class="c"><input type="checkbox" id="c-42155313" checked=""/><div class="controls bullet"><span class="by">fastasucan</span><span>|</span><a href="#42152558">root</a><span>|</span><a href="#42154570">parent</a><span>|</span><a href="#42155217">prev</a><span>|</span><a href="#42153286">next</a><span>|</span><label class="collapse" for="c-42155313">[-]</label><label class="expand" for="c-42155313">[1 more]</label></div><br/><div class="children"><div class="content">&gt;With a single node engine you have a ceiling how good it can get.<p>Well, you are a lot closer to that with Polars than with Pandas at least.</div><br/></div></div></div></div><div id="42154526" class="c"><input type="checkbox" id="c-42154526" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#42152558">parent</a><span>|</span><a href="#42153286">prev</a><span>|</span><a href="#42153238">next</a><span>|</span><label class="collapse" for="c-42154526">[-]</label><label class="expand" for="c-42154526">[1 more]</label></div><br/><div class="children"><div class="content">I thought the same thing about Spark, coming from R and later Pandas.</div><br/></div></div><div id="42153238" class="c"><input type="checkbox" id="c-42153238" checked=""/><div class="controls bullet"><span class="by">coding123</span><span>|</span><a href="#42152558">parent</a><span>|</span><a href="#42154526">prev</a><span>|</span><a href="#42155262">next</a><span>|</span><label class="collapse" for="c-42153238">[-]</label><label class="expand" for="c-42153238">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how well the polars implementation works, but what I love about PySpark is that sometimes spark is able to push those groupings down to the database. Not always, but sometimes. However I imagine that many people love polars&#x2F;pandas performance for transactional queries (from start to finish get me a result in less than a second (as long as the number of underlying rows is not greater than 20k-ish). Pyspark will never be super great for that.</div><br/></div></div></div></div><div id="42155262" class="c"><input type="checkbox" id="c-42155262" checked=""/><div class="controls bullet"><span class="by">combocosmo</span><span>|</span><a href="#42152558">prev</a><span>|</span><a href="#42152477">next</a><span>|</span><label class="collapse" for="c-42155262">[-]</label><label class="expand" for="c-42155262">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always liked scatter solutions for these kind of problems:<p><pre><code>  import numpy as np
  
  def scatter_mean(index, value):
      sums = np.zeros(max(index)+1)
      counts = np.zeros(max(index)+1)
      for i in range(len(index)):
          j = index[i]
          sums[j] += value[i]
          counts[j] += 1
      return sums &#x2F; counts
  
  def scatter_max(index, value):
      maxs = -np.inf * np.ones(max(index)+1)
      for i in range(len(index)):
          j = index[i]
          maxs[j] = max(maxs[j], value[i])
      return maxs
  
  def scatter_count(index):
      counts = np.zeros(max(index)+1, dtype=np.int32)
      for i in range(len(index)):
          counts[index[i]] += 1
      return counts
  
  id = np.array([1, 1, 1, 2, 2, 2]) - 1
  sales = np.array([4, 1, 2, 7, 6, 7])
  views = np.array([3, 1, 2, 8, 6, 7])
  means = scatter_mean(id, sales).repeat(scatter_count(id))
  print(views[sales &gt; means].max())
</code></pre>
Obviously you&#x27;d need good implementations of the scatter operations, not these naive python for-loops. But once you have them the solution is a pretty readable two-liner.</div><br/></div></div><div id="42152477" class="c"><input type="checkbox" id="c-42152477" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42155262">prev</a><span>|</span><a href="#42155185">next</a><span>|</span><label class="collapse" for="c-42152477">[-]</label><label class="expand" for="c-42152477">[5 more]</label></div><br/><div class="children"><div class="content">Pandas sat alone in the Python ecosphere for a long time. Lack of competition is generally not a good thing. I&#x27;m thrilled to have Polars around to innovate on the API end (and push Pandas to be better).<p>And I say this as someone who makes much of their living from Pandas.</div><br/><div id="42152577" class="c"><input type="checkbox" id="c-42152577" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#42152477">parent</a><span>|</span><a href="#42155185">next</a><span>|</span><label class="collapse" for="c-42152577">[-]</label><label class="expand" for="c-42152577">[4 more]</label></div><br/><div class="children"><div class="content">I think pandas is well aware of some of the unfortunate legacy API decisions without Polars. They are trapped by backwards compatibility. Wes’ “Things I Hate About Pandas” post covers the highlights. Most of which boils down to having not put a layer between numpy and pandas. Which is why they were stuck with the unfortunate integer null situation.</div><br/><div id="42153124" class="c"><input type="checkbox" id="c-42153124" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#42152477">root</a><span>|</span><a href="#42152577">parent</a><span>|</span><a href="#42153821">next</a><span>|</span><label class="collapse" for="c-42153124">[-]</label><label class="expand" for="c-42153124">[2 more]</label></div><br/><div class="children"><div class="content">Which is all stuff they could fix, if they&#x27;d be willing to, with a major version bump. They&#x27;d need a killer feature to encourage that migration though.</div><br/><div id="42153214" class="c"><input type="checkbox" id="c-42153214" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#42152477">root</a><span>|</span><a href="#42153124">parent</a><span>|</span><a href="#42153821">next</a><span>|</span><label class="collapse" for="c-42153214">[-]</label><label class="expand" for="c-42153214">[1 more]</label></div><br/><div class="children"><div class="content">The really brutal thing is all of the code using Pandas written by researchers and non-software engineers running quietly in lab environments. Difficult to reproduce environments, small or non-existent test suites, code written by grad students long gone. If the Pandas interface breaks for installs done via `pip install pandas` it will cause a lot of pain.<p>With that acknowledged, it&#x27;ll make life a lot easier on everyone if the &quot;fix the API&quot; Pandas 3 had a different package name. Polars and others seem like exactly that solution, even if not literally Pandas.</div><br/></div></div></div></div><div id="42153821" class="c"><input type="checkbox" id="c-42153821" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42152477">root</a><span>|</span><a href="#42152577">parent</a><span>|</span><a href="#42153124">prev</a><span>|</span><a href="#42155185">next</a><span>|</span><label class="collapse" for="c-42153821">[-]</label><label class="expand" for="c-42153821">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the interesting thing is that pandas developers are moving towards adopting polars-like advances now. Which wasn&#x27;t the case previously.</div><br/></div></div></div></div></div></div><div id="42155185" class="c"><input type="checkbox" id="c-42155185" checked=""/><div class="controls bullet"><span class="by">wismwasm</span><span>|</span><a href="#42152477">prev</a><span>|</span><a href="#42152870">next</a><span>|</span><label class="collapse" for="c-42155185">[-]</label><label class="expand" for="c-42155185">[1 more]</label></div><br/><div class="children"><div class="content">I’m just using Ibis: <a href="https:&#x2F;&#x2F;ibis-project.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ibis-project.org&#x2F;</a>
They provide a nice backend agnostic API. For most backends it will just compile to SQL and act as a query builder. SQL basically has solved the problem of providing a declarative data transformation syntax, why reinvent the wheel?</div><br/></div></div><div id="42152870" class="c"><input type="checkbox" id="c-42152870" checked=""/><div class="controls bullet"><span class="by">lend000</span><span>|</span><a href="#42155185">prev</a><span>|</span><a href="#42152387">next</a><span>|</span><label class="collapse" for="c-42152870">[-]</label><label class="expand" for="c-42152870">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve wanted to convert a massive Pandas codebase to Polars for a long time. Probably 90% of the compute time is Pandas operations, especially creating new columns &#x2F; resizing dataframes (which I understand to involve less of a speed difference compared to the grouping operations mentioned in the post, but still substantial). Anyone had success doing this and found it to be worth the effort?</div><br/><div id="42153781" class="c"><input type="checkbox" id="c-42153781" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42152870">parent</a><span>|</span><a href="#42152966">next</a><span>|</span><label class="collapse" for="c-42153781">[-]</label><label class="expand" for="c-42153781">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on what you are doing.<p>My book, Effective Polars, has a whole chapter devoted to the question of whether porting from pandas makes sense.</div><br/></div></div><div id="42152966" class="c"><input type="checkbox" id="c-42152966" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#42152870">parent</a><span>|</span><a href="#42153781">prev</a><span>|</span><a href="#42154882">next</a><span>|</span><label class="collapse" for="c-42152966">[-]</label><label class="expand" for="c-42152966">[6 more]</label></div><br/><div class="children"><div class="content">I converted to DuckDB and Polars. It’s worth it for the speed improvement.<p>However there are subtle differences between Pandas and Polars behaviors so regression testing is your friend. It’s not 1:1 mapping.</div><br/><div id="42153200" class="c"><input type="checkbox" id="c-42153200" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#42152870">root</a><span>|</span><a href="#42152966">parent</a><span>|</span><a href="#42153140">next</a><span>|</span><label class="collapse" for="c-42153200">[-]</label><label class="expand" for="c-42153200">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s been so many subtle changes in pandas to pandas upgrades (especially groupby is somehow always hit), so regression tests are always needed...</div><br/></div></div><div id="42153140" class="c"><input type="checkbox" id="c-42153140" checked=""/><div class="controls bullet"><span class="by">willseth</span><span>|</span><a href="#42152870">root</a><span>|</span><a href="#42152966">parent</a><span>|</span><a href="#42153200">prev</a><span>|</span><a href="#42154882">next</a><span>|</span><label class="collapse" for="c-42153140">[-]</label><label class="expand" for="c-42153140">[4 more]</label></div><br/><div class="children"><div class="content">Which things did you decide to move to duckdb?</div><br/><div id="42153476" class="c"><input type="checkbox" id="c-42153476" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#42152870">root</a><span>|</span><a href="#42153140">parent</a><span>|</span><a href="#42154882">next</a><span>|</span><label class="collapse" for="c-42153476">[-]</label><label class="expand" for="c-42153476">[3 more]</label></div><br/><div class="children"><div class="content">A lot of aggregation, pivot and join logic, like:<p><pre><code>    df = duckdb.query(&quot;from tbl1 join tbl2 using (id) where id is not null &quot;).pl()
</code></pre>
The .pl() is a Arrow-based conversation from DuckDB to Polars. It&#x27;s in-memory and I believe zero-copy, so it happens almost instantaneously.<p>I go back and forth between DuckDB and Polars functions in the same scope because it&#x27;s so cheap to convert between the two.</div><br/><div id="42153792" class="c"><input type="checkbox" id="c-42153792" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42152870">root</a><span>|</span><a href="#42153476">parent</a><span>|</span><a href="#42154882">next</a><span>|</span><label class="collapse" for="c-42153792">[-]</label><label class="expand" for="c-42153792">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m genuinely curious, if you are already using (and assuming that you like) dataframe APIs, why you would use SQL?</div><br/><div id="42154326" class="c"><input type="checkbox" id="c-42154326" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#42152870">root</a><span>|</span><a href="#42153792">parent</a><span>|</span><a href="#42154882">next</a><span>|</span><label class="collapse" for="c-42154326">[-]</label><label class="expand" for="c-42154326">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the opposite; I prefer DuckDB and generally work with DuckDB&#x27;s friendly SQL interface. SQL is declarative and is (for me) more intuitive than method-chaining -- especially for complex analytic operations that happen in one go.<p>(software people might beg to differ about the intuitive bit because they are more used to an imperative style, and to my surprise, even the best software engineers struggle with SQL because it requires one to think in set and relation operations rather than function calls, which many software folks are not used to)<p>I actually don&#x27;t use the Polars dataframe APIs much except for some operations which are easier to do in dataframe form, like applying a Python function as UDF, or transposing (not pivoting) a dataframe.<p>Also Polars is good for materializing the query into a dataframe rapidly, which can then be passed into methods&#x2F;functions. It&#x27;s also a lot easier to unit test dataframes than SQL tables. There&#x27;s a lot more tooling for that.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42154882" class="c"><input type="checkbox" id="c-42154882" checked=""/><div class="controls bullet"><span class="by">salomonk_mur</span><span>|</span><a href="#42152870">parent</a><span>|</span><a href="#42152966">prev</a><span>|</span><a href="#42152387">next</a><span>|</span><label class="collapse" for="c-42154882">[-]</label><label class="expand" for="c-42154882">[2 more]</label></div><br/><div class="children"><div class="content">This is a prime use case for LLMs</div><br/><div id="42155138" class="c"><input type="checkbox" id="c-42155138" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42152870">root</a><span>|</span><a href="#42154882">parent</a><span>|</span><a href="#42152387">next</a><span>|</span><label class="collapse" for="c-42155138">[-]</label><label class="expand" for="c-42155138">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, just let the LLM refactor your numeric methods, #yolo.<p>What could go wrong?</div><br/></div></div></div></div></div></div><div id="42152387" class="c"><input type="checkbox" id="c-42152387" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#42152870">prev</a><span>|</span><a href="#42155169">next</a><span>|</span><label class="collapse" for="c-42152387">[-]</label><label class="expand" for="c-42152387">[11 more]</label></div><br/><div class="children"><div class="content">The difference is a sanely and presciently designed expression API, which is a bit more verbose in some common cases, but is more predictable and much more expressive in more complex situations like this.<p>On a tangent, i wonder what this op would look like in SQL? Probably would need support for filtering in a window function, which I&#x27;m not sure is standardized?</div><br/><div id="42152954" class="c"><input type="checkbox" id="c-42152954" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#42152387">parent</a><span>|</span><a href="#42153344">next</a><span>|</span><label class="collapse" for="c-42152954">[-]</label><label class="expand" for="c-42152954">[4 more]</label></div><br/><div class="children"><div class="content">Props to Ritchie Vink for designing polars.<p>But also props to Wes McKinney for giving us a dataframe library during a time when we had none. Java still doesn’t have a decent dataframe library so we mustn’t take these things for granted.<p>The Pandas API is no longer the way things should be done today nor should it be in new tutorials. Pandas was the jquery of its time —- great but no longer the state of the art. But I have much gratitude for it being around when it was needed.</div><br/><div id="42154505" class="c"><input type="checkbox" id="c-42154505" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#42152387">root</a><span>|</span><a href="#42152954">parent</a><span>|</span><a href="#42153787">next</a><span>|</span><label class="collapse" for="c-42154505">[-]</label><label class="expand" for="c-42154505">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s worth giving some credit to prior art here. Polars was heavily inspired by the &quot;Spark SQL&quot; API, and Pandas by R data frames.<p>I disagree that Pandas is no longer state of the art: its interface is optimized for a different use case compared to Polars.</div><br/><div id="42155062" class="c"><input type="checkbox" id="c-42155062" checked=""/><div class="controls bullet"><span class="by">disgruntledphd2</span><span>|</span><a href="#42152387">root</a><span>|</span><a href="#42154505">parent</a><span>|</span><a href="#42153787">next</a><span>|</span><label class="collapse" for="c-42155062">[-]</label><label class="expand" for="c-42155062">[1 more]</label></div><br/><div class="children"><div class="content">I think a lot of the weirdness in pandas comes from firstly the original focus on time series, and secondly the attempt to make logical indexing work like it did in R.<p>I&#x27;m not a big fan of the pandas API but it&#x27;s a super useful tool nonetheless.</div><br/></div></div></div></div><div id="42153787" class="c"><input type="checkbox" id="c-42153787" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#42152387">root</a><span>|</span><a href="#42152954">parent</a><span>|</span><a href="#42154505">prev</a><span>|</span><a href="#42153344">next</a><span>|</span><label class="collapse" for="c-42153787">[-]</label><label class="expand" for="c-42153787">[1 more]</label></div><br/><div class="children"><div class="content">Well said.</div><br/></div></div></div></div><div id="42153344" class="c"><input type="checkbox" id="c-42153344" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#42152387">parent</a><span>|</span><a href="#42152954">prev</a><span>|</span><a href="#42154947">next</a><span>|</span><label class="collapse" for="c-42153344">[-]</label><label class="expand" for="c-42153344">[1 more]</label></div><br/><div class="children"><div class="content">Without having checked, maybe something like:<p><pre><code>  select id, max(views) from &lt;tbl&gt;
  where sales &gt; avg(sales) over (partition by id) group by 1
</code></pre>
In dplyr, there is an ‘old style’ method which works on an intermediate ‘grouped data frame’ and a new style which doesn’t. In the old style:<p><pre><code>  df |&gt; group_by(id) |&gt;
    filter(sales &gt; mean(sales)) |&gt;
    summarize(max(views))
</code></pre>
In the new style, either:<p><pre><code>  df |&gt; filter(.by=id, sales&gt;mean(sales)) |&gt; summarize(.by=id,max(views))
</code></pre>
Or:<p><pre><code>  df |&gt; summarize(.by=id, max(views[sales&gt;mean(sales)]))</code></pre></div><br/></div></div><div id="42154947" class="c"><input type="checkbox" id="c-42154947" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#42152387">parent</a><span>|</span><a href="#42153344">prev</a><span>|</span><a href="#42152617">next</a><span>|</span><label class="collapse" for="c-42154947">[-]</label><label class="expand" for="c-42154947">[1 more]</label></div><br/><div class="children"><div class="content">If I understand what you mean, it&#x27;s supported everywhere that has windowing at all afaik.<p>If you mean filtering the rows in the window, you can do &#x27;sum(case when condition then value else null end) over (window)&#x27;; if you mean selecting rows based on the value of a window function you use &#x27;qualify&#x27; where supported or a trivial subquery or CTE and &#x27;where&#x27; (which qualify is just shorthand for)</div><br/></div></div><div id="42152617" class="c"><input type="checkbox" id="c-42152617" checked=""/><div class="controls bullet"><span class="by">andy81</span><span>|</span><a href="#42152387">parent</a><span>|</span><a href="#42154947">prev</a><span>|</span><a href="#42152629">next</a><span>|</span><label class="collapse" for="c-42152617">[-]</label><label class="expand" for="c-42152617">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an example implementation in MSSQL - <a href="https:&#x2F;&#x2F;data.stackexchange.com&#x2F;stackoverflow&#x2F;query&#x2F;edit&#x2F;1873356" rel="nofollow">https:&#x2F;&#x2F;data.stackexchange.com&#x2F;stackoverflow&#x2F;query&#x2F;edit&#x2F;1873...</a><p>No need to filter within the window function if you use subquery or CTE, which is supported everywhere.</div><br/></div></div><div id="42152629" class="c"><input type="checkbox" id="c-42152629" checked=""/><div class="controls bullet"><span class="by">capitainenemo</span><span>|</span><a href="#42152387">parent</a><span>|</span><a href="#42152617">prev</a><span>|</span><a href="#42152630">next</a><span>|</span><label class="collapse" for="c-42152629">[-]</label><label class="expand" for="c-42152629">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SQL?useskin=vector#Standardization_history" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SQL?useskin=vector#Standardiza...</a><p>According to wikipedia, windowing was standardized back in 2003.</div><br/></div></div><div id="42152630" class="c"><input type="checkbox" id="c-42152630" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#42152387">parent</a><span>|</span><a href="#42152629">prev</a><span>|</span><a href="#42155169">next</a><span>|</span><label class="collapse" for="c-42152630">[-]</label><label class="expand" for="c-42152630">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  -- &quot;find the maximum value of &#x27;views&#x27;,
  -- where &#x27;sales&#x27; is greater than its mean, per &#x27;id&#x27;&quot;.

  select max(views), id  -- &quot;find the maximum value of   &#x27;views&#x27;,
  from example_table as et 
  where exists 
  (
    SELECT *
      FROM 
    ( 
      SELECT id, avg(sales) as mean_sales 
      FROM example_table
      GROUP by id 
    ) as f --  
    where et.sales  &gt; f.mean_sales -- where &#x27;sales&#x27; is greater than its mean
    and et.id = f.id 
  )
  group by id; -- per &#x27;id&#x27;&quot;.</code></pre></div><br/></div></div></div></div><div id="42153360" class="c"><input type="checkbox" id="c-42153360" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#42155169">prev</a><span>|</span><a href="#42153812">next</a><span>|</span><label class="collapse" for="c-42153360">[-]</label><label class="expand" for="c-42153360">[1 more]</label></div><br/><div class="children"><div class="content">The power of having an API that allows usage of the Free monad.  
And in less-funny-FP-speak, the power of allowing the user write a program (expressions), that the sufficiently-smart backend later compiles&#x2F;interprets.<p>Awesome! Didn&#x27;t expect such a vast difference in usability at first.</div><br/></div></div><div id="42153812" class="c"><input type="checkbox" id="c-42153812" checked=""/><div class="controls bullet"><span class="by">Larrikin</span><span>|</span><a href="#42153360">prev</a><span>|</span><a href="#42153478">next</a><span>|</span><label class="collapse" for="c-42153812">[-]</label><label class="expand" for="c-42153812">[4 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m doing some data science just for fun and personal projects, is there any reason to not go with Polars?<p>I took some data science classes in grad school, but basically haven&#x27;t had any reason to touch pandas since I graduated. But, did like the ecosystem of tools, learning materials, and other libraries surrounding it when I was working with it. I recently just started a new project and am quickly going through my old notes to refamiliarize myself with pandas, but maybe I should just go and learn Polars?</div><br/><div id="42154514" class="c"><input type="checkbox" id="c-42154514" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#42153812">parent</a><span>|</span><a href="#42153845">next</a><span>|</span><label class="collapse" for="c-42154514">[-]</label><label class="expand" for="c-42154514">[1 more]</label></div><br/><div class="children"><div class="content">Pandas can be easier for interactive poking around on smaller data sets. It feels more like Excel, whereas Polars feels more like SQL. It&#x27;s no surprise that on a forum full of programmers Polars is widely preferred, but IMO it&#x27;s worth at least trying both.</div><br/></div></div><div id="42153845" class="c"><input type="checkbox" id="c-42153845" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#42153812">parent</a><span>|</span><a href="#42154514">prev</a><span>|</span><a href="#42153883">next</a><span>|</span><label class="collapse" for="c-42153845">[-]</label><label class="expand" for="c-42153845">[1 more]</label></div><br/><div class="children"><div class="content">I adore polars for its speed and I find the interface easier than pandas. But pandas still has a richer ecosystem of stuff built around it. I try to use polars in greenfield things but occasionally get yoinked back.</div><br/></div></div><div id="42153883" class="c"><input type="checkbox" id="c-42153883" checked=""/><div class="controls bullet"><span class="by">ibash</span><span>|</span><a href="#42153812">parent</a><span>|</span><a href="#42153845">prev</a><span>|</span><a href="#42153478">next</a><span>|</span><label class="collapse" for="c-42153883">[-]</label><label class="expand" for="c-42153883">[1 more]</label></div><br/><div class="children"><div class="content">Go with polars, you can always convert a polars data frame  back when needed.</div><br/></div></div></div></div><div id="42153478" class="c"><input type="checkbox" id="c-42153478" checked=""/><div class="controls bullet"><span class="by">kolja005</span><span>|</span><a href="#42153812">prev</a><span>|</span><a href="#42153276">next</a><span>|</span><label class="collapse" for="c-42153478">[-]</label><label class="expand" for="c-42153478">[13 more]</label></div><br/><div class="children"><div class="content">Does anyone have a good heuristic for when a dataframe library is a good tool choice? I work on a team that has a lot of data scientists and a few engineers (including myself) and I often see the data scientists using dataframes when simple python classes would be much more appropriate so that you have a better sense of the object you&#x27;re working with. I&#x27;m been having a hard time getting this idea across to people though.</div><br/><div id="42154688" class="c"><input type="checkbox" id="c-42154688" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#42153478">parent</a><span>|</span><a href="#42153600">next</a><span>|</span><label class="collapse" for="c-42154688">[-]</label><label class="expand" for="c-42154688">[1 more]</label></div><br/><div class="children"><div class="content">Performance is my heuristic. I can&#x27;t make it quantitative, because 100M records in 1 minute might be considered fast for some use cases, but slow for others. For me it&#x27;s the qualitative &quot;is this thing too slow?&quot;.<p>Personally, I see a dataframe library as a last resort. I prefer to improve the algorithm, or push more things into the database, or even scale up the hardware in some cases. If I&#x27;ve exhausted all other options and it&#x27;s still too slow, then I use a dataframe library.<p>But then I&#x27;m not a data scientist. I&#x27;ve found that data scientists have a hammer that they really really like, so they&#x27;ll use it everywhere.</div><br/></div></div><div id="42153600" class="c"><input type="checkbox" id="c-42153600" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#42153478">parent</a><span>|</span><a href="#42154688">prev</a><span>|</span><a href="#42153601">next</a><span>|</span><label class="collapse" for="c-42153600">[-]</label><label class="expand" for="c-42153600">[1 more]</label></div><br/><div class="children"><div class="content">Frankly, the heuristic I&#x27;ve developed over the past few years working on a team that sounds like yours is: The data scientists are probably right.<p>If you&#x27;re actually operating on an object, ie. the equivalent to a single row in a dataframe, then yeah, it&#x27;s silly to use a dataframe library. But if you&#x27;re operating on N value objects ... yeah you probably want a dataframe with N rows and a column for each field in your object.<p>Your mileage may vary I guess, but I resisted this for quite awhile and I now think I was the one who was wrong.</div><br/></div></div><div id="42153601" class="c"><input type="checkbox" id="c-42153601" checked=""/><div class="controls bullet"><span class="by">internet101010</span><span>|</span><a href="#42153478">parent</a><span>|</span><a href="#42153600">prev</a><span>|</span><a href="#42153803">next</a><span>|</span><label class="collapse" for="c-42153601">[-]</label><label class="expand" for="c-42153601">[9 more]</label></div><br/><div class="children"><div class="content">DataFrames are easy to use, everyone knows how to use them, you can move fast, and it&#x27;s easy to iterate and test differences between things, and reviewing the code is a breeze.<p>That said, my team moved to polars about a year ago and we haven&#x27;t looked back.</div><br/><div id="42154631" class="c"><input type="checkbox" id="c-42154631" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42153601">parent</a><span>|</span><a href="#42153697">next</a><span>|</span><label class="collapse" for="c-42154631">[-]</label><label class="expand" for="c-42154631">[2 more]</label></div><br/><div class="children"><div class="content">&gt; reviewing the code is a breeze<p>I have the opposite opinion. In a previous codebase I fought hard to use dataclasses &amp; type hinting where possible over dictionaries, because with dictionaries you&#x27;d never know what type anything was, or what keys were present. That worked nicely and it was much easier to understand the codebase.<p>Now I&#x27;ve been put on a Pandas project and it&#x27;s full of mysterious<p><pre><code>    df = df[df[&quot;thing&quot;] == &quot;value&quot;]
</code></pre>
I just feel like we&#x27;ve gone back to the unreadability of dictionaries.<p>Everything&#x27;s just called &quot;df&quot;, you never know what type anything is without going in and checking, the structure of the frames is completely opaque, they change the structure of the dataframe halfway through the program. Type hinting these things is much harder than TypedDict&#x2F;dataclass, at least doing it correctly &amp; unambiguously is. It&#x27;s practically a requirement to shove this stuff in a debugger&#x2F;REPL because you&#x27;d have no chance otherwise.<p>Sure, the argument is that I&#x27;m just in a bad Pandas codebase, and it can be done much better. However what I take issue with is that this seems to be the overwhelming &quot;culture&quot; of Pandas. All Pandas code I&#x27;ve ever read is like this. If you look at tutorials, examples online, you see the same stuff. They all call everything the same name and program in the most dynamic &amp; opaque fashion possible. Sure it&#x27;s quick to write, and if you love Pandas you&#x27;re used to it, but personally I wince every time I look in a method and see this stuff instead of normal code.<p>Personally I only use Pandas if I absolutely need it for performance, as a last resort.</div><br/><div id="42154854" class="c"><input type="checkbox" id="c-42154854" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42154631">parent</a><span>|</span><a href="#42153697">next</a><span>|</span><label class="collapse" for="c-42154854">[-]</label><label class="expand" for="c-42154854">[1 more]</label></div><br/><div class="children"><div class="content">Is it just the generic, non-descriptive naming, or what do you think is the root of your distaste for pandas?<p>Like if we have a dataclass:<p><pre><code>    obj.thing == value
</code></pre>
Or SQL:<p><pre><code>    SELECT * FROM table WHERE thing = ‘value’
</code></pre>
We don’t know what the types are, either, without looking it up.<p>The fact the dataframe often changes halfway through the program is, I think, more to do with the task at hand, that often pandas is being used to perform data transformation (the T in ETL), where some raw data is read in, and the goal is literally to change the structure to clean it up and normalize it, so the data can be ingested into a SQL table in a consistent form with other data points.<p>But if transformation is not what <i>you</i> are doing, then yes, that might not be the right use of dataframes.</div><br/></div></div></div></div><div id="42153697" class="c"><input type="checkbox" id="c-42153697" checked=""/><div class="controls bullet"><span class="by">_boffin_</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42153601">parent</a><span>|</span><a href="#42154631">prev</a><span>|</span><a href="#42153803">next</a><span>|</span><label class="collapse" for="c-42153697">[-]</label><label class="expand" for="c-42153697">[6 more]</label></div><br/><div class="children"><div class="content">Why not sql?</div><br/><div id="42153766" class="c"><input type="checkbox" id="c-42153766" checked=""/><div class="controls bullet"><span class="by">bmer</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42153697">parent</a><span>|</span><a href="#42153803">next</a><span>|</span><label class="collapse" for="c-42153766">[-]</label><label class="expand" for="c-42153766">[5 more]</label></div><br/><div class="children"><div class="content">Editor completion. Programmability &quot;out-of-the-box&quot; (rather than having to generate SQL using another programming language).</div><br/><div id="42154726" class="c"><input type="checkbox" id="c-42154726" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42153766">parent</a><span>|</span><a href="#42153803">next</a><span>|</span><label class="collapse" for="c-42154726">[-]</label><label class="expand" for="c-42154726">[4 more]</label></div><br/><div class="children"><div class="content">Why would you generate SQL using another programming language? To me that sounds like something you&#x27;d only do if you&#x27;re deep in an ORM with no escape hatch. For data analysis tasks, that&#x27;s extremely unergonomic and you should definitely just write normal SQL. Use the ORM for CRUD. I&#x27;ve never seen an ORM that won&#x27;t let you drop down to regular SQL for ad-hoc queries.<p>Editor completion is an extremely low ranking aspect for choosing technologies for data analysis. If SQL is the better tool but you&#x27;re not using it because it doesn&#x27;t have editor completion, then you need a better editor. It pains me when people prioritise &quot;developer experience in VS Code&quot; over &quot;actually the correct technological choice&quot;.</div><br/><div id="42154887" class="c"><input type="checkbox" id="c-42154887" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42154726">parent</a><span>|</span><a href="#42153803">next</a><span>|</span><label class="collapse" for="c-42154887">[-]</label><label class="expand" for="c-42154887">[3 more]</label></div><br/><div class="children"><div class="content">Can I ask what you do for version control of SQL?<p>I ask this sincerely, as I’ve seen many scenarios over the years where a tool like Django is used to manage a Postgres database, solely that the schema migrations are captured in version control. A .sql file can be in version control, but rolling back a git commit is not the same as being able to roll back a schema migration in the actual database.</div><br/><div id="42155212" class="c"><input type="checkbox" id="c-42155212" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42154887">parent</a><span>|</span><a href="#42154994">next</a><span>|</span><label class="collapse" for="c-42155212">[-]</label><label class="expand" for="c-42155212">[1 more]</label></div><br/><div class="children"><div class="content">Sure, happy to go into it. Firstly we need to distinguish between version control of DQL and DDL.<p>In the context of comparing SQL and Pandas, we&#x27;re mostly talking about DQL, so version control for this is exactly the same as any other query code.<p>For the DDL side that you&#x27;re asking about, indeed just version controlling SQL files won&#x27;t work, you need to use a proper migration tool. There are many available that do pure SQL migrations in the same way Django works (a sequence of up&#x2F;down operations to perform or revert a migration). Personally I use migrate[1].<p>So you really can achieve the same thing. Personally I like this approach because it can do anything Django can, but it can also do more complicated migrations that can&#x27;t be expressed by an ORM&#x27;s DB-agnostic abstract layer. Pure SQL migrations also decouple your database schema from your ORM&#x2F;framework, which I think is sensible anyway; databases &amp; data tend to be much stickier than apps &amp; frameworks.<p>A downside here is that you need to do some extra work to keep models in sync with the schema. But the point I was making with my original post is that you can totally use ORMs for CRUD and auto-generate away all that boilerplate, _in addition to_ using raw SQL for complicated data analysis. My point is it&#x27;s not binary, you can mix them, and there&#x27;s nothing forcing you to generate _all_ your queries if you use an ORM for most of them. Use the ORM to manage schema, then SQL for a one-off query - still works.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang-migrate&#x2F;migrate">https:&#x2F;&#x2F;github.com&#x2F;golang-migrate&#x2F;migrate</a></div><br/></div></div><div id="42154994" class="c"><input type="checkbox" id="c-42154994" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#42153478">root</a><span>|</span><a href="#42154887">parent</a><span>|</span><a href="#42155212">prev</a><span>|</span><a href="#42153803">next</a><span>|</span><label class="collapse" for="c-42154994">[-]</label><label class="expand" for="c-42154994">[1 more]</label></div><br/><div class="children"><div class="content">You roll back a schema migration on a dev&#x2F;test database by nuking it and regenerating it, probably with the same tools you use to manage the rest of your environment.<p>You don&#x27;t rollback a schema migration to a production database, because that is impossible. What has been done cannot be undone.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42153803" class="c"><input type="checkbox" id="c-42153803" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42153478">parent</a><span>|</span><a href="#42153601">prev</a><span>|</span><a href="#42153276">next</a><span>|</span><label class="collapse" for="c-42153803">[-]</label><label class="expand" for="c-42153803">[1 more]</label></div><br/><div class="children"><div class="content">I go through this all the time with my clients. Short answer: it really depends.<p>(I spend a good deal of my time and helping client use pandas and Polars.)</div><br/></div></div></div></div><div id="42153276" class="c"><input type="checkbox" id="c-42153276" checked=""/><div class="controls bullet"><span class="by">Vaslo</span><span>|</span><a href="#42153478">prev</a><span>|</span><a href="#42153472">next</a><span>|</span><label class="collapse" for="c-42153276">[-]</label><label class="expand" for="c-42153276">[1 more]</label></div><br/><div class="children"><div class="content">I’ve moved mostly to polars.  I still have some frameworks that demand pandas and pandas is still a very solid dataframe, but when I need to interpolate months in millions of lines of quarterly data, polars just blows it away.<p>Even better is using tools like Narwhals and Ibis which can convert back and forth to any frames you want.</div><br/></div></div><div id="42153472" class="c"><input type="checkbox" id="c-42153472" checked=""/><div class="controls bullet"><span class="by">xgdgsc</span><span>|</span><a href="#42153276">prev</a><span>|</span><label class="collapse" for="c-42153472">[-]</label><label class="expand" for="c-42153472">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27; m tired of remembering of all these library invented concepts and prefer doing brainless for loops to process data in Julia.</div><br/><div id="42154610" class="c"><input type="checkbox" id="c-42154610" checked=""/><div class="controls bullet"><span class="by">Demiurge</span><span>|</span><a href="#42153472">parent</a><span>|</span><a href="#42153811">next</a><span>|</span><label class="collapse" for="c-42154610">[-]</label><label class="expand" for="c-42154610">[1 more]</label></div><br/><div class="children"><div class="content">You’re tired, but I don’t know if I have enough brains to rewrite the API “query” from this article using brainless loops.</div><br/></div></div><div id="42153811" class="c"><input type="checkbox" id="c-42153811" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42153472">parent</a><span>|</span><a href="#42154610">prev</a><span>|</span><label class="collapse" for="c-42153811">[-]</label><label class="expand" for="c-42153811">[3 more]</label></div><br/><div class="children"><div class="content">You can do brainless for loops in Python really easily.<p>Oh yeah, toss numba or cython on top and you are back to numpy speed...</div><br/><div id="42153915" class="c"><input type="checkbox" id="c-42153915" checked=""/><div class="controls bullet"><span class="by">xgdgsc</span><span>|</span><a href="#42153472">root</a><span>|</span><a href="#42153811">parent</a><span>|</span><label class="collapse" for="c-42153915">[-]</label><label class="expand" for="c-42153915">[2 more]</label></div><br/><div class="children"><div class="content">Nope they are still libraries with their own feature set that need remembering.</div><br/><div id="42154011" class="c"><input type="checkbox" id="c-42154011" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42153472">root</a><span>|</span><a href="#42153915">parent</a><span>|</span><label class="collapse" for="c-42154011">[-]</label><label class="expand" for="c-42154011">[1 more]</label></div><br/><div class="children"><div class="content">Ok, if you consider @jit a feature set...<p>(Admittedly, there are more features, but in my book, I demonstrate pure Python code that runs as fast as numpy and cython with this decorator added.)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>