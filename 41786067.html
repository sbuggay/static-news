<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728723674136" as="style"/><link rel="stylesheet" href="styles.css?v=1728723674136"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://hardmath123.github.io/conways-gradient.html">Conway&#x27;s Gradient of Life</a> <span class="domain">(<a href="https://hardmath123.github.io">hardmath123.github.io</a>)</span></div><div class="subtext"><span>networked</span> | <span>24 comments</span></div><br/><div><div id="41815124" class="c"><input type="checkbox" id="c-41815124" checked=""/><div class="controls bullet"><span class="by">versteegen</span><span>|</span><a href="#41812338">next</a><span>|</span><label class="collapse" for="c-41815124">[-]</label><label class="expand" for="c-41815124">[2 more]</label></div><br/><div class="children"><div class="content">The objective function here defines a Markov random field (MRF) with boolean random variables and certain local statistics of nearest neighbours, either uniform if the target is a white image, or varying with location to produce an image. MRFs define Gibbs probability distributions, which you can sample from (which will already produce a good image here) or perform gradient ascent on to reach a local maxima. The negative log-likelihood of the MRF distribution is equal to the loss function of the original optimisation problem, so the maximum likelihood estimate (MLE) (there will often be multiple due to symmetry) of the MRF is the optimal solution(s) to the original problem. (But in general the MLE  can look completely different to a sample.)<p>The statistics are 9th-order (of 3x3 blocks of pixels) but of a simple form which are hardly more expressive than 2nd-order nearest neighbour statistics (in terms of the different textures that they can reproduce) which are well known. In the approximate case where you only care about the average value of each pixel I think it would collapse to 2nd-order. Texture synthesis with MRFs with local statistics is discretized (in space) Turing reaction-diffusion. I did my PhD on this topic.<p>Probably the most influential early paper on this kind of simple texture model, where you will see similar patterns, is:<p>Cross &amp; Jain, 1983, PAMI, Markov Random Field Texture Models</div><br/><div id="41816731" class="c"><input type="checkbox" id="c-41816731" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#41815124">parent</a><span>|</span><a href="#41812338">next</a><span>|</span><label class="collapse" for="c-41816731">[-]</label><label class="expand" for="c-41816731">[1 more]</label></div><br/><div class="children"><div class="content">Anything you’ve found to be additionally interesting or curious along this path or different but somewhat related?<p>Are you still working on this topic or other things now?</div><br/></div></div></div></div><div id="41812338" class="c"><input type="checkbox" id="c-41812338" checked=""/><div class="controls bullet"><span class="by">dvh</span><span>|</span><a href="#41815124">prev</a><span>|</span><a href="#41816819">next</a><span>|</span><label class="collapse" for="c-41812338">[-]</label><label class="expand" for="c-41812338">[1 more]</label></div><br/><div class="children"><div class="content">Few days ago I posted this: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41743887">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41743887</a></div><br/></div></div><div id="41816819" class="c"><input type="checkbox" id="c-41816819" checked=""/><div class="controls bullet"><span class="by">ddejohn</span><span>|</span><a href="#41812338">prev</a><span>|</span><a href="#41813783">next</a><span>|</span><label class="collapse" for="c-41816819">[-]</label><label class="expand" for="c-41816819">[1 more]</label></div><br/><div class="children"><div class="content">Really cool to see. Was curious about the author&#x27;s other work and was very annoyed that the blog does not link to the author&#x27;s other posts, either with a &quot;next&#x2F;previous&quot; link, an archive, or a homepage where a list of posts can be viewed. The only way to see other posts is to subscribe to the RSS. I can&#x27;t imagine there being a good reason for having such a bad UX.</div><br/></div></div><div id="41813783" class="c"><input type="checkbox" id="c-41813783" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#41816819">prev</a><span>|</span><a href="#41812745">next</a><span>|</span><label class="collapse" for="c-41813783">[-]</label><label class="expand" for="c-41813783">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &quot;its like showing a solved rubiks cube and asking what the scramble was&quot;
</code></pre>
^ this analogy may be the best I&#x27;ve seen in a long time.</div><br/><div id="41817522" class="c"><input type="checkbox" id="c-41817522" checked=""/><div class="controls bullet"><span class="by">Etherlord87</span><span>|</span><a href="#41813783">parent</a><span>|</span><a href="#41812745">next</a><span>|</span><label class="collapse" for="c-41817522">[-]</label><label class="expand" for="c-41817522">[1 more]</label></div><br/><div class="children"><div class="content">I disagree, getting a scramble is trivial for a Rubik&#x27;s cube (because any scramble will do, and unlike with Conway&#x27;s Game of Life, here going in reverse is simple). If there was a particular scramble and you want to recover it, you just can&#x27;t do it without some additional information.</div><br/></div></div></div></div><div id="41812745" class="c"><input type="checkbox" id="c-41812745" checked=""/><div class="controls bullet"><span class="by">mbauman</span><span>|</span><a href="#41813783">prev</a><span>|</span><a href="#41815524">next</a><span>|</span><label class="collapse" for="c-41812745">[-]</label><label class="expand" for="c-41812745">[1 more]</label></div><br/><div class="children"><div class="content">Atavising was new to me. From <a href="https:&#x2F;&#x2F;nbickford.wordpress.com&#x2F;2012&#x2F;04&#x2F;15&#x2F;reversing-the-game-of-life-for-fun-and-profit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nbickford.wordpress.com&#x2F;2012&#x2F;04&#x2F;15&#x2F;reversing-the-gam...</a> :<p>&gt; First of all, while I said “Predecessorifier” in the talk, “Ataviser” seems to be the accepted word, coming from “Atavism”, which the online Merriam-Webster dictionary defines as “recurrence of or reversion to a past style, manner, outlook, approach, or activity”.</div><br/></div></div><div id="41815524" class="c"><input type="checkbox" id="c-41815524" checked=""/><div class="controls bullet"><span class="by">drofnarc</span><span>|</span><a href="#41812745">prev</a><span>|</span><a href="#41815450">next</a><span>|</span><label class="collapse" for="c-41815524">[-]</label><label class="expand" for="c-41815524">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m so glad to see others working on this. I&#x27;ve attempted it too, but not with any measure of success.<p>Trying to trade space for time, I used a model that gives every cell a set of all 512 of the possible 3x3 neighborhoods that could have caused that cell&#x27;s present state (&quot;alibis&quot;). It then goes to each cell, comparing its alibis to those of neighboring cells and eliminating mutually impossible ones from either set. This step has to be repeated until no more alibis are shed in a pass.<p>When it finally stabilizes, the model is a solution kernel that can then field further manual guesses against it. If a cell&#x27;s alibis all agree it was dead in the &quot;before&quot;, there&#x27;s no need to guess, but if they&#x27;re not unanimous, what if we hazard a guess one way or the other for a bit? How does that ripple through the rest of the board? If any of the cells ran completely out of alibis given a certain guess, that guess was clearly not a proper solution, and it&#x27;s time to back out and try a different one. If there&#x27;s no solution at all, that&#x27;s a Garden of Eden.<p>Ultimately I wanted to generate not just one solution, but all the solutions for a given board. I got stumped because I wasn&#x27;t convinced I wasn&#x27;t still working in 2**(n*m) time or worse trying guesses against the kernel.<p>It&#x27;s a really fascinating problem, so much so that I even made a pico8 game about it years ago! Even the 6x6 grids are really tough!</div><br/><div id="41816743" class="c"><input type="checkbox" id="c-41816743" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#41815524">parent</a><span>|</span><a href="#41815450">next</a><span>|</span><label class="collapse" for="c-41816743">[-]</label><label class="expand" for="c-41816743">[1 more]</label></div><br/><div class="children"><div class="content">What do you think might be the path &#x2F; solution but needs playful experiments ? Ideas to seed others?</div><br/></div></div></div></div><div id="41815450" class="c"><input type="checkbox" id="c-41815450" checked=""/><div class="controls bullet"><span class="by">rustybolt</span><span>|</span><a href="#41815524">prev</a><span>|</span><a href="#41815162">next</a><span>|</span><label class="collapse" for="c-41815450">[-]</label><label class="expand" for="c-41815450">[2 more]</label></div><br/><div class="children"><div class="content">Feels to me like there is no need for backpropagation. I think you can just iteratively grab a random pixel and flip it of that would bring you closer to the target after one step.<p>It would probably work even better if you tweak the loss function with some kind of averaging&#x2F;blurring filter.</div><br/><div id="41816472" class="c"><input type="checkbox" id="c-41816472" checked=""/><div class="controls bullet"><span class="by">quantadev</span><span>|</span><a href="#41815450">parent</a><span>|</span><a href="#41815162">next</a><span>|</span><label class="collapse" for="c-41816472">[-]</label><label class="expand" for="c-41816472">[1 more]</label></div><br/><div class="children"><div class="content">This is just the brute force solution. I&#x27;m pretty sure that&#x27;s no more efficient than guessing all pixels at once and trying to check of that worked or not.</div><br/></div></div></div></div><div id="41815162" class="c"><input type="checkbox" id="c-41815162" checked=""/><div class="controls bullet"><span class="by">chillee</span><span>|</span><a href="#41815450">prev</a><span>|</span><a href="#41814512">next</a><span>|</span><label class="collapse" for="c-41815162">[-]</label><label class="expand" for="c-41815162">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always fun when people use autodiff in packages like PyTorch for completely unrelated usecases :)</div><br/></div></div><div id="41814512" class="c"><input type="checkbox" id="c-41814512" checked=""/><div class="controls bullet"><span class="by">jwood27</span><span>|</span><a href="#41815162">prev</a><span>|</span><a href="#41815136">next</a><span>|</span><label class="collapse" for="c-41814512">[-]</label><label class="expand" for="c-41814512">[1 more]</label></div><br/><div class="children"><div class="content">I made a related crossword puzzle. You can find it here if you want to give it a try! <a href="https:&#x2F;&#x2F;jacobw.xyz&#x2F;projects&#x2F;crossword&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jacobw.xyz&#x2F;projects&#x2F;crossword&#x2F;</a></div><br/></div></div><div id="41815136" class="c"><input type="checkbox" id="c-41815136" checked=""/><div class="controls bullet"><span class="by">christina97</span><span>|</span><a href="#41814512">prev</a><span>|</span><a href="#41817393">next</a><span>|</span><label class="collapse" for="c-41815136">[-]</label><label class="expand" for="c-41815136">[2 more]</label></div><br/><div class="children"><div class="content">I feel like just doing simulated annealing on the starting grid would work better and be faster to implement?<p>(Not saying the goal was working well and being fast to implement.)</div><br/><div id="41815260" class="c"><input type="checkbox" id="c-41815260" checked=""/><div class="controls bullet"><span class="by">versteegen</span><span>|</span><a href="#41815136">parent</a><span>|</span><a href="#41817393">next</a><span>|</span><label class="collapse" for="c-41815260">[-]</label><label class="expand" for="c-41815260">[1 more]</label></div><br/><div class="children"><div class="content">Simulated annealing (basically MCMC sampling with a temperature schedule) is how you optimise or sample the equivalent MRF, which I discussed in my other comment. You can hope to escape local minima using annealing, and lower the temperature to zero to fall into a local minima, minimising the noise added by annealing. In practice if you&#x27;re trying to produce something that looks like a target image as in the article I&#x27;m pretty sure the results will be indistinguishable. If you actually cared about how many individual pixels are correct, yes, annealing is better than gradient descent. That&#x27;s why stochastic gradient descent is used in ML.</div><br/></div></div></div></div><div id="41817393" class="c"><input type="checkbox" id="c-41817393" checked=""/><div class="controls bullet"><span class="by">ngruhn</span><span>|</span><a href="#41815136">prev</a><span>|</span><a href="#41814323">next</a><span>|</span><label class="collapse" for="c-41817393">[-]</label><label class="expand" for="c-41817393">[1 more]</label></div><br/><div class="children"><div class="content">Very cool!</div><br/></div></div><div id="41814323" class="c"><input type="checkbox" id="c-41814323" checked=""/><div class="controls bullet"><span class="by">conorpo</span><span>|</span><a href="#41817393">prev</a><span>|</span><a href="#41814040">next</a><span>|</span><label class="collapse" for="c-41814323">[-]</label><label class="expand" for="c-41814323">[3 more]</label></div><br/><div class="children"><div class="content">Seeing alot of parallels to the article by Stephen Wolfram posted a few days back on the fundamental nature of time .</div><br/><div id="41814627" class="c"><input type="checkbox" id="c-41814627" checked=""/><div class="controls bullet"><span class="by">sleepingreset</span><span>|</span><a href="#41814323">parent</a><span>|</span><a href="#41814040">next</a><span>|</span><label class="collapse" for="c-41814627">[-]</label><label class="expand" for="c-41814627">[2 more]</label></div><br/><div class="children"><div class="content">which?</div><br/><div id="41814765" class="c"><input type="checkbox" id="c-41814765" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#41814323">root</a><span>|</span><a href="#41814627">parent</a><span>|</span><a href="#41814040">next</a><span>|</span><label class="collapse" for="c-41814765">[-]</label><label class="expand" for="c-41814765">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41782534">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41782534</a></div><br/></div></div></div></div></div></div><div id="41814040" class="c"><input type="checkbox" id="c-41814040" checked=""/><div class="controls bullet"><span class="by">Hugsun</span><span>|</span><a href="#41814323">prev</a><span>|</span><a href="#41813832">next</a><span>|</span><label class="collapse" for="c-41814040">[-]</label><label class="expand" for="c-41814040">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. I can&#x27;t zoom on mobile which is frustrating.</div><br/></div></div><div id="41813857" class="c"><input type="checkbox" id="c-41813857" checked=""/><div class="controls bullet"><span class="by">xfreesoft</span><span>|</span><a href="#41815543">prev</a><span>|</span><label class="collapse" for="c-41813857">[-]</label><label class="expand" for="c-41813857">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;vtempest&#x2F;Automated-Automata">https:&#x2F;&#x2F;github.com&#x2F;vtempest&#x2F;Automated-Automata</a>
One idea is to have the gradient patterns emergent from simple rules calculating prior numbers with no need for hand of God intrvention.</div><br/></div></div></div></div></div></div></div></body></html>