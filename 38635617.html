<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702544459156" as="style"/><link rel="stylesheet" href="styles.css?v=1702544459156"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.biscuitsec.org/">Biscuit authorization</a>Â <span class="domain">(<a href="https://www.biscuitsec.org">www.biscuitsec.org</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>65 comments</span></div><br/><div><div id="38637677" class="c"><input type="checkbox" id="c-38637677" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#38637616">next</a><span>|</span><label class="collapse" for="c-38637677">[-]</label><label class="expand" for="c-38637677">[27 more]</label></div><br/><div class="children"><div class="content">I was searching for a quick explainer of how revocation is implemented, but didn&#x27;t find it (at least not quickly). Can anyone say how this works?<p>Revocation is essentially the Achilles heel of JWTs - you want to have completely stateless bearer tokens, but if you need to check for revocations, it means you have to do <i>some</i> sort of lookup against a revocation table, and at that point you really lose the stateless nature that you wanted in the first place. There are some tricks to make this more tenable, but it&#x27;s still a big reason why some folks say &quot;don&#x27;t use JWTs for end-user auth&quot;.<p>Would greatly appreciate details on how Biscuit implements this with their &quot;revocation IDs&quot;.<p>Edit: Nevermind, I found it: <a href="https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;why-biscuit&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;why-biscuit&#x2F;</a> - and it turns out revocation is a &quot;non goal&quot;. And then in the linked page about how to implement revocations, they basically do exactly what I do for JWTs: have a revocation list, but then revocations can fall off that list once they&#x27;re past the expiration date anyway.<p>So, not to be too harsh, but why would I use this over JWTs? There is no &quot;magic&quot; getting around the &quot;well, they&#x27;re <i>kinda</i> stateless&quot; problem. To be honest I don&#x27;t really care about some of the other tangential benefits (after all, you can stick whatever you want on a JWT and interpret it however you like) if it still has by far the same glaring pain point associated with any bearer token system.</div><br/><div id="38638942" class="c"><input type="checkbox" id="c-38638942" checked=""/><div class="controls bullet"><span class="by">ivanb</span><span>|</span><a href="#38637677">parent</a><span>|</span><a href="#38639148">next</a><span>|</span><label class="collapse" for="c-38638942">[-]</label><label class="expand" for="c-38638942">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Revocation is essentially the Achilles heel of JWTs<p>By the nature of the problem you have to store some kind of a list of tokens. Either a black list as with JWTs or a white list as with classic session tokens. There is no way around it. This makes both approaches practically the same.<p>One can argue that the black list will in general be shorter than the white list, but in a case of a serious attack, would it really be so?<p>I am afraid that the community will now abandon JWTs and move to biscuits, macaroons, buns and meringues as they did with classic session tokens, throwing away the tools and security practices.</div><br/></div></div><div id="38639148" class="c"><input type="checkbox" id="c-38639148" checked=""/><div class="controls bullet"><span class="by">geal</span><span>|</span><a href="#38637677">parent</a><span>|</span><a href="#38638942">prev</a><span>|</span><a href="#38637972">next</a><span>|</span><label class="collapse" for="c-38639148">[-]</label><label class="expand" for="c-38639148">[1 more]</label></div><br/><div class="children"><div class="content">(Biscuit author here) there is some support for revocation with the way revocation ids are implemented: there&#x27;s one generated for each block of a token, so if you add the token&#x27;s last block&#x27;s revocation id to the revocation list, then all tokens derived from that one will be revoked as well.
We outline the strategies to manage revocation in <a href="https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;guides&#x2F;revocation&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;guides&#x2F;revocation&#x2F;</a> but as you said, there is no magic here, adding revocation reintroduces state in the system.
As for why you would use this over JWTs: Biscuit avoids JWT&#x27;s usual footguns, specifies an authorization language where checks can be carred by the token, it adds attenuation and third party blocks. You can build a lot more with those tokens</div><br/></div></div><div id="38637972" class="c"><input type="checkbox" id="c-38637972" checked=""/><div class="controls bullet"><span class="by">Ecoste</span><span>|</span><a href="#38637677">parent</a><span>|</span><a href="#38639148">prev</a><span>|</span><a href="#38637766">next</a><span>|</span><label class="collapse" for="c-38637972">[-]</label><label class="expand" for="c-38637972">[2 more]</label></div><br/><div class="children"><div class="content">Maybe a naive question: but is there any way at all (impractical or not) to implement stateless revocation? In my mind JWT is already non-stateless in the sense that the server at least needs to keep one piece of information which is the secret key. It&#x27;s very memory efficient, but not stateless. If a decision is made to revoke a user, that state needs to be kept somewhere.</div><br/><div id="38638469" class="c"><input type="checkbox" id="c-38638469" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637972">parent</a><span>|</span><a href="#38637766">next</a><span>|</span><label class="collapse" for="c-38638469">[-]</label><label class="expand" for="c-38638469">[1 more]</label></div><br/><div class="children"><div class="content">No. But a stateful revocation service can be extremely lightweight. The number of JWTs being revoked will be minimal and they are only revoked until they would otherwise expire, which keeps the dataset small. This could easily fit in an in memory cache to avoid a database hit.</div><br/></div></div></div></div><div id="38637766" class="c"><input type="checkbox" id="c-38637766" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#38637677">parent</a><span>|</span><a href="#38637972">prev</a><span>|</span><a href="#38638015">next</a><span>|</span><label class="collapse" for="c-38637766">[-]</label><label class="expand" for="c-38637766">[17 more]</label></div><br/><div class="children"><div class="content">Off topic: I&#x27;m always confused by the passion to use JWTs where normal session uuid&#x27;s would do just as well.<p>A place I worked at recently insisted on JWTs despite being a monolith and calling the database on every API endpoint. I still don&#x27;t get why.</div><br/><div id="38638178" class="c"><input type="checkbox" id="c-38638178" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637766">parent</a><span>|</span><a href="#38638698">next</a><span>|</span><label class="collapse" for="c-38638178">[-]</label><label class="expand" for="c-38638178">[8 more]</label></div><br/><div class="children"><div class="content">JWTs let you reject unauthorized requests on their face, without having to even make a database call.<p>Protecting your database from even being queried when the request is unauthorized reduces your attack surface enormously.</div><br/><div id="38638757" class="c"><input type="checkbox" id="c-38638757" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638178">parent</a><span>|</span><a href="#38638280">next</a><span>|</span><label class="collapse" for="c-38638757">[-]</label><label class="expand" for="c-38638757">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get why that&#x27;s a reduction in attack surface?<p>I guess DDOS attacks - if we&#x27;re checking the session ID on every request then that&#x27;s a potential attack if you just make up uuids and throw them at the server.<p>But JWT&#x27;s themselves are an attack vector, surely? If there&#x27;s any mistake in the encryption (or any vulnerability in the libraries used) then this is a door open very wide indeed.<p>The beauty of session IDs is the simplicity of it - very few moving parts, so very few opportunities for mischief. JWTs seem to be the opposite: lots of moving parts, lots of opportunities.</div><br/></div></div><div id="38638280" class="c"><input type="checkbox" id="c-38638280" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638178">parent</a><span>|</span><a href="#38638757">prev</a><span>|</span><a href="#38638698">next</a><span>|</span><label class="collapse" for="c-38638280">[-]</label><label class="expand" for="c-38638280">[6 more]</label></div><br/><div class="children"><div class="content">So does every Rails and Django encrypted session token.</div><br/><div id="38638484" class="c"><input type="checkbox" id="c-38638484" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638280">parent</a><span>|</span><a href="#38638698">next</a><span>|</span><label class="collapse" for="c-38638484">[-]</label><label class="expand" for="c-38638484">[5 more]</label></div><br/><div class="children"><div class="content">How do you revoke an encrypted session token that doesn&#x27;t need to hit the database to see if the request is authorized?</div><br/><div id="38638531" class="c"><input type="checkbox" id="c-38638531" checked=""/><div class="controls bullet"><span class="by">DecoPerson</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638484">parent</a><span>|</span><a href="#38638698">next</a><span>|</span><label class="collapse" for="c-38638531">[-]</label><label class="expand" for="c-38638531">[4 more]</label></div><br/><div class="children"><div class="content">Include an expiry time in the encrypted part. The encryption, and the fact the token decrypts invalidly if not encrypted with the correct key, acts like a discount JWT.<p>Encrypted session tokens with embedded expiry will serve the needs of 99% of applications&#x2F;services.</div><br/><div id="38638652" class="c"><input type="checkbox" id="c-38638652" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638531">parent</a><span>|</span><a href="#38638698">next</a><span>|</span><label class="collapse" for="c-38638652">[-]</label><label class="expand" for="c-38638652">[3 more]</label></div><br/><div class="children"><div class="content">In that case why not use JWTs which do this for you?  In your case you end up building a subset of JWTs yourself.</div><br/><div id="38638981" class="c"><input type="checkbox" id="c-38638981" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638652">parent</a><span>|</span><a href="#38638698">next</a><span>|</span><label class="collapse" for="c-38638981">[-]</label><label class="expand" for="c-38638981">[2 more]</label></div><br/><div class="children"><div class="content">These might predate JWTs.</div><br/><div id="38639138" class="c"><input type="checkbox" id="c-38639138" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638981">parent</a><span>|</span><a href="#38638698">next</a><span>|</span><label class="collapse" for="c-38639138">[-]</label><label class="expand" for="c-38639138">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, RFC 7519 dates from 2015 while both Rails and Django are older than that by a decade or more.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38638698" class="c"><input type="checkbox" id="c-38638698" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637766">parent</a><span>|</span><a href="#38638178">prev</a><span>|</span><a href="#38638483">next</a><span>|</span><label class="collapse" for="c-38638698">[-]</label><label class="expand" for="c-38638698">[1 more]</label></div><br/><div class="children"><div class="content">It is cheaper to look up at the handful of recovered tokens than however many active sessions you have, assuming you have a substantial number of them, otherwise, it is a moot point, similar to microservices for websites with 3-4 digits traffic per hour.</div><br/></div></div><div id="38638483" class="c"><input type="checkbox" id="c-38638483" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637766">parent</a><span>|</span><a href="#38638698">prev</a><span>|</span><a href="#38638000">next</a><span>|</span><label class="collapse" for="c-38638483">[-]</label><label class="expand" for="c-38638483">[1 more]</label></div><br/><div class="children"><div class="content">I guess you could use token exchange[1] to get benefits of both.<p>[1]: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8693.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8693.html</a></div><br/></div></div><div id="38638000" class="c"><input type="checkbox" id="c-38638000" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637766">parent</a><span>|</span><a href="#38638483">prev</a><span>|</span><a href="#38638161">next</a><span>|</span><label class="collapse" for="c-38638000">[-]</label><label class="expand" for="c-38638000">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t using JWTs in this case permit for starting to chip away on the monolith and integrating side services in the authz offered by the core service?<p>I do get wanting to keep it simple but with sessions I don&#x27;t know what is more simple once your project starts to grow. Rolling your own auth can be a minefield especially if you want to span it across more than one service and most of the off the shelf solutions will push you towards OAuth&#x2F;OIDC any way at which point JWTs are some kind of de-facto standard. The good thing is that once one has gotten accustomed to OAuth verbiage you don&#x27;t really have to think about it any more.</div><br/><div id="38638254" class="c"><input type="checkbox" id="c-38638254" checked=""/><div class="controls bullet"><span class="by">caseyohara</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638000">parent</a><span>|</span><a href="#38638161">next</a><span>|</span><label class="collapse" for="c-38638254">[-]</label><label class="expand" for="c-38638254">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but that presupposes that breaking apart a monolith is the goal, or even that &quot;integrating side services&quot; is a positive improvement.<p>I resisted microservice mania when it emerged, and now I feel validated that the pendulum has swung back.</div><br/></div></div></div></div><div id="38638161" class="c"><input type="checkbox" id="c-38638161" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637766">parent</a><span>|</span><a href="#38638000">prev</a><span>|</span><a href="#38637836">next</a><span>|</span><label class="collapse" for="c-38638161">[-]</label><label class="expand" for="c-38638161">[1 more]</label></div><br/><div class="children"><div class="content">It can be nice in a distributed app built with eventual consistency. Often ok if revocations take a short time to propagate but that&#x27;s generally not true for session tokens.</div><br/></div></div><div id="38637836" class="c"><input type="checkbox" id="c-38637836" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637766">parent</a><span>|</span><a href="#38638161">prev</a><span>|</span><a href="#38638015">next</a><span>|</span><label class="collapse" for="c-38637836">[-]</label><label class="expand" for="c-38637836">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A place I worked at recently insisted on JWTs despite being a monolith and calling the database on every API endpoint.<p>JWTs <i>are</i> really nice because you can validate things like roles and permissions just by validating the token signature. And there are much better ways to implement revocation lists than &quot;calling the database on every API endpoint&quot; (if that&#x27;s what you were referring to). Since revocation lists are usually very small (depending on the nature of your app), it&#x27;s often possible to just replicate them to in-memory data structures on your servers.</div><br/><div id="38638995" class="c"><input type="checkbox" id="c-38638995" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637836">parent</a><span>|</span><a href="#38638015">next</a><span>|</span><label class="collapse" for="c-38638995">[-]</label><label class="expand" for="c-38638995">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, but the parent probably meant accessing the DB for every request for stuff other than revocation.</div><br/><div id="38639217" class="c"><input type="checkbox" id="c-38639217" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638995">parent</a><span>|</span><a href="#38638015">next</a><span>|</span><label class="collapse" for="c-38639217">[-]</label><label class="expand" for="c-38639217">[1 more]</label></div><br/><div class="children"><div class="content">I did. Thanks :)</div><br/></div></div></div></div></div></div></div></div><div id="38638015" class="c"><input type="checkbox" id="c-38638015" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38637677">parent</a><span>|</span><a href="#38637766">prev</a><span>|</span><a href="#38637745">next</a><span>|</span><label class="collapse" for="c-38638015">[-]</label><label class="expand" for="c-38638015">[2 more]</label></div><br/><div class="children"><div class="content">In Macaroonia, which is one of the most important Biscuit inspirations, you can address &quot;stateless&quot; revocation with a 3P caveat on a revocation check service, which can issue time-limited &quot;not revoked&quot; attestations; the services that rely on the tokens don&#x27;t even have to understand what that revocation check service is, or have any revocation checking code at all; it&#x27;s all hidden from the application, the service can get moved around, scaled out independently, etc.<p>I&#x27;d be surprised if there wasn&#x27;t a similar strategy available to Biscuits.</div><br/><div id="38639091" class="c"><input type="checkbox" id="c-38639091" checked=""/><div class="controls bullet"><span class="by">geal</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38638015">parent</a><span>|</span><a href="#38637745">next</a><span>|</span><label class="collapse" for="c-38639091">[-]</label><label class="expand" for="c-38639091">[1 more]</label></div><br/><div class="children"><div class="content">there&#x27;s a siimilar concept in Biscuit, the 3rd party block: <a href="https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;blog&#x2F;third-party-blocks-why-how-when-who&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;blog&#x2F;third-party-blocks-why-how-w...</a>
It&#x27;s not advertised a lot right now because it&#x27;s not supported by all libraries yet</div><br/></div></div></div></div><div id="38637745" class="c"><input type="checkbox" id="c-38637745" checked=""/><div class="controls bullet"><span class="by">nulltxt</span><span>|</span><a href="#38637677">parent</a><span>|</span><a href="#38638015">prev</a><span>|</span><a href="#38637616">next</a><span>|</span><label class="collapse" for="c-38637745">[-]</label><label class="expand" for="c-38637745">[2 more]</label></div><br/><div class="children"><div class="content">I believe from when I looked at it you have to store the revocation tokens in a list so it isn&#x27;t an amazing solution but better than storing the whole token ig</div><br/><div id="38637750" class="c"><input type="checkbox" id="c-38637750" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#38637677">root</a><span>|</span><a href="#38637745">parent</a><span>|</span><a href="#38637616">next</a><span>|</span><label class="collapse" for="c-38637750">[-]</label><label class="expand" for="c-38637750">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s generally better because revocation lists are assumed to be smaller than valid lists.</div><br/></div></div></div></div></div></div><div id="38637616" class="c"><input type="checkbox" id="c-38637616" checked=""/><div class="controls bullet"><span class="by">CobrastanJorji</span><span>|</span><a href="#38637677">prev</a><span>|</span><a href="#38638625">next</a><span>|</span><label class="collapse" for="c-38637616">[-]</label><label class="expand" for="c-38637616">[4 more]</label></div><br/><div class="children"><div class="content">This is a neat project.<p>That said, the documentation does this thing I see a lot where the author focuses entirely on things that are good. It repeats and clarifies things that are good (you can reduce the scopes of offline, but never increase the scope of tokens, and you can do it offline, without contacting servers. Any server can validate credentials because it uses public keys. And did we tell you about attenuating tokens?), but it kind of sweeps anything that is NOT a discriminator under a rug a bit. I don&#x27;t think it&#x27;s malicious. Creators get excited about the exciting bits of their project.<p>But there are a lot of details that may or may not be present, and if I&#x27;m evaluating your thing, I want to know which exist an which don&#x27;t. Given a long-term token, can I create short-term, auto-expiring tokens? Is there some revocation mechanism? How do these things line up against JWT or OAuth? When should I prefer this, but also when should I NOT prefer this?<p>Still, I like a lot about the documentation. I love how it&#x27;s not afraid to get into the weeds about EXACTLY what it does without losing the clarity. It&#x27;s really easy to follow when it gets technical, which is rare.</div><br/><div id="38639236" class="c"><input type="checkbox" id="c-38639236" checked=""/><div class="controls bullet"><span class="by">geal</span><span>|</span><a href="#38637616">parent</a><span>|</span><a href="#38637692">next</a><span>|</span><label class="collapse" for="c-38639236">[-]</label><label class="expand" for="c-38639236">[2 more]</label></div><br/><div class="children"><div class="content">(biscuit author here) you caught me, I can&#x27;t help getting excited about the project XD<p>&gt; Given a long-term token, can I create short-term, auto-expiring tokens?<p>yes, with attenuation: <a href="https:&#x2F;&#x2F;doc.biscuitsec.org&#x2F;recipes&#x2F;common-patterns#expiration-check" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.biscuitsec.org&#x2F;recipes&#x2F;common-patterns#expiratio...</a><p>&gt; Is there some revocation mechanism?<p>In a token, each block has a revocation id, so if you revoke a token, all the tokens derived from that one will be revoked as well. As for how to handle those revocation ids, it&#x27;s the same strategies as in other systems, reintroducing some state to check revocation lists: <a href="https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;guides&#x2F;revocation&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;guides&#x2F;revocation&#x2F;</a><p>&gt; How do these things line up against JWT or OAuth? When should I prefer this, but also when should I NOT prefer this?<p>JWT has a lot of footguns, especially in the way it handles the list of algorithms, and libraries tend to all go through the same set of mistakes (a lot of them are stable now though). JWT are good to transmit a small amount of data, and are overall well supported. JWTs do not enforce any authorization system, you have to add one yourself.
Biscuit is very strict in how it deserializes and verifies tokens, so it avoids the usual JWT issues (partly by its spec, partly by an extensive test suite). Biscuits can be larger than JWTs, and can take longer to verify (one signature verification per block). Biscuit comes with its own authorization, based on a logic language, that can be both carried by the token and provided by the verifier. It has implementations in a lot of languages but is not as widely supported as JWT yet.<p>I&#x27;d say if you can live with JWTs containing a little data (like a sub to look up in DB) and a simple authz system like a RBAC, keep using it, that will work well.
But if you can benefit from attenuation (ex: per request attenuation <a href="https:&#x2F;&#x2F;doc.biscuitsec.org&#x2F;recipes&#x2F;per-request-attenuation" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.biscuitsec.org&#x2F;recipes&#x2F;per-request-attenuation</a> and delegation <a href="https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;guides&#x2F;microservices&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;docs&#x2F;guides&#x2F;microservices&#x2F;</a> ), then look into Biscuit, it can help</div><br/><div id="38639244" class="c"><input type="checkbox" id="c-38639244" checked=""/><div class="controls bullet"><span class="by">geal</span><span>|</span><a href="#38637616">root</a><span>|</span><a href="#38639236">parent</a><span>|</span><a href="#38637692">next</a><span>|</span><label class="collapse" for="c-38639244">[-]</label><label class="expand" for="c-38639244">[1 more]</label></div><br/><div class="children"><div class="content">oh and for OAuth, it can integrate well with it: <a href="https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;blog&#x2F;oauth-oidc&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.biscuitsec.org&#x2F;blog&#x2F;oauth-oidc&#x2F;</a></div><br/></div></div></div></div><div id="38637692" class="c"><input type="checkbox" id="c-38637692" checked=""/><div class="controls bullet"><span class="by">ztorkelson</span><span>|</span><a href="#38637616">parent</a><span>|</span><a href="#38639236">prev</a><span>|</span><a href="#38638625">next</a><span>|</span><label class="collapse" for="c-38637692">[-]</label><label class="expand" for="c-38637692">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Given a long-term token, can I create short-term, auto-expiring tokens?<p>I suspect the answer is: yes, via attenuation. :)</div><br/></div></div></div></div><div id="38638625" class="c"><input type="checkbox" id="c-38638625" checked=""/><div class="controls bullet"><span class="by">isuckatcoding</span><span>|</span><a href="#38637616">prev</a><span>|</span><a href="#38638973">next</a><span>|</span><label class="collapse" for="c-38638625">[-]</label><label class="expand" for="c-38638625">[2 more]</label></div><br/><div class="children"><div class="content">Really cool concept but having a really hard time understanding the datalog language and the semantics.<p>Like specifically what is the difference between check if and allow if?</div><br/><div id="38639254" class="c"><input type="checkbox" id="c-38639254" checked=""/><div class="controls bullet"><span class="by">geal</span><span>|</span><a href="#38638625">parent</a><span>|</span><a href="#38638973">next</a><span>|</span><label class="collapse" for="c-38639254">[-]</label><label class="expand" for="c-38639254">[1 more]</label></div><br/><div class="children"><div class="content">check if: if any one of those fails, the entire authorization fails
allow if&#x2F;deny if: they are tried in order, we stop at the first that matches. If an allow if matches and all checks passed, then the request is authorized</div><br/></div></div></div></div><div id="38638973" class="c"><input type="checkbox" id="c-38638973" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#38638625">prev</a><span>|</span><a href="#38638711">next</a><span>|</span><label class="collapse" for="c-38638973">[-]</label><label class="expand" for="c-38638973">[1 more]</label></div><br/><div class="children"><div class="content">After cookies, now we have biscuits. How about some Tiramisu?</div><br/></div></div><div id="38638711" class="c"><input type="checkbox" id="c-38638711" checked=""/><div class="controls bullet"><span class="by">bluepuma77</span><span>|</span><a href="#38638973">prev</a><span>|</span><a href="#38636968">next</a><span>|</span><label class="collapse" for="c-38638711">[-]</label><label class="expand" for="c-38638711">[3 more]</label></div><br/><div class="children"><div class="content">Interesting to see<p>&quot;Portable - Biscuit is implemented in Rust, Haskell, Go, Java, WebAssembly, C...&quot;<p>but nothing about Javascript, NodeJS and Python, which seem very common these days.</div><br/><div id="38639009" class="c"><input type="checkbox" id="c-38639009" checked=""/><div class="controls bullet"><span class="by">Lio</span><span>|</span><a href="#38638711">parent</a><span>|</span><a href="#38638866">next</a><span>|</span><label class="collapse" for="c-38639009">[-]</label><label class="expand" for="c-38639009">[1 more]</label></div><br/><div class="children"><div class="content">According to their docs, the NodeJS and Python libraries seem to be wrappers around the Rust implementation.<p>In the case of NodeJS they&#x27;re using WebAssembly to run the compiled Rust code, which is an interesting approach.<p>If they&#x27;re just going to wrap the rust implementation, I&#x27;m surprised they haven&#x27;t offered Ruby FFI or PHP FFI wrappers too.</div><br/></div></div><div id="38638866" class="c"><input type="checkbox" id="c-38638866" checked=""/><div class="controls bullet"><span class="by">ptman</span><span>|</span><a href="#38638711">parent</a><span>|</span><a href="#38639009">prev</a><span>|</span><a href="#38636968">next</a><span>|</span><label class="collapse" for="c-38638866">[-]</label><label class="expand" for="c-38638866">[1 more]</label></div><br/><div class="children"><div class="content">webassembly may be useable in many javascript environments</div><br/></div></div></div></div><div id="38636968" class="c"><input type="checkbox" id="c-38636968" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#38638711">prev</a><span>|</span><a href="#38637249">next</a><span>|</span><label class="collapse" for="c-38636968">[-]</label><label class="expand" for="c-38636968">[7 more]</label></div><br/><div class="children"><div class="content">A better explainer: <a href="https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;blog&#x2F;engineering&#x2F;2021&#x2F;04&#x2F;12&#x2F;introduction-to-biscuit&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;blog&#x2F;engineering&#x2F;2021&#x2F;04&#x2F;12&#x2F;int...</a></div><br/><div id="38637049" class="c"><input type="checkbox" id="c-38637049" checked=""/><div class="controls bullet"><span class="by">gnabgib</span><span>|</span><a href="#38636968">parent</a><span>|</span><a href="#38637249">next</a><span>|</span><label class="collapse" for="c-38637049">[-]</label><label class="expand" for="c-38637049">[6 more]</label></div><br/><div class="children"><div class="content">Somewhat?  Browser cookies can literally contain anything (not just session identifiers, or authentication tokens), I&#x27;ve only heard JWT pronounced &quot;Jay-double you-tea&quot; (but maybe that&#x27;s regional), Macaroons[0] and Maracrons[1] are French (given clever-cloud is french, this is strange), OPA doesn&#x27;t need to be server side.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Macaroon" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Macaroon</a>
[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Macaron" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Macaron</a></div><br/><div id="38637259" class="c"><input type="checkbox" id="c-38637259" checked=""/><div class="controls bullet"><span class="by">brontitall</span><span>|</span><a href="#38636968">root</a><span>|</span><a href="#38637049">parent</a><span>|</span><a href="#38637913">next</a><span>|</span><label class="collapse" for="c-38637259">[-]</label><label class="expand" for="c-38637259">[4 more]</label></div><br/><div class="children"><div class="content">I think the RFC pronunciation guide<p>&gt; the same as the English word &quot;jot&quot;.<p>Only makes sense if your dialect has the cot-caught merger[0]<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cot%E2%80%93caught_merger" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cot%E2%80%93caught_merger</a></div><br/><div id="38637634" class="c"><input type="checkbox" id="c-38637634" checked=""/><div class="controls bullet"><span class="by">gnabgib</span><span>|</span><a href="#38636968">root</a><span>|</span><a href="#38637259">parent</a><span>|</span><a href="#38637409">next</a><span>|</span><label class="collapse" for="c-38637634">[-]</label><label class="expand" for="c-38637634">[2 more]</label></div><br/><div class="children"><div class="content">You skipped an important part of the quote from RFC-7519[0] (later replaced by two RFCs[1],[2] without the strange suggestion):<p>&gt; <i>The suggested pronunciation of JWT is</i> the same as the English word &quot;jot&quot;.<p>Replaced by RFC-7797[1] and RFC-8725[2], neither of which have the pronunciation suggestion.  There was also an errata about the pronunciation line[3], which probably explains the mismatch.<p>[0]: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7519" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7519</a>
[1]: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7797" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7797</a>
[2]: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8725" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8725</a>
[3]: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;errata&#x2F;eid5648" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;errata&#x2F;eid5648</a></div><br/><div id="38638725" class="c"><input type="checkbox" id="c-38638725" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#38636968">root</a><span>|</span><a href="#38637634">parent</a><span>|</span><a href="#38637409">next</a><span>|</span><label class="collapse" for="c-38638725">[-]</label><label class="expand" for="c-38638725">[1 more]</label></div><br/><div class="children"><div class="content">Those RFCs donât replace 7519, they are extensions and best practices. âJotâ is still indeed the intended pronunciation, whether you like it or not.</div><br/></div></div></div></div><div id="38637409" class="c"><input type="checkbox" id="c-38637409" checked=""/><div class="controls bullet"><span class="by">airstrike</span><span>|</span><a href="#38636968">root</a><span>|</span><a href="#38637259">parent</a><span>|</span><a href="#38637634">prev</a><span>|</span><a href="#38637913">next</a><span>|</span><label class="collapse" for="c-38637409">[-]</label><label class="expand" for="c-38637409">[1 more]</label></div><br/><div class="children"><div class="content">Only <i>barely</i> makes sense, you mean. And only if you squint...</div><br/></div></div></div></div><div id="38637913" class="c"><input type="checkbox" id="c-38637913" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#38636968">root</a><span>|</span><a href="#38637049">parent</a><span>|</span><a href="#38637259">prev</a><span>|</span><a href="#38637249">next</a><span>|</span><label class="collapse" for="c-38637913">[-]</label><label class="expand" for="c-38637913">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve only heard JWT pronounced &quot;Jay-double you-tea&quot;<p>That doesn&#x27;t save any effort over &quot;JSON web token&quot;.</div><br/></div></div></div></div></div></div><div id="38637249" class="c"><input type="checkbox" id="c-38637249" checked=""/><div class="controls bullet"><span class="by">throwoutway</span><span>|</span><a href="#38636968">prev</a><span>|</span><a href="#38636976">next</a><span>|</span><label class="collapse" for="c-38637249">[-]</label><label class="expand" for="c-38637249">[8 more]</label></div><br/><div class="children"><div class="content">Reminds me of macaroons.  Has anyone done a comparison?<p><a href="https:&#x2F;&#x2F;backstage.forgerock.com&#x2F;docs&#x2F;am&#x2F;7&#x2F;oauth2-guide&#x2F;oauth2-macaroons.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;backstage.forgerock.com&#x2F;docs&#x2F;am&#x2F;7&#x2F;oauth2-guide&#x2F;oauth...</a><p><a href="https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;macaroons-cookies-with-contextual-caveats-for-decentralized-authorization-in-the-cloud&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;macaroons-cookies-with-contextu...</a></div><br/><div id="38637412" class="c"><input type="checkbox" id="c-38637412" checked=""/><div class="controls bullet"><span class="by">arnarbi</span><span>|</span><a href="#38637249">parent</a><span>|</span><a href="#38637453">next</a><span>|</span><label class="collapse" for="c-38637412">[-]</label><label class="expand" for="c-38637412">[3 more]</label></div><br/><div class="children"><div class="content">(author of the paper in your second link, which the Biscuit spec also references)<p>Macaroons are an abstract thing. They don&#x27;t define an encoding format, nor any semantics or language for the caveats. So a lot of detail is left up to the implementer, which is why they&#x27;re fairly hard to use. Their basic form is also built on symemtric keys and hmacs, so only the issuer can verify, which is a significant limitation in the real world.<p>AFAICT Biscuits define those (protobuf for encoding, a logic language for the caveats) and use public keys instead to allow other parties than the issuer (=holder of the root key) to verify them.</div><br/><div id="38637931" class="c"><input type="checkbox" id="c-38637931" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38637249">root</a><span>|</span><a href="#38637412">parent</a><span>|</span><a href="#38637453">next</a><span>|</span><label class="collapse" for="c-38637931">[-]</label><label class="expand" for="c-38637931">[2 more]</label></div><br/><div class="children"><div class="content">That abstraction is also a strength. I think one of the reasons Macaroons really resonate with security engineers is that the underlying cryptography is simple and user-proof, and the resulting formats and protocols are super flexibleâ , which is not a combination you typically get with cryptosystems. It&#x27;s also one of the truly great security papers; having worked with a team for a year scaling them out, I get something new every time I read it. My only quibble is the internal naming (&quot;CID&quot;, &quot;VID&quot;).<p>We&#x27;re doing a big-ass blog post as we speak about how our Macaroon tokens work, and it covers how we worked around the issuer&#x2F;verifier constraint (spoiler: a litefs-backed replicated isolated internal API) and we did basic stuff like encoding (spoiler: we defined a rigid struct schema, and just MsgPack&#x27;d it).<p>One of the things I think I have to say about Macaroons is that there&#x27;s a sliding scale of how much you use it; I think there are some simple ideas in them that would be pretty neat in any application&#x27;s authentication cookie scheme.<p>â  <i>Also one of a couple reasons, I think, that &quot;standard Macaroons&quot; and their associated libraries never went anywhere.</i></div><br/><div id="38638773" class="c"><input type="checkbox" id="c-38638773" checked=""/><div class="controls bullet"><span class="by">glenngillen</span><span>|</span><a href="#38637249">root</a><span>|</span><a href="#38637931">parent</a><span>|</span><a href="#38637453">next</a><span>|</span><label class="collapse" for="c-38638773">[-]</label><label class="expand" for="c-38638773">[1 more]</label></div><br/><div class="children"><div class="content">Iâm very intrigued and excited about this! I read your earlier post comparing schemes and saying after years beating the drum for macaroons, after trying to implement them, you wouldnât beat that drum any more. Have you come back around?</div><br/></div></div></div></div></div></div><div id="38637453" class="c"><input type="checkbox" id="c-38637453" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#38637249">parent</a><span>|</span><a href="#38637412">prev</a><span>|</span><a href="#38637439">next</a><span>|</span><label class="collapse" for="c-38637453">[-]</label><label class="expand" for="c-38637453">[2 more]</label></div><br/><div class="children"><div class="content">tptacek wrote up a rather nice comparative survey of the field, including Biscuits and Macaroons<p><a href="https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;api-tokens-a-tedious-survey">https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;api-tokens-a-tedious-survey</a></div><br/><div id="38637941" class="c"><input type="checkbox" id="c-38637941" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38637249">root</a><span>|</span><a href="#38637453">parent</a><span>|</span><a href="#38637439">next</a><span>|</span><label class="collapse" for="c-38637941">[-]</label><label class="expand" for="c-38637941">[1 more]</label></div><br/><div class="children"><div class="content">We also did an episode of the podcast with Geoffroy:<p><a href="https:&#x2F;&#x2F;securitycryptographywhatever.com&#x2F;2022&#x2F;01&#x2F;29&#x2F;biscuits-with-geoffroy-couprie&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;securitycryptographywhatever.com&#x2F;2022&#x2F;01&#x2F;29&#x2F;biscuits...</a></div><br/></div></div></div></div><div id="38637439" class="c"><input type="checkbox" id="c-38637439" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#38637249">parent</a><span>|</span><a href="#38637453">prev</a><span>|</span><a href="#38636976">next</a><span>|</span><label class="collapse" for="c-38637439">[-]</label><label class="expand" for="c-38637439">[2 more]</label></div><br/><div class="children"><div class="content">I remember seeing a talk[1] at Gophercon a while back on how nightmarish macaroons were to implement.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MZFv62qz8RU" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=MZFv62qz8RU</a></div><br/><div id="38637978" class="c"><input type="checkbox" id="c-38637978" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38637249">root</a><span>|</span><a href="#38637439">parent</a><span>|</span><a href="#38636976">next</a><span>|</span><label class="collapse" for="c-38637978">[-]</label><label class="expand" for="c-38637978">[1 more]</label></div><br/><div class="children"><div class="content">First, I don&#x27;t think that&#x27;s a good characterization of the talk.<p>Second, I&#x27;m not sure (based on the talk) that I see how they had any of the problems that Macaroons solve.<p>Third, I think a lot of the trouble they ran into feels like generic &quot;we built our own token system&quot; stuff; for instance, they backed themselves into designing a refresh token system (all their Macaroons had a third-party caveat discharged by their central Rails app, which, without any extra context, seems like a weird choice); similarly, they ran into revocation problems, which they addressed by routing all their requests through their Rails application --- these are just standard &quot;stateless token&quot; problems that you&#x27;d run into with a custom JWT solution as well!<p>(They also issued a whole bunch of long-expiry stateless tokens, and then had to wait forever to transform them to their new tokens, which is a problem every token and stateless cookie implementer has had to deal with).<p>I feel like they kind of went &quot;full Macaroon&quot;, exercising all the features described in the paper, some of which weren&#x27;t good fits for their problems.<p>We wrote a survey of auth tokens (it&#x27;s linked upthread) a year or so ago, and I mentioned this talk, and I remember at the time that it made a dent with me. But we&#x27;ve spent a year rolling out Macaroons and gotten real-world experience with them, and in the course of writing that up I re-watched the talk and was much less persuaded by it --- in particular, I found that much of it was less a critique of Macaroons and more just a good war story about rolling out <i>any</i> custom stateless token scheme.</div><br/></div></div></div></div></div></div><div id="38636976" class="c"><input type="checkbox" id="c-38636976" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#38637249">prev</a><span>|</span><a href="#38637788">next</a><span>|</span><label class="collapse" for="c-38636976">[-]</label><label class="expand" for="c-38636976">[8 more]</label></div><br/><div class="children"><div class="content">The offline attenuation concept is really cool. I wonder how many chained attenuations you could perform before you start to run into practical limitations with storing  them attenuated token in cookies, etc.</div><br/><div id="38637414" class="c"><input type="checkbox" id="c-38637414" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#38636976">parent</a><span>|</span><a href="#38637517">next</a><span>|</span><label class="collapse" for="c-38637414">[-]</label><label class="expand" for="c-38637414">[6 more]</label></div><br/><div class="children"><div class="content">It sounds neat - but in-practice it&#x27;s something other schemes have had for yonks, albeit centralized instead of being entirely at the discretion of the subject (e.g. OAuth2&#x27;s delegation grant), and there&#x27;s the obvious risk of someone&#x27;s token being used to counter-sign or delegate permission without their knowledge (this isn&#x27;t unrealistic considering the sheer number of daily posters to StackOverflow who think browser&#x27;s localStorage is an acceptable place to hold secrets and keys...).</div><br/><div id="38638575" class="c"><input type="checkbox" id="c-38638575" checked=""/><div class="controls bullet"><span class="by">forgotusername6</span><span>|</span><a href="#38636976">root</a><span>|</span><a href="#38637414">parent</a><span>|</span><a href="#38637988">next</a><span>|</span><label class="collapse" for="c-38638575">[-]</label><label class="expand" for="c-38638575">[1 more]</label></div><br/><div class="children"><div class="content">Where should web pages store secrets and keys?</div><br/></div></div><div id="38637988" class="c"><input type="checkbox" id="c-38637988" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38636976">root</a><span>|</span><a href="#38637414">parent</a><span>|</span><a href="#38638575">prev</a><span>|</span><a href="#38637517">next</a><span>|</span><label class="collapse" for="c-38637988">[-]</label><label class="expand" for="c-38637988">[4 more]</label></div><br/><div class="children"><div class="content">What do you mean? How do you do an offline attenuation of an OAuth2 token?</div><br/><div id="38638179" class="c"><input type="checkbox" id="c-38638179" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#38636976">root</a><span>|</span><a href="#38637988">parent</a><span>|</span><a href="#38637517">next</a><span>|</span><label class="collapse" for="c-38638179">[-]</label><label class="expand" for="c-38638179">[3 more]</label></div><br/><div class="children"><div class="content">You canât do it offline; but in practice that isnât a problem because IdPs generally are five-nines available.</div><br/><div id="38638271" class="c"><input type="checkbox" id="c-38638271" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38636976">root</a><span>|</span><a href="#38638179">parent</a><span>|</span><a href="#38637517">next</a><span>|</span><label class="collapse" for="c-38638271">[-]</label><label class="expand" for="c-38638271">[2 more]</label></div><br/><div class="children"><div class="content">No, it is a problem, because the motivating use case for offline attenuation is doing JIT minimization of tokens before sending them. IdP OAuth2 tokens tend to be all-powerful, a game-over break if stolen. That&#x27;s why offline attenuation was invented.<p>You can say that offline attenuation and minimization doesn&#x27;t matter; for a lot of applications, it probably doesn&#x27;t. But you can&#x27;t say OAuth2 has the same feature, and certainly not &quot;had for yonks&quot;.</div><br/><div id="38638943" class="c"><input type="checkbox" id="c-38638943" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#38636976">root</a><span>|</span><a href="#38638271">parent</a><span>|</span><a href="#38637517">next</a><span>|</span><label class="collapse" for="c-38638943">[-]</label><label class="expand" for="c-38638943">[1 more]</label></div><br/><div class="children"><div class="content">You can of course use Macaroons <i>with</i> OAuth, which was something that I tried to get the OAuth WG interested in, with little success. But I did get it added to my then employerâs AS product: <a href="https:&#x2F;&#x2F;neilmadden.blog&#x2F;2020&#x2F;07&#x2F;29&#x2F;least-privilege-with-less-effort-macaroon-access-tokens-in-am-7-0&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;neilmadden.blog&#x2F;2020&#x2F;07&#x2F;29&#x2F;least-privilege-with-less...</a><p>(Not sure why the images in that post are suddenly broken, will try to fix later).<p>This also reminds me that I need to finish off my own take on Biscuits&#x2F;Macaroons that takes a <i>completely</i> different approach based on Diffie-Hellman. I call them Florentines.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38637517" class="c"><input type="checkbox" id="c-38637517" checked=""/><div class="controls bullet"><span class="by">moribvndvs</span><span>|</span><a href="#38636976">parent</a><span>|</span><a href="#38637414">prev</a><span>|</span><a href="#38637788">next</a><span>|</span><label class="collapse" for="c-38637517">[-]</label><label class="expand" for="c-38637517">[1 more]</label></div><br/><div class="children"><div class="content">I agree, the current OAuth2&#x2F;OIDC path of having to inline a non-standard (at the moment) token exchange grant absolutely sucks.</div><br/></div></div></div></div><div id="38637788" class="c"><input type="checkbox" id="c-38637788" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#38636976">prev</a><span>|</span><label class="collapse" for="c-38637788">[-]</label><label class="expand" for="c-38637788">[4 more]</label></div><br/><div class="children"><div class="content">&gt; All you need for a new implementation is a Protobuf generator<p>Nope. I will never touch anything that uses protobuf. The fact that it&#x27;s not self describing (and pointlessly so) is instant deal breaker. Anyone who&#x27;s ever looked into parsing the wire format knows what an awful standard it is.</div><br/><div id="38639295" class="c"><input type="checkbox" id="c-38639295" checked=""/><div class="controls bullet"><span class="by">geal</span><span>|</span><a href="#38637788">parent</a><span>|</span><a href="#38638007">next</a><span>|</span><label class="collapse" for="c-38639295">[-]</label><label class="expand" for="c-38639295">[1 more]</label></div><br/><div class="children"><div class="content">(biscuit author here) I tried a lot of different formats, especially looking for something that generated small tokens, that could have a canonical form, and that was supported in a lot of languages. The canonical part was a dead end as most formats did not support that well. Protobuf ended up being the one which generated the smallest tokens, and was easily supported in most languages, even if, like you, I don&#x27;t agree with everything in the way it&#x27;s serialized.
Self describing formats were a dead end as well because it grows the token size</div><br/></div></div><div id="38638007" class="c"><input type="checkbox" id="c-38638007" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#38637788">parent</a><span>|</span><a href="#38639295">prev</a><span>|</span><a href="#38638270">next</a><span>|</span><label class="collapse" for="c-38638007">[-]</label><label class="expand" for="c-38638007">[1 more]</label></div><br/><div class="children"><div class="content">Why do we feel using variable length integers in protobuf&#x27;s wire format vs strings is an instant deal breaker? Isn&#x27;t understanding a protocol is going to require a more documentation than just a string field name? The kind of documentation that can often be found as comments in a protocol buffer definition file?<p>Having written a binary serialization format that <i>does</i> make the choice to use strings for field identifiers on the wire (<a href="https:&#x2F;&#x2F;litevectors.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;litevectors.org</a>), I can still see the appeal of using integers - they&#x27;re smaller and parse faster. I&#x27;ve used protocol buffers in several places, including in an embedded microcontroller where parsing something like JSON would have been a lift. Aside from some issues with the impact of deeply nested buffers on the stack size, protocol buffers worked brilliantly, and allowed us to keep a consistent data representation across multiple languages and platforms.</div><br/></div></div><div id="38638270" class="c"><input type="checkbox" id="c-38638270" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#38637788">parent</a><span>|</span><a href="#38638007">prev</a><span>|</span><label class="collapse" for="c-38638270">[-]</label><label class="expand" for="c-38638270">[1 more]</label></div><br/><div class="children"><div class="content">What do you use instead?</div><br/></div></div></div></div></div></div></div></div></div></body></html>