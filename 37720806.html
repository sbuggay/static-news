<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696150859561" as="style"/><link rel="stylesheet" href="styles.css?v=1696150859561"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://embeddedartistry.com/blog/2017/05/22/werror-is-not-your-friend/">-Werror Is not your friend (2017)</a> <span class="domain">(<a href="https://embeddedartistry.com">embeddedartistry.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>66 comments</span></div><br/><div><div id="37721391" class="c"><input type="checkbox" id="c-37721391" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#37721613">next</a><span>|</span><label class="collapse" for="c-37721391">[-]</label><label class="expand" for="c-37721391">[17 more]</label></div><br/><div class="children"><div class="content">Within a company (at least in my experience) compilers&#x2F;toolchains are changed infrequently, usually less than once a year. In this case, keeping the software building with -Werror is a heck of a lot easier than allowing warnings to creep in, then trying to fix it later. It ends up that “later” never happens. Using -Werror from the very beginning forces you to address warnings: either by silencing obviously false positives, or fixing legitimate problems.<p>A previous company I worked at had large C++ projects that built with 5000+ warnings. Nobody looked at them, obviously. Buried within them I recall one about printf-style formatting string mismatching arguments, that said something like “mismatching arguments will cause a crash if this code is executed.” I only noticed it buried in the list of warnings after debugging a segfault caused by that line of code.</div><br/><div id="37721638" class="c"><input type="checkbox" id="c-37721638" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#37721391">parent</a><span>|</span><a href="#37721558">next</a><span>|</span><label class="collapse" for="c-37721638">[-]</label><label class="expand" for="c-37721638">[5 more]</label></div><br/><div class="children"><div class="content">I feel like you&#x27;re replying to the title and not the article. The article starts with a huge disclaimer saying that the author has no tolerance for warnings getting merged in to their projects, but they have the warnings check in the CI pipeline. Doing that would totally prevent the kind of lax never-fixed errors you&#x27;re talking about, while allowing more flexibility while the PR is still in progress.</div><br/><div id="37721689" class="c"><input type="checkbox" id="c-37721689" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721638">parent</a><span>|</span><a href="#37721842">next</a><span>|</span><label class="collapse" for="c-37721689">[-]</label><label class="expand" for="c-37721689">[2 more]</label></div><br/><div class="children"><div class="content">That’s fair, I’m responding more to the general aversion to using -Werror at all than the specific case of the OP. If I were writing open source software expected to be used by a wide variety of compilers and platforms I’d probably also not want to make -Werror the default.</div><br/><div id="37722883" class="c"><input type="checkbox" id="c-37722883" checked=""/><div class="controls bullet"><span class="by">TheGoddessInari</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721689">parent</a><span>|</span><a href="#37721842">next</a><span>|</span><label class="collapse" for="c-37722883">[-]</label><label class="expand" for="c-37722883">[1 more]</label></div><br/><div class="children"><div class="content">As an anecdote, there may be one or two packages in openwrt that won&#x27;t build by default because of a strange interaction between certain glibc headers and the behavior of _FORTIFY_SOURCE on some embedded platforms, but only on some versions of gcc.<p>Werror tends to be placed eagerly pass the buck along to anyone building it, not just CI or developers. I used to feel that Werror was a good thing, but nowadays anything with CI on merge requests will tell me about any warnings, and someone wanting to build the software shouldn&#x27;t get penalized for having a different build environment: there&#x27;s a reason they aren&#x27;t thrown as errors to begin with. Does this make sense?</div><br/></div></div></div></div><div id="37721842" class="c"><input type="checkbox" id="c-37721842" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721638">parent</a><span>|</span><a href="#37721689">prev</a><span>|</span><a href="#37721558">next</a><span>|</span><label class="collapse" for="c-37721842">[-]</label><label class="expand" for="c-37721842">[2 more]</label></div><br/><div class="children"><div class="content">Yeah the author doesn&#x27;t agree with his own title :)</div><br/><div id="37723051" class="c"><input type="checkbox" id="c-37723051" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721842">parent</a><span>|</span><a href="#37721558">next</a><span>|</span><label class="collapse" for="c-37723051">[-]</label><label class="expand" for="c-37723051">[1 more]</label></div><br/><div class="children"><div class="content">He says -Werror is CI&#x27;s friend, not dev&#x27;s.</div><br/></div></div></div></div></div></div><div id="37721558" class="c"><input type="checkbox" id="c-37721558" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37721391">parent</a><span>|</span><a href="#37721638">prev</a><span>|</span><a href="#37721473">next</a><span>|</span><label class="collapse" for="c-37721558">[-]</label><label class="expand" for="c-37721558">[5 more]</label></div><br/><div class="children"><div class="content">I feel like every person who advocates for -Werror shows up to a codebase with a billion warnings once and then assumes that nobody can ever voluntarily keep their code compiling without warnings if they don’t have the build stop immediately so they can fix it.<p>I’ve worked on dozens of non-legacy codebases and in every single one we don’t have warnings last for long, because going from zero to a few warnings is annoying. I don’t want that spam in my logs and I definitely don’t want suspicious constructs in my codebase. For the ones that enable -Werror, by the way, I always disable it so I can work and clean things up before committing. It’s just basic hygiene and discipline, the same as formatting your code before sending a PR. If your team doesn’t have that then it has bigger problems.</div><br/><div id="37722053" class="c"><input type="checkbox" id="c-37722053" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721558">parent</a><span>|</span><a href="#37721811">next</a><span>|</span><label class="collapse" for="c-37722053">[-]</label><label class="expand" for="c-37722053">[2 more]</label></div><br/><div class="children"><div class="content">It sounds like you don&#x27;t want your compiler to stop on errors, but rather, you want your <i>CI</i> to recognize errors, and to prevent the <i>merging</i> of feature branches that have any warnings.</div><br/><div id="37722087" class="c"><input type="checkbox" id="c-37722087" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37722053">parent</a><span>|</span><a href="#37721811">next</a><span>|</span><label class="collapse" for="c-37722087">[-]</label><label class="expand" for="c-37722087">[1 more]</label></div><br/><div class="children"><div class="content">Maybe this is what you&#x27;re saying, but to have CI prevent the <i>merging</i> of feature branches that introduce <i>new</i> warnings? That&#x27;s my favorite setup for introducing lint or lint rules to a large codebase.</div><br/></div></div></div></div><div id="37721811" class="c"><input type="checkbox" id="c-37721811" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721558">parent</a><span>|</span><a href="#37722053">prev</a><span>|</span><a href="#37721473">next</a><span>|</span><label class="collapse" for="c-37721811">[-]</label><label class="expand" for="c-37721811">[2 more]</label></div><br/><div class="children"><div class="content">How many people were involved in this codebase at a given time and how many years was the project ongoing?</div><br/><div id="37721961" class="c"><input type="checkbox" id="c-37721961" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721811">parent</a><span>|</span><a href="#37721473">next</a><span>|</span><label class="collapse" for="c-37721961">[-]</label><label class="expand" for="c-37721961">[1 more]</label></div><br/><div class="children"><div class="content">Professionally the ones that did this had between 2-200 engineers working on them at any given time. Most code was a decade or so old, with some legacy components that were older or vendored (but in many cases were not touched much and may have certain warnings disabled). iOS-focused, so Swift, Objective-C, C++ in Xcode.<p>In open source projects most of the ones I work on have a handful of regular contributors and a couple dozen one-off or other irregular contributions. In many cases we don&#x27;t get <i>all</i> the warnings on every system that anyone uses but if someone goes &quot;fix warnings for GCC 13 on Alpha&quot; or whatever environment they&#x27;re using we are more than happy to take their changes, and if it warns in CI or on any of our machines we&#x27;ll either bring it up during PR review or submit a change soon afterwards to fix it. I&#x27;m too young to have projects more than a few years old but there&#x27;s a decent number of other open source projects with a long history and many contributors that compile with no warnings on say their Linux CI and maybe a handful if you pass it through Apple Clang (since they don&#x27;t test that much).</div><br/></div></div></div></div></div></div><div id="37721473" class="c"><input type="checkbox" id="c-37721473" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#37721391">parent</a><span>|</span><a href="#37721558">prev</a><span>|</span><a href="#37721596">next</a><span>|</span><label class="collapse" for="c-37721473">[-]</label><label class="expand" for="c-37721473">[2 more]</label></div><br/><div class="children"><div class="content">&gt; either by silencing obviously false positives<p>(Off-topic) Oh how I wish this were possible in the language I use at $dayjob. Swift does not let you silence warnings on a line by line basis. It’s easily one of the top 5 worst things about the language.</div><br/><div id="37721530" class="c"><input type="checkbox" id="c-37721530" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721473">parent</a><span>|</span><a href="#37721596">next</a><span>|</span><label class="collapse" for="c-37721530">[-]</label><label class="expand" for="c-37721530">[1 more]</label></div><br/><div class="children"><div class="content">This would allow you to make a dialect where you call a function that Apple in their infinite wisdom has deprecated. Consider the tax this would impose on the ecosystem!</div><br/></div></div></div></div><div id="37721596" class="c"><input type="checkbox" id="c-37721596" checked=""/><div class="controls bullet"><span class="by">crustaceansoup</span><span>|</span><a href="#37721391">parent</a><span>|</span><a href="#37721473">prev</a><span>|</span><a href="#37721577">next</a><span>|</span><label class="collapse" for="c-37721596">[-]</label><label class="expand" for="c-37721596">[2 more]</label></div><br/><div class="children"><div class="content">Are there companies which would allow or suggest employees or contractors just use whatever random toolchain they have installed?<p>I can understand the argument for open-source projects that aren&#x27;t attached to a company, but otherwise? Maybe this is my bias being in a subindustry centered on distributed binaries and so have set standard toolchains (i.e. what the build machines use), but I&#x27;m still not seeing it. This seems like the more harmful practice than using -Werror</div><br/><div id="37721975" class="c"><input type="checkbox" id="c-37721975" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37721391">root</a><span>|</span><a href="#37721596">parent</a><span>|</span><a href="#37721577">next</a><span>|</span><label class="collapse" for="c-37721975">[-]</label><label class="expand" for="c-37721975">[1 more]</label></div><br/><div class="children"><div class="content">Most companies I have worked at have a specific compile script that everyone uses and they don&#x27;t mind if you use something else as long as you aren&#x27;t causing problems for everyone else. I typically run pre-release toolchains to spot errors early for example, or sometimes I&#x27;ll swap out the compiler to test things.<p>Obviously, what gets built and deployed to production is not built off my computer; it goes through the standard CI they have.</div><br/></div></div></div></div><div id="37721577" class="c"><input type="checkbox" id="c-37721577" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#37721391">parent</a><span>|</span><a href="#37721596">prev</a><span>|</span><a href="#37721645">next</a><span>|</span><label class="collapse" for="c-37721577">[-]</label><label class="expand" for="c-37721577">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly why the author says to check for warnings in CI. Most warnings will be noticed and fixed by the dev before pushing, and the rare ones that get missed will be caught in CI before merging.</div><br/></div></div><div id="37721645" class="c"><input type="checkbox" id="c-37721645" checked=""/><div class="controls bullet"><span class="by">bluedino</span><span>|</span><a href="#37721391">parent</a><span>|</span><a href="#37721577">prev</a><span>|</span><a href="#37721613">next</a><span>|</span><label class="collapse" for="c-37721645">[-]</label><label class="expand" for="c-37721645">[1 more]</label></div><br/><div class="children"><div class="content">Interview question (from the job seeker): can I see your application logs?<p>I once worked at a place that could flood the error&#x2F;warning logs in two seconds (Ruby). Unless it was causing an issue, all warnings etc were ignored.<p>Is that the kind of codebase you want to work in?</div><br/></div></div></div></div><div id="37721613" class="c"><input type="checkbox" id="c-37721613" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37721391">prev</a><span>|</span><a href="#37722108">next</a><span>|</span><label class="collapse" for="c-37721613">[-]</label><label class="expand" for="c-37721613">[1 more]</label></div><br/><div class="children"><div class="content">What you really want for working on a large scale codebase is &quot;don&#x27;t allow changes that introduce new warnings&quot;. And with current tooling that&#x27;s something you can only really enforce at CI level if at all, but it shouldn&#x27;t be that way. I&#x27;d like to have the same thing early in the test-edit cycle - compiling with a newer compiler that adds more warnings shouldn&#x27;t be an error, but a code change that triggers a new warning should be.</div><br/></div></div><div id="37722108" class="c"><input type="checkbox" id="c-37722108" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37721613">prev</a><span>|</span><a href="#37723872">next</a><span>|</span><label class="collapse" for="c-37722108">[-]</label><label class="expand" for="c-37722108">[1 more]</label></div><br/><div class="children"><div class="content">This is better understood when writing websites. A website shouldn’t be tied to a particular browser vendor or a particular browser version. Browsers don’t have any mechanism similar to -Werror because it would be a “break if the user upgrades their browser” flag. (There is “use strict” but it doesn’t become stricter with browser upgrades.)<p>Similarly, let’s say we’re talking about an open source project that users may download and compile from source. A portable open source project shouldn’t needlessly break if you use a newer or different compiler.<p>So:<p>- Do make the source code as clean as you can, using all tools available, including -Werror. Putting -Werror in your continuous build should be fine too.<p>- When a user downloads your library and compiles it in order to use it, the make target (or equivalent) that <i>they</i> use shouldn’t compile with -Werror, because we don’t know which compiler they have or which warnings that enables.</div><br/></div></div><div id="37723872" class="c"><input type="checkbox" id="c-37723872" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#37722108">prev</a><span>|</span><a href="#37721324">next</a><span>|</span><label class="collapse" for="c-37723872">[-]</label><label class="expand" for="c-37723872">[1 more]</label></div><br/><div class="children"><div class="content">werror is absolutely your friend. The examples given in the article are borderline strawmen.<p>Changing toolchains is a very rare occurrence because the subtle differences will almost always cause problems. When someone suggests changing toolchains, they owe everyone a VERY CONVINCING argument. After which the changed warnings will be the LEAST of your problems as you migrate.<p>Toolchain upgrades will cause new warnings to surface as the detection gets better. But you DO want to fix them, don&#x27;t you? You ARE a professional, aren&#x27;t you? You DO care about your product&#x27;s quality, don&#x27;t you?<p>After over a decade without werror, followed by a decade with werror, I&#x27;d take werror every time. Warnings exist for a reason, and in the case of C compilers, VERY GOOD reasons that you really should address.<p>At my workplace, we use werror, static analysis, various lints, detekt... everything that can issue warnings about your code quality. If any of them complain, you can&#x27;t merge your PR, because we&#x27;re professionals.</div><br/></div></div><div id="37721324" class="c"><input type="checkbox" id="c-37721324" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37723872">prev</a><span>|</span><a href="#37721643">next</a><span>|</span><label class="collapse" for="c-37721324">[-]</label><label class="expand" for="c-37721324">[3 more]</label></div><br/><div class="children"><div class="content">I would make a &#x27;make dev&#x27; target with stuff like -Werror</div><br/><div id="37722047" class="c"><input type="checkbox" id="c-37722047" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#37721324">parent</a><span>|</span><a href="#37721343">next</a><span>|</span><label class="collapse" for="c-37722047">[-]</label><label class="expand" for="c-37722047">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, use it with your CI or test suite. Also `-Wd` for Python, and I&#x27;m sure there are equivalents for other toolchains&#x2F;languages.<p>IMHO it&#x27;s similar to the robustness principle&#x2F;Postel&#x27;s law: &quot;be conservative in what you send, be liberal in what you accept&quot;. Your build should pass without warnings on your system, but your build system should allow warnings on your customer&#x27;s system.</div><br/></div></div><div id="37721343" class="c"><input type="checkbox" id="c-37721343" checked=""/><div class="controls bullet"><span class="by">isilofi</span><span>|</span><a href="#37721324">parent</a><span>|</span><a href="#37722047">prev</a><span>|</span><a href="#37721643">next</a><span>|</span><label class="collapse" for="c-37721343">[-]</label><label class="expand" for="c-37721343">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. -Werror for the normal make target is problematic.<p>But -Werror for a dev target that e.g. CI uses to compile-test pull requests on known toolchains and distros that you explicitly intend to support is useful. The alternative would be tons of effort to skip -Werror but still have CI flag that pull request that introduces new warnings. Just having the build fail because -Werror is far simpler and less fragile.</div><br/></div></div></div></div><div id="37721643" class="c"><input type="checkbox" id="c-37721643" checked=""/><div class="controls bullet"><span class="by">nathan_compton</span><span>|</span><a href="#37721324">prev</a><span>|</span><a href="#37722573">next</a><span>|</span><label class="collapse" for="c-37721643">[-]</label><label class="expand" for="c-37721643">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t uh your build chain introduce a build chain dependency? Like each compiler compiles differently anyway, so if you care enough about warnings to have a zero warning policy, then don&#x27;t you also care about it on every platform&#x2F;build chain? I don&#x27;t get this.</div><br/><div id="37721765" class="c"><input type="checkbox" id="c-37721765" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#37721643">parent</a><span>|</span><a href="#37722573">next</a><span>|</span><label class="collapse" for="c-37721765">[-]</label><label class="expand" for="c-37721765">[1 more]</label></div><br/><div class="children"><div class="content">As someone in DevOps with very similar frustrations to those expressed in TFA, I think my main issue with it comes when the people maintaining the software (who added Werror) aren&#x27;t the ones spearheading the migration to a new Ubuntu LTS and therefore a new toolchain. That centralized strike force migration team now has to either fix everyone else&#x27;s piddly deprecations for them, or else have a way off temporarily patching out Werror until that work can be handed back to the original maintainers.</div><br/></div></div></div></div><div id="37722573" class="c"><input type="checkbox" id="c-37722573" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37721643">prev</a><span>|</span><a href="#37721583">next</a><span>|</span><label class="collapse" for="c-37722573">[-]</label><label class="expand" for="c-37722573">[4 more]</label></div><br/><div class="children"><div class="content">You should identify specify diagnostics that represent situations you don&#x27;t want in your code.<p>Then use -Werror=&lt;warning-name&gt; for each such diagnostic.<p>The problem there is that GCC fails if you give it an option it doesn&#x27;t recognize, including just a diagnostic one.<p>If you use -Werror=funky-new-warning, it will fail on an older GCC that doesn&#x27;t have funky-new-warning.</div><br/><div id="37723363" class="c"><input type="checkbox" id="c-37723363" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37722573">parent</a><span>|</span><a href="#37721583">next</a><span>|</span><label class="collapse" for="c-37723363">[-]</label><label class="expand" for="c-37723363">[3 more]</label></div><br/><div class="children"><div class="content">Blacklisting specific warnings is a bad idea. Instead you should `-Werror` <i>all</i> warnings by default and then whitelist specific ones with `-Wno-foo` of `-Wno-error=foo` if you don&#x27;t care about them.<p>To handle differences in GCC&#x2F;Clang flags you just have to detect the compiler (trivial with CMake), or dictate the compiler.<p>But <i>only</i> do that for your developers and CI. Don&#x27;t use `-Werror` for downstream users of your project.</div><br/><div id="37723538" class="c"><input type="checkbox" id="c-37723538" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37722573">root</a><span>|</span><a href="#37723363">parent</a><span>|</span><a href="#37723521">next</a><span>|</span><label class="collapse" for="c-37723538">[-]</label><label class="expand" for="c-37723538">[1 more]</label></div><br/><div class="children"><div class="content">Say I&#x27;ve decided in my project that shadowing is evil.  Why wouldn&#x27;t I turn on -Werror=shadow? Where is the bad idea?<p>Including downstream. I don&#x27;t want people writing me patches that trigger my pet warnings.<p>This is entirely compatible with the idea of locally only turning on -Werror, and then disabling certain warnings that you don&#x27;t intend to fix, without foisting -Werror onto downstream.<p>You can still have non-negotiable warnings that you turn on rather than off, and those do go downstream too.</div><br/></div></div></div></div></div></div><div id="37721583" class="c"><input type="checkbox" id="c-37721583" checked=""/><div class="controls bullet"><span class="by">emidln</span><span>|</span><a href="#37722573">prev</a><span>|</span><a href="#37721625">next</a><span>|</span><label class="collapse" for="c-37721583">[-]</label><label class="expand" for="c-37721583">[4 more]</label></div><br/><div class="children"><div class="content">Reifying the toolchain dependency is the point. If you don&#x27;t do this, you&#x27;re fucked anyway.</div><br/><div id="37721630" class="c"><input type="checkbox" id="c-37721630" checked=""/><div class="controls bullet"><span class="by">ploxiln</span><span>|</span><a href="#37721583">parent</a><span>|</span><a href="#37721625">next</a><span>|</span><label class="collapse" for="c-37721630">[-]</label><label class="expand" for="c-37721630">[3 more]</label></div><br/><div class="children"><div class="content">So, how have linux distros worked for the past 25 years? Many independent projects write commonly used libraries and&#x2F;or tools in C, and then each distro takes those and builds them with a slightly (or significantly!) different toolchain ... obviously it has worked pretty well. The pressure to work for all reasonable toolchains is <i>good</i> for software quality, instead of depending on quirks of a very particular toolchain to mask some bugs or nonstandard behavior dependency.</div><br/><div id="37721936" class="c"><input type="checkbox" id="c-37721936" checked=""/><div class="controls bullet"><span class="by">emidln</span><span>|</span><a href="#37721583">root</a><span>|</span><a href="#37721630">parent</a><span>|</span><a href="#37721625">next</a><span>|</span><label class="collapse" for="c-37721936">[-]</label><label class="expand" for="c-37721936">[2 more]</label></div><br/><div class="children"><div class="content">You bump the version gcc.spec in say, Fedora rawhide. What happens when random package foo doesnt compile with it? Foo is fixed or you skip that gcc version. Unless foo is very important and very hard to fix, you fix foo.<p>Distros already enforce a consistent toolchain. Arch, Debian, Fedora, Gentoo, etc.</div><br/><div id="37722937" class="c"><input type="checkbox" id="c-37722937" checked=""/><div class="controls bullet"><span class="by">ploxiln</span><span>|</span><a href="#37721583">root</a><span>|</span><a href="#37721936">parent</a><span>|</span><a href="#37721625">next</a><span>|</span><label class="collapse" for="c-37722937">[-]</label><label class="expand" for="c-37722937">[1 more]</label></div><br/><div class="children"><div class="content">A distro uses a consistent toolchain, but doesn&#x27;t write most of the code. The projects writing the vast bulk of the code, like linux, git, firefox, gtk, qt, openssl, curl, etc, don&#x27;t strictly control the toolchain, and it does vary between distros and distro releases.<p>Distros like Arch and Alpine keep the patching to a minimum, most packages need no patches. RedHat&#x2F;Fedora and Ubuntu do patch significantly more. Debian is in the middle ... there was an infamous incident where they patched openssl to fix an uninitialized-memory warning, and caused a huge security issue for many people: <a href="https:&#x2F;&#x2F;www.schneier.com&#x2F;blog&#x2F;archives&#x2F;2008&#x2F;05&#x2F;random_number_b.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.schneier.com&#x2F;blog&#x2F;archives&#x2F;2008&#x2F;05&#x2F;random_number...</a> (yes, openssl sucks, but still.)
So this is why distros take their cleanup patches upstream. Distro patches are for real observed bugs that aren&#x27;t fixed in an upstream release (or not in the desired major release branch), or to just disable -Werror in projects that don&#x27;t know better.</div><br/></div></div></div></div></div></div></div></div><div id="37721625" class="c"><input type="checkbox" id="c-37721625" checked=""/><div class="controls bullet"><span class="by">notnmeyer</span><span>|</span><a href="#37721583">prev</a><span>|</span><a href="#37723114">next</a><span>|</span><label class="collapse" for="c-37721625">[-]</label><label class="expand" for="c-37721625">[4 more]</label></div><br/><div class="children"><div class="content">seems like -Werror isn’t the problem as much as not having a codified&#x2F;reproducible build toolchain is.<p>there’s so many ways to skin that cat.</div><br/><div id="37721677" class="c"><input type="checkbox" id="c-37721677" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#37721625">parent</a><span>|</span><a href="#37723114">next</a><span>|</span><label class="collapse" for="c-37721677">[-]</label><label class="expand" for="c-37721677">[3 more]</label></div><br/><div class="children"><div class="content">In open source you don&#x27;t get that option. Where you have a known set of build tools it is easy to use -werror, and if a new toolchain is added someone gets assigned to clean it up.</div><br/><div id="37722011" class="c"><input type="checkbox" id="c-37722011" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#37721625">root</a><span>|</span><a href="#37721677">parent</a><span>|</span><a href="#37723114">next</a><span>|</span><label class="collapse" for="c-37722011">[-]</label><label class="expand" for="c-37722011">[2 more]</label></div><br/><div class="children"><div class="content">This only works if the maintainer cares enough. I’ve encountered maintainers who, bizarrely, are strict with “no warnings” but only when it comes to their preferred toolchain. Me: “Here’s a patch to get your project to compile cleanly using the Green Hills compiler targeting MIPS.” Maintainer: IDGAF. Rejected.</div><br/><div id="37724006" class="c"><input type="checkbox" id="c-37724006" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#37721625">root</a><span>|</span><a href="#37722011">parent</a><span>|</span><a href="#37723114">next</a><span>|</span><label class="collapse" for="c-37724006">[-]</label><label class="expand" for="c-37724006">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not been in the situation yet, but it makes sense to me.<p>Accepting a patch like that can be a significant commitment of time and brain power. &quot;What exactly does this fix? Does it actually fix it?&quot;. Such patches can be a lot more complicated than a straightforward new feature.<p>And then there&#x27;s that oddball compilers may not support everything gcc and clang do, so making them happy may actually mean sacrificing something.</div><br/></div></div></div></div></div></div></div></div><div id="37723114" class="c"><input type="checkbox" id="c-37723114" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#37721625">prev</a><span>|</span><a href="#37721931">next</a><span>|</span><label class="collapse" for="c-37723114">[-]</label><label class="expand" for="c-37723114">[2 more]</label></div><br/><div class="children"><div class="content">the real gist here is<p>&gt;&gt;&gt; We primarily use Clang, and it is a common occurrence that our CI server will report a warning when compiling our “warning-free” code with GCC.<p>...
my only point here is: FIX YOUR TOOL CHAIN
why do you want to use Clang if all your dependency relies on GCC?</div><br/><div id="37723136" class="c"><input type="checkbox" id="c-37723136" checked=""/><div class="controls bullet"><span class="by">packetslave</span><span>|</span><a href="#37723114">parent</a><span>|</span><a href="#37721931">next</a><span>|</span><label class="collapse" for="c-37723136">[-]</label><label class="expand" for="c-37723136">[1 more]</label></div><br/><div class="children"><div class="content">Google used to compile development builds with clang by default (better tooling and error messages) but production builds with GCC (better optimization).  I don&#x27;t know if they still do that.</div><br/></div></div></div></div><div id="37721931" class="c"><input type="checkbox" id="c-37721931" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#37723114">prev</a><span>|</span><a href="#37721742">next</a><span>|</span><label class="collapse" for="c-37721931">[-]</label><label class="expand" for="c-37721931">[3 more]</label></div><br/><div class="children"><div class="content">We use -Wall -Werror -Wextra -Weverything, plus we use clang-tidy with -Werror as well, plus we use ASan, TSan, MSan, UBSan, plus fuzzing (5+ different types of it), plus we update to the latest compiler on every release, so today it is clang-17, and we build every dependency from source, and always use hermetic builds (cross-compiling).<p>I think it is the only sane way for C++.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;</a></div><br/><div id="37721970" class="c"><input type="checkbox" id="c-37721970" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#37721931">parent</a><span>|</span><a href="#37722687">next</a><span>|</span><label class="collapse" for="c-37721970">[-]</label><label class="expand" for="c-37721970">[1 more]</label></div><br/><div class="children"><div class="content">-Weverything is explicitly not supported in clang and not supposed to produce working results.<p>Same in gcc, it will give you wrong warnings like -Wstrict-aliasing.</div><br/></div></div><div id="37722687" class="c"><input type="checkbox" id="c-37722687" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#37721931">parent</a><span>|</span><a href="#37721970">prev</a><span>|</span><a href="#37721742">next</a><span>|</span><label class="collapse" for="c-37722687">[-]</label><label class="expand" for="c-37722687">[1 more]</label></div><br/><div class="children"><div class="content">I don’t do -Weverything but generally most of the rest. I am in the maximum build hygiene camp, which means builds have to work across GCC and Clang, and x86-64 and ARM64, or they fail in CI. It finds quite a few compiler bugs as well as subtle code bugs.</div><br/></div></div></div></div><div id="37721742" class="c"><input type="checkbox" id="c-37721742" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#37721931">prev</a><span>|</span><a href="#37721562">next</a><span>|</span><label class="collapse" for="c-37721742">[-]</label><label class="expand" for="c-37721742">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;d be cool if I could have a code review view that&#x27;s instrumented with output from static analyzers. I know some places have this (FB&#x2F;Meta?) but I don&#x27;t think it&#x27;s a very &quot;out of the box&quot; kinda setup.</div><br/><div id="37723024" class="c"><input type="checkbox" id="c-37723024" checked=""/><div class="controls bullet"><span class="by">fh973</span><span>|</span><a href="#37721742">parent</a><span>|</span><a href="#37722709">next</a><span>|</span><label class="collapse" for="c-37723024">[-]</label><label class="expand" for="c-37723024">[1 more]</label></div><br/><div class="children"><div class="content">You can set this up with gerrit.</div><br/></div></div><div id="37722709" class="c"><input type="checkbox" id="c-37722709" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#37721742">parent</a><span>|</span><a href="#37723024">prev</a><span>|</span><a href="#37721562">next</a><span>|</span><label class="collapse" for="c-37722709">[-]</label><label class="expand" for="c-37722709">[1 more]</label></div><br/><div class="children"><div class="content">What about the GitHub checks view and API?</div><br/></div></div></div></div><div id="37721562" class="c"><input type="checkbox" id="c-37721562" checked=""/><div class="controls bullet"><span class="by">orwin</span><span>|</span><a href="#37721742">prev</a><span>|</span><a href="#37722146">next</a><span>|</span><label class="collapse" for="c-37721562">[-]</label><label class="expand" for="c-37721562">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good clickbait. I think i was tired and wanted to get outraged (well, what&#x27;s count as outraged to me, meaning shaking my head disapprovingly), i clicked on it then manage to agree with every points, and manage to learn something new with the &quot;Refined Warning-As-Error Control&quot; paragraph. Thank you author!</div><br/></div></div><div id="37722146" class="c"><input type="checkbox" id="c-37722146" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#37721562">prev</a><span>|</span><a href="#37721279">next</a><span>|</span><label class="collapse" for="c-37722146">[-]</label><label class="expand" for="c-37722146">[1 more]</label></div><br/><div class="children"><div class="content">&gt; aws.c:158:1: warning: control reaches end of non-void function [-Wreturn-type]<p>I prefer modern languages like Go, because all these warnings and errors are just
part of the default &quot;go build&quot;:<p><pre><code>    package hello
    
    func world() int {
       println(&quot;world&quot;)
    } &#x2F;&#x2F; hello.go:5:1: missing return</code></pre></div><br/></div></div><div id="37721279" class="c"><input type="checkbox" id="c-37721279" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37722146">prev</a><span>|</span><a href="#37721667">next</a><span>|</span><label class="collapse" for="c-37721279">[-]</label><label class="expand" for="c-37721279">[11 more]</label></div><br/><div class="children"><div class="content">The dependency on the toolchain should be made explicit and this issue goes away.<p>When updating the toolchain you can set default flags to disable the new warnings if you wish to fix each warning one a time.</div><br/><div id="37721364" class="c"><input type="checkbox" id="c-37721364" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37721279">parent</a><span>|</span><a href="#37721319">next</a><span>|</span><label class="collapse" for="c-37721364">[-]</label><label class="expand" for="c-37721364">[5 more]</label></div><br/><div class="children"><div class="content">Only in your controlled environment. When you publish something and it gets picked up by a distribution, it will fail. Sometimes even on a bug in a specific compiler version - Ubuntu had a GCC which sometimes picked up a `write()` result as unused and you couldn&#x27;t ignore&#x2F;dismiss in any way, so I had to carry patches for some project.</div><br/><div id="37721523" class="c"><input type="checkbox" id="c-37721523" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37721279">root</a><span>|</span><a href="#37721364">parent</a><span>|</span><a href="#37722309">next</a><span>|</span><label class="collapse" for="c-37721523">[-]</label><label class="expand" for="c-37721523">[3 more]</label></div><br/><div class="children"><div class="content">If the project is an “executable” then the toolchain dependency should be explicit. If it’s a “library” then it should be implicit. But it’s really not hard to support Clang + GCC + MSVC. And if new toolchains introduce new warnings they should be fixed.<p>That said, my preference is for “dev” builds to not have warnings as errors, only “retail” which gets built by CI.<p>Third party libraries almost always have to be compiled without warnings as errors because almost all open source code is rife with warnings.</div><br/><div id="37721612" class="c"><input type="checkbox" id="c-37721612" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#37721279">root</a><span>|</span><a href="#37721523">parent</a><span>|</span><a href="#37722309">next</a><span>|</span><label class="collapse" for="c-37721612">[-]</label><label class="expand" for="c-37721612">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If the project is an “executable” then the toolchain dependency should be explicit.<p>Cross-platform makes this fun. I work on a project that, in production, runs on an embedded Linux box. With a couple of features disabled, I can do development work just fine on my Macbook. Unfortunately, the embedded target uses a relatively old and crusty version of GCC and OS X has a newer version of Clang. We generally shoot for &quot;zero warnings on production builds&quot; but warnings in development on OS X are... okay. We pay attention to them and have occasionally benefitted from warnings that Clang provides that the older GCC does not, but some of the warnings come from some (admittedly questionable but work correctly) casts that a 3rd party library&#x27;s header makes. Definitely not worth the effort to try to get upstream to fix the code gen that makes these headers to make OS X Clang happy.</div><br/><div id="37722998" class="c"><input type="checkbox" id="c-37722998" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#37721279">root</a><span>|</span><a href="#37721612">parent</a><span>|</span><a href="#37722309">next</a><span>|</span><label class="collapse" for="c-37722998">[-]</label><label class="expand" for="c-37722998">[1 more]</label></div><br/><div class="children"><div class="content">I do a lot of Linux + macOS + Windows support. Yeah third-party libraries are effectively a lost cause. It&#x27;s ok if it&#x27;s limited to cpp files. If it&#x27;s in headers it&#x27;s annoying.<p>We vendor all third-party dependencies but would probably bias towards fixing the warning. It just spirals out of control too fast if you don&#x27;t. Ancient toolchains for embedded or similar is definitely tough.<p>If you can use modern toolchains then the combination of warnings across GCC + Clang + MSVC is probably a win.</div><br/></div></div></div></div></div></div><div id="37722309" class="c"><input type="checkbox" id="c-37722309" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37721279">root</a><span>|</span><a href="#37721364">parent</a><span>|</span><a href="#37721523">prev</a><span>|</span><a href="#37721319">next</a><span>|</span><label class="collapse" for="c-37722309">[-]</label><label class="expand" for="c-37722309">[1 more]</label></div><br/><div class="children"><div class="content">If distros are compiling with an unsupported toolchain then its on them if it fails. This is similar to how some distros will build your application with unsupported versions of libraries resulting in crashes.</div><br/></div></div></div></div><div id="37721319" class="c"><input type="checkbox" id="c-37721319" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#37721279">parent</a><span>|</span><a href="#37721364">prev</a><span>|</span><a href="#37721667">next</a><span>|</span><label class="collapse" for="c-37721319">[-]</label><label class="expand" for="c-37721319">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fine if you&#x27;re not writing open source code and don&#x27;t plan on updating your toolchain frequently.<p>For the rest of us? -Werror is not our friend.</div><br/><div id="37722310" class="c"><input type="checkbox" id="c-37722310" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37721279">root</a><span>|</span><a href="#37721319">parent</a><span>|</span><a href="#37721853">next</a><span>|</span><label class="collapse" for="c-37722310">[-]</label><label class="expand" for="c-37722310">[3 more]</label></div><br/><div class="children"><div class="content">It works the same with open source. If your open source library is always built with clang 16 then it will never fail to compile. If people want to use an unsupported toolchain they can figure out how to get it working themselves.</div><br/><div id="37722982" class="c"><input type="checkbox" id="c-37722982" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#37721279">root</a><span>|</span><a href="#37722310">parent</a><span>|</span><a href="#37721853">next</a><span>|</span><label class="collapse" for="c-37722982">[-]</label><label class="expand" for="c-37722982">[2 more]</label></div><br/><div class="children"><div class="content">As an author of open source software, you must expect people to use their system&#x27;s toolchain. You can define minimum versions sure, but if you use Clang 16, you really ought to not break when a user tries to compile with Clang 17, unless your build system actually automatically downloads and uses the right clang version automatically. Most of us aren&#x27;t using such a build system.</div><br/><div id="37723293" class="c"><input type="checkbox" id="c-37723293" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37721279">root</a><span>|</span><a href="#37722982">parent</a><span>|</span><a href="#37721853">next</a><span>|</span><label class="collapse" for="c-37723293">[-]</label><label class="expand" for="c-37723293">[1 more]</label></div><br/><div class="children"><div class="content">&gt;you must expect people to use their system&#x27;s toolchain<p>Why? I don&#x27;t expect people to build against their system libraries.<p>&gt;unless your build system actually automatically downloads and uses the right clang version automatically<p>Nix, bazel, buck, etc all support defining the toolchain for your build. Reproducable builds are useful. You are supporting a known configuration. Crashes can all be collected an easily analyzed. You can be sure you have a properly compiled version by verifying the hash.<p>&gt;Most of us aren&#x27;t using such a build system.<p>That&#x27;s okay. You can just ingest a prebuilt artifact if you aren&#x27;t capable of tying it into your build system.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37721639" class="c"><input type="checkbox" id="c-37721639" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#37721667">prev</a><span>|</span><a href="#37721979">next</a><span>|</span><label class="collapse" for="c-37721639">[-]</label><label class="expand" for="c-37721639">[4 more]</label></div><br/><div class="children"><div class="content">-Werror is the least of your problems if you are compiling older C code in a newer GCC-based toolchain.  Seemingly as a matter of policy, GCC has started playing very fast and loose with undefined behavior, treating it as a license to emit any code it wants or none at all, regardless of what most people would say the programmer &quot;obviously&quot; intended.<p>There&#x27;s a good chance your old code will compile if you don&#x27;t use -Werror, or even if you do, but whether it runs the way it used to is a different question entirely.</div><br/><div id="37722299" class="c"><input type="checkbox" id="c-37722299" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#37721639">parent</a><span>|</span><a href="#37721979">next</a><span>|</span><label class="collapse" for="c-37722299">[-]</label><label class="expand" for="c-37722299">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Seemingly as a matter of policy, GCC has started playing very fast and loose with undefined behavior, treating it as a license to emit any code it wants or none at all, regardless of what most people would say the programmer &quot;obviously&quot; intended.<p>But isn&#x27;t that exactly what the C standard has said Undefined Behavior is, for as long as it has existed?</div><br/><div id="37722504" class="c"><input type="checkbox" id="c-37722504" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#37721639">root</a><span>|</span><a href="#37722299">parent</a><span>|</span><a href="#37721979">next</a><span>|</span><label class="collapse" for="c-37722504">[-]</label><label class="expand" for="c-37722504">[2 more]</label></div><br/><div class="children"><div class="content">Sigh. Yes, but here on Planet Earth, a lot of legacy code was (irresponsibly) written under the assumption that the contemporary compilers wouldn&#x27;t change <i>their</i> behavior in the future.<p>Also here on Planet Earth, performance optimization has become <i>much</i> less important than not breaking older code that previously worked, but nobody told the GCC devs.<p>Never change, HN.  Keep working toward a Utopia that never was and never will be.  And keep downvoting helpful hints indicating additional things to watch out for in the context of the article.</div><br/><div id="37722657" class="c"><input type="checkbox" id="c-37722657" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#37721639">root</a><span>|</span><a href="#37722504">parent</a><span>|</span><a href="#37721979">next</a><span>|</span><label class="collapse" for="c-37722657">[-]</label><label class="expand" for="c-37722657">[1 more]</label></div><br/><div class="children"><div class="content">Previous poster just asked a question; not everyone deals with C code, or old C code.<p>I agree there&#x27;s sometimes a certain lack of pragmatism, and that UB is used as the ultimate argument that trumps all arguments. But on the other hand, it really <i>is</i> UB, so that seems more of an argument for &quot;we want a migration path&quot; rather than &quot;never change it until the end of time&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="37721979" class="c"><input type="checkbox" id="c-37721979" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#37721639">prev</a><span>|</span><label class="collapse" for="c-37721979">[-]</label><label class="expand" for="c-37721979">[2 more]</label></div><br/><div class="children"><div class="content">I pretty frequently argue that memory safety (etc) outcomes in modern C++ are pretty comparable to Rust, but that’s only true if you’re throwing clang-tidy, -Werror, -Wall, -Wpedantic, and CI under ASAN, MSAN, UBSAN, TSAN.<p>That’s pretty close to rustc.<p>And I get that you can’t throw that at a giant codebase in one day, and I get that dev builds probably drop —Werror. Thrrr are realities.<p>But new stuff not under clang-tidy, cppcheck, and pvs if you’re feeling speedy? People do that?</div><br/><div id="37722184" class="c"><input type="checkbox" id="c-37722184" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#37721979">parent</a><span>|</span><label class="collapse" for="c-37722184">[-]</label><label class="expand" for="c-37722184">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s simply not true. All of those tools are regularly used by large projects like chrome and have been for years. Memory safety continues to be the largest source of issues for them in spite of that. Sanitizers and other modern tools are a fantastic improvement over the old way of doing things, but they don&#x27;t catch everything and we shouldn&#x27;t pretend they do.</div><br/></div></div></div></div></div></div></div></div></div></body></html>