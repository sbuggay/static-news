<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732698075277" as="style"/><link rel="stylesheet" href="styles.css?v=1732698075277"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.thalium.re/posts/llvm-powered-devirtualization/">LLVM-powered devirtualization</a>Â <span class="domain">(<a href="https://blog.thalium.re">blog.thalium.re</a>)</span></div><div class="subtext"><span>dddnzzz334</span> | <span>9 comments</span></div><br/><div><div id="42253615" class="c"><input type="checkbox" id="c-42253615" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#42253923">next</a><span>|</span><label class="collapse" for="c-42253615">[-]</label><label class="expand" for="c-42253615">[1 more]</label></div><br/><div class="children"><div class="content">In compiler context, &quot;devirtualization&quot; I encountered usually meant compiling a virtual call to a direct call. See for example &quot;Devirtualization in LLVM and Clang&quot; on LLVM blog: <a href="https:&#x2F;&#x2F;blog.llvm.org&#x2F;2017&#x2F;03&#x2F;devirtualization-in-llvm-and-clang.html" rel="nofollow">https:&#x2F;&#x2F;blog.llvm.org&#x2F;2017&#x2F;03&#x2F;devirtualization-in-llvm-and-c...</a>.<p>&quot;Devirtualization&quot; in this post is something different, being an inverse of virtualization which is an obfuscation technique to hinder reverse engineering.</div><br/></div></div><div id="42253923" class="c"><input type="checkbox" id="c-42253923" checked=""/><div class="controls bullet"><span class="by">mshockwave</span><span>|</span><a href="#42253615">prev</a><span>|</span><a href="#42249489">next</a><span>|</span><label class="collapse" for="c-42253923">[-]</label><label class="expand" for="c-42253923">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t recommend using the term &quot;devirtualization&quot; here, as that term has been used to refer simplifying C++ virtual function calls (into normal function call) in LLVM. And such optimization has been turned on by default for quite some time.</div><br/></div></div><div id="42249489" class="c"><input type="checkbox" id="c-42249489" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#42253923">prev</a><span>|</span><a href="#42246230">next</a><span>|</span><label class="collapse" for="c-42249489">[-]</label><label class="expand" for="c-42249489">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, a lot of the techniques this article describes are also used in fuzzing. I wonder how much overlap there is between fuzzing and devirtualization.</div><br/></div></div><div id="42246230" class="c"><input type="checkbox" id="c-42246230" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#42249489">prev</a><span>|</span><label class="collapse" for="c-42246230">[-]</label><label class="expand" for="c-42246230">[5 more]</label></div><br/><div class="children"><div class="content">Also, Bochs can fool most VM detectors as it can emulate a whole CPU in software, but an i7 might be able to run a fully emulated Pentium 4 based computer with ease in almost real time.  But Bochs&#x27; debugger can do crazy things to most malware and propietary obfuscators.</div><br/><div id="42250541" class="c"><input type="checkbox" id="c-42250541" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#42246230">parent</a><span>|</span><label class="collapse" for="c-42250541">[-]</label><label class="expand" for="c-42250541">[4 more]</label></div><br/><div class="children"><div class="content">I find that hard to believe. Bochs is trivial to detect, unless you heavily patch it, then it&#x27;s still detectable (for example, by leveraging known bugs&#x2F;mismatches with a real CPSs). And that&#x27;s just a tip of the iceberg as far as antivm goes.<p>But I agree that many detectors used by malware don&#x27;t expect Bochs and thus don&#x27;t detect it.</div><br/><div id="42252029" class="c"><input type="checkbox" id="c-42252029" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#42246230">root</a><span>|</span><a href="#42250541">parent</a><span>|</span><a href="#42251592">next</a><span>|</span><label class="collapse" for="c-42252029">[-]</label><label class="expand" for="c-42252029">[1 more]</label></div><br/><div class="children"><div class="content">Actually, I believe it&#x27;s true. It&#x27;s not that detecting Bochs is <i>necessarily</i> hard, it&#x27;s just that it&#x27;s probably not on most people&#x27;s radars. I had similar success evading anti-VM detection by just simply using Qemu (without KVM) instead of VMware a while ago. (Long enough ago that I still used VMware, I suppose.)<p>If there <i>were</i> an anti-VM cat-and-mouse game with Qemu&#x2F;Bochs&#x2F;etc. that evolved beyond primitive string searches and the like, CPU emulation would likely do a lot better against anti-VM technology. I suspect this is the same thing that makes Unicorn Engine and Qiling fairly effective for analyzing obfuscated code.</div><br/></div></div><div id="42251592" class="c"><input type="checkbox" id="c-42251592" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#42246230">root</a><span>|</span><a href="#42250541">parent</a><span>|</span><a href="#42252029">prev</a><span>|</span><a href="#42250958">next</a><span>|</span><label class="collapse" for="c-42251592">[-]</label><label class="expand" for="c-42251592">[1 more]</label></div><br/><div class="children"><div class="content">&gt; leveraging known bugs&#x2F;mismatches<p>What if a real CPU ends up having a similar bug? The more detection tricks you try, the higher the rate of false positives will be.<p>Bochs emulation side-steps most VM detection because it&#x27;s not a VM. You can&#x27;t even use the CPUID&#x2F;VMEXIT timing detection trick because it&#x27;s all emulated.</div><br/></div></div><div id="42250958" class="c"><input type="checkbox" id="c-42250958" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#42246230">root</a><span>|</span><a href="#42250541">parent</a><span>|</span><a href="#42251592">prev</a><span>|</span><label class="collapse" for="c-42250958">[-]</label><label class="expand" for="c-42250958">[1 more]</label></div><br/><div class="children"><div class="content">Bochs can use several BIOSes than its own ones.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>