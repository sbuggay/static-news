<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697014864179" as="style"/><link rel="stylesheet" href="styles.css?v=1697014864179"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack">The novel HTTP/2 &#x27;Rapid Reset&#x27; DDoS attack</a> <span class="domain">(<a href="https://cloud.google.com">cloud.google.com</a>)</span></div><div class="subtext"><span>jsnell</span> | <span>102 comments</span></div><br/><div><div id="37836511" class="c"><input type="checkbox" id="c-37836511" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37833365">next</a><span>|</span><label class="collapse" for="c-37836511">[-]</label><label class="expand" for="c-37836511">[1 more]</label></div><br/><div class="children"><div class="content">Related ongoing threads:<p><i>The largest DDoS attack to date, peaking above 398M rps</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37831062">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37831062</a><p><i>HTTP&#x2F;2 Zero-Day Vulnerability Results in Record-Breaking DDoS Attacks</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37830998">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37830998</a></div><br/></div></div><div id="37833365" class="c"><input type="checkbox" id="c-37833365" checked=""/><div class="controls bullet"><span class="by">comice</span><span>|</span><a href="#37836511">prev</a><span>|</span><a href="#37832424">next</a><span>|</span><label class="collapse" for="c-37833365">[-]</label><label class="expand" for="c-37833365">[4 more]</label></div><br/><div class="children"><div class="content">Nice to see that the haproxy people had spotted this kind of issue with http&#x2F;2 and apparently mitigated it back in 2018: <a href="https:&#x2F;&#x2F;www.mail-archive.com&#x2F;haproxy@formilux.org&#x2F;msg44134.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.mail-archive.com&#x2F;haproxy@formilux.org&#x2F;msg44134.h...</a></div><br/><div id="37835699" class="c"><input type="checkbox" id="c-37835699" checked=""/><div class="controls bullet"><span class="by">jabart</span><span>|</span><a href="#37833365">parent</a><span>|</span><a href="#37836230">next</a><span>|</span><label class="collapse" for="c-37835699">[-]</label><label class="expand" for="c-37835699">[1 more]</label></div><br/><div class="children"><div class="content">Nice, I was looking for this type of information for haproxy. Gives me a lot of confidence in their new QUIC feature.</div><br/></div></div><div id="37836230" class="c"><input type="checkbox" id="c-37836230" checked=""/><div class="controls bullet"><span class="by">vdfs</span><span>|</span><a href="#37833365">parent</a><span>|</span><a href="#37835699">prev</a><span>|</span><a href="#37832424">next</a><span>|</span><label class="collapse" for="c-37836230">[-]</label><label class="expand" for="c-37836230">[2 more]</label></div><br/><div class="children"><div class="content">If anyone is curios, Nginx is vulnerable to this<p><a href="https:&#x2F;&#x2F;www.nginx.com&#x2F;blog&#x2F;http-2-rapid-reset-attack-impacting-f5-nginx-products" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nginx.com&#x2F;blog&#x2F;http-2-rapid-reset-attack-impacti...</a></div><br/><div id="37836847" class="c"><input type="checkbox" id="c-37836847" checked=""/><div class="controls bullet"><span class="by">obituary_latte</span><span>|</span><a href="#37833365">root</a><span>|</span><a href="#37836230">parent</a><span>|</span><a href="#37832424">next</a><span>|</span><label class="collapse" for="c-37836847">[-]</label><label class="expand" for="c-37836847">[1 more]</label></div><br/><div class="children"><div class="content"><i>IF</i> configured away from the defaults:<p>By relying on the default keepalive limit, NGINX prevents this type of attack. Creating additional connections to circumvent this limit exposes bad actors via standard layer 4 monitoring and alerting tools.<p>However, if NGINX is configured with a keepalive that is substantially higher than the default and recommended setting, the attack may deplete system resources.</div><br/></div></div></div></div></div></div><div id="37832424" class="c"><input type="checkbox" id="c-37832424" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#37833365">prev</a><span>|</span><a href="#37832934">next</a><span>|</span><label class="collapse" for="c-37832424">[-]</label><label class="expand" for="c-37832424">[15 more]</label></div><br/><div class="children"><div class="content">&gt; In a typical HTTP&#x2F;2 server implementation, the server will still have to do significant amounts of work for canceled requests, such as allocating new stream data structures, parsing the query and doing header decompression, and mapping the URL to a resource. For reverse proxy implementations, the request may be proxied to the backend server before the RST_STREAM frame is processed. The client on the other hand paid almost no costs for sending the requests. This creates an exploitable cost asymmetry between the server and the client.<p>I&#x27;m surprised this wasn&#x27;t foreseen when HTTP&#x2F;2 was designed. Amplification attacks were already well known from other protocols.<p>I&#x27;m similarly similarly surprised it took this long for this attack to surface, but maybe HTTP&#x2F;2 wasn&#x27;t widely enough deployed to be a worthwhile target till recently?</div><br/><div id="37832708" class="c"><input type="checkbox" id="c-37832708" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37832424">parent</a><span>|</span><a href="#37834241">next</a><span>|</span><label class="collapse" for="c-37832708">[-]</label><label class="expand" for="c-37832708">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really an amplification attack. It&#x27;s just drastically more efficiently using TCP connections.</div><br/><div id="37836295" class="c"><input type="checkbox" id="c-37836295" checked=""/><div class="controls bullet"><span class="by">callalex</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37832708">parent</a><span>|</span><a href="#37834686">next</a><span>|</span><label class="collapse" for="c-37836295">[-]</label><label class="expand" for="c-37836295">[4 more]</label></div><br/><div class="children"><div class="content">Isn’t any kind of attack where a little bit of effort from the attacker causes a lot of work for the victim an amplification attack? Or do you only consider it an amplification attack if it is exploiting layer 3?<p>I tried looking it up and couldn’t find an authoritative answer. Can you recommend a resource that you like for this subject?</div><br/><div id="37837216" class="c"><input type="checkbox" id="c-37837216" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37836295">parent</a><span>|</span><a href="#37836399">next</a><span>|</span><label class="collapse" for="c-37837216">[-]</label><label class="expand" for="c-37837216">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Isn’t any kind of attack where a little bit of effort from the attacker causes a lot of work for the victim an amplification attack?<p>That is technically any HTTP request that requires processing to satisfy. For example if I find a page on your site that executes an expensive database query.<p>Amplification attacks are generally defined as packets that can be sent with a spoofed source address that result in a larger number of packets being returned to the spoofed victim.</div><br/></div></div><div id="37836399" class="c"><input type="checkbox" id="c-37836399" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37836295">parent</a><span>|</span><a href="#37837216">prev</a><span>|</span><a href="#37840134">next</a><span>|</span><label class="collapse" for="c-37836399">[-]</label><label class="expand" for="c-37836399">[1 more]</label></div><br/><div class="children"><div class="content">Amplification attack usually means the first victim produces more traffic than was sent to it and can direct it at the second victim.</div><br/></div></div><div id="37840134" class="c"><input type="checkbox" id="c-37840134" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37836295">parent</a><span>|</span><a href="#37836399">prev</a><span>|</span><a href="#37834686">next</a><span>|</span><label class="collapse" for="c-37840134">[-]</label><label class="expand" for="c-37840134">[1 more]</label></div><br/><div class="children"><div class="content">No, this is Resource exhaustion attacks <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Resource_exhaustion_attack" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Resource_exhaustion_attack</a> And its not the first HTTP2 rodeo <a href="https:&#x2F;&#x2F;www.akamai.com&#x2F;blog&#x2F;security&#x2F;http2-vulnerabilities" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.akamai.com&#x2F;blog&#x2F;security&#x2F;http2-vulnerabilities</a><p>One of the 2019 vulns <a href="https:&#x2F;&#x2F;cve.mitre.org&#x2F;cgi-bin&#x2F;cvename.cgi?name=CVE-2019-9514" rel="nofollow noreferrer">https:&#x2F;&#x2F;cve.mitre.org&#x2F;cgi-bin&#x2F;cvename.cgi?name=CVE-2019-9514</a> even sounds extremely similar to current attack.</div><br/></div></div></div></div><div id="37834686" class="c"><input type="checkbox" id="c-37834686" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37832708">parent</a><span>|</span><a href="#37836295">prev</a><span>|</span><a href="#37834241">next</a><span>|</span><label class="collapse" for="c-37834686">[-]</label><label class="expand" for="c-37834686">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. I hadn&#x27;t had my coffee yet and the asymmetric cost reminded me of amplification attacks. I&#x27;m still surprised this attack wasn&#x27;t foreseen though. It just doesn&#x27;t seem all that clever or original.</div><br/></div></div></div></div><div id="37834241" class="c"><input type="checkbox" id="c-37834241" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#37832424">parent</a><span>|</span><a href="#37832708">prev</a><span>|</span><a href="#37833290">next</a><span>|</span><label class="collapse" for="c-37834241">[-]</label><label class="expand" for="c-37834241">[3 more]</label></div><br/><div class="children"><div class="content">I was surprised too, but if you look at the timelines then RST_STREAM seems to have been present in early versions of SPDY, and SPDY seems mostly to have been designed around 2009. Attacks like Slowloris were coming out at about the same time, but they weren&#x27;t well-known.<p>On the other hand, SYN cookies were introduced in 1996, so there&#x27;s definitely some historic precedent for attacks in the (victim pays Y, attacker pays X, X&lt;&lt;Y) class.</div><br/><div id="37835941" class="c"><input type="checkbox" id="c-37835941" checked=""/><div class="controls bullet"><span class="by">c0l0</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37834241">parent</a><span>|</span><a href="#37833290">next</a><span>|</span><label class="collapse" for="c-37835941">[-]</label><label class="expand" for="c-37835941">[2 more]</label></div><br/><div class="children"><div class="content">If you are working on the successor protocol of HTTP&#x2F;1.1, and are not aware of Slowloris the moment it hits and every serious httpd implementation out there gets patched to mitigate it, I&#x27;d argue you are in the wrong line of work.</div><br/><div id="37838244" class="c"><input type="checkbox" id="c-37838244" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37835941">parent</a><span>|</span><a href="#37833290">next</a><span>|</span><label class="collapse" for="c-37838244">[-]</label><label class="expand" for="c-37838244">[1 more]</label></div><br/><div class="children"><div class="content">While I agree in principle, slow loris is a very different attack than this one.</div><br/></div></div></div></div></div></div><div id="37833290" class="c"><input type="checkbox" id="c-37833290" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#37832424">parent</a><span>|</span><a href="#37834241">prev</a><span>|</span><a href="#37832934">next</a><span>|</span><label class="collapse" for="c-37833290">[-]</label><label class="expand" for="c-37833290">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m similarly similarly surprised it took this long for this attack to surface<p>As with most things like this, probably many hundreds of unimportant people saw it and tried it out.<p>Trying to do it on Google, with a serious effort, that&#x27;s the wacky part.</div><br/><div id="37836682" class="c"><input type="checkbox" id="c-37836682" checked=""/><div class="controls bullet"><span class="by">sangnoir</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37833290">parent</a><span>|</span><a href="#37832934">next</a><span>|</span><label class="collapse" for="c-37836682">[-]</label><label class="expand" for="c-37836682">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Trying to do it on Google, with a serious effort, that&#x27;s the wacky part<p>If I were the FBI, I&#x27;d be looking at people with recently bought Google puts expiring soon. I can&#x27;t imagine anyone taking a swing at Google infra &quot;for the lulz&quot;. Also in contention: nation-states doing a practice run.</div><br/><div id="37837371" class="c"><input type="checkbox" id="c-37837371" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37836682">parent</a><span>|</span><a href="#37837132">next</a><span>|</span><label class="collapse" for="c-37837371">[-]</label><label class="expand" for="c-37837371">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because you don&#x27;t think like a 16 year old<p>This is exactly the kind of things that a smart kid who&#x27;s still just a foolish highschool student would do. I wouldn&#x27;t be surprised if this attack already exists in the wild, it&#x27;s not hard to write<p>Also the subsequent attacks were less effective, that&#x27;s exactly what some kid would be doing.<p>You don&#x27;t even need an expansive botnot. A rich kid whose parents are in neighborhoods with residential fiber with a bunch of friends could probably coordinate it through a discord server<p>Most of us really don&#x27;t interact with teenagers regularly so we forget they&#x27;re out there (they also tend to dislike adults so they make themselves especially invisible around us). When it comes to things like this, that&#x27;s my first assumption until further evidence.<p>Merely teenaged graffiti for the digital age.</div><br/></div></div><div id="37837132" class="c"><input type="checkbox" id="c-37837132" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37836682">parent</a><span>|</span><a href="#37837371">prev</a><span>|</span><a href="#37837238">next</a><span>|</span><label class="collapse" for="c-37837132">[-]</label><label class="expand" for="c-37837132">[1 more]</label></div><br/><div class="children"><div class="content">Google infra is attacked with large scale DDoS type attacks literally multiple times a day. They’re usually a nothingburger.</div><br/></div></div><div id="37837238" class="c"><input type="checkbox" id="c-37837238" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#37832424">root</a><span>|</span><a href="#37836682">parent</a><span>|</span><a href="#37837132">prev</a><span>|</span><a href="#37832934">next</a><span>|</span><label class="collapse" for="c-37837238">[-]</label><label class="expand" for="c-37837238">[1 more]</label></div><br/><div class="children"><div class="content">Google is rarely the target of intentional attacks. Their cloud customers are the intended victims.</div><br/></div></div></div></div></div></div></div></div><div id="37832934" class="c"><input type="checkbox" id="c-37832934" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#37832424">prev</a><span>|</span><a href="#37832128">next</a><span>|</span><label class="collapse" for="c-37832934">[-]</label><label class="expand" for="c-37832934">[18 more]</label></div><br/><div class="children"><div class="content">So we needed HTTP2 to deliver ads, trackers and bloated frontend frameworks faster. And now it delivers attacks faster too.</div><br/><div id="37838185" class="c"><input type="checkbox" id="c-37838185" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37832934">parent</a><span>|</span><a href="#37836708">next</a><span>|</span><label class="collapse" for="c-37838185">[-]</label><label class="expand" for="c-37838185">[2 more]</label></div><br/><div class="children"><div class="content">HTTP&#x2F;2 makes the browsing experience of high-latency connections a lot more tolerable. It also makes loading web pages in general faster.<p>Luckily, HTTP&#x2F;1.1 still works. You can always enable it in your browser configuration and in your web servers if you don&#x27;t like the protocol.</div><br/><div id="37841795" class="c"><input type="checkbox" id="c-37841795" checked=""/><div class="controls bullet"><span class="by">tlamponi</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37838185">parent</a><span>|</span><a href="#37836708">next</a><span>|</span><label class="collapse" for="c-37841795">[-]</label><label class="expand" for="c-37841795">[1 more]</label></div><br/><div class="children"><div class="content">&gt; HTTP&#x2F;2 makes the browsing experience of high-latency connections a lot more tolerable. It also makes loading web pages in general faster.<p>HTTP&#x2F;3 does that in my experience (lots of train rides with spotty onboard Wi-Fi) quite a bit better though. As HTTP&#x2F;2 is still affected by head-of-line blocking and a single packet loss can block all other streams, even if the lost packet didn&#x27;t hold data for them.</div><br/></div></div></div></div><div id="37836708" class="c"><input type="checkbox" id="c-37836708" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#37832934">parent</a><span>|</span><a href="#37838185">prev</a><span>|</span><a href="#37833242">next</a><span>|</span><label class="collapse" for="c-37836708">[-]</label><label class="expand" for="c-37836708">[14 more]</label></div><br/><div class="children"><div class="content">Are you suggesting that we didn&#x27;t need HTTP2? What&#x27;s the real alternative here?</div><br/><div id="37837682" class="c"><input type="checkbox" id="c-37837682" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37836708">parent</a><span>|</span><a href="#37838595">next</a><span>|</span><label class="collapse" for="c-37837682">[-]</label><label class="expand" for="c-37837682">[7 more]</label></div><br/><div class="children"><div class="content">In some alternative history there would have been a push to make http 1.1 pipelining work, trim fat from bloated websites (loading cookie consent banners from a 3rd party domain is a travesty on several levels) and maybe use websockets for tiny API requests. And the prioritization attributes on various resources.
Then shoveling everything over ~2 TCP connections would have done the job?</div><br/><div id="37839942" class="c"><input type="checkbox" id="c-37839942" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37837682">parent</a><span>|</span><a href="#37838649">next</a><span>|</span><label class="collapse" for="c-37839942">[-]</label><label class="expand" for="c-37839942">[1 more]</label></div><br/><div class="children"><div class="content">Personally, as a website visitor and occasional author, I don’t want the performance to be good enough to ‘do the job’.  I want it to be as fast as possible.  I want it to be instant.  For that we need unbloated websites <i>and</i> better protocols.  It’s not a competition.<p>After all, you don’t need bloat to suffer from head-of-line blocking.  You just need a few images.<p>(Though, personally I’m a much bigger fan of HTTP&#x2F;3 than HTTP&#x2F;2.  With a more principled solution to head-of-line blocking and proper 0-RTT, HTTP&#x2F;3 makes a stronger case for why we need a new protocol than HTTP&#x2F;2 did.  I don’t know why HTTP&#x2F;2 had to exist at all, really, when QUIC already existed by the time HTTP&#x2F;2 was being standardized.  Oh well.)</div><br/></div></div><div id="37838649" class="c"><input type="checkbox" id="c-37838649" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37837682">parent</a><span>|</span><a href="#37839942">prev</a><span>|</span><a href="#37841191">next</a><span>|</span><label class="collapse" for="c-37838649">[-]</label><label class="expand" for="c-37838649">[3 more]</label></div><br/><div class="children"><div class="content">What incentive would most businesses have to do what you&#x27;re describing?<p>It is _much_ faster, cheaper, and easier to build a bloated website than an optimized one. Similarly, it is much easier to enable HTTP2 than it is to fix the root of the problem.<p>I&#x27;m not saying that it&#x27;s right -- anyone without a fast connection or who cares about their privacy isn&#x27;t getting a great deal here.</div><br/><div id="37838821" class="c"><input type="checkbox" id="c-37838821" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37838649">parent</a><span>|</span><a href="#37840255">next</a><span>|</span><label class="collapse" for="c-37838821">[-]</label><label class="expand" for="c-37838821">[1 more]</label></div><br/><div class="children"><div class="content">Most businesses are not in a position to push through a new network protocol for the entire planet! So if we lived in a world with fewer monopolies then protocols might have evolved more incrementally. Though we&#x27;d presumably still have gotten something like BBR because congestion algorithms can be implemented unilaterally.</div><br/></div></div><div id="37840255" class="c"><input type="checkbox" id="c-37840255" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37838649">parent</a><span>|</span><a href="#37838821">prev</a><span>|</span><a href="#37841191">next</a><span>|</span><label class="collapse" for="c-37840255">[-]</label><label class="expand" for="c-37840255">[1 more]</label></div><br/><div class="children"><div class="content">What incentive do most businesses have to make your checkout process smooth, have automatic doors, or provide shopping carts? Simple: customers like the easiest business to shop at.</div><br/></div></div></div></div><div id="37841191" class="c"><input type="checkbox" id="c-37841191" checked=""/><div class="controls bullet"><span class="by">KingMob</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37837682">parent</a><span>|</span><a href="#37838649">prev</a><span>|</span><a href="#37840249">next</a><span>|</span><label class="collapse" for="c-37841191">[-]</label><label class="expand" for="c-37841191">[1 more]</label></div><br/><div class="children"><div class="content">Even for leaner websites, HTTP&#x2F;2 was always going to be an improvement, for HTTP head-of-line blocking and better header compression, if nothing else. These are orthogonal issues for the most part.<p>Also, they tried prioritization, but it was too unwieldy in practice, the browser vendors didn&#x27;t agree, and it was deprecated in the latest RFC 9113.</div><br/></div></div><div id="37840249" class="c"><input type="checkbox" id="c-37840249" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37837682">parent</a><span>|</span><a href="#37841191">prev</a><span>|</span><a href="#37838595">next</a><span>|</span><label class="collapse" for="c-37840249">[-]</label><label class="expand" for="c-37840249">[1 more]</label></div><br/><div class="children"><div class="content">Loading cookie consent banners from a 3rd-party domain is probably a GDPR violation because it transmits user information to a 3rd party without consent.</div><br/></div></div></div></div><div id="37838595" class="c"><input type="checkbox" id="c-37838595" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37836708">parent</a><span>|</span><a href="#37837682">prev</a><span>|</span><a href="#37836728">next</a><span>|</span><label class="collapse" for="c-37838595">[-]</label><label class="expand" for="c-37838595">[2 more]</label></div><br/><div class="children"><div class="content">SCTP (Stream Control Transmission Protocol) or the equivalent.  HTTP is really the wrong layer for things like bonding multiple connections, congestion adjustments, etc.<p>Unfortunately, most computers only pass TCP and UDP (Windows and middleboxes).  So, protocol evolution is a dead end.<p>Thus you have to piggyback on what computers will let through--so you&#x27;re stuck with creating an HTTP flavor of TCP.</div><br/><div id="37840479" class="c"><input type="checkbox" id="c-37840479" checked=""/><div class="controls bullet"><span class="by">murderfs</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37838595">parent</a><span>|</span><a href="#37836728">next</a><span>|</span><label class="collapse" for="c-37840479">[-]</label><label class="expand" for="c-37840479">[1 more]</label></div><br/><div class="children"><div class="content">QUIC (the basis for HTTP&#x2F;3) is basically the spiritual successor to SCTP, except with TLS baked in, so compared with SCTP+DTLS, connection establishment requires significantly fewer roundtrips (0 round trips for session resumption, 1 roundtrip at worst, compared to 4 or so for DTLS).</div><br/></div></div></div></div><div id="37836728" class="c"><input type="checkbox" id="c-37836728" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37836708">parent</a><span>|</span><a href="#37838595">prev</a><span>|</span><a href="#37833242">next</a><span>|</span><label class="collapse" for="c-37836728">[-]</label><label class="expand" for="c-37836728">[4 more]</label></div><br/><div class="children"><div class="content">Nothing in their comment claims that, there&#x27;s no need to bring absurd strawmen into the discussion.</div><br/><div id="37836911" class="c"><input type="checkbox" id="c-37836911" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37836728">parent</a><span>|</span><a href="#37836912">next</a><span>|</span><label class="collapse" for="c-37836911">[-]</label><label class="expand" for="c-37836911">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just trying to figure out what the parent was trying to communicate, since the comment by itself didn&#x27;t add much to the discussion.<p>It seems that they&#x27;re more upset by the state of web development today than they are by HTTP2 or anything else that this thread pertains to.</div><br/></div></div><div id="37836912" class="c"><input type="checkbox" id="c-37836912" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37836728">parent</a><span>|</span><a href="#37836911">prev</a><span>|</span><a href="#37836898">next</a><span>|</span><label class="collapse" for="c-37836912">[-]</label><label class="expand" for="c-37836912">[1 more]</label></div><br/><div class="children"><div class="content">The comment lists three negative things as &quot;the reason we needed HTTP&#x2F;2&quot;. I don&#x27;t even see how you could read it <i>other than</i> implying that HTTP&#x2F;2 was not actually necessary.</div><br/></div></div><div id="37836898" class="c"><input type="checkbox" id="c-37836898" checked=""/><div class="controls bullet"><span class="by">ramranch</span><span>|</span><a href="#37832934">root</a><span>|</span><a href="#37836728">parent</a><span>|</span><a href="#37836912">prev</a><span>|</span><a href="#37833242">next</a><span>|</span><label class="collapse" for="c-37836898">[-]</label><label class="expand" for="c-37836898">[1 more]</label></div><br/><div class="children"><div class="content">It does strongly imply it. HTTP2 is needed for more than just the bloatware of the modern internet.</div><br/></div></div></div></div></div></div><div id="37833242" class="c"><input type="checkbox" id="c-37833242" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#37832934">parent</a><span>|</span><a href="#37836708">prev</a><span>|</span><a href="#37832128">next</a><span>|</span><label class="collapse" for="c-37833242">[-]</label><label class="expand" for="c-37833242">[1 more]</label></div><br/><div class="children"><div class="content">Well said :) hehe.</div><br/></div></div></div></div><div id="37832128" class="c"><input type="checkbox" id="c-37832128" checked=""/><div class="controls bullet"><span class="by">scrpl</span><span>|</span><a href="#37832934">prev</a><span>|</span><a href="#37838194">next</a><span>|</span><label class="collapse" for="c-37832128">[-]</label><label class="expand" for="c-37832128">[13 more]</label></div><br/><div class="children"><div class="content">Another reason to keep foundational protocols small. HTTP&#x2F;2 has been around for more than a decade (including SPDY), and this is a first time this attack type surfaced. I wonder what surprises HTTP&#x2F;3 and QUIC hide...</div><br/><div id="37832243" class="c"><input type="checkbox" id="c-37832243" checked=""/><div class="controls bullet"><span class="by">cmeacham98</span><span>|</span><a href="#37832128">parent</a><span>|</span><a href="#37836076">next</a><span>|</span><label class="collapse" for="c-37832243">[-]</label><label class="expand" for="c-37832243">[11 more]</label></div><br/><div class="children"><div class="content">DNS is a small protocol and is abused by DDoS actors worldwide for relay attacks.</div><br/><div id="37832414" class="c"><input type="checkbox" id="c-37832414" checked=""/><div class="controls bullet"><span class="by">scrpl</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37832243">parent</a><span>|</span><a href="#37836919">next</a><span>|</span><label class="collapse" for="c-37832414">[-]</label><label class="expand" for="c-37832414">[8 more]</label></div><br/><div class="children"><div class="content">DNS is from 1983, give it some slack</div><br/><div id="37833019" class="c"><input type="checkbox" id="c-37833019" checked=""/><div class="controls bullet"><span class="by">cmeacham98</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37832414">parent</a><span>|</span><a href="#37838454">next</a><span>|</span><label class="collapse" for="c-37833019">[-]</label><label class="expand" for="c-37833019">[6 more]</label></div><br/><div class="children"><div class="content">The point I&#x27;m trying to make is that &quot;small&quot; protocols aren&#x27;t less likely to be DDoS vectors.<p>Avoiding designing in DDoS relay&#x2F;amplication vectors requires luck or intention, not just making the protocol small.</div><br/><div id="37833525" class="c"><input type="checkbox" id="c-37833525" checked=""/><div class="controls bullet"><span class="by">scrpl</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37833019">parent</a><span>|</span><a href="#37838454">next</a><span>|</span><label class="collapse" for="c-37833525">[-]</label><label class="expand" for="c-37833525">[5 more]</label></div><br/><div class="children"><div class="content">Small, less complex protocols are inherently less likely to be insecure all things being equal, simply due to reduced attack surface.<p>DNS was created for a different environment, at a time when security wasn&#x27;t at forefront so it&#x27;s not a good example of the opposite.</div><br/><div id="37833857" class="c"><input type="checkbox" id="c-37833857" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37833525">parent</a><span>|</span><a href="#37835399">next</a><span>|</span><label class="collapse" for="c-37833857">[-]</label><label class="expand" for="c-37833857">[1 more]</label></div><br/><div class="children"><div class="content">This is such a strong claim I&#x27;d really appreciate something other than &quot;smaller is better&quot;<p>Abuse and abuse vectors vary wildly in complexity, some complexity is certainly required exactly to avoid dumb bottlenecks if not vulnerabilities. So based on what are you saying something simple will inherently resist abuse better?</div><br/></div></div><div id="37835399" class="c"><input type="checkbox" id="c-37835399" checked=""/><div class="controls bullet"><span class="by">baby_souffle</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37833525">parent</a><span>|</span><a href="#37833857">prev</a><span>|</span><a href="#37838454">next</a><span>|</span><label class="collapse" for="c-37835399">[-]</label><label class="expand" for="c-37835399">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Small, less complex protocols are inherently less likely to be insecure all things being equal, simply due to reduced attack surface.<p>That feels intuitive in the &quot;less code is less bugs is less security issues&quot; sense but implies that &quot;secure&quot; and &quot;can&#x27;t be abused&quot; are the same thing.<p>Related? Sure.  Same?  No.<p>Oddly enough, we probably could have prevented the replay&#x2F;amplification dos attacks that use DNS by making DNS more complex &#x2F; adding mutual authentication so it&#x27;s not possible for A to request something that is then sent to B.</div><br/><div id="37836701" class="c"><input type="checkbox" id="c-37836701" checked=""/><div class="controls bullet"><span class="by">LK5ZJwMwgBbHuVI</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37835399">parent</a><span>|</span><a href="#37838454">next</a><span>|</span><label class="collapse" for="c-37836701">[-]</label><label class="expand" for="c-37836701">[2 more]</label></div><br/><div class="children"><div class="content">We could have prevented the replay&#x2F;amplification dos attacks that use DNS by making DNS use TCP.<p>In practice though the only way to &quot;fix&quot; DNS that would&#x27;ve worked in the 80s would&#x27;ve probably been to require the request be padded to larger than the response...</div><br/><div id="37837749" class="c"><input type="checkbox" id="c-37837749" checked=""/><div class="controls bullet"><span class="by">smallnix</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37836701">parent</a><span>|</span><a href="#37838454">next</a><span>|</span><label class="collapse" for="c-37837749">[-]</label><label class="expand" for="c-37837749">[1 more]</label></div><br/><div class="children"><div class="content">But TCP is way more complex</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37838454" class="c"><input type="checkbox" id="c-37838454" checked=""/><div class="controls bullet"><span class="by">aflag</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37832414">parent</a><span>|</span><a href="#37833019">prev</a><span>|</span><a href="#37836919">next</a><span>|</span><label class="collapse" for="c-37838454">[-]</label><label class="expand" for="c-37838454">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also from 1983 and I haven&#x27;t been DDoSed</div><br/></div></div></div></div><div id="37836919" class="c"><input type="checkbox" id="c-37836919" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37832243">parent</a><span>|</span><a href="#37832414">prev</a><span>|</span><a href="#37836076">next</a><span>|</span><label class="collapse" for="c-37836919">[-]</label><label class="expand" for="c-37836919">[2 more]</label></div><br/><div class="children"><div class="content">DNS is an enormous protocol, almost unmeasurably large.</div><br/><div id="37839252" class="c"><input type="checkbox" id="c-37839252" checked=""/><div class="controls bullet"><span class="by">mcesch</span><span>|</span><a href="#37832128">root</a><span>|</span><a href="#37836919">parent</a><span>|</span><a href="#37836076">next</a><span>|</span><label class="collapse" for="c-37839252">[-]</label><label class="expand" for="c-37839252">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a bit overblown. There&#x27;s a lot there and some of it conflicts with itself but it&#x27;s not unmeasurably large by any means. It&#x27;s a knowable protocol (and yes, I&#x27;m aware of the camel meme[1]).<p>1. <a href="https:&#x2F;&#x2F;powerdns.org&#x2F;dns-camel&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;powerdns.org&#x2F;dns-camel&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37836076" class="c"><input type="checkbox" id="c-37836076" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#37832128">parent</a><span>|</span><a href="#37832243">prev</a><span>|</span><a href="#37838194">next</a><span>|</span><label class="collapse" for="c-37836076">[-]</label><label class="expand" for="c-37836076">[1 more]</label></div><br/><div class="children"><div class="content">HTTP&#x2F;2 <i>is</i> pretty small.</div><br/></div></div></div></div><div id="37838194" class="c"><input type="checkbox" id="c-37838194" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#37832128">prev</a><span>|</span><a href="#37838900">next</a><span>|</span><label class="collapse" for="c-37838194">[-]</label><label class="expand" for="c-37838194">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft dropped its patch details here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;issues&#x2F;93303">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;issues&#x2F;93303</a></div><br/></div></div><div id="37838900" class="c"><input type="checkbox" id="c-37838900" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#37838194">prev</a><span>|</span><a href="#37832417">next</a><span>|</span><label class="collapse" for="c-37838900">[-]</label><label class="expand" for="c-37838900">[2 more]</label></div><br/><div class="children"><div class="content">I would like to remind everyone that Google invented HTTP&#x2F;2.<p>Now they are telling us a yarn about how they are heroically saving us from the problem they created, but without mentioning the part that they created it.<p>The nerve of these tech companies! Microsoft has been doing this for decades, too.</div><br/><div id="37838934" class="c"><input type="checkbox" id="c-37838934" checked=""/><div class="controls bullet"><span class="by">gsich</span><span>|</span><a href="#37838900">parent</a><span>|</span><a href="#37832417">next</a><span>|</span><label class="collapse" for="c-37838934">[-]</label><label class="expand" for="c-37838934">[1 more]</label></div><br/><div class="children"><div class="content">They tried to solve problems that weren&#x27;t existant.</div><br/></div></div></div></div><div id="37832417" class="c"><input type="checkbox" id="c-37832417" checked=""/><div class="controls bullet"><span class="by">ta1243</span><span>|</span><a href="#37838900">prev</a><span>|</span><a href="#37832963">next</a><span>|</span><label class="collapse" for="c-37832417">[-]</label><label class="expand" for="c-37832417">[1 more]</label></div><br/><div class="children"><div class="content">See also<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37830998">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37830998</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37830987">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37830987</a></div><br/></div></div><div id="37832963" class="c"><input type="checkbox" id="c-37832963" checked=""/><div class="controls bullet"><span class="by">n4te</span><span>|</span><a href="#37832417">prev</a><span>|</span><a href="#37831724">next</a><span>|</span><label class="collapse" for="c-37832963">[-]</label><label class="expand" for="c-37832963">[6 more]</label></div><br/><div class="children"><div class="content">The blog header popping up constantly makes the page unreadable.</div><br/><div id="37833760" class="c"><input type="checkbox" id="c-37833760" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#37832963">parent</a><span>|</span><a href="#37831724">next</a><span>|</span><label class="collapse" for="c-37833760">[-]</label><label class="expand" for="c-37833760">[5 more]</label></div><br/><div class="children"><div class="content">Readability hack: <a href="https:&#x2F;&#x2F;github.com&#x2F;t-mart&#x2F;kill-sticky">https:&#x2F;&#x2F;github.com&#x2F;t-mart&#x2F;kill-sticky</a></div><br/><div id="37835873" class="c"><input type="checkbox" id="c-37835873" checked=""/><div class="controls bullet"><span class="by">oars</span><span>|</span><a href="#37832963">root</a><span>|</span><a href="#37833760">parent</a><span>|</span><a href="#37834376">next</a><span>|</span><label class="collapse" for="c-37835873">[-]</label><label class="expand" for="c-37835873">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing Kill Sticky!</div><br/></div></div><div id="37834376" class="c"><input type="checkbox" id="c-37834376" checked=""/><div class="controls bullet"><span class="by">n4te</span><span>|</span><a href="#37832963">root</a><span>|</span><a href="#37833760">parent</a><span>|</span><a href="#37835873">prev</a><span>|</span><a href="#37831724">next</a><span>|</span><label class="collapse" for="c-37834376">[-]</label><label class="expand" for="c-37834376">[3 more]</label></div><br/><div class="children"><div class="content">Ha, it works great! I like it, thank you!</div><br/><div id="37834754" class="c"><input type="checkbox" id="c-37834754" checked=""/><div class="controls bullet"><span class="by">ticulatedspline</span><span>|</span><a href="#37832963">root</a><span>|</span><a href="#37834376">parent</a><span>|</span><a href="#37831724">next</a><span>|</span><label class="collapse" for="c-37834754">[-]</label><label class="expand" for="c-37834754">[2 more]</label></div><br/><div class="children"><div class="content">Not sure about chrome but in Firefox there&#x27;s a button for &quot;reader view&quot; on many sites which works great for cutting out UI crap like that.</div><br/><div id="37835639" class="c"><input type="checkbox" id="c-37835639" checked=""/><div class="controls bullet"><span class="by">n4te</span><span>|</span><a href="#37832963">root</a><span>|</span><a href="#37834754">parent</a><span>|</span><a href="#37831724">next</a><span>|</span><label class="collapse" for="c-37835639">[-]</label><label class="expand" for="c-37835639">[1 more]</label></div><br/><div class="children"><div class="content">Good point, that also works. For some reason I never remember to use it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37831724" class="c"><input type="checkbox" id="c-37831724" checked=""/><div class="controls bullet"><span class="by">arisudesu</span><span>|</span><a href="#37832963">prev</a><span>|</span><a href="#37834180">next</a><span>|</span><label class="collapse" for="c-37831724">[-]</label><label class="expand" for="c-37831724">[19 more]</label></div><br/><div class="children"><div class="content">Can anyone can explain what&#x27;s novel about this attack that isn&#x27;t plain old requests flood?</div><br/><div id="37831860" class="c"><input type="checkbox" id="c-37831860" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#37831724">parent</a><span>|</span><a href="#37831906">next</a><span>|</span><label class="collapse" for="c-37831860">[-]</label><label class="expand" for="c-37831860">[15 more]</label></div><br/><div class="children"><div class="content">It depends on what you think a &quot;request flood&quot; attack is.<p>With HTTP&#x2F;1.1 you could send one request per RTT [0]. With HTTP&#x2F;2 multiplexing you could send 100 requests per RTT. With this attack you can send an indefinite number of requests per RTT.<p>I&#x27;d hope the diagram in this article (disclaimer: I&#x27;m a co-author) shows the difference, but maybe you mean yet another form of attack than the above?<p>[0] Modulo HTTP&#x2F;1.1 pipelining which can cut out one RTT component, but basically no real clients use HTTP&#x2F;1.1 pipelining, so its use would be a very crisp signal that it&#x27;s abusive traffic.</div><br/><div id="37832750" class="c"><input type="checkbox" id="c-37832750" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37831860">parent</a><span>|</span><a href="#37834987">next</a><span>|</span><label class="collapse" for="c-37832750">[-]</label><label class="expand" for="c-37832750">[10 more]</label></div><br/><div class="children"><div class="content">I think for this audience a good clarification is:<p>* HTTP&#x2F;1.1: 1 request per RTT <i>per connection</i><p>* HTTP&#x2F;2 multiplexing: 100 requests per RTT <i>per connection</i><p>* HTTP&#x2F;2 rapid reset: indefinite requests <i>per connection</i><p>In each case attackers are grinding down a performance limitation they had with previous generations of the attack over HTTP. It is a request flood; the thing people need to keep in mind is that HTTP made these floods annoying to generate.</div><br/><div id="37833785" class="c"><input type="checkbox" id="c-37833785" checked=""/><div class="controls bullet"><span class="by">maxfurman</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37832750">parent</a><span>|</span><a href="#37839670">next</a><span>|</span><label class="collapse" for="c-37833785">[-]</label><label class="expand" for="c-37833785">[2 more]</label></div><br/><div class="children"><div class="content">What does RTT stand for? My gut says &quot;Round Trip (something)&quot; but I could certainly be wrong.</div><br/><div id="37834081" class="c"><input type="checkbox" id="c-37834081" checked=""/><div class="controls bullet"><span class="by">hathawsh</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37833785">parent</a><span>|</span><a href="#37839670">next</a><span>|</span><label class="collapse" for="c-37834081">[-]</label><label class="expand" for="c-37834081">[1 more]</label></div><br/><div class="children"><div class="content">The HTTP spec defines it as Round Trip Time, but in this little discussion thread, &quot;round-trip transaction&quot; would be a better fit.<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Round_Trip_Time" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Round_Trip...</a></div><br/></div></div></div></div><div id="37839670" class="c"><input type="checkbox" id="c-37839670" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37832750">parent</a><span>|</span><a href="#37833785">prev</a><span>|</span><a href="#37834773">next</a><span>|</span><label class="collapse" for="c-37839670">[-]</label><label class="expand" for="c-37839670">[3 more]</label></div><br/><div class="children"><div class="content">I wonder why exactly this attack can&#x27;t be pulled off with HTTP&#x2F;1.1 and TCP RST for cancellation.
It seems that (even with SYN cookies involved) an attacker could create new connections, send HTTP request, then quickly after send a RST.<p>Is it just that the kernel doesn&#x27;t really communicate TCP RST all that well to the application, so the HTTP server continues to count the connection against the &quot;open connection limit&quot; even though it isn&#x27;t open anymore?</div><br/><div id="37839983" class="c"><input type="checkbox" id="c-37839983" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37839670">parent</a><span>|</span><a href="#37840265">next</a><span>|</span><label class="collapse" for="c-37839983">[-]</label><label class="expand" for="c-37839983">[1 more]</label></div><br/><div class="children"><div class="content">The problem for the attacker is they then run into resource limits on the TCP connections. The resets are essential to get the consumption not counting.</div><br/></div></div><div id="37840265" class="c"><input type="checkbox" id="c-37840265" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37839670">parent</a><span>|</span><a href="#37839983">prev</a><span>|</span><a href="#37834773">next</a><span>|</span><label class="collapse" for="c-37840265">[-]</label><label class="expand" for="c-37840265">[1 more]</label></div><br/><div class="children"><div class="content">The server kernel won&#x27;t communicate the new connection to the application until you go through SYN-SYNACK-ACK.</div><br/></div></div></div></div><div id="37834773" class="c"><input type="checkbox" id="c-37834773" checked=""/><div class="controls bullet"><span class="by">altairprime</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37832750">parent</a><span>|</span><a href="#37839670">prev</a><span>|</span><a href="#37832924">next</a><span>|</span><label class="collapse" for="c-37834773">[-]</label><label class="expand" for="c-37834773">[1 more]</label></div><br/><div class="children"><div class="content">In the style of the above clarification, how would you describe HTTP&#x2F;3 in &quot;x requests (per y)? per connection&quot;?</div><br/></div></div><div id="37832924" class="c"><input type="checkbox" id="c-37832924" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37832750">parent</a><span>|</span><a href="#37834773">prev</a><span>|</span><a href="#37836292">next</a><span>|</span><label class="collapse" for="c-37832924">[-]</label><label class="expand" for="c-37832924">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, that&#x27;s a crucial clarification. Thanks.</div><br/></div></div><div id="37836292" class="c"><input type="checkbox" id="c-37836292" checked=""/><div class="controls bullet"><span class="by">blauditore</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37832750">parent</a><span>|</span><a href="#37832924">prev</a><span>|</span><a href="#37834987">next</a><span>|</span><label class="collapse" for="c-37836292">[-]</label><label class="expand" for="c-37836292">[2 more]</label></div><br/><div class="children"><div class="content">What happens if you send more? Does it just get ignored by the server?</div><br/><div id="37836371" class="c"><input type="checkbox" id="c-37836371" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37836292">parent</a><span>|</span><a href="#37834987">next</a><span>|</span><label class="collapse" for="c-37836371">[-]</label><label class="expand" for="c-37836371">[1 more]</label></div><br/><div class="children"><div class="content">For most current HTTP&#x2F;2 implementations it&#x27;ll just be ignored, and that is a problem. We&#x27;ve seen versions of the attack doing just that, as covered in the variants  section of the article.<p>Servers should switch to closing the connection if clients exceed the stream limit too often, not just ignoring the bogus streams.</div><br/></div></div></div></div></div></div><div id="37834987" class="c"><input type="checkbox" id="c-37834987" checked=""/><div class="controls bullet"><span class="by">arisudesu</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37831860">parent</a><span>|</span><a href="#37832750">prev</a><span>|</span><a href="#37831906">next</a><span>|</span><label class="collapse" for="c-37834987">[-]</label><label class="expand" for="c-37834987">[4 more]</label></div><br/><div class="children"><div class="content">By request flood I mean, request flood, as in sending insanely high number of requests per unit of time (second) to the target server to cause exhaustion of its resources.<p>You&#x27;re right, with HTTP&#x2F;1.1 we have single request in-flight (or none in keep-alive state) at any moment. But that doesn&#x27;t limit number of simultaneous connections from a single IP address. An attacker could use the whole port space of TCP to create 65535 (theoretically) connections to the server and to send requests to them in parallel. This is a lot, too. In pre-HTTP&#x2F;2 era this could be mitigated by limiting number of connections per IP address.<p>In HTTP&#x2F;2 however, we could have multiple parallel connections with multiple parallel requests at any moment, this is by many orders higher than possible with HTTP&#x2F;1.x. But the preceeding mitigation could be implemented by applying to the number of requests over all connections per IP address.<p>I guess, this was overlooked in the implementations or in the protocol itself? Or rather, it is more difficult to apply restrictions because of L7 protocol multiplexing because it&#x27;s entirely in the userspace?<p>Added:
The diagram in the article (&quot;HTTP&#x2F;2 Rapid Reset attack&quot; figure) doesn&#x27;t really explain why this is an attack. In my thinking, as soon as the request is reset, the server resources are expected to be freed, thus not causing exhaustion of them. I think this should be possible in modern async servers.</div><br/><div id="37835212" class="c"><input type="checkbox" id="c-37835212" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37834987">parent</a><span>|</span><a href="#37838189">next</a><span>|</span><label class="collapse" for="c-37835212">[-]</label><label class="expand" for="c-37835212">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  But that doesn&#x27;t limit number of simultaneous connections from a single IP address.<p>Opening new connections is relatively expensive compared to sending data on an existing connection.<p>&gt; In my thinking, as soon as the request is reset, the server resources are expected to be freed,<p>You can&#x27;t claw back the CPU resources that have already been spent on processing the request before it was cancelled.<p>&gt; By request flood I mean, request flood, as in sending insanely high number of requests per unit of time (second) to the target server to cause exhaustion of its resources.<p>Right. And how do you send an insanely high number of requests? What if you could send more?<p>Imagine the largest attack you could do by &quot;sending an insanely high number requests&quot; with HTTP&#x2F;1.1 with a given set of machine and network resources. With H&#x2F;2 multiplexing you could do 100x that. With this attack, another 10x on top of that.</div><br/></div></div><div id="37838189" class="c"><input type="checkbox" id="c-37838189" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37834987">parent</a><span>|</span><a href="#37835212">prev</a><span>|</span><a href="#37831906">next</a><span>|</span><label class="collapse" for="c-37838189">[-]</label><label class="expand" for="c-37838189">[2 more]</label></div><br/><div class="children"><div class="content">&gt; An attacker could use the whole port space of TCP to create 65535 (theoretically) connections to the server and to send requests to them in parallel.<p>This is harder for the client than it is for the server. As a server, it&#x27;s kind of not great that I&#x27;m wasting 64k of my connections on one client, but it&#x27;s harder for you to make them than it is for me to receive them, so not a huge deal with today&#x27;s servers.<p>On this attack, I think the problem becomes if you&#x27;ve got a reverse proxy h2 frontend, and you don&#x27;t limit backend connections because you were limiting frontend requests. Sounds like HAProxy won&#x27;t start a new backend request until the pending backend requests is under the session limit; but google&#x27;s server must not have been limiting based on that. So cancel the frontend request, try to cancel the backend request, but before you confirm the backend request is canceled, start another one. (Plus what the sibling mentioned... backend may spend a lot of resources handling the requests that will be canceled immediately)</div><br/><div id="37840271" class="c"><input type="checkbox" id="c-37840271" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37838189">parent</a><span>|</span><a href="#37831906">next</a><span>|</span><label class="collapse" for="c-37840271">[-]</label><label class="expand" for="c-37840271">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re wrong about that. It&#x27;s hard to make 65k new connections on your average client OS, but a packet generator has no problem with it.</div><br/></div></div></div></div></div></div></div></div><div id="37831906" class="c"><input type="checkbox" id="c-37831906" checked=""/><div class="controls bullet"><span class="by">bribroder</span><span>|</span><a href="#37831724">parent</a><span>|</span><a href="#37831860">prev</a><span>|</span><a href="#37834180">next</a><span>|</span><label class="collapse" for="c-37831906">[-]</label><label class="expand" for="c-37831906">[3 more]</label></div><br/><div class="children"><div class="content">The new technique described avoids the maximum limit on number of requests per second (per client) the attacker can get the server to process. By sending both requests and stream resets within the same single connection, the attacker can send more requests per connection&#x2F;client than used to be possible, so it is perhaps cheaper as an attack and&#x2F;or more difficult to stop</div><br/><div id="37834785" class="c"><input type="checkbox" id="c-37834785" checked=""/><div class="controls bullet"><span class="by">arisudesu</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37831906">parent</a><span>|</span><a href="#37834180">next</a><span>|</span><label class="collapse" for="c-37834785">[-]</label><label class="expand" for="c-37834785">[2 more]</label></div><br/><div class="children"><div class="content">Is is a fundamental HTTP&#x2F;2 protocol issue or implementations issue? Could this be an issue at all, if a server has strict limits of requests per IP address, regardless of number of connections?</div><br/><div id="37837208" class="c"><input type="checkbox" id="c-37837208" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#37831724">root</a><span>|</span><a href="#37834785">parent</a><span>|</span><a href="#37834180">next</a><span>|</span><label class="collapse" for="c-37837208">[-]</label><label class="expand" for="c-37837208">[1 more]</label></div><br/><div class="children"><div class="content">Implementation issue. Some implementations are immune.</div><br/></div></div></div></div></div></div></div></div><div id="37834180" class="c"><input type="checkbox" id="c-37834180" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37831724">prev</a><span>|</span><a href="#37833497">next</a><span>|</span><label class="collapse" for="c-37834180">[-]</label><label class="expand" for="c-37834180">[7 more]</label></div><br/><div class="children"><div class="content">Wouldn’t this same attack apply to QUIC (and HTTP&#x2F;3)?</div><br/><div id="37834610" class="c"><input type="checkbox" id="c-37834610" checked=""/><div class="controls bullet"><span class="by">stonogo</span><span>|</span><a href="#37834180">parent</a><span>|</span><a href="#37833497">next</a><span>|</span><label class="collapse" for="c-37834610">[-]</label><label class="expand" for="c-37834610">[6 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t apply to HTTP&#x2F;3 because the receiver has to extend the stream concurrency maximum before the sender can open a new stream.  This attack works because the sender doesn&#x27;t have to wait for that after sending a reset in HTTP&#x2F;2.</div><br/><div id="37836121" class="c"><input type="checkbox" id="c-37836121" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#37834180">root</a><span>|</span><a href="#37834610">parent</a><span>|</span><a href="#37833497">next</a><span>|</span><label class="collapse" for="c-37836121">[-]</label><label class="expand" for="c-37836121">[5 more]</label></div><br/><div class="children"><div class="content">But the max is still ~100 streams...  And you can open 100 streams all with one UDP packet using zero-rtt connections.<p>I can send ~1 Million UDP packets per second from one machine.   So thats 100 million HTTP requests per second you have to deal with.  And when I bring in my 20,000 friends, you need to deal with 2 trillion requests per second.<p>I&#x27;d say that&#x27;s still a problem.</div><br/><div id="37836407" class="c"><input type="checkbox" id="c-37836407" checked=""/><div class="controls bullet"><span class="by">stonogo</span><span>|</span><a href="#37834180">root</a><span>|</span><a href="#37836121">parent</a><span>|</span><a href="#37833497">next</a><span>|</span><label class="collapse" for="c-37836407">[-]</label><label class="expand" for="c-37836407">[4 more]</label></div><br/><div class="children"><div class="content">Ok, but it&#x27;s not the same problem, which was the question asked.</div><br/><div id="37836855" class="c"><input type="checkbox" id="c-37836855" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37834180">root</a><span>|</span><a href="#37836407">parent</a><span>|</span><a href="#37833497">next</a><span>|</span><label class="collapse" for="c-37836855">[-]</label><label class="expand" for="c-37836855">[3 more]</label></div><br/><div class="children"><div class="content">I’m still missing something. Can’t you close a Quic stream and open another one within the same UDP packet?</div><br/><div id="37836917" class="c"><input type="checkbox" id="c-37836917" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#37834180">root</a><span>|</span><a href="#37836855">parent</a><span>|</span><a href="#37833497">next</a><span>|</span><label class="collapse" for="c-37836917">[-]</label><label class="expand" for="c-37836917">[2 more]</label></div><br/><div class="children"><div class="content">You can do it a few times, but you can&#x27;t do it 500 times. For HTTP&#x2F;3, the highest permitted stream ID is an explicit state variable communicated by the server to the client, eventually forcing a round-trip. That&#x27;s different from HTTP&#x2F;2 where the client is entitled to assume that new &quot;stream id window space&quot; (for the lack of a better term) opens up immediately after a stream is closed.<p>(I&#x27;m fudging things a bit. You can probably build attacks that look kind of similar, but we don&#x27;t think you you could build anything that is actually scalable. But we could be wrong about that! Hence the recommendation to apply similar mitigations to HTTP&#x2F;3 as well, even if it isn&#x27;t immediately vulnerable.)</div><br/><div id="37838614" class="c"><input type="checkbox" id="c-37838614" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37834180">root</a><span>|</span><a href="#37836917">parent</a><span>|</span><a href="#37833497">next</a><span>|</span><label class="collapse" for="c-37838614">[-]</label><label class="expand" for="c-37838614">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the explanation. Makes sense.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37834827" class="c"><input type="checkbox" id="c-37834827" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#37833497">prev</a><span>|</span><a href="#37835703">next</a><span>|</span><label class="collapse" for="c-37834827">[-]</label><label class="expand" for="c-37834827">[5 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this trivially mitigated by throttling?<p>And the throttling seems even simple: give each IP address an initial allowance of A requests, then increase the allowance every T time up to a maximum of B. Perhaps A=B=10, T=150ms.</div><br/><div id="37835105" class="c"><input type="checkbox" id="c-37835105" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#37834827">parent</a><span>|</span><a href="#37835245">next</a><span>|</span><label class="collapse" for="c-37835105">[-]</label><label class="expand" for="c-37835105">[3 more]</label></div><br/><div class="children"><div class="content">The whole point of a &#x27;D&#x27;DoS is that there are numerous compromised IP addresses, which only need to make maybe one connection each.<p>You can&#x27;t simply blacklist weird connections entirely, since legitimate clients <i>can</i> use those features.</div><br/><div id="37835217" class="c"><input type="checkbox" id="c-37835217" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#37834827">root</a><span>|</span><a href="#37835105">parent</a><span>|</span><a href="#37835245">next</a><span>|</span><label class="collapse" for="c-37835217">[-]</label><label class="expand" for="c-37835217">[2 more]</label></div><br/><div class="children"><div class="content">The whole point of this attack is to be able to make a lot of requests for each IP address.<p>If you are making one or few requests per IP you don&#x27;t need this attack, and also aren&#x27;t likely to have any effect on a Google-sized entity.</div><br/><div id="37839322" class="c"><input type="checkbox" id="c-37839322" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37834827">root</a><span>|</span><a href="#37835217">parent</a><span>|</span><a href="#37835245">next</a><span>|</span><label class="collapse" for="c-37839322">[-]</label><label class="expand" for="c-37839322">[1 more]</label></div><br/><div class="children"><div class="content">It is a little more complicated because a request is few layers deep. In HTTP2 you open a connection, start a stream, then send a request over that stream.<p>Are you tracking per connection? Per stream? Isn&#x27;t it normal for multiple requests to happen quite quickly? I load a single page with 50 external assets, those get multiplexed over the current stream - is that okay? Is that abusive? The other stream is handling a video player and its requesting (http2) frames of video data - too much? Too fast?</div><br/></div></div></div></div></div></div></div></div><div id="37836780" class="c"><input type="checkbox" id="c-37836780" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#37835703">prev</a><span>|</span><a href="#37834270">next</a><span>|</span><label class="collapse" for="c-37836780">[-]</label><label class="expand" for="c-37836780">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;nvd.nist.gov&#x2F;vuln&#x2F;detail&#x2F;CVE-2023-44487" rel="nofollow noreferrer">https:&#x2F;&#x2F;nvd.nist.gov&#x2F;vuln&#x2F;detail&#x2F;CVE-2023-44487</a><p>Dont forget about nghttp2</div><br/></div></div><div id="37834270" class="c"><input type="checkbox" id="c-37834270" checked=""/><div class="controls bullet"><span class="by">unethical_ban</span><span>|</span><a href="#37836780">prev</a><span>|</span><a href="#37836649">next</a><span>|</span><label class="collapse" for="c-37834270">[-]</label><label class="expand" for="c-37834270">[4 more]</label></div><br/><div class="children"><div class="content">I got out of web proxy management a while back and haven&#x27;t had to delve into HTTP2 or HTTP3.<p>It seems HTTP2 is TCP on TCP for HTTP messages specifically. This must be why HTTP3 is over a UDP based protocol.</div><br/><div id="37837069" class="c"><input type="checkbox" id="c-37837069" checked=""/><div class="controls bullet"><span class="by">rollcat</span><span>|</span><a href="#37834270">parent</a><span>|</span><a href="#37836649">next</a><span>|</span><label class="collapse" for="c-37837069">[-]</label><label class="expand" for="c-37837069">[3 more]</label></div><br/><div class="children"><div class="content">HTTP2 is not TCP on TCP (that&#x27;s a very basic recipe for a complete disaster, the moment any congestion kicks in); it&#x27;s mostly just multiplexing concurrent HTTP requests over a single TCP connection.<p>HTTP3 is using UDP for different reasons, although it effectively re-implements TCP from the application POV (it&#x27;s still HTTP under the hood after all). Basically with plain old TCP your bandwidth is limited by latency, because every transmitted frame has to be acknowledged - sequentially. Some industries&#x2F;applications (like transferring raw video files over the pond) have been using specialized, UDP-based transfer protocols for a while for this reason. You only need to re-transmit those frames you know didn&#x27;t make it, in any order it suits you.</div><br/><div id="37838075" class="c"><input type="checkbox" id="c-37838075" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#37834270">root</a><span>|</span><a href="#37837069">parent</a><span>|</span><a href="#37840276">next</a><span>|</span><label class="collapse" for="c-37838075">[-]</label><label class="expand" for="c-37838075">[1 more]</label></div><br/><div class="children"><div class="content">TCP&#x27;s stream nature causes multiplexing to bump into head of line blocking, basically.</div><br/></div></div><div id="37840276" class="c"><input type="checkbox" id="c-37840276" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#37834270">root</a><span>|</span><a href="#37837069">parent</a><span>|</span><a href="#37838075">prev</a><span>|</span><a href="#37836649">next</a><span>|</span><label class="collapse" for="c-37840276">[-]</label><label class="expand" for="c-37840276">[1 more]</label></div><br/><div class="children"><div class="content">HTTP on SCTP on UDP. If only protocols didn&#x27;t ossify.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>