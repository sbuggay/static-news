<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709283672982" as="style"/><link rel="stylesheet" href="styles.css?v=1709283672982"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2310.18166">Functional ownership through fractional uniqueness</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>37 comments</span></div><br/><div><div id="39558606" class="c"><input type="checkbox" id="c-39558606" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#39558289">next</a><span>|</span><label class="collapse" for="c-39558606">[-]</label><label class="expand" for="c-39558606">[1 more]</label></div><br/><div class="children"><div class="content">I recently read this series of papers, and while I don’t like the exact specific APIs they cook up, the core insights are wonderful.<p>The fractional piece of a generated symbol &#x2F; variable is a really nice way to think about may-alias information.<p>Likewise the way they talk about uniqueness as aliasing info from the past and linearity as aliasing info for the future, in the precursor paper, is a really nice explanation, that while being per se folk lore, is really hard to remember or explain usually.</div><br/></div></div><div id="39558289" class="c"><input type="checkbox" id="c-39558289" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#39558606">prev</a><span>|</span><a href="#39557482">next</a><span>|</span><label class="collapse" for="c-39558289">[-]</label><label class="expand" for="c-39558289">[5 more]</label></div><br/><div class="children"><div class="content">The work done in the Gradle project by Orchard, et al has been consistently good. I think a really solid progression from this paper is to take the same approach and combine it with the type system feature in ‘A Flexible Type System for Fearless Concurrency’ (Milano,etal 2022) [1]. The thrust of said paper is to utilize a coarser grain for ‘objects’ than what Rust promotes, which allows for much simpler implementations of common data structures (the paper uses a doubly linked, circular list as a well worked out example). Combining Milano’s approach to the scale at which ‘ownership’ is applied with the graded modality work from Orchard, et al would produce a very promising type system, with less syntactic noise from annotations, and still allow for a sliding scale of fineness in ownership semantics.<p>1 - <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3519939.3523443" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3519939.3523443</a></div><br/><div id="39558988" class="c"><input type="checkbox" id="c-39558988" checked=""/><div class="controls bullet"><span class="by">riscy</span><span>|</span><a href="#39558289">parent</a><span>|</span><a href="#39558608">next</a><span>|</span><label class="collapse" for="c-39558988">[-]</label><label class="expand" for="c-39558988">[2 more]</label></div><br/><div class="children"><div class="content">Swift recently adopted a region-based approach for safe concurrency that builds on Milano et al’s ideas (shared co-author as well): <a href="https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift-evolution&#x2F;blob&#x2F;main&#x2F;proposals&#x2F;0414-region-based-isolation.md">https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift-evolution&#x2F;blob&#x2F;main&#x2F;proposals...</a></div><br/><div id="39559013" class="c"><input type="checkbox" id="c-39559013" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#39558289">root</a><span>|</span><a href="#39558988">parent</a><span>|</span><a href="#39558608">next</a><span>|</span><label class="collapse" for="c-39559013">[-]</label><label class="expand" for="c-39559013">[1 more]</label></div><br/><div class="children"><div class="content">I didn’t know it had gotten approved&#x2F;merged. She (Milano) gave a talk at Strange Loop in ~October of 2023 and reviewed her research work and mentioned on one of the last few slides there was a formal proposal for the implementing the system in Swift. I bookmarked it earlier today, now I’ll have to find the whole discussion history and read that too.</div><br/></div></div></div></div><div id="39558608" class="c"><input type="checkbox" id="c-39558608" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#39558289">parent</a><span>|</span><a href="#39558988">prev</a><span>|</span><a href="#39557482">next</a><span>|</span><label class="collapse" for="c-39558608">[-]</label><label class="expand" for="c-39558608">[2 more]</label></div><br/><div class="children"><div class="content">I think you mean Granule</div><br/><div id="39558691" class="c"><input type="checkbox" id="c-39558691" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#39558289">root</a><span>|</span><a href="#39558608">parent</a><span>|</span><a href="#39557482">next</a><span>|</span><label class="collapse" for="c-39558691">[-]</label><label class="expand" for="c-39558691">[1 more]</label></div><br/><div class="children"><div class="content">True, Granule and Gerty are the language implementations out of Orchard’s group. Thanks for the correction.</div><br/></div></div></div></div></div></div><div id="39557482" class="c"><input type="checkbox" id="c-39557482" checked=""/><div class="controls bullet"><span class="by">digdugdirk</span><span>|</span><a href="#39558289">prev</a><span>|</span><a href="#39556715">next</a><span>|</span><label class="collapse" for="c-39557482">[-]</label><label class="expand" for="c-39557482">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;re some good resources to build up the knowledge base needed to understand this article?<p>I&#x27;ve always been fascinated by the building blocks of computation, there just seems to be a massive investment required to get that understanding.</div><br/><div id="39557832" class="c"><input type="checkbox" id="c-39557832" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#39557482">parent</a><span>|</span><a href="#39557906">next</a><span>|</span><label class="collapse" for="c-39557832">[-]</label><label class="expand" for="c-39557832">[1 more]</label></div><br/><div class="children"><div class="content">A while back I interviewed a coauthor of this paper here: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rqArTpY_kNY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rqArTpY_kNY</a><p>We discussed the language he&#x27;s helping develop (Granule) and which the concepts in this paper are implemented in. I actually asked him if he thought something like this paper would be possible and IIRC he said he was hopeful. I think listening to the interview would be a good way to get a feel for the big ideas.<p>To get deeper into it, I&#x27;d recommend learning Haskell at least up to the point where you understand typeclasses, functors, and monads. That will get you familiar with some relatively advanced type system features. Granule is a research language so it has additional stuff going on, but that is a solid foundation. After that, just google terms you don&#x27;t know (e.g. modal type theory) or look at the papers that are cited. You can also join the PLTD discord server, there are lots of type nerds in there who are usually happy to answer questions.</div><br/></div></div><div id="39557906" class="c"><input type="checkbox" id="c-39557906" checked=""/><div class="controls bullet"><span class="by">matt_d</span><span>|</span><a href="#39557482">parent</a><span>|</span><a href="#39557832">prev</a><span>|</span><a href="#39556715">next</a><span>|</span><label class="collapse" for="c-39557906">[-]</label><label class="expand" for="c-39557906">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend by starting with the talk by Daniel Marshall (one of the authors) from Lambda Days 2023, &quot;A Hitchhiker&#x27;s Guide to Linearity&quot;, <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QtlkqJGdnuM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QtlkqJGdnuM</a><p>The Granule Project&#x27;s website, <a href="https:&#x2F;&#x2F;granule-project.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;granule-project.github.io&#x2F;</a>, links relevant resources, too, in particular <a href="https:&#x2F;&#x2F;granule-project.github.io&#x2F;granule.html" rel="nofollow">https:&#x2F;&#x2F;granule-project.github.io&#x2F;granule.html</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;granule-project&#x2F;granule&#x2F;blob&#x2F;main&#x2F;examples&#x2F;intro.gr.md">https:&#x2F;&#x2F;github.com&#x2F;granule-project&#x2F;granule&#x2F;blob&#x2F;main&#x2F;example...</a><p>The latter tutorial is based on &quot;Quantitative program reasoning with graded modal types&quot; (ICFP 2019), with the talk and paper available at <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3341714" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3341714</a><p>See also &quot;Linearity and Uniqueness: An Entente Cordiale&quot; (ESOP 2022), <a href="https:&#x2F;&#x2F;granule-project.github.io&#x2F;papers&#x2F;esop22-paper.pdf" rel="nofollow">https:&#x2F;&#x2F;granule-project.github.io&#x2F;papers&#x2F;esop22-paper.pdf</a></div><br/></div></div></div></div><div id="39556715" class="c"><input type="checkbox" id="c-39556715" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#39557482">prev</a><span>|</span><a href="#39557057">next</a><span>|</span><label class="collapse" for="c-39556715">[-]</label><label class="expand" for="c-39556715">[25 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    the Rust compiler is able to infer that allowing two mutable borrows 
    is safe as long as one of them is never used
</code></pre>
This (i.e. proving a variable is never used) is impossible in general 
since it is equivalent to the halting problem.
There are many cases where it can be solved, so the compiler lets the programmer
get away with this in the cases where one of the mutable borrows is provably not used. Now imagine re-factoring the code so that the compiler could no longer produce the proof. Now an error is generated and the programmer is left scratching their head
wondering where this new error came from.</div><br/><div id="39556955" class="c"><input type="checkbox" id="c-39556955" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#39556715">parent</a><span>|</span><a href="#39556984">next</a><span>|</span><label class="collapse" for="c-39556955">[-]</label><label class="expand" for="c-39556955">[1 more]</label></div><br/><div class="children"><div class="content">The compiler doesn&#x27;t do anything here that is hard to understand- its approximate solution works purely in terms of the control flow graph, so there is a very clear and bright dividing line between &quot;you have a use of this variable here&quot; and not, which is never impacted by anything subtle about the values of conditions or whatever.<p>The closest to head-scratching that I have ever seen here are the sorts of errors that include &quot;note: value may be accessed in another iteration of this loop,&quot; or perhaps the corner cases that Polonius aims to solve if you count those.</div><br/></div></div><div id="39556984" class="c"><input type="checkbox" id="c-39556984" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39556715">parent</a><span>|</span><a href="#39556955">prev</a><span>|</span><a href="#39557217">next</a><span>|</span><label class="collapse" for="c-39556984">[-]</label><label class="expand" for="c-39556984">[9 more]</label></div><br/><div class="children"><div class="content">In an ideal (?) world, a refactoring would come along with a machine proof that the refactored code is equivalent to the original code (because otherwise, how can you be sure?). In that case, the compiler would also be able to prove that the code is still safe.<p>I believe that type checking should closely match the reasoning programmers do in their head, and thereby verify the correctness of that reasoning. Conversely, this means that programmers must express their reasoning through the type system. If something doesn’t typecheck, either the reasoning as expressed is wrong or incomplete, or the programmer has used some reasoning that cannot be expressed in the type system (meaning that the type system is lacking in that respect).</div><br/><div id="39557710" class="c"><input type="checkbox" id="c-39557710" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39556984">parent</a><span>|</span><a href="#39557009">next</a><span>|</span><label class="collapse" for="c-39557710">[-]</label><label class="expand" for="c-39557710">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I believe that type checking should closely match the reasoning programmers do in their head, and thereby verify the correctness of that reasoning. Conversely, this means that programmers must express their reasoning through the type system. If something doesn’t typecheck, either the reasoning as expressed is wrong or incomplete, or the programmer has used some reasoning that cannot be expressed in the type system (meaning that the type system is lacking in that respect).<p>Right. The (well, a) problem with NLL in Rust is that it isn&#x27;t expressible; it creates lifetimes that don&#x27;t correspond to anything in the syntax, and so can&#x27;t be written explicitly into the program even if the programmer wants to. (As opposed to conventional type inference where you can always write the type explicitly if the code is confusing)</div><br/><div id="39558048" class="c"><input type="checkbox" id="c-39558048" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557710">parent</a><span>|</span><a href="#39557009">next</a><span>|</span><label class="collapse" for="c-39558048">[-]</label><label class="expand" for="c-39558048">[2 more]</label></div><br/><div class="children"><div class="content">You couldn&#x27;t write explicit lifetimes before NLL, either. (Nor does conventional type inference mean you can always write the type! This is why people who design type systems care about &quot;principal types.&quot;)<p>NLL (and even moreso Polonius) brought the borrow checker closer to how programmers reason about lifetimes in their head than it was before, empirically speaking. The thing you described was a worry at the time but it never turned out to be accurate.<p>If there is anything about the borrow check that does match your description, it is things like &quot;borrow splitting&quot; and mutable reborrows, which can be done locally but are not expressible in function signatures. These problems existed long before NLL, though, and don&#x27;t have anything to do with syntax or lexical scope.</div><br/><div id="39558362" class="c"><input type="checkbox" id="c-39558362" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39558048">parent</a><span>|</span><a href="#39557009">next</a><span>|</span><label class="collapse" for="c-39558362">[-]</label><label class="expand" for="c-39558362">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You couldn&#x27;t write explicit lifetimes before NLL, either.<p>Well, no, but you can write scopes explicitly, and all your lifetimes correspond to scopes, by definition.<p>&gt; NLL (and even moreso Polonius) brought the borrow checker closer to how programmers reason about lifetimes in their head than it was before, empirically speaking. The thing you described was a worry at the time but it never turned out to be accurate.<p>It worked for how <i>some</i> programmers reason about lifetimes in their head. Not for me. Maybe I&#x27;m the minority.</div><br/></div></div></div></div></div></div><div id="39557009" class="c"><input type="checkbox" id="c-39557009" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39556984">parent</a><span>|</span><a href="#39557710">prev</a><span>|</span><a href="#39557217">next</a><span>|</span><label class="collapse" for="c-39557009">[-]</label><label class="expand" for="c-39557009">[5 more]</label></div><br/><div class="children"><div class="content">Proving that two programs are the same is not decidable either.</div><br/><div id="39557122" class="c"><input type="checkbox" id="c-39557122" checked=""/><div class="controls bullet"><span class="by">scarmig</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557009">parent</a><span>|</span><a href="#39557722">next</a><span>|</span><label class="collapse" for="c-39557122">[-]</label><label class="expand" for="c-39557122">[1 more]</label></div><br/><div class="children"><div class="content">Proving that two real numbers are the same is not decidable either. Despite that, there are some real numbers that we can prove are equal to each other (rarely).</div><br/></div></div><div id="39557722" class="c"><input type="checkbox" id="c-39557722" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557009">parent</a><span>|</span><a href="#39557122">prev</a><span>|</span><a href="#39557381">next</a><span>|</span><label class="collapse" for="c-39557722">[-]</label><label class="expand" for="c-39557722">[1 more]</label></div><br/><div class="children"><div class="content">Just to make it explicit, checking  an existing proof is very decidable, given a reasonable programming language. Now getting that proof does pose some practical difficulties, but it would doubtless be built up by fairly simple proofs derived from user-supplied editing steps; a bit of a pain, but not Halting-complete.</div><br/></div></div><div id="39557381" class="c"><input type="checkbox" id="c-39557381" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557009">parent</a><span>|</span><a href="#39557722">prev</a><span>|</span><a href="#39557217">next</a><span>|</span><label class="collapse" for="c-39557381">[-]</label><label class="expand" for="c-39557381">[2 more]</label></div><br/><div class="children"><div class="content">“You can’t do it in general” is the bathwater.</div><br/><div id="39557614" class="c"><input type="checkbox" id="c-39557614" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557381">parent</a><span>|</span><a href="#39557217">next</a><span>|</span><label class="collapse" for="c-39557614">[-]</label><label class="expand" for="c-39557614">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I am not clever enough to come up with a baby worth throwing out. Restricted to lexical scope seems pretty reasonable. Maybe someday this will compile:<p><pre><code>    let mut viridian = Colour(52, 161, 128);
    let x = &amp;mut viridian; 
    let y = &amp;mut viridian; 
    if find_counter_example_to_Reimann_Hypothesis {
       do something with x and y
    }</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="39557217" class="c"><input type="checkbox" id="c-39557217" checked=""/><div class="controls bullet"><span class="by">Hugsun</span><span>|</span><a href="#39556715">parent</a><span>|</span><a href="#39556984">prev</a><span>|</span><a href="#39557690">next</a><span>|</span><label class="collapse" for="c-39557217">[-]</label><label class="expand" for="c-39557217">[4 more]</label></div><br/><div class="children"><div class="content">The quote betrays a slight misunderstanding of non lexical lifetimes. The two borrows happen in separate implicit scopes. The first borrow is only valid until the second borrow is made. At that point it&#x27;s dropped. So the two mutable references can&#x27;t exist at the same time.<p>A refactor that breaks this ordering results in code that obviously shouldn&#x27;t work in the eyes of any non-beginner rust programmer.</div><br/><div id="39557402" class="c"><input type="checkbox" id="c-39557402" checked=""/><div class="controls bullet"><span class="by">legerdemain</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557217">parent</a><span>|</span><a href="#39557690">next</a><span>|</span><label class="collapse" for="c-39557402">[-]</label><label class="expand" for="c-39557402">[3 more]</label></div><br/><div class="children"><div class="content">You can 100% have multiple mutable references to the same variable in the same scope, without the first one getting dropped. For example:<p><pre><code>   fn main() {
      let mut s = String::from(&quot;s&quot;);
      let mut1: &amp;mut _ = &amp;mut s;
      let mut2: &amp;mut _ = &amp;mut *mut1;
      *mut2 = String::from(&quot;t&quot;);
      println!(&quot;using mut2: {mut2}&quot;);
      println!(&quot;using mut1: {mut1}&quot;);
   }
</code></pre>
Some people use a mental model of reference lifetimes that allows &quot;discontinuous lifetimes&quot; where the valid region has holes. I don&#x27;t think that&#x27;s how the compiler models reborrowing, and even under that model, `mut1` is created before `mut2` and gets dropped after `mut2`.</div><br/><div id="39557697" class="c"><input type="checkbox" id="c-39557697" checked=""/><div class="controls bullet"><span class="by">jayshua</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557402">parent</a><span>|</span><a href="#39557690">next</a><span>|</span><label class="collapse" for="c-39557697">[-]</label><label class="expand" for="c-39557697">[2 more]</label></div><br/><div class="children"><div class="content">I read this as mut1 and mut2 both being downgraded to shared references because they aren&#x27;t used to mutate anymore. I&#x27;d imagine that&#x27;s not what&#x27;s actually happening though?</div><br/><div id="39558040" class="c"><input type="checkbox" id="c-39558040" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557697">parent</a><span>|</span><a href="#39557690">next</a><span>|</span><label class="collapse" for="c-39558040">[-]</label><label class="expand" for="c-39558040">[1 more]</label></div><br/><div class="children"><div class="content">No - that they are both &amp;mut _ indicates that a mutable reference is being acquired regardless of whether or not they’re used for any mutation. Possibly the compiler could automatically lower to a shared reference if it detects no mutation access locally but there may be design reasons why that’s impossible (+ you can’t have a mutable and a shared reference simultaneously anyway so downgrading to shared would still be disallowed)</div><br/></div></div></div></div></div></div></div></div><div id="39557690" class="c"><input type="checkbox" id="c-39557690" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39556715">parent</a><span>|</span><a href="#39557217">prev</a><span>|</span><a href="#39556878">next</a><span>|</span><label class="collapse" for="c-39557690">[-]</label><label class="expand" for="c-39557690">[6 more]</label></div><br/><div class="children"><div class="content">Yeah. This is why I think NLL is a mistake, just as I&#x27;ve come to think that implicit TCE is a mistake. Our tools must not only be correct but also comprehensible.</div><br/><div id="39558234" class="c"><input type="checkbox" id="c-39558234" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39557690">parent</a><span>|</span><a href="#39556878">next</a><span>|</span><label class="collapse" for="c-39558234">[-]</label><label class="expand" for="c-39558234">[5 more]</label></div><br/><div class="children"><div class="content">Do you mean Tail Call Elimination? If so, are you thinking of all tail calls, or are you more focusing on the conversion of recursive calls to iteration?</div><br/><div id="39558272" class="c"><input type="checkbox" id="c-39558272" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39558234">parent</a><span>|</span><a href="#39556878">next</a><span>|</span><label class="collapse" for="c-39558272">[-]</label><label class="expand" for="c-39558272">[4 more]</label></div><br/><div class="children"><div class="content">Yes, tail call elimination. Conversion of recursion to iteration is the most common case, I don&#x27;t really understand what you&#x27;re asking by distinguishing between &quot;all tail calls&quot; and &quot;the conversion of recursive calls to iteration&quot;. The point is it&#x27;s a similar case where a seemingly innocuous refactor can break your program because the implicit TCE stops working.</div><br/><div id="39558410" class="c"><input type="checkbox" id="c-39558410" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39558272">parent</a><span>|</span><a href="#39556878">next</a><span>|</span><label class="collapse" for="c-39558410">[-]</label><label class="expand" for="c-39558410">[3 more]</label></div><br/><div class="children"><div class="content">Regarding the distinguishing between recursive tail calls and other tail calls:<p>The conversion of tail calls to direct jumps seems to me a simpler conversion, where refactoring would be less likely to introduce errors. The conversion of recursive calls to iteration is different, I can see how the implicit conversion could lead to much more sensitive preconditions that refactoring could cause to not be satisfied.<p>My initial (and rather lazily considered) reaction to the potential for breakage could be wrong, I doubt it would be worth an exhaustive testing effort to validate. I find TCE to be a conversion that is worth the potential downsides in heavily functional paradigms, but I certainly sympathize with becoming more skeptical of implicit alterations to code as written.</div><br/><div id="39558565" class="c"><input type="checkbox" id="c-39558565" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39558410">parent</a><span>|</span><a href="#39556878">next</a><span>|</span><label class="collapse" for="c-39558565">[-]</label><label class="expand" for="c-39558565">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The conversion of tail calls to direct jumps seems to me a simpler conversion, where refactoring would be less likely to introduce errors. The conversion of recursive calls to iteration is different, I can see how the implicit conversion could lead to much more sensitive preconditions that refactoring could cause to not be satisfied.<p>Isn&#x27;t it the same thing? If you convert a tail call to a jump, if the place you jumped to leads back to the same line (directly or indirectly) then you&#x27;ve converted recursion to iteration. Iteration is ultimately implemented as jumps too.<p>&gt; I doubt it would be worth an exhaustive testing effort to validate. I find TCE to be a conversion that is worth the potential downsides in heavily functional paradigms, but I certainly sympathize with becoming more skeptical of implicit alterations to code as written.<p>I&#x27;ve been bitten by it often enough to be wary. I swear I once saw a language that had an explicit keyword for tail calls (not just an annotation to error out if TCO wasn&#x27;t performed, but a keyword to make a tail call and no implicit optimization), which sounded like the best solution, but I can&#x27;t find it now.</div><br/><div id="39558770" class="c"><input type="checkbox" id="c-39558770" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39558565">parent</a><span>|</span><a href="#39556878">next</a><span>|</span><label class="collapse" for="c-39558770">[-]</label><label class="expand" for="c-39558770">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, after a relatively quick check, it seems that the tail recursive conversion is actually simpler and more predictable than in the non-recursive case. For recursive calls the stack size is always the same between the caller and callee so refactoring of the recursive function is less likely to produce errors. In the general case, where caller&#x2F;callee stacks are different sizes the algorithm requires more effort and analysis to ensure the proper stack adjustments are made, and such algorithms are seemingly going to more finicky with regards to changes in either function.<p>This certainly seems to be one of those times when my gut instinct was just absolutely backwards, so thanks for the response which prompted me to actual check my assumptions.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39556878" class="c"><input type="checkbox" id="c-39556878" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#39556715">parent</a><span>|</span><a href="#39557690">prev</a><span>|</span><a href="#39556812">next</a><span>|</span><label class="collapse" for="c-39556878">[-]</label><label class="expand" for="c-39556878">[2 more]</label></div><br/><div class="children"><div class="content">compiler != runtime<p>ultimately no code is free of side effects. this is a tool to mark code as safe and propagate that safety up the call stack to make your code&#x27;s safety something you can reason about.<p>it&#x27;s definitely true that if a piece of code is unsafe, you need to be more careful.<p>(not a rust programmer, but have had to fight the compiler when i first looked at it)</div><br/><div id="39556951" class="c"><input type="checkbox" id="c-39556951" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39556878">parent</a><span>|</span><a href="#39556812">next</a><span>|</span><label class="collapse" for="c-39556951">[-]</label><label class="expand" for="c-39556951">[1 more]</label></div><br/><div class="children"><div class="content">This is a static error. A compiler generated error. With static analysis reachability is not computable.</div><br/></div></div></div></div><div id="39556812" class="c"><input type="checkbox" id="c-39556812" checked=""/><div class="controls bullet"><span class="by">nh23423fefe</span><span>|</span><a href="#39556715">parent</a><span>|</span><a href="#39556878">prev</a><span>|</span><a href="#39557057">next</a><span>|</span><label class="collapse" for="c-39556812">[-]</label><label class="expand" for="c-39556812">[2 more]</label></div><br/><div class="children"><div class="content">why is it a head scratcher? the error message seems clear?</div><br/><div id="39556930" class="c"><input type="checkbox" id="c-39556930" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#39556715">root</a><span>|</span><a href="#39556812">parent</a><span>|</span><a href="#39557057">next</a><span>|</span><label class="collapse" for="c-39556930">[-]</label><label class="expand" for="c-39556930">[1 more]</label></div><br/><div class="children"><div class="content">The head scratcher is that as soon as the compiler can&#x27;t produce the proof (even though the borrow still may be unreachable) an error is generated. The programmer will be wondering why a new error cropped up when they may not have been doing anything that was semantically any different.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>