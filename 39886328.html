<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711962074806" as="style"/><link rel="stylesheet" href="styles.css?v=1711962074806"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/proposal-signals/proposal-signals">A proposal to add signals to JavaScript</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>beeman</span> | <span>214 comments</span></div><br/><div><div id="39887549" class="c"><input type="checkbox" id="c-39887549" checked=""/><div class="controls bullet"><span class="by">itsjustme2</span><span>|</span><a href="#39890755">next</a><span>|</span><label class="collapse" for="c-39887549">[-]</label><label class="expand" for="c-39887549">[27 more]</label></div><br/><div class="children"><div class="content">Am I the only one that thinks the vanilla js example is actually easier to read and work with?<p>- &quot;The setup is noise and boilerplate heavy.&quot; Actually the signals example looks just as noisy and boilerplate heavy to me. And it introduces new boilerplate concepts which are hard for beginners to understand.<p>- &quot;If the counter changes but parity does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.&quot; - Sounds like they want premature memoization.<p>- &quot;What if another part of our UI just wants to render when the counter updates?&quot; Then I agree the strawman example is probably not what you want. At that point you might want to handle the state using signals, event handling, central state store (e.g. redux-like tools), or some other method. I think this is also what they meant by &quot;The counter state is tightly coupled to the rendering system.&quot;? Some of this document feels a little repetitive.<p>- &quot;What if another part of our UI is dependent on isEven or parity alone?&quot; Sure, you could change your entire approach because of this if that&#x27;s a really central part of your app, but most often it&#x27;s not. And &quot;The render function, which is only dependent on parity must instead &quot;know&quot; that it actually needs to subscribe to counter.&quot; is often not an unreasonable obligation. I mean, that&#x27;s one of the nice things about pure computed functions- it&#x27;s easy to spot their inputs.</div><br/><div id="39887654" class="c"><input type="checkbox" id="c-39887654" checked=""/><div class="controls bullet"><span class="by">leononame</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39888833">next</a><span>|</span><label class="collapse" for="c-39887654">[-]</label><label class="expand" for="c-39887654">[11 more]</label></div><br/><div class="children"><div class="content">Why do you think this is premature memoization? This is an example, boiled down to a simple function. Do you think people just came up with the use case for this without ever having needed it?<p>I think an effort in standardizing signals, a concept that is increasingly used in UI development is a laudable effort. I don&#x27;t want to get into the nitty gritty about what is too much boilerplate and whether you should build an event system or not, but since signals are something that is used in a variety of frameworks, there might be a good reason to it? And why not make an effort and standardize them over time?</div><br/><div id="39891883" class="c"><input type="checkbox" id="c-39891883" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39887654">parent</a><span>|</span><a href="#39888484">next</a><span>|</span><label class="collapse" for="c-39891883">[-]</label><label class="expand" for="c-39891883">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a concept that is increasingly used in UI development<p>For a desktop app developer that&#x27;s a pretty funny statement, given that the Qt framework introduced signals and slots in the mid 90s.<p>I am curious how many web devs think that signals are a new concept. (I don&#x27;t necessarily mean the parent poster.)</div><br/></div></div><div id="39888484" class="c"><input type="checkbox" id="c-39888484" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39887654">parent</a><span>|</span><a href="#39891883">prev</a><span>|</span><a href="#39888833">next</a><span>|</span><label class="collapse" for="c-39888484">[-]</label><label class="expand" for="c-39888484">[9 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t want to get into the nitty gritty about what is too much boilerplate and whether you should build an event system or not<p>You&#x27;re basically saying you want this thing, but you don&#x27;t want to have to justify it</div><br/><div id="39889022" class="c"><input type="checkbox" id="c-39889022" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39888484">parent</a><span>|</span><a href="#39888833">next</a><span>|</span><label class="collapse" for="c-39889022">[-]</label><label class="expand" for="c-39889022">[8 more]</label></div><br/><div class="children"><div class="content">The rationale for it is the fact that multiple frameworks provide their own versions of this mechanism.  The proposal is to relocate extremely popular and common functionality from framework space to the language&#x2F;runtime space. The popularity of React is itself the rationale for the utility of this idea, and any terse version of the rationale is for show.  Is that a good enough rationale? Maybe, maybe not, but you are shooting the messenger.</div><br/><div id="39889121" class="c"><input type="checkbox" id="c-39889121" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889022">parent</a><span>|</span><a href="#39888833">next</a><span>|</span><label class="collapse" for="c-39889121">[-]</label><label class="expand" for="c-39889121">[7 more]</label></div><br/><div class="children"><div class="content">Most importantly: OP is right re: vanilla example is most legible. Reading the proposal, I have no idea what this &quot;Signal&quot; word adds other than complexity.<p>Less important: I really, really, really, really, am reluctant to consider that is something that needs standardizing.<p>Disclaimer: I don&#x27;t have 100% context if this concept is _really_ the same across all these frameworks.<p>But frankly, I doubt it, if it was that similar, why are there at least a dozen frameworks with their own version?*<p>Also, I&#x27;ve lived through React, Redux, effects, and so on becoming Fundamentally Necessary, until they&#x27;re not. Usually when it actually is fundamental you can smell it outside of JS as well. (ex. promises &lt;=&gt; futures). I&#x27;ve seen 1000 Rx frameworks come into style and go out of style, from JS to Objective-C to Kotlin to Dart. Let them live vibrant lives, don&#x27;t tie them to the browser.<p>*  I know that&#x27;s begging the question, put more complex: if they are that similar and that set in stone that its at a good point to codify, why are there enough differences between them to enable a dozen different frameworks that are actively used?</div><br/><div id="39890637" class="c"><input type="checkbox" id="c-39890637" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889121">parent</a><span>|</span><a href="#39891325">next</a><span>|</span><label class="collapse" for="c-39890637">[-]</label><label class="expand" for="c-39890637">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Disclaimer: I don&#x27;t have 100% context if this concept is _really_ the same across all these frameworks.<p>Very nearly[1] every current framework <i>now has</i> a similar concept, all with the same general foundation: some unit of atomic state, some mechanism to subscribe to its state changes by reading it in a tracking context, and some internal logic to notify those subscriptions when the state is written. They all have a varied set of related abstractions that build upon those fundamental concepts, which…<p>&gt; But frankly, I doubt it, if it was that similar, why are there at least a dozen frameworks with their own version?*<p>… is part of what distinguishes each such framework. Another part is that state management and derived computations are only <i>part</i> of what any of the frameworks do. They all have, beyond their diverse set of complementary reactive abstractions, also their own varied takes on templating, rendering models, data fetching, routing, composition, integration with other tools and systems.<p>Moreover, this foundational similarity between the frameworks is relatively recent. It’s a convergence around a successful set of basic abstractions which in many ways comes from each framework learning from the others. And that convergence is so pervasive that it’s motivating the standardization effort.<p>This especially stands out because the reference polyfill is derived from Angular’s implementation, which only very recently embraced the concept. From reading the PR notes, the implementation has only minor changes to satisfy the proposed spec. That’s because Angular’s own implementation, being so recent, internalizes many lessons learned from prior art which also inform the thinking behind the spec itself.<p>This is very much like the analogy to Promises, which saw a similar sea change in convergence around a set of basic foundational concepts after years of competing approaches eventually drifting in that same direction.<p>[1]: Most notably, React is unique in that it has largely avoided signals while many frameworks <i>inspired by it</i> have gravitated towards them.</div><br/><div id="39891535" class="c"><input type="checkbox" id="c-39891535" checked=""/><div class="controls bullet"><span class="by">merb</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39890637">parent</a><span>|</span><a href="#39891325">next</a><span>|</span><label class="collapse" for="c-39891535">[-]</label><label class="expand" for="c-39891535">[2 more]</label></div><br/><div class="children"><div class="content">what makes useState different than signals?!</div><br/><div id="39892014" class="c"><input type="checkbox" id="c-39892014" checked=""/><div class="controls bullet"><span class="by">veidelis</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39891535">parent</a><span>|</span><a href="#39891325">next</a><span>|</span><label class="collapse" for="c-39892014">[-]</label><label class="expand" for="c-39892014">[1 more]</label></div><br/><div class="children"><div class="content">Explicit vs implicit dependencies (useEffect vs Signal.Computed&#x2F;effect) and the fact that signals in contrast to useState can be used outside of react context which I assume is a good thing.<p>I personally mostly prefer more explicit handling of &quot;observable values&quot; where function signatures show which signals&#x2F;observables are used inside them.</div><br/></div></div></div></div></div></div><div id="39891325" class="c"><input type="checkbox" id="c-39891325" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889121">parent</a><span>|</span><a href="#39890637">prev</a><span>|</span><a href="#39889844">next</a><span>|</span><label class="collapse" for="c-39891325">[-]</label><label class="expand" for="c-39891325">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why are there enough differences between them to enable a dozen different frameworks that are actively used?<p>Because they are not in the standard library of the language? Because they all arrived at the solution at different times and had to adapt the solution to the various idiosyncratic ways of each library? Because this happen in each and every language: people have similar, but different solutions until they are built into the language&#x2F;standard library?</div><br/></div></div><div id="39889844" class="c"><input type="checkbox" id="c-39889844" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889121">parent</a><span>|</span><a href="#39891325">prev</a><span>|</span><a href="#39891511">next</a><span>|</span><label class="collapse" for="c-39889844">[-]</label><label class="expand" for="c-39889844">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But frankly, I doubt it, if it was that similar, why are there at least a dozen frameworks with their own version?*<p>Welcome to the fashion cycle that is JavaScript. Given a few years, every old concept gets reinvented and then you have half a dozen frameworks that are basically the same but sufficiently different so that you have to relearn the APIs. This is what I think standardization helps circumvent<p>A good standard library prevents fragmentation on ideas that are good enough to keep getting reinvented</div><br/></div></div><div id="39891511" class="c"><input type="checkbox" id="c-39891511" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889121">parent</a><span>|</span><a href="#39889844">prev</a><span>|</span><a href="#39888833">next</a><span>|</span><label class="collapse" for="c-39891511">[-]</label><label class="expand" for="c-39891511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But frankly, I doubt it, if it was that similar, why are there at least a dozen frameworks with their own version?*<p>To answer this specifically: signals are a relatively low-level part of most frameworks. Once you&#x27;ve got signals, there are still plenty of other decisions to make as to how a specific framework works that differentiate one framework from another. For example:<p>* Different frameworks expose the underlying mechanism of signals in different ways. SolidJS explicitly separates out the read and write parts of a signal in order to encourage one-way data flow, whereas Vue exposes signals as a mutable object using proxies to give a more conventional, imperative API.<p>* Different frameworks will tie signals to different parts of the rendering process. For example, typically, signals have been used to decide when you rerender a component - Vue and Preact (mostly) work like this. That way, you still have render functions and a vdom of some description. On the other hand frameworks like SolidJS and Svelte use a compiler to tie signal updates directly to instructions to update parts of the DOM.<p>* Different frameworks make different choices about what additional features are included in the framework, completely outside of the signal mechanism. Angular brings its own services and DI mechanism, Vue bundles a tool for isolating component styles, SolidJS strips most parts away but is designed to produce very efficient code, etc.<p>So in total, even if all of the frameworks shared the same signals mechanism, they&#x27;d all still behave very differently and offer very different approaches to using them.<p>As to why different frameworks use different implementations as opposed to standardising on a single library, as I understand it this has a lot to do with how signals are currently often tied to the component lifestyle of different frameworks. Because signals require circular references, it&#x27;s very difficult to build them in such a way that they will be garbage collected at the right time, at least in Javascript. A lot of frameworks therefore tie the listener lifecycle to the lifecycle of the components themselves, which means that the listeners can be destroyed when the component is no longer in use. This requires signals to typically be relatively deeply integrated into the framework.<p>They reference this a bit in the proposal, and mention both the GC side of things (which is easier to fix if you&#x27;re adding a new primitive directly to the engine), and providing lots of hooks to make it possible to tie subscriptions to the component lifecycle. So I suspect they&#x27;re thinking about this issue, although I also suspect it&#x27;ll be a fairly hard problem.<p>Fwiw, as someone who has worked a lot with signals, I am also somewhat sceptical of this proposal. Signals are very powerful and useful, but I&#x27;m not sure if they, by themselves, represent enough of a fundamental mechanism to be worth embedding into the language.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39888833" class="c"><input type="checkbox" id="c-39888833" checked=""/><div class="controls bullet"><span class="by">ksherlock</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39887654">prev</a><span>|</span><a href="#39891062">next</a><span>|</span><label class="collapse" for="c-39888833">[-]</label><label class="expand" for="c-39888833">[5 more]</label></div><br/><div class="children"><div class="content">I agree. But look at Preact&#x27;s signal documentation -<p><a href="https:&#x2F;&#x2F;preactjs.com&#x2F;guide&#x2F;v10&#x2F;signals" rel="nofollow">https:&#x2F;&#x2F;preactjs.com&#x2F;guide&#x2F;v10&#x2F;signals</a><p>&quot;In Preact, when a signal is passed down through a tree as props or context, we&#x27;re only passing around references to the signal. The signal can be updated without re-rendering any components, since components see the signal and not its value. This lets us skip all of the expensive rendering work and jump immediately to any components in the tree that actually access the signal&#x27;s .value property.&quot;<p>&quot;Signals have a second important characteristic, which is that they track when their value is accessed and when it is updated. In Preact, accessing a signal&#x27;s .value property from within a component automatically re-renders the component when that signal&#x27;s value changes.&quot;<p>I think it makes a lot more sense in a context like that.</div><br/><div id="39888866" class="c"><input type="checkbox" id="c-39888866" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39888833">parent</a><span>|</span><a href="#39891062">next</a><span>|</span><label class="collapse" for="c-39888866">[-]</label><label class="expand" for="c-39888866">[4 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; In Preact, when a signal is passed down through a tree as props or context,<p>I have found that passing props makes React-like applications very complex and messy and props are to be avoided as must as practical.<p>The mechanism for avoiding props is Custom events.<p>It concerns me to see the concept of signals being passed as props when surely signals&#x2F;events should be removing the need for props?</div><br/><div id="39889441" class="c"><input type="checkbox" id="c-39889441" checked=""/><div class="controls bullet"><span class="by">Pufferbo</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39888866">parent</a><span>|</span><a href="#39891062">next</a><span>|</span><label class="collapse" for="c-39889441">[-]</label><label class="expand" for="c-39889441">[3 more]</label></div><br/><div class="children"><div class="content">You don’t need to pass a Preact signal as a prop to get reactivity. If you’re using Preact, signal references will make your component reactive by default, and if you’re using React you can introduce reactivity by way of the useSignals hook or a Babel plugin. (1)<p>React signals have become my go to state management tool. So easy to use and very flexible.<p>1: <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@preact&#x2F;signals-react" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@preact&#x2F;signals-react</a></div><br/><div id="39889526" class="c"><input type="checkbox" id="c-39889526" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889441">parent</a><span>|</span><a href="#39891062">next</a><span>|</span><label class="collapse" for="c-39889526">[-]</label><label class="expand" for="c-39889526">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; React signals have become my go to state management tool.<p>I&#x27;ve ditched almost all state in my React apps except state local to the component.<p>Custom events do all the work for passing information around the application and directing activity.<p>What do signals give me that events do not?</div><br/><div id="39890032" class="c"><input type="checkbox" id="c-39890032" checked=""/><div class="controls bullet"><span class="by">Pufferbo</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889526">parent</a><span>|</span><a href="#39891062">next</a><span>|</span><label class="collapse" for="c-39890032">[-]</label><label class="expand" for="c-39890032">[1 more]</label></div><br/><div class="children"><div class="content">I’m also a fan of local state, but there are some cases where it makes sense for a bit of global state - mainly user context.<p>However you can use signals for local state as well and they work amazingly. Being able to assign a new value to a signal without having to go though a setter is a way cleaner pattern, in my opinion.<p>The other use cause is for communication between micro frontends. It’s so nice to just be able to import&#x2F;export a signal and get its reactivity. Before them, I would create a pub&#x2F;sub pattern and that’s just not as clean.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39891062" class="c"><input type="checkbox" id="c-39891062" checked=""/><div class="controls bullet"><span class="by">vundercind</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39888833">prev</a><span>|</span><a href="#39887887">next</a><span>|</span><label class="collapse" for="c-39891062">[-]</label><label class="expand" for="c-39891062">[1 more]</label></div><br/><div class="children"><div class="content">I dislike both examples but find the Signals one far worse, no question.<p>You <i>can</i> do it that way, but… why? When you could just not?</div><br/></div></div><div id="39887887" class="c"><input type="checkbox" id="c-39887887" checked=""/><div class="controls bullet"><span class="by">LittleDan</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39891062">prev</a><span>|</span><a href="#39889812">next</a><span>|</span><label class="collapse" for="c-39887887">[-]</label><label class="expand" for="c-39887887">[3 more]</label></div><br/><div class="children"><div class="content">I think there is room for improvement in how we explain this. The problems aren’t really visible in this small sample and comes up more for bigger things. PRs welcome.</div><br/><div id="39888656" class="c"><input type="checkbox" id="c-39888656" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39887887">parent</a><span>|</span><a href="#39891332">next</a><span>|</span><label class="collapse" for="c-39888656">[-]</label><label class="expand" for="c-39888656">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps mentioning the tradeoffs between a simple easy to explain example vs a more obvious comprehensive example. With links to more complex code bases? With a before &amp; after?</div><br/></div></div><div id="39891332" class="c"><input type="checkbox" id="c-39891332" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39887887">parent</a><span>|</span><a href="#39888656">prev</a><span>|</span><a href="#39889812">next</a><span>|</span><label class="collapse" for="c-39891332">[-]</label><label class="expand" for="c-39891332">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t be surprised if Ryan Carniato already has a perfect explanation somewhere :)</div><br/></div></div></div></div><div id="39889812" class="c"><input type="checkbox" id="c-39889812" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39887887">prev</a><span>|</span><a href="#39887591">next</a><span>|</span><label class="collapse" for="c-39889812">[-]</label><label class="expand" for="c-39889812">[2 more]</label></div><br/><div class="children"><div class="content">I think it’s worth avoiding a change in design when you pass some threshold of complexity. The vanilla JS approach has some scaling limitation in term of state graph complexity, and the problem isn’t the ergonomics above and below the threshold, but discontinuous  change in ergonomics when you cross that threshold</div><br/><div id="39890440" class="c"><input type="checkbox" id="c-39890440" checked=""/><div class="controls bullet"><span class="by">aporetics</span><span>|</span><a href="#39887549">root</a><span>|</span><a href="#39889812">parent</a><span>|</span><a href="#39887591">next</a><span>|</span><label class="collapse" for="c-39890440">[-]</label><label class="expand" for="c-39890440">[1 more]</label></div><br/><div class="children"><div class="content">Well said</div><br/></div></div></div></div><div id="39887591" class="c"><input type="checkbox" id="c-39887591" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39889812">prev</a><span>|</span><a href="#39887884">next</a><span>|</span><label class="collapse" for="c-39887591">[-]</label><label class="expand" for="c-39887591">[1 more]</label></div><br/><div class="children"><div class="content">I agree the initial example is easier to read, but it has problems as stated.</div><br/></div></div><div id="39887884" class="c"><input type="checkbox" id="c-39887884" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39887591">prev</a><span>|</span><a href="#39890663">next</a><span>|</span><label class="collapse" for="c-39887884">[-]</label><label class="expand" for="c-39887884">[1 more]</label></div><br/><div class="children"><div class="content">Since reactivity is not baked into Javascript. Adding reactivity is going to add abstraction overhead. It&#x27;s meant to be used if it&#x27;s needed. Not necessarily a default way to work with state.<p>In my experience, the big benefit is the ability to make reactive state modular. In an imperative style, additional state is needed to track changes. Modularity is achieved using abstraction. Only use when needed.<p>&gt; Sounds like they want premature memoization<p>It&#x27;s a balance to present a simple example that is applicable. Cases where reactivity have a clear benefit tend to be more complex examples. Which is more difficult to demonstrate than a simple, less applicable example.</div><br/></div></div><div id="39890663" class="c"><input type="checkbox" id="c-39890663" checked=""/><div class="controls bullet"><span class="by">tipiirai</span><span>|</span><a href="#39887549">parent</a><span>|</span><a href="#39887884">prev</a><span>|</span><a href="#39890978">next</a><span>|</span><label class="collapse" for="c-39890663">[-]</label><label class="expand" for="c-39890663">[1 more]</label></div><br/><div class="children"><div class="content">Definitely not. I prefer the vanilla version as well.</div><br/></div></div></div></div><div id="39890755" class="c"><input type="checkbox" id="c-39890755" checked=""/><div class="controls bullet"><span class="by">fwlr</span><span>|</span><a href="#39887549">prev</a><span>|</span><a href="#39890148">next</a><span>|</span><label class="collapse" for="c-39890755">[-]</label><label class="expand" for="c-39890755">[8 more]</label></div><br/><div class="children"><div class="content">When they added Promises to JavaScript, I bristled at the thought that I might have to start writing `new Promise` everywhere.<p>In practice, I can count on two hands the number of times I’ve written `new Promise`. What <i>did</i> happen, though, is I started to write `.then` a whole lot more, especially when working with third party libraries.<p>In the end, the actual day-to-day effect of the Promise addition to JavaScript was it gave me a fairly simple, usually solid, and mostly universal interface to a wide variety of special behaviors and capabilities provided by third party libraries. Whether it’s a file read or an api request or a build step output, I know I can write `.then(res =&gt; …)` and I’m already 50% of the way to something workable.<p>If this Signal proposal can do something similar for me when it comes to the Cambrian explosion of reactive UI frameworks, I am in favor! What’s more, maybe it will even help take reactivity beyond UI; I’ve often daydreamed about some kind of incrementally re-computed state tree for things other than UI state.</div><br/><div id="39891312" class="c"><input type="checkbox" id="c-39891312" checked=""/><div class="controls bullet"><span class="by">jonathanlydall</span><span>|</span><a href="#39890755">parent</a><span>|</span><a href="#39890148">next</a><span>|</span><label class="collapse" for="c-39891312">[-]</label><label class="expand" for="c-39891312">[7 more]</label></div><br/><div class="children"><div class="content">I assumed the Promises was added primarily so that async&#x2F;await could be added, which is where the really substantial quality of life improvement is. In practice you rarely need to explicitly go “new Promise” yourself.<p>While .then in initial promises was a great improvement over nested delegates and is fine for simple chained promises, once you start conditionally chaining different promises or need different error handling for particular chains in the promise, or wanting to do an early return, the code can become much harder to read and work with.<p>With async&#x2F;await though you just write the call essentially as if it’s not a promise and can easily put try&#x2F;catch around particular promise calls, easily have early returns, etc.</div><br/><div id="39891416" class="c"><input type="checkbox" id="c-39891416" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#39890755">root</a><span>|</span><a href="#39891312">parent</a><span>|</span><a href="#39890148">next</a><span>|</span><label class="collapse" for="c-39891416">[-]</label><label class="expand" for="c-39891416">[6 more]</label></div><br/><div class="children"><div class="content">&gt; In practice you rarely need to explicitly go “new Promise” yourself<p>However you do quite often need to use Promise.all, even when using async&#x2F;await.</div><br/><div id="39891961" class="c"><input type="checkbox" id="c-39891961" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#39890755">root</a><span>|</span><a href="#39891416">parent</a><span>|</span><a href="#39891922">next</a><span>|</span><label class="collapse" for="c-39891961">[-]</label><label class="expand" for="c-39891961">[1 more]</label></div><br/><div class="children"><div class="content">Also, wrapping callback APIs or containing side effects:<p><pre><code>  function sleep(ms) {
    return new Promise((resolve) =&gt; setTimeout(resolve, ms));
  }
  await sleep(100);
</code></pre>
There are some use cases for the Promise class still, and it’s great to have that kind of control facility at hand when you need it.</div><br/></div></div><div id="39891922" class="c"><input type="checkbox" id="c-39891922" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#39890755">root</a><span>|</span><a href="#39891416">parent</a><span>|</span><a href="#39891961">prev</a><span>|</span><a href="#39891560">next</a><span>|</span><label class="collapse" for="c-39891922">[-]</label><label class="expand" for="c-39891922">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s  an issue with JavaScript though. It&#x27;s inherent complexity in your code&#x27;s handling of concurrent operations, not incidental complexity arising from the language.</div><br/></div></div><div id="39891560" class="c"><input type="checkbox" id="c-39891560" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#39890755">root</a><span>|</span><a href="#39891416">parent</a><span>|</span><a href="#39891922">prev</a><span>|</span><a href="#39890148">next</a><span>|</span><label class="collapse" for="c-39891560">[-]</label><label class="expand" for="c-39891560">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve literally never needed to do that. What&#x27;s a real world use case?</div><br/><div id="39891629" class="c"><input type="checkbox" id="c-39891629" checked=""/><div class="controls bullet"><span class="by">3m</span><span>|</span><a href="#39890755">root</a><span>|</span><a href="#39891560">parent</a><span>|</span><a href="#39891652">next</a><span>|</span><label class="collapse" for="c-39891629">[-]</label><label class="expand" for="c-39891629">[1 more]</label></div><br/><div class="children"><div class="content">Doing multiple async tasks concurrently as opposed to in sequence. If you have never used this you have either worked on extremely simple systems or have been leaving a ton of perf gains on the table.</div><br/></div></div><div id="39891652" class="c"><input type="checkbox" id="c-39891652" checked=""/><div class="controls bullet"><span class="by">mattdesl</span><span>|</span><a href="#39890755">root</a><span>|</span><a href="#39891560">parent</a><span>|</span><a href="#39891629">prev</a><span>|</span><a href="#39890148">next</a><span>|</span><label class="collapse" for="c-39891652">[-]</label><label class="expand" for="c-39891652">[1 more]</label></div><br/><div class="children"><div class="content">I often map a series of X to Y with Promise.all. For example, mapping a series of image URIs to loaded Image elements.<p>It is shorter to write than a for of loop, and importantly, all images will be loaded in parallel rather than sequentially, which can be significantly faster.<p><pre><code>  images = Promise.all(uris.map(loadImage))</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39890148" class="c"><input type="checkbox" id="c-39890148" checked=""/><div class="controls bullet"><span class="by">nikitaga</span><span>|</span><a href="#39890755">prev</a><span>|</span><a href="#39886969">next</a><span>|</span><label class="collapse" for="c-39890148">[-]</label><label class="expand" for="c-39890148">[10 more]</label></div><br/><div class="children"><div class="content">Why does it need to be a part of the language? This could be a library. There <i>are</i> such libraries. They are small, so including them in your code is no big deal. Adding this to the language <i>should not even be a goal</i>.<p>Thinking that the current crop of JS UI libraries designed their signals in such a good way that it needs to become a part of the language is hubris. Signals have many possible implementations with different tradeoffs, and none of them deserve to have a special place in the JavaScript spec.<p>Before these libraries used signals, they or their predecessors used virtual DOM. Luckily, <i>that</i> didn&#x27;t become part of JS, but how are signals any different? They aren&#x27;t. The argument for making them standard is even worse than for virtual DOM.<p>Are we just going pile every fad into a runtime that basically has no way to dispose of no-longer-wanted features without breaking the web? That is quite short sighted.</div><br/><div id="39891889" class="c"><input type="checkbox" id="c-39891889" checked=""/><div class="controls bullet"><span class="by">kabes</span><span>|</span><a href="#39890148">parent</a><span>|</span><a href="#39891351">next</a><span>|</span><label class="collapse" for="c-39891889">[-]</label><label class="expand" for="c-39891889">[1 more]</label></div><br/><div class="children"><div class="content">You can say this about most things in the standard library. But as stated in the motivation, there&#x27;s an ongoing trend to extend the rather small standard library js offers, so you don&#x27;t need to have a package for each and every common task.<p>You can argue about the need for this, but if we&#x27;re going to extend the standard lib, then looking at what is popular is a good approach IMO.<p>&gt; Before these libraries used signals, they or their predecessors used virtual DOM<p>Signals are not a replacement 
for virtual DOM.</div><br/></div></div><div id="39891351" class="c"><input type="checkbox" id="c-39891351" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#39890148">parent</a><span>|</span><a href="#39891889">prev</a><span>|</span><a href="#39890918">next</a><span>|</span><label class="collapse" for="c-39891351">[-]</label><label class="expand" for="c-39891351">[2 more]</label></div><br/><div class="children"><div class="content">One good argument for standardizing Signals is that debugging them seems to be a nightmare. Imagine a deep tree of calculated signals firing off each other and you need to find the source of what started the chain reaction. Standardizing will allow devtools to develop around it.</div><br/><div id="39891776" class="c"><input type="checkbox" id="c-39891776" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#39890148">root</a><span>|</span><a href="#39891351">parent</a><span>|</span><a href="#39890918">next</a><span>|</span><label class="collapse" for="c-39891776">[-]</label><label class="expand" for="c-39891776">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t fire off each other, they simply depend on each other like functions do:<p><pre><code>  a = () =&gt; 42
  b = () =&gt; a() - 1
  c = () =&gt; a() + b() * 2
</code></pre>
It isn&#x27;t a bigger nightmare than debugging pure functions. The source for `c` is `a` and `b`. All signal values (as proposed) will be lexically available in a body of a dependent signal, so there&#x27;s no hidden registry to navigate anyway. If in-browser IDEs want to record a call tree for an activation record, they can do that without a standard.</div><br/></div></div></div></div><div id="39890918" class="c"><input type="checkbox" id="c-39890918" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39890148">parent</a><span>|</span><a href="#39891351">prev</a><span>|</span><a href="#39890175">next</a><span>|</span><label class="collapse" for="c-39890918">[-]</label><label class="expand" for="c-39890918">[4 more]</label></div><br/><div class="children"><div class="content">Good points. We don’t want the wrong thing. But we want the right one!<p>Reactive UI won. The main thing stopping me from using vanilla JS is the absolute explosion in complexity managing state for even small sized applications. To me, any reactive framework is better than vanilla, so perhaps there is a construct missing? Now that it’s been a decade or so, we <i>should</i> start thinking about possible cut-points for standardization. Like with promises, this could bring down complexity for extremely common use-cases, if done right.<p>I think a better way to evaluate it would be: “would this proposal be used by existing reactive frameworks?”. If not, why? What’s missing? What’s superfluous? What about lessons from UI annd reactivity from other languages? There’s a lot of fragmented experience to distill, but it’s a worthwhile endeavor imo.</div><br/><div id="39891286" class="c"><input type="checkbox" id="c-39891286" checked=""/><div class="controls bullet"><span class="by">nikitaga</span><span>|</span><a href="#39890148">root</a><span>|</span><a href="#39890918">parent</a><span>|</span><a href="#39890175">next</a><span>|</span><label class="collapse" for="c-39891286">[-]</label><label class="expand" for="c-39891286">[3 more]</label></div><br/><div class="children"><div class="content">If you want to do &quot;the right thing&quot; – implement your proposal as a library, AND convince people to use it <i>on its own technical merits</i>. Then when everyone uses it (because it&#x27;s so obviously &quot;the right thing&quot;), you can start asking if anyone wants your library to be built into the language.<p>But that&#x27;s not what you&#x27;re doing. You&#x27;re gunning for becoming the standard from the start – you are trying to convince people to use your draft implementation <i>based on its status as a proposed standard</i>, instead of them using it on its own technical merits.<p>Ditch the status, and see if anyone still wants it.<p>--<p>Yes, reactive UI won – just fine, without having signals in the JS standard. Because not having signals in the language was never an actual problem holding back reactive UI development in JS.<p>Your proposal does not &quot;bring down complexity&quot;. It simply moves the complexity from UI libraries into the JS standard. In doing that, you forcefully marry the ecosystem to that particular style of complexity. Every browser vendor will need to implement it and support it... for how many decades?<p>And to what end? Unlike e.g. promises that are useful on their own, your proposal isn&#x27;t nearly ergonomic enough to allow building reactive UIs in vanilla JS. Users will <i>still</i> need to use libraries for that, just like they do today. You&#x27;re just moving one piece of such libraries into the standard, without building the case for why it&#x27;s needed there.<p>--<p>Your proposal spends pages selling the readers on signals, but that is not what you need to sell. We already have many implementations of signals. You need to sell why your (or any) signals implementation needs to be in the JavaScript standard.<p>You have one tiny &quot;Benefits of a standard library&quot; subsection under &quot;Secondary benefits&quot; but it&#x27;s just ridiculous. You&#x27;re basically saying that we should add signals to JS because we&#x27;ve added (much simpler or more needed) things to JS before – is that really your best argument?<p>And... &quot;saving bundle size&quot;? You want to bless one implementation of a complex problem to save what, 5KB of this: <a href="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;s-js" rel="nofollow">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;s-js</a><p>Sorry, just – nothing about this makes sense to me.</div><br/><div id="39891399" class="c"><input type="checkbox" id="c-39891399" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39890148">root</a><span>|</span><a href="#39891286">parent</a><span>|</span><a href="#39891396">next</a><span>|</span><label class="collapse" for="c-39891399">[-]</label><label class="expand" for="c-39891399">[1 more]</label></div><br/><div class="children"><div class="content">I don’t have a dog in the fight. I also don&#x27;t see yet any mainstream support behind the proposal. So I don’t get why it has to be so heated?<p>The main benefit is interop. Same with promises. You can implement all of promises with custom callbacks - in fact it’s trivial. But competing implementations don’t typically land on API compatibility simply because they’re solving the same problem. That causes a fractured ecosystem. Maybe interop could be important with signals? I think they should argue that, if so!<p>&gt; Users will still need to use libraries for that, just like they do today.<p>Yes? But you reduce the lifting by the libs - ideally enabling a class of vanilla use-cases which can be made demonstrably improved. You could say querySelector was unnecessary because you can do it in lib. Or filter, or map. Standardization can cover std-lib like features too no?<p>Doesn’t mean I am in favor. I think you should always default to no unless strong and consistent proven benefits. But why not have good faith arguments for what problems this will or won’t solve. For instance, if hypothetically let’s say react or svelte has a different model that cannot possibly use these signals, then that’s probably a sign it’s not good. My philosophy with proposals is balancing the curiosity and honest inquiry with a grumpy defensive inquisition before saying aye. Flaming though is really not helpful.<p>&gt; You&#x27;re basically saying that we should add signals to JS because we&#x27;ve added (much simpler or more needed) things to JS before<p>&gt; saving bundle size<p>Yes, I agree these are weak arguments.</div><br/></div></div><div id="39891396" class="c"><input type="checkbox" id="c-39891396" checked=""/><div class="controls bullet"><span class="by">jonathanlydall</span><span>|</span><a href="#39890148">root</a><span>|</span><a href="#39891286">parent</a><span>|</span><a href="#39891399">prev</a><span>|</span><a href="#39890175">next</a><span>|</span><label class="collapse" for="c-39891396">[-]</label><label class="expand" for="c-39891396">[1 more]</label></div><br/><div class="children"><div class="content">I think you’re right, I don’t see how building this into the base library makes some things possible which weren’t before.<p>I think that the Promise API was not the actual thing people directly wanted (and on its own had no compelling reason to be added to the base library), but a standardised Promise API was needed in order to add the hugely useful async&#x2F;await keywords which are unachievable without changes to the language.<p>I am however a big fan of a really good base library (it’s one of the things I love about working with .NET), but they should be focussing on functionality with the broadest reach (as in most encountered by average JS devs working on day to day tasks), e.g. things like better tools for working with dates and times.</div><br/></div></div></div></div></div></div><div id="39890175" class="c"><input type="checkbox" id="c-39890175" checked=""/><div class="controls bullet"><span class="by">imbnwa</span><span>|</span><a href="#39890148">parent</a><span>|</span><a href="#39890918">prev</a><span>|</span><a href="#39886969">next</a><span>|</span><label class="collapse" for="c-39890175">[-]</label><label class="expand" for="c-39890175">[2 more]</label></div><br/><div class="children"><div class="content">Remember the Observable proposal?</div><br/><div id="39890210" class="c"><input type="checkbox" id="c-39890210" checked=""/><div class="controls bullet"><span class="by">tengbretson</span><span>|</span><a href="#39890148">root</a><span>|</span><a href="#39890175">parent</a><span>|</span><a href="#39886969">next</a><span>|</span><label class="collapse" for="c-39890210">[-]</label><label class="expand" for="c-39890210">[1 more]</label></div><br/><div class="children"><div class="content">The Observable proposal made a stronger case in my opinion, since Observables provide an interface that is functionally unique and useful for the boundaries between app logic and libraries, so a single standard approach has benefits. Signals on the other hand  live right where application state binds to the ui. Is this really somewhere that people are patching together a hodge podge of libraries that need to use a consistent api? I&#x27;m not so sure.</div><br/></div></div></div></div></div></div><div id="39886969" class="c"><input type="checkbox" id="c-39886969" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#39890148">prev</a><span>|</span><a href="#39887380">next</a><span>|</span><label class="collapse" for="c-39886969">[-]</label><label class="expand" for="c-39886969">[63 more]</label></div><br/><div class="children"><div class="content">When I need to signal something across my application, I use events:<p><pre><code>    window.dispatchEvent(new Event(&#x27;counterChange&#x27;));
</code></pre>
And every part of the application that wants to react to it can subscribe via<p><pre><code>    window.addEventListener(&#x27;counterChange&#x27;, () =&gt; {
        ... do something ...
    });
</code></pre>
Anything wrong with that?</div><br/><div id="39887183" class="c"><input type="checkbox" id="c-39887183" checked=""/><div class="controls bullet"><span class="by">_the_inflator</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887161">next</a><span>|</span><label class="collapse" for="c-39887183">[-]</label><label class="expand" for="c-39887183">[12 more]</label></div><br/><div class="children"><div class="content">Historically, this example is the reason why the Web evolved into jQuery and from there forked into the world of Angular and React mainly.<p>Event handling is getting messy very easily. If you want to get deeper into it, have a look at event bubbling and propagation.<p>Large applications need a robust event handling. This is the nowadays hidden benefit of frameworks like Angular, Vue etc.<p>Believe me, you don’t want to use the standard event handling API without a framework. Adding, deleting, cloning, firing, removing, fire once etc on many elements can have serious unwanted side effects.</div><br/><div id="39888838" class="c"><input type="checkbox" id="c-39888838" checked=""/><div class="controls bullet"><span class="by">unemployable</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887183">parent</a><span>|</span><a href="#39887481">next</a><span>|</span><label class="collapse" for="c-39888838">[-]</label><label class="expand" for="c-39888838">[2 more]</label></div><br/><div class="children"><div class="content">&gt;If you want to get deeper into it, have a look at event bubbling and propagation.<p>In this example, the event is on the Window. There is no bubbling. It is already at the top level.<p>&gt;Believe me, you don’t want to use the standard event handling API without a framework. Adding, deleting, cloning, firing, removing, fire once etc on many elements can have serious unwanted side effects.<p>I don&#x27;t know what this means. The frameworks do not have much to do with this topic.</div><br/><div id="39889110" class="c"><input type="checkbox" id="c-39889110" checked=""/><div class="controls bullet"><span class="by">pquki4</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888838">parent</a><span>|</span><a href="#39887481">next</a><span>|</span><label class="collapse" for="c-39889110">[-]</label><label class="expand" for="c-39889110">[1 more]</label></div><br/><div class="children"><div class="content">I think the previous comment discusses events in a general sense.<p>Frameworks batch changes so that updates are efficient, and in many cases figures out the &quot;correct&quot; order of doing things. If you do all of those yourself in a large and complex UI, very likely you are updating the DOM less efficiently than what frameworks are doing, and very likely you introduced some subtle bugs. Speaking of that from my first-hand experience.</div><br/></div></div></div></div><div id="39887481" class="c"><input type="checkbox" id="c-39887481" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887183">parent</a><span>|</span><a href="#39888838">prev</a><span>|</span><a href="#39887444">next</a><span>|</span><label class="collapse" for="c-39887481">[-]</label><label class="expand" for="c-39887481">[1 more]</label></div><br/><div class="children"><div class="content">I use events extensively in large applications and its never been a problem.  In fact they solve complexity.</div><br/></div></div><div id="39887444" class="c"><input type="checkbox" id="c-39887444" checked=""/><div class="controls bullet"><span class="by">beezlewax</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887183">parent</a><span>|</span><a href="#39887481">prev</a><span>|</span><a href="#39887161">next</a><span>|</span><label class="collapse" for="c-39887444">[-]</label><label class="expand" for="c-39887444">[8 more]</label></div><br/><div class="children"><div class="content">What kind of side effects specifically?</div><br/><div id="39887490" class="c"><input type="checkbox" id="c-39887490" checked=""/><div class="controls bullet"><span class="by">doomroot</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887444">parent</a><span>|</span><a href="#39887161">next</a><span>|</span><label class="collapse" for="c-39887490">[-]</label><label class="expand" for="c-39887490">[7 more]</label></div><br/><div class="children"><div class="content">I believe memory leaks to start</div><br/><div id="39888906" class="c"><input type="checkbox" id="c-39888906" checked=""/><div class="controls bullet"><span class="by">unemployable</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887490">parent</a><span>|</span><a href="#39888306">next</a><span>|</span><label class="collapse" for="c-39888906">[-]</label><label class="expand" for="c-39888906">[3 more]</label></div><br/><div class="children"><div class="content">Memory leaks can occur when a component adds events to an element outside of the component (such as the window) and then gets removed from the DOM without removing the event handler from the window. This is solved in native Web Components by the mount&#x2F;unmount methods where you can run code to remove event listeners when the component has been unmounted.<p>For other event listeners, they get removed when the DOM element is removed.<p>The frameworks do not solve this to any greater degree. They also just make everything invisible and behind-the-scenes and hard to debug due to their declarative nature, but that is another topic.</div><br/><div id="39891387" class="c"><input type="checkbox" id="c-39891387" checked=""/><div class="controls bullet"><span class="by">ngc6677</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888906">parent</a><span>|</span><a href="#39891090">next</a><span>|</span><label class="collapse" for="c-39891387">[-]</label><label class="expand" for="c-39891387">[1 more]</label></div><br/><div class="children"><div class="content">Example with web components in all frameworks <a href="https:&#x2F;&#x2F;webcomponents.dev&#x2F;blog&#x2F;all-the-ways-to-make-a-web-component&#x2F;" rel="nofollow">https:&#x2F;&#x2F;webcomponents.dev&#x2F;blog&#x2F;all-the-ways-to-make-a-web-co...</a> and an other version to experiment with <a href="https:&#x2F;&#x2F;jsbin.com&#x2F;yiviragiba&#x2F;8&#x2F;edit?html,css,js,console,output" rel="nofollow">https:&#x2F;&#x2F;jsbin.com&#x2F;yiviragiba&#x2F;8&#x2F;edit?html,css,js,console,outp...</a></div><br/></div></div><div id="39891090" class="c"><input type="checkbox" id="c-39891090" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888906">parent</a><span>|</span><a href="#39891387">prev</a><span>|</span><a href="#39888306">next</a><span>|</span><label class="collapse" for="c-39891090">[-]</label><label class="expand" for="c-39891090">[1 more]</label></div><br/><div class="children"><div class="content">Removing event listeners upon some component being removed actually sounds like a great use case for the new FinalizationRegistry API[1]<p>[1]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;FinalizationRegistry" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/></div></div></div></div><div id="39888306" class="c"><input type="checkbox" id="c-39888306" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887490">parent</a><span>|</span><a href="#39888906">prev</a><span>|</span><a href="#39887639">next</a><span>|</span><label class="collapse" for="c-39888306">[-]</label><label class="expand" for="c-39888306">[1 more]</label></div><br/><div class="children"><div class="content">This is one of those points where you need to link to some kind of data or conclusive result actually showcasing this, because you&#x27;re arguing against a pattern that&#x27;s been in browser ecosystems for decades. I&#x27;ve done this for larger applications and haven&#x27;t experienced issues.<p>Being charitable, the best I can imagine right now that&#x27;d cause memory leaks is someone running into the old school JS scoping issues and capturing something in handlers that they shouldn&#x27;t. That&#x27;s not the handler itself that&#x27;s the problem, though - that&#x27;s the developer.<p>(Yes, we could rant on and on about the poor design decisions that JS has built in, but that&#x27;s been beaten to death)</div><br/></div></div><div id="39887639" class="c"><input type="checkbox" id="c-39887639" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887490">parent</a><span>|</span><a href="#39888306">prev</a><span>|</span><a href="#39887161">next</a><span>|</span><label class="collapse" for="c-39887639">[-]</label><label class="expand" for="c-39887639">[2 more]</label></div><br/><div class="children"><div class="content">Are you implying that there are memory leaks in browsers&#x27; internal implementation of events? Because my take is that the problem is with &quot;user space&quot; scripts not cleaning up after themselves, and I don&#x27;t see how that would get better by adding yet another API to be mindful of.</div><br/><div id="39888446" class="c"><input type="checkbox" id="c-39888446" checked=""/><div class="controls bullet"><span class="by">gibbitz</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887639">parent</a><span>|</span><a href="#39887161">next</a><span>|</span><label class="collapse" for="c-39888446">[-]</label><label class="expand" for="c-39888446">[1 more]</label></div><br/><div class="children"><div class="content">I believe this would be more related to something like memoizing a DOM structure in a &quot;Live&quot; listener that is later removed from the DOM but not garbage collected due to the reference in the event listener. As the poster mentioned, developer error -- not a fundamental language or browser implementation flaw.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39887161" class="c"><input type="checkbox" id="c-39887161" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887183">prev</a><span>|</span><a href="#39888419">next</a><span>|</span><label class="collapse" for="c-39887161">[-]</label><label class="expand" for="c-39887161">[1 more]</label></div><br/><div class="children"><div class="content">According to TFA, event emitters &#x2F; observables cause unnecessary work when called multiple times.<p>The difference with signals is that the resulting value is only ever calculated when the end consumer reads the value- so you schedule render updates asynchronously from the actual writes to the signal, and whatever chain of computations the watchers perform is done just the one time during the render.<p>Interim values sent to the signal will get lost, so you really can&#x27;t do too much interesting work in them. It&#x27;s really just a fancy abstraction layer to coordinate a rendering cycle.</div><br/></div></div><div id="39888419" class="c"><input type="checkbox" id="c-39888419" checked=""/><div class="controls bullet"><span class="by">kabes</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887161">prev</a><span>|</span><a href="#39887869">next</a><span>|</span><label class="collapse" for="c-39888419">[-]</label><label class="expand" for="c-39888419">[1 more]</label></div><br/><div class="children"><div class="content">Signals are also just pub&#x2F;sub, but with a more ergonomic api. More ergonomic because listeners are added and released automatically.<p>It can also be more performant, eg, say you have a computation that depends on 2 values:<p>`result = a ? b : 0`<p>Then if a is falsy, we don&#x27;t need to recompute if b changes. This is achieved automatically with signals, but would require quite some code with classic pub&#x2F;sub.</div><br/></div></div><div id="39887869" class="c"><input type="checkbox" id="c-39887869" checked=""/><div class="controls bullet"><span class="by">dakom</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39888419">prev</a><span>|</span><a href="#39887026">next</a><span>|</span><label class="collapse" for="c-39887869">[-]</label><label class="expand" for="c-39887869">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s often desirable for UI to be described in a declarative fashion, i.e. instead of where you have &quot;do something&quot; (set button color to red), refactoring so it becomes &quot;is something&quot; (button is red if state is x)<p>I might not be describing that well, because once you go down that road it really becomes a whole overall approach that infects the whole program (like functional reactive programming), and so it&#x27;s really about how the whole flow fits together from top to bottom, and that can be very elegant.<p>I don&#x27;t think that&#x27;s the right fit for everything, i.e. in gamedev it might make more sense to just update some object&#x27;s position imperatively, but for UI it tends to work pretty well.</div><br/></div></div><div id="39887026" class="c"><input type="checkbox" id="c-39887026" checked=""/><div class="controls bullet"><span class="by">hk__2</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887869">prev</a><span>|</span><a href="#39887047">next</a><span>|</span><label class="collapse" for="c-39887026">[-]</label><label class="expand" for="c-39887026">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Anything wrong with that?<p>It has all the downsides of the pub&#x2F;sub architecture highlighted in the proposal.</div><br/></div></div><div id="39887047" class="c"><input type="checkbox" id="c-39887047" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887026">prev</a><span>|</span><a href="#39887105">next</a><span>|</span><label class="collapse" for="c-39887047">[-]</label><label class="expand" for="c-39887047">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using patterns like this for more than a decade. The thing that&#x27;s hard is, down the road you could have a listener, which triggers a other event, then another event, which comes back to the first routine and now you got a listen-loop that won&#x27;t quit.<p>And it&#x27;s hard to ensure that all listener don&#x27;t cause that trigger cascade.</div><br/><div id="39887094" class="c"><input type="checkbox" id="c-39887094" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887047">parent</a><span>|</span><a href="#39889970">next</a><span>|</span><label class="collapse" for="c-39887094">[-]</label><label class="expand" for="c-39887094">[5 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it possible to define all listeners &#x2F; publishers in a declarative way which can be compiled to catch for this issues?</div><br/><div id="39888622" class="c"><input type="checkbox" id="c-39888622" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887094">parent</a><span>|</span><a href="#39889970">next</a><span>|</span><label class="collapse" for="c-39888622">[-]</label><label class="expand" for="c-39888622">[4 more]</label></div><br/><div class="children"><div class="content">Yes. It is. And most pub&#x2F;sub or Observer architectures and design patterns have the &quot;loop&quot; thing solved just fine.<p>In fact, the GOF spend an entire paragraph on the problem of complex update semantics in &quot;design Patterns&quot; (1995) ch Observer p299.<p>So, while it is a real problem, it&#x27;s one that has been solved (for at least 29 years)</div><br/><div id="39889200" class="c"><input type="checkbox" id="c-39889200" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888622">parent</a><span>|</span><a href="#39889545">next</a><span>|</span><label class="collapse" for="c-39889200">[-]</label><label class="expand" for="c-39889200">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I want to mention, since I was up-thread, it is solved but not all tooling or environment are setup for that.<p>When the app is small you likely don&#x27;t need it. And then it grows and you absolutely do.<p>It&#x27;s better, in greenfield to use framework&#x2F;tooling that is ready for it.</div><br/></div></div><div id="39889545" class="c"><input type="checkbox" id="c-39889545" checked=""/><div class="controls bullet"><span class="by">jbreckmckye</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888622">parent</a><span>|</span><a href="#39889200">prev</a><span>|</span><a href="#39889970">next</a><span>|</span><label class="collapse" for="c-39889545">[-]</label><label class="expand" for="c-39889545">[2 more]</label></div><br/><div class="children"><div class="content">In fact I solved a similar issue in my JS reactive micro library in just 500 bytes: <a href="https:&#x2F;&#x2F;github.com&#x2F;jbreckmckye&#x2F;trkl">https:&#x2F;&#x2F;github.com&#x2F;jbreckmckye&#x2F;trkl</a></div><br/><div id="39890106" class="c"><input type="checkbox" id="c-39890106" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39889545">parent</a><span>|</span><a href="#39889970">next</a><span>|</span><label class="collapse" for="c-39890106">[-]</label><label class="expand" for="c-39890106">[1 more]</label></div><br/><div class="children"><div class="content">I was not aware of trkl. Well done! I wrote rmemo (Reactive Memo) which solves the same problems &amp; is a similar size. Different semantics though.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ctx-core&#x2F;rmemo">https:&#x2F;&#x2F;github.com&#x2F;ctx-core&#x2F;rmemo</a><p>Nanostores is also small <a href="https:&#x2F;&#x2F;github.com&#x2F;nanostores&#x2F;nanostores">https:&#x2F;&#x2F;github.com&#x2F;nanostores&#x2F;nanostores</a>.<p>And if you only need reactivity in the browser (not server side), VanJS is small &amp; includes reactive primitives. <a href="https:&#x2F;&#x2F;vanjs.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vanjs.org&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="39889970" class="c"><input type="checkbox" id="c-39889970" checked=""/><div class="controls bullet"><span class="by">zaphar</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887047">parent</a><span>|</span><a href="#39887094">prev</a><span>|</span><a href="#39887105">next</a><span>|</span><label class="collapse" for="c-39889970">[-]</label><label class="expand" for="c-39889970">[1 more]</label></div><br/><div class="children"><div class="content">I like signals as primitive but in this particular case they make it roughly about as easy to create loops accidentally as events do. I don&#x27;t think this problem gets better or worse with signals.</div><br/></div></div></div></div><div id="39887105" class="c"><input type="checkbox" id="c-39887105" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887047">prev</a><span>|</span><a href="#39887900">next</a><span>|</span><label class="collapse" for="c-39887105">[-]</label><label class="expand" for="c-39887105">[1 more]</label></div><br/><div class="children"><div class="content">This pattern is precisely what everyone&#x27;s favorite &quot;look, JS&#x2F;electron can be high performance!&quot; example uses. (VS Code).</div><br/></div></div><div id="39887900" class="c"><input type="checkbox" id="c-39887900" checked=""/><div class="controls bullet"><span class="by">LittleDan</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887105">prev</a><span>|</span><a href="#39887512">next</a><span>|</span><label class="collapse" for="c-39887900">[-]</label><label class="expand" for="c-39887900">[1 more]</label></div><br/><div class="children"><div class="content">LGTM! Smells like Redux (in a good way). But then ultimately at the root you probably want the event to update your “model”, and then that leads to an update of the “view”. This is the part where signals can be useful.</div><br/></div></div><div id="39887512" class="c"><input type="checkbox" id="c-39887512" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887900">prev</a><span>|</span><a href="#39888457">next</a><span>|</span><label class="collapse" for="c-39887512">[-]</label><label class="expand" for="c-39887512">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Anything wrong with that?<p>Well, don&#x27;t events only bubble upwards? You need to know the exact element of it is not on a lower level in the DOM tree.<p>Events were too messy, so I wrote a small pub&#x2F;sub message queue type of thing. Anyone anywhere in the DOM can subscribe to messages based on subject regexes.<p>Makes things a lot easier, especially when I added web components to wrap existing elements so that publishing and subscribing is done with attributes, not js.</div><br/><div id="39888512" class="c"><input type="checkbox" id="c-39888512" checked=""/><div class="controls bullet"><span class="by">everybackdoor</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887512">parent</a><span>|</span><a href="#39888457">next</a><span>|</span><label class="collapse" for="c-39888512">[-]</label><label class="expand" for="c-39888512">[2 more]</label></div><br/><div class="children"><div class="content">You can also fire events on pretty much any object, essentially creating a channel where the message bus queue is the vm event queue.</div><br/><div id="39891032" class="c"><input type="checkbox" id="c-39891032" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888512">parent</a><span>|</span><a href="#39888457">next</a><span>|</span><label class="collapse" for="c-39891032">[-]</label><label class="expand" for="c-39891032">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can also fire events on pretty much any object,<p>Only if you have a reference to the object.<p>The reason I made up my own message queue pub&#x2F;sub is <i>because</i> events required a lot of complexity in acquiring the correct reference to the correct object or subtree in the DOM.<p>With pub&#x2F;sub type message queue, any element can emit a message with subject &quot;POST &#x2F;getnetpage&quot; and the function listening for (subscribed) POST messages emits a RESPONSE message when the response comes back. This lets a third element listen (subscribe) for a &quot;RESPONSE FROM &#x2F;getnextpage&quot; subject message, and handle it.<p>None of the 3 parties in the above need to have a reference to each other, nor do they even have to know about each other, <i>and</i> I can inject some nice observability tools because I can just add a subscriber for specific message types, which makes debugging a breeze.</div><br/></div></div></div></div></div></div><div id="39888457" class="c"><input type="checkbox" id="c-39888457" checked=""/><div class="controls bullet"><span class="by">fwlr</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887512">prev</a><span>|</span><a href="#39887499">next</a><span>|</span><label class="collapse" for="c-39888457">[-]</label><label class="expand" for="c-39888457">[3 more]</label></div><br/><div class="children"><div class="content">If you mis-type ‘countenChange’ it could be quite frustrating!</div><br/><div id="39888540" class="c"><input type="checkbox" id="c-39888540" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888457">parent</a><span>|</span><a href="#39888497">next</a><span>|</span><label class="collapse" for="c-39888540">[-]</label><label class="expand" for="c-39888540">[1 more]</label></div><br/><div class="children"><div class="content">If that truly is your reason to choose or forego a software design pattern, than what the h. are you doing with JavaScript?</div><br/></div></div><div id="39888497" class="c"><input type="checkbox" id="c-39888497" checked=""/><div class="controls bullet"><span class="by">everybackdoor</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39888457">parent</a><span>|</span><a href="#39888540">prev</a><span>|</span><a href="#39887499">next</a><span>|</span><label class="collapse" for="c-39888497">[-]</label><label class="expand" for="c-39888497">[1 more]</label></div><br/><div class="children"><div class="content">In 2024 we have linters and other static analysis tools for catching these kinds of things right in the IDE.</div><br/></div></div></div></div><div id="39887499" class="c"><input type="checkbox" id="c-39887499" checked=""/><div class="controls bullet"><span class="by">nurple</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39888457">prev</a><span>|</span><a href="#39887956">next</a><span>|</span><label class="collapse" for="c-39887499">[-]</label><label class="expand" for="c-39887499">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  Welcome to Node.js v21.6.2.
  Type &quot;.help&quot; for more information.
  &gt; window.dispatchEvent(new Event(&#x27;counterChange&#x27;))
  Uncaught ReferenceError: window is not defined</code></pre></div><br/><div id="39887569" class="c"><input type="checkbox" id="c-39887569" checked=""/><div class="controls bullet"><span class="by">runarberg</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887499">parent</a><span>|</span><a href="#39890389">next</a><span>|</span><label class="collapse" for="c-39887569">[-]</label><label class="expand" for="c-39887569">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    $ node
    Welcome to Node.js v20.6.1.
    Type &quot;.help&quot; for more information.
    &gt; const target = new EventTarget()
    undefined
    &gt; target.dispatchEvent(new Event(&quot;counterChange&quot;))
    true</code></pre></div><br/><div id="39887865" class="c"><input type="checkbox" id="c-39887865" checked=""/><div class="controls bullet"><span class="by">nurple</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887569">parent</a><span>|</span><a href="#39890389">next</a><span>|</span><label class="collapse" for="c-39887865">[-]</label><label class="expand" for="c-39887865">[1 more]</label></div><br/><div class="children"><div class="content">tyvm!</div><br/></div></div></div></div><div id="39890389" class="c"><input type="checkbox" id="c-39890389" checked=""/><div class="controls bullet"><span class="by">extheat</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887499">parent</a><span>|</span><a href="#39887569">prev</a><span>|</span><a href="#39887956">next</a><span>|</span><label class="collapse" for="c-39890389">[-]</label><label class="expand" for="c-39890389">[1 more]</label></div><br/><div class="children"><div class="content">Even better on Node, you have EventEmitter. A much simpler interface.</div><br/></div></div></div></div><div id="39887956" class="c"><input type="checkbox" id="c-39887956" checked=""/><div class="controls bullet"><span class="by">briantakita</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887499">prev</a><span>|</span><a href="#39887034">next</a><span>|</span><label class="collapse" for="c-39887956">[-]</label><label class="expand" for="c-39887956">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  Anything wrong with that?<p>It only works in browser environments.</div><br/><div id="39888852" class="c"><input type="checkbox" id="c-39888852" checked=""/><div class="controls bullet"><span class="by">lelandfe</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887956">parent</a><span>|</span><a href="#39887034">next</a><span>|</span><label class="collapse" for="c-39888852">[-]</label><label class="expand" for="c-39888852">[1 more]</label></div><br/><div class="children"><div class="content">Node has EventEmitter: <a href="https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;learn&#x2F;asynchronous-work&#x2F;the-nodejs-event-emitter" rel="nofollow">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;learn&#x2F;asynchronous-work&#x2F;the-nodejs-eve...</a><p>See, for instance, <a href="https:&#x2F;&#x2F;www.electronjs.org&#x2F;docs&#x2F;latest&#x2F;api&#x2F;ipc-renderer" rel="nofollow">https:&#x2F;&#x2F;www.electronjs.org&#x2F;docs&#x2F;latest&#x2F;api&#x2F;ipc-renderer</a></div><br/></div></div></div></div><div id="39887049" class="c"><input type="checkbox" id="c-39887049" checked=""/><div class="controls bullet"><span class="by">cyanydeez</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887034">prev</a><span>|</span><a href="#39890503">next</a><span>|</span><label class="collapse" for="c-39887049">[-]</label><label class="expand" for="c-39887049">[11 more]</label></div><br/><div class="children"><div class="content">Mostly the teardown logic and inevitable memory leaks.<p>A alt proposal would be some kind of auto remove listener if it goes out of context</div><br/><div id="39887074" class="c"><input type="checkbox" id="c-39887074" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887049">parent</a><span>|</span><a href="#39887174">next</a><span>|</span><label class="collapse" for="c-39887074">[-]</label><label class="expand" for="c-39887074">[4 more]</label></div><br/><div class="children"><div class="content">The new `using` feature handles RAII just fine. This proposal is entirely unnecessary given the existence of `using` and the already-existing event listeners. <a href="https:&#x2F;&#x2F;iliazeus.github.io&#x2F;articles&#x2F;js-explicit-resource-management-en&#x2F;" rel="nofollow">https:&#x2F;&#x2F;iliazeus.github.io&#x2F;articles&#x2F;js-explicit-resource-man...</a></div><br/><div id="39888925" class="c"><input type="checkbox" id="c-39888925" checked=""/><div class="controls bullet"><span class="by">lelandfe</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887074">parent</a><span>|</span><a href="#39889323">next</a><span>|</span><label class="collapse" for="c-39888925">[-]</label><label class="expand" for="c-39888925">[1 more]</label></div><br/><div class="children"><div class="content">Quite a good link, thanks.</div><br/></div></div><div id="39889323" class="c"><input type="checkbox" id="c-39889323" checked=""/><div class="controls bullet"><span class="by">cyanydeez</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887074">parent</a><span>|</span><a href="#39888925">prev</a><span>|</span><a href="#39887174">next</a><span>|</span><label class="collapse" for="c-39889323">[-]</label><label class="expand" for="c-39889323">[2 more]</label></div><br/><div class="children"><div class="content">Nice, but mixing typescript into a proposed standard just confusing.</div><br/><div id="39890422" class="c"><input type="checkbox" id="c-39890422" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39889323">parent</a><span>|</span><a href="#39887174">next</a><span>|</span><label class="collapse" for="c-39890422">[-]</label><label class="expand" for="c-39890422">[1 more]</label></div><br/><div class="children"><div class="content">The standard doesn&#x27;t have anything to do with TypeScript, not sure where you got that from? <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-explicit-resource-management">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-explicit-resource-managemen...</a></div><br/></div></div></div></div></div></div><div id="39887174" class="c"><input type="checkbox" id="c-39887174" checked=""/><div class="controls bullet"><span class="by">gray_-_wolf</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887049">parent</a><span>|</span><a href="#39887074">prev</a><span>|</span><a href="#39890503">next</a><span>|</span><label class="collapse" for="c-39887174">[-]</label><label class="expand" for="c-39887174">[6 more]</label></div><br/><div class="children"><div class="content">Maybe a stupid question, but isn&#x27;t the memory released anyway when I close the tab?  So why do memory leaks matter?</div><br/><div id="39890704" class="c"><input type="checkbox" id="c-39890704" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887174">parent</a><span>|</span><a href="#39887408">next</a><span>|</span><label class="collapse" for="c-39890704">[-]</label><label class="expand" for="c-39890704">[1 more]</label></div><br/><div class="children"><div class="content">Not &quot;stupid&quot;, but maybe hasty &#x2F; shallow? Many SPAs are long-running, and memory leaks can accrue quickly, destroying performance.</div><br/></div></div><div id="39887408" class="c"><input type="checkbox" id="c-39887408" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887174">parent</a><span>|</span><a href="#39890704">prev</a><span>|</span><a href="#39887349">next</a><span>|</span><label class="collapse" for="c-39887408">[-]</label><label class="expand" for="c-39887408">[1 more]</label></div><br/><div class="children"><div class="content">It depends on how much you&#x27;re leaking, and how fast.<p>Best case scenario, it just slows down garage collection a little bit, as you&#x27;re holding into a lot of references that aren&#x27;t going anywhere.<p>On the other hand, I recall a bug in a particular version of AngularJS where component DOM nodes wouldn&#x27;t get cleaned up when navigating with the router unless you manually set all of the scope values their templates used to null.<p>We had a data dense application with tables and what not, and you could clearly watch memory jump tens or more megabytes flipping between pages in the chrome dev tooling.<p>Eventually (this was a SPA intended to be used for upwards of hours at a time) the page would crash.</div><br/></div></div><div id="39887349" class="c"><input type="checkbox" id="c-39887349" checked=""/><div class="controls bullet"><span class="by">dr_kiszonka</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887174">parent</a><span>|</span><a href="#39887408">prev</a><span>|</span><a href="#39887546">next</a><span>|</span><label class="collapse" for="c-39887349">[-]</label><label class="expand" for="c-39887349">[1 more]</label></div><br/><div class="children"><div class="content">Not a web dev person, but some &quot;tabs&quot; have a very long lifetime, e.g., webmail clients, Whatsapp, etc.</div><br/></div></div><div id="39887546" class="c"><input type="checkbox" id="c-39887546" checked=""/><div class="controls bullet"><span class="by">Xenoamorphous</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887174">parent</a><span>|</span><a href="#39887349">prev</a><span>|</span><a href="#39887391">next</a><span>|</span><label class="collapse" for="c-39887546">[-]</label><label class="expand" for="c-39887546">[1 more]</label></div><br/><div class="children"><div class="content">Have you ever seen Chrome’s “aw, snap!” screen (if you use Chrome)?<p>More often than not that’s due to a memory leak.</div><br/></div></div><div id="39887391" class="c"><input type="checkbox" id="c-39887391" checked=""/><div class="controls bullet"><span class="by">leptons</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887174">parent</a><span>|</span><a href="#39887546">prev</a><span>|</span><a href="#39890503">next</a><span>|</span><label class="collapse" for="c-39887391">[-]</label><label class="expand" for="c-39887391">[1 more]</label></div><br/><div class="children"><div class="content">The problem is if you don&#x27;t close the tab, the memory leak can cause that one tab&#x27;s memory to balloon to 1GB or more because memory isn&#x27;t being released, when that tab should only be consuming 50MB.</div><br/></div></div></div></div></div></div><div id="39890503" class="c"><input type="checkbox" id="c-39890503" checked=""/><div class="controls bullet"><span class="by">6510</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39887049">prev</a><span>|</span><a href="#39887038">next</a><span>|</span><label class="collapse" for="c-39890503">[-]</label><label class="expand" for="c-39890503">[1 more]</label></div><br/><div class="children"><div class="content">You have to name the function or you cant remove it :P</div><br/></div></div><div id="39887038" class="c"><input type="checkbox" id="c-39887038" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#39886969">parent</a><span>|</span><a href="#39890503">prev</a><span>|</span><a href="#39887380">next</a><span>|</span><label class="collapse" for="c-39887038">[-]</label><label class="expand" for="c-39887038">[11 more]</label></div><br/><div class="children"><div class="content">Did you read the document? They have an example there, which is quite similar to yours, and explain what is the problem.</div><br/><div id="39887060" class="c"><input type="checkbox" id="c-39887060" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887038">parent</a><span>|</span><a href="#39887109">next</a><span>|</span><label class="collapse" for="c-39887060">[-]</label><label class="expand" for="c-39887060">[8 more]</label></div><br/><div class="children"><div class="content">No, they don&#x27;t. In fact, if you search &quot;event&quot; in the proposal you get exactly one result, the prefix of &quot;eventually&quot;. This is a serious shortcoming of the proposal that should be addressed.</div><br/><div id="39887118" class="c"><input type="checkbox" id="c-39887118" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887060">parent</a><span>|</span><a href="#39887141">next</a><span>|</span><label class="collapse" for="c-39887118">[-]</label><label class="expand" for="c-39887118">[3 more]</label></div><br/><div class="children"><div class="content">I think the comment you&#x27;re replying to is referring to the pub&#x2F;sub sections of the proposal. They don&#x27;t explicitly mention events, but events are a subset of the publish&#x2F;subscribe pattern.</div><br/><div id="39887138" class="c"><input type="checkbox" id="c-39887138" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887118">parent</a><span>|</span><a href="#39887141">next</a><span>|</span><label class="collapse" for="c-39887138">[-]</label><label class="expand" for="c-39887138">[2 more]</label></div><br/><div class="children"><div class="content">But then so are signals.<p>The only &quot;benefit&quot; signals as proposed here give you is less control over the exact dispatch pattern of the graph, for instance things like debouncing, throttling, batching, etc etc etc. Aka all the things you absolutely must have control over if you want to make something resembling a high performance application.</div><br/><div id="39887250" class="c"><input type="checkbox" id="c-39887250" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887138">parent</a><span>|</span><a href="#39887141">next</a><span>|</span><label class="collapse" for="c-39887250">[-]</label><label class="expand" for="c-39887250">[1 more]</label></div><br/><div class="children"><div class="content">Signals are not a subset of events. Signals combine event subscription with value construction, which promotes a remote declarative model for updates.<p>&gt; The only &quot;benefit&quot; signals as proposed here give you is less control over the exact dispatch pattern of the graph, for instance things like debouncing, throttling, batching,<p>Events don&#x27;t give you any more control over those properties than signals, they just require more boilerplate.</div><br/></div></div></div></div></div></div><div id="39887124" class="c"><input type="checkbox" id="c-39887124" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887060">parent</a><span>|</span><a href="#39887141">prev</a><span>|</span><a href="#39887109">next</a><span>|</span><label class="collapse" for="c-39887124">[-]</label><label class="expand" for="c-39887124">[3 more]</label></div><br/><div class="children"><div class="content">Oh, come on. They do have an example of architecture, not literal example of events. It doesn’t matter what trivial implementation of Observer pattern you choose.</div><br/><div id="39887153" class="c"><input type="checkbox" id="c-39887153" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887124">parent</a><span>|</span><a href="#39887109">next</a><span>|</span><label class="collapse" for="c-39887153">[-]</label><label class="expand" for="c-39887153">[2 more]</label></div><br/><div class="children"><div class="content">Except one is already built into the language? And it provides all the upsides of signals with none of the downsides? (Modulo proper use of `using` directives)</div><br/></div></div></div></div></div></div><div id="39887109" class="c"><input type="checkbox" id="c-39887109" checked=""/><div class="controls bullet"><span class="by">ahmedfromtunis</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887038">parent</a><span>|</span><a href="#39887060">prev</a><span>|</span><a href="#39887380">next</a><span>|</span><label class="collapse" for="c-39887109">[-]</label><label class="expand" for="c-39887109">[2 more]</label></div><br/><div class="children"><div class="content">Can you please point to where in the document such an example was mentioned? I rechecked the document and couldn&#x27;t find it.</div><br/><div id="39887168" class="c"><input type="checkbox" id="c-39887168" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#39886969">root</a><span>|</span><a href="#39887109">parent</a><span>|</span><a href="#39887380">next</a><span>|</span><label class="collapse" for="c-39887168">[-]</label><label class="expand" for="c-39887168">[1 more]</label></div><br/><div class="children"><div class="content">Just look for the example of a design pattern („Example - A VanillaJS Counter“ section), not for a literal implementation of it via events. Conceptually they are the same.</div><br/></div></div></div></div></div></div></div></div><div id="39887380" class="c"><input type="checkbox" id="c-39887380" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39886969">prev</a><span>|</span><a href="#39886837">next</a><span>|</span><label class="collapse" for="c-39887380">[-]</label><label class="expand" for="c-39887380">[23 more]</label></div><br/><div class="children"><div class="content">I’ve been trying for decades to understand why people find it so hard to keep track of state and update the DOM.<p>Sure, it requires a bit of discipline, but it’s vastly simpler to me than whatever solution comes up every few years (Backbone, Knockout, Angular, React, modifying the language itself, etc). There must be something profoundly different with the way I think.<p>It even expresses itself in the function naming. They call updating innerText “render”. You’re not rendering anything. At most, the browser is, but so is everything else it does related to painting. It feels like a desperate attempt to complicate what is one of the simplest DOM functions. It really baffles me.</div><br/><div id="39887400" class="c"><input type="checkbox" id="c-39887400" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#39887380">parent</a><span>|</span><a href="#39887448">next</a><span>|</span><label class="collapse" for="c-39887400">[-]</label><label class="expand" for="c-39887400">[17 more]</label></div><br/><div class="children"><div class="content">In simple applications it is easy.<p>More complex it is not easy.</div><br/><div id="39887439" class="c"><input type="checkbox" id="c-39887439" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887400">parent</a><span>|</span><a href="#39887448">next</a><span>|</span><label class="collapse" for="c-39887439">[-]</label><label class="expand" for="c-39887439">[16 more]</label></div><br/><div class="children"><div class="content">I’ve been writing web apps for easily 25+ years. Never have I reached for React and friends voluntarily. But again, I know I’m in a minority. I’m just not completely sure why.</div><br/><div id="39887460" class="c"><input type="checkbox" id="c-39887460" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887439">parent</a><span>|</span><a href="#39887564">next</a><span>|</span><label class="collapse" for="c-39887460">[-]</label><label class="expand" for="c-39887460">[4 more]</label></div><br/><div class="children"><div class="content">You could work for 50 years and never need those… it just depends on what you’re creating &#x2F; how many devs and so on.<p>I know some guys who over the years wrote their own framework.  It works great… for them.</div><br/><div id="39887592" class="c"><input type="checkbox" id="c-39887592" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887460">parent</a><span>|</span><a href="#39887564">next</a><span>|</span><label class="collapse" for="c-39887592">[-]</label><label class="expand" for="c-39887592">[3 more]</label></div><br/><div class="children"><div class="content">Right, the only thing that convinces me is team and hiring dynamics. But that’s not what these tools advertise.<p>It’s always like: you have dozens of interactive controls in this view, it’s getting out of hand, you should use this language that compiles to HTML and JavaScript and carry all these dependencies. To which I always reply: no thanks, I rather deal with the dozens of controls.</div><br/><div id="39887613" class="c"><input type="checkbox" id="c-39887613" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887592">parent</a><span>|</span><a href="#39887564">next</a><span>|</span><label class="collapse" for="c-39887613">[-]</label><label class="expand" for="c-39887613">[2 more]</label></div><br/><div class="children"><div class="content">&gt; team and hiring dynamics. But that’s not what these tools advertise.<p>I think that’s a given for any proposed standard.  We all get a common way we understand things and can even just communicate about a thing.</div><br/><div id="39887772" class="c"><input type="checkbox" id="c-39887772" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887613">parent</a><span>|</span><a href="#39887564">next</a><span>|</span><label class="collapse" for="c-39887772">[-]</label><label class="expand" for="c-39887772">[1 more]</label></div><br/><div class="children"><div class="content">My argument is that it’s not their selling point. When you go to React’s page you’re not greeted with: “React is a great way to hire devs and manage a team”.<p>The solution they sell is technical, like state management, reusable components, etc. Which I don’t find convincing.</div><br/></div></div></div></div></div></div></div></div><div id="39887564" class="c"><input type="checkbox" id="c-39887564" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887439">parent</a><span>|</span><a href="#39887460">prev</a><span>|</span><a href="#39888340">next</a><span>|</span><label class="collapse" for="c-39887564">[-]</label><label class="expand" for="c-39887564">[6 more]</label></div><br/><div class="children"><div class="content">FB&#x27;s website has settings subpages that are more complicated than an average web app and is an SPA-style-mega-app made of piles of other apps. It typically keeps highly consistent state throughout. There&#x27;s no doing that sanely by hand, you&#x27;ll just forget something or, more likely, it will get lost between the dozens upon dozens of people needed to build such a thing.</div><br/><div id="39887721" class="c"><input type="checkbox" id="c-39887721" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887564">parent</a><span>|</span><a href="#39888340">next</a><span>|</span><label class="collapse" for="c-39887721">[-]</label><label class="expand" for="c-39887721">[5 more]</label></div><br/><div class="children"><div class="content">1) Almost no one is building FB or Gmail, yet act like it. The precise reason why still escapes me.<p>2) For other use cases, it’s not that hard to manually update some elements in the DOM. You very quickly learn how not shot yourself in the foot. Certainly a lot easier (and faster) than dealing with the mess that is the React ecosystem.</div><br/><div id="39888151" class="c"><input type="checkbox" id="c-39888151" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887721">parent</a><span>|</span><a href="#39888340">next</a><span>|</span><label class="collapse" for="c-39888151">[-]</label><label class="expand" for="c-39888151">[4 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to be building Facebook or Google to have a TON of state in a webpage. Obviously if you are doing a basic dashboard, a blog or something similar, it isn&#x27;t really needed. But for more complex stuff I think react provides a much better way to handle state changes than just using vanilla js. It&#x27;s not like using react makes an app more complex, because if you wanted to do the same thing in vanillajs you&#x27;d end up with a much bigger mess.<p>I agree that some web pages don&#x27;t need any of that, but those don&#x27;t usually require a lot of development anyways.</div><br/><div id="39889475" class="c"><input type="checkbox" id="c-39889475" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39888151">parent</a><span>|</span><a href="#39888340">next</a><span>|</span><label class="collapse" for="c-39889475">[-]</label><label class="expand" for="c-39889475">[3 more]</label></div><br/><div class="children"><div class="content">Could you give a concrete example for the more complex stuff?</div><br/><div id="39890922" class="c"><input type="checkbox" id="c-39890922" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39889475">parent</a><span>|</span><a href="#39891117">next</a><span>|</span><label class="collapse" for="c-39890922">[-]</label><label class="expand" for="c-39890922">[1 more]</label></div><br/><div class="children"><div class="content">Sure! Where I work we build very specialized, very low user count live remote non destructive testing software that can be run on a browser. Well, it used to be native, but clients complained a lot in part due to IT restrictions on updates. That means that we basically have to have a remote processing unit, sync the state with the front end at all time, and with the scanning equipment too. That means multiple different canvases and charts, different tabs etc that all contain state, need state to be updated sometimes in the background, and need to have consistent state changes. I don&#x27;t do a lot of front end dev, but I did help in setting up our new inference module there as I&#x27;m in the AI&#x2F;ML side and it would&#x27;ve been a nightmare to deal with even if I mostly did stuff in a webgl canvas. It was angular, which I don&#x27;t really like, but is still much better than going vanilla.<p>I know it&#x27;s pretty niche, but I&#x27;d say most non-trivial (blogs, CMS, forms) front ends handle a lot of state. If they don&#x27;t, then they are relatively simple anyways. That&#x27;s a generalization but still, you quickly hit the point where react&#x2F;other framework becomes worth the complexity overhead versus the complexity of doing it in vanillajs</div><br/></div></div><div id="39891117" class="c"><input type="checkbox" id="c-39891117" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39889475">parent</a><span>|</span><a href="#39890922">prev</a><span>|</span><a href="#39888340">next</a><span>|</span><label class="collapse" for="c-39891117">[-]</label><label class="expand" for="c-39891117">[1 more]</label></div><br/><div class="children"><div class="content">Maybe try making something like Grafana&#x27;s dashboard by hand.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39888340" class="c"><input type="checkbox" id="c-39888340" checked=""/><div class="controls bullet"><span class="by">__david__</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887439">parent</a><span>|</span><a href="#39887564">prev</a><span>|</span><a href="#39889560">next</a><span>|</span><label class="collapse" for="c-39888340">[-]</label><label class="expand" for="c-39888340">[1 more]</label></div><br/><div class="children"><div class="content">Do you just use document.createElement(), getElementById(), and friends? I&#x27;ve written lots of web apps that just used those. But I&#x27;ve also jumped into React a couple times to learn if it&#x27;s better or faster or whatever. I generally think it&#x27;s a reasonable approach for a template style web app—ie, when you need to build a whole lot of html nodes that interact with each other in the way a complicated ui does. But I do find I can get stuck trying to reason about some of the weird reactivity stuff with useState() and useEffect(). I kinda chalk that up to me being not an expert, but it also feels like a bit of an impedance mismatch with the language itself.<p>But I don&#x27;t think React necessary for _every_ app and it really depends on what kind of apps you are making.<p>Certainly you can do the original style of app where the templating is on the server and any js is just to hook up already existing nodes. The js community has more or less moved away from that &quot;rails&quot; style of app years ago…</div><br/></div></div><div id="39889560" class="c"><input type="checkbox" id="c-39889560" checked=""/><div class="controls bullet"><span class="by">jbreckmckye</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887439">parent</a><span>|</span><a href="#39888340">prev</a><span>|</span><a href="#39889561">next</a><span>|</span><label class="collapse" for="c-39889560">[-]</label><label class="expand" for="c-39889560">[2 more]</label></div><br/><div class="children"><div class="content">I think it would help if you mentioned the kinds of applications you&#x27;re building.<p>What do you mean by &quot;web apps&quot; here? My memory of the web in 1999 was that the only rich web UX was in Java applets</div><br/><div id="39890093" class="c"><input type="checkbox" id="c-39890093" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39889560">parent</a><span>|</span><a href="#39889561">next</a><span>|</span><label class="collapse" for="c-39890093">[-]</label><label class="expand" for="c-39890093">[1 more]</label></div><br/><div class="children"><div class="content">There was this thing called DHTML. It was no Ajax, but you could hide and show elements, change its contents, respond to events, etc. Cross browser was a nightmare. And the server side handled most of the work.<p>Today I build all sorts of things with lots of interactive elements on the frontend, but trying to avoid using React if I can.</div><br/></div></div></div></div><div id="39889561" class="c"><input type="checkbox" id="c-39889561" checked=""/><div class="controls bullet"><span class="by">pquki4</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887439">parent</a><span>|</span><a href="#39889560">prev</a><span>|</span><a href="#39887448">next</a><span>|</span><label class="collapse" for="c-39889561">[-]</label><label class="expand" for="c-39889561">[2 more]</label></div><br/><div class="children"><div class="content">If you are working in a team with 5+ developers who work on the UI where people need to be able to quickly reuse components and put them in large, complicated applications with lots of data that could be fetched and updated with HTTP requests, it is almost impossible not to use any of those frameworks.<p>If you are working on your own, or only create small web apps, sure, you can avoid frameworks in some cases.</div><br/><div id="39890187" class="c"><input type="checkbox" id="c-39890187" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39889561">parent</a><span>|</span><a href="#39887448">next</a><span>|</span><label class="collapse" for="c-39890187">[-]</label><label class="expand" for="c-39890187">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it is almost impossible not to use any of those frameworks.<p>Agreed, but because it’s a lot easier to just search for “React programmer” these days than it is to evaluate lots of JavaScript candidates, which has a much wider scope and proficiency level and make sure they’ll fit right in when hired.<p>But not because direct DOM manipulation is not inherently scalable. See puter[1] for instance, a fairly complex, 100k+ lines of code of jQuery.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;HeyPuter&#x2F;puter">https:&#x2F;&#x2F;github.com&#x2F;HeyPuter&#x2F;puter</a></div><br/></div></div></div></div></div></div></div></div><div id="39887448" class="c"><input type="checkbox" id="c-39887448" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#39887380">parent</a><span>|</span><a href="#39887400">prev</a><span>|</span><a href="#39890800">next</a><span>|</span><label class="collapse" for="c-39887448">[-]</label><label class="expand" for="c-39887448">[4 more]</label></div><br/><div class="children"><div class="content">Decades is a long time. You must remember the complexities of updating the DOM between browsers, surely.<p>Keeping the DOM in sync with a data state isn’t too difficult but doing so in a highly performant (60 fps) way _is_ tremendously difficult. Especially when it comes to creating APIs that aren’t leaky but also not too cumbersome.<p>It would frankly be easier to just paint pixels to a canvas game-style, than translating changes to a living DOM tree.</div><br/><div id="39887470" class="c"><input type="checkbox" id="c-39887470" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887448">parent</a><span>|</span><a href="#39890800">next</a><span>|</span><label class="collapse" for="c-39887470">[-]</label><label class="expand" for="c-39887470">[3 more]</label></div><br/><div class="children"><div class="content">If you need 60fps you shouldn’t use the DOM. It’s not a game engine. Like you said, go with canvas.</div><br/><div id="39889546" class="c"><input type="checkbox" id="c-39889546" checked=""/><div class="controls bullet"><span class="by">pquki4</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39887470">parent</a><span>|</span><a href="#39890800">next</a><span>|</span><label class="collapse" for="c-39889546">[-]</label><label class="expand" for="c-39889546">[2 more]</label></div><br/><div class="children"><div class="content">60fps is not a high bar. A timer that gets updated every 10 millisecond (or in truth whatever the next event loop interval) is commonly used as tutorial, and there is no reason such a widget does not have a high refresh rate.<p>The point of the original comment is that DOM updates should be fast, efficient and avoid visible delays to user&#x27;s eye, which is not easy. If you are not careful, small changes in a large application could lead to too many DOM updates -- that is where frameworks shine.<p>And canvas is not the solution to everything and has its own problems. To begin with, accessibility.</div><br/><div id="39890017" class="c"><input type="checkbox" id="c-39890017" checked=""/><div class="controls bullet"><span class="by">tambourine_man</span><span>|</span><a href="#39887380">root</a><span>|</span><a href="#39889546">parent</a><span>|</span><a href="#39890800">next</a><span>|</span><label class="collapse" for="c-39890017">[-]</label><label class="expand" for="c-39890017">[1 more]</label></div><br/><div class="children"><div class="content">I agree with all of it. I did recently a timeline with hundreds of elements, 3D transforms etc. Everything was smooth and not because I was particularly clever, but because browsers are fast. All direct DOM manipulation.<p>My complaint with modern frameworks is not FPS, but rather that a hello world often requires 20k files plus a compilation step and the upshot isn’t particularly clear to me. I’ve never been to one of its landing pages and thought: wow, that’s a problem I have and this looks like the perfect solution.<p>Conversely, I clearly remember the first time I saw jQuery. Loading content via Ajax and fading in when done, all in 3 lines of code and cross browser. I was sold at that very second.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39886837" class="c"><input type="checkbox" id="c-39886837" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39887380">prev</a><span>|</span><a href="#39888284">next</a><span>|</span><label class="collapse" for="c-39886837">[-]</label><label class="expand" for="c-39886837">[15 more]</label></div><br/><div class="children"><div class="content">Promises are a nice success story, but without async&#x2F;await it wasn&#x27;t really necessary to standardize<p>&gt; The current draft is based on design input from the authors&#x2F;maintainers of Angular, Bubble, Ember, FAST, MobX, Preact, Qwik, RxJS, Solid, Starbeam, Svelte, Vue, Wiz, and more…<p>Would be interested what existing library authors think of this proposal. Interesting that React is not in that list<p>Signals are a bit like channels, except they&#x27;re broadcast instead of single receiver. It&#x27;d be neat if this could somehow be leveraged to allow web workers to communicate with channels instead of onMessage callbacks. Specifically being able to `select` over signals&#x2F;channels&#x2F;promises like in Go would over a syntactic benefit over having to try manage multiple concurrent messaging mechanism with callbacks (maybe by allowing signals to be included in `Promise.any`)</div><br/><div id="39888035" class="c"><input type="checkbox" id="c-39888035" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#39886837">parent</a><span>|</span><a href="#39886897">next</a><span>|</span><label class="collapse" for="c-39888035">[-]</label><label class="expand" for="c-39888035">[1 more]</label></div><br/><div class="children"><div class="content">&gt; without async&#x2F;await it wasn&#x27;t really necessary to standardize<p>Hard disagree.<p>`x instanceof Promise` simply doesn&#x27;t work. If my library has a then method that accepts a catch callback and yours doesn&#x27;t, they&#x27;re silently non-interoperable, and there&#x27;s no way to detect it. When does `finally` run? What expectations can you have around how async the callbacks are? Without a standard, every single library that uses promises needs to bring its own polyfill because you can&#x27;t trust what&#x27;s there. And you can&#x27;t actually consume any other library&#x27;s promises, because you can&#x27;t trust that they behave in the way you expect them to.<p>And I&#x27;m not just speculating, this was reality for many years and a hell that many of us had to endure.</div><br/></div></div><div id="39886897" class="c"><input type="checkbox" id="c-39886897" checked=""/><div class="controls bullet"><span class="by">watson</span><span>|</span><a href="#39886837">parent</a><span>|</span><a href="#39888035">prev</a><span>|</span><a href="#39886965">next</a><span>|</span><label class="collapse" for="c-39886897">[-]</label><label class="expand" for="c-39886897">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Promises are a nice success story, but without async&#x2F;await it wasn&#x27;t really necessary to standardize<p>One benefit of standardisation that&#x27;s not tied to async&#x2F;await is that the JavaScript engines has been able to do performance optimisations not otherwise possible which benefit Promise-heavy applications</div><br/></div></div><div id="39886965" class="c"><input type="checkbox" id="c-39886965" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#39886837">parent</a><span>|</span><a href="#39886897">prev</a><span>|</span><a href="#39886912">next</a><span>|</span><label class="collapse" for="c-39886965">[-]</label><label class="expand" for="c-39886965">[8 more]</label></div><br/><div class="children"><div class="content"><i>&gt; “Interesting that React is not in that list”</i><p>Signals are not a part of the core React API, unlike Preact.<p>My vague gut feeling is that signals are too much like a generalized useEffect() and would only introduce further confusion into React by muddling what happens during the render cycle. For better and worse, React takes a different tack to updates than signals do. But maybe I’m wrong about their applicability.</div><br/><div id="39887671" class="c"><input type="checkbox" id="c-39887671" checked=""/><div class="controls bullet"><span class="by">Fatalist_ma</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39886965">parent</a><span>|</span><a href="#39887121">next</a><span>|</span><label class="collapse" for="c-39887671">[-]</label><label class="expand" for="c-39887671">[5 more]</label></div><br/><div class="children"><div class="content">There is an interesting debate about React and signals in the comments of this article, between Dan Abramov and Ryan Carniato - <a href="https:&#x2F;&#x2F;dev.to&#x2F;this-is-learning&#x2F;react-vs-signals-10-years-later-3k71" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;this-is-learning&#x2F;react-vs-signals-10-years-la...</a></div><br/><div id="39888429" class="c"><input type="checkbox" id="c-39888429" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39887671">parent</a><span>|</span><a href="#39887121">next</a><span>|</span><label class="collapse" for="c-39888429">[-]</label><label class="expand" for="c-39888429">[4 more]</label></div><br/><div class="children"><div class="content">I read it until the point where he defends the idea that these two functions obviously do something completely different:<p><pre><code>  function One(props) {
    const doubleCount = props.count * 2;
    return &lt;div&gt;Count: {doubleCount}&lt;&#x2F;div&gt;;
  }

  function Two(props) {
    return &lt;div&gt;Count: {props.count * 2}&lt;&#x2F;div&gt;;
  }
</code></pre>
It honestly made me wonder whether the article was dated April 1 and I’d been had.<p>More generously, JS framework design is hard. If you’re ambitious at all, you end up fighting the language and your runtime paradigms will hang like ill-fitting clothes on its syntax. The One&#x2F;Two example above shows how easily expectations break in this world of extensions to extensions. There’s no way to know what an apparently simple piece of code will actually do without knowing the specifics of a given framework.</div><br/><div id="39889931" class="c"><input type="checkbox" id="c-39889931" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39888429">parent</a><span>|</span><a href="#39889515">next</a><span>|</span><label class="collapse" for="c-39889931">[-]</label><label class="expand" for="c-39889931">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I read it until the point where he defends the idea that these two functions obviously do something completely different<p>&gt; [code]<p>&gt; It honestly made me wonder whether the article was dated April 1 and I’d been had.<p>They don’t do anything different if your model of components is that they rerun. But that model is only one way to implement components, and JSX is unopinionated about semantics exactly like this. <i>Intentionally, by design.</i><p>If you’re only familiar with React and other frameworks with a similar rendering model, of course it’ll be surprising that those two functions would behave differently. But if you’re familiar with other JSX implementations like Solid, you’ll spot the difference right away: components don’t rerun, only the JSX does. The first function will always render the same thing because `doubleCount` is <i>set up</i> on component creation and static for the remainder of the time the returned div is mounted.<p>You are welcome to prefer React’s model. It certainly has some cognitive advantages. But it’s not inherently the only correct model either.</div><br/></div></div><div id="39889515" class="c"><input type="checkbox" id="c-39889515" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39888429">parent</a><span>|</span><a href="#39889931">prev</a><span>|</span><a href="#39890876">next</a><span>|</span><label class="collapse" for="c-39889515">[-]</label><label class="expand" for="c-39889515">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There’s no way to know what an apparently simple piece of code will actually do without knowing the specifics of a given framework.<p>Yes. In solid-js JSX interpolation needs to be read as having implicit lambdas. You need to know how a framework works to use it<p>It&#x27;s somewhat what the discussion was getting at between Ryan &amp; Dan. solid-js having fine grained reactivity involves a lot of lambdas, in JSX they&#x27;re implicit, but code outside of JSX has to spell them out explicitly</div><br/></div></div><div id="39890876" class="c"><input type="checkbox" id="c-39890876" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39888429">parent</a><span>|</span><a href="#39889515">prev</a><span>|</span><a href="#39887121">next</a><span>|</span><label class="collapse" for="c-39890876">[-]</label><label class="expand" for="c-39890876">[1 more]</label></div><br/><div class="children"><div class="content">There are those of us for which this actually makes sense. More sense than react anyway.</div><br/></div></div></div></div></div></div><div id="39887121" class="c"><input type="checkbox" id="c-39887121" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39886965">parent</a><span>|</span><a href="#39887671">prev</a><span>|</span><a href="#39886912">next</a><span>|</span><label class="collapse" for="c-39887121">[-]</label><label class="expand" for="c-39887121">[2 more]</label></div><br/><div class="children"><div class="content">My feeling is that it&#x27;s philosophically outside the purview of React whose focus is rendering (and components and their state but not global state), RxJS and and MobX are both usable with React and have signals whilst Redux goes another route and React is &quot;above&quot; that choice.</div><br/><div id="39891476" class="c"><input type="checkbox" id="c-39891476" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39887121">parent</a><span>|</span><a href="#39886912">next</a><span>|</span><label class="collapse" for="c-39891476">[-]</label><label class="expand" for="c-39891476">[1 more]</label></div><br/><div class="children"><div class="content">Rendering in React would benefit greatly from fine-grained reactivity (which what signals offer). However, for some reason the React team insists that the lowest level of reactivity in their system os the component, no matter how large or complex it is.</div><br/></div></div></div></div></div></div><div id="39886912" class="c"><input type="checkbox" id="c-39886912" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#39886837">parent</a><span>|</span><a href="#39886965">prev</a><span>|</span><a href="#39887353">next</a><span>|</span><label class="collapse" for="c-39886912">[-]</label><label class="expand" for="c-39886912">[3 more]</label></div><br/><div class="children"><div class="content">Maybe they can call it &quot;EventEmitter&quot;<p><a href="https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;learn&#x2F;asynchronous-work&#x2F;the-nodejs-event-emitter" rel="nofollow">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;learn&#x2F;asynchronous-work&#x2F;the-nodejs-eve...</a></div><br/><div id="39887280" class="c"><input type="checkbox" id="c-39887280" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39886912">parent</a><span>|</span><a href="#39887353">next</a><span>|</span><label class="collapse" for="c-39887280">[-]</label><label class="expand" for="c-39887280">[2 more]</label></div><br/><div class="children"><div class="content">That looks like it fits with the theme, but events are difficult to compose &amp; tend to have easy leaks by requiring explicit attach&#x2F;detach (not that I&#x27;m sure the proposal here addresses those issues)</div><br/><div id="39891155" class="c"><input type="checkbox" id="c-39891155" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#39886837">root</a><span>|</span><a href="#39887280">parent</a><span>|</span><a href="#39887353">next</a><span>|</span><label class="collapse" for="c-39891155">[-]</label><label class="expand" for="c-39891155">[1 more]</label></div><br/><div class="children"><div class="content">Could you not just compose a new EventEmitter constructor that uses the new FinalizationRegistry API to drop all handlers of subjects which have since been garbage collected?</div><br/></div></div></div></div></div></div><div id="39887353" class="c"><input type="checkbox" id="c-39887353" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#39886837">parent</a><span>|</span><a href="#39886912">prev</a><span>|</span><a href="#39888284">next</a><span>|</span><label class="collapse" for="c-39887353">[-]</label><label class="expand" for="c-39887353">[1 more]</label></div><br/><div class="children"><div class="content">React isn’t in this list because its effects are declarative, not imperative (except for props changes and re-renders which you could argue are in fact declarative, just one abstraction removed). UseEffect neatly compartmentalizes imperative behavior.<p>This looks a lot like ember data binding which becomes an imperative nightmare. Its default state is “foot gun” with tons of cognitive overhead and meta patterns to keep it from getting that way.</div><br/></div></div></div></div><div id="39888284" class="c"><input type="checkbox" id="c-39888284" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#39886837">prev</a><span>|</span><a href="#39886923">next</a><span>|</span><label class="collapse" for="c-39888284">[-]</label><label class="expand" for="c-39888284">[1 more]</label></div><br/><div class="children"><div class="content">Related is S.js: <a href="https:&#x2F;&#x2F;github.com&#x2F;adamhaile&#x2F;s">https:&#x2F;&#x2F;github.com&#x2F;adamhaile&#x2F;s</a><p>I love signals. I prefer them when making UIs over any other primitive (besides, perhaps, the cassowary constraint algorithm). I try to replicate them in every language I use, just for fun.<p>I also don&#x27;t believe they belong in the Javascript language whatsoever. Let the language be for a while, people already struggle to keep up with it. TC-39 is already scaring away people from the language.</div><br/></div></div><div id="39886923" class="c"><input type="checkbox" id="c-39886923" checked=""/><div class="controls bullet"><span class="by">lambdaba</span><span>|</span><a href="#39888284">prev</a><span>|</span><a href="#39888117">next</a><span>|</span><label class="collapse" for="c-39886923">[-]</label><label class="expand" for="c-39886923">[2 more]</label></div><br/><div class="children"><div class="content">This looks very much like mobx, which is my favorite JS effect system.<p>Here is the mobx version:<p><pre><code>  import { observable, computed, autorun } from &#x27;mobx&#x27;;

  const counter = observable.box(0);

  const isEven = computed(() =&gt; (counter.get() &amp; 1) === 0);

  const parity = computed(() =&gt; isEven.get() ? &quot;even&quot; : &quot;odd&quot;);

  autorun(() =&gt; {
    element.innerText = parity.get();
  });

  &#x2F;&#x2F; Simulate external updates to counter...
  setInterval(() =&gt; counter.set(counter.get() + 1), 1000);</code></pre></div><br/><div id="39888333" class="c"><input type="checkbox" id="c-39888333" checked=""/><div class="controls bullet"><span class="by">kabes</span><span>|</span><a href="#39886923">parent</a><span>|</span><a href="#39888117">next</a><span>|</span><label class="collapse" for="c-39888333">[-]</label><label class="expand" for="c-39888333">[1 more]</label></div><br/><div class="children"><div class="content">Well, mobx is signals. But signals where the dependencies are tracked implicitly via the proxy ovject, instead of explicitly by a getter.</div><br/></div></div></div></div><div id="39888117" class="c"><input type="checkbox" id="c-39888117" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#39886923">prev</a><span>|</span><a href="#39891533">next</a><span>|</span><label class="collapse" for="c-39888117">[-]</label><label class="expand" for="c-39888117">[1 more]</label></div><br/><div class="children"><div class="content">&quot;let&#x27;s bake my current framework du jour into the standard library!&quot;<p>It&#x27;s a bit like tattooing your girlfriend&#x27;s name onto yourself.</div><br/></div></div><div id="39891533" class="c"><input type="checkbox" id="c-39891533" checked=""/><div class="controls bullet"><span class="by">gloosx</span><span>|</span><a href="#39888117">prev</a><span>|</span><a href="#39887631">next</a><span>|</span><label class="collapse" for="c-39891533">[-]</label><label class="expand" for="c-39891533">[3 more]</label></div><br/><div class="children"><div class="content">To be as a long-time react.js user – these examples look like a kinda weird mix of declarative with some bitter imperatives. Like, foo.set depending on foo.get and having to manually set element innerText inside the side-effect, eww, I can only imagine how messy it can get for a somewhat more complex application.<p>React boilerplate for this case looks so much better in my opinion, take a look<p>```<p>function Component() {<p><pre><code>  const [counter, tick] = useReducer(st =&gt; st + 1, 0)

  useEffect(() =&gt; setInterval(tick, 1000))

  return counter % 2 ? &#x27;odd&#x27; : &#x27;even&#x27;</code></pre>
}<p>```<p>Three lines, declarative, functional, noice.</div><br/><div id="39891581" class="c"><input type="checkbox" id="c-39891581" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#39891533">parent</a><span>|</span><a href="#39887631">next</a><span>|</span><label class="collapse" for="c-39891581">[-]</label><label class="expand" for="c-39891581">[2 more]</label></div><br/><div class="children"><div class="content">Functional usually means the output can only depend on the input. But this is depending on some external state getting smuggled in through a hook.  FWIW some people prefer the alternatives over this.</div><br/><div id="39891796" class="c"><input type="checkbox" id="c-39891796" checked=""/><div class="controls bullet"><span class="by">gloosx</span><span>|</span><a href="#39891533">root</a><span>|</span><a href="#39891581">parent</a><span>|</span><a href="#39887631">next</a><span>|</span><label class="collapse" for="c-39891796">[-]</label><label class="expand" for="c-39891796">[1 more]</label></div><br/><div class="children"><div class="content">This not really correct, the useReducer hook is not some external state which is smuggled in. It is an actual input for the reconciler which defines an output of this component, so it is perfectly functional even by your definition.</div><br/></div></div></div></div></div></div><div id="39887631" class="c"><input type="checkbox" id="c-39887631" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#39891533">prev</a><span>|</span><a href="#39887442">next</a><span>|</span><label class="collapse" for="c-39887631">[-]</label><label class="expand" for="c-39887631">[9 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t understand the example in the linked README.<p><pre><code>  &#x2F;&#x2F; A library or framework defines effects based on other Signal primitives
  declare function effect(cb: () =&gt; void): (() =&gt; void);
</code></pre>
What library? What framework? I lost here. What&#x27;s effect?<p><pre><code>  effect(() =&gt; element.innerText = parity.get());
</code></pre>
How does effect knows that it needs to call this lambda whenever parity gets changed? Will it call this lambda on any signal change? Why this talk about caching then? Probably not.<p>Anyway I think that signal idea is sound, if I understood correctly what the authors tried to convey. My main issue with those decoupling architectures is that once your application is complex enough, you will get lost trying to figure out why this particular event being emitting. Ideally signals should fix this by modifying stacktrace, so when my callback is being called, it&#x27;d already contain a stacktrace of the code which triggered that signal in the first place.</div><br/><div id="39887786" class="c"><input type="checkbox" id="c-39887786" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#39887631">parent</a><span>|</span><a href="#39888189">next</a><span>|</span><label class="collapse" for="c-39887786">[-]</label><label class="expand" for="c-39887786">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What library? What framework? I lost here. What&#x27;s effect?<p>There are various libraries that export a function called effect which allows you to run arbitrary code in response to a signal update. The Preact docs have a great primer on signals and effects: <a href="https:&#x2F;&#x2F;preactjs.com&#x2F;guide&#x2F;v10&#x2F;signals#effectfn" rel="nofollow">https:&#x2F;&#x2F;preactjs.com&#x2F;guide&#x2F;v10&#x2F;signals#effectfn</a><p>As I understand it, these effect functions run the callback once initially to see which signals were accessed while the callback was executing, and then call the callback again whenever the signals it depends on update. As long as signal access is synchronous and single-threaded, you know that if a signal was accessed during the callback&#x27;s execution that the callback should be subscribed to those signals.<p>&gt; How does effect knows that it needs to call this lambda whenever parity gets changed? Will it call this lambda on any signal change?<p>You can do this with getters [1], where the effect function tracks which properties of the signal were accessed in a getter method (I believe Vue historically did this in version 2), but you can also track object access using proxies [2]. The example from the proposal simply has a &#x27;get&#x27; method that is called to access the value of the signal, and executing this method allows dependencies to be tracked.<p>[1] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Functions&#x2F;get" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>[2] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Proxy" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/></div></div><div id="39888189" class="c"><input type="checkbox" id="c-39888189" checked=""/><div class="controls bullet"><span class="by">mondrian</span><span>|</span><a href="#39887631">parent</a><span>|</span><a href="#39887786">prev</a><span>|</span><a href="#39889990">next</a><span>|</span><label class="collapse" for="c-39888189">[-]</label><label class="expand" for="c-39888189">[4 more]</label></div><br/><div class="children"><div class="content">&gt; How does effect knows that it needs to call this lambda whenever parity gets changed?<p>The call `parity.get()` will register a dependency on the function that is passed to `effect()`. When `parity` is updated, the function is called.<p>&gt; Will it call this lambda on any signal change?<p>Only when a dependent signal changes.<p>In this case, `parity` depends on `isEven` and `isEven` depends on `counter`. So when `counter` is updated, that whole dependency chain is invalidated leading to `parity` getting invalidated, and that callback re-running.</div><br/><div id="39888320" class="c"><input type="checkbox" id="c-39888320" checked=""/><div class="controls bullet"><span class="by">posix86</span><span>|</span><a href="#39887631">root</a><span>|</span><a href="#39888189">parent</a><span>|</span><a href="#39889990">next</a><span>|</span><label class="collapse" for="c-39888320">[-]</label><label class="expand" for="c-39888320">[3 more]</label></div><br/><div class="children"><div class="content">This works well until you accidentally have an if&#x2F;else branch, then you get hard to track bugs (halting problem in the general case).<p>I&#x27;m guessing this is why they don&#x27;t propose to add this function to the standard: That fact makes it not very pretty.</div><br/><div id="39888555" class="c"><input type="checkbox" id="c-39888555" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#39887631">root</a><span>|</span><a href="#39888320">parent</a><span>|</span><a href="#39888542">next</a><span>|</span><label class="collapse" for="c-39888555">[-]</label><label class="expand" for="c-39888555">[1 more]</label></div><br/><div class="children"><div class="content">if&#x2F;else isn&#x27;t a problem. If the condition isn&#x27;t dependent then update of unused branch doesn&#x27;t matter</div><br/></div></div><div id="39888542" class="c"><input type="checkbox" id="c-39888542" checked=""/><div class="controls bullet"><span class="by">mondrian</span><span>|</span><a href="#39887631">root</a><span>|</span><a href="#39888320">parent</a><span>|</span><a href="#39888555">prev</a><span>|</span><a href="#39889990">next</a><span>|</span><label class="collapse" for="c-39888542">[-]</label><label class="expand" for="c-39888542">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, can you explain how if&#x2F;else branches cause hard to track bugs?</div><br/></div></div></div></div></div></div><div id="39889990" class="c"><input type="checkbox" id="c-39889990" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#39887631">parent</a><span>|</span><a href="#39888189">prev</a><span>|</span><a href="#39887934">next</a><span>|</span><label class="collapse" for="c-39889990">[-]</label><label class="expand" for="c-39889990">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How does effect knows that it needs to call this lambda whenever parity gets changed?<p>Basically all implementations of signals (by whatever name) build a dynamic dependency graph, where edges are established by reading nodes. In a tracking context like this hypothetical `effect`, the read also establishes an edge between the signal’s state node and the effect’s computation node—effectively subscribing the latter to subsequent writes to the former, in order to determine when to rerun the computation.</div><br/></div></div><div id="39887934" class="c"><input type="checkbox" id="c-39887934" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#39887631">parent</a><span>|</span><a href="#39889990">prev</a><span>|</span><a href="#39887779">next</a><span>|</span><label class="collapse" for="c-39887934">[-]</label><label class="expand" for="c-39887934">[1 more]</label></div><br/><div class="children"><div class="content">I suspect the watcher is needed by the implementation of effect</div><br/></div></div><div id="39887779" class="c"><input type="checkbox" id="c-39887779" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#39887631">parent</a><span>|</span><a href="#39887934">prev</a><span>|</span><a href="#39887442">next</a><span>|</span><label class="collapse" for="c-39887779">[-]</label><label class="expand" for="c-39887779">[1 more]</label></div><br/><div class="children"><div class="content">1. effect is any function you want to invoke<p>2. with signals the dependency tracking mechanism knows what values need to be recalculated and as a result the system knows which functions to call again</div><br/></div></div></div></div><div id="39887442" class="c"><input type="checkbox" id="c-39887442" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#39887631">prev</a><span>|</span><a href="#39887015">next</a><span>|</span><label class="collapse" for="c-39887442">[-]</label><label class="expand" for="c-39887442">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think signals will help move development away from further complexity, and that&#x27;s really what we need today.<p>There&#x27;s a fundamental question of why modern sites&#x2F;apps reach for patterns like signals, memorization, hybrid rendering patterns, etc. I wouldn&#x27;t begin to claim I have all the answers, but clearly there are gaps in the platform with regards to the patterns people <i>want</i> to implement and I&#x27;m not sure that jumping to signals as a standard helps better understand whether its the platform or our mental models that need updating to get back in sync.<p>Personally I&#x27;ve found code much easier to maintain when the frontend is only responsible for state that truly is temporary and doesn&#x27;t live on the back end at all. For me any persisted state belongs on the server, as does any rendering that depends on it. This largely makes signals unnecessary, very few apps have such complex temporary state that I need a complicated setup to manage it.</div><br/></div></div><div id="39887015" class="c"><input type="checkbox" id="c-39887015" checked=""/><div class="controls bullet"><span class="by">makkesk8</span><span>|</span><a href="#39887442">prev</a><span>|</span><a href="#39888142">next</a><span>|</span><label class="collapse" for="c-39887015">[-]</label><label class="expand" for="c-39887015">[7 more]</label></div><br/><div class="children"><div class="content">Looks useful, but what baffles me is.. Why is every framework setting state or their &quot;signals&quot; using &quot;setX&quot; functions? What&#x27;s wrong with the built in getter and setters that you can either proxy or straight up override?<p>This feels arguably cleaner:
something = &quot;else&quot;;<p>Than:    
setSomething(&quot;else&quot;);</div><br/><div id="39891996" class="c"><input type="checkbox" id="c-39891996" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#39887015">parent</a><span>|</span><a href="#39890786">next</a><span>|</span><label class="collapse" for="c-39891996">[-]</label><label class="expand" for="c-39891996">[1 more]</label></div><br/><div class="children"><div class="content">Because javascript lacks scope-as-an-object. You can&#x27;t track `var x; x = value` through it. `setSomething()` sends a notification after an assignment. Also, DOM elements can only take raw values and must be manually updated from your data flow.<p>Adding these features in-browser would seriously slow down DOM and JS and thus all websites for real. So instead we load megabytes of JS abstraction wrappers and run them in a browser to only simulate the effect.</div><br/></div></div><div id="39890786" class="c"><input type="checkbox" id="c-39890786" checked=""/><div class="controls bullet"><span class="by">mhio</span><span>|</span><a href="#39887015">parent</a><span>|</span><a href="#39891996">prev</a><span>|</span><a href="#39887517">next</a><span>|</span><label class="collapse" for="c-39890786">[-]</label><label class="expand" for="c-39890786">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    something = &quot;else&quot;;
</code></pre>
That is not observable for the primitive JS types that aren&#x27;t objects and have no methods or properties or getters&#x2F;setters (string, number, boolean, undefined, symbol, null).<p><pre><code>    some.thing = &quot;else&quot;;
</code></pre>
The `some` can be proxied and observed. Most frameworks are setting up the `some` container&#x2F;proxy&#x2F;object so everything can be accessed and observed consistently. Whether the framework exposes the object, a function, or hides it away in a DSL depends on the implementation.</div><br/></div></div><div id="39887517" class="c"><input type="checkbox" id="c-39887517" checked=""/><div class="controls bullet"><span class="by">notnullorvoid</span><span>|</span><a href="#39887015">parent</a><span>|</span><a href="#39890786">prev</a><span>|</span><a href="#39887170">next</a><span>|</span><label class="collapse" for="c-39887517">[-]</label><label class="expand" for="c-39887517">[1 more]</label></div><br/><div class="children"><div class="content">Some libraries that feature signals style reactivity do use getter and setters (ember.js, and mobx are 2 good examples). However it makes sense for the primitive API to use functions since getter and setters are functions under the hood and get applied to an object as part of a property descriptor. It&#x27;s also not always desirable to have a reactive value embedded in an object, sometimes you just want to pass around a single changeable value.<p>As for why some libraries choose the `[thing, setThing] = signal()` API (like solid.js) that&#x27;s often referred to as read write segregation. Which essentially encourages the practice of passing read only values by default, and opting in to allowing consumer writes on a value by explicitly passing it&#x27;s setter function. This is something that was popularized by React hooks.<p>Either way this proposal isn&#x27;t limiting the API choice of libraries since you can create whatever kind of wrappers around the primitive that you want.</div><br/></div></div><div id="39887170" class="c"><input type="checkbox" id="c-39887170" checked=""/><div class="controls bullet"><span class="by">j1elo</span><span>|</span><a href="#39887015">parent</a><span>|</span><a href="#39887517">prev</a><span>|</span><a href="#39888494">next</a><span>|</span><label class="collapse" for="c-39887170">[-]</label><label class="expand" for="c-39887170">[1 more]</label></div><br/><div class="children"><div class="content">For one I can write &quot;.set&quot; and the IDE would auto-complete with all possible somethings that can be set, even without having the slightest idea of which ones there are.<p>I&#x27;ve very much enjoyed this kind of consistency wherever is found (having a common prefix for common behaviors, in this case, setters)</div><br/></div></div><div id="39888494" class="c"><input type="checkbox" id="c-39888494" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#39887015">parent</a><span>|</span><a href="#39887170">prev</a><span>|</span><a href="#39887394">next</a><span>|</span><label class="collapse" for="c-39888494">[-]</label><label class="expand" for="c-39888494">[1 more]</label></div><br/><div class="children"><div class="content">well to use setters it has to be &quot;foo.something = else&quot;, because JS can&#x27;t override plain old local bindings -- not since &quot;with&quot; was sent to the cornfield anyway.  Once you do that, you can indeed have a framework that generates getters and setters, which is exactly what Vue 2 does.  Switch to proxies instead of get&#x2F;set and you have Vue 3 -- the signals API is pretty much identical to the Vue composition API.</div><br/></div></div><div id="39887394" class="c"><input type="checkbox" id="c-39887394" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#39887015">parent</a><span>|</span><a href="#39888494">prev</a><span>|</span><a href="#39888142">next</a><span>|</span><label class="collapse" for="c-39887394">[-]</label><label class="expand" for="c-39887394">[1 more]</label></div><br/><div class="children"><div class="content">One big problem is right now they are _tremendously_ slow to use. (At least through the Proxy native class). Not sure if this is an artifact of JITs or the nature of prototypal inheritance.</div><br/></div></div></div></div><div id="39888142" class="c"><input type="checkbox" id="c-39888142" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#39887015">prev</a><span>|</span><a href="#39891427">next</a><span>|</span><label class="collapse" for="c-39888142">[-]</label><label class="expand" for="c-39888142">[1 more]</label></div><br/><div class="children"><div class="content">Back in the days there was an effort to put observables in the language because they were popular (and rxjs was, too).<p>Glad that didn&#x27;t happen. And I think everybody else is, too. Maybe we should keep that in mind when standardizing features of frameworks.</div><br/></div></div><div id="39891427" class="c"><input type="checkbox" id="c-39891427" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#39888142">prev</a><span>|</span><a href="#39891528">next</a><span>|</span><label class="collapse" for="c-39891427">[-]</label><label class="expand" for="c-39891427">[2 more]</label></div><br/><div class="children"><div class="content">This looks sufficiently advanced to warrant some language support.<p>This could be a much more powerful feature if signal-dependencies were discovered statically, rather than after use in runtime.<p>If you’ve reached the point where you agree that the library should be standardized, why not take it even further to integrate it even more?</div><br/><div id="39891463" class="c"><input type="checkbox" id="c-39891463" checked=""/><div class="controls bullet"><span class="by">sapling-ginger</span><span>|</span><a href="#39891427">parent</a><span>|</span><a href="#39891528">next</a><span>|</span><label class="collapse" for="c-39891463">[-]</label><label class="expand" for="c-39891463">[1 more]</label></div><br/><div class="children"><div class="content">Because there&#x27;s no rule that says signals should ever be created at the top level assigned to a const variable. You could create signal objects dynamically based on user input, no current proposal or implementation prevents this. So there&#x27;s no way to do static analysis on signal graphs.</div><br/></div></div></div></div><div id="39891528" class="c"><input type="checkbox" id="c-39891528" checked=""/><div class="controls bullet"><span class="by">sattoshi</span><span>|</span><a href="#39891427">prev</a><span>|</span><a href="#39889623">next</a><span>|</span><label class="collapse" for="c-39891528">[-]</label><label class="expand" for="c-39891528">[1 more]</label></div><br/><div class="children"><div class="content">The first and only question that matters: is this useful as a primitive?<p>Im inclined to say no. Signals seem like they are a UI concept, primarily. Just use any signal lib you want. Utility libraries dont really need to understand signals.</div><br/></div></div><div id="39889623" class="c"><input type="checkbox" id="c-39889623" checked=""/><div class="controls bullet"><span class="by">nojvek</span><span>|</span><a href="#39891528">prev</a><span>|</span><a href="#39886637">next</a><span>|</span><label class="collapse" for="c-39889623">[-]</label><label class="expand" for="c-39889623">[1 more]</label></div><br/><div class="children"><div class="content">Oh man. This sounds complicated.<p>The hard part of signals is similar to over complicating events.<p>It’s hard to debug what is going on and what to fix when things go wrong.</div><br/></div></div><div id="39886637" class="c"><input type="checkbox" id="c-39886637" checked=""/><div class="controls bullet"><span class="by">senoralligator</span><span>|</span><a href="#39889623">prev</a><span>|</span><a href="#39891380">next</a><span>|</span><label class="collapse" for="c-39886637">[-]</label><label class="expand" for="c-39886637">[7 more]</label></div><br/><div class="children"><div class="content">Surely it would be better to fix the interoperability issues of the language? &quot;Lets just add a single implementation of everything to the standard!&quot; seems like quite a strange response to &quot;users of the language are having trouble with interoperability due to false coupling.&quot;</div><br/><div id="39886780" class="c"><input type="checkbox" id="c-39886780" checked=""/><div class="controls bullet"><span class="by">nullvoxpopuli</span><span>|</span><a href="#39886637">parent</a><span>|</span><a href="#39886771">next</a><span>|</span><label class="collapse" for="c-39886780">[-]</label><label class="expand" for="c-39886780">[3 more]</label></div><br/><div class="children"><div class="content">is it strange?<p>Vue reactivity isn&#x27;t compatible with Svelte, nor Angular.<p>As a counter example to your question, what if we all had competing implementations of the object primitive. Libraries would barely work with one another and would need an interop layer between them (just as reactivity layers do today!)</div><br/><div id="39886824" class="c"><input type="checkbox" id="c-39886824" checked=""/><div class="controls bullet"><span class="by">senoralligator</span><span>|</span><a href="#39886637">root</a><span>|</span><a href="#39886780">parent</a><span>|</span><a href="#39886771">next</a><span>|</span><label class="collapse" for="c-39886824">[-]</label><label class="expand" for="c-39886824">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll admit I don&#x27;t use JavaScript very often, but surely the state of polymorphism could be improved? For example, C++ recently added concepts, and most (modern) languages have some way to describe interfaces.<p>As to your counterexample, I agree with current JavaScript that would be a problem, but with good language support it would certainly be possible. For example, Rust (and C++?) have competing implementations of the global allocator, and must users will never notice.</div><br/><div id="39887500" class="c"><input type="checkbox" id="c-39887500" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#39886637">root</a><span>|</span><a href="#39886824">parent</a><span>|</span><a href="#39886771">next</a><span>|</span><label class="collapse" for="c-39887500">[-]</label><label class="expand" for="c-39887500">[1 more]</label></div><br/><div class="children"><div class="content">The reactivity layers are all pretty tied into the hearts of the frameworks. There&#x27;s no advantage to any framework to expose such a thing to end users to leverage a competing implementation.<p>As for polymorphism, even the current class syntax largely operates in the same way as the original prototypal inheritance mechanism, with a few exceptions in constructor behavior to support subclassing certain built-in objects.<p>You can pretty easily create run-time traits- like functions with prototpyes, the class construct is an expression whose resulting value can be passed around, mutated, etc.<p>For example, you can write a function that takes a class as an argument, and returns a new class that extends it.</div><br/></div></div></div></div></div></div><div id="39886771" class="c"><input type="checkbox" id="c-39886771" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#39886637">parent</a><span>|</span><a href="#39886780">prev</a><span>|</span><a href="#39887399">next</a><span>|</span><label class="collapse" for="c-39886771">[-]</label><label class="expand" for="c-39886771">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the language hurts or hinders interop much? It has a wide range of tools that can adapt objects between different shapes, for when we do have two similar but different interfaces we are trying to bridge.<p>I struggle to see what more one could want. Do you have any specific features you think would help a massive ecosystem of packages be able to work together, when for example different packages have different Signal implementations?</div><br/><div id="39886848" class="c"><input type="checkbox" id="c-39886848" checked=""/><div class="controls bullet"><span class="by">senoralligator</span><span>|</span><a href="#39886637">root</a><span>|</span><a href="#39886771">parent</a><span>|</span><a href="#39887399">next</a><span>|</span><label class="collapse" for="c-39886848">[-]</label><label class="expand" for="c-39886848">[1 more]</label></div><br/><div class="children"><div class="content">Better ways to describe polymorphism, a better type system in general really. Look to async Rust for a great example of such interoperability.</div><br/></div></div></div></div><div id="39887399" class="c"><input type="checkbox" id="c-39887399" checked=""/><div class="controls bullet"><span class="by">polynomial</span><span>|</span><a href="#39886637">parent</a><span>|</span><a href="#39886771">prev</a><span>|</span><a href="#39891380">next</a><span>|</span><label class="collapse" for="c-39887399">[-]</label><label class="expand" for="c-39887399">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this similar to small core vs large core debates you see in other projects, often where drivers are concerned? (ie question around where the coupling layer is materialized)</div><br/></div></div></div></div><div id="39891380" class="c"><input type="checkbox" id="c-39891380" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#39886637">prev</a><span>|</span><a href="#39886964">next</a><span>|</span><label class="collapse" for="c-39891380">[-]</label><label class="expand" for="c-39891380">[1 more]</label></div><br/><div class="children"><div class="content">The examples only show simple values. What happens when mutating nested objects and arrays?<p>Other frameworks usually struggle a lot with this. With workarounds like having to override equality functions in useMemo() or call .set after a mutation even if you pass in the same instance as before.</div><br/></div></div><div id="39886964" class="c"><input type="checkbox" id="c-39886964" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#39891380">prev</a><span>|</span><a href="#39891393">next</a><span>|</span><label class="collapse" for="c-39886964">[-]</label><label class="expand" for="c-39886964">[8 more]</label></div><br/><div class="children"><div class="content">Is dependency tracking problem statically solvable (without calling effect once and subscribing to all .get&#x27;s)?<p>I don&#x27;t think this needs to be a language feature, rather abstraction of existing features. In other words, can&#x27;t this be a library?<p>I know that SolidJS is able to figure out dependent signals, but probably doing so on the first execution.</div><br/><div id="39887219" class="c"><input type="checkbox" id="c-39887219" checked=""/><div class="controls bullet"><span class="by">twiss</span><span>|</span><a href="#39886964">parent</a><span>|</span><a href="#39888071">next</a><span>|</span><label class="collapse" for="c-39887219">[-]</label><label class="expand" for="c-39887219">[2 more]</label></div><br/><div class="children"><div class="content">I believe Svelte does figure it out at build time.<p>Which does make me question the mention of Svelte in the proposal, and makes me wonder what the Svelte developers think of it - because IIUC they indeed don&#x27;t need this (at runtime), if I&#x27;m not mistaken.</div><br/><div id="39888442" class="c"><input type="checkbox" id="c-39888442" checked=""/><div class="controls bullet"><span class="by">Phillippe</span><span>|</span><a href="#39886964">root</a><span>|</span><a href="#39887219">parent</a><span>|</span><a href="#39888071">next</a><span>|</span><label class="collapse" for="c-39888442">[-]</label><label class="expand" for="c-39888442">[1 more]</label></div><br/><div class="children"><div class="content">The current Svelte version does it at build&#x2F;compile time. The up and coming Svelte 5 is using signals and the reactivity is moved to runtime</div><br/></div></div></div></div><div id="39888071" class="c"><input type="checkbox" id="c-39888071" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#39886964">parent</a><span>|</span><a href="#39887219">prev</a><span>|</span><a href="#39887005">next</a><span>|</span><label class="collapse" for="c-39888071">[-]</label><label class="expand" for="c-39888071">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In other words, can&#x27;t this be a library?<p>You answered your own question:<p>&gt; I know that SolidJS is able to<p>It already is, obviously. But how is SolidJS supposed to work with other non-SolidJS code? It can&#x27;t. Unless every library builds support for every other library, they can&#x27;t possibly interoperate.</div><br/><div id="39888723" class="c"><input type="checkbox" id="c-39888723" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#39886964">root</a><span>|</span><a href="#39888071">parent</a><span>|</span><a href="#39890147">next</a><span>|</span><label class="collapse" for="c-39888723">[-]</label><label class="expand" for="c-39888723">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame that JS ecosystem is so sparse.<p>E.g. in Rust it&#x27;s much more common to rely on existing &quot;building blocks&quot; like futures, tokio, syn, serde even just for basic bindings, favoring interoperability.</div><br/><div id="39889231" class="c"><input type="checkbox" id="c-39889231" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#39886964">root</a><span>|</span><a href="#39888723">parent</a><span>|</span><a href="#39890147">next</a><span>|</span><label class="collapse" for="c-39889231">[-]</label><label class="expand" for="c-39889231">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;ve got it backwards. Fifteen years ago we had jQuery and not a whole lot else. Everyone just used the &quot;building blocks&quot; libraries of js. But then the community and the ecosystem grew exponentially, and we have innumerable choices. Python is similar: I can think of a half dozen ways off the top of my head to build a web app. At least Python was on top of standardizing things like WSGI, but even then you can see rough edges like the non-interoperable nature of concurrent code (twisted vs tornado vs greenlets vs threading vs multiprocessing vs asyncio etc).<p>Rust will have the same thing happen in another decade or so. It&#x27;s prevalence will grow the community, which will grow the ecosystem, and the positive feedback loop will mean that there&#x27;s a huge amount of choice. That&#x27;s a good thing, but it will have downsides, like decreased interoperability (unless the language evolves). JavaScript was cursed for a very long time by leadership that was essentially asleep at the wheel.</div><br/></div></div></div></div><div id="39890147" class="c"><input type="checkbox" id="c-39890147" checked=""/><div class="controls bullet"><span class="by">imbnwa</span><span>|</span><a href="#39886964">root</a><span>|</span><a href="#39888071">parent</a><span>|</span><a href="#39888723">prev</a><span>|</span><a href="#39887005">next</a><span>|</span><label class="collapse" for="c-39890147">[-]</label><label class="expand" for="c-39890147">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It already is, obviously. But how is SolidJS supposed to work with other non-SolidJS code?<p>Who actually writes code like this? People use some signal graph library for application code typically, I’ve never seen anyone mixing SolidJs with MobX in application code or as a consequence of a library dep.</div><br/></div></div></div></div><div id="39887005" class="c"><input type="checkbox" id="c-39887005" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#39886964">parent</a><span>|</span><a href="#39888071">prev</a><span>|</span><a href="#39891393">next</a><span>|</span><label class="collapse" for="c-39887005">[-]</label><label class="expand" for="c-39887005">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In other words, can&#x27;t this be a library?<p>It is explicitly mentioned in the proposal. The problem with 3rd party libraries is their interoperability and diversity of implementations, which might be unnecessary for this kind of things.</div><br/></div></div></div></div><div id="39891393" class="c"><input type="checkbox" id="c-39891393" checked=""/><div class="controls bullet"><span class="by">moi2388</span><span>|</span><a href="#39886964">prev</a><span>|</span><a href="#39887411">next</a><span>|</span><label class="collapse" for="c-39891393">[-]</label><label class="expand" for="c-39891393">[1 more]</label></div><br/><div class="children"><div class="content">But the vanilla code is much cleaner and nicer to read and reason about than the proposal?!<p>Seriously the JavaScript ecosystem is so strange..</div><br/></div></div><div id="39887411" class="c"><input type="checkbox" id="c-39887411" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#39891393">prev</a><span>|</span><a href="#39891017">next</a><span>|</span><label class="collapse" for="c-39887411">[-]</label><label class="expand" for="c-39887411">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, if we can optimize the reactive state management in all web apps, that sounds cool.<p>If this is to be a base for VueJS, it should handle deep changes. They have a note about support Map and Set, but being able to to control depth is nice in VueJS. (I&#x27;d say watch() should be deep by default, since non-deep is an optimization that can lead to accidental inconsistent state.)<p>Streams. Generally, I find RxJS backwards. Usually you just need &quot;state&quot;, so that should be the easiest thing to implement. But I can&#x27;t deny that the programming model is beautiful. Standardizing &quot;state&quot; without also considering streams seems odd to me. The &quot;computed&quot; creates a pipeline of updates, very similar to one you&#x27;d do with a map over a stream. If RxJS didn&#x27;t already exist, I probably wouldn&#x27;t have cared about this duality.<p>Async. Sure, signals can be synchronous, but Computed should definitely play well with async functions. This is a big shortcoming in VueJS (that people work around on their own.) That also implies handling &quot;pending computation&quot; gracefully for debuggability. I see there&#x27;s a &quot;computing&quot; state, but this would have to be surfaced to be able to debug stuck promises.<p>Exceptions. I like the idea of .get() rethrowing exceptions from Computed. VueJS is a bit vague on that front, and just stops.</div><br/><div id="39887465" class="c"><input type="checkbox" id="c-39887465" checked=""/><div class="controls bullet"><span class="by">nullvoxpopuli</span><span>|</span><a href="#39887411">parent</a><span>|</span><a href="#39891017">next</a><span>|</span><label class="collapse" for="c-39887465">[-]</label><label class="expand" for="c-39887465">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it should handle deep changes.<p>these can be implemented in userland via proxy -- and I think probably should, as is proven by this collection of utils: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;nullvoxpopuli&#x2F;status&#x2F;1772669749991739788" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;nullvoxpopuli&#x2F;status&#x2F;1772669749991739788</a><p>If we were to try implementing <i>everything</i> as reactive versions, there&#x27;d be be no end, and implementations couldn&#x27;t keep up -- by pushing reactive Map&#x2F;Set&#x2F;etc to userland&#x2F;library land, we can implement what we need when we need it incrementally, built on the solid foundation of the signal primitives.<p>&gt; since non-deep is an optimization that can lead to accidental inconsistent state.<p>conversely, deep-all-the-time is a performance hit that we don&#x27;t want to be default. Svelte and Ember take this approach of opt-in-deep reactivity.</div><br/></div></div></div></div><div id="39891017" class="c"><input type="checkbox" id="c-39891017" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#39887411">prev</a><span>|</span><a href="#39886950">next</a><span>|</span><label class="collapse" for="c-39891017">[-]</label><label class="expand" for="c-39891017">[1 more]</label></div><br/><div class="children"><div class="content">I’m in favour. Mobx is great. This will focus efforts on making better devtools.</div><br/></div></div><div id="39886950" class="c"><input type="checkbox" id="c-39886950" checked=""/><div class="controls bullet"><span class="by">alserio</span><span>|</span><a href="#39891017">prev</a><span>|</span><a href="#39887176">next</a><span>|</span><label class="collapse" for="c-39886950">[-]</label><label class="expand" for="c-39886950">[1 more]</label></div><br/><div class="children"><div class="content">really looking forward to get nice dev tools out of this work</div><br/></div></div><div id="39887176" class="c"><input type="checkbox" id="c-39887176" checked=""/><div class="controls bullet"><span class="by">angleofrepose</span><span>|</span><a href="#39886950">prev</a><span>|</span><a href="#39889658">next</a><span>|</span><label class="collapse" for="c-39887176">[-]</label><label class="expand" for="c-39887176">[7 more]</label></div><br/><div class="children"><div class="content">Off topic, but I’m wondering if anyone attracted to this topic could help me understand why JavaScript doesn’t have macros.<p>I’m aware of much conversation around dismissing macros, often in the context of bad dev experience — but this sounds like a shallow dismissal to me.<p>At the end of the day, we have some of the results of macros in the JavaScript ecosystem, but rather than being supported by the language they are kicked out to transpilers and compilers.<p>Can anyone point me to authoritative sources discussing macros in JavaScript? I have a hard time finding deep and earnest  discussion around macros by searching myself.</div><br/><div id="39888148" class="c"><input type="checkbox" id="c-39888148" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#39887176">parent</a><span>|</span><a href="#39887590">next</a><span>|</span><label class="collapse" for="c-39888148">[-]</label><label class="expand" for="c-39888148">[2 more]</label></div><br/><div class="children"><div class="content">Interpreted languages rarely have macros.<p>But more importantly, do you really want script tags on webpages defining macros that globally affect how other files are parsed&#x2F;interpreted? What if the macro references an identifier that&#x27;s not global? What if I define a macro in a script that loads after some other JavaScript has already run? Do macros affect eval() and the output of Function.prototype.toString?<p>Sure, you could scope macros to one script&#x2F;module to prevent code from blowing up left and right, but now you need to repeat your macro definitions in every file you create. You could avoid that by bundling your js into one file, but now you&#x27;re back to using a compiler, which makes the whole thing moot.</div><br/><div id="39891171" class="c"><input type="checkbox" id="c-39891171" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#39887176">root</a><span>|</span><a href="#39888148">parent</a><span>|</span><a href="#39887590">next</a><span>|</span><label class="collapse" for="c-39891171">[-]</label><label class="expand" for="c-39891171">[1 more]</label></div><br/><div class="children"><div class="content">It turns out there might actually be a benefit of the compilation step which has been introduced now that everyone uses Typescript... would be really interesting to see macros get added, though I suspect it&#x27;s too far away from Typescript&#x27;s mandate to add as few new features on top of Javascript as possible</div><br/></div></div></div></div><div id="39887590" class="c"><input type="checkbox" id="c-39887590" checked=""/><div class="controls bullet"><span class="by">notnullorvoid</span><span>|</span><a href="#39887176">parent</a><span>|</span><a href="#39888148">prev</a><span>|</span><a href="#39888671">next</a><span>|</span><label class="collapse" for="c-39887590">[-]</label><label class="expand" for="c-39887590">[1 more]</label></div><br/><div class="children"><div class="content">Macros don&#x27;t really make sense in JS runtime spec. Since you can mostly already achieve macro level features by using eval or new Function, but it&#x27;s not very efficient. Macros make most sense at build time, and there have been a few attempts at generalized build macros with various bundlers &#x2F; transpiler plugins. I think the space needs more time to mature. I&#x27;m optimistic that we&#x27;ll eventually see some sort of (un)official macro spec emerge.</div><br/></div></div><div id="39887206" class="c"><input type="checkbox" id="c-39887206" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#39887176">parent</a><span>|</span><a href="#39888671">prev</a><span>|</span><a href="#39889658">next</a><span>|</span><label class="collapse" for="c-39887206">[-]</label><label class="expand" for="c-39887206">[2 more]</label></div><br/><div class="children"><div class="content">You could start here: <a href="https:&#x2F;&#x2F;github.com&#x2F;search?q=org%3Atc39%20macro&amp;type=code">https:&#x2F;&#x2F;github.com&#x2F;search?q=org%3Atc39%20macro&amp;type=code</a></div><br/><div id="39887417" class="c"><input type="checkbox" id="c-39887417" checked=""/><div class="controls bullet"><span class="by">angleofrepose</span><span>|</span><a href="#39887176">root</a><span>|</span><a href="#39887206">parent</a><span>|</span><a href="#39889658">next</a><span>|</span><label class="collapse" for="c-39887417">[-]</label><label class="expand" for="c-39887417">[1 more]</label></div><br/><div class="children"><div class="content">A great resource that I should have found on my own. Thank you. I’ll look through this later. Giving it a quick glance now I see some of the same language I see other places; here that macros are “too far.”<p>I don’t know why macros are approached with apprehension. As I briefly get at in my first comment, I’m aware of a lot of dismissals of macros as a tool, but those dismissals don’t make sense to me in context. I’m missing some backstory or critical mind-share tipping points in the history of the concept.<p>What could be a good set of sources to understand the background perspective with which TC39 members approach the concept of macros?</div><br/></div></div></div></div></div></div><div id="39889658" class="c"><input type="checkbox" id="c-39889658" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#39887176">prev</a><span>|</span><a href="#39889810">next</a><span>|</span><label class="collapse" for="c-39889658">[-]</label><label class="expand" for="c-39889658">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The current draft is based on design input from the authors&#x2F;maintainers of Angular, Bubble, Ember, FAST, MobX, Preact, Qwik, RxJS, Solid, Starbeam, Svelte, Vue, Wiz, and more…<p>This is primarily the only handful of consumers of this stdlib.</div><br/></div></div><div id="39889810" class="c"><input type="checkbox" id="c-39889810" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#39889658">prev</a><span>|</span><a href="#39887387">next</a><span>|</span><label class="collapse" for="c-39889810">[-]</label><label class="expand" for="c-39889810">[1 more]</label></div><br/><div class="children"><div class="content">From a first look, signals seem to parallel event&#x2F;behaviour-style functional reactive programming (FRP). Hopefully some useful ideas from the FRP world can be brought across.</div><br/></div></div><div id="39887387" class="c"><input type="checkbox" id="c-39887387" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#39889810">prev</a><span>|</span><a href="#39886976">next</a><span>|</span><label class="collapse" for="c-39887387">[-]</label><label class="expand" for="c-39887387">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been enjoying &quot;signals&quot; in the form of re-frame subscriptions for many years now.<p>They solve a neat subset of problems in front-end developments.
But they don&#x27;t solve all of them.<p>Adding it to JavaScript as language construct is unnecessary.</div><br/></div></div><div id="39886976" class="c"><input type="checkbox" id="c-39886976" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#39887387">prev</a><span>|</span><a href="#39887347">next</a><span>|</span><label class="collapse" for="c-39886976">[-]</label><label class="expand" for="c-39886976">[1 more]</label></div><br/><div class="children"><div class="content">I like the quality of this proposal, which reminds me of JSRs. It does make a lot of sense.</div><br/></div></div><div id="39887347" class="c"><input type="checkbox" id="c-39887347" checked=""/><div class="controls bullet"><span class="by">rblatz</span><span>|</span><a href="#39886976">prev</a><span>|</span><label class="collapse" for="c-39887347">[-]</label><label class="expand" for="c-39887347">[6 more]</label></div><br/><div class="children"><div class="content">The lack of signals isn’t remotely the largest issue with JS, and adding them has minimal impact for most users of JavaScript. The biggest issue is the lack of a standard library, resulting in npm hell in most projects.</div><br/><div id="39887860" class="c"><input type="checkbox" id="c-39887860" checked=""/><div class="controls bullet"><span class="by">phpnode</span><span>|</span><a href="#39887347">parent</a><span>|</span><a href="#39888019">next</a><span>|</span><label class="collapse" for="c-39887860">[-]</label><label class="expand" for="c-39887860">[2 more]</label></div><br/><div class="children"><div class="content">JS does have a standard library and this proposal is about expanding it, so that’s good, right?</div><br/><div id="39888227" class="c"><input type="checkbox" id="c-39888227" checked=""/><div class="controls bullet"><span class="by">mrpepka</span><span>|</span><a href="#39887347">root</a><span>|</span><a href="#39887860">parent</a><span>|</span><a href="#39888019">next</a><span>|</span><label class="collapse" for="c-39888227">[-]</label><label class="expand" for="c-39888227">[1 more]</label></div><br/><div class="children"><div class="content">Unless it&#x27;s half-assed, clumsy and short-sighted, and we are stuck with it forever, because standard. Until one&#x27;s implementation becomes a standard thanks to the fact it wins as a library (as jQuery did), it should not be slyly forced into the language.</div><br/></div></div></div></div><div id="39888019" class="c"><input type="checkbox" id="c-39888019" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#39887347">parent</a><span>|</span><a href="#39887860">prev</a><span>|</span><a href="#39889625">next</a><span>|</span><label class="collapse" for="c-39888019">[-]</label><label class="expand" for="c-39888019">[1 more]</label></div><br/><div class="children"><div class="content">This is referenced in the proposal:<p>&gt; JavaScript has had a fairly minimal standard library, but a trend in TC39 has been to make JS more of a &quot;batteries-included&quot; language, with a high-quality, built-in set of functionality available<p>I think the description &quot;minimal&quot; is fairer than &quot;no&quot; wrt the standard library.</div><br/></div></div><div id="39889625" class="c"><input type="checkbox" id="c-39889625" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#39887347">parent</a><span>|</span><a href="#39888019">prev</a><span>|</span><a href="#39888308">next</a><span>|</span><label class="collapse" for="c-39889625">[-]</label><label class="expand" for="c-39889625">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s getting better.  I can build a medium-sized, modern TS&#x2F;React app with 12 dependencies.  A large enterprise app will be closer to 30-40 which is still a marked improvement over previous dep lists.</div><br/></div></div><div id="39888308" class="c"><input type="checkbox" id="c-39888308" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#39887347">parent</a><span>|</span><a href="#39889625">prev</a><span>|</span><label class="collapse" for="c-39888308">[-]</label><label class="expand" for="c-39888308">[1 more]</label></div><br/><div class="children"><div class="content">Strongly disagree - it&#x27;s trivial for a project to just add a small std-lib, or add lodash as a single dep, or just add it directly as source code.<p>JS projects exist in npm hell because people have been taught to use a library to save typing 10 characters. No standard library is going to fix. Because someone can just call in a new lib that just curries something in the standard lib with minor improvements like caching.</div><br/></div></div></div></div></div></div></div></div></div></body></html>