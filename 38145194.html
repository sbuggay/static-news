<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699174857834" as="style"/><link rel="stylesheet" href="styles.css?v=1699174857834"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://v5.chriskrycho.com/journal/how-to-do-a-typescript-conversion/">How to Do a TypeScript Conversion: an opinionated take on gradual conversions</a> <span class="domain">(<a href="https://v5.chriskrycho.com">v5.chriskrycho.com</a>)</span></div><div class="subtext"><span>chriskrycho</span> | <span>26 comments</span></div><br/><div><div id="38147167" class="c"><input type="checkbox" id="c-38147167" checked=""/><div class="controls bullet"><span class="by">bichiliad</span><span>|</span><a href="#38146952">next</a><span>|</span><label class="collapse" for="c-38147167">[-]</label><label class="expand" for="c-38147167">[1 more]</label></div><br/><div class="children"><div class="content">Bit of a shameless plug, but I wrote about how Etsy migrated to TypeScript a few years back. I agree with the author generally: TS strict mode is the way to go, and you may find yourself regretting the alternative, even if it sounds appealing. It takes a lot of work, but most of the effort ended up being:<p>1. writing types for the big, central libraries that everyone uses (and make them &quot;smart enough&quot; to infer as much as possible).<p>2. teaching everyone at the company a brand new language without them hating it, and without their team losing (much) velocity.<p><a href="https:&#x2F;&#x2F;codeascraft.com&#x2F;2021&#x2F;11&#x2F;08&#x2F;etsys-journey-to-typescript&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;codeascraft.com&#x2F;2021&#x2F;11&#x2F;08&#x2F;etsys-journey-to-typescri...</a></div><br/></div></div><div id="38146952" class="c"><input type="checkbox" id="c-38146952" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#38147167">prev</a><span>|</span><a href="#38147897">next</a><span>|</span><label class="collapse" for="c-38146952">[-]</label><label class="expand" for="c-38146952">[3 more]</label></div><br/><div class="children"><div class="content">I forget where I learned this. But this follows my refactoring legacy code principal.<p>Your new code (typescript in this case) should never reference the old code. Old code is the only thing that knows about new code.<p>The reason being is if your new code ever knows about your old code, your new code will carry on old code forever. You can never escape.<p>But if only old code knows about new code. Your new code is perfectly clean.<p>For this typescript conversion problem the nice thing is you can configure typescript to allowJs and your existing code can import compiled  typescript</div><br/><div id="38149107" class="c"><input type="checkbox" id="c-38149107" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38146952">parent</a><span>|</span><a href="#38149213">next</a><span>|</span><label class="collapse" for="c-38149107">[-]</label><label class="expand" for="c-38149107">[1 more]</label></div><br/><div class="children"><div class="content">Ooh that may have been the approach for my sister comment about circular deps. Thanks for the insight.<p>The solution for me would be make new libraries (without circle) and migrate old code to reference them. Instead of pulling old code into the new libraries with the circular deps coming with them</div><br/></div></div><div id="38149213" class="c"><input type="checkbox" id="c-38149213" checked=""/><div class="controls bullet"><span class="by">redbar0n</span><span>|</span><a href="#38146952">parent</a><span>|</span><a href="#38149107">prev</a><span>|</span><a href="#38147897">next</a><span>|</span><label class="collapse" for="c-38149213">[-]</label><label class="expand" for="c-38149213">[1 more]</label></div><br/><div class="children"><div class="content">But then you effectively won’t be able to build on what you already have?<p>Or, you’d have to continue expanding the old code using only the old language&#x2F;methods (here: JS instead of TS).</div><br/></div></div></div></div><div id="38147897" class="c"><input type="checkbox" id="c-38147897" checked=""/><div class="controls bullet"><span class="by">steve_taylor</span><span>|</span><a href="#38146952">prev</a><span>|</span><a href="#38147086">next</a><span>|</span><label class="collapse" for="c-38147897">[-]</label><label class="expand" for="c-38147897">[4 more]</label></div><br/><div class="children"><div class="content">I’m currently going through this at work and my experience even with smaller packages agrees with the author: After trying it the loose way and failing, I realised the best way to proceed is with maximum strictness from the start, converting the .js files to .ts in dependency order. When a file is converted from .js to .js, it’s almost guaranteed to be 100% converted. There are probably some edge cases where some refactoring necessitated by the conversion propagates to its already converted dependencies, but I would expect those to be minimal.</div><br/><div id="38148427" class="c"><input type="checkbox" id="c-38148427" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#38147897">parent</a><span>|</span><a href="#38149092">next</a><span>|</span><label class="collapse" for="c-38148427">[-]</label><label class="expand" for="c-38148427">[2 more]</label></div><br/><div class="children"><div class="content">I wish mypy was the same. I’ve tried to add typing for our fairly large (100k+ LOC) python libraries 3 or 4 times now and failed every time. One of the big issues is strict isn’t well supported, and some libraries and frameworks just do not play well with typing or have separate half baked stub libraries. I also firmly believe it should integrate seamlessly with e.g. pre-commit, and that hasn’t been my experience either, with special workarounds needed for the pre-commit hook to perform identically to running it in the locally installed venv.<p>So we just write new code with types by convention but have no actual linting or checks because it’s too hard to actually static typing to an existing repository.</div><br/><div id="38149154" class="c"><input type="checkbox" id="c-38149154" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38147897">root</a><span>|</span><a href="#38148427">parent</a><span>|</span><a href="#38149092">next</a><span>|</span><label class="collapse" for="c-38149154">[-]</label><label class="expand" for="c-38149154">[1 more]</label></div><br/><div class="children"><div class="content">In my experience the best way is:<p>1. Give up on pre-commit. It would be nice if it just worked, but it doesn&#x27;t. Just make a type checking script and run it as the first thing in CI.<p>2. Use Pyright, not Mypy. It&#x27;s much much better.<p>3. You can start with a very loose config and gradually make it stricter.<p>4. Make liberal use of `type: ignore` (and add TODOs to make it clear they&#x27;re not intentional).<p>5. You can also make an alias for Any and use that for types that you intend to figure out but haven&#x27;t yet.<p>Typing Python that wasn&#x27;t written with type hints in the first place is always going to be a complete nightmare though. People that write untyped Python tend to write it in highly dynamic ways and Python&#x27;s type hints often aren&#x27;t expressive enough to describe them (e.g. they only very recently added support for properly typing kwargs).</div><br/></div></div></div></div><div id="38149092" class="c"><input type="checkbox" id="c-38149092" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38147897">parent</a><span>|</span><a href="#38148427">prev</a><span>|</span><a href="#38147086">next</a><span>|</span><label class="collapse" for="c-38149092">[-]</label><label class="expand" for="c-38149092">[1 more]</label></div><br/><div class="children"><div class="content">Were there any circular dependencies in files?<p>While I have never done a js to ts conversation, trying to modularize a ts monolith into even some rudimentary packages was very difficult because of circular dependencies at the file level
(which is entirely possible).<p>Ended up giving up at the time because of cost&#x2F;benefit.</div><br/></div></div></div></div><div id="38147086" class="c"><input type="checkbox" id="c-38147086" checked=""/><div class="controls bullet"><span class="by">esprehn</span><span>|</span><a href="#38147897">prev</a><span>|</span><a href="#38146608">next</a><span>|</span><label class="collapse" for="c-38147086">[-]</label><label class="expand" for="c-38147086">[1 more]</label></div><br/><div class="children"><div class="content">Airbnb converted many millions of lines gradually using automation and wrote about it:<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;airbnb-engineering&#x2F;ts-migrate-a-tool-for-migrating-to-typescript-at-scale-cd23bfeb5cc" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;airbnb-engineering&#x2F;ts-migrate-a-tool-for-...</a><p>And also open sourced the tooling:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;airbnb&#x2F;ts-migrate">https:&#x2F;&#x2F;github.com&#x2F;airbnb&#x2F;ts-migrate</a></div><br/></div></div><div id="38146608" class="c"><input type="checkbox" id="c-38146608" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#38147086">prev</a><span>|</span><a href="#38147002">next</a><span>|</span><label class="collapse" for="c-38146608">[-]</label><label class="expand" for="c-38146608">[1 more]</label></div><br/><div class="children"><div class="content">Having done several Typescript migration on 100k+ line codebases, this rings entirely true for me.<p>An additional problem with doing partial migrations is that it leaves people in a position to just not fix the file they’re working on, since half converted files are the norm, and they have more important things to do.</div><br/></div></div><div id="38147002" class="c"><input type="checkbox" id="c-38147002" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#38146608">prev</a><span>|</span><a href="#38145438">next</a><span>|</span><label class="collapse" for="c-38147002">[-]</label><label class="expand" for="c-38147002">[4 more]</label></div><br/><div class="children"><div class="content">I think ChatGPT makes a huge difference here.<p>I routinely ask it to convert javascript to typescript.<p>It does a great job for the most part in seconds, leaving me to clean up where it got it wrong, and then fix the bugs that typescript exposed.<p>Surely this makes the task easier?<p>The only trap to avoid is it takes a conscious decision to do no other factoring than the typescript conversion. Don’t start “just fixing this other little thing while I’m here”.</div><br/><div id="38147181" class="c"><input type="checkbox" id="c-38147181" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#38147002">parent</a><span>|</span><a href="#38145438">next</a><span>|</span><label class="collapse" for="c-38147181">[-]</label><label class="expand" for="c-38147181">[3 more]</label></div><br/><div class="children"><div class="content">The real benefit of a statically typed language, especially one like TypeScript with a rich type system, is that you get to express your application in terms of the type system, and that you tend to think a lot more about your data structures.<p>You can, for example, make invalid states impossible to represent. This can catch a huge number of bugs and prevent some types of bugs from ever appearing.<p>If you&#x27;re using something like ChatGPT or some other automated system to add types to your code you have adopted a type system with receiving very little of the benefits. You end up with many of the drawbacks and only a little of the reward.</div><br/><div id="38149017" class="c"><input type="checkbox" id="c-38149017" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#38147002">root</a><span>|</span><a href="#38147181">parent</a><span>|</span><a href="#38147623">next</a><span>|</span><label class="collapse" for="c-38149017">[-]</label><label class="expand" for="c-38149017">[1 more]</label></div><br/><div class="children"><div class="content">You can do a refactoring later, or reap the benefits of typescript for all new code.<p>ChatGPT here doesn&#x27;t need to do a good job. You get value just by getting a codebase type-annotated.</div><br/></div></div><div id="38147623" class="c"><input type="checkbox" id="c-38147623" checked=""/><div class="controls bullet"><span class="by">joshxyz</span><span>|</span><a href="#38147002">root</a><span>|</span><a href="#38147181">parent</a><span>|</span><a href="#38149017">prev</a><span>|</span><a href="#38145438">next</a><span>|</span><label class="collapse" for="c-38147623">[-]</label><label class="expand" for="c-38147623">[1 more]</label></div><br/><div class="children"><div class="content">also when i edit one file, i can just run tsc --noEmit and i will see the list of affected files.<p>smoothest workflow ever.</div><br/></div></div></div></div></div></div><div id="38145438" class="c"><input type="checkbox" id="c-38145438" checked=""/><div class="controls bullet"><span class="by">BrianHenryIE</span><span>|</span><a href="#38147002">prev</a><span>|</span><a href="#38148609">next</a><span>|</span><label class="collapse" for="c-38145438">[-]</label><label class="expand" for="c-38145438">[5 more]</label></div><br/><div class="children"><div class="content">Is there any automated tool that can add types? I have Playwright E2E tests – it seems reasonable that the type each variable is used as could be recorded and the code annotated with that.</div><br/><div id="38145714" class="c"><input type="checkbox" id="c-38145714" checked=""/><div class="controls bullet"><span class="by">chriskrycho</span><span>|</span><a href="#38145438">parent</a><span>|</span><a href="#38147388">next</a><span>|</span><label class="collapse" for="c-38145714">[-]</label><label class="expand" for="c-38145714">[1 more]</label></div><br/><div class="children"><div class="content">The specific thing you’re asking for there is possible but non-trivial if you try to do it at runtime with tools like Playwright; more importantly it’s more overhead than you really need, and runtime types are often not exactly the same as what you want to describe an API, as you’ll be looking at various objects where you then have to decide how much of the prototype chain to walk and lots of other decisions like that. The way most tools in the space work is by leaning on TS’ own programmatic API. The two most interesting such tools I know of are AirBnB’s ts-migrate and LinkedIn’s RehearsalJS (full disclosure: I was loosely involved in design discussions for the matter, but did not contribute to it code-wise).</div><br/></div></div><div id="38147388" class="c"><input type="checkbox" id="c-38147388" checked=""/><div class="controls bullet"><span class="by">idontwantthis</span><span>|</span><a href="#38145438">parent</a><span>|</span><a href="#38145714">prev</a><span>|</span><a href="#38148609">next</a><span>|</span><label class="collapse" for="c-38147388">[-]</label><label class="expand" for="c-38147388">[3 more]</label></div><br/><div class="children"><div class="content">I wouldn’t recommend that. You want your types to have meaning for the business and you want to derive types from each other. It’s counterproductive to individually type every variable without context.</div><br/><div id="38149036" class="c"><input type="checkbox" id="c-38149036" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#38145438">root</a><span>|</span><a href="#38147388">parent</a><span>|</span><a href="#38148609">next</a><span>|</span><label class="collapse" for="c-38149036">[-]</label><label class="expand" for="c-38149036">[2 more]</label></div><br/><div class="children"><div class="content">In python at least, with strict-mode, Any is useless because you can do almost nothing to it. You can print, you can call &#x27;dir&#x27; &#x27;help&#x27; and other built-ins, and you can pass it to functions that accept Any.<p>That means that sprinkling any around your code isn&#x27;t a great way to silence errors.</div><br/><div id="38149289" class="c"><input type="checkbox" id="c-38149289" checked=""/><div class="controls bullet"><span class="by">idontwantthis</span><span>|</span><a href="#38145438">root</a><span>|</span><a href="#38149036">parent</a><span>|</span><a href="#38148609">next</a><span>|</span><label class="collapse" for="c-38149289">[-]</label><label class="expand" for="c-38149289">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know about Python, but for converting JS to TS you start with allow-implicit-any turned on and add types to your business objects as you go. Eventually your turn it off and fix what remains.</div><br/></div></div></div></div></div></div></div></div><div id="38148609" class="c"><input type="checkbox" id="c-38148609" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#38145438">prev</a><span>|</span><a href="#38146478">next</a><span>|</span><label class="collapse" for="c-38148609">[-]</label><label class="expand" for="c-38148609">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really like the idea of sprinking around &#x27;any&#x27; to silence noImplicitAny problems.<p>Either put in the correct type or leave it as is. Placing &#x27;any&#x27; in the code just fossilizes badness. Implicit any is just easier to accept, because when you finally have time to get serious you can disable it an write the correct types. You don&#x27;t have to hunt for &#x27;any&#x27; throughout the code.</div><br/><div id="38149050" class="c"><input type="checkbox" id="c-38149050" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#38148609">parent</a><span>|</span><a href="#38148895">next</a><span>|</span><label class="collapse" for="c-38149050">[-]</label><label class="expand" for="c-38149050">[1 more]</label></div><br/><div class="children"><div class="content">We’ve forbidden the use of any specifically because it’s unwieldy. You can develop using ‘unknown’ until you’re finally ready to type something correctly. It works like any, but it doesn’t allow you to reassign your type. In our opinion any is one of the legacies of JavaScript that you should never, ever, use.<p>It’s not like you can’t of course, it’s just that it doesn’t “encourage” your developers to type things as they build them, which will eventually lead to shortcuts for a lot of people (myself included). Even if it doesn’t, it’s usually better for people to think about their types earlier rather than later, especially the less senior they are, or at least that is our experience. It’s much easier to get new people onboard when they aren’t doing “bad habits” that they then have to fix before their code is allowed to pass through the production pipeline.</div><br/></div></div><div id="38148895" class="c"><input type="checkbox" id="c-38148895" checked=""/><div class="controls bullet"><span class="by">triyambakam</span><span>|</span><a href="#38148609">parent</a><span>|</span><a href="#38149050">prev</a><span>|</span><a href="#38146478">next</a><span>|</span><label class="collapse" for="c-38148895">[-]</label><label class="expand" for="c-38148895">[3 more]</label></div><br/><div class="children"><div class="content">I think it can make it easier to keep track of the work that needs to be done when explicit any (noImplicitAny) is used. I use them to monitor percentage of progress</div><br/><div id="38148928" class="c"><input type="checkbox" id="c-38148928" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#38148609">root</a><span>|</span><a href="#38148895">parent</a><span>|</span><a href="#38146478">next</a><span>|</span><label class="collapse" for="c-38148928">[-]</label><label class="expand" for="c-38148928">[2 more]</label></div><br/><div class="children"><div class="content">How do you measure how many any&#x27;s you got in your code?<p>How do you track where you have them? Just \bany\b regexp?</div><br/><div id="38148985" class="c"><input type="checkbox" id="c-38148985" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#38148609">root</a><span>|</span><a href="#38148928">parent</a><span>|</span><a href="#38146478">next</a><span>|</span><label class="collapse" for="c-38148985">[-]</label><label class="expand" for="c-38148985">[1 more]</label></div><br/><div class="children"><div class="content">typescript-eslint has a rule targeting explicit any annotations, and even several rules about assignments etc which are inferred as any. If you really want to include any in a strict-gradual migration strategy (I’m skeptical but could be persuaded depending on the baseline), you can use those rules as warnings or whatever makes the most sense. It’s definitely statically analyzable without a ton of bespoke effort.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>