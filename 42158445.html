<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731834066719" as="style"/><link rel="stylesheet" href="styles.css?v=1731834066719"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://logica.dev/">Logica – Declarative logic programming language for data</a> <span class="domain">(<a href="https://logica.dev">logica.dev</a>)</span></div><div class="subtext"><span>voat</span> | <span>46 comments</span></div><br/><div><div id="42162753" class="c"><input type="checkbox" id="c-42162753" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#42158630">next</a><span>|</span><label class="collapse" for="c-42162753">[-]</label><label class="expand" for="c-42162753">[2 more]</label></div><br/><div class="children"><div class="content">Its nice to see Logica has come on a bit. A year or two ago I tried to use this in production and it was very buggy.<p>The basic selling point is a compositional query language, so that over-time one may have a library of re-usable components. If anyone really has built such a library I&#x27;d love to know more about how it worked out in practice. It isn&#x27;t obvious to me how those decorators are supposed to compose and abstract on first look.<p>Its also not immediately obvious to me how complicated your library of SQL has to be for this approach to make sense. Say I had a collection of 100 moderately complex and correlated SQL queries, and I was to refactor them into Logica, in what circumstances would it yield a substantial benefit versus (1) doing nothing, (2) creating views or stored procedures, (3) using DBT &#x2F; M4 or some other preprocessor for generic abstraction.</div><br/><div id="42162912" class="c"><input type="checkbox" id="c-42162912" checked=""/><div class="controls bullet"><span class="by">thenaturalist</span><span>|</span><a href="#42162753">parent</a><span>|</span><a href="#42158630">next</a><span>|</span><label class="collapse" for="c-42162912">[-]</label><label class="expand" for="c-42162912">[1 more]</label></div><br/><div class="children"><div class="content">Never heard of M4 before and, lo and behold, of course HN has a discussion of it: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34159699">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34159699</a><p>The author discusses Logica vs. plain SQL vs POSIX.<p>I’d always start with dbt&#x2F; Sqlmesh.<p>The library you’re talking about exists: dbt packages.<p>Check out hub.getdbt.com and you’ll find dozens of public packages for standardizing sources, data formatting or all kinds of data ops.<p>You can use almost any query engine&#x2F; DB out there.<p>Then go for dbt power user in VS Code or use Paradime and you have first class IDE support.<p>I have no affiliation with any of the products, but from a practitioner perspective the gap between these technologies (and their ecosystems) is so large that the ranking of value for programming is as clear as they come.</div><br/></div></div></div></div><div id="42158630" class="c"><input type="checkbox" id="c-42158630" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42162753">prev</a><span>|</span><a href="#42158724">next</a><span>|</span><label class="collapse" for="c-42158630">[-]</label><label class="expand" for="c-42158630">[3 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Google is pushing the new language Logica to solve the major flaws in SQL</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29715957">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29715957</a> - Dec 2021 (1 comment)<p><i>Logica, a novel open-source logic programming language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26805121">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26805121</a> - April 2021 (98 comments)</div><br/><div id="42162766" class="c"><input type="checkbox" id="c-42162766" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#42158630">parent</a><span>|</span><a href="#42158724">next</a><span>|</span><label class="collapse" for="c-42162766">[-]</label><label class="expand" for="c-42162766">[2 more]</label></div><br/><div class="children"><div class="content">I may be misremembering but I think that at the time, Logica was the work of one developer who happened to be at Google. I&#x27;m not sure that there was an institutional push to use this language, nor that it has significant adoption at Google itself.</div><br/><div id="42162915" class="c"><input type="checkbox" id="c-42162915" checked=""/><div class="controls bullet"><span class="by">thenaturalist</span><span>|</span><a href="#42158630">root</a><span>|</span><a href="#42162766">parent</a><span>|</span><a href="#42158724">next</a><span>|</span><label class="collapse" for="c-42162915">[-]</label><label class="expand" for="c-42162915">[1 more]</label></div><br/><div class="children"><div class="content">This seems supported by the fact that the repo is not under a Google org and it has a single maintainer.</div><br/></div></div></div></div></div></div><div id="42158724" class="c"><input type="checkbox" id="c-42158724" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#42158630">prev</a><span>|</span><a href="#42159668">next</a><span>|</span><label class="collapse" for="c-42158724">[-]</label><label class="expand" for="c-42158724">[2 more]</label></div><br/><div class="children"><div class="content">If, like me, your first reaction is that this looks suspiciously like Datalog then you may be interested to learn that they indeed consider Logical to be &quot;in the the Datalog family&quot;.</div><br/><div id="42158818" class="c"><input type="checkbox" id="c-42158818" checked=""/><div class="controls bullet"><span class="by">jp57</span><span>|</span><a href="#42158724">parent</a><span>|</span><a href="#42159668">next</a><span>|</span><label class="collapse" for="c-42158818">[-]</label><label class="expand" for="c-42158818">[1 more]</label></div><br/><div class="children"><div class="content">I think Datalog should be thought of as &quot;in the logic programming family&quot;, so other data languages based on logic programming are likely to be similar.<p>And, of course the relational model of data is based on first-order logic, so one could say that SQL is a declarative logic programming language for data.</div><br/></div></div></div></div><div id="42159668" class="c"><input type="checkbox" id="c-42159668" checked=""/><div class="controls bullet"><span class="by">Agraillo</span><span>|</span><a href="#42158724">prev</a><span>|</span><a href="#42160024">next</a><span>|</span><label class="collapse" for="c-42159668">[-]</label><label class="expand" for="c-42159668">[1 more]</label></div><br/><div class="children"><div class="content">I think it is a good direction imho. Once being familiar with SQL I learned Prolog a little and similarities struck me. I wasn&#x27;t the first one sure, and there are others who summarized it better than me [1] (2010-2012):<p><i>Each can do the other, to a limited extent, but it becomes increasingly difficult with even small increases in complexity. For instance, you can do inferencing in SQL, but it is almost entirely manual in nature and not at all like the automatic forward-inferencing of Prolog. And yes, you can store data(facts) in Prolog, but it is not at all designed for the &quot;storage, retrieval, projection and reduction of Trillions of rows with thousands of simultaneous users&quot; that SQL is.</i><p>I even wanted to implement something like Logica at the moment, primarily trying to build a bridge through a virtual table in SQLite that would allow storing rules as mostly Prolog statements and having adapters to SQL storage when inference needs facts.<p>[1]: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;2119003" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;2119003</a></div><br/></div></div><div id="42160024" class="c"><input type="checkbox" id="c-42160024" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#42159668">prev</a><span>|</span><a href="#42159583">next</a><span>|</span><label class="collapse" for="c-42160024">[-]</label><label class="expand" for="c-42160024">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Composite(a * b) distinct :- ...<p>Wait, does Logica factorize the number passed to this predicate when unifying the number with a * b?<p>So when we call Composite (100) it automatically tries all a&#x27;s and b&#x27;s who give 100 when m7ltiplied<p>I&#x27;d be curious to see the SQL it transpiles to.</div><br/><div id="42162549" class="c"><input type="checkbox" id="c-42162549" checked=""/><div class="controls bullet"><span class="by">puzzledobserver</span><span>|</span><a href="#42160024">parent</a><span>|</span><a href="#42159583">next</a><span>|</span><label class="collapse" for="c-42162549">[-]</label><label class="expand" for="c-42162549">[1 more]</label></div><br/><div class="children"><div class="content">As someone who is intimately familiar with Datalog, but have not read much about Logica:<p>The way I read these rules is not from left-to-right but from right-to-left. In this case, it would say: Pick two numbers a &gt; 1 and b &gt; 1, their product a*b is a composite number. The solver starts with the facts that are immediately evident, and repeatedly apply these rules until no more conclusions are left to be drawn.<p>&quot;But there are infinitely many composite numbers,&quot; you&#x27;ll object. To which I will point out the limit of numbers &lt;= 30 in the line above. So the fixpoint is achieved in bounded time.<p>Datalog is usually defined using what is called set semantics. In other words, tuples are either derivable or not. A cursory inspection of the page seems to indicate that Logica works over bags &#x2F; multisets. The distinct keyword in the rule seems to have something to do with this, but I am not entirely sure.<p>This reading of Datalog rules is commonly called bottom-up evaluation. Assuming a finite universe, bottom-up and top-down evaluation are equivalent, although one approach might be computationally more expensive, as you point out.<p>In contrast to this, Prolog enforces a top-down evaluation approach, though the actual mechanics of evaluation are somewhat more complicated.</div><br/></div></div></div></div><div id="42159583" class="c"><input type="checkbox" id="c-42159583" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42160024">prev</a><span>|</span><a href="#42161142">next</a><span>|</span><label class="collapse" for="c-42159583">[-]</label><label class="expand" for="c-42159583">[3 more]</label></div><br/><div class="children"><div class="content">I find the appeals to composition tough to agree with.  For one, most queries begin as ad hoc questions.  And can usually be tossed after.  If they are needed for speed, it is the index structure that is more vital than the query structure.  That and knowing what materialized views have been made with implications on propagation delays.<p>Curious to hear battle stories from other teams using this.</div><br/><div id="42160902" class="c"><input type="checkbox" id="c-42160902" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42159583">parent</a><span>|</span><a href="#42161142">next</a><span>|</span><label class="collapse" for="c-42160902">[-]</label><label class="expand" for="c-42160902">[2 more]</label></div><br/><div class="children"><div class="content">Depends who your users are and what the context is.<p>Having been in quite a few data teams, and supported businesses using dashboards, a very large chunk of the time, the requests do align with the composable feature: people want “the data from that dashboard but with x&#x2F;y&#x2F;z constraints too” or “&lt;some well defined customer segment&gt; who did a|b in the last time, and then send that to me each week, and then break it down by something-else”. Scenarios that all benefit massively from being able to compose queries more easily, especially as things like “well defined customer segment” get evolved. Even ad-hoc queries would benefit because you’d be able to throw them together faster.<p>There’s a number of tools that proclaim to solve this, but solving this at the language level strikes me as a far better solution.</div><br/><div id="42161205" class="c"><input type="checkbox" id="c-42161205" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42159583">root</a><span>|</span><a href="#42160902">parent</a><span>|</span><a href="#42161142">next</a><span>|</span><label class="collapse" for="c-42161205">[-]</label><label class="expand" for="c-42161205">[1 more]</label></div><br/><div class="children"><div class="content">I supported a team at a large company looking at engagement metrics for emails.  Materialized views (edit: manually done) and daily aggregate jobs over indexed ranges was really the only viable solution.  You could tell the new members because they would invariably think to go to base data and build up aggregates they wanted, and not look directly for the aggregates.<p>That is so say, you have to define the jobs that do the aggregations, as well.  Knowing that you can&#x27;t just add historical records and have them immediately on current reports.<p>I welcome the idea that a support team could use better tools.  I suspect polyglot to win.  Ad hoc is hard to do better than SQL.  DDL is different, but largely difficult to beat SQL, still. And job description is a frontier of mistakes.</div><br/></div></div></div></div></div></div><div id="42161142" class="c"><input type="checkbox" id="c-42161142" checked=""/><div class="controls bullet"><span class="by">anorak27</span><span>|</span><a href="#42159583">prev</a><span>|</span><a href="#42161751">next</a><span>|</span><label class="collapse" for="c-42161142">[-]</label><label class="expand" for="c-42161142">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s  also Malloy[0] from Google that compiles into SQL<p>&gt; Malloy is an experimental language for describing data relationships and transformations.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;malloydata&#x2F;malloy">https:&#x2F;&#x2F;github.com&#x2F;malloydata&#x2F;malloy</a></div><br/></div></div><div id="42161751" class="c"><input type="checkbox" id="c-42161751" checked=""/><div class="controls bullet"><span class="by">transfire</span><span>|</span><a href="#42161142">prev</a><span>|</span><a href="#42159700">next</a><span>|</span><label class="collapse" for="c-42161751">[-]</label><label class="expand" for="c-42161751">[1 more]</label></div><br/><div class="children"><div class="content">Nice idea, but the syntax seems hacky.</div><br/></div></div><div id="42159700" class="c"><input type="checkbox" id="c-42159700" checked=""/><div class="controls bullet"><span class="by">foobarqux</span><span>|</span><a href="#42161751">prev</a><span>|</span><a href="#42159507">next</a><span>|</span><label class="collapse" for="c-42159700">[-]</label><label class="expand" for="c-42159700">[2 more]</label></div><br/><div class="children"><div class="content">There don&#x27;t seem to be any examples of how to connect to an existing (say sqlite) database even though it says you should try logica if &quot;you already have data in BigQuery, PostgreSQL or SQLite,&quot;. How do you connect to an existing sqlite database?</div><br/><div id="42161210" class="c"><input type="checkbox" id="c-42161210" checked=""/><div class="controls bullet"><span class="by">kukkeliskuu</span><span>|</span><a href="#42159700">parent</a><span>|</span><a href="#42159507">next</a><span>|</span><label class="collapse" for="c-42161210">[-]</label><label class="expand" for="c-42161210">[1 more]</label></div><br/><div class="children"><div class="content">I was turned off by this at first, but then tried it out. These are mistakes in the documentation. The tools just work with PostgreSQL and SQLite without any extra work.</div><br/></div></div></div></div><div id="42159507" class="c"><input type="checkbox" id="c-42159507" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42159700">prev</a><span>|</span><a href="#42162138">next</a><span>|</span><label class="collapse" for="c-42159507">[-]</label><label class="expand" for="c-42159507">[1 more]</label></div><br/><div class="children"><div class="content">If this is how you want to compile to SQL, why not invent your own DCG with Prolog proper?<p>It should be easy enough if you&#x27;re somewhat fluent in both languages, and has the perk of not being some Python thing at a megacorp famous for killing its projects.</div><br/></div></div><div id="42162138" class="c"><input type="checkbox" id="c-42162138" checked=""/><div class="controls bullet"><span class="by">cynicalsecurity</span><span>|</span><a href="#42159507">prev</a><span>|</span><a href="#42158755">next</a><span>|</span><label class="collapse" for="c-42162138">[-]</label><label class="expand" for="c-42162138">[1 more]</label></div><br/><div class="children"><div class="content">This is going to be a hell in production. Someone is going to write queries in this new language and then wonder why the produced MySQL queries in production take 45 minutes to execute.</div><br/></div></div><div id="42158755" class="c"><input type="checkbox" id="c-42158755" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#42162138">prev</a><span>|</span><a href="#42158900">next</a><span>|</span><label class="collapse" for="c-42158755">[-]</label><label class="expand" for="c-42158755">[1 more]</label></div><br/><div class="children"><div class="content">Only one active committer on github..</div><br/></div></div><div id="42158900" class="c"><input type="checkbox" id="c-42158900" checked=""/><div class="controls bullet"><span class="by">thenaturalist</span><span>|</span><a href="#42158755">prev</a><span>|</span><label class="collapse" for="c-42158900">[-]</label><label class="expand" for="c-42158900">[25 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to come off as too overconfident, but would be very hard pressed to see the value of this.<p>At face value, I shudder at the syntax.<p>Example from their tutorial:<p>EmployeeName(name:) :- Employee(name:);<p>Engineer(name:) :- Employee(name:, role: &quot;Engineer&quot;);<p>EngineersAndProductManagers(name:) :-
  Employee(name:, role:),
  role == &quot;Engineer&quot; || role == &quot;Product Manager&quot;;<p>vs. the equivalent SQL:<p>SELECT Employee.name AS name<p>FROM t_0_Employee AS Employee<p>WHERE (Employee.role = &quot;Engineer&quot; OR Employee.role = &quot;Product Manager&quot;);<p>SQL is much more concise, extremely easy to follow.<p>No weird OOP-style class instantiation for something as simple as just getting the name.<p>As already noted in the 2021 discussion, what&#x27;s actually the killer though is adoption and, three years later, ecosystem.<p>SQL for analytics has come an extremely long way with the ecosystem that was ignited by dbt.<p>There is so much better tooling today when it comes to testing, modelling, running in memory with tools like DuckDB or Ibis, Apache Iceberg.<p>There is value to abstracting on top of SQL, but it does very much seem to me like this is not it.</div><br/><div id="42159072" class="c"><input type="checkbox" id="c-42159072" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42158900">parent</a><span>|</span><a href="#42159873">next</a><span>|</span><label class="collapse" for="c-42159072">[-]</label><label class="expand" for="c-42159072">[19 more]</label></div><br/><div class="children"><div class="content">Logica is in the Datalog&#x2F;Prolog&#x2F;Logic family of programming languages. It&#x27;s very familiar to anyone who knows how to read it. None of this has anything to do with OOP at all and you will heavily mislead yourself if you try to map any of that thinking onto it. (Beyond that, and not specific to Logica or SQL in any way -- comparing two 3-line programs to draw conclusions is effectively meaningless. You have to actually write programs bigger than that to see the whole picture.)<p>Datalog is not really a query language, actually. But it is relational, like SQL, so it lets you express relations between &quot;facts&quot; (the rows) inside tables. But it is more general, because it also lets you express relations between <i>tables themselves</i> (e.g. this &quot;table&quot; is built from the relationship between two smaller tables), and it does so without requiring extra special case semantics like VIEWs.<p>Because of this, it&#x27;s easy to write small fragments of Datalog programs, and then stick it together with other fragments, without a lot of planning ahead of time, meaning as a language it is very compositional. This is one of the primary reasons why many people are interested in it as a SQL alternative; aside from your typical weird SQL quirks that are avoided with better language design (which are annoying, but not really the big picture.)</div><br/><div id="42159145" class="c"><input type="checkbox" id="c-42159145" checked=""/><div class="controls bullet"><span class="by">thenaturalist</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159072">parent</a><span>|</span><a href="#42159449">next</a><span>|</span><label class="collapse" for="c-42159145">[-]</label><label class="expand" for="c-42159145">[10 more]</label></div><br/><div class="children"><div class="content">&gt; but it is more general, because it also lets you express relations between tables themselves (e.g. this &quot;table&quot; is built from the relationship between two smaller tables), and it does so without requiring extra special case semantics like VIEWs.<p>If I understand you correctly, you can easily get the same with ephemeral models in dbt or CTEs generally?<p>&gt; Because of this, it&#x27;s easy to write small fragments of Datalog programs, and then stick it together with other fragments, without a lot of planning ahead of time, meaning as a language it is very compositional.<p>This can be a benefit in some cases, I guess, but how can you guarantee correctness with flexibility involved?<p>With SQL, I get either table or column level lineage with all modern tools, can audit each upstream output before going into a downstream input. 
In dbt I have macros which I can reuse everywhere.<p>It&#x27;s very compositional while at the same time perfectly documented and testable at runtime.<p>Could you share a more specific example or scenario where you have seen Datalog&#x2F; Logica outperform a modern SQL setup?<p>Generally curious.<p>I am not at all familiar with the Logica&#x2F;Datalog&#x2F;Prolog world.</div><br/><div id="42159431" class="c"><input type="checkbox" id="c-42159431" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159145">parent</a><span>|</span><a href="#42159326">next</a><span>|</span><label class="collapse" for="c-42159431">[-]</label><label class="expand" for="c-42159431">[3 more]</label></div><br/><div class="children"><div class="content">Here is a proof that you can translate non-recursive datalog into relational algebra and vice versa: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;mangle&#x2F;blob&#x2F;main&#x2F;docs&#x2F;spec_explain_relational_algebra.md">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;mangle&#x2F;blob&#x2F;main&#x2F;docs&#x2F;spec_explain...</a><p>Since Logica is translated to SQL it should benefit from all the query optimistic goodness that went into the SQL engine that runs the resulting queries.<p>I personally see the disadvantages of SQL in that it is not really modular, you cannot have libraries, tests and such.<p>Disclosure: I wrote Mangle (the link goes to the Mangle repo), another datalog, different way of extending, no SQL translation but an engine library.</div><br/><div id="42160523" class="c"><input type="checkbox" id="c-42160523" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159431">parent</a><span>|</span><a href="#42159326">next</a><span>|</span><label class="collapse" for="c-42160523">[-]</label><label class="expand" for="c-42160523">[2 more]</label></div><br/><div class="children"><div class="content">Mangle looks very interesting, thanks for the share. In particular I love your GRPC demo, because it shows a prototype of something I&#x27;ve been thinking about for a long time: what if we did GraphQL, but with Datalog! Maybe we could call it LogiQL :)<p>In particular many people talk a lot about concerns like optimizations across GraphQL plans and how they are expected to behave on underlying tables, but this is something that I think has seen a lot of research in the Datalog realm. And to top it off, even ignoring that, Datalog just feels much more natural to write and read after a bit of practice, I think. (Obviously you need to be in the pure fragment of datalog without recursion, but even then it might be feasible to add those features with termination criteria even if it&#x27;s just &quot;decrement an internal counter and if it hits zero throw a big error&quot;)<p>What do you think the plans for the Rust implementation will be? That&#x27;s probably the most likely place I&#x27;d use it, as I don&#x27;t really use Go that much.</div><br/><div id="42161877" class="c"><input type="checkbox" id="c-42161877" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42160523">parent</a><span>|</span><a href="#42159326">next</a><span>|</span><label class="collapse" for="c-42161877">[-]</label><label class="expand" for="c-42161877">[1 more]</label></div><br/><div class="children"><div class="content">The Mangle repo has the beginnings of a Rust implementation but it will take some time before it is usable. The go implementation is also still being improved, but I think real DB work with persistent data will happen only in Rust. Bindings to other host languages would also use the Rust implementation. There are no big challenges here it is just work and takes time.<p>The combination of top-down and bottom up logic programming is interesting, especially when one can move work between pre computation and query time.<p>I like that optimizing queries in datalog can be discussed like optimization of programming language but of course the biggest gains in DB come from join order and making use of indices. There is a tension here between declarative and having some control or hints for execution. I haven&#x27;t yet figured out how one should go about it, and also how to help programmers combine top-down and bottom-up computation. Work in progress! :-)</div><br/></div></div></div></div></div></div><div id="42159326" class="c"><input type="checkbox" id="c-42159326" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159145">parent</a><span>|</span><a href="#42159431">prev</a><span>|</span><a href="#42160072">next</a><span>|</span><label class="collapse" for="c-42159326">[-]</label><label class="expand" for="c-42159326">[3 more]</label></div><br/><div class="children"><div class="content">Prolog et al is a real brain buster. As in it will break your spirits and build you back up better. 
I remember in college I was able to build a binary tree with 3 lines of code. And once you write the insert, the delete, search, and others just magically appear.<p>It also frames your thinking about defining what you want rather than how to get it.<p>If you really want to see the power of these kinds of languages look up Einstein&#x27;s puzzle solved with prolog. The solution just magically comes out by entering the constraints of the puzzle.</div><br/><div id="42159681" class="c"><input type="checkbox" id="c-42159681" checked=""/><div class="controls bullet"><span class="by">surgical_fire</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159326">parent</a><span>|</span><a href="#42159604">next</a><span>|</span><label class="collapse" for="c-42159681">[-]</label><label class="expand" for="c-42159681">[1 more]</label></div><br/><div class="children"><div class="content">I had to use Prolog in college, and while I never saw it in the wild - I at least never stumbled upon a scenario where prolog was the answer - I really enjoyed how I had to change how I looked at a problem in order to solve it in prolog.</div><br/></div></div><div id="42159604" class="c"><input type="checkbox" id="c-42159604" checked=""/><div class="controls bullet"><span class="by">rytis</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159326">parent</a><span>|</span><a href="#42159681">prev</a><span>|</span><a href="#42160072">next</a><span>|</span><label class="collapse" for="c-42159604">[-]</label><label class="expand" for="c-42159604">[1 more]</label></div><br/><div class="children"><div class="content">I suppose something like this: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;8270393" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;8270393</a>
?</div><br/></div></div></div></div><div id="42160072" class="c"><input type="checkbox" id="c-42160072" checked=""/><div class="controls bullet"><span class="by">jyounker</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159145">parent</a><span>|</span><a href="#42159326">prev</a><span>|</span><a href="#42159555">next</a><span>|</span><label class="collapse" for="c-42160072">[-]</label><label class="expand" for="c-42160072">[1 more]</label></div><br/><div class="children"><div class="content">The covid analysis seems like a pretty good example: <a href="https:&#x2F;&#x2F;colab.research.google.com&#x2F;github&#x2F;EvgSkv&#x2F;logica&#x2F;blob&#x2F;main&#x2F;examples&#x2F;Logica_example_Covid_Analysis.ipynb" rel="nofollow">https:&#x2F;&#x2F;colab.research.google.com&#x2F;github&#x2F;EvgSkv&#x2F;logica&#x2F;blob&#x2F;...</a><p>A good exercise might be converting it to the corresponding SQL and comparing the two for clarity.</div><br/></div></div><div id="42159555" class="c"><input type="checkbox" id="c-42159555" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159145">parent</a><span>|</span><a href="#42160072">prev</a><span>|</span><a href="#42159449">next</a><span>|</span><label class="collapse" for="c-42159555">[-]</label><label class="expand" for="c-42159555">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If I understand you correctly, you can easily get the same with ephemeral models in dbt or CTEs generally?<p>You can bolt on any number of 3rd party features or extensions to get some extra thing, that goes for any tool in the world. The point of something like Datalog is that it can express a similar class of relational programs that SQL can, but with a smaller set of core ideas. &quot;Do more with less.&quot;<p>&gt; I guess, but how can you guarantee correctness with flexibility involved?<p>How do you guarantee the correctness of anything? How do you know any SQL query you write is correct? Well, as the author, you typically have a good idea. The point of being compositional is that it&#x27;s easier to stick together arbitrary things defined in Datalog, and have the resulting thing work smoothly.<p>Going back to the previous example, you can define any two &quot;tables&quot; and then just derive a third &quot;table&quot; from these, using language features that you already use -- to define relationships between rows. Datalog can define relations between rules (tables) and between facts (rows), all with a single syntactic&#x2F;semantic concept. While SQL can only by default express relations between rows. Therefore, raw SQL is kind of &quot;the bottom half&quot; of Datalog, and to get the upper half you need features like CTEs, VIEWs, etc, and apply them appropriately. You need more concepts to cover both the bottom and top half; Datalog covers them with one concept. Datalog also makes it easy to express things like e.g. queries on graph structures, but again, you don&#x27;t need extra features like CTEs for this to happen.<p>There are of course lots of tricky bits (e.g. optimization) but the general idea works very well.<p>&gt; Could you share a more specific example or scenario where you have seen Datalog&#x2F; Logica outperform a modern SQL setup?<p>Again, Datalog is not about SQL. It&#x27;s a logic programming language. You need to actually spend time doing logic programming with something like Prolog or Datalog to appreciate the class of things it can do well. It just so happens Datalog is also good for expressing relational programs, which is what you do in SQL.<p>Most of the times I&#x27;m doing logic programming I&#x27;m actually writing programs, not database queries. Trying to do things like analyze programs to learn facts about them (Souffle Datalog, &quot;can this function ever call this other function in any circumstance?&quot;) or something like a declarative program as a decision procedure. For example, I have a prototype Prolog program sitting around that scans a big code repository, figures out all 3rd party dependencies and their licenses, then tries to work out whether they are compatible.<p>It&#x27;s a bit like Lisp, in the sense that it&#x27;s a core formulation of a set of ideas that you aren&#x27;t going to magically adopt without doing it yourself a bunch. I could show you a bunch of logic programs, but without experience all the core ideas are going to be lost and the comparison would be meaningless.<p>For the record, I don&#x27;t use Logica with SQL, but not because I wouldn&#x27;t want to. It seems like a good approach. I would use Datalog over SQL happily for my own projects if I could. The reasons I don&#x27;t use Logica for instance are more technical than anything -- it is a Python library, and I don&#x27;t use Python.</div><br/><div id="42160577" class="c"><input type="checkbox" id="c-42160577" checked=""/><div class="controls bullet"><span class="by">kthejoker2</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159555">parent</a><span>|</span><a href="#42159449">next</a><span>|</span><label class="collapse" for="c-42160577">[-]</label><label class="expand" for="c-42160577">[1 more]</label></div><br/><div class="children"><div class="content">CTEs aren&#x27;t really an &quot;extra&quot; feature they just are a composable reusable subquery. This just adds the benefit of storing CTEs as function calls aka table valued functions (TVFs) ... also not really an &quot;extra&quot; feature.<p>The main advantage to any non SQL language is its ability to more efficiently express recursion (graph &#x2F; hierarchical queries) and dynamic expressions like transposition and pivots.<p>You can do those in SQL it&#x27;s just clunky.</div><br/></div></div></div></div></div></div><div id="42159449" class="c"><input type="checkbox" id="c-42159449" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159072">parent</a><span>|</span><a href="#42159145">prev</a><span>|</span><a href="#42159858">next</a><span>|</span><label class="collapse" for="c-42159449">[-]</label><label class="expand" for="c-42159449">[3 more]</label></div><br/><div class="children"><div class="content">Right, so that&#x27;s what they claim, that you&#x27;ll get small reusable pieces.<p>But:
&quot;Logica compiles to SQL&quot;.<p>With the caveat that it only kind of does, since it seems constrained to three database engines, probably the one they optimise the output to perform well on, one where it usually doesn&#x27;t matter and one that&#x27;s kind of mid performance wise anyway.<p>In light of that quote it&#x27;s also weird that they mention that they are able to run the SQL they compiled to &quot;in interactive time&quot; on a rather large dataset, which they supposedly already could with SQL.<p>Arguably I&#x27;m not very good with Datalog and have mostly used Prolog, but to me it doesn&#x27;t look much like a Datalog. Predicates seems to be variadic with named parameters, making variables implicit at the call site so to understand a complex predicate you need to hop away and look at how the composite predicates are defined to understand what they return. Maybe I misunderstand how it works, but at first glance that doesn&#x27;t look particularly attractive to me.<p>Can you put arithmetic in the head of clauses in Datalog proper? As far as I can remember, that&#x27;s not part of the language. To me it isn&#x27;t obvious what this is supposed to do in this query language.</div><br/><div id="42159693" class="c"><input type="checkbox" id="c-42159693" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159449">parent</a><span>|</span><a href="#42159858">next</a><span>|</span><label class="collapse" for="c-42159693">[-]</label><label class="expand" for="c-42159693">[2 more]</label></div><br/><div class="children"><div class="content">For the record, I don&#x27;t use Logica myself so I&#x27;m not familiar with every design decision or feature -- I&#x27;m not a Python programmer. I&#x27;m speaking about Datalog in general.<p>&gt; making variables implicit at the call site<p>What example are you looking at? The NewsData example for instance seems pretty understandable to me. It seems like for any given predicate you can either take the implicit name of the column or you can map it onto a different name e.g. `date: date_num` for the underlying column on gdelt-bq.gdeltv2.gkg.<p>Really it just seems like a way to make the grammar less complicated; the `name: foo` syntax is their way of expressing &#x27;AS&#x27; clauses and `name:` is just a shorthand for `name: name`<p>&gt; In light of that quote it&#x27;s also weird that they mention that they are able to run the SQL they compiled to &quot;in interactive time&quot; on a rather large dataset, which they supposedly already could with SQL.<p>The query in question is run on BigQuery (which IIRC was the original and only target database for Logica), and in that setup you might do a query over 4TB of data but get a response in milliseconds due to partitioning, column compression, parallel aggregation, etc. This is actually really common for many queries. So, in that kind of setup the translation layer needs to be fast so it doesn&#x27;t spoil the benefit for the end user. I think the statement makes complete sense, tbh. (This also probably explains why they wrote it in Python, so you could use it in Jupyter notebooks hooked up to BigQuery.)</div><br/><div id="42162228" class="c"><input type="checkbox" id="c-42162228" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159693">parent</a><span>|</span><a href="#42159858">next</a><span>|</span><label class="collapse" for="c-42162228">[-]</label><label class="expand" for="c-42162228">[1 more]</label></div><br/><div class="children"><div class="content">They define a NewsData&#x2F;5, but use a NewsData&#x2F;2.<p>Are you aware of any SQL transpilers that spend so much time transpiling that you get irritated? I&#x27;m not.</div><br/></div></div></div></div></div></div><div id="42159858" class="c"><input type="checkbox" id="c-42159858" checked=""/><div class="controls bullet"><span class="by">joe_the_user</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159072">parent</a><span>|</span><a href="#42159449">prev</a><span>|</span><a href="#42159873">next</a><span>|</span><label class="collapse" for="c-42159858">[-]</label><label class="expand" for="c-42159858">[5 more]</label></div><br/><div class="children"><div class="content"><i>It&#x27;s very familiar to anyone who knows how to read it.</i><p>&quot;Anyone who know the system can easily learn it&quot; he said with a sniff.<p>Yes, the similarity to Prolog lets you draw on a vast pool of Prolog programmers out there.<p>I mean, I studied a variety of esoteric languages in college and they were interesting (I can&#x27;t remember if we got to prolog tbh but I know 1st logic pretty well and that&#x27;s related). When I was thrown into a job with SQL, it&#x27;s English language syntax made things really easy. I feel confident that knowing SQL wouldn&#x27;t oppositely make learning Prolog easy (I remember Scala later and not being able to deal with it&#x27;s opaque verbosity easily).<p>Basically, SQL syntax makes easy things easy. This gets underestimated a lot, indeed people seem to have contempt for it. I think that&#x27;s a serious mistake.</div><br/><div id="42159988" class="c"><input type="checkbox" id="c-42159988" checked=""/><div class="controls bullet"><span class="by">jyounker</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159858">parent</a><span>|</span><a href="#42160091">next</a><span>|</span><label class="collapse" for="c-42159988">[-]</label><label class="expand" for="c-42159988">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Basically, SQL syntax makes easy things easy. This gets underestimated a lot, indeed people seem to have contempt for it. I think that&#x27;s a serious mistake.<p>The flip side of that is SQL makes hard things nearly impossible.<p>SQL doesn&#x27;t have facilities for abstraction, and it doesn&#x27;t compose, and this has consequences that I deal with daily.<p>The lack of abstract facilities makes it hard to construct complicated queries, it makes it hard to debug them, and it makes it hard refactor them.<p>Instead of writing more complicated SQL queries, developers lean on the host languages to coordinate SQL calls, using the host language&#x27;s abstraction facilities to cover for SQL&#x27;s inadequacies.</div><br/><div id="42160103" class="c"><input type="checkbox" id="c-42160103" checked=""/><div class="controls bullet"><span class="by">joe_the_user</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159988">parent</a><span>|</span><a href="#42160091">next</a><span>|</span><label class="collapse" for="c-42160103">[-]</label><label class="expand" for="c-42160103">[2 more]</label></div><br/><div class="children"><div class="content"><i>The flip side of that is SQL makes hard things nearly impossible.</i><p>What about SQL <i>syntax</i> makes the hard things possible? I get that the actual language SQL is broken in all sorts of ways. But I don&#x27;t see any reason to replace it with some opaque from get-go.<p>I mean, what stops you from defining, say adjectives and using those for rough modularity.<p>Say<p><pre><code>    EXPENSIVE(T) means T.price &gt; 0;
    Select name FROM books WHERE EXPENSIVE(books); 
</code></pre>
Seems understandable.</div><br/><div id="42162433" class="c"><input type="checkbox" id="c-42162433" checked=""/><div class="controls bullet"><span class="by">geocar</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42160103">parent</a><span>|</span><a href="#42160091">next</a><span>|</span><label class="collapse" for="c-42162433">[-]</label><label class="expand" for="c-42162433">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that just WITH?<p><pre><code>    WITH expensive AS (SELECT * FROM books WHERE price &gt; 100)
    SELECT name FROM expensive</code></pre></div><br/></div></div></div></div></div></div><div id="42160091" class="c"><input type="checkbox" id="c-42160091" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159858">parent</a><span>|</span><a href="#42159988">prev</a><span>|</span><a href="#42159873">next</a><span>|</span><label class="collapse" for="c-42160091">[-]</label><label class="expand" for="c-42160091">[1 more]</label></div><br/><div class="children"><div class="content">I mean, yes, that&#x27;s sort of how linguistics works in general? You can&#x27;t just look at a language with completely different orthography or semantic concepts and expect to be able to reliably map it onto your pre-existing language with no effort. That&#x27;s sort of the whole reason translation is a generally difficult problem.<p>I don&#x27;t really get this kind of complaint in general I&#x27;m afraid. Many people can read and write, say, Hangul just fine -- and at the same time we don&#x27;t expect random English speakers with no familiarity will be able to understand Korean conversations, or any syllabic writing systems in general. Programming language families&#x2F;classes like logic programming are really no different.<p>&gt; it&#x27;s English language syntax made things really easy<p>That&#x27;s just called &quot;being familiar with English&quot; more than any inherent property of SQL or English.</div><br/></div></div></div></div></div></div><div id="42159873" class="c"><input type="checkbox" id="c-42159873" checked=""/><div class="controls bullet"><span class="by">jyounker</span><span>|</span><a href="#42158900">parent</a><span>|</span><a href="#42159072">prev</a><span>|</span><a href="#42162215">next</a><span>|</span><label class="collapse" for="c-42159873">[-]</label><label class="expand" for="c-42159873">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No weird OOP-style class instantiation for something as simple as just getting the name.<p>I understand the desire to no waste your time, but I think you&#x27;re missing the big idea. Those statements define logical relations. There&#x27;s nothing related to classes or OOP.<p>Using those building blocks you can do everything that you can with SQL. No need for having clauses. No need for group by clauses. No need for subquery clauses. No need for special join syntax. Just what you see above.<p>And you can keep going with it. SQL quickly runs into the limitations of the language. Using the syntax above (which is basically Prolog) you can construct arbitrarily large software systems which are still understandable.<p>If you&#x27;re really interested in improving as a developer, then I suggest that spend a day or two playing with a logic programming system of some sort. It&#x27;s a completely different way of thinking about programming, and it will give you mental tools that you will never pick up any other way.</div><br/></div></div><div id="42162215" class="c"><input type="checkbox" id="c-42162215" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#42158900">parent</a><span>|</span><a href="#42159873">prev</a><span>|</span><a href="#42158997">next</a><span>|</span><label class="collapse" for="c-42162215">[-]</label><label class="expand" for="c-42162215">[1 more]</label></div><br/><div class="children"><div class="content">Have a look at PRQL [1] for analytical queries. That&#x27;s exactly what it&#x27;s designed for. Disclaimer: I&#x27;m a contributor.<p>That said. I like Logica and Datalog. For me the main use case is &quot;recursive&quot; queries as they are simpler to express that way. PRQL has made some progress there with the loop operator but it could still be better. If you have any ideas for improvement, please reach out!<p>1: <a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;prql-lang.org&#x2F;</a></div><br/></div></div><div id="42158997" class="c"><input type="checkbox" id="c-42158997" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#42158900">parent</a><span>|</span><a href="#42162215">prev</a><span>|</span><label class="collapse" for="c-42158997">[-]</label><label class="expand" for="c-42158997">[3 more]</label></div><br/><div class="children"><div class="content">The syntax is Prolog-like, so people in the field are familiar
with it.</div><br/><div id="42159153" class="c"><input type="checkbox" id="c-42159153" checked=""/><div class="controls bullet"><span class="by">thenaturalist</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42158997">parent</a><span>|</span><label class="collapse" for="c-42159153">[-]</label><label class="expand" for="c-42159153">[2 more]</label></div><br/><div class="children"><div class="content">Which field would that be?<p>I.e. I understand now that it&#x27;s seemingly about more than simple querying, so me coming very much from an analytics&#x2F; data crunching background am wondering what a use case would look like where this is arguably superior to SQL.</div><br/><div id="42159739" class="c"><input type="checkbox" id="c-42159739" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#42158900">root</a><span>|</span><a href="#42159153">parent</a><span>|</span><label class="collapse" for="c-42159739">[-]</label><label class="expand" for="c-42159739">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Which field would that be?</i><p>Database theory papers and books have used Prolog&#x2F;Datalog-like syntax throughout the years, such as those by Serge Abiteboul, just to give a single example of a researcher and prolific author over the decades.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>