<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729242071367" as="style"/><link rel="stylesheet" href="styles.css?v=1729242071367"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://boston.conman.org/2024/10/13.1">A benchmark of three different floating point packages for the 6809</a> <span class="domain">(<a href="https://boston.conman.org">boston.conman.org</a>)</span></div><div class="subtext"><span>ingve</span> | <span>8 comments</span></div><br/><div><div id="41877001" class="c"><input type="checkbox" id="c-41877001" checked=""/><div class="controls bullet"><span class="by">jcmeyrignac</span><span>|</span><a href="#41875816">next</a><span>|</span><label class="collapse" for="c-41877001">[-]</label><label class="expand" for="c-41877001">[2 more]</label></div><br/><div class="children"><div class="content">Here are a few other 6809 FP libraries:
<a href="https:&#x2F;&#x2F;gitlab.com&#x2F;dfffffff&#x2F;fpo9" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;dfffffff&#x2F;fpo9</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;spotlessmind1975&#x2F;ugbasic&#x2F;blob&#x2F;main&#x2F;ugbc&#x2F;src&#x2F;hw&#x2F;6809&#x2F;fp_routines.asm">https:&#x2F;&#x2F;github.com&#x2F;spotlessmind1975&#x2F;ugbasic&#x2F;blob&#x2F;main&#x2F;ugbc&#x2F;s...</a><p>If I remember correctly, the ROM of MO6&#x2F;TO7 contain also a fast implementation, but I was not able to find a disassembly.</div><br/><div id="41877089" class="c"><input type="checkbox" id="c-41877089" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41877001">parent</a><span>|</span><a href="#41875816">next</a><span>|</span><label class="collapse" for="c-41877089">[-]</label><label class="expand" for="c-41877089">[1 more]</label></div><br/><div class="children"><div class="content">The first link is to the MC6839, which is covered already in the blog post.  The second link is the Lennart Beschop&#x27;s floating point routines, which is what the post is about.<p>&gt; ROM of MO6&#x2F;TO7<p>Do you mean the MC6839 here?  Or something else?</div><br/></div></div></div></div><div id="41875816" class="c"><input type="checkbox" id="c-41875816" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#41877001">prev</a><span>|</span><label class="collapse" for="c-41875816">[-]</label><label class="expand" for="c-41875816">[5 more]</label></div><br/><div class="children"><div class="content">If you can find a copy Apple&#x27;s SANE for the 6502  test it. It was faster than hardware fpus. That was according to a friend who was an FP geek back when.</div><br/><div id="41876676" class="c"><input type="checkbox" id="c-41876676" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#41875816">parent</a><span>|</span><a href="#41876206">next</a><span>|</span><label class="collapse" for="c-41876676">[-]</label><label class="expand" for="c-41876676">[2 more]</label></div><br/><div class="children"><div class="content">That is a completely ridiculous suggestion.<p>The hardware FPU on the 1954 IBM 704 took 60 µs for addition and 300 µs for multiplication.<p>That is likely to be the slowest hardware FPU ever. The Intel 8087, for example, was about six times faster. I expect the optional FPUs on things like early PDP-11s to also be faster.<p>AppleSoft BASIC has quick&amp;dirty FP operations and uses about 1000 µs for an add and 3000 µs for a multiply.<p>SANE is IEEE-compliant and has to be careful to get 0.5 ULP, round correctly, set flags etc and therefore I would expect it to be slower than AppleSoft. But I don&#x27;t know how much slower. I never used it on a 6502.</div><br/><div id="41877433" class="c"><input type="checkbox" id="c-41877433" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41875816">root</a><span>|</span><a href="#41876676">parent</a><span>|</span><a href="#41876206">next</a><span>|</span><label class="collapse" for="c-41877433">[-]</label><label class="expand" for="c-41877433">[1 more]</label></div><br/><div class="children"><div class="content">Moreover, Intel 8080 and its derivatives, like Z80, where frequently much faster for floating-point operantions than 6502 derivatives, depending on their relative clock frequencies and on the speed of the memory.<p>The main reason was that 8080&#x2F;Z80 could do much faster FP multiplications (which were extremely slow on 8-bit microprocessors, typically requiring many milliseconds or even tens of milliseconds per FP64 multiplication), because those could be implemented by using 16-bit additions and 16-bit shifts and accumulating partial results in registers (i.e. by using the 16-bit index operations and registers, not the 8-bit accumulator operations). 6502 had only 8-bit operations and too few registers to keep partial results in them, so the partial results had to be stored in memory.<p>Nevertheless, the great advantage of 8080&#x2F;Z80 in computational speed was not always realized, because a lot of the 8080&#x2F;Z80 programs used naive multiplication procedures that were an order of magnitude or more slower than the optimized multiplication.<p>Even in the Microsoft BASIC and in the run-time library of the Microsoft FORTRAN compiler for CP&#x2F;M the floating-point operations did not have an optimum implementation, so after reverse-engineering them and replacing the core algorithms I could speed up a lot my programs in MS CP&#x2F;M FORTRAN and BASIC.</div><br/></div></div></div></div><div id="41876206" class="c"><input type="checkbox" id="c-41876206" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41875816">parent</a><span>|</span><a href="#41876676">prev</a><span>|</span><label class="collapse" for="c-41876206">[-]</label><label class="expand" for="c-41876206">[2 more]</label></div><br/><div class="children"><div class="content">First off, the assembler is for a Motorola 6809, which is <i>not</i> a 6502.  Second, one benchmark result I found [1] showed it being a bit slower than some alternatives.<p>[1] <a href="https:&#x2F;&#x2F;www.callapple.org&#x2F;programming&#x2F;sane-programming-on-the-apple-ii&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.callapple.org&#x2F;programming&#x2F;sane-programming-on-th...</a></div><br/><div id="41877377" class="c"><input type="checkbox" id="c-41877377" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41875816">root</a><span>|</span><a href="#41876206">parent</a><span>|</span><label class="collapse" for="c-41877377">[-]</label><label class="expand" for="c-41877377">[1 more]</label></div><br/><div class="children"><div class="content">Motorola MC6809 was much faster for floating-point computations than any other 8-bit microprocessor, because it not only had 16-bit additions and shifts, but it also had 8 bit by 8 bit multiplications. No other 8-bit microprocessor had multiplication instructions.<p>MC6809 had a very beautiful ISA in comparison with all other 8-bit microprocessors, but it was launched too late, in 1979, when there already were the 16-bit microprocessors Intel 8086 and Motorola MC68000.<p>Motorola had made the mistake of developing simultaneously two incompatible instruction sets, MC6809 intended for cheap CPUs and MC68000 intended for expensive CPUs. They should have developed a single architecture, with a stripped-down version of MC68000 for cheap CPUs, like they have done later with MC68008, but only when it was too late, because the cheap version of Intel 8086, i.e. Intel 8088, had already won the IBM PC.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>