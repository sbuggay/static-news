<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708419661424" as="style"/><link rel="stylesheet" href="styles.css?v=1708419661424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://emilymstark.com/2024/02/09/e2ee-on-the-web-is-the-web-really-that-bad.html">E2EE on the web: is the web that bad?</a> <span class="domain">(<a href="https://emilymstark.com">emilymstark.com</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>50 comments</span></div><br/><div><div id="39436941" class="c"><input type="checkbox" id="c-39436941" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#39436754">next</a><span>|</span><label class="collapse" for="c-39436941">[-]</label><label class="expand" for="c-39436941">[8 more]</label></div><br/><div class="children"><div class="content">Desktop applications are uniquely auditable by security professionals in a way that web sites inherently aren&#x27;t. It&#x27;s very, very hard to hide &quot;send this unencrypted message to evilserver.com&quot; in a desktop app in the same way it&#x27;s possible to in a web app (because the web app could serve the evilserver.com code only to the targeted subject under surveillance and send only good code to the rest of the world). And mobile apps have the explicit review pipeline you mention. So web apps need some sort of &quot;frozen, trustable, third-party reviewed&quot; version to be able to match the security of desktop apps.</div><br/><div id="39437998" class="c"><input type="checkbox" id="c-39437998" checked=""/><div class="controls bullet"><span class="by">jordoh</span><span>|</span><a href="#39436941">parent</a><span>|</span><a href="#39438671">next</a><span>|</span><label class="collapse" for="c-39437998">[-]</label><label class="expand" for="c-39437998">[1 more]</label></div><br/><div class="children"><div class="content">Code delivery happens in desktop apps too, when you download the binary from evilsite.com, or when you receive an auto-update, they can give you a different binary than the security professionals reviewed. That&#x27;s assuming the professionals even reviewed the binary, and not the source evilsite.com claimed it was built from.<p>It would also be difficult for said professionals to detect IP-(range)-specific backdoors (with as much obfuscation as you like; only send on Tuesdays; encrypted using a string constant elsewhere in the binary), in App Store delivered binaries that are harder to vary per downloader.<p>Some web apps - [Cryptee](<a href="https:&#x2F;&#x2F;crypt.ee&#x2F;threat-model" rel="nofollow">https:&#x2F;&#x2F;crypt.ee&#x2F;threat-model</a>) is a notable example - address this with a &quot;trust on first use&quot; approach, that makes any change to the (web) code require approval, but that&#x27;s in the same realm as a desktop app, where you&#x27;ve trusted it on the first download, and trust it to have actually followed through on that promise.</div><br/></div></div><div id="39438671" class="c"><input type="checkbox" id="c-39438671" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#39436941">parent</a><span>|</span><a href="#39437998">prev</a><span>|</span><a href="#39438462">next</a><span>|</span><label class="collapse" for="c-39438671">[-]</label><label class="expand" for="c-39438671">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not really fair in the day and age of Electron apps. If the Electron app downloads JS code to run in its embedded browser &#x2F; NodeJS runtime, then it&#x27;s subject to similar attacks. Hypothetically, so too could any traditional desktop binary download and execute code. An audit will only reveal that such capability exists, not whether or not it is being abused.<p>If that&#x27;s genuinely part of your threat model, then you simply must run on-premises code only, backed up by robust network controls that allowlist very specific parts of the Internet.</div><br/><div id="39438758" class="c"><input type="checkbox" id="c-39438758" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#39436941">root</a><span>|</span><a href="#39438671">parent</a><span>|</span><a href="#39438462">next</a><span>|</span><label class="collapse" for="c-39438758">[-]</label><label class="expand" for="c-39438758">[1 more]</label></div><br/><div class="children"><div class="content">Indeed Microsoft Teams once contained a bug where specially-formed HTML messages could trigger arbitrary code execution when received.<p>Any platform where the security model is two steps:<p>1. Check if the message contains any code. If so, reject it.
2. Scan the message for code and eval() it.<p>is extremely susceptible to code execution bugs.</div><br/></div></div></div></div><div id="39438462" class="c"><input type="checkbox" id="c-39438462" checked=""/><div class="controls bullet"><span class="by">jwells89</span><span>|</span><a href="#39436941">parent</a><span>|</span><a href="#39438671">prev</a><span>|</span><a href="#39437433">next</a><span>|</span><label class="collapse" for="c-39438462">[-]</label><label class="expand" for="c-39438462">[1 more]</label></div><br/><div class="children"><div class="content">There’s more tooling for non-professionals to keep a leash on desktop app network usage, too, like LuLu[0] and OpenSnitch[1]. There’s ways around these tools as there is with anything else, but it raises the bar a bit since the user is unlikely to let random programs connect to servers they have no good reason to connect to, once made aware that the attempts are being made.<p>It’s not as reasonable for the layman to do this on the web, since it’s par for the course for a single visit to a big commercial website to kick off connections to dozens of unintelligible domains, and to sometimes break if these connections aren’t allowed. OS-level tools like LuLu aren’t of much help here because significant limitations on the servers a browser can connect to essentially break the browser, which leaves you with extensions like NoScript and uMatrix which for the explained reasons aren’t as straightforward to operate.<p>[0]: <a href="https:&#x2F;&#x2F;objective-see.org&#x2F;products&#x2F;lulu.html" rel="nofollow">https:&#x2F;&#x2F;objective-see.org&#x2F;products&#x2F;lulu.html</a>
[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;evilsocket&#x2F;opensnitch">https:&#x2F;&#x2F;github.com&#x2F;evilsocket&#x2F;opensnitch</a></div><br/></div></div><div id="39437433" class="c"><input type="checkbox" id="c-39437433" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#39436941">parent</a><span>|</span><a href="#39438462">prev</a><span>|</span><a href="#39437675">next</a><span>|</span><label class="collapse" for="c-39437433">[-]</label><label class="expand" for="c-39437433">[2 more]</label></div><br/><div class="children"><div class="content">You just described Manifest v3 Chrome extensions hosted on the Chrome Web Store. No remotely loaded code, frozen assets, third party review.</div><br/><div id="39438308" class="c"><input type="checkbox" id="c-39438308" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39436941">root</a><span>|</span><a href="#39437433">parent</a><span>|</span><a href="#39437675">next</a><span>|</span><label class="collapse" for="c-39438308">[-]</label><label class="expand" for="c-39438308">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, the threat model for Chrome extensions is not the same as that of arbitrary websites. You can probably reasonably accomplish some things in extensions that are untenable on web pages.</div><br/></div></div></div></div><div id="39437675" class="c"><input type="checkbox" id="c-39437675" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#39436941">parent</a><span>|</span><a href="#39437433">prev</a><span>|</span><a href="#39436754">next</a><span>|</span><label class="collapse" for="c-39437675">[-]</label><label class="expand" for="c-39437675">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Desktop applications are uniquely auditable by security professionals in a way that web sites inherently aren&#x27;t.<p>Except for the desktop applications that simply pop up a web view to load the web site from the internet.<p>(Looks at Discord, Slack, Zoom)<p>Not all Electron apps are this way, for example LM Studio stores its interface locally and therefore doesn&#x27;t rely on loading it from a remote server at application start time. But a surprising number of them are.</div><br/></div></div></div></div><div id="39436754" class="c"><input type="checkbox" id="c-39436754" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39436941">prev</a><span>|</span><a href="#39436512">next</a><span>|</span><label class="collapse" for="c-39436754">[-]</label><label class="expand" for="c-39436754">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Often, security experts argue that the web isn’t suited for E2EE applications because of the vast attack surface for code injection – abusable by the developer or by an external attacker. For many web applications, a web browser receives and runs code from a zillion servers, retrieved over a zillion TLS connections.<p>This feels like the wrong argument. I don&#x27;t think this has anything to do with suitability of end to end encryption. It is easily worked around with e.g. subresource integrity, or rolling your own signing scheme.<p>The real problem with end to end security on the web is you don&#x27;t have a trusted base. You have to bootstrap your application with some sort of trusted base. On a website you are redownloading the website everytime.<p>The entire point of end to end encryption is that the service provider should not be able to intercept messages. The service provider is the attacker. This is impossible to prevent if you redownload the app everytime you open the page†. You have to build trust from some starting point. If you have some trusted bootstrap code you can build from there with signatures, but you can&#x27;t build trust out of thin air running code directly supplied by the party you are trying to protect against.<p>The problem isn&#x27;t the zillion TLS servers. The problem is the first TLS server, which in the e2ee threat model we have to assume is evil.<p>† i guess service workers can extend that to once every 24 hours. Still not super compelling.</div><br/><div id="39437860" class="c"><input type="checkbox" id="c-39437860" checked=""/><div class="controls bullet"><span class="by">ahazred8ta</span><span>|</span><a href="#39436754">parent</a><span>|</span><a href="#39436879">next</a><span>|</span><label class="collapse" for="c-39437860">[-]</label><label class="expand" for="c-39437860">[5 more]</label></div><br/><div class="children"><div class="content">Subresource integrity hash checks are supposed to let you pin a particular version of a webpage &#x2F; webapp, but the W3C managed to not let SRI work on bookmarks. If you could bookmark a specific version of a url with SRI, that would make so many problems go away.<p>You can have a personal startpage saved on your device&#x27;s local storage, with an SRI link to a webapp, but that takes a bit of fiddling.<p>E2EE: <a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;query=e2ee&amp;sort=byDate&amp;type=story" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;qu...</a></div><br/><div id="39438769" class="c"><input type="checkbox" id="c-39438769" checked=""/><div class="controls bullet"><span class="by">jezek2</span><span>|</span><a href="#39436754">root</a><span>|</span><a href="#39437860">parent</a><span>|</span><a href="#39437946">next</a><span>|</span><label class="collapse" for="c-39438769">[-]</label><label class="expand" for="c-39438769">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps bookmarklets could make that possible? It could generate loading of the resources using the SRIs hardcoded directly in the JS contained in the bookmark itself.<p>Or even simpler, use the data: URI for the initial page as a bookmark.</div><br/></div></div><div id="39437946" class="c"><input type="checkbox" id="c-39437946" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39436754">root</a><span>|</span><a href="#39437860">parent</a><span>|</span><a href="#39438769">prev</a><span>|</span><a href="#39436879">next</a><span>|</span><label class="collapse" for="c-39437946">[-]</label><label class="expand" for="c-39437946">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Subresource integrity hash checks are supposed to let you pin a particular version of a webpage &#x2F; webapp<p>I dont think that is true. Its called <i>sub</i>resource integrity not resource integrity. I don&#x27;t think pinning a specific top level resource was ever part of the goal.<p>&gt; but the W3C managed to not let SRI work on bookmarks. If you could bookmark a specific version of a url with SRI, that would make so many problems go away.<p>I don&#x27;t really think this makes sense in the context of how web browsers currently work. Are you proposing that users just unilateraly pin versions of websites?</div><br/><div id="39438651" class="c"><input type="checkbox" id="c-39438651" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#39436754">root</a><span>|</span><a href="#39437946">parent</a><span>|</span><a href="#39436879">next</a><span>|</span><label class="collapse" for="c-39438651">[-]</label><label class="expand" for="c-39438651">[2 more]</label></div><br/><div class="children"><div class="content">The idea is that users could bookmark reviewed and vetted versions of websites &#x2F; apps.<p>It won&#x27;t work &quot;unilaterally&quot; for obvious reasons but there are lots of p2p, e2e, security and crypto type apps where creators would love to be able to reduce the degree to which infra like CDNs and hosting need to be trusted.<p>The &quot;page level SRI&quot; mechanism wouldn&#x27;t even need to work that well (eg limited support for web features). If you could get a trusted &quot;bootstrapper&quot; to work with no software installation then you could do the rest of the trust chain in js &quot;userland&quot;.</div><br/><div id="39439199" class="c"><input type="checkbox" id="c-39439199" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39436754">root</a><span>|</span><a href="#39438651">parent</a><span>|</span><a href="#39436879">next</a><span>|</span><label class="collapse" for="c-39439199">[-]</label><label class="expand" for="c-39439199">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It won&#x27;t work &quot;unilaterally&quot; for obvious reasons but there are lots of p2p, e2e, security and crypto type apps where creators would love to be able to reduce the degree to which infra like CDNs and hosting need to be trusted.<p>If we are moving out of the http&#x2F;web space into some sort of distributed protocol, just use magnet links, problem solved. Or some equivalant hash based content-addresable scheme. (How applicable depends on what space we are talking about)</div><br/></div></div></div></div></div></div></div></div><div id="39436879" class="c"><input type="checkbox" id="c-39436879" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#39436754">parent</a><span>|</span><a href="#39437860">prev</a><span>|</span><a href="#39438828">next</a><span>|</span><label class="collapse" for="c-39436879">[-]</label><label class="expand" for="c-39436879">[2 more]</label></div><br/><div class="children"><div class="content">This is where IPFS can shine, as (if you don&#x27;t use the very-optional IPNS) you are browsing directly to a fixed hash that your browser could (it doesn&#x27;t, but this is trivially fixable) verify; it thereby exists in a space between pre-downloaded and web-requested software (with different tradeoffs, some positive and some negative; but like, all three of these options have negatives).</div><br/><div id="39437376" class="c"><input type="checkbox" id="c-39437376" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39436754">root</a><span>|</span><a href="#39436879">parent</a><span>|</span><a href="#39438828">next</a><span>|</span><label class="collapse" for="c-39437376">[-]</label><label class="expand" for="c-39437376">[1 more]</label></div><br/><div class="children"><div class="content">Yes, i agree, this is one of the most interesting aspects of content-addressable networks like IPFS.</div><br/></div></div></div></div><div id="39438828" class="c"><input type="checkbox" id="c-39438828" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#39436754">parent</a><span>|</span><a href="#39436879">prev</a><span>|</span><a href="#39436512">next</a><span>|</span><label class="collapse" for="c-39438828">[-]</label><label class="expand" for="c-39438828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is easily worked around with e.g. subresource integrity, or rolling your own signing scheme.<p>Or, you know, <i>not loading resources from third parties in your secure web application</i>.</div><br/></div></div></div></div><div id="39436512" class="c"><input type="checkbox" id="c-39436512" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#39436754">prev</a><span>|</span><a href="#39437097">next</a><span>|</span><label class="collapse" for="c-39436512">[-]</label><label class="expand" for="c-39436512">[5 more]</label></div><br/><div class="children"><div class="content">Yes, <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39315585">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39315585</a><p>&quot; Why Bloat Is Still Software’s Biggest Vulnerability
&gt; A 2024 plea for lean software &quot;<p>The problem involves so many dependencies that it is impossible for an individual and maybe even megacorporations to fully audit the code base and prove the software behaves as intended.  Everything these days is best effort.<p>We _need_ a native interface that portable software can target, to at LEAST get to the level where &#x27;If you trust the OS, then the rest of the software is known to behave as expected&#x27; is a statement that can be made to have a plausibly secure environment for End to End Encryption on anything.<p>This __has__ to ship, in a DEFAULT install of Windows AND OSX AND mobile computing devices (so iOS and Android too).  It absolutely has to be a baseline target, otherwise we&#x27;ll never get past shipping the browser, again, out of band as yet another thing that must have it&#x27;s entire monstrosity of libraries updated for every security patch.</div><br/><div id="39436867" class="c"><input type="checkbox" id="c-39436867" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39436512">parent</a><span>|</span><a href="#39436700">next</a><span>|</span><label class="collapse" for="c-39436867">[-]</label><label class="expand" for="c-39436867">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The problem involves so many dependencies that it is impossible for an individual and maybe even megacorporations to fully audit the code base and prove the software behaves as intended. Everything these days is best effort.<p>Everything has always been best effort, there was no point in time that formally verified software was mainstream. Even attempts at that have turned out broken later on (e.g. KRACK attack on wpa2) so its not a pancea.<p>&gt; We _need_ a native interface that portable software can target, to at LEAST get to the level where &#x27;If you trust the OS, then the rest of the software is known to behave as expected&#x27; is a statement that can be made to have a plausibly secure environment for End to End Encryption on anything.<p>This doesn&#x27;t really make sense unless this portable interface contains the entire App. Like how do you imagine such a system would work? What would such an interface do or contain that would bring this dream even remotely close to reality?</div><br/><div id="39437419" class="c"><input type="checkbox" id="c-39437419" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#39436512">root</a><span>|</span><a href="#39436867">parent</a><span>|</span><a href="#39436700">next</a><span>|</span><label class="collapse" for="c-39437419">[-]</label><label class="expand" for="c-39437419">[2 more]</label></div><br/><div class="children"><div class="content">&gt; there was no point in time that formally verified software was mainstream. Even attempts at that have turned out broken later on (e.g. KRACK attack on wpa2)<p>In what ways was wpa2 an attempt at formally verified software? The KRACK attack exploited an issue in the standard itself. Were notable implementations of it formally verified? Was the spec itself verified in some flawed ways? I read the Wikipedia page and couldn&#x27;t find anything relevant.</div><br/><div id="39437487" class="c"><input type="checkbox" id="c-39437487" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39436512">root</a><span>|</span><a href="#39437419">parent</a><span>|</span><a href="#39436700">next</a><span>|</span><label class="collapse" for="c-39437487">[-]</label><label class="expand" for="c-39437487">[1 more]</label></div><br/><div class="children"><div class="content">See section 6.4 of <a href="https:&#x2F;&#x2F;papers.mathyvanhoef.com&#x2F;ccs2017.pdf" rel="nofollow">https:&#x2F;&#x2F;papers.mathyvanhoef.com&#x2F;ccs2017.pdf</a><p>Essentially the spec was formally verified, but it turned out that the formal definition of &quot;secure&quot; they used wasn&#x27;t sufficient. Formal verification only works if you properly define all the security relavent properties that need to be proven, and the process of defining them can have errors itself.</div><br/></div></div></div></div></div></div><div id="39436700" class="c"><input type="checkbox" id="c-39436700" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#39436512">parent</a><span>|</span><a href="#39436867">prev</a><span>|</span><a href="#39437097">next</a><span>|</span><label class="collapse" for="c-39436700">[-]</label><label class="expand" for="c-39436700">[1 more]</label></div><br/><div class="children"><div class="content">It shouldn&#x27;t even be as hard as it appears.  If the business logic is designed as a generic library made to be portable to different platforms then you can call into it from a native application built using whatever the native UI toolkits and conventions for that platform are.<p>Libtorrent is a shining example of this architecture.  It runs everywhere, even on mobile platforms.  Rust being more popular with makes this even more accessible than it used to be.  There&#x27;s even libraries like PyO3 to make writing bindings to other languages easier.</div><br/></div></div></div></div><div id="39437097" class="c"><input type="checkbox" id="c-39437097" checked=""/><div class="controls bullet"><span class="by">mortallywounded</span><span>|</span><a href="#39436512">prev</a><span>|</span><a href="#39437000">next</a><span>|</span><label class="collapse" for="c-39437097">[-]</label><label class="expand" for="c-39437097">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the main issue with e2ee on the web the fact that you&#x27;re battling on three fronts?<p>1. You need to securely get the code and resources to the browser. A state level attacker can make this very hard.<p>2. You need to securely run the code on the client which may or may not include code from n-third parties.<p>3. You need to securely handle data and logic from the client which may or may not involve n-third parties.<p>Phew. That&#x27;s a heck of a challenge.</div><br/><div id="39437413" class="c"><input type="checkbox" id="c-39437413" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39437097">parent</a><span>|</span><a href="#39437146">next</a><span>|</span><label class="collapse" for="c-39437413">[-]</label><label class="expand" for="c-39437413">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You need to securely get the code and resources to the browser. A state level attacker can make this very hard.<p>Even worse, you need to securely get code to the browser without trusting yourself. The E2EE model assumes that you (the service provider&#x2F;app maker) will turn evil at some future point.<p>Code distribution is hard enough if you can trust yourself. Its basically impossible if the threat you are protecting against is your future self.</div><br/></div></div><div id="39437146" class="c"><input type="checkbox" id="c-39437146" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39437097">parent</a><span>|</span><a href="#39437413">prev</a><span>|</span><a href="#39437436">next</a><span>|</span><label class="collapse" for="c-39437146">[-]</label><label class="expand" for="c-39437146">[1 more]</label></div><br/><div class="children"><div class="content">An amateur attacker can make getting cryptographic code securely to a browser very hard. :)</div><br/></div></div><div id="39437436" class="c"><input type="checkbox" id="c-39437436" checked=""/><div class="controls bullet"><span class="by">ta2234234242</span><span>|</span><a href="#39437097">parent</a><span>|</span><a href="#39437146">prev</a><span>|</span><a href="#39437000">next</a><span>|</span><label class="collapse" for="c-39437436">[-]</label><label class="expand" for="c-39437436">[1 more]</label></div><br/><div class="children"><div class="content">4.  You need to not trust the cert authorities installed in a system.</div><br/></div></div></div></div><div id="39437000" class="c"><input type="checkbox" id="c-39437000" checked=""/><div class="controls bullet"><span class="by">buu700</span><span>|</span><a href="#39437097">prev</a><span>|</span><a href="#39437233">next</a><span>|</span><label class="collapse" for="c-39437000">[-]</label><label class="expand" for="c-39437000">[5 more]</label></div><br/><div class="children"><div class="content"><i>If we do care about the delta in security model between the web and other platforms, then we could build some kind of code bundling and signing mechanism for web applications, perhaps with some kind of transparency layer on top to make the code publicly auditable and make it harder to target specific users with malicious code. A bundling&#x2F;signing&#x2F;transparency solution for the web could probably be built out of some of a collection of mechanisms that already exist or have at least been explored. Related ideas include Subresource Integrity, Isolated Web Apps, Signed Exchanges and Web Packaging, Meta’s Code Verify extension, and source code and supply chain transparency proposals.</i><p>Incidentally, I&#x27;ve actually just recently developed a solution to this exact problem: <a href="https:&#x2F;&#x2F;www.websign.app" rel="nofollow">https:&#x2F;&#x2F;www.websign.app</a>.<p>WebSign started a while back as an internal framework used by the Cyph E2EE messenger (<a href="https:&#x2F;&#x2F;www.cyph.com" rel="nofollow">https:&#x2F;&#x2F;www.cyph.com</a>), and @eganist and I gave a talk that covered part of the TOFU architecture at Black Hat and DEF CON. Now there&#x27;s a static web hosting service built around it for others to use, which takes care of bundling and code signing during deployment.<p>If anyone here has a use case for it, we&#x27;re looking for pilot customers now. Just shoot me an email at ryan@cyph.com.</div><br/><div id="39438078" class="c"><input type="checkbox" id="c-39438078" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#39437000">parent</a><span>|</span><a href="#39437233">next</a><span>|</span><label class="collapse" for="c-39438078">[-]</label><label class="expand" for="c-39438078">[4 more]</label></div><br/><div class="children"><div class="content">I thought it was vaguely interesting until where you write how blockchain-based DAO &quot;will enhance the scalability and transparency&quot; of your infrastructure...</div><br/><div id="39438101" class="c"><input type="checkbox" id="c-39438101" checked=""/><div class="controls bullet"><span class="by">buu700</span><span>|</span><a href="#39437000">root</a><span>|</span><a href="#39438078">parent</a><span>|</span><a href="#39437233">next</a><span>|</span><label class="collapse" for="c-39438101">[-]</label><label class="expand" for="c-39438101">[3 more]</label></div><br/><div class="children"><div class="content">Appreciate the feedback on the messaging. I can see how mentioning that risks painting the whole thing with a brush that won&#x27;t appeal to everyone.<p>To be clear, what you quoted is an idea that has been requested by some potential customers — essentially decentralized and distributed code review&#x2F;signing. It&#x27;s not a feature of the current product, and likely won&#x27;t be until someone pays for it, although I do think it would be cool.<p>Either way, it&#x27;s not something that would detract from the fundamental value proposition. It would be an optional add-on.</div><br/><div id="39438166" class="c"><input type="checkbox" id="c-39438166" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#39437000">root</a><span>|</span><a href="#39438101">parent</a><span>|</span><a href="#39437233">next</a><span>|</span><label class="collapse" for="c-39438166">[-]</label><label class="expand" for="c-39438166">[2 more]</label></div><br/><div class="children"><div class="content">I see. Yeah, it made me think you&#x27;re  making an interesting service just to let someone to compromise it if they collect enough tokens. I guess more specific phrasing wouldn&#x27;t hurt for skeptics like me</div><br/><div id="39438180" class="c"><input type="checkbox" id="c-39438180" checked=""/><div class="controls bullet"><span class="by">buu700</span><span>|</span><a href="#39437000">root</a><span>|</span><a href="#39438166">parent</a><span>|</span><a href="#39437233">next</a><span>|</span><label class="collapse" for="c-39438180">[-]</label><label class="expand" for="c-39438180">[1 more]</label></div><br/><div class="children"><div class="content">Ahh, yeah, definitely nothing like that. I&#x27;ll make a note to clarify the language there in the next website update.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39437233" class="c"><input type="checkbox" id="c-39437233" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39437000">prev</a><span>|</span><a href="#39436970">next</a><span>|</span><label class="collapse" for="c-39437233">[-]</label><label class="expand" for="c-39437233">[1 more]</label></div><br/><div class="children"><div class="content">I think Code Verify (mentioned in the article) is the right approach <a href="https:&#x2F;&#x2F;engineering.fb.com&#x2F;2022&#x2F;03&#x2F;10&#x2F;security&#x2F;code-verify&#x2F;" rel="nofollow">https:&#x2F;&#x2F;engineering.fb.com&#x2F;2022&#x2F;03&#x2F;10&#x2F;security&#x2F;code-verify&#x2F;</a><p>Although it&#x27;s all open source, if you install the published version of their extension, iiuc, it will only work with certain facebook sites out of the box. There should be an easier way to enroll new sites - I&#x27;m thinking TOFU with fingerprinting.</div><br/></div></div><div id="39436970" class="c"><input type="checkbox" id="c-39436970" checked=""/><div class="controls bullet"><span class="by">shitter</span><span>|</span><a href="#39437233">prev</a><span>|</span><a href="#39436669">next</a><span>|</span><label class="collapse" for="c-39436970">[-]</label><label class="expand" for="c-39436970">[5 more]</label></div><br/><div class="children"><div class="content">It seems like using a browser extension instead of a website gets you most of the way there:<p>- Extensions are signed with a developer key<p>- You can be pretty sure any code changes pushed out to one user are pushed out to everyone<p>- You benefit from the Chrome Web Store review process (or whatever equivalent Apple and Mozilla do)<p>- Extensions are permissioned and sandboxed</div><br/><div id="39436986" class="c"><input type="checkbox" id="c-39436986" checked=""/><div class="controls bullet"><span class="by">Andrex</span><span>|</span><a href="#39436970">parent</a><span>|</span><a href="#39436669">next</a><span>|</span><label class="collapse" for="c-39436986">[-]</label><label class="expand" for="c-39436986">[4 more]</label></div><br/><div class="children"><div class="content">More relevant to the article, Chrome extensions can&#x27;t just &quot;open a zillion connections.&quot; Included scripts must be unminified and external scripts are strictly declared ahead of time with more secure default permissions.<p>I like that idea.</div><br/><div id="39437021" class="c"><input type="checkbox" id="c-39437021" checked=""/><div class="controls bullet"><span class="by">shitter</span><span>|</span><a href="#39436970">root</a><span>|</span><a href="#39436986">parent</a><span>|</span><a href="#39436669">next</a><span>|</span><label class="collapse" for="c-39437021">[-]</label><label class="expand" for="c-39437021">[3 more]</label></div><br/><div class="children"><div class="content">Indeed, Manifest V3 disallows remotely hosted scripts entirely: <a href="https:&#x2F;&#x2F;developer.chrome.com&#x2F;docs&#x2F;extensions&#x2F;develop&#x2F;migrate&#x2F;improve-security" rel="nofollow">https:&#x2F;&#x2F;developer.chrome.com&#x2F;docs&#x2F;extensions&#x2F;develop&#x2F;migrate...</a></div><br/><div id="39438448" class="c"><input type="checkbox" id="c-39438448" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#39436970">root</a><span>|</span><a href="#39437021">parent</a><span>|</span><a href="#39438441">prev</a><span>|</span><a href="#39436669">next</a><span>|</span><label class="collapse" for="c-39438448">[-]</label><label class="expand" for="c-39438448">[1 more]</label></div><br/><div class="children"><div class="content">I mean, kinda.  It&#x27;s little more than a consumer-grade padlock or maybe &quot;do not cross&quot; tape - there are countless ways around it, it mostly just encourages normal cases to be more static (which is a good thing! but very far from <i>a security tool</i>)</div><br/></div></div></div></div></div></div></div></div><div id="39436669" class="c"><input type="checkbox" id="c-39436669" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#39436970">prev</a><span>|</span><a href="#39436338">next</a><span>|</span><label class="collapse" for="c-39436669">[-]</label><label class="expand" for="c-39436669">[4 more]</label></div><br/><div class="children"><div class="content">It seems like &quot;code from a zillion servers, retrieved over a zillion TLS connections&quot; can be solved by serving the app from a single origin. You have to vendor your dependencies but that&#x27;s probably wise anyway.</div><br/><div id="39436826" class="c"><input type="checkbox" id="c-39436826" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#39436669">parent</a><span>|</span><a href="#39436338">next</a><span>|</span><label class="collapse" for="c-39436826">[-]</label><label class="expand" for="c-39436826">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the whole <i>point</i> of using E2EE on Company A&#x27;s messenger app that you <i>distrust Company A?</i><p>After all, they could easily serve up slightly different js when you log into their website; for all practical purposes it would be undetectable.<p>Being reasonably confident that you&#x27;re running the same code as everyone else seems pretty important to me - and that&#x27;s not how the web works.</div><br/><div id="39437007" class="c"><input type="checkbox" id="c-39437007" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#39436669">root</a><span>|</span><a href="#39436826">parent</a><span>|</span><a href="#39436338">next</a><span>|</span><label class="collapse" for="c-39437007">[-]</label><label class="expand" for="c-39437007">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the ideal but browsers don&#x27;t support that today. Trusting the client but not the server is weaker but still better than nothing.</div><br/><div id="39437432" class="c"><input type="checkbox" id="c-39437432" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39436669">root</a><span>|</span><a href="#39437007">parent</a><span>|</span><a href="#39436338">next</a><span>|</span><label class="collapse" for="c-39437432">[-]</label><label class="expand" for="c-39437432">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s the ideal but browsers don&#x27;t support that today.<p>Which is why people say E2EE is unsuitable to the browser.<p>Sure there exists other threats and other security issues in the browser, many of which can be addressed by various means, but that is a different thing than E2EE.</div><br/></div></div></div></div></div></div></div></div><div id="39436338" class="c"><input type="checkbox" id="c-39436338" checked=""/><div class="controls bullet"><span class="by">fatkam</span><span>|</span><a href="#39436669">prev</a><span>|</span><a href="#39437228">next</a><span>|</span><label class="collapse" for="c-39436338">[-]</label><label class="expand" for="c-39436338">[6 more]</label></div><br/><div class="children"><div class="content">E2EE can be done anywhere, but of course some entities like Google or Apple might try to spy locally.</div><br/><div id="39436708" class="c"><input type="checkbox" id="c-39436708" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#39436338">parent</a><span>|</span><a href="#39437228">next</a><span>|</span><label class="collapse" for="c-39436708">[-]</label><label class="expand" for="c-39436708">[5 more]</label></div><br/><div class="children"><div class="content">Indeed, the article&#x27;s assertion that &quot;mobile is convincingly a more secure platform&quot; falls over if you don&#x27;t trust the gatekeepers holding the keys.</div><br/><div id="39436974" class="c"><input type="checkbox" id="c-39436974" checked=""/><div class="controls bullet"><span class="by">Andrex</span><span>|</span><a href="#39436338">root</a><span>|</span><a href="#39436708">parent</a><span>|</span><a href="#39437158">next</a><span>|</span><label class="collapse" for="c-39436974">[-]</label><label class="expand" for="c-39436974">[1 more]</label></div><br/><div class="children"><div class="content">And even if you trust them, they could be compromised now or in the future:<p><a href="https:&#x2F;&#x2F;www.computerworld.com&#x2F;article&#x2F;3712380&#x2F;russia-hacks-microsoft-its-worse-than-you-think.html" rel="nofollow">https:&#x2F;&#x2F;www.computerworld.com&#x2F;article&#x2F;3712380&#x2F;russia-hacks-m...</a></div><br/></div></div><div id="39437158" class="c"><input type="checkbox" id="c-39437158" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39436338">root</a><span>|</span><a href="#39436708">parent</a><span>|</span><a href="#39436974">prev</a><span>|</span><a href="#39437228">next</a><span>|</span><label class="collapse" for="c-39437158">[-]</label><label class="expand" for="c-39437158">[3 more]</label></div><br/><div class="children"><div class="content">So that&#x27;s fine and all, but if you&#x27;ve lost that trust in the platform itself, you can&#x27;t trust <i>any</i> E2EE; it&#x27;s not as if browsers somehow fare better in that analysis; they are in fact strictly worse.</div><br/><div id="39437804" class="c"><input type="checkbox" id="c-39437804" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39436338">root</a><span>|</span><a href="#39437158">parent</a><span>|</span><a href="#39437454">next</a><span>|</span><label class="collapse" for="c-39437804">[-]</label><label class="expand" for="c-39437804">[1 more]</label></div><br/><div class="children"><div class="content">Browsers can run on platforms that don&#x27;t have secret baseband firmware, obligatory auto-updates, etc. etc.. Obviously a layer on top of a specific platform can never have better security than that underlying platform, but you can run a browser on a better platform.</div><br/></div></div><div id="39437454" class="c"><input type="checkbox" id="c-39437454" checked=""/><div class="controls bullet"><span class="by">fatkam</span><span>|</span><a href="#39436338">root</a><span>|</span><a href="#39437158">parent</a><span>|</span><a href="#39437804">prev</a><span>|</span><a href="#39437228">next</a><span>|</span><label class="collapse" for="c-39437454">[-]</label><label class="expand" for="c-39437454">[1 more]</label></div><br/><div class="children"><div class="content">browsers do add one more layer of trust when thinking about the OS, but any mobile app also does?</div><br/></div></div></div></div></div></div></div></div><div id="39437228" class="c"><input type="checkbox" id="c-39437228" checked=""/><div class="controls bullet"><span class="by">mortallywounded</span><span>|</span><a href="#39436338">prev</a><span>|</span><a href="#39437182">next</a><span>|</span><label class="collapse" for="c-39437228">[-]</label><label class="expand" for="c-39437228">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say neither web or desktop are easy. Cryptocat was a great example. It started off as a web app and got a lot of heat. Was rewritten as a desktop app and still failed.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cryptocat#History" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cryptocat#History</a></div><br/></div></div><div id="39437182" class="c"><input type="checkbox" id="c-39437182" checked=""/><div class="controls bullet"><span class="by">nektro</span><span>|</span><a href="#39437228">prev</a><span>|</span><label class="collapse" for="c-39437182">[-]</label><label class="expand" for="c-39437182">[1 more]</label></div><br/><div class="children"><div class="content">seeing &quot;memory-unsafe languages&quot; in an article is one way to get ppl to instantly click away</div><br/></div></div></div></div></div></div></div></body></html>