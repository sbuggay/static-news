<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720170065432" as="style"/><link rel="stylesheet" href="styles.css?v=1720170065432"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lazamar.github.io/haskell-data-compression-with-huffman-codes/">Building a data compression utility in Haskell using Huffman codes</a> <span class="domain">(<a href="https://lazamar.github.io">lazamar.github.io</a>)</span></div><div class="subtext"><span>lazamar</span> | <span>84 comments</span></div><br/><div><div id="40873138" class="c"><input type="checkbox" id="c-40873138" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40873382">next</a><span>|</span><label class="collapse" for="c-40873138">[-]</label><label class="expand" for="c-40873138">[7 more]</label></div><br/><div class="children"><div class="content">There exists an array-based, in-place algorithm for this, reducing the need to allocate trees and chase pointers.<p>I mention this only because, when I learned the tree-based approach at uni, I simply wasn&#x27;t aware that there was another way to do it, and I&#x27;m wondering how many of you that&#x27;s true for as well.<p>While the tree approach is intuitive and illuminating, it probably makes more sense to work with in-place arrays, since the situations when you care most about compression are probably the situations when you have a lot of data and want to run fast.<p><pre><code>  In-Place Calculation of Minimum-Redundancy Codes
  Moffat, Katajainen.  1995.
  http:&#x2F;&#x2F;hjemmesider.diku.dk&#x2F;~jyrki&#x2F;Paper&#x2F;WADS95.pdf</code></pre></div><br/><div id="40873162" class="c"><input type="checkbox" id="c-40873162" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40873138">parent</a><span>|</span><a href="#40875056">next</a><span>|</span><label class="collapse" for="c-40873162">[-]</label><label class="expand" for="c-40873162">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In-Place Calculation of Minimum-Redundancy Codes<p>Or in general, refer to &quot;On the Implementation of Minimum Redundancy Prefix Codes&quot; by Moffat and Turpin (1997), as strongly recommended and later explained by Charles Bloom [1].<p>[1] <a href="https:&#x2F;&#x2F;cbloomrants.blogspot.com&#x2F;2010&#x2F;08&#x2F;08-12-10-lost-huffman-paper.html" rel="nofollow">https:&#x2F;&#x2F;cbloomrants.blogspot.com&#x2F;2010&#x2F;08&#x2F;08-12-10-lost-huffm...</a></div><br/><div id="40873294" class="c"><input type="checkbox" id="c-40873294" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873138">root</a><span>|</span><a href="#40873162">parent</a><span>|</span><a href="#40875056">next</a><span>|</span><label class="collapse" for="c-40873294">[-]</label><label class="expand" for="c-40873294">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the link. I was motivated to write the post after reading Moffat’s book ‘Managing Gigabytes’. A pearl from the 90’s.<p>The authors mention this technique in the second edition.</div><br/></div></div></div></div><div id="40875056" class="c"><input type="checkbox" id="c-40875056" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40873138">parent</a><span>|</span><a href="#40873162">prev</a><span>|</span><a href="#40875000">next</a><span>|</span><label class="collapse" for="c-40875056">[-]</label><label class="expand" for="c-40875056">[1 more]</label></div><br/><div class="children"><div class="content">The JPEG standard ITU T.81 (1992) has a description of the algorithm in flowcharts, so the knowledge of array-based Huffman was probably already somewhat common in the 80s.</div><br/></div></div><div id="40875000" class="c"><input type="checkbox" id="c-40875000" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#40873138">parent</a><span>|</span><a href="#40875056">prev</a><span>|</span><a href="#40873228">next</a><span>|</span><label class="collapse" for="c-40875000">[-]</label><label class="expand" for="c-40875000">[1 more]</label></div><br/><div class="children"><div class="content">It’s mentioned at the end and left as an exercise to the reader.</div><br/></div></div><div id="40873228" class="c"><input type="checkbox" id="c-40873228" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#40873138">parent</a><span>|</span><a href="#40875000">prev</a><span>|</span><a href="#40873382">next</a><span>|</span><label class="collapse" for="c-40873228">[-]</label><label class="expand" for="c-40873228">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and I&#x27;m wondering how many of you that&#x27;s true for as well<p>the phrasing sounds like a list comprehension</div><br/><div id="40874714" class="c"><input type="checkbox" id="c-40874714" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#40873138">root</a><span>|</span><a href="#40873228">parent</a><span>|</span><a href="#40873382">next</a><span>|</span><label class="collapse" for="c-40874714">[-]</label><label class="expand" for="c-40874714">[1 more]</label></div><br/><div class="children"><div class="content">true, tickles my brain in all kinds of funny ways</div><br/></div></div></div></div></div></div><div id="40873382" class="c"><input type="checkbox" id="c-40873382" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40873138">prev</a><span>|</span><a href="#40874811">next</a><span>|</span><label class="collapse" for="c-40873382">[-]</label><label class="expand" for="c-40873382">[9 more]</label></div><br/><div class="children"><div class="content">&gt; To make it unambiguous we must make sure that no code word is a prefix of another code word.<p>Technically, this is not quite correct. The class of so-called uniquely decodable codes is unambigous, and a superset of the prefix codes. One simple example of a 
uniquely decodable code is the reverse of a prefix code. For the example in the article that would be<p><pre><code>    a 1
    b 00
    c 10
</code></pre>
While the code for a is a prefix of the code of c, one can still unambiguously decode any code sequence by processing it in reverse order. It would be interesting to see a uniquely decodable code that is neither a prefix code nor one in reverse.</div><br/><div id="40875389" class="c"><input type="checkbox" id="c-40875389" checked=""/><div class="controls bullet"><span class="by">imurray</span><span>|</span><a href="#40873382">parent</a><span>|</span><a href="#40878776">next</a><span>|</span><label class="collapse" for="c-40875389">[-]</label><label class="expand" for="c-40875389">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It would be interesting to see a uniquely decodable code that is neither a prefix code nor one in reverse.<p>More interesting than I thought. First the adversarial answer; sure (edit: ah, I see someone else posted exactly the same!):<p><pre><code>    a 101
    b 1
</code></pre>
But it&#x27;s a bad code, because we&#x27;d always be better with a=1 and b=0.<p>The Kraft inequality gives the sets of code lengths that can be made uniquely decodable, and we can achieve any of those with Huffman coding. So there&#x27;s never a reason to use a non-prefix code (assuming we are doing symbol coding, and not swapping to something else like ANS or arithmetic coding).<p>But hmmmm, I don&#x27;t know if there exists a uniquely-decodable code with the same set of lengths as an optimal Huffman code that is neither a prefix code nor one in reverse (a suffix code).<p>If I was going to spend time on it, I&#x27;d look at <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sardinas-Patterson_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sardinas-Patterson_algorithm</a> -- either to brute force a counter-example, or to see if a proof is inspired by how it works.</div><br/></div></div><div id="40878776" class="c"><input type="checkbox" id="c-40878776" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#40873382">parent</a><span>|</span><a href="#40875389">prev</a><span>|</span><a href="#40875179">next</a><span>|</span><label class="collapse" for="c-40878776">[-]</label><label class="expand" for="c-40878776">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It would be interesting to see a [not gratuitously inefficient] uniquely decodable code that is neither a prefix code nor one in reverse.<p>This can be done by composing a prefix code with a suffix code:<p><pre><code>    A   0
    B  01
    C  11
  a A  0
  b BA 010
  c BB 0101
  d BC 0111
  e C  11
  {a=0,b=010,c=0101,d=0111,e=11}
</code></pre>
This is trivially uniquely decodable by uniquely decoding 0-&gt;A&#x2F;etc backward, then uniquely decoding A-&gt;a&#x2F;etc foreward. It&#x27;s equivalent in lengths to the optimal prefix code {a=0,b=110,c=1110,d=1111,e=10} so it&#x27;s a (one of several) optimal code for the same probability distributions.<p>And it&#x27;s neither prefix nor suffix itself, since a=0 and b=010. In fact, it can&#x27;t in general be decoded incrementally at all, in either direction, since &quot;cee...ee?&quot; vs &quot;bee...ee?&quot; and &quot;?cc...cca&quot; vs &quot;?cc...ccb&quot; both depend on unbounded lookahead to distinguish a single symbol.<p>I&#x27;m not sure the optimality holds for <i>any</i> composition of a in-isolation-optimal prefix code with a in-isolation-optimal suffix code, but it did work for the most trivial cases (other than the degenerate 1-to-1 code) I could come up with.</div><br/></div></div><div id="40875179" class="c"><input type="checkbox" id="c-40875179" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#40873382">parent</a><span>|</span><a href="#40878776">prev</a><span>|</span><a href="#40873413">next</a><span>|</span><label class="collapse" for="c-40875179">[-]</label><label class="expand" for="c-40875179">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a weird example, but what about<p><pre><code>  a 1
  b 101
</code></pre>
?<p>It is neither prefix-free nor suffix-free. Yet every occurrence of 0 corresponds to an occurrence of b.<p>However, this is obviously inefficient. So I guess the question is whether there&#x27;s an optimal code which is neither prefix-free nor suffix-free.<p>--------------<p>EDIT<p>I did some googling and found this webpage <a href="https:&#x2F;&#x2F;blog.plover.com&#x2F;CS&#x2F;udcodes.html" rel="nofollow">https:&#x2F;&#x2F;blog.plover.com&#x2F;CS&#x2F;udcodes.html</a> where the author gives the following example of a uniquely decodable code:<p><pre><code>  a 0011
  b 011
  c 11
  d 1110
</code></pre>
I guess this is &quot;almost&quot; prefix-free since the only prefix is c of d. If a message starts wiht 1, you could find the first 0 and then look at whether there&#x27;s an odd or even number of 1&#x27;s. So I think I can see how it&#x27;s uniquely decodable. However, my crypto knowledge is too rusty to remember how to show whether this is an optimal code for some probability distribution.</div><br/><div id="40875414" class="c"><input type="checkbox" id="c-40875414" checked=""/><div class="controls bullet"><span class="by">imurray</span><span>|</span><a href="#40873382">root</a><span>|</span><a href="#40875179">parent</a><span>|</span><a href="#40873413">next</a><span>|</span><label class="collapse" for="c-40875414">[-]</label><label class="expand" for="c-40875414">[2 more]</label></div><br/><div class="children"><div class="content">That code in the EDIT is suboptimal. It doesn&#x27;t saturate the Kraft inequality. You could make every codeword two bits and still encode 4 symbols, so that would be strictly better.</div><br/><div id="40875467" class="c"><input type="checkbox" id="c-40875467" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#40873382">root</a><span>|</span><a href="#40875414">parent</a><span>|</span><a href="#40873413">next</a><span>|</span><label class="collapse" for="c-40875467">[-]</label><label class="expand" for="c-40875467">[1 more]</label></div><br/><div class="children"><div class="content">Ah of course. Thanks for the insight. About 15 years since I studied this stuff!</div><br/></div></div></div></div></div></div><div id="40873413" class="c"><input type="checkbox" id="c-40873413" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873382">parent</a><span>|</span><a href="#40875179">prev</a><span>|</span><a href="#40873670">next</a><span>|</span><label class="collapse" for="c-40873413">[-]</label><label class="expand" for="c-40873413">[1 more]</label></div><br/><div class="children"><div class="content">That’s interesting. I guess this is not usually used because you may have a long string of bits that is ambiguous till you get to a disambiguating bit.<p>Something like<p>`100000000000000001`<p>In this case, where to know whether the first code was an `a` or a `c` you have to read all the way to where the zeroes end.</div><br/></div></div></div></div><div id="40874811" class="c"><input type="checkbox" id="c-40874811" checked=""/><div class="controls bullet"><span class="by">goldfishgold</span><span>|</span><a href="#40873382">prev</a><span>|</span><a href="#40873300">next</a><span>|</span><label class="collapse" for="c-40874811">[-]</label><label class="expand" for="c-40874811">[1 more]</label></div><br/><div class="children"><div class="content">Coursera’s functional programming course (in Scala) includes a pretty similar Huffman coding assignment with autograder if anybody wants to take a stab at it themselves.<p><a href="https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;scala-functional-programming?specialization=scala#modules" rel="nofollow">https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;scala-functional-programming?...</a></div><br/></div></div><div id="40873300" class="c"><input type="checkbox" id="c-40873300" checked=""/><div class="controls bullet"><span class="by">atlintots</span><span>|</span><a href="#40874811">prev</a><span>|</span><a href="#40873240">next</a><span>|</span><label class="collapse" for="c-40873300">[-]</label><label class="expand" for="c-40873300">[3 more]</label></div><br/><div class="children"><div class="content">This is great! Are there any other similar tutorials going through writing a Haskell program, but with some more advanced features (monad transformers, lenses, etc)</div><br/><div id="40873749" class="c"><input type="checkbox" id="c-40873749" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40873300">parent</a><span>|</span><a href="#40875618">next</a><span>|</span><label class="collapse" for="c-40873749">[-]</label><label class="expand" for="c-40873749">[1 more]</label></div><br/><div class="children"><div class="content">I would recommend the book <i>Haskell in Depth</i>, which covers both of those topics (monad transformers by chapter 6, lenses in chapter 3 and chapter 14). It also covers some other advanced features, like Template Haskell and concurrency, and has a chapter dedicated to working with SQL databases in Haskell.</div><br/></div></div><div id="40875618" class="c"><input type="checkbox" id="c-40875618" checked=""/><div class="controls bullet"><span class="by">mirpa</span><span>|</span><a href="#40873300">parent</a><span>|</span><a href="#40873749">prev</a><span>|</span><a href="#40873240">next</a><span>|</span><label class="collapse" for="c-40875618">[-]</label><label class="expand" for="c-40875618">[1 more]</label></div><br/><div class="children"><div class="content">You might try: <a href="https:&#x2F;&#x2F;github.com&#x2F;turion&#x2F;rhine-koans">https:&#x2F;&#x2F;github.com&#x2F;turion&#x2F;rhine-koans</a>
it is tutorial for FRP library Rhine, well commented with tests</div><br/></div></div></div></div><div id="40873240" class="c"><input type="checkbox" id="c-40873240" checked=""/><div class="controls bullet"><span class="by">banish-m4</span><span>|</span><a href="#40873300">prev</a><span>|</span><a href="#40872674">next</a><span>|</span><label class="collapse" for="c-40873240">[-]</label><label class="expand" for="c-40873240">[1 more]</label></div><br/><div class="children"><div class="content">Last time I used Huffman codes, it was to run a MICMAC processor macroprogram (assembly text) in the fewest number of microcycles and to use the fewest microinstructions in the microprogram (microcode). So starting with a histogram of the macroinstructions executed (IIRC, I first wrote an interpreter in C to count how many of each were executed), I crafted a progressive decoding microcode program to implement all of the required ISA macro-operations. IIRC, the macro instruction ISA I created was bit-granular instead of byte-oriented. In the real world, it would&#x27;ve been slow and inconvenient. What&#x27;s nice about Huffman codes is that you can vary the prefix depth based on the distribution of values, so you don&#x27;t have to have lopsided codes based on 1 bit prefixes.<p>Also, the microprogram had to deal with branch prediction because it was a non-superscalar pipelined processor model. Guess the wrong branch, and enjoy wasting cycles on a pipeline stall while the correct branch filters forward.</div><br/></div></div><div id="40872674" class="c"><input type="checkbox" id="c-40872674" checked=""/><div class="controls bullet"><span class="by">tankfeeder</span><span>|</span><a href="#40873240">prev</a><span>|</span><a href="#40873532">next</a><span>|</span><label class="collapse" for="c-40872674">[-]</label><label class="expand" for="c-40872674">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Huffman_coding" rel="nofollow">https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Huffman_coding</a></div><br/></div></div><div id="40873532" class="c"><input type="checkbox" id="c-40873532" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#40872674">prev</a><span>|</span><a href="#40873743">next</a><span>|</span><label class="collapse" for="c-40873532">[-]</label><label class="expand" for="c-40873532">[19 more]</label></div><br/><div class="children"><div class="content">Hey, since this is likely to attract Haskell programmers: how fast is Haskell these days for a programmer intent on writing optimized code?  I am particularly interested in its performance for numerical crunching like matrix operations and other stuff that benefit from SIMD.</div><br/><div id="40873943" class="c"><input type="checkbox" id="c-40873943" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40873780">next</a><span>|</span><label class="collapse" for="c-40873943">[-]</label><label class="expand" for="c-40873943">[1 more]</label></div><br/><div class="children"><div class="content">Haskell&#x27;s speed can be competitive with systems languages but keep in mind that its killer feature is ease of abstraction.<p>The idea is that it is simple to assemble multiple parts into a coherent, well organised program. Which is important for the entirety of the program, no just the tight loop.<p>So, with the nice FFI Haskell has, you can always drop down to languages without a GC for inherently imperative optimisations. Then you wrap that into a library with nice types and you can now leverage that raw power anywhere in your Haskell code where the types will match.<p>I worked at Meta in a high performance Haskell application and that&#x27;s what we did. Wrote beautiful, large, fast Haskell programs which in some specialised parts had C++ building blocks. 99% of the time was spent on Haskell land composing things into more and more useful applications.</div><br/></div></div><div id="40873780" class="c"><input type="checkbox" id="c-40873780" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40873943">prev</a><span>|</span><a href="#40873689">next</a><span>|</span><label class="collapse" for="c-40873780">[-]</label><label class="expand" for="c-40873780">[2 more]</label></div><br/><div class="children"><div class="content">I like Haskell performance for every-day backend&#x2F;web and CLI stuff.  But I drop down into Rust when I&#x27;m writing something performance-focused.<p>That said, Haskell&#x27;s no slouch.  Here&#x27;s a small program to count the 1-bits in a file.<p><pre><code>  main :: IO ()
  main = do
    content &lt;- getArgs &gt;&gt;= \[a] -&gt; unsafeMMapVector a Nothing
    print (vectorPopCount content)

  vectorPopCount :: V.Vector Word64 -&gt; Int
  vectorPopCount = V.foldl&#x27; (+) 0 . V.map popCount
</code></pre>
When you compile with -msse4.2, it will correctly use the hardware popcount instruction, and crunches through a 1GB input file in 0m0,090s.  Rounding to the nearest MB, it uses 0 heap.  (For the curious, if I compile without -msse4.2 it runs in 0m0,293s).<p>I haven&#x27;t tried crunching matrices, but I would start by checking out repa, accelerate, or massiv.<p><pre><code>  https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;repa
  https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;accelerate
  https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;massiv</code></pre></div><br/><div id="40875234" class="c"><input type="checkbox" id="c-40875234" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40873780">parent</a><span>|</span><a href="#40873689">next</a><span>|</span><label class="collapse" for="c-40875234">[-]</label><label class="expand" for="c-40875234">[1 more]</label></div><br/><div class="children"><div class="content">The lack of heap allocations is great!  Thanks for the pointers.</div><br/></div></div></div></div><div id="40873689" class="c"><input type="checkbox" id="c-40873689" checked=""/><div class="controls bullet"><span class="by">Iceland_jack</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40873780">prev</a><span>|</span><a href="#40875959">next</a><span>|</span><label class="collapse" for="c-40873689">[-]</label><label class="expand" for="c-40873689">[2 more]</label></div><br/><div class="children"><div class="content">I met Sam Derbyshire at ZuriHac who told me all the difficult architectural work had been done for SIMD support.<p>+ <a href="https:&#x2F;&#x2F;gitlab.haskell.org&#x2F;ghc&#x2F;ghc&#x2F;-&#x2F;issues&#x2F;7741" rel="nofollow">https:&#x2F;&#x2F;gitlab.haskell.org&#x2F;ghc&#x2F;ghc&#x2F;-&#x2F;issues&#x2F;7741</a><p>It might make it for GHC 9.12 (for 128 bit vectors only, and mostly floating-point operations unless other people come in and contribute).<p>The patch is at:<p>+ <a href="https:&#x2F;&#x2F;gitlab.haskell.org&#x2F;ghc&#x2F;ghc&#x2F;-&#x2F;merge_requests&#x2F;12860" rel="nofollow">https:&#x2F;&#x2F;gitlab.haskell.org&#x2F;ghc&#x2F;ghc&#x2F;-&#x2F;merge_requests&#x2F;12860</a></div><br/><div id="40875228" class="c"><input type="checkbox" id="c-40875228" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40873689">parent</a><span>|</span><a href="#40875959">next</a><span>|</span><label class="collapse" for="c-40875228">[-]</label><label class="expand" for="c-40875228">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the info!</div><br/></div></div></div></div><div id="40875959" class="c"><input type="checkbox" id="c-40875959" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40873689">prev</a><span>|</span><a href="#40877187">next</a><span>|</span><label class="collapse" for="c-40875959">[-]</label><label class="expand" for="c-40875959">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s doable but harder than in imperative languages and the resulting code is _really_ ugly. See the thread of the 1BRC <a href="https:&#x2F;&#x2F;discourse.haskell.org&#x2F;t&#x2F;one-billion-row-challenge-in-hs&#x2F;8946" rel="nofollow">https:&#x2F;&#x2F;discourse.haskell.org&#x2F;t&#x2F;one-billion-row-challenge-in...</a> with example code at (I hope that&#x27;s the right Gist) <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;AndrasKovacs&#x2F;e156ae66b8c28b1b84abe6b483ea20ec" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;AndrasKovacs&#x2F;e156ae66b8c28b1b84abe6b...</a></div><br/></div></div><div id="40877187" class="c"><input type="checkbox" id="c-40877187" checked=""/><div class="controls bullet"><span class="by">tkz1312</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40875959">prev</a><span>|</span><a href="#40873651">next</a><span>|</span><label class="collapse" for="c-40877187">[-]</label><label class="expand" for="c-40877187">[1 more]</label></div><br/><div class="children"><div class="content">Haskell really shines when you want to write high level, declarative code. Performance when using this style is generally fine for CLI &#x2F; web backend style stuff. It has the tools to write pretty fast low level code, but they’re fairly clunky and if that’s all you want to write it’s probably not going to be the best tool for the job. They’re pretty nice if you have a few focused hotspots you need to optimize.<p>It has pretty nice CPU profiling tools, so finding and optimizing CPU hotspots is fairly pleasant. Tracking down rouge memory leaks (which lazy evaluation makes more likely) on the other hand can be extremely frustrating.<p>If you look at the benchmarks game results [1], the fastest haskell implementations are generally between 2 and 5 times slower than the fastest c versions, and will be written in a highly imperative style.<p>[1]: <a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;fastest&#x2F;clang-ghc.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a></div><br/></div></div><div id="40873651" class="c"><input type="checkbox" id="c-40873651" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40877187">prev</a><span>|</span><a href="#40876921">next</a><span>|</span><label class="collapse" for="c-40873651">[-]</label><label class="expand" for="c-40873651">[4 more]</label></div><br/><div class="children"><div class="content">I’m not the best person to answer this question, but AFAIK it’s very very fast (in the rough vicinity of C). But also memory-hungry.</div><br/><div id="40875377" class="c"><input type="checkbox" id="c-40875377" checked=""/><div class="controls bullet"><span class="by">freilanzer</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40873651">parent</a><span>|</span><a href="#40876921">next</a><span>|</span><label class="collapse" for="c-40875377">[-]</label><label class="expand" for="c-40875377">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure highly optimised code won&#x27;t be elegant Haskell code though.</div><br/><div id="40875514" class="c"><input type="checkbox" id="c-40875514" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40875377">parent</a><span>|</span><a href="#40879335">next</a><span>|</span><label class="collapse" for="c-40875514">[-]</label><label class="expand" for="c-40875514">[1 more]</label></div><br/><div class="children"><div class="content">Highly optimized code tends to be inelegant in any language. That said, you can get really good performance from very elegant looking “normal” Haskell too. The big challenge with performance in Haskell is that the differences between optimized and unoptimized code can be pretty subtle if you’re not used to thinking about Haskell performance.</div><br/></div></div><div id="40879335" class="c"><input type="checkbox" id="c-40879335" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40875377">parent</a><span>|</span><a href="#40875514">prev</a><span>|</span><a href="#40876921">next</a><span>|</span><label class="collapse" for="c-40879335">[-]</label><label class="expand" for="c-40879335">[1 more]</label></div><br/><div class="children"><div class="content">Let me clarify: naive&#x2F;beautiful&#x2F;effortless Haskell code tends to be highly performant, although that is not <i>always</i> true. I believe it is much easier to write fast Haskell code than to write fast C&#x2F;C++ code.</div><br/></div></div></div></div></div></div><div id="40876921" class="c"><input type="checkbox" id="c-40876921" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40873651">prev</a><span>|</span><a href="#40875608">next</a><span>|</span><label class="collapse" for="c-40876921">[-]</label><label class="expand" for="c-40876921">[1 more]</label></div><br/><div class="children"><div class="content">If you want to write fast stuff that takes advantage of SIMD, you want to use ISPC, which is made for high performance SIMD. Using haskell for this would be like doing surgery with a dull rock, you will never get what you want.</div><br/></div></div><div id="40875608" class="c"><input type="checkbox" id="c-40875608" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40876921">prev</a><span>|</span><a href="#40877542">next</a><span>|</span><label class="collapse" for="c-40875608">[-]</label><label class="expand" for="c-40875608">[4 more]</label></div><br/><div class="children"><div class="content">The reality is that for any language, including C, compiler optimized code will never be as fast as hand optimized code in libraries like BLAS. So at some level, the choice of host language doesn&#x27;t matter very much, because you&#x27;re going to be outsourcing all of the computation anyway if you&#x27;re really serious about speed. This is the same reason all the AI stuff, possibly the single largest consumer of compute in the world, gets away with being written in python except for the low level compute libraries.<p>To answer your question directly, The GHC compiler is very good. High level code will perform very well, and for most realistic applications, performance bottlenecks are architectural, not e.g. the use of single width versus SIMD, and the &quot;architectural asymptotics&quot; of haskell are very favorable. I think GHC has&#x2F;is getting SIMD support but that&#x27;s not what I would focus on when evaluating perf.<p>I wouldn&#x27;t write a matrix multiplication algorithm in Haskell, but I also wouldn&#x27;t write one in rust or C if I was serious about speed.<p>Many focus on number crunching as a performance metric, but almost no one is ever actually bottlenecked on that, and if they are it doesn&#x27;t really matter what high level language they&#x27;re using.</div><br/><div id="40875817" class="c"><input type="checkbox" id="c-40875817" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40875608">parent</a><span>|</span><a href="#40877542">next</a><span>|</span><label class="collapse" for="c-40875817">[-]</label><label class="expand" for="c-40875817">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The reality is that for any language, including C, compiler optimized code will never be as fast as hand optimized code<p>That&#x27;s not strictly true; sometimes a C compiler can optimize away my whole program: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;oG5nfGE6z" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;oG5nfGE6z</a></div><br/><div id="40878104" class="c"><input type="checkbox" id="c-40878104" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40875817">parent</a><span>|</span><a href="#40877542">next</a><span>|</span><label class="collapse" for="c-40878104">[-]</label><label class="expand" for="c-40878104">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re doing extremely simple constant arithmetic here. GHC can optimize this type of thing away to nothing as well. Are we talking about contrived examples or real numerical bottlenecks?</div><br/><div id="40879266" class="c"><input type="checkbox" id="c-40879266" checked=""/><div class="controls bullet"><span class="by">Twisol</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40878104">parent</a><span>|</span><a href="#40877542">next</a><span>|</span><label class="collapse" for="c-40879266">[-]</label><label class="expand" for="c-40879266">[1 more]</label></div><br/><div class="children"><div class="content">I think it was a joke about compilers removing code by reasoning about undefined behavior.</div><br/></div></div></div></div></div></div></div></div><div id="40877542" class="c"><input type="checkbox" id="c-40877542" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#40873532">parent</a><span>|</span><a href="#40875608">prev</a><span>|</span><a href="#40873743">next</a><span>|</span><label class="collapse" for="c-40877542">[-]</label><label class="expand" for="c-40877542">[2 more]</label></div><br/><div class="children"><div class="content">If you’re writing idiomatic Haskell. Its performance is terrible.<p>If you’re choosing to fight with Haskell, why? Just use something else.<p>To understand why people claim Haskell is “fast”, you need to understand what they mean. What they mean is “if you opted to write C in such a way as you were performing similar amounts of copious and useless data copying, pointer following and stack blowing madness, Haskell will perform that fast”. They are not saying “Haskell is as fast as the fastest idiomatic C implementation”.<p>Another thing you’re going to see a lot of is extremely simple anecdotes, such as counting in a loop, or favourable measure points (they will measure the whole c program, but just the point in Haskell after they’ve flattened data, for example, stating “we just want to compare those parts”).</div><br/><div id="40879357" class="c"><input type="checkbox" id="c-40879357" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40873532">root</a><span>|</span><a href="#40877542">parent</a><span>|</span><a href="#40873743">next</a><span>|</span><label class="collapse" for="c-40879357">[-]</label><label class="expand" for="c-40879357">[1 more]</label></div><br/><div class="children"><div class="content">I think if your <i>runtime</i> performance is terrible with Haskell, either the explanation is that you might be doing something a bit crazy, or that your application is memory-constrained.</div><br/></div></div></div></div></div></div><div id="40873743" class="c"><input type="checkbox" id="c-40873743" checked=""/><div class="controls bullet"><span class="by">chvrchbvrner</span><span>|</span><a href="#40873532">prev</a><span>|</span><a href="#40872934">next</a><span>|</span><label class="collapse" for="c-40873743">[-]</label><label class="expand" for="c-40873743">[3 more]</label></div><br/><div class="children"><div class="content">I think there is a typo in the table of the &quot;Creating prefix-free codes&quot; section. D should be &#x27;0010&#x27; (not &#x27;0110&#x27;).<p>Otherwise a great read, thanks!</div><br/><div id="40873812" class="c"><input type="checkbox" id="c-40873812" checked=""/><div class="controls bullet"><span class="by">polytely</span><span>|</span><a href="#40873743">parent</a><span>|</span><a href="#40873856">next</a><span>|</span><label class="collapse" for="c-40873812">[-]</label><label class="expand" for="c-40873812">[1 more]</label></div><br/><div class="children"><div class="content">Aha, that makes sense, I was wracking my brain as to how 0110 was unambiguous.</div><br/></div></div><div id="40873856" class="c"><input type="checkbox" id="c-40873856" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873743">parent</a><span>|</span><a href="#40873812">prev</a><span>|</span><a href="#40872934">next</a><span>|</span><label class="collapse" for="c-40873856">[-]</label><label class="expand" for="c-40873856">[1 more]</label></div><br/><div class="children"><div class="content">Fixed it. Well spotted!</div><br/></div></div></div></div><div id="40872934" class="c"><input type="checkbox" id="c-40872934" checked=""/><div class="controls bullet"><span class="by">alwinaugustin</span><span>|</span><a href="#40873743">prev</a><span>|</span><a href="#40873004">next</a><span>|</span><label class="collapse" for="c-40872934">[-]</label><label class="expand" for="c-40872934">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing. Very nice and insightful.</div><br/></div></div><div id="40873004" class="c"><input type="checkbox" id="c-40873004" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40872934">prev</a><span>|</span><a href="#40873699">next</a><span>|</span><label class="collapse" for="c-40873004">[-]</label><label class="expand" for="c-40873004">[13 more]</label></div><br/><div class="children"><div class="content">For all readers, arithmetic codes are better in nearly all ways.   They can be implemented in less RAM and code, they compress and decompress to a better ratio, and the probabilities of different symbols appearing can be dynamically updated during the stream far more easily.<p>The only reason Huffman codes are used is they were invented first and arithmetic codes were patented.    That patent has now expired, so we should use the better design.</div><br/><div id="40873172" class="c"><input type="checkbox" id="c-40873172" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40873004">parent</a><span>|</span><a href="#40873025">next</a><span>|</span><label class="collapse" for="c-40873172">[-]</label><label class="expand" for="c-40873172">[1 more]</label></div><br/><div class="children"><div class="content">If you do have an option to switch from Huffman, rANS is now the way to go, not a clasical arithmetic coding.</div><br/></div></div><div id="40873025" class="c"><input type="checkbox" id="c-40873025" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40873004">parent</a><span>|</span><a href="#40873172">prev</a><span>|</span><a href="#40873124">next</a><span>|</span><label class="collapse" for="c-40873025">[-]</label><label class="expand" for="c-40873025">[1 more]</label></div><br/><div class="children"><div class="content">Two slight benefits of Huffman codes over arithmetic:<p>* They usually self synchronize when some data is corrupted (but not guaranteed, does not apply where the Huffman table is dynamic)<p>* Neither Huffman nor arithmetic codes are easy to parallelize the decoding of, but Huffman is slightly easier.</div><br/></div></div><div id="40873124" class="c"><input type="checkbox" id="c-40873124" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#40873004">parent</a><span>|</span><a href="#40873025">prev</a><span>|</span><a href="#40875083">next</a><span>|</span><label class="collapse" for="c-40873124">[-]</label><label class="expand" for="c-40873124">[5 more]</label></div><br/><div class="children"><div class="content">I was under the impression that arithmetic codes are guaranteed to be <i>at least</i> one bit less efficient than Huffman codes per input block. What makes you say they have better compression ratio?<p>Are you thinking of pre-defined Huffman tables that aren&#x27;t adapted to the input? Because the latter ought to be as good as it gets.<p>(I agree with the other benefits. Since arithmetic coding tables are built in a streaming fashion rather than constructing the codebook up front, they are more memory-efficient while working.)</div><br/><div id="40873179" class="c"><input type="checkbox" id="c-40873179" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40873004">root</a><span>|</span><a href="#40873124">parent</a><span>|</span><a href="#40873210">next</a><span>|</span><label class="collapse" for="c-40873179">[-]</label><label class="expand" for="c-40873179">[3 more]</label></div><br/><div class="children"><div class="content">Huffman codes are conceptually isomorphic to arithmetic codes where all probabilities are 2^-k with k integer, so they have an obvious disadvantage due to more inaccurate symbol distribution.</div><br/><div id="40873855" class="c"><input type="checkbox" id="c-40873855" checked=""/><div class="controls bullet"><span class="by">SassyBird</span><span>|</span><a href="#40873004">root</a><span>|</span><a href="#40873179">parent</a><span>|</span><a href="#40873210">next</a><span>|</span><label class="collapse" for="c-40873855">[-]</label><label class="expand" for="c-40873855">[2 more]</label></div><br/><div class="children"><div class="content">Hopefully k is natural. ;)</div><br/><div id="40874211" class="c"><input type="checkbox" id="c-40874211" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40873004">root</a><span>|</span><a href="#40873855">parent</a><span>|</span><a href="#40873210">next</a><span>|</span><label class="collapse" for="c-40874211">[-]</label><label class="expand" for="c-40874211">[1 more]</label></div><br/><div class="children"><div class="content">Implied because any symbol distribution which probabilities do not sum to 1 is invalid anyway ;-)</div><br/></div></div></div></div></div></div><div id="40873210" class="c"><input type="checkbox" id="c-40873210" checked=""/><div class="controls bullet"><span class="by">hcs</span><span>|</span><a href="#40873004">root</a><span>|</span><a href="#40873124">parent</a><span>|</span><a href="#40873179">prev</a><span>|</span><a href="#40875083">next</a><span>|</span><label class="collapse" for="c-40873210">[-]</label><label class="expand" for="c-40873210">[1 more]</label></div><br/><div class="children"><div class="content">Huffman codes are less efficient per symbol since each symbol is a bit string, arithmetic coding effectively smears symbols across bits more finely. Whether you use a dynamic or static probability model is a different issue applying to either coding method. (Emotionally though I prefer Huffman codes, they&#x27;re just so <i>neat</i>)</div><br/></div></div></div></div><div id="40875083" class="c"><input type="checkbox" id="c-40875083" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40873004">parent</a><span>|</span><a href="#40873124">prev</a><span>|</span><a href="#40873342">next</a><span>|</span><label class="collapse" for="c-40875083">[-]</label><label class="expand" for="c-40875083">[3 more]</label></div><br/><div class="children"><div class="content">LZ is even better. Neither arithmetic nor Huffman will compress when the probability of all symbols is the same, but LZ will find repetitions easily. LZ also decompresses extremely quickly --- <i>faster than memcpy</i> is often mentioned.</div><br/><div id="40875165" class="c"><input type="checkbox" id="c-40875165" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873004">root</a><span>|</span><a href="#40875083">parent</a><span>|</span><a href="#40875344">next</a><span>|</span><label class="collapse" for="c-40875165">[-]</label><label class="expand" for="c-40875165">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, but worth noting that LZ is a modelling scheme, whilst Huffman is a coding technique.<p>That is, LZ determines, dynamically as it goes, what are all the elements we want to encode and their probabilities. Then you need a coder, like Huffman, to actually encode it.<p>In the post I used a semi-static zero-order byte-based model. 
Which means I counted the byte occurrences first and just used that count for the probabilities throughout all of the encoding. Then I used Huffman codes to translate those probabilities into bits.<p>But I&#x27;m considering writing a follow-up changing this static model for an LZ77 one as I think that would be fun.</div><br/></div></div><div id="40875344" class="c"><input type="checkbox" id="c-40875344" checked=""/><div class="controls bullet"><span class="by">d_burfoot</span><span>|</span><a href="#40873004">root</a><span>|</span><a href="#40875083">parent</a><span>|</span><a href="#40875165">prev</a><span>|</span><a href="#40873342">next</a><span>|</span><label class="collapse" for="c-40875344">[-]</label><label class="expand" for="c-40875344">[1 more]</label></div><br/><div class="children"><div class="content">&gt; LZ is even better. Neither arithmetic nor Huffman will compress when the probability of all symbols is the same<p>Comparing LZ to arithmetic encoding is a category error. LZ and Huffman are combined modeling+encoding methods, while arithmetic is just an encoding method, and it can be combined with any modeling technique. Arithmetic plus a suitable modeling technique will achieve compression as good as LZ, Huffman, or any other scheme. The PAQ8 compressors, and I believe its successors in the Hutter Prize ranking, use arithmetic plus a very advanced modeling scheme.<p><a href="http:&#x2F;&#x2F;prize.hutter1.net&#x2F;hfaq.htm#paq8" rel="nofollow">http:&#x2F;&#x2F;prize.hutter1.net&#x2F;hfaq.htm#paq8</a></div><br/></div></div></div></div><div id="40873342" class="c"><input type="checkbox" id="c-40873342" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873004">parent</a><span>|</span><a href="#40875083">prev</a><span>|</span><a href="#40873699">next</a><span>|</span><label class="collapse" for="c-40873342">[-]</label><label class="expand" for="c-40873342">[2 more]</label></div><br/><div class="children"><div class="content">There is one way in which Huffman codes are better: they are easier to explain and simpler to implement.<p>I went for simplicity of exposition in the post, but arithmetic coders can indeed get arbitrarily close to the entropy, which is not quite the case with Huffman.</div><br/><div id="40873732" class="c"><input type="checkbox" id="c-40873732" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#40873004">root</a><span>|</span><a href="#40873342">parent</a><span>|</span><a href="#40873699">next</a><span>|</span><label class="collapse" for="c-40873732">[-]</label><label class="expand" for="c-40873732">[1 more]</label></div><br/><div class="children"><div class="content">&gt; easier to explain<p>I think Huffman is the one compression algorithm that compresses stuff significantly that can fit on the proverbial napkin, so it&#x27;s a good start.<p>The others require the whole napkin stack at the table.</div><br/></div></div></div></div></div></div><div id="40873699" class="c"><input type="checkbox" id="c-40873699" checked=""/><div class="controls bullet"><span class="by">bdahz</span><span>|</span><a href="#40873004">prev</a><span>|</span><a href="#40872875">next</a><span>|</span><label class="collapse" for="c-40873699">[-]</label><label class="expand" for="c-40873699">[9 more]</label></div><br/><div class="children"><div class="content">How is the performance when compared to similar implementations in C&#x2F;C++ or Rust?</div><br/><div id="40873762" class="c"><input type="checkbox" id="c-40873762" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873699">parent</a><span>|</span><a href="#40873944">next</a><span>|</span><label class="collapse" for="c-40873762">[-]</label><label class="expand" for="c-40873762">[7 more]</label></div><br/><div class="children"><div class="content">I’d say unbeatable!<p>The goal was simplicity of implementation and code clarity. For this kind of thing I say Haskell performs the best.</div><br/><div id="40873805" class="c"><input type="checkbox" id="c-40873805" checked=""/><div class="controls bullet"><span class="by">bdahz</span><span>|</span><a href="#40873699">root</a><span>|</span><a href="#40873762">parent</a><span>|</span><a href="#40873788">next</a><span>|</span><label class="collapse" for="c-40873805">[-]</label><label class="expand" for="c-40873805">[4 more]</label></div><br/><div class="children"><div class="content">For the simplicity of implementation and code clarity, I need to know how much I need to pay for it.<p>If the Haskell implementation is 3x slower than C&#x2F;C++&#x2F;Rust implementation, it would be acceptable.<p>If it&#x27;s 30x slower, I would rather choose C&#x2F;C++&#x2F;Rust even the implementation won&#x27;t be simple.<p>If it is even possible to be 3x faster than C&#x2F;C++&#x2F;Rust, then why not the mainstream programmers adopt Haskell everywhere?</div><br/><div id="40875663" class="c"><input type="checkbox" id="c-40875663" checked=""/><div class="controls bullet"><span class="by">rebeccaskinner</span><span>|</span><a href="#40873699">root</a><span>|</span><a href="#40873805">parent</a><span>|</span><a href="#40873959">next</a><span>|</span><label class="collapse" for="c-40875663">[-]</label><label class="expand" for="c-40875663">[2 more]</label></div><br/><div class="children"><div class="content">The general rule of thumb I’d give is that a performance aware but not micro-optimized Haskell program will typically run in about 2x to 5x the time of a comparable C program, and will take somewhere between 2x and 10x as much memory. For a naive Haskell program the range is much bigger- maybe 2x to 10x as much time and 10x to 1000x as much memory (it’s easy to do a lot of allocations in Haskell).<p>For extremely optimized Haskell you can get close to the speed of C, but there’s still a garbage collector.<p>There are also certain classes of problem where a naive Haskell implementation can beat other languages by mile, including C, if you use the same implementation in both languages. Laziness can be really great sometimes. This didn’t happen much in practice though because the kind of code that’s really efficient with lazy evaluation is very obviously not in a strict language so people don’t usually write code that way.<p>In the end I’d say Haskell is a good choice for performance sensitive but not performance critical program. In a larger Haskell application if you have a performance critical bit you can usually write Haskell code that will be fast enough if you know what your doing. For something stand alone that needs to be as fast as possible, or the most critically performance sensitive parts of a bigger application, I’d consider using C or C++.</div><br/><div id="40876108" class="c"><input type="checkbox" id="c-40876108" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40873699">root</a><span>|</span><a href="#40875663">parent</a><span>|</span><a href="#40873959">next</a><span>|</span><label class="collapse" for="c-40876108">[-]</label><label class="expand" for="c-40876108">[1 more]</label></div><br/><div class="children"><div class="content">To rephrase using my experience: &quot;performance aware&quot; Haskell is about as &quot;fast&quot; as Go, but needs more memory, and both are slower than the same Java code - but both are way more fun to write ;). Optimising Go is easier for most people though, in Haskell you _really_ need to know Haskell internals (how to read core and write unboxed code) and understand laziness.<p>My try of the 1 billion row challenge in Go and Haskell (and C) and comparison to other, fast implementations: <a href="https:&#x2F;&#x2F;github.com&#x2F;Release-Candidate&#x2F;1-billion-row-challenge?tab=readme-ov-file#results">https:&#x2F;&#x2F;github.com&#x2F;Release-Candidate&#x2F;1-billion-row-challenge...</a></div><br/></div></div></div></div><div id="40873959" class="c"><input type="checkbox" id="c-40873959" checked=""/><div class="controls bullet"><span class="by">lazamar</span><span>|</span><a href="#40873699">root</a><span>|</span><a href="#40873805">parent</a><span>|</span><a href="#40875663">prev</a><span>|</span><a href="#40873788">next</a><span>|</span><label class="collapse" for="c-40873959">[-]</label><label class="expand" for="c-40873959">[1 more]</label></div><br/><div class="children"><div class="content">The goal of this implementation is not to be fast, but to be clear.<p>I am doing some inefficient things (like two pass encoding) on purpose to keep things simple and clear. So using this particular piece of code to judge a language&#x27;s performance potential is not really the way to go here.</div><br/></div></div></div></div><div id="40873788" class="c"><input type="checkbox" id="c-40873788" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40873699">root</a><span>|</span><a href="#40873762">parent</a><span>|</span><a href="#40873805">prev</a><span>|</span><a href="#40873944">next</a><span>|</span><label class="collapse" for="c-40873788">[-]</label><label class="expand" for="c-40873788">[2 more]</label></div><br/><div class="children"><div class="content">That wasn&#x27;t really the spirit of the question as I read it.  &#x27;Performance&#x27; has a narrower definition than that.</div><br/><div id="40874349" class="c"><input type="checkbox" id="c-40874349" checked=""/><div class="controls bullet"><span class="by">zarathustreal</span><span>|</span><a href="#40873699">root</a><span>|</span><a href="#40873788">parent</a><span>|</span><a href="#40873944">next</a><span>|</span><label class="collapse" for="c-40874349">[-]</label><label class="expand" for="c-40874349">[1 more]</label></div><br/><div class="children"><div class="content">The point they’re making is that there is no performance without tradeoffs and “fast” is meaningless unless you define what you’re measuring. Asking the question implies a misunderstanding of the intent of the implementation, OP was trying to subtly let them know.</div><br/></div></div></div></div></div></div></div></div><div id="40872875" class="c"><input type="checkbox" id="c-40872875" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#40873699">prev</a><span>|</span><a href="#40873443">next</a><span>|</span><label class="collapse" for="c-40872875">[-]</label><label class="expand" for="c-40872875">[2 more]</label></div><br/><div class="children"><div class="content">Very nice read, thanks for sharing!</div><br/><div id="40873734" class="c"><input type="checkbox" id="c-40873734" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#40872875">parent</a><span>|</span><a href="#40873443">next</a><span>|</span><label class="collapse" for="c-40873734">[-]</label><label class="expand" for="c-40873734">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s nice ?</div><br/></div></div></div></div><div id="40873443" class="c"><input type="checkbox" id="c-40873443" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40872875">prev</a><span>|</span><a href="#40873763">next</a><span>|</span><label class="collapse" for="c-40873443">[-]</label><label class="expand" for="c-40873443">[10 more]</label></div><br/><div class="children"><div class="content">Haskell is a really nice language. In general I don’t identify as an X programmer for any value of X: I tend to write in a half dozen languages daily and they all suck in their own special way.<p>But on two separate occasions I made important career decisions with opportunity cost to work with highly lethal GHC contributors: those people are just really good.<p>If Haskell sucks like all languages it’s because Haskell excels at using computers to <i>compute</i> something: Haskell considers data shuffling a strictly secondary concern compared to doing actual computations.</div><br/><div id="40873940" class="c"><input type="checkbox" id="c-40873940" checked=""/><div class="controls bullet"><span class="by">random3</span><span>|</span><a href="#40873443">parent</a><span>|</span><a href="#40874898">next</a><span>|</span><label class="collapse" for="c-40873940">[-]</label><label class="expand" for="c-40873940">[7 more]</label></div><br/><div class="children"><div class="content">How do you distinguish data shuffling from computation? What’s actual computation from this perspective?</div><br/><div id="40875108" class="c"><input type="checkbox" id="c-40875108" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40873443">root</a><span>|</span><a href="#40873940">parent</a><span>|</span><a href="#40874410">next</a><span>|</span><label class="collapse" for="c-40875108">[-]</label><label class="expand" for="c-40875108">[1 more]</label></div><br/><div class="children"><div class="content">Before I was good at Haskell, I would approach a data-processing job sequentially based on the next thing that needs to be done.<p>I want to open a file, and I can&#x27;t read it all at once, so I&#x27;ll use a FileReader and it should be buffered, so I&#x27;ll wrap it with a BufferedReader.  I&#x27;ll use try-with-resources and click into the classes because I can&#x27;t remember if the contract of the outermost reader is that it will close the inner readers too.<p>Right, now I&#x27;ll grab the next n bytes from the stream, and start thinking about the algorithm.  Swear a bit when I think about crossing the buffer boundaries, and on-and-on...<p>The IO concerns are very much interwoven with the algorithm.<p>In Haskell I just start by writing one function from bytes to bytes. That&#x27;s the computation.  Then when that&#x27;s done I expose that function as bytes to bytes.<p>Others can hook it up to files, webservers, pipe it through gzip, whatever!</div><br/></div></div><div id="40874410" class="c"><input type="checkbox" id="c-40874410" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#40873443">root</a><span>|</span><a href="#40873940">parent</a><span>|</span><a href="#40875108">prev</a><span>|</span><a href="#40874184">next</a><span>|</span><label class="collapse" for="c-40874410">[-]</label><label class="expand" for="c-40874410">[2 more]</label></div><br/><div class="children"><div class="content">Reading a row from a database and putting it on the screen, and reading some numbers from the keyboard and putting them in the database. These things I would not call computation. I mean sure, displaying needs to compute coordinates for where to light up pixels, but that&#x27;s all already written. I just call it. Same with updating btrees when writing to the db.<p>I&#x27;m guessing if all you do is this kind of db - screen - keyboard and back stuff, haskell is not very useful, if not actively a hindrance.</div><br/><div id="40880068" class="c"><input type="checkbox" id="c-40880068" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40873443">root</a><span>|</span><a href="#40874410">parent</a><span>|</span><a href="#40874184">next</a><span>|</span><label class="collapse" for="c-40880068">[-]</label><label class="expand" for="c-40880068">[1 more]</label></div><br/><div class="children"><div class="content">Haskell is actively a hindrance if one is mostly moving bytes from one place to another: the only thing that matters when you need to talk to 7 databases each different is fashion. The language that has bindings to all 7 each with a zillion users is the one you should use.<p>If you’re moving a lot of undifferentiated bytes the language you should use is historically C, more recently C++ (which is still the standard), or maybe soon Rust (which looks to become the standard).<p>If IO is a small part of your problem, performance needs to be good but not insane, and you’re mostly thinking about algorithms and mathematics?<p>Haskell is a very pragmatic choice there. OCaml is strong here too, and TypeScript is a very cool compromise between “mainstream” and “we do math here”.</div><br/></div></div></div></div><div id="40874184" class="c"><input type="checkbox" id="c-40874184" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#40873443">root</a><span>|</span><a href="#40873940">parent</a><span>|</span><a href="#40874410">prev</a><span>|</span><a href="#40874898">next</a><span>|</span><label class="collapse" for="c-40874184">[-]</label><label class="expand" for="c-40874184">[3 more]</label></div><br/><div class="children"><div class="content">Philosophically speaking there is no difference.<p>What parent commenter probably refers to is that you think in terms of computations and not in terms of data units.<p>And that is just tremendously elegant.</div><br/><div id="40877637" class="c"><input type="checkbox" id="c-40877637" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#40873443">root</a><span>|</span><a href="#40874184">parent</a><span>|</span><a href="#40874898">next</a><span>|</span><label class="collapse" for="c-40877637">[-]</label><label class="expand" for="c-40877637">[2 more]</label></div><br/><div class="children"><div class="content">Philosophically speaking there&#x27;s a great difference.<p>Data shuffling doesn&#x27;t —in principle— lose information; computation does. (&quot;evaluation is forgetting&quot;)<p>In <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32498382">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32498382</a> &quot;glue code&quot; and &quot;parsley code&quot; are data shuffling, while &quot;crunch code&quot; is computation.</div><br/><div id="40880701" class="c"><input type="checkbox" id="c-40880701" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#40873443">root</a><span>|</span><a href="#40877637">parent</a><span>|</span><a href="#40874898">next</a><span>|</span><label class="collapse" for="c-40880701">[-]</label><label class="expand" for="c-40880701">[1 more]</label></div><br/><div class="children"><div class="content">Surely someone could find a taxonomy that makes a distinction...<p>I guess we have to colive in a world where both views are true.</div><br/></div></div></div></div></div></div></div></div><div id="40874898" class="c"><input type="checkbox" id="c-40874898" checked=""/><div class="controls bullet"><span class="by">blandblender</span><span>|</span><a href="#40873443">parent</a><span>|</span><a href="#40873940">prev</a><span>|</span><a href="#40874860">next</a><span>|</span><label class="collapse" for="c-40874898">[-]</label><label class="expand" for="c-40874898">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I tend to write in a half dozen languages daily<p>6 languages per day? Are they the same six the next day?<p>&gt; they all suck in their own special way.<p>Not surprising if you&#x27;re writing 6 different languages per day.<p>&gt; Haskell excels at using computers to compute something<p>Can you please explain how Haskell computes medians more elegantly than say C?</div><br/></div></div></div></div><div id="40873763" class="c"><input type="checkbox" id="c-40873763" checked=""/><div class="controls bullet"><span class="by">2-3-7-43-1807</span><span>|</span><a href="#40873443">prev</a><span>|</span><a href="#40877041">next</a><span>|</span><label class="collapse" for="c-40873763">[-]</label><label class="expand" for="c-40873763">[1 more]</label></div><br/><div class="children"><div class="content">and yet another episode in the series of &quot;look, what I did with Haskell&quot;</div><br/></div></div><div id="40877041" class="c"><input type="checkbox" id="c-40877041" checked=""/><div class="controls bullet"><span class="by">polterguy1000</span><span>|</span><a href="#40873763">prev</a><span>|</span><label class="collapse" for="c-40877041">[-]</label><label class="expand" for="c-40877041">[3 more]</label></div><br/><div class="children"><div class="content">Oh, Hacker News, you’ve done it again. A riveting discussion on building a data compression utility in Haskell using Huffman codes. Because nothing screams “cutting-edge tech” like rehashing algorithms from the 1950s in a language that most people use to feel intellectually superior.<p>Let’s dive into this treasure trove of comments, shall we?<p>Array-based, in-place algorithm: Oh, wow, an algorithm that reduces the need to allocate trees and chase pointers. Because, you know, memory management is for plebs.<p>Moffat and Katajainen’s paper: Because nothing says “I’m a true nerd” like referencing academic papers from the 90s. Next, they’ll be quoting ancient Greek philosophers on software design.<p>JPEG standard ITU T.81 (1992): Ah, the good old days when JPEG was the pinnacle of image compression. Let’s all take a moment to appreciate how far we’ve come. Or not.<p>Uniquely decodable codes: Because clearly, the world needed a deep dive into the nuances of prefix-free and suffix-free codes. I’m sure this will revolutionize the way we… do something.<p>Functional programming course in Scala: Oh, joy! More academic exercises in a language that’s as fun to write as it is to pronounce. Because nothing says “practical” like autograders and theoretical assignments.<p>Haskell performance: The eternal debate. Is it fast? Is it slow? Does it even matter when you’re using it to write code that only other Haskell enthusiasts will ever read?<p>Arithmetic codes vs. Huffman codes: Because clearly, the world needed another debate on which compression algorithm is marginally better. Spoiler alert: neither will make your life significantly better.<p>LZ compression: Ah, yes, the savior of all things compressed. Because why use a simple algorithm when you can use a complex one that requires a PhD to understand?<p>In conclusion, if you want to spend your time debating the finer points of data compression in a language that 99% of developers will never touch, this thread is your playground. For the rest of us, maybe stick to something more practical—like Hyperlambda.<p>Thomas Ai-Ai Shitboat Handsom<p>“To compress is human; to really overcomplicate it requires Haskell.” - Reversed and paraphrased for your amusement.<p>PLEASE FORGIVE ME  <a href="https:&#x2F;&#x2F;ainiro.io&#x2F;blog&#x2F;how-to-create-an-ai-ai-shitboat-in-30-seconds" rel="nofollow">https:&#x2F;&#x2F;ainiro.io&#x2F;blog&#x2F;how-to-create-an-ai-ai-shitboat-in-30...</a></div><br/><div id="40877116" class="c"><input type="checkbox" id="c-40877116" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#40877041">parent</a><span>|</span><a href="#40877223">next</a><span>|</span><label class="collapse" for="c-40877116">[-]</label><label class="expand" for="c-40877116">[1 more]</label></div><br/><div class="children"><div class="content">Arithmetic codes are not marginally better.<p>Asymmetric numeral systems, which is related to arithmetic coding was a real breakthrough used in all modern compressors.</div><br/></div></div><div id="40877223" class="c"><input type="checkbox" id="c-40877223" checked=""/><div class="controls bullet"><span class="by">VMG</span><span>|</span><a href="#40877041">parent</a><span>|</span><a href="#40877116">prev</a><span>|</span><label class="collapse" for="c-40877223">[-]</label><label class="expand" for="c-40877223">[1 more]</label></div><br/><div class="children"><div class="content">Downvoted not because of AI but because of snark and negativity</div><br/></div></div></div></div></div></div></div></div></div></body></html>