<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717664465038" as="style"/><link rel="stylesheet" href="styles.css?v=1717664465038"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://coder.com/blog/delivering-5x-faster-throughput-in-coder-2-12-0">We improved the performance of a userspace TCP stack in Go</a> <span class="domain">(<a href="https://coder.com">coder.com</a>)</span></div><div class="subtext"><span>infomaniac</span> | <span>100 comments</span></div><br/><div><div id="40593526" class="c"><input type="checkbox" id="c-40593526" checked=""/><div class="controls bullet"><span class="by">zxt_tzx</span><span>|</span><a href="#40588669">next</a><span>|</span><label class="collapse" for="c-40593526">[-]</label><label class="expand" for="c-40593526">[2 more]</label></div><br/><div class="children"><div class="content">I met one of the founders of Coder.com, he&#x27;s a really cool dude. It&#x27;s a pity that it is a product aimed more at enterprises than individual developers, else it would have far more developer mindshare.<p>Unlike, say, GitHub Codespaces, running something like this on your own infra means your incentives and Coder.com&#x27;s are aligned, i.e. both of you want to reduce your cloud costs (as opposed to, say, GitHub running on Azure gives them an opportunity and incentive to mark up on Azure cloud costs).</div><br/><div id="40594899" class="c"><input type="checkbox" id="c-40594899" checked=""/><div class="controls bullet"><span class="by">santiagobasulto</span><span>|</span><a href="#40593526">parent</a><span>|</span><a href="#40588669">next</a><span>|</span><label class="collapse" for="c-40594899">[-]</label><label class="expand" for="c-40594899">[1 more]</label></div><br/><div class="children"><div class="content">It seems like a great product. I&#x27;m wondering why they don&#x27;t offer more &quot;startup-oriented&quot; plans. It&#x27;s like either Self Hosted or &quot;Talk to sales&quot;. Is it maybe to not compete against Github codespaces?</div><br/></div></div></div></div><div id="40588669" class="c"><input type="checkbox" id="c-40588669" checked=""/><div class="controls bullet"><span class="by">dpeckett</span><span>|</span><a href="#40593526">prev</a><span>|</span><a href="#40587958">next</a><span>|</span><label class="collapse" for="c-40588669">[-]</label><label class="expand" for="c-40588669">[7 more]</label></div><br/><div class="children"><div class="content">Really cool to see others hacking on netstack, bit of a shame it&#x27;s tied up in the gVisor monorepo (and all the Bazel idiosyncracies) but it&#x27;s a very neat piece of kit.<p>I&#x27;ve actually been hacking on a similar FOSS project lately, with a focus on building what I&#x27;m calling a layer 3 service mesh for the edge. More or less came out of my learned hatred for managing mTLS at scale and my dislike for shoving everything through a L7 proxy (insane protocol complexity, weird bugs, and you still have the issue of authenticating you are actually talking to the proxy you expect).<p>Last week I got the first release of the userspace router shipped, worth taking a look if you want to play around with a completely userspace and unprivileged WireGuard compatible VPN server.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;noisysockets&#x2F;nsh&#x2F;blob&#x2F;main&#x2F;docs&#x2F;router.md">https:&#x2F;&#x2F;github.com&#x2F;noisysockets&#x2F;nsh&#x2F;blob&#x2F;main&#x2F;docs&#x2F;router.md</a></div><br/><div id="40589887" class="c"><input type="checkbox" id="c-40589887" checked=""/><div class="controls bullet"><span class="by">iangudger</span><span>|</span><a href="#40588669">parent</a><span>|</span><a href="#40587958">next</a><span>|</span><label class="collapse" for="c-40589887">[-]</label><label class="expand" for="c-40589887">[6 more]</label></div><br/><div class="children"><div class="content">If you want to use netstack without Bazel, just use the go branch:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;gvisor&#x2F;tree&#x2F;go">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;gvisor&#x2F;tree&#x2F;go</a><p>go get gvisor.dev&#x2F;gvisor&#x2F;pkg&#x2F;tcpip@go<p>The go branch is auto generated with all of the generated code checked in.</div><br/><div id="40591510" class="c"><input type="checkbox" id="c-40591510" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40588669">root</a><span>|</span><a href="#40589887">parent</a><span>|</span><a href="#40592021">next</a><span>|</span><label class="collapse" for="c-40591510">[-]</label><label class="expand" for="c-40591510">[3 more]</label></div><br/><div class="children"><div class="content">I did this once for an experimental project and found it really difficult to keep the version of gVisor I was using up to date, since it seems like the API is extremely volatile. Anyone else had this experience? If so, is there some way around it that I don&#x27;t know? Or did I just try it at a bad point in the development timeline?</div><br/><div id="40592254" class="c"><input type="checkbox" id="c-40592254" checked=""/><div class="controls bullet"><span class="by">iangudger</span><span>|</span><a href="#40588669">root</a><span>|</span><a href="#40591510">parent</a><span>|</span><a href="#40591619">next</a><span>|</span><label class="collapse" for="c-40592254">[-]</label><label class="expand" for="c-40592254">[1 more]</label></div><br/><div class="children"><div class="content">It could be that you happened to find a period of rapid change, but it is also possible that you ran into the issue that raggi mentioned in the sibling comment.</div><br/></div></div><div id="40591619" class="c"><input type="checkbox" id="c-40591619" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#40588669">root</a><span>|</span><a href="#40591510">parent</a><span>|</span><a href="#40592254">prev</a><span>|</span><a href="#40592021">next</a><span>|</span><label class="collapse" for="c-40591619">[-]</label><label class="expand" for="c-40591619">[1 more]</label></div><br/><div class="children"><div class="content">The API is indeed prone to change without notice, but it isn&#x27;t anything terribly unmanageable.<p>&gt; <i>really difficult to keep the version of gVisor I was using up to date</i><p>For our project, we update gvisor whenever Tailscale does.</div><br/></div></div></div></div><div id="40592021" class="c"><input type="checkbox" id="c-40592021" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40588669">root</a><span>|</span><a href="#40589887">parent</a><span>|</span><a href="#40591510">prev</a><span>|</span><a href="#40587958">next</a><span>|</span><label class="collapse" for="c-40592021">[-]</label><label class="expand" for="c-40592021">[2 more]</label></div><br/><div class="children"><div class="content">hey Ian, long time. Is there any chance y&#x27;all could swap out main so that main contains the generated code version?<p>I don&#x27;t know the status on those export tools these days as I left the company years ago, but if they could sync with a different branch.<p>This would help various folks quite a bit, as for example tsnet users often fall into the trap of trying to do `go get -u`, which then pulls a non-functional gvisor version.</div><br/><div id="40592243" class="c"><input type="checkbox" id="c-40592243" checked=""/><div class="controls bullet"><span class="by">iangudger</span><span>|</span><a href="#40588669">root</a><span>|</span><a href="#40592021">parent</a><span>|</span><a href="#40587958">next</a><span>|</span><label class="collapse" for="c-40592243">[-]</label><label class="expand" for="c-40592243">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t work on gVisor anymore. That said, I think it would be a tough sell. It would be a pretty big breaking change. Also, there is already a problem with people trying to send patches against the go branch and making it the default would make that much worse.<p>I think the solution is an automatically exported repository at a different path. Kind of (or maybe exactly) like what Tailscale&#x2F;bradfitz used to maintain.</div><br/></div></div></div></div></div></div></div></div><div id="40587958" class="c"><input type="checkbox" id="c-40587958" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#40588669">prev</a><span>|</span><a href="#40592099">next</a><span>|</span><label class="collapse" for="c-40587958">[-]</label><label class="expand" for="c-40587958">[29 more]</label></div><br/><div class="children"><div class="content">&quot;Asking for elevated permissions inside secure clusters at regulated financial enterprises or top secret government networks is at best a big delay and at worst a nonstarter.&quot;<p>But exfiltrating data with a userspace VPN is totally fine?<p>I&#x27;m also wondering why not use TLS.</div><br/><div id="40588543" class="c"><input type="checkbox" id="c-40588543" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40587958">parent</a><span>|</span><a href="#40592030">next</a><span>|</span><label class="collapse" for="c-40588543">[-]</label><label class="expand" for="c-40588543">[17 more]</label></div><br/><div class="children"><div class="content">Every connection you make to a remote service &quot;exfiltrates data&quot;. Modern TLS is just as opaque to middleboxes as WireGuard is, unless you add security telemetry directly to endpoints --- and then you don&#x27;t care about the network anyways, so just monitor the endpoint.<p>The reason you&#x27;d use WireGuard rather than TLS is that it allows you to talk directly to multiple services, using multiple protocols (most notably, things like Postgres and Redis) without having to build custom serverside &quot;gateways&quot; for each of those protocols.</div><br/><div id="40588868" class="c"><input type="checkbox" id="c-40588868" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588543">parent</a><span>|</span><a href="#40592030">next</a><span>|</span><label class="collapse" for="c-40588868">[-]</label><label class="expand" for="c-40588868">[16 more]</label></div><br/><div class="children"><div class="content">I think the point was more that doing this as a way to avoid the red tape of getting permission to open a new connection is odd?</div><br/><div id="40588944" class="c"><input type="checkbox" id="c-40588944" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588868">parent</a><span>|</span><a href="#40592030">next</a><span>|</span><label class="collapse" for="c-40588944">[-]</label><label class="expand" for="c-40588944">[15 more]</label></div><br/><div class="children"><div class="content">I understand the impulse, but I think it misconstrues the &quot;red tape&quot; this method avoids. It&#x27;s sidestepping a quirky OS limitation, which dates back to an era of &quot;privileged ports&quot; and multi-user machines. It&#x27;s not really sidestepping any sort of modern policy boundary. For instance: you could do the exact same thing with WebSockets (and people do).</div><br/><div id="40589202" class="c"><input type="checkbox" id="c-40589202" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588944">parent</a><span>|</span><a href="#40591966">next</a><span>|</span><label class="collapse" for="c-40589202">[-]</label><label class="expand" for="c-40589202">[2 more]</label></div><br/><div class="children"><div class="content">I was thinking websockets; though, I thought those largely hit the same criticisms?  That is, tons of things moved to them specifically to avoid any firewall rules about what they were allowed to send over a network.<p>I&#x27;ll fully grant that that seems to be the norm for everything browser related.  Policies got difficult to install new software, just point your browser to this url and call it a day.</div><br/><div id="40591869" class="c"><input type="checkbox" id="c-40591869" checked=""/><div class="controls bullet"><span class="by">mindcrime</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40589202">parent</a><span>|</span><a href="#40591966">next</a><span>|</span><label class="collapse" for="c-40591869">[-]</label><label class="expand" for="c-40591869">[1 more]</label></div><br/><div class="children"><div class="content"><i>I was thinking websockets; though, I thought those largely hit the same criticisms? That is, tons of things moved to them specifically to avoid any firewall rules about what they were allowed to send over a network.</i><p>Arguably, this basic phenomenon has been going on for 20+ years. A lot of people by 2005-2007 or so had come to belive (and probably correctly) that a lot of the impetus for adopting SOAP based web-services over the preceding few years was simply because everything ran over ports 80 and 443 which were already open in the firewall. So deploying a remote service this way was more tractable than submitting a request to allow access to yet another port in firewall, and deal with the inevitable bureaucratic nightmare of getting that approved.</div><br/></div></div></div></div><div id="40591966" class="c"><input type="checkbox" id="c-40591966" checked=""/><div class="controls bullet"><span class="by">Xelynega</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588944">parent</a><span>|</span><a href="#40589202">prev</a><span>|</span><a href="#40592030">next</a><span>|</span><label class="collapse" for="c-40591966">[-]</label><label class="expand" for="c-40591966">[12 more]</label></div><br/><div class="children"><div class="content">You can also sidestep that &quot;quirky OS limitation&quot; by just setting the first unprivileged port to 0(ip_unprivileged_port_start), no need for an new stack.<p><a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;networking&#x2F;ip-sysctl.txt" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;networking&#x2F;ip-sysct...</a></div><br/><div id="40591986" class="c"><input type="checkbox" id="c-40591986" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40591966">parent</a><span>|</span><a href="#40591998">next</a><span>|</span><label class="collapse" for="c-40591986">[-]</label><label class="expand" for="c-40591986">[7 more]</label></div><br/><div class="children"><div class="content">You can do that. Random programs cannot. Our CLI, which also does user-mode WireGuard and TCP&#x2F;IP, doesn&#x27;t even want to run under sudo. You&#x27;re seeing the point, now: you want to build interesting network features that work the same way everywhere without demanding that your users be system administrators. Hence: user-mode TCP&#x2F;IP.</div><br/><div id="40592123" class="c"><input type="checkbox" id="c-40592123" checked=""/><div class="controls bullet"><span class="by">Xelynega</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40591986">parent</a><span>|</span><a href="#40591998">next</a><span>|</span><label class="collapse" for="c-40592123">[-]</label><label class="expand" for="c-40592123">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still not seeing the point sadly.<p>If you&#x27;re running on a system you don&#x27;t administrate that has ports under 1024 set as privileged, there&#x27;s no way(with or without your cli) to have a userspace program receive TCP or UDP packets coming into the kernel from external devices for these ports(unless I&#x27;m completely mistaken).<p>What can you accomplish with &quot;user-mode TCP&#x2F;IP&quot; that you can&#x27;t from userspace with system calls?</div><br/><div id="40592151" class="c"><input type="checkbox" id="c-40592151" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40592123">parent</a><span>|</span><a href="#40591998">next</a><span>|</span><label class="collapse" for="c-40592151">[-]</label><label class="expand" for="c-40592151">[5 more]</label></div><br/><div class="children"><div class="content">You are completely mistaken. You can do literally anything you want with TCP&#x2F;IP provided you can talk UDP on any port, by running a user-mode TCP&#x2F;IP stack over WireGuard on that port.</div><br/><div id="40592173" class="c"><input type="checkbox" id="c-40592173" checked=""/><div class="controls bullet"><span class="by">Xelynega</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40592151">parent</a><span>|</span><a href="#40591998">next</a><span>|</span><label class="collapse" for="c-40592173">[-]</label><label class="expand" for="c-40592173">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you understand, and based on your reply it doesn&#x27;t sound like I&#x27;m mistaken.<p>With this CLI I am able to listen for external packets to port 80 from userspace without any elevated permissions and intercept traffic that&#x27;s going to an application that&#x27;s bound to that port on the OS?<p>Edit: I think I understand what you&#x27;re trying to do, but if I do then traffic is going from the kernel UDP stack to the userland TCP stack, back to the UDP kernel stack. Not sure how that avoids sending the packet to the kernel. If it&#x27;s to get around the port restrictions, why can you not just use unprivileged ports?</div><br/><div id="40592213" class="c"><input type="checkbox" id="c-40592213" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40592173">parent</a><span>|</span><a href="#40591998">next</a><span>|</span><label class="collapse" for="c-40592213">[-]</label><label class="expand" for="c-40592213">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I can make this any simpler for you or easier to get your head around. If it helps: the idea here is <i>giving an invocation of your program its own IP address</i>. It can then do whatever it likes with TCP&#x2F;IP for that address; its own routing, arbitrary protocols, whatever. The Go standard library makes it extremely easy to integrate. To the OS, it&#x27;s all just ordinary socket code.</div><br/><div id="40592923" class="c"><input type="checkbox" id="c-40592923" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40592213">parent</a><span>|</span><a href="#40591998">next</a><span>|</span><label class="collapse" for="c-40592923">[-]</label><label class="expand" for="c-40592923">[2 more]</label></div><br/><div class="children"><div class="content">I think it is a valid question on why not use unprivileged ports, though?  Or am I also missing something?</div><br/><div id="40593116" class="c"><input type="checkbox" id="c-40593116" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40592923">parent</a><span>|</span><a href="#40591998">next</a><span>|</span><label class="collapse" for="c-40593116">[-]</label><label class="expand" for="c-40593116">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Unprivileged ports&quot; is just a case in point for everything you would need privileges to do, from binding arbitrary ports to adding arbitrary addresses and running local servers on them, etc, etc, etc. The point is: turning &quot;complicated&quot; network features that require privilege into simple unprivileged socket code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40591998" class="c"><input type="checkbox" id="c-40591998" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40591966">parent</a><span>|</span><a href="#40591986">prev</a><span>|</span><a href="#40592052">next</a><span>|</span><label class="collapse" for="c-40591998">[-]</label><label class="expand" for="c-40591998">[1 more]</label></div><br/><div class="children"><div class="content">Getting that change onto the system sounds like &quot;at best a big delay and at worst a nonstarter&quot;.</div><br/></div></div><div id="40592052" class="c"><input type="checkbox" id="c-40592052" checked=""/><div class="controls bullet"><span class="by">nonameiguess</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40591966">parent</a><span>|</span><a href="#40591998">prev</a><span>|</span><a href="#40592030">next</a><span>|</span><label class="collapse" for="c-40592052">[-]</label><label class="expand" for="c-40592052">[3 more]</label></div><br/><div class="children"><div class="content">When they&#x27;re talking about classified defense networks, the actual restrictions they mean is least privilege and separation of duties. Devs are not admins. They don&#x27;t get root privilege on their machines. They can&#x27;t create virtual network interfaces and they also can&#x27;t change kernel settings. But if you put a full TCP&#x2F;IP stack in userspace, well, they can run that and do whatever they want with it.<p>To answer the upstream question about why arbitary outbound connections are allowed, they&#x27;re not. This is connecting to a cloud development environment, and I would have to assume this service can be self-hosted, because on a classified network, the &quot;cloud&quot; isn&#x27;t the cloud as Hacker News readers know it. Amazon et all run private data centers on US military installations that only the military and the IC can access and they&#x27;re airgapped from the Internet. If you&#x27;re on a workstation that can access this environment, that&#x27;s all it can access. The only place you can exfiltrate data to is other military-controlled servers.</div><br/><div id="40592156" class="c"><input type="checkbox" id="c-40592156" checked=""/><div class="controls bullet"><span class="by">Xelynega</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40592052">parent</a><span>|</span><a href="#40592030">next</a><span>|</span><label class="collapse" for="c-40592156">[-]</label><label class="expand" for="c-40592156">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re talking about developer machines, isn&#x27;t the best(and easiest) solution to just run a VM that you administer so you can create virtual networks?<p>If you&#x27;re talking about production machines, a userspace application wouldn&#x27;t be able to sniff privileged ports without elevated permissions, so I fail to see how this application would let you get around that limitation.</div><br/><div id="40592220" class="c"><input type="checkbox" id="c-40592220" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40592156">parent</a><span>|</span><a href="#40592030">next</a><span>|</span><label class="collapse" for="c-40592220">[-]</label><label class="expand" for="c-40592220">[1 more]</label></div><br/><div class="children"><div class="content">No, because VMs are expensive and require some base level of system administration to operate, booting them usually requires privilege, and if the only problem you&#x27;re trying to solve is reliably running (e.g.) Postgres and Redis protocol between your CLI and a server somewhere, it&#x27;s extreme overkill.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40592030" class="c"><input type="checkbox" id="c-40592030" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#40587958">parent</a><span>|</span><a href="#40588543">prev</a><span>|</span><a href="#40592031">next</a><span>|</span><label class="collapse" for="c-40592030">[-]</label><label class="expand" for="c-40592030">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t control what information flows through an outbound connection, not even in trivial cases. Even if you straight go ahead and say &quot;I allow you to make this connection, but I&#x27;m not even allowing you to send any data&quot;, you have timing sidechannels to deal with. In any more reasonable case, an almost infinite number of things can be used to exfiltrate any data you want, even if you think you have not only full application-level inspection, but even application-level <i>rewrite</i>.<p>Pretty much the only thing you can do is somewhat filter out known-bad, not directly motivated outbound traffic, such as malware payloads with very clear signatures. This only works if it&#x27;s &quot;not directly motivated&quot;, because as soon as there&#x27;s a person who <i>wants</i> to do it, they can skirt around it again.</div><br/></div></div><div id="40592031" class="c"><input type="checkbox" id="c-40592031" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40587958">parent</a><span>|</span><a href="#40592030">prev</a><span>|</span><a href="#40587994">next</a><span>|</span><label class="collapse" for="c-40592031">[-]</label><label class="expand" for="c-40592031">[1 more]</label></div><br/><div class="children"><div class="content">fwiw, you technically don&#x27;t need a privileged container to use tun, you just need suitable permissions on the kernel tun interfaces.</div><br/></div></div><div id="40587994" class="c"><input type="checkbox" id="c-40587994" checked=""/><div class="controls bullet"><span class="by">tazjin</span><span>|</span><a href="#40587958">parent</a><span>|</span><a href="#40592031">prev</a><span>|</span><a href="#40592099">next</a><span>|</span><label class="collapse" for="c-40587994">[-]</label><label class="expand" for="c-40587994">[9 more]</label></div><br/><div class="children"><div class="content">Yeah, the optimisations are cool of course, but (maybe due to being unfamiliar with the tool?!) I didn&#x27;t understand why they can&#x27;t just `listen(2)`.</div><br/><div id="40588053" class="c"><input type="checkbox" id="c-40588053" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40587994">parent</a><span>|</span><a href="#40592099">next</a><span>|</span><label class="collapse" for="c-40588053">[-]</label><label class="expand" for="c-40588053">[8 more]</label></div><br/><div class="children"><div class="content">It’s answered in the opening paragraph although I’ll admit I’m still unclear.<p>&gt; We are committed to keeping your data safe through end-to-end encryption and to making Coder easy to run across a wide variety of systems from client laptops and desktops to VMs, containers, and bare metal. If we used the TCP implementation in the OS, we’d need a way for the TCP packets to get from the operating system back into Coder for encryption. This is called a TUN device in unix-style operating systems and creating one requires elevated permissions, limiting who can run Coder and where. Asking for elevated permissions inside secure clusters at regulated financial enterprises or top secret government networks is at best a big delay and at worst a nonstarter.<p>The specific part that’s unclear is why encryption needs to be applied at the TCP layer and at that point if they need it at the transport layer why they’re not using something like QUIC which has a much more mature user-space implementation.</div><br/><div id="40588871" class="c"><input type="checkbox" id="c-40588871" checked=""/><div class="controls bullet"><span class="by">dpeckett</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588053">parent</a><span>|</span><a href="#40592046">next</a><span>|</span><label class="collapse" for="c-40588871">[-]</label><label class="expand" for="c-40588871">[1 more]</label></div><br/><div class="children"><div class="content">I think the key insight behind this approach (and I&#x27;m biased here having written something similar) is that the difference between QUIC and (wireguard + network stack) is A LOT less than you might think.</div><br/></div></div><div id="40592046" class="c"><input type="checkbox" id="c-40592046" checked=""/><div class="controls bullet"><span class="by">Xelynega</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588053">parent</a><span>|</span><a href="#40588871">prev</a><span>|</span><a href="#40588408">next</a><span>|</span><label class="collapse" for="c-40592046">[-]</label><label class="expand" for="c-40592046">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused on why they would need a TUN device for a client or server application, so why they would need this solution in the first place(even with their explanation).<p>As I understand the only reason you&#x27;d use a TUN interface is if you want to send&#x2F;receive raw IP packets. Their marketing doesn&#x27;t make it very clear what their product does, but I can&#x27;t see a reason it would need to send&#x2F;receive raw IP packets rather than TCP&#x2F;UDP packets over a specific port...</div><br/></div></div><div id="40588408" class="c"><input type="checkbox" id="c-40588408" checked=""/><div class="controls bullet"><span class="by">cricketlover</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588053">parent</a><span>|</span><a href="#40592046">prev</a><span>|</span><a href="#40588206">next</a><span>|</span><label class="collapse" for="c-40588408">[-]</label><label class="expand" for="c-40588408">[1 more]</label></div><br/><div class="children"><div class="content">Agree. Very unclear why they won&#x27;t simply use a secure socket or why a user space tunnel will be needed.<p>I surmise that the reason might be that a user space tunnel might be faster (like maybe they can do UDP over TCP or something to gain speed improvements).<p>Good post nevertheless.</div><br/></div></div><div id="40588206" class="c"><input type="checkbox" id="c-40588206" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588053">parent</a><span>|</span><a href="#40588408">prev</a><span>|</span><a href="#40588319">next</a><span>|</span><label class="collapse" for="c-40588206">[-]</label><label class="expand" for="c-40588206">[1 more]</label></div><br/><div class="children"><div class="content">Or TLS. It seems to be a remote cloud desktop type of product, so why not use TLS like every other one?</div><br/></div></div><div id="40588319" class="c"><input type="checkbox" id="c-40588319" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588053">parent</a><span>|</span><a href="#40588206">prev</a><span>|</span><a href="#40592099">next</a><span>|</span><label class="collapse" for="c-40588319">[-]</label><label class="expand" for="c-40588319">[3 more]</label></div><br/><div class="children"><div class="content">The quote - is this yet another issue caused by abysmal FFI overhead in Go?</div><br/><div id="40590668" class="c"><input type="checkbox" id="c-40590668" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588319">parent</a><span>|</span><a href="#40588343">next</a><span>|</span><label class="collapse" for="c-40590668">[-]</label><label class="expand" for="c-40590668">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;12nt2le&#x2F;when_dealing_with_c_when_is_go_slow&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;12nt2le&#x2F;when_dealin...</a><p>If your C doesn&#x27;t fight the scheduler it isn&#x27;t that bad.</div><br/></div></div><div id="40588343" class="c"><input type="checkbox" id="c-40588343" checked=""/><div class="controls bullet"><span class="by">tazjin</span><span>|</span><a href="#40587958">root</a><span>|</span><a href="#40588319">parent</a><span>|</span><a href="#40590668">prev</a><span>|</span><a href="#40592099">next</a><span>|</span><label class="collapse" for="c-40588343">[-]</label><label class="expand" for="c-40588343">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing related to FFI calls in this quote.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40592099" class="c"><input type="checkbox" id="c-40592099" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40587958">prev</a><span>|</span><a href="#40588582">next</a><span>|</span><label class="collapse" for="c-40592099">[-]</label><label class="expand" for="c-40592099">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s great to see this, I know the team went on a long journey through this and the blog makes it almost look shorter and simpler than it was. I&#x27;m hoping one day we can all integrate the support for GSO that&#x27;s been landing in gvisor too, but so far we&#x27;ve (tailscale) not had a chance to look deeply into that yet. It was really effective for our tun and UDP interfaces though.</div><br/><div id="40592495" class="c"><input type="checkbox" id="c-40592495" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#40592099">parent</a><span>|</span><a href="#40588582">next</a><span>|</span><label class="collapse" for="c-40592495">[-]</label><label class="expand" for="c-40592495">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>one day we can all integrate the support for GSO that&#x27;s been landing in gvisor</i><p>Google engs recently rewrote the GSO bit, but unlike Tailscale, it is only for TCP, though.<p>Besides, gvisor has had &quot;software&quot; &amp; &quot;hardware&quot; GSO support for as long as I can remember.</div><br/></div></div></div></div><div id="40588582" class="c"><input type="checkbox" id="c-40588582" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40592099">prev</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40588582">[-]</label><label class="expand" for="c-40588582">[34 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know anything about Coder, but Gvisor proliferation is annoying. It&#x27;s a boon for cloud providers, helping them find another way to get a large multiple performance decrease per dollar spent in exchange for questionable security benefits. And I&#x27;m seeing it everywhere now.</div><br/><div id="40590873" class="c"><input type="checkbox" id="c-40590873" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#40588582">parent</a><span>|</span><a href="#40588958">next</a><span>|</span><label class="collapse" for="c-40590873">[-]</label><label class="expand" for="c-40590873">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand - what do you suggest as an alternative to Gvisor?<p>&gt; large multiple performance decrease per dollar spent<p>Gvisor helps you offer multi-tenant products which can be actually much cheaper to operate and offer to customers, especially when their usage is lower than a single VM would require. Also, a lot of applications won&#x27;t see big performance hits from running under Gvisor depending on their resource requirements and perf bottlenecks.</div><br/><div id="40593046" class="c"><input type="checkbox" id="c-40593046" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40590873">parent</a><span>|</span><a href="#40588958">next</a><span>|</span><label class="collapse" for="c-40593046">[-]</label><label class="expand" for="c-40593046">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t understand - what do you suggest as an alternative to Gvisor?<p>Their performance documents you linked claim vs runc: 20-40x syscall overhead, half of redis&#x27; QPS, and a 20% increase in runtime in a sample tenserflow script. Also google &quot;CloudRun slow&quot; and &quot;Digital Ocean Apps slow&quot;, both are Gvisor.<p>Literally anything else.</div><br/><div id="40593453" class="c"><input type="checkbox" id="c-40593453" checked=""/><div class="controls bullet"><span class="by">amscanne</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40593046">parent</a><span>|</span><a href="#40588958">next</a><span>|</span><label class="collapse" for="c-40593453">[-]</label><label class="expand" for="c-40593453">[3 more]</label></div><br/><div class="children"><div class="content">A decent while ago, I was the original author of that performance guide. I tried to lay out the set of performance trade-offs in an objective and realistic way. It is shocking to me that you’re spending so much time commenting on a few figures from there, ostensibly w&#x2F;o reading it.<p>System call overhead does matter, but it’s not the ultimate measure of anything. If it were, gVisor with the KVM platform would be <i>faster</i> than native containers (looking at the runsc-kvm data point which you’ve ignored for an unknown reason). But it is obviously more complex than that alone. For example, let’s click down and ask — how is it even possible to be faster? The default docker seccomp profile itself installs an eBPF filter that slows system calls by 20x! (And this path does not apply within the guest context.) On that basis, should you start shouting that everyone should stop using Docker because of the system call overhead? I would hope not, because looking at any one figure in isolation is dumb — consider the overall application and architecture. Containers themselves have a cost (higher context switch time due to cgroup accounting, costs to devirtualize namespaces in many system calls, etc.) but it’s obviously worth it in most cases.<p>The redis case is called out as a worst case — the application itself does very little beyond dispatching I&#x2F;O, so almost everything manifests as overhead. But if you’re doing something that has 20% overhead, you need hard security boundaries, and fine-grained multi-tenancy can lower costs by 80% it might make perfect sense. If something doesn’t work for <i>you</i> because your trade-offs are different, just don’t use it!</div><br/><div id="40593643" class="c"><input type="checkbox" id="c-40593643" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40593453">parent</a><span>|</span><a href="#40588958">next</a><span>|</span><label class="collapse" for="c-40593643">[-]</label><label class="expand" for="c-40593643">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it is shocking to me that you’re spending so much time commenting on a few figures from there<p>You give me too much credit! They were copy pastes to the same responder who responded to me in a few places in the thread. I did that to avoid spending too much time responding!<p>&gt; because looking at any one figure in isolation is dumb<p>So the self-reported performance figures are bad, the are hundreds of web pages and support pages reporting slow performance and low startup time from their first hand experience, there are Google hosted documentation pages about how to improve app performance for cloudrun (probably the largest user and creators of Gvisor, can I assume they know how to run it?) including gems like &quot;delete temporary files&quot; and a blog post recommending &quot;using global variables&quot; (I&#x27;m not joking). And the accusation is &quot;dumb&quot; cherry-picking? Huh?<p>Also, if I&#x27;m not wrong CloudRun GCP&#x27;s main (only? besides managed K8s) PaaS container runtime. Presenting it as a general container runtime with ultra fast scaling when people online are reporting 30 second startup times for basic python&#x2F;node apps, is a joke. These tradeoffs should also be highlighted somewhere in these sales pages, but they&#x27;re not.<p>This is the last I&#x27;m responding to this thread. Also my apologies to the Coder folks for going off topic like this.</div><br/><div id="40593911" class="c"><input type="checkbox" id="c-40593911" checked=""/><div class="controls bullet"><span class="by">amscanne</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40593643">parent</a><span>|</span><a href="#40588958">next</a><span>|</span><label class="collapse" for="c-40593911">[-]</label><label class="expand" for="c-40593911">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think copy&#x2F;pasting the same response everywhere is better.<p>IIRC, CloudRun has multiple modes of operation (fully-managed and in a K8s cluster) and different sandboxes for the fully-managed environment (VM-based and gVisor-based). Like everything, performance depends a lot of the specifics — for example, the network depends a lot more on the network path (e.g. are
you using a VPC connector?) than it does the specific sandbox or network stack (i.e. if you want to push 40gbps, spin up a dedicated GCE instance.) Similarly, the lack of a persistent disk is a design choice for multiple reasons — if you need a lot of non-tmpfs disk or persistent state, CloudRun might not be the right place for the service.<p>It sounds like you personally had a bad experience or hit a sharp edge, which sucks and I empathize — but I think you can just be concrete about that rather than projecting with system call times (I’d be happy to give you the reason gen1 sandbox would be slow for a typical heavy python app doing 20,000 stats on startup — and it’s real but not really system calls or anything you’re pointing at,… either way you could just turn on gen2 or use other products, e.g. GCE containers, GKE autopilot, etc.).<p>I’m not sure what’s wrong with advice re: optimizing for a serverless platform (like global variables). I don’t really think it would be sensible to recompute&#x2F;rebuild application state on any serverless platform on any provider.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40588958" class="c"><input type="checkbox" id="c-40588958" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">parent</a><span>|</span><a href="#40590873">prev</a><span>|</span><a href="#40588906">next</a><span>|</span><label class="collapse" for="c-40588958">[-]</label><label class="expand" for="c-40588958">[17 more]</label></div><br/><div class="children"><div class="content">Are you referring to gVisor the container runtime, or gVisor&#x2F;netstack, the TCP&#x2F;IP stack? I see more uptick in netstack. I don&#x27;t see proliferation of gVisor itself. &quot;Security&quot; is much more salient to gVisor than it is to netstack.</div><br/><div id="40590140" class="c"><input type="checkbox" id="c-40590140" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40588958">parent</a><span>|</span><a href="#40588906">next</a><span>|</span><label class="collapse" for="c-40590140">[-]</label><label class="expand" for="c-40590140">[16 more]</label></div><br/><div class="children"><div class="content">In the issue of abysmal performance on cloud-compute&#x2F;PaaS Im talking about the container runtime (most Paas is gVisor or Firecracker, no?) cloudrun, DO, modal, etc.<p>But given this article is about improving gvisors userland tcp performance significantly, it seems like the netstack stuff causes major performance losses too.<p>I saw a github link in another top article today <a href="https:&#x2F;&#x2F;github.com&#x2F;misprit7&#x2F;computerraria">https:&#x2F;&#x2F;github.com&#x2F;misprit7&#x2F;computerraria</a> where the Readme&#x27;s Pitch section feels very relevant to gvisor.</div><br/><div id="40591147" class="c"><input type="checkbox" id="c-40591147" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40590140">parent</a><span>|</span><a href="#40593583">next</a><span>|</span><label class="collapse" for="c-40591147">[-]</label><label class="expand" for="c-40591147">[6 more]</label></div><br/><div class="children"><div class="content">I don’t believe many PAAS run gVisor; a surprising number just run multitenant docker.<p>The netstack stuff here has nothing to do with the rest of gVisor.</div><br/><div id="40591845" class="c"><input type="checkbox" id="c-40591845" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40591147">parent</a><span>|</span><a href="#40593583">next</a><span>|</span><label class="collapse" for="c-40591845">[-]</label><label class="expand" for="c-40591845">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The netstack stuff here has nothing to do with the rest of gVisor.<p>How so? Besides being part of it, it is at least similar in the group of &quot;bloated slow userland implementation of things the kernel handles well&quot;</div><br/><div id="40591872" class="c"><input type="checkbox" id="c-40591872" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40591845">parent</a><span>|</span><a href="#40593583">next</a><span>|</span><label class="collapse" for="c-40591872">[-]</label><label class="expand" for="c-40591872">[4 more]</label></div><br/><div class="children"><div class="content">A TCP&#x2F;IP stack is not an &quot;implementation of syscalls&quot;. The things most netstack users do with netstack have nothing to do with wanting to move the kernel into userland and everything to do with the fact that the kernel features they want to access are either privileged or (in a lot of IP routing cases) not available at all. Netstack (like any user-mode IP stack) allows programs to do things they couldn&#x27;t otherwise do at all.<p>The gVisor&#x2F;perf thing is a tendentious argument. You can have whatever opinion you like about whether running a platform under gVisor supervision is a good idea. But the post we&#x27;re commenting on is obviously not about gVisor; it&#x27;s about a library inside of gVisor that is probably a lot more popular than gVisor itself.</div><br/><div id="40592072" class="c"><input type="checkbox" id="c-40592072" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40591872">parent</a><span>|</span><a href="#40593583">next</a><span>|</span><label class="collapse" for="c-40592072">[-]</label><label class="expand" for="c-40592072">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The gVisor&#x2F;perf thing is a tendentious argument<p>Interesting to dismiss it as such. The gvisor netstack is a (big) part of gvisor and this article is discussing how the performance of that component was, and could well still be, garbage.<p>These tools bring marginal capability and performance gains, shoved down peoples throat by manufacturing security paranoia. Oh an it all happens to cost you like 10x time, but look at the shiny capabilities, trust me it couldn&#x27;t be done before! A netsec and infra peddlers wet dream.</div><br/><div id="40594815" class="c"><input type="checkbox" id="c-40594815" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592072">parent</a><span>|</span><a href="#40592146">next</a><span>|</span><label class="collapse" for="c-40594815">[-]</label><label class="expand" for="c-40594815">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The gvisor netstack ... this article is discussing how the performance of that component was ... garbage.</i><p>The article and a related GitHub discussion (linked from TFA) points out that the default congestion algorithm (reno) wasn&#x27;t good for long-distance (over Internet) workloads. The gvisor team never noticed it because they test&#x2F;tune for in-datacenter usecases.<p>&gt; <i>These tools bring marginal capability and performance gains</i><p>I get your point (ex: app sandbox in Android ruins battery &amp; perf, website sandbox on chrome wastes memory, etc). While 0-days continue to sell for millions, opsec are right to be skeptical about a very critical component (kernel) that runs on 50%+ of all servers &amp; personal devices.</div><br/></div></div><div id="40592146" class="c"><input type="checkbox" id="c-40592146" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592072">parent</a><span>|</span><a href="#40594815">prev</a><span>|</span><a href="#40593583">next</a><span>|</span><label class="collapse" for="c-40592146">[-]</label><label class="expand" for="c-40592146">[1 more]</label></div><br/><div class="children"><div class="content">None of this has anything to do with security paranoia.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40593583" class="c"><input type="checkbox" id="c-40593583" checked=""/><div class="controls bullet"><span class="by">shanemhansen</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40590140">parent</a><span>|</span><a href="#40591147">prev</a><span>|</span><a href="#40592377">next</a><span>|</span><label class="collapse" for="c-40593583">[-]</label><label class="expand" for="c-40593583">[1 more]</label></div><br/><div class="children"><div class="content">Google is my former employer and this statement isn&#x27;t referring to stuff I heard while employed there.<p>But after I left, I heard a that alot of the poor performance of Cloud Run is just plain old oversubscribed shared core e2 stuff.</div><br/></div></div><div id="40592377" class="c"><input type="checkbox" id="c-40592377" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40590140">parent</a><span>|</span><a href="#40593583">prev</a><span>|</span><a href="#40588906">next</a><span>|</span><label class="collapse" for="c-40592377">[-]</label><label class="expand" for="c-40592377">[8 more]</label></div><br/><div class="children"><div class="content">In the context of coder, the userspace TCP overhead should be negligible. Based on <a href="https:&#x2F;&#x2F;gvisor.dev&#x2F;docs&#x2F;architecture_guide&#x2F;performance&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gvisor.dev&#x2F;docs&#x2F;architecture_guide&#x2F;performance&#x2F;</a> and assuming runc is mostly just using the regular kernel networking stack (I think it does, since it mostly just does syscall filtering?) it should be at most a 30% direct TCP performance hit. But in a real application you typically only spend a negligible amount of total time in the TCP stack - the client code, total e2e latency, and server code corresponding to a particular packet will take much more time.<p>You&#x27;ll note their node&#x2F;ruby benchmarks showed a substantially bigger performance hit. That&#x27;s because the other gvisor sandboxing functionality (general syscall + file I&#x2F;O) has more of an impact on performance, but also because these are network-processing bound applications (rare) that were still reaching high QPS in absolute terms for their perspective runtimes (do you know many real-world node apps doing 350qps-800qps per instance?).<p>Because coder is not likely to be bottlenecked by CPU availability for networking, the resource overhead should be inconsequential, and what&#x27;s really important is the impact on user latency. But that&#x27;s something likely on the order of 1ms for a roundtrip that is already spending probably 30-50ms at best in transit between client and server (given that coder&#x27;s server would be running in a datacenter with clients at home or the office), plus the actual application logic overhead which is at best 10ms. And that&#x27;s very similar to a lot of gvisor netstack use cases which is why it&#x27;s not as big of a deal as you think it is.<p>TLDR: For the stuff you&#x27;d actually care about (roundtrip latency) in the coder usecase the perf hit of using gvisor netstack should be like 2% at most, and most likely much less. Either way it&#x27;s small enough to be imperceivable to the actual human using the client.</div><br/><div id="40592934" class="c"><input type="checkbox" id="c-40592934" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592377">parent</a><span>|</span><a href="#40592398">next</a><span>|</span><label class="collapse" for="c-40592934">[-]</label><label class="expand" for="c-40592934">[5 more]</label></div><br/><div class="children"><div class="content">TCP overhead is part of the story. Theres 20-40x overhead in syscalls, 20% running a tensorflow project end to end, 50% fewer RPS in redis, etc.</div><br/><div id="40593111" class="c"><input type="checkbox" id="c-40593111" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592934">parent</a><span>|</span><a href="#40592398">next</a><span>|</span><label class="collapse" for="c-40593111">[-]</label><label class="expand" for="c-40593111">[4 more]</label></div><br/><div class="children"><div class="content">We are still talking about people using runsc&#x2F;runc. That&#x27;s not what `coder` is doing. All they did was poach a (popular) networking library from the gVisor codebase. None of this benchmarking has anything to do with their product.</div><br/><div id="40593532" class="c"><input type="checkbox" id="c-40593532" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40593111">parent</a><span>|</span><a href="#40592398">next</a><span>|</span><label class="collapse" for="c-40593532">[-]</label><label class="expand" for="c-40593532">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve already accepted this whole thread is a digression, but I keep getting pulled in. Calling out my dislike for Gvisor on a thread lauding a 5x tcp performance they found in it felt on topic to me at the time.</div><br/><div id="40593716" class="c"><input type="checkbox" id="c-40593716" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40593532">parent</a><span>|</span><a href="#40592398">next</a><span>|</span><label class="collapse" for="c-40593716">[-]</label><label class="expand" for="c-40593716">[2 more]</label></div><br/><div class="children"><div class="content">Ok. I&#x27;m only triggered by two things:<p>1. An argument that a tool using netstack is in any way tainted with gVisor&#x27;s runtime costs.<p>2. An argument that shared-kernel multitenant is tenable and thus gVisor addresses no meaningful security concerns.</div><br/><div id="40593984" class="c"><input type="checkbox" id="c-40593984" checked=""/><div class="controls bullet"><span class="by">demi56</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40593716">parent</a><span>|</span><a href="#40592398">next</a><span>|</span><label class="collapse" for="c-40593984">[-]</label><label class="expand" for="c-40593984">[1 more]</label></div><br/><div class="children"><div class="content">Not gonna lie am also getting 200% triggered whenever he states gVisor Syscall costs lol</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40592398" class="c"><input type="checkbox" id="c-40592398" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592377">parent</a><span>|</span><a href="#40592934">prev</a><span>|</span><a href="#40588906">next</a><span>|</span><label class="collapse" for="c-40592398">[-]</label><label class="expand" for="c-40592398">[2 more]</label></div><br/><div class="children"><div class="content">Are they even using runc&#x2F;runsc?</div><br/><div id="40592422" class="c"><input type="checkbox" id="c-40592422" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592398">parent</a><span>|</span><a href="#40588906">next</a><span>|</span><label class="collapse" for="c-40592422">[-]</label><label class="expand" for="c-40592422">[1 more]</label></div><br/><div class="children"><div class="content">At coder, no since &quot;gVisor is a container runtime that reimplements the entire Linux ABI (syscalls) in Go, but we only need the networking for our purposes&quot;<p>but gvisor was using full runsc for the networking benchmarks I linked, and IIUC runc&#x27;s networking should be sufficiently similar to unsandboxed networking that I believe runsc&lt;-&gt;runc network performance difference should approximate gvisor netstack&lt;-&gt;vanilla kernel networking.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40588906" class="c"><input type="checkbox" id="c-40588906" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40588582">parent</a><span>|</span><a href="#40588958">prev</a><span>|</span><a href="#40589930">next</a><span>|</span><label class="collapse" for="c-40588906">[-]</label><label class="expand" for="c-40588906">[1 more]</label></div><br/><div class="children"><div class="content">There are still products from cloud providers that don&#x27;t use gvisor. Basics like EC2 or GCE. Sounds like you chose the wrong cloud product.</div><br/></div></div><div id="40589930" class="c"><input type="checkbox" id="c-40589930" checked=""/><div class="controls bullet"><span class="by">loosescrews</span><span>|</span><a href="#40588582">parent</a><span>|</span><a href="#40588906">prev</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40589930">[-]</label><label class="expand" for="c-40589930">[10 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on your concern? Is the issue that you don&#x27;t trust gVisor to keep the cloud provider secure?</div><br/><div id="40590320" class="c"><input type="checkbox" id="c-40590320" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40589930">parent</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40590320">[-]</label><label class="expand" for="c-40590320">[9 more]</label></div><br/><div class="children"><div class="content">Providers managed secure shared environments for decades before ultra inefficient wrappers and runtimes like gVisor existed.</div><br/><div id="40591786" class="c"><input type="checkbox" id="c-40591786" checked=""/><div class="controls bullet"><span class="by">lima</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40590320">parent</a><span>|</span><a href="#40592231">next</a><span>|</span><label class="collapse" for="c-40591786">[-]</label><label class="expand" for="c-40591786">[1 more]</label></div><br/><div class="children"><div class="content">OpenVZ, Virtuozzo and friends definitely weren&#x27;t secure the way gVisor or Firecracker are. You can still do that and some providers do, doesn&#x27;t make it a good idea.</div><br/></div></div><div id="40592231" class="c"><input type="checkbox" id="c-40592231" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40590320">parent</a><span>|</span><a href="#40591786">prev</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40592231">[-]</label><label class="expand" for="c-40592231">[7 more]</label></div><br/><div class="children"><div class="content">No. The providers that did so soundly used virtualization to accomplish this, and a big part of the appeal of K8s is having a much lightweight unit of scheduling than full virtualization. gVisor is a middle ground between full virtualization and shared-kernel multitenant (which has an abysmal security track record).</div><br/><div id="40592353" class="c"><input type="checkbox" id="c-40592353" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592231">parent</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40592353">[-]</label><label class="expand" for="c-40592353">[6 more]</label></div><br/><div class="children"><div class="content">Virtualization, lxc, containers (and K8s), etc were solutions to &quot;secure shared environments&quot;. And they have an order of magnitude lower performance hit than gvisor does (Google &#x27;cloudrun python startup times&#x27; if you&#x27;re curious on the real impact of this stuff).<p>Have we proven they&#x27;re not secure and safe? Have we broken out of containers yet? Heroku was running LXC for years before docker, did they run into major security woes (actual curious)?<p>If &quot;secured shared environments&quot; is a more specific term meaning &quot;multi user unix environment&quot;, I didn&#x27;t intend to say that.<p>Though you already mentioned my whole thread is a bit off topic to this post (and I sorta agree) but then baited me with this comment after. I&#x27;m happy to drop it and wait for a Gvisor container runtime thread.</div><br/><div id="40592628" class="c"><input type="checkbox" id="c-40592628" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592353">parent</a><span>|</span><a href="#40592385">next</a><span>|</span><label class="collapse" for="c-40592628">[-]</label><label class="expand" for="c-40592628">[2 more]</label></div><br/><div class="children"><div class="content">Containers are not compute environments, their runtimes are, and gvisor (runsc) is one implementation of that. Docker engine (~runc) is another. It has similar performance characteristics to gvisor afaict looking online (the minimum cold start times I&#x27;m seeing are 500ms which I&#x27;ve beat in gvisor), yet implements less security features.<p>If by virtualization you mean VMs, gvisor can be more performant than those based on my experience. For example, AWS claims a p0 coldstart time of ~500ms using Firecracker but I know firsthand that applications sandboxed by gvisor can be made to cold start in significantly less time (like less than half): <a href="https:&#x2F;&#x2F;catalog.workshops.aws&#x2F;java-on-aws-lambda&#x2F;en-US&#x2F;03-snapstart&#x2F;tiered" rel="nofollow">https:&#x2F;&#x2F;catalog.workshops.aws&#x2F;java-on-aws-lambda&#x2F;en-US&#x2F;03-sn...</a>, and you should be able to confirm this yourself by using products that leverage Gvisor under the hood or with your own testing. I actually worked on this (using gvisor, but working on adjacent tech) for years...<p>&gt; Have we broken out of containers yet?<p>Sure, how about <a href="https:&#x2F;&#x2F;scout.docker.com&#x2F;vulnerabilities&#x2F;id&#x2F;CVE-2024-21626" rel="nofollow">https:&#x2F;&#x2F;scout.docker.com&#x2F;vulnerabilities&#x2F;id&#x2F;CVE-2024-21626</a> where runc (Docker) exposed the host filesystem to containerized applications? Precisely the kind of exploit gvisor is designed to prevent.<p>I&#x27;ll note that a lot of people are thinking about how to reduce sandbox overhead in multitenant PaaS and it&#x27;s one of the things I want to eventually address in my own startup. But I think blindly hating on gvisor because of a nebulous dislike of overhead really is misplaced without considering its alternatives.</div><br/><div id="40592849" class="c"><input type="checkbox" id="c-40592849" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592628">parent</a><span>|</span><a href="#40592385">next</a><span>|</span><label class="collapse" for="c-40592849">[-]</label><label class="expand" for="c-40592849">[1 more]</label></div><br/><div class="children"><div class="content">The charts you linked in the performance guide show a 30x syscall overhead in runsc vs runc (careful quit a few of the charts are logrithmic). That&#x27;s insane! They also go on claim a 20% tensorflow workload difference.<p>&gt; I want to eventually address in my own startup.<p>You worked on CloudRun and their performance is dogshit. Seriously google it theres like 100 stack overflow questions on the subject. It&#x27;s common enough a query Google even suggests follow up questions like: &quot;Why is cloud run so slow?&quot;.<p>Now your answer might be &quot;avoid syscalls&quot;, &quot;don&#x27;t do anything on the file system (oh by the way your file system is memory mapped hehe)&quot;, &quot;interpreters can be slow to load their code, sorry&quot;, &quot;look at these charts its not as bad as you say&quot;, &quot;tcp overhead is only 30%&quot;, etc but your next set of customers wont have the same vendor lock in you enjoyed at Google.<p>Then do the same query for &quot;Digital Ocean Apps slow&quot;, also gvisor. And bam you&#x27;ll have a long list of customers ready to use your better version! Perhaps Google and Digital Ocean will enlist your expertise (again).</div><br/></div></div></div></div><div id="40592385" class="c"><input type="checkbox" id="c-40592385" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592353">parent</a><span>|</span><a href="#40592628">prev</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40592385">[-]</label><label class="expand" for="c-40592385">[3 more]</label></div><br/><div class="children"><div class="content">Yes, we have proven that shared-kernel multitenant is unsafe. The best example (though there are many) is the `waitid` LPE; nobody&#x27;s container lockdown configuration was blocking `waitid`, which is what you&#x27;d have had to do to prevent container code from compromising the kernel. The list of Linux LPEs is long, and syzkaller crashes longer stil.</div><br/><div id="40592471" class="c"><input type="checkbox" id="c-40592471" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592385">parent</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40592471">[-]</label><label class="expand" for="c-40592471">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40591147">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40591147</a><p>So the PaaS providers mentioned in that comment should be assumed to be compromised?</div><br/><div id="40594346" class="c"><input type="checkbox" id="c-40594346" checked=""/><div class="controls bullet"><span class="by">ahmedtd</span><span>|</span><a href="#40588582">root</a><span>|</span><a href="#40592471">parent</a><span>|</span><a href="#40588333">next</a><span>|</span><label class="collapse" for="c-40594346">[-]</label><label class="expand" for="c-40594346">[1 more]</label></div><br/><div class="children"><div class="content">If they are using multitenant Docker &#x2F; containerd containers with no additional sandboxing, then yes, then it&#x27;s only a matter of time and attacker interest before a cross-tenant compromise occurs.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40588333" class="c"><input type="checkbox" id="c-40588333" checked=""/><div class="controls bullet"><span class="by">pantalaimon</span><span>|</span><a href="#40588582">prev</a><span>|</span><a href="#40590446">next</a><span>|</span><label class="collapse" for="c-40588333">[-]</label><label class="expand" for="c-40588333">[6 more]</label></div><br/><div class="children"><div class="content">The obvious question is: How does it compare to the in-Kernel TCP stack?</div><br/><div id="40592119" class="c"><input type="checkbox" id="c-40592119" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40588333">parent</a><span>|</span><a href="#40588459">next</a><span>|</span><label class="collapse" for="c-40592119">[-]</label><label class="expand" for="c-40592119">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s less mature, which shows up in lots of places, such as sometimes having less than ideal defaults (as in buffer sizes shown here), and bugs if you start using more fancy features (which improve over time of course).<p>This is approximately the case for any alternative IP stack you might pick though, a mature IP stack is a huge undertaking with all the many flavors of enhancements to IP and particularly TCP over the years, the high variance in platform behaviors and configurations and so on.<p>In general you should only take on a dependency of a lesser-used IP stack if you&#x27;re willing to retain or train IP experts in house over the long haul, because as is demonstrated here, taking on such a dependency means eventually you&#x27;ll find a business need for that expertise. If that&#x27;s way outside of your budget or wheelhouse, it might be worth skipping.</div><br/></div></div><div id="40588459" class="c"><input type="checkbox" id="c-40588459" checked=""/><div class="controls bullet"><span class="by">syzcowboy99</span><span>|</span><a href="#40588333">parent</a><span>|</span><a href="#40592119">prev</a><span>|</span><a href="#40590446">next</a><span>|</span><label class="collapse" for="c-40588459">[-]</label><label class="expand" for="c-40588459">[4 more]</label></div><br/><div class="children"><div class="content">gVisor&#x27;s netstack is still much slower than the kernel&#x27;s (and likely always will be). The goal of this userspace netstack is not to compete with the kernel on performance, but offer an alternative that is more portable and secure.</div><br/><div id="40592076" class="c"><input type="checkbox" id="c-40592076" checked=""/><div class="controls bullet"><span class="by">Xelynega</span><span>|</span><a href="#40588333">root</a><span>|</span><a href="#40588459">parent</a><span>|</span><a href="#40592050">next</a><span>|</span><label class="collapse" for="c-40592076">[-]</label><label class="expand" for="c-40592076">[2 more]</label></div><br/><div class="children"><div class="content">How is it more portable or secure than an API that&#x27;s been stable for decades, and getting constant security fixes?<p>I see an explanation in their blog about avoiding TUN devices since they require elevated permissions, but why would you need a TUN device to send data to&#x2F;from an application? I can&#x27;t understand what their product does from the marketing material but it doesn&#x27;t look like it would require constructing raw IP packets instead of TCP&#x2F;UDP packets and letting the OS wrap them in the other layers.</div><br/><div id="40592164" class="c"><input type="checkbox" id="c-40592164" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40588333">root</a><span>|</span><a href="#40592076">parent</a><span>|</span><a href="#40592050">next</a><span>|</span><label class="collapse" for="c-40592164">[-]</label><label class="expand" for="c-40592164">[1 more]</label></div><br/><div class="children"><div class="content">You can have multiple layers of security boundary on most of the customer-exposed surface area, and avoid more risky surface areas in the kernel.<p>Portable is a bit of a weird word here because for many of us with gray beards the word means architectures, kernels and systems, but I think in this context it tends to more mean &quot;can run just as easily on my macbook as in a cloud container&quot;, but in practice the software isn&#x27;t that portable, as Go isn&#x27;t that portable - at least not in the context of vs. a niche C &quot;portable network stack&quot; that would build roughly anywhere that there&#x27;s a working C toolchain, which is almost everywhere.<p>Constant security fixes for the kernel are a real pain in deployments unless you follow upstream kernels closely. If your business is in shipping Linux runtimes with a high packing density, you really need to find ways to minimize the exposed Linux surface area, or organize to be able to ship kernel upstream updates at an extremely high frequency (relative to normal infrastructure upgrade rates for kernels &#x2F; mandatory reboots) (and I would not consider kexec safe in this kind of context, at all).<p>An alternative approach might be firecracker &#x2F; microvms and so on, but those have their own tradeoffs too. The core point is that you want more than one layer between the host machines and the user code that wants to interact with Linux features.</div><br/></div></div></div></div><div id="40592050" class="c"><input type="checkbox" id="c-40592050" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40588333">root</a><span>|</span><a href="#40588459">parent</a><span>|</span><a href="#40592076">prev</a><span>|</span><a href="#40590446">next</a><span>|</span><label class="collapse" for="c-40592050">[-]</label><label class="expand" for="c-40592050">[1 more]</label></div><br/><div class="children"><div class="content">for some definition of portable which is deeply tied to the go runtime</div><br/></div></div></div></div></div></div><div id="40588402" class="c"><input type="checkbox" id="c-40588402" checked=""/><div class="controls bullet"><span class="by">nynx</span><span>|</span><a href="#40590446">prev</a><span>|</span><a href="#40590316">next</a><span>|</span><label class="collapse" for="c-40588402">[-]</label><label class="expand" for="c-40588402">[5 more]</label></div><br/><div class="children"><div class="content">Doesn’t creating a raw socket need elevated permissions?</div><br/><div id="40588569" class="c"><input type="checkbox" id="c-40588569" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588402">parent</a><span>|</span><a href="#40590316">next</a><span>|</span><label class="collapse" for="c-40588569">[-]</label><label class="expand" for="c-40588569">[4 more]</label></div><br/><div class="children"><div class="content">They&#x27;re not creating raw sockets†. The neat thing about WireGuard is that it runs over vanilla UDP, and presents to the &quot;client&quot; a full TCP&#x2F;IP interface. We normally plug that interface directly into the kernel, but you don&#x27;t have to; you can just write a userspace program that speaks WireGuard directly, and through it give a TCP&#x2F;IP stack interface directly to your program.<p>† <i>I don&#x27;t think? I didn&#x27;t see them say that, and we do the same thing and we don&#x27;t create raw sockets.</i></div><br/><div id="40590370" class="c"><input type="checkbox" id="c-40590370" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40588402">root</a><span>|</span><a href="#40588569">parent</a><span>|</span><a href="#40590316">next</a><span>|</span><label class="collapse" for="c-40590370">[-]</label><label class="expand" for="c-40590370">[3 more]</label></div><br/><div class="children"><div class="content">So it tunnels TCP&#x2F;IP over Wireguard UDP?</div><br/><div id="40591598" class="c"><input type="checkbox" id="c-40591598" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40588402">root</a><span>|</span><a href="#40590370">parent</a><span>|</span><a href="#40591652">next</a><span>|</span><label class="collapse" for="c-40591598">[-]</label><label class="expand" for="c-40591598">[1 more]</label></div><br/><div class="children"><div class="content">Correct (I mean, that&#x27;s fundamentally what WireGuard is: a UDP TCP&#x2F;IP tunnel, with strong modern encryption).</div><br/></div></div><div id="40591652" class="c"><input type="checkbox" id="c-40591652" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#40588402">root</a><span>|</span><a href="#40590370">parent</a><span>|</span><a href="#40591598">prev</a><span>|</span><a href="#40590316">next</a><span>|</span><label class="collapse" for="c-40591652">[-]</label><label class="expand" for="c-40591652">[1 more]</label></div><br/><div class="children"><div class="content">Yes; also see: <a href="https:&#x2F;&#x2F;github.com&#x2F;WireGuard&#x2F;wireguard-go&#x2F;blob&#x2F;12269c2761734b15625017d8565745096325392f&#x2F;tun&#x2F;netstack&#x2F;examples&#x2F;http_client.go">https:&#x2F;&#x2F;github.com&#x2F;WireGuard&#x2F;wireguard-go&#x2F;blob&#x2F;12269c2761734...</a></div><br/></div></div></div></div></div></div></div></div><div id="40588526" class="c"><input type="checkbox" id="c-40588526" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#40590316">prev</a><span>|</span><a href="#40588283">next</a><span>|</span><label class="collapse" for="c-40588526">[-]</label><label class="expand" for="c-40588526">[1 more]</label></div><br/><div class="children"><div class="content">If you’re tunneling a better connection configuration isn’t the tunnel what defines the latency?</div><br/></div></div><div id="40588283" class="c"><input type="checkbox" id="c-40588283" checked=""/><div class="controls bullet"><span class="by">jijji</span><span>|</span><a href="#40588526">prev</a><span>|</span><a href="#40593529">next</a><span>|</span><label class="collapse" for="c-40588283">[-]</label><label class="expand" for="c-40588283">[3 more]</label></div><br/><div class="children"><div class="content">it&#x27;s a solution looking for a problem</div><br/><div id="40592831" class="c"><input type="checkbox" id="c-40592831" checked=""/><div class="controls bullet"><span class="by">hpeter</span><span>|</span><a href="#40588283">parent</a><span>|</span><a href="#40589759">next</a><span>|</span><label class="collapse" for="c-40592831">[-]</label><label class="expand" for="c-40592831">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an engineering challenge and they do solve a problem, it&#x27;s just not your problem :) It&#x27;s a nice read anyways.</div><br/></div></div><div id="40589759" class="c"><input type="checkbox" id="c-40589759" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#40588283">parent</a><span>|</span><a href="#40592831">prev</a><span>|</span><a href="#40593529">next</a><span>|</span><label class="collapse" for="c-40589759">[-]</label><label class="expand" for="c-40589759">[1 more]</label></div><br/><div class="children"><div class="content">gVisor definitely solves a problem for me: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39900329">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39900329</a></div><br/></div></div></div></div><div id="40593529" class="c"><input type="checkbox" id="c-40593529" checked=""/><div class="controls bullet"><span class="by">Narhem</span><span>|</span><a href="#40588283">prev</a><span>|</span><a href="#40588241">next</a><span>|</span><label class="collapse" for="c-40593529">[-]</label><label class="expand" for="c-40593529">[1 more]</label></div><br/><div class="children"><div class="content">I refuse to code in a language that literally means shit</div><br/></div></div><div id="40588241" class="c"><input type="checkbox" id="c-40588241" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#40593529">prev</a><span>|</span><a href="#40588541">next</a><span>|</span><label class="collapse" for="c-40588241">[-]</label><label class="expand" for="c-40588241">[2 more]</label></div><br/><div class="children"><div class="content">is this part of the open source releases? I looked at the coder.com github, but couldn&#x27;t find it. I haven&#x27;t written a compatible TCP, but a different reliable transport in go userspace. fairness aside, i wonder why we dont see this more often. would love to take a look</div><br/><div id="40588327" class="c"><input type="checkbox" id="c-40588327" checked=""/><div class="controls bullet"><span class="by">tazjin</span><span>|</span><a href="#40588241">parent</a><span>|</span><a href="#40588541">next</a><span>|</span><label class="collapse" for="c-40588327">[-]</label><label class="expand" for="c-40588327">[1 more]</label></div><br/><div class="children"><div class="content">They upstreamed their gVisor changes: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;gvisor&#x2F;pull&#x2F;10287">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;gvisor&#x2F;pull&#x2F;10287</a></div><br/></div></div></div></div><div id="40588541" class="c"><input type="checkbox" id="c-40588541" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#40588241">prev</a><span>|</span><label class="collapse" for="c-40588541">[-]</label><label class="expand" for="c-40588541">[5 more]</label></div><br/><div class="children"><div class="content">I have a problem right now which is that it’s slow to copy large files from one side of the earth to the other. Is this the basis of a solution to that maybe?</div><br/><div id="40588829" class="c"><input type="checkbox" id="c-40588829" checked=""/><div class="controls bullet"><span class="by">392</span><span>|</span><a href="#40588541">parent</a><span>|</span><a href="#40588755">next</a><span>|</span><label class="collapse" for="c-40588829">[-]</label><label class="expand" for="c-40588829">[1 more]</label></div><br/><div class="children"><div class="content">No. Profile first. Make sure you&#x27;ve tried tweaking params like batch sizes.</div><br/></div></div><div id="40588755" class="c"><input type="checkbox" id="c-40588755" checked=""/><div class="controls bullet"><span class="by">dpe82</span><span>|</span><a href="#40588541">parent</a><span>|</span><a href="#40588829">prev</a><span>|</span><a href="#40592196">next</a><span>|</span><label class="collapse" for="c-40588755">[-]</label><label class="expand" for="c-40588755">[2 more]</label></div><br/><div class="children"><div class="content">What do you think are the current problems contributing to your slow transfers?</div><br/><div id="40588810" class="c"><input type="checkbox" id="c-40588810" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#40588541">root</a><span>|</span><a href="#40588755">parent</a><span>|</span><a href="#40592196">next</a><span>|</span><label class="collapse" for="c-40588810">[-]</label><label class="expand" for="c-40588810">[1 more]</label></div><br/><div class="children"><div class="content">Window and buffer size is a problem on high latency links.</div><br/></div></div></div></div><div id="40592196" class="c"><input type="checkbox" id="c-40592196" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#40588541">parent</a><span>|</span><a href="#40588755">prev</a><span>|</span><label class="collapse" for="c-40592196">[-]</label><label class="expand" for="c-40592196">[1 more]</label></div><br/><div class="children"><div class="content">not enough detail here to provide a good answer, but I can tell you explicitly that if you&#x27;re using SMB you&#x27;re likely not going to get good performance here even if your network stack is has tons of space to overcome bdp and congestion challenges.</div><br/></div></div></div></div></div></div></div></div></div></body></html>