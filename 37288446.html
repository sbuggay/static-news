<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693213263719" as="style"/><link rel="stylesheet" href="styles.css?v=1693213263719"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.nihamkin.com/2016/10/23/writing-linux-modules-in-ada-part-1/#writing-linux-modules-in-ada-part-1">Writing Linux Modules in Ada (2016)</a> <span class="domain">(<a href="http://www.nihamkin.com">www.nihamkin.com</a>)</span></div><div class="subtext"><span>slondr</span> | <span>29 comments</span></div><br/><div><div id="37288562" class="c"><input type="checkbox" id="c-37288562" checked=""/><div class="controls bullet"><span class="by">gscho</span><span>|</span><a href="#37288799">next</a><span>|</span><label class="collapse" for="c-37288562">[-]</label><label class="expand" for="c-37288562">[2 more]</label></div><br/><div class="children"><div class="content">Back in university I took a course in legacy programming. We did a project in each of Fortran, COBOL and Ada. I enjoyed Ada very much. The module system made a lot of sense to me and the compiler found a lot of mistakes (compared to C). Thanks for sharing this article. It brought me back and makes me want to give Ada another go now that I have 10 years of real world experience.</div><br/><div id="37288912" class="c"><input type="checkbox" id="c-37288912" checked=""/><div class="controls bullet"><span class="by">dilawar</span><span>|</span><a href="#37288562">parent</a><span>|</span><a href="#37288799">next</a><span>|</span><label class="collapse" for="c-37288912">[-]</label><label class="expand" for="c-37288912">[1 more]</label></div><br/><div class="children"><div class="content">I had a digital design course. The instructor hated verilog and preferred VHDL for reason that didn&#x27;t make much sense to me those days. There was only one VHDL compiler available that time called ghdl which worked fine for course. There was modelsim as well but one had to go to the lab.<p>Later I learnt that VHDL is related to ADA. I&#x27;ve been itching to try it for a long while. Might give it a try this week. Currently I am in my Rust phase and loving it (thanks cargo).  My Haskell fever is gone though.</div><br/></div></div></div></div><div id="37288799" class="c"><input type="checkbox" id="c-37288799" checked=""/><div class="controls bullet"><span class="by">inamberclad</span><span>|</span><a href="#37288562">prev</a><span>|</span><a href="#37289735">next</a><span>|</span><label class="collapse" for="c-37288799">[-]</label><label class="expand" for="c-37288799">[14 more]</label></div><br/><div class="children"><div class="content">Hah, my perfect niche!<p>I think that an ada-like language could make a real resurgence in embedded programming. Ada gets all the things about bare-metal right that C got wrong. However, it&#x27;s held up by legacy tooling, clunky syntax, and obtuse compiler errors. Adacore has gone a long way towards alleviating those issues over the last few years, with alire and the ada_language_server. Time will see where this language takes us.</div><br/><div id="37289254" class="c"><input type="checkbox" id="c-37289254" checked=""/><div class="controls bullet"><span class="by">ajxs</span><span>|</span><a href="#37288799">parent</a><span>|</span><a href="#37291107">next</a><span>|</span><label class="collapse" for="c-37289254">[-]</label><label class="expand" for="c-37289254">[12 more]</label></div><br/><div class="children"><div class="content">I completely agree. &#x27;Design-by-committee&#x27; gets a bad rap, but Ada&#x27;s designers got a lot of things right when it came to bare-metal programming. The ability to specify the in-memory representation of a type is one of my personal favourites. I don&#x27;t think Ada&#x27;s syntax has aged well. I wish it would get a 21st-century overhaul. I don&#x27;t think that&#x27;s likely though, but we can all dream. AdaCore do great work, and contribute a lot back to the open-source community.</div><br/><div id="37291113" class="c"><input type="checkbox" id="c-37291113" checked=""/><div class="controls bullet"><span class="by">hashmal</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37289254">parent</a><span>|</span><a href="#37290365">next</a><span>|</span><label class="collapse" for="c-37291113">[-]</label><label class="expand" for="c-37291113">[1 more]</label></div><br/><div class="children"><div class="content">It was designed by committee, but as long as the original author was involved he had a veto right and he used it <i>very</i> often, which alleviated the &quot;committee&quot; effect.</div><br/></div></div><div id="37290365" class="c"><input type="checkbox" id="c-37290365" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37289254">parent</a><span>|</span><a href="#37291113">prev</a><span>|</span><a href="#37290751">next</a><span>|</span><label class="collapse" for="c-37290365">[-]</label><label class="expand" for="c-37290365">[2 more]</label></div><br/><div class="children"><div class="content">Usually many forget that their beloved C, JavaScript, Webassembly, OpenGL, Vulkan, Web, POSIX,... are equally design by committee.</div><br/><div id="37291165" class="c"><input type="checkbox" id="c-37291165" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37290365">parent</a><span>|</span><a href="#37290751">next</a><span>|</span><label class="collapse" for="c-37291165">[-]</label><label class="expand" for="c-37291165">[1 more]</label></div><br/><div class="children"><div class="content">The benevolent dictator cachet comes mostly from Python microcosm.</div><br/></div></div></div></div><div id="37290751" class="c"><input type="checkbox" id="c-37290751" checked=""/><div class="controls bullet"><span class="by">sttaft</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37289254">parent</a><span>|</span><a href="#37290365">prev</a><span>|</span><a href="#37290002">next</a><span>|</span><label class="collapse" for="c-37290751">[-]</label><label class="expand" for="c-37290751">[1 more]</label></div><br/><div class="children"><div class="content">For what it is worth, Ada was not &quot;designed by committee&quot; more than most languages.  It was designed by a design team, and in each revision, there was a strong technical leader of the design team, with the whole design team sharing a strong design aesthetic.  I doubt you could say even that about many mainstream languages these days.</div><br/></div></div><div id="37290002" class="c"><input type="checkbox" id="c-37290002" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37289254">parent</a><span>|</span><a href="#37290751">prev</a><span>|</span><a href="#37291107">next</a><span>|</span><label class="collapse" for="c-37290002">[-]</label><label class="expand" for="c-37290002">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s unclear exactly what you mean by your remark that Ada&#x27;s syntax hasn&#x27;t aged well, let alone what a 21st-century overhaul would look like.<p>Is there any chance you&#x27;d expand on that? I&#x27;m curious to know your thoughts.</div><br/><div id="37290803" class="c"><input type="checkbox" id="c-37290803" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37290002">parent</a><span>|</span><a href="#37290028">next</a><span>|</span><label class="collapse" for="c-37290803">[-]</label><label class="expand" for="c-37290803">[1 more]</label></div><br/><div class="children"><div class="content">They probably mean that they can’t get past the fact that it looks more like Algol or Pascal than C. Which is, frankly, a pretty silly argument.<p>I’ve heard this exact argument about VHDL versus Verilog, with the former being explicitly based on Ada’s syntax and the latter being explicitly based on C’s. (Turns out though that VHDL is also strictly better than at least traditional Verilog, as it requires separate interface specifications which lead to improved modularity.)<p>If anyone were to actually try to create “Ada: The Next Generation” I’d encourage you to just go all the way to S-expressions. Focus on the completeness and correctness of _the system_ and stop worrying about superficial complaints—or brush them off with a suggestion that they can use any syntax they want and just translate it to the standard one via tree-walking.</div><br/></div></div><div id="37290028" class="c"><input type="checkbox" id="c-37290028" checked=""/><div class="controls bullet"><span class="by">inamberclad</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37290002">parent</a><span>|</span><a href="#37290803">prev</a><span>|</span><a href="#37291107">next</a><span>|</span><label class="collapse" for="c-37290028">[-]</label><label class="expand" for="c-37290028">[5 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s evident to most people that write Ada that the language is too English-heavy. This gets in the way of actually representing the computations. This was a design decision when the language was created, since the emphasis was put on maintainable code</div><br/><div id="37290109" class="c"><input type="checkbox" id="c-37290109" checked=""/><div class="controls bullet"><span class="by">thrawa8387336</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37290028">parent</a><span>|</span><a href="#37291107">next</a><span>|</span><label class="collapse" for="c-37290109">[-]</label><label class="expand" for="c-37290109">[4 more]</label></div><br/><div class="children"><div class="content">Is this meant as a joke, too English-heavy?</div><br/><div id="37290466" class="c"><input type="checkbox" id="c-37290466" checked=""/><div class="controls bullet"><span class="by">cjbgkagh</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37290109">parent</a><span>|</span><a href="#37290451">next</a><span>|</span><label class="collapse" for="c-37290466">[-]</label><label class="expand" for="c-37290466">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s a reference to keyword heavy in an effort to mimic natural language similar to what COBOL tried to do.</div><br/></div></div><div id="37290451" class="c"><input type="checkbox" id="c-37290451" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37290109">parent</a><span>|</span><a href="#37290466">prev</a><span>|</span><a href="#37291107">next</a><span>|</span><label class="collapse" for="c-37290451">[-]</label><label class="expand" for="c-37290451">[2 more]</label></div><br/><div class="children"><div class="content">They likely mean the pascal-like syntax</div><br/><div id="37290999" class="c"><input type="checkbox" id="c-37290999" checked=""/><div class="controls bullet"><span class="by">augustk</span><span>|</span><a href="#37288799">root</a><span>|</span><a href="#37290451">parent</a><span>|</span><a href="#37291107">next</a><span>|</span><label class="collapse" for="c-37290999">[-]</label><label class="expand" for="c-37290999">[1 more]</label></div><br/><div class="children"><div class="content">Standard Pascal has 35 reserved words compared to ANSI C 89 which has 32. Not a big difference in terms of English-heaviness.<p><a href="https:&#x2F;&#x2F;wiki.freepascal.org&#x2F;Standard_Pascal" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.freepascal.org&#x2F;Standard_Pascal</a><p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;keyword" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;keyword</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37291107" class="c"><input type="checkbox" id="c-37291107" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#37288799">parent</a><span>|</span><a href="#37289254">prev</a><span>|</span><a href="#37289735">next</a><span>|</span><label class="collapse" for="c-37291107">[-]</label><label class="expand" for="c-37291107">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ada gets all the things about bare-metal right that C got wrong<p>I&#x27;m curious, never had a look at Ada, can you elaborate?</div><br/></div></div></div></div><div id="37289735" class="c"><input type="checkbox" id="c-37289735" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#37288799">prev</a><span>|</span><a href="#37290098">next</a><span>|</span><label class="collapse" for="c-37289735">[-]</label><label class="expand" for="c-37289735">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never used Ada, and I also don&#x27;t really do systems stuff, but it does seem like it&#x27;s a pretty neat language, at least compared to C. From what I have seen, it looks like it has better memory guarantees while still being fast and low-level.<p>With be the popularity of Rust, it makes me kind of wonder why Ada isn&#x27;t more popular. I should give the language a go.</div><br/><div id="37290771" class="c"><input type="checkbox" id="c-37290771" checked=""/><div class="controls bullet"><span class="by">demizer</span><span>|</span><a href="#37289735">parent</a><span>|</span><a href="#37290098">next</a><span>|</span><label class="collapse" for="c-37290771">[-]</label><label class="expand" for="c-37290771">[1 more]</label></div><br/><div class="children"><div class="content">There wasn&#x27;t an open source compiler from the beginning, and thus a lot of the compilers where expensive. You could only use the language in an awful legacy setting behind a wall of NDAs and security clearances. Not my experience, just a bunch comments on HN of actual retired Ada devs on why the language didn&#x27;t take when I was researching the language.<p>Adacore in the last few years have been investing heavily in modernizing the tool chain, but now it seems they are also investing in Rust.</div><br/></div></div></div></div><div id="37290098" class="c"><input type="checkbox" id="c-37290098" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37289735">prev</a><span>|</span><a href="#37289768">next</a><span>|</span><label class="collapse" for="c-37290098">[-]</label><label class="expand" for="c-37290098">[2 more]</label></div><br/><div class="children"><div class="content">A very long time ago The University of York (UK) secured the contract from the UK Science and Engineering Council (SERC) to write a unix Ada compiler.<p>It was a multi pass, 5-10 stage process (or more. I want to say 13 but time plays tricks) Very costly language to compile, in those days. (Vax 11&#x2F;780 running Unix 32V, a precursor to BSD and Ultrix by some years)<p>The story was it emitted an error&#x2F;warning code along the lines of &quot;Congratulations you have used the most abstruse feature of the ADA language&quot; -which the approval people made them take out before it got certified.<p>Wirth had a sabbatical residency in York around the time of the Ada language selection process, his choices didn&#x27;t make it through the strawman&#x2F;steelman process, I think they resurfaced in Modula-II. It was a pascal teaching department like many others in the UK of the time, so it made sense for him to spend time there. Modula-II is said to be a systems programming language too.<p>Ada was very hard to teach. The ideas of asynchronous, and exception handling didn&#x27;t sit very well on young minds. Maybe now they&#x27;re well enough understood to teach in Rust. At the time, the absence of a rationale around &quot;why&quot; was very strong. York had a miniature 2-lift engine model which it used as a proving ground for Ada programs and undergraduate projects. Lift sequencing is a bit of a black art in itself but if you put that optimality of &quot;which lift, which direction, which floor&quot; to one side, the mixture of real-time controls and sensors were probably a good fit. (lift == elevator for the other side of the Atlantic)<p>I remember some concern in the department the only logical endpoint for Ada was to code military flight control&#x2F;weapons&#x2F;radar systems, and people felt uncomfortable about the implicit participation in the UK War economy. This was during the time of the Greenham common protests against US nuclear forces on UK soil.<p>During the Alvey 5th Generation funding debacle (&quot;Catch up with Japan at all costs&quot;) there was another round of this using GEC400 computers, again very directly related to Uk MOD needs for weapons control systems and what I think became the Nimrod airborne radar. Probably signals processing is a very good fit for Ada. (I didn&#x27;t work on that project, or the compiler)<p>People said that the consistency of mapping data structures to devices, chip signal lines, real things, and the abstractions around that in types worked well in Ada. I found it horrendously complicated to understand. People might say C is a hack but the literal directness of C structs on a PDP11 or Vax to the underlying architecture worked pretty well to me. I guess the problem is that C was always too close to Assembler for some people. Bliss&#x2F;32 was the systems programming language of choice in Digital, and I think continued to be used to write VMS, although I read now it was almost entirely written in DEC Macro assembler.</div><br/><div id="37291233" class="c"><input type="checkbox" id="c-37291233" checked=""/><div class="controls bullet"><span class="by">gbu</span><span>|</span><a href="#37290098">parent</a><span>|</span><a href="#37289768">next</a><span>|</span><label class="collapse" for="c-37291233">[-]</label><label class="expand" for="c-37291233">[1 more]</label></div><br/><div class="children"><div class="content">10 or so years ago they had a collection of marble runs with mixed steel&#x2F;glass marbles with a Hall effect sensor, a proximity sensor and some track switches. Students would use Ada to run the marble tracks and have them sort the marbles.<p>It’s interesting to hear that they had a longer history of teaching Ada with real-time sensors and controls.</div><br/></div></div></div></div><div id="37289768" class="c"><input type="checkbox" id="c-37289768" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#37290098">prev</a><span>|</span><a href="#37288835">next</a><span>|</span><label class="collapse" for="c-37289768">[-]</label><label class="expand" for="c-37289768">[1 more]</label></div><br/><div class="children"><div class="content">Cool project for a proof of concept. That said, the kernel has so many unsafe features that making real world modules that are safe requires a lot of boilerplate to get around those features. Sometimes it&#x27;s impossible. Rust is only barely useable now after tons of work to make it viable.</div><br/></div></div><div id="37288835" class="c"><input type="checkbox" id="c-37288835" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#37289768">prev</a><span>|</span><a href="#37288797">next</a><span>|</span><label class="collapse" for="c-37288835">[-]</label><label class="expand" for="c-37288835">[5 more]</label></div><br/><div class="children"><div class="content">Memory safety might not be a bad idea for Linux in general.</div><br/><div id="37290064" class="c"><input type="checkbox" id="c-37290064" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37288835">parent</a><span>|</span><a href="#37288797">next</a><span>|</span><label class="collapse" for="c-37290064">[-]</label><label class="expand" for="c-37290064">[4 more]</label></div><br/><div class="children"><div class="content">Ada’s take on memory safety is pretty limited. Heap allocation is explicit; there’s a procedure literally named Unchecked_Deallocation to free a pointer. It does have thread-scoped locals and arenas, but nothing like declared lifetimes or borrowing. The spec allows for GC but I believe it’s rarely offered.<p>It’s safer than C, but I’m not quite sure where recent specs line up against C++.</div><br/><div id="37290386" class="c"><input type="checkbox" id="c-37290386" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37288835">root</a><span>|</span><a href="#37290064">parent</a><span>|</span><a href="#37290427">next</a><span>|</span><label class="collapse" for="c-37290386">[-]</label><label class="expand" for="c-37290386">[2 more]</label></div><br/><div class="children"><div class="content">Only true for those stuck in Ada83.<p>People keep repeating this nonsense without updating themselves beforehand.<p>EDIT: To simply education on Ada,<p>Yes there was an optional GC, no one ever implemented it, so in Ada2012 got removed from the standard.<p>Almost everything can be allocated on the stack, so a strategy is to catch exceptions of not enough stack space and retry the same function with a smaller size for the data structure.<p>Ada95 introduced controlled types, which is basically Ada&#x27;s version of RAII, no need to call Unchecked_Deallocation outside implementation details. Hardly any different from Rust code that uses unsafe underneath.<p>Ada&#x2F;SPARK, now part of regular Ada specification, provides theorem proving capabilities, and contracts, allowing another safety level still not available in Rust.<p>Additionally Ada Core is contributing improving lifetime rules for access types, to have a kind of borrow checker light, when needed.<p>Finally, there are still 7 Ada vendors in business, with 40 years of experience deploying Ada into safety critical scenarios.</div><br/><div id="37290763" class="c"><input type="checkbox" id="c-37290763" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#37288835">root</a><span>|</span><a href="#37290386">parent</a><span>|</span><a href="#37290427">next</a><span>|</span><label class="collapse" for="c-37290763">[-]</label><label class="expand" for="c-37290763">[1 more]</label></div><br/><div class="children"><div class="content">What’s your sense of the size of the Ada job market? High hundreds? Close to 10,000? Is it static or growing or shrinking? Is there a preferred online community for Ada devs?</div><br/></div></div></div></div><div id="37290427" class="c"><input type="checkbox" id="c-37290427" checked=""/><div class="controls bullet"><span class="by">touisteur</span><span>|</span><a href="#37288835">root</a><span>|</span><a href="#37290064">parent</a><span>|</span><a href="#37290386">prev</a><span>|</span><a href="#37288797">next</a><span>|</span><label class="collapse" for="c-37290427">[-]</label><label class="expand" for="c-37290427">[1 more]</label></div><br/><div class="children"><div class="content">Recent work have introduced lifetimes and an ownership model into SPARK (the reduced easier-to-prove Ada subset) <a href="https:&#x2F;&#x2F;blog.adacore.com&#x2F;using-pointers-in-spark" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.adacore.com&#x2F;using-pointers-in-spark</a> and hopefully it&#x27;ll trickle down soon in Ada.<p>Edit: there&#x27;s also reference counting and controlled types of course. And the secondary stack makes many uses of heap allocation go away.</div><br/></div></div></div></div></div></div><div id="37288797" class="c"><input type="checkbox" id="c-37288797" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#37288835">prev</a><span>|</span><label class="collapse" for="c-37288797">[-]</label><label class="expand" for="c-37288797">[2 more]</label></div><br/><div class="children"><div class="content">(2016)</div><br/><div id="37289751" class="c"><input type="checkbox" id="c-37289751" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37288797">parent</a><span>|</span><label class="collapse" for="c-37289751">[-]</label><label class="expand" for="c-37289751">[1 more]</label></div><br/><div class="children"><div class="content">Added. Thanks!</div><br/></div></div></div></div></div></div></div></div></div></body></html>