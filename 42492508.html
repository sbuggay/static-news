<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735030877304" as="style"/><link rel="stylesheet" href="styles.css?v=1735030877304"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: Programmers who don&#x27;t use autocomplete/LSP, how do you do it?</a> </div><div class="subtext"><span>zackoverflow</span> | <span>110 comments</span></div><br/><div><div id="42500195" class="c"><input type="checkbox" id="c-42500195" checked=""/><div class="controls bullet"><span class="by">daltonpinto</span><span>|</span><a href="#42500573">next</a><span>|</span><label class="collapse" for="c-42500195">[-]</label><label class="expand" for="c-42500195">[9 more]</label></div><br/><div class="children"><div class="content">This question reminds me of the first time I met a blind programmer.<p>I asked him how he managed to code, and he replied with something that stayed with me: a good programmer should organize software in such a way that every piece of code has a clear and logical place. The organization should be so intuitive that anyone could build a mental model of the structure and navigate it easily, even without seeing it.<p>It felt like something out of a Yoda or Mr. Miyagi lesson. Skeptical, I asked his colleagues if he was truly able to code or if he was just exaggerating. To my surprise, they told me not only was he capable, but he was the best programmer they had ever worked with. They said no one else came close to writing code as organized as his.<p>That conversation changed my perspective. Ever since, whenever I’m unsure where to place new code, I don’t think about DDD or any specific methodology. Instead, I try to follow the logic and structure of the project in a way that feels natural and easy to follow later.<p>Later in life, I met two other blind programmers and heard similar stories about their ability to produce well-organized code.<p>To bring this back to the original question: I view LSP&#x2F;IDE features the same way those programmers view &quot;visual aids.&quot; Code should be organized according to a clear and logical structure that makes it easy to navigate.<p>Relying on features like Ctrl+Click to find where things are located worries me. Why? Because it can mask structural flaws in the codebase. If we can&#x27;t intuitively figure out where something belongs, that’s a sign the codebase lacks structure—and that should motivate us to refactor it.<p>Not only do I avoid using LSP features, but I’m also opposed to their use. While they can help with navigation, they may prevent developers from experiencing and addressing the underlying structural issues in their code.</div><br/><div id="42500639" class="c"><input type="checkbox" id="c-42500639" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42500195">parent</a><span>|</span><a href="#42500611">next</a><span>|</span><label class="collapse" for="c-42500639">[-]</label><label class="expand" for="c-42500639">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree with the idea but disagree with the… submission to the norms.<p>We rarely talk about it and it’s also the constant source of teamwork issues. Look, if our code <i>needs</i> structure to be observable, it lacks structure in the first place.<p>Languages and editing methods — not talking IDEs here, it’s more fundamental — are still “empty file canvas, paint anything” model. That must be stopped.<p>These structural issues are analogous to malformed xml issues. They should not exist normally. We could start with e.g. better isolation&#x2F;visibility systems than “files with exports”, then address lack of annotated TOCs for projects and modules. Then replace files with something more database-like. Theeen we could talk about someone breaking a nice structure. Because this structure only exist in a human’s mind, blindness only serving as a bitter “equalizer” to it.</div><br/></div></div><div id="42500611" class="c"><input type="checkbox" id="c-42500611" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42500195">parent</a><span>|</span><a href="#42500639">prev</a><span>|</span><a href="#42500470">next</a><span>|</span><label class="collapse" for="c-42500611">[-]</label><label class="expand" for="c-42500611">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not only do I avoid using LSP features, but I’m also opposed to their use. While they can help with navigation, they may prevent developers from experiencing and addressing the underlying structural issues in their code.<p>LSP by itself will not prevent anything. LSP (using the terminology from OP, but any IDE really) is just a tool like any other which allows you to do things faster. It doesn&#x27;t matter how organized your code base is, it will never be as fast to find some definition as hitting a keyboard shortcut (please don&#x27;t use Ctrl+Click, my gosh... learn the keyboard shortcut for things you do often like this). I want to see docs for a function without moving my eyes from the code I am currently writing. I want to be able to jump back and forth between definitions without interrupting my chain of thought, see function definitions inline instead of having to jump to the file it&#x27;s defined on.<p>When you have to manually search for files and then Ctrl+F to find functions, lookup docs in a web browser (which I hear is how people who don&#x27;t use IDEs still do that), or manually run a linter&#x2F;compiler to see warnings in your code, you&#x27;re just being really inefficient. I can&#x27;t understand that at all. Why don&#x27;t you use automation to help your job when the whole point of your job is automation?<p>Keeping the code organized is still good advice, but has nothing to do with using an IDE.</div><br/></div></div><div id="42500470" class="c"><input type="checkbox" id="c-42500470" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#42500195">parent</a><span>|</span><a href="#42500611">prev</a><span>|</span><a href="#42500325">next</a><span>|</span><label class="collapse" for="c-42500470">[-]</label><label class="expand" for="c-42500470">[1 more]</label></div><br/><div class="children"><div class="content">I greatly enjoyed this comment of yours daltonpinto. Thank you.<p>I do not rejoice with code bases where every file has no logic or code in it but there are hundreds of methods and files with everything spread out. I have no idea how those projects fit together because the actual logic is spread out.<p>For my personal side project hobby work it&#x27;s all in one file.</div><br/></div></div><div id="42500325" class="c"><input type="checkbox" id="c-42500325" checked=""/><div class="controls bullet"><span class="by">mckn1ght</span><span>|</span><a href="#42500195">parent</a><span>|</span><a href="#42500470">prev</a><span>|</span><a href="#42500573">next</a><span>|</span><label class="collapse" for="c-42500325">[-]</label><label class="expand" for="c-42500325">[5 more]</label></div><br/><div class="children"><div class="content">Of course I agree that code should be organized logically, but I wonder if you could expand on what you mean. Do you drill down into finer and finer directories of detail, code units, classes and functions?<p>I work with someone that navigates the tree structure of all our directories every time they need to look for something. It is painfully slow to watch and if you ask me, they produce fairly spaghetti architecture. Some of that could be a lack of familiarity with the idioms of our platform and its available SDKs.<p>But I ⌘ click all the time as well as quick-open right to the class, variable or function I need to work with, and I feel like I still organize things better. I’m constantly fixing the weirdness and proposing even more things that should be improved.<p>You might even get a bit of a Conway’s Law effect by committing unnecessarily to a specific, onerous work style.</div><br/><div id="42500438" class="c"><input type="checkbox" id="c-42500438" checked=""/><div class="controls bullet"><span class="by">dijksterhuis</span><span>|</span><a href="#42500195">root</a><span>|</span><a href="#42500325">parent</a><span>|</span><a href="#42500363">next</a><span>|</span><label class="collapse" for="c-42500438">[-]</label><label class="expand" for="c-42500438">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Of course I agree that code should be organized logically, but I wonder if you could expand on what you mean. Do you drill down into finer and finer directories of detail, code units, classes and functions?<p>from the parent (i am not the parent)<p>&gt; I try to follow the logic and structure of the project in a way that feels natural and easy to follow later.<p>in my own experience it applies to everything in a codebase.<p>what the end state looks like completely depends on the problem domain at hand, and the tools used to solve the problem.<p>how to make a codebase “intuitive” is learned, not taught. understand the problem domain, understand the tools in use, then refactor, refactor, refactor, refactor until it makes sense.<p>&gt; I work with someone that navigates the tree structure of all our directories every time they need to look for something<p>sounds like they have yet to learn how the code modules are organised.<p>possibly because the modules are not intuitively organised, possibly because there’s a lot of code, possibly because they just don’t care and don’t mind the mental break of mindlessly looking for the right module.</div><br/></div></div><div id="42500363" class="c"><input type="checkbox" id="c-42500363" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#42500195">root</a><span>|</span><a href="#42500325">parent</a><span>|</span><a href="#42500438">prev</a><span>|</span><a href="#42500573">next</a><span>|</span><label class="collapse" for="c-42500363">[-]</label><label class="expand" for="c-42500363">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I work with someone that navigates the tree structure of all our directories every time they need to look for something<p>Counter example: I’m working with LSP dragging codebase where basic code lint takes 45s. My colleague takes a break after each change so that their code navigation starts working again.<p>Inefficient people are inefficient.<p>Not using LSPs isn’t guarantee of efficiency just as using LSP isn’t one. Different strokes for different folks - one has to accept consequences though (more automation means less presence, but it’s everyone’s own choice to make).</div><br/><div id="42500469" class="c"><input type="checkbox" id="c-42500469" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#42500195">root</a><span>|</span><a href="#42500363">parent</a><span>|</span><a href="#42500448">next</a><span>|</span><label class="collapse" for="c-42500469">[-]</label><label class="expand" for="c-42500469">[1 more]</label></div><br/><div class="children"><div class="content">Needs more RAM?<p>I&#x27;ve been doing work on a Raspberry Pi project, which got large enough that it took forever to get code nav back after an edit.<p>I switched to using VSCODE remote from a beefier machine with 32GB of memory (and an admittedly better processor). Editing response is now under 10 seconds. Sweetness and light! And even the compiles (which still take place on the Pi) run about 6x faster.</div><br/></div></div></div></div></div></div></div></div><div id="42500573" class="c"><input type="checkbox" id="c-42500573" checked=""/><div class="controls bullet"><span class="by">vq</span><span>|</span><a href="#42500195">prev</a><span>|</span><a href="#42500046">next</a><span>|</span><label class="collapse" for="c-42500573">[-]</label><label class="expand" for="c-42500573">[4 more]</label></div><br/><div class="children"><div class="content">I work almost exclusively in Emacs without the modern LSP-based tools.  I believe I do keep more in my head than programmers that use more advanced IDEs.<p>In code I have control over myself I avoid imports that doesn&#x27;t enumerate all imported symbols.  That is I always use the import Library (symbol) syntax in Haskell and never do wildcard import in Python.<p>When coding C I sometimes use tags so that I can go to definitions quickly, I should probably use it more than I do to be honest.<p>I do use hippie-expand for quick auto-completion but it is completely textual, it has no understanding of the programming language it currently works on which makes it much less powerful of course but it also has some benefits.<p>I always have the documentation very reachable, I use a search keyword in my browser to search on hoogle.  I type H &lt;Space&gt; symbol&#x2F;type-expression &lt;Enter&gt; and I quickly find the documentation.<p>I do use Visual Studio on a Windows box for working on a C# codebase a couple of times per year and when I do I always turn off that code lens thing and I find that I rely on the code navigation features quite a bit.  Part of it is probably due to it being a code base that is larger and that C#(&#x2F;Java)-flavoured OOP makes the code more spread out.  In terser languages like Haskell (which is much terser) it is natural for more functionality or types to live in the same file which means that you get much further with just simple textual search.</div><br/><div id="42500596" class="c"><input type="checkbox" id="c-42500596" checked=""/><div class="controls bullet"><span class="by">gotts</span><span>|</span><a href="#42500573">parent</a><span>|</span><a href="#42500046">next</a><span>|</span><label class="collapse" for="c-42500596">[-]</label><label class="expand" for="c-42500596">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I work almost exclusively in Emacs without the modern LSP-based tools<p>I&#x27;m wondering how many people in the comments would misinterpret it as &quot;Emacs is outdated&quot;&#x2F;&quot;Emacs does not have modern LSP-based tools&quot;</div><br/><div id="42500623" class="c"><input type="checkbox" id="c-42500623" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#42500573">root</a><span>|</span><a href="#42500596">parent</a><span>|</span><a href="#42500635">next</a><span>|</span><label class="collapse" for="c-42500623">[-]</label><label class="expand" for="c-42500623">[1 more]</label></div><br/><div class="children"><div class="content">I was about to switch from Emacs when I found TIDE for Typescript development (which is what I do), and it kept me in Emacs for years longer.<p>Recently though I couldn&#x27;t resist experimenting with Copilot and I switched to VS code for it, after 32 years. Is there a good Emacs module for it by now?</div><br/></div></div><div id="42500635" class="c"><input type="checkbox" id="c-42500635" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42500573">root</a><span>|</span><a href="#42500596">parent</a><span>|</span><a href="#42500623">prev</a><span>|</span><a href="#42500046">next</a><span>|</span><label class="collapse" for="c-42500635">[-]</label><label class="expand" for="c-42500635">[1 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s bullshit. emacs has had most of the tools that LSP enables, it just had that only for some languages that had better emacs modes (C, elisp, Common Lisp etc.). All LSP is doing is making it easier to write modes for new languages really. emacs with eglot (not the LSP modes which are generally terrible) is a great IDE, and does thing the emacs way. Saying you use emacs but don&#x27;t like &quot;LSP&quot; feels like a joke to me. The very reason SLIME was so great decades before IDEs became mainstream was that it was already a powerful IDE, it just does the IDE things a bit different than you&#x27;re probably used to.</div><br/></div></div></div></div></div></div><div id="42500046" class="c"><input type="checkbox" id="c-42500046" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#42500573">prev</a><span>|</span><a href="#42499402">next</a><span>|</span><label class="collapse" for="c-42500046">[-]</label><label class="expand" for="c-42500046">[10 more]</label></div><br/><div class="children"><div class="content">The shell is my development environment. I open up new terminals and shells willy nilly. I find cli tools like find&#x2F;fd&#x2F;grep&#x2F;rg are useful because I rarely need to find only the definition of a function, but rather other call sites too, to find out how it is being used. I think being surrounded by the code and being able to slice and dice it leads to a certain kind of familiarity that a tool that takes you right there doesn&#x27;t afford. I like fast compilers, and type checking, so it doesn&#x27;t matter if I can remember the types and fields. I&#x27;m not bothered by error messages or warnings, I fix them and I have a greater understanding of the code I&#x27;m writing. My editor is a pretty stock vim setup with format-on-save and syntax highlighting, but I can operate without those (in fact, I&#x27;m often hindered by some other defaults, like bad color choice (dark blue on my black terminal) that makes things hard to read. I dont have much vim customization because I can not rely on it always being there. I use a pretty basic setup that lets me be productive in just about any default unix&#x2F;Linux environment. I find IDEs to have a lot of visual distractions. When I was first exposed to unix in the early 90s, programming using it just clicked for me and I&#x27;ve never really felt hindered by the defaults. I read man pages and the languages&#x27; stdlib docs (usually web pages) so I&#x27;m a little more than passingly familiar with what&#x27;s in them and their capabilities and how to navigate them.</div><br/><div id="42500385" class="c"><input type="checkbox" id="c-42500385" checked=""/><div class="controls bullet"><span class="by">ximm</span><span>|</span><a href="#42500046">parent</a><span>|</span><a href="#42500286">next</a><span>|</span><label class="collapse" for="c-42500385">[-]</label><label class="expand" for="c-42500385">[1 more]</label></div><br/><div class="children"><div class="content">I have an alias for `vim -p $(git grep -li &quot;$1&quot;) +&quot;&#x2F;$1&quot;` that allows me to quickly open files that contain a given string.</div><br/></div></div><div id="42500286" class="c"><input type="checkbox" id="c-42500286" checked=""/><div class="controls bullet"><span class="by">tmountain</span><span>|</span><a href="#42500046">parent</a><span>|</span><a href="#42500385">prev</a><span>|</span><a href="#42500135">next</a><span>|</span><label class="collapse" for="c-42500286">[-]</label><label class="expand" for="c-42500286">[5 more]</label></div><br/><div class="children"><div class="content">I did it this way for about 20 years and recently moved to VSCode with its integrated terminal. It makes me feel pretty lazy and like I’m “cheating”, but there are some productivity benefits (LSP), and I’m less of a purist than I used to be. I maintained a blog about vim for 3-4 years, so I was pretty committed to that workflow back in the day.</div><br/><div id="42500371" class="c"><input type="checkbox" id="c-42500371" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#42500046">root</a><span>|</span><a href="#42500286">parent</a><span>|</span><a href="#42500399">next</a><span>|</span><label class="collapse" for="c-42500371">[-]</label><label class="expand" for="c-42500371">[3 more]</label></div><br/><div class="children"><div class="content">I know about VSCode&#x27;s terminal, and the few times I&#x27;ve used it seems like an afterthought, bolted on, to the primary function of the program <i>as an editor and file navigator</i>. I don&#x27;t live in the editor. I live in the shell. The editor is a sub function of living in the shell.</div><br/><div id="42500429" class="c"><input type="checkbox" id="c-42500429" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42500046">root</a><span>|</span><a href="#42500371">parent</a><span>|</span><a href="#42500399">next</a><span>|</span><label class="collapse" for="c-42500429">[-]</label><label class="expand" for="c-42500429">[2 more]</label></div><br/><div class="children"><div class="content">I actually think the VSC terminal is one of the few saving graces it has. Maybe not so much on *nix. It works well enough on Mac, but it really shines on Windows where you’ll have a much easier time running powershell, GitShell and WSL terminals within VSC than outside of it. It also has really good integration with the various Azure CLI tools.<p>I don’t think VSC is a very good IDE though. I have no idea why a Vim user would use it instead of upgrading to Neovim, and obviously doom emacs is the best choice but I do think the terminal is actually pretty good in VSC. At least on Windows.</div><br/><div id="42500622" class="c"><input type="checkbox" id="c-42500622" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#42500046">root</a><span>|</span><a href="#42500429">parent</a><span>|</span><a href="#42500399">next</a><span>|</span><label class="collapse" for="c-42500622">[-]</label><label class="expand" for="c-42500622">[1 more]</label></div><br/><div class="children"><div class="content">on windows VSCode is a great way to remote into a VM with with a sane-er OS.</div><br/></div></div></div></div></div></div></div></div><div id="42500135" class="c"><input type="checkbox" id="c-42500135" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#42500046">parent</a><span>|</span><a href="#42500286">prev</a><span>|</span><a href="#42500527">next</a><span>|</span><label class="collapse" for="c-42500135">[-]</label><label class="expand" for="c-42500135">[2 more]</label></div><br/><div class="children"><div class="content">Good point re: using error messages. If I call a function incorrectly, the call stack will helpfully point out the file and line number of the location the error was thrown from, just a few keystrokes in vim will get you there.</div><br/><div id="42500530" class="c"><input type="checkbox" id="c-42500530" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#42500046">root</a><span>|</span><a href="#42500135">parent</a><span>|</span><a href="#42500527">next</a><span>|</span><label class="collapse" for="c-42500530">[-]</label><label class="expand" for="c-42500530">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the call stack will helpfully point out the file and line number of the location the error was thrown from, just a few keystrokes in vim will get you there.<p>Or Cmd+Click&#x2F;Ctrl+Click in an IDE</div><br/></div></div></div></div><div id="42500527" class="c"><input type="checkbox" id="c-42500527" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#42500046">parent</a><span>|</span><a href="#42500135">prev</a><span>|</span><a href="#42499402">next</a><span>|</span><label class="collapse" for="c-42500527">[-]</label><label class="expand" for="c-42500527">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find cli tools like find&#x2F;fd&#x2F;grep&#x2F;rg are useful because I rarely need to find only the definition of a function, but rather other call sites too, to find out how it is being used<p>And find&#x2F;grep are very bad and limited tools for this compared to what an IDE will give you</div><br/></div></div></div></div><div id="42499402" class="c"><input type="checkbox" id="c-42499402" checked=""/><div class="controls bullet"><span class="by">jasonpeacock</span><span>|</span><a href="#42500046">prev</a><span>|</span><a href="#42500175">next</a><span>|</span><label class="collapse" for="c-42499402">[-]</label><label class="expand" for="c-42499402">[43 more]</label></div><br/><div class="children"><div class="content">You should try turning off those features yourself for at least a month and see what happens ;) You’ll learn the answers yourself, much better than us trying to explain them.<p>You’ll learn where all the reference docs live for your language, libraries, and frameworks, and along the way you’ll learn more by actually reading the docs.<p>You’ll learn the value of good project organization and file naming, and explicit import statements.<p>And you’ll learn that the speed of typing, even long method names, is not the limiting factor of your productivity.</div><br/><div id="42500535" class="c"><input type="checkbox" id="c-42500535" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42499588">next</a><span>|</span><label class="collapse" for="c-42500535">[-]</label><label class="expand" for="c-42500535">[1 more]</label></div><br/><div class="children"><div class="content">I agree on turning it off to find out. I disagree with almost all of your takes though. If you work without it, I would similarly suggest turning it in for a month.<p>&gt; You’ll learn where all the reference docs live for your language, libraries, and frameworks, and along the way you’ll learn more by actually reading the docs.<p>I know where they are. I use them every day. But reaching for them to check every argument if every function I use is a waste of time. It als only works for stuff that has a full suite of documentation. If you’re using an internal library you’re very likely searching the code anyway.<p>&gt; good project organisation, file naming and explicit import statements.<p>Good file naming is a crutch for a lack of tooling to explore and modify at a project level. Good project organisation doesn’t require you to disable tooling with semantic knowledge of your project. And explicit imports are a (necessary) distraction m.<p>&gt; And you’ll learn that the speed of typing, even long method names, is not the limiting factor of your productivity.<p>It has nothing to do with the speed of typing and it never has. It has everything to do with working at the abstraction level I want to work at - my codebase. It’s using the tooling that means I think about “I have an X and I need it to do Y. “ rather than “let’s go context switch to the browser to figure out if it’s len, count, size, chars”<p>A good corollary is a linter - it’s incredibly important to the project, knowing and understanding the rules and why they exist is very helpful and would benefit everyone on the team. But a computer can do it for us, and let us focus on writing the code rather than ensuring we have tabs instead of spaces.</div><br/></div></div><div id="42499588" class="c"><input type="checkbox" id="c-42499588" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42500535">prev</a><span>|</span><a href="#42500137">next</a><span>|</span><label class="collapse" for="c-42499588">[-]</label><label class="expand" for="c-42499588">[3 more]</label></div><br/><div class="children"><div class="content">And then you&#x27;ll turn it back on and feel the lifting of a significant mental burden.<p>Autocomplete has never been about the speed of typing things, and always about finding and recalling abstractions that you sort of know but haven&#x27;t committed to strong memory yet.</div><br/><div id="42500035" class="c"><input type="checkbox" id="c-42500035" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499588">parent</a><span>|</span><a href="#42500137">next</a><span>|</span><label class="collapse" for="c-42500035">[-]</label><label class="expand" for="c-42500035">[2 more]</label></div><br/><div class="children"><div class="content">Or for switching between many languages without having to work on remembering if it&#x27;s lowercase, lower, tolower, lcase, or to_lower this time.</div><br/></div></div></div></div><div id="42500137" class="c"><input type="checkbox" id="c-42500137" checked=""/><div class="controls bullet"><span class="by">zaran</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42499588">prev</a><span>|</span><a href="#42499462">next</a><span>|</span><label class="collapse" for="c-42500137">[-]</label><label class="expand" for="c-42500137">[6 more]</label></div><br/><div class="children"><div class="content">Autocomplete is more for discoverability than saving on typed characters, letting you rely less on documentation and more on the actual interface you&#x27;re interacting with</div><br/><div id="42500374" class="c"><input type="checkbox" id="c-42500374" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500137">parent</a><span>|</span><a href="#42500413">next</a><span>|</span><label class="collapse" for="c-42500374">[-]</label><label class="expand" for="c-42500374">[4 more]</label></div><br/><div class="children"><div class="content">I’m curious as how it lets you rely less on documentation. If you don’t know what you’re looking for then how will you know you chose the right thing?<p>The classic example of getting this wrong is probably C# developers using IEnumerable when they should’ve used IQueryable.</div><br/><div id="42500414" class="c"><input type="checkbox" id="c-42500414" checked=""/><div class="controls bullet"><span class="by">MrLeap</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500374">parent</a><span>|</span><a href="#42500474">next</a><span>|</span><label class="collapse" for="c-42500414">[-]</label><label class="expand" for="c-42500414">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on this? I&#x27;m one of C# developers who operate predominately in the Unity3d slums. This isn&#x27;t familiar to me.<p>The closest thing coming to mind to me is mixing up IEnumerable and IEnumerator when trying to define a coroutine.</div><br/><div id="42500461" class="c"><input type="checkbox" id="c-42500461" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500414">parent</a><span>|</span><a href="#42500474">next</a><span>|</span><label class="collapse" for="c-42500461">[-]</label><label class="expand" for="c-42500461">[1 more]</label></div><br/><div class="children"><div class="content">IQuerable Inherits IEnumerable and extends it with functionality to lessen the memory loaded when querying a collection (typically when reading from a database). Using IEnumerable can increase memory usage significantly compared to IQuerable.<p>Not every C# developer knows the difference, in my region of the world it’s an infamous mistake and is often the first thing you look for when tasked with improving bottlenecks in C# backends. On the flip-side, using IQuerable isn’t very efficient if what you wanted was to work on in memory collections.<p>There is an equally infamous somewhat related issue in Python with list vs generators. Especially common when non Python developers work with Python.</div><br/></div></div></div></div><div id="42500474" class="c"><input type="checkbox" id="c-42500474" checked=""/><div class="controls bullet"><span class="by">tazjin</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500374">parent</a><span>|</span><a href="#42500414">prev</a><span>|</span><a href="#42500413">next</a><span>|</span><label class="collapse" for="c-42500474">[-]</label><label class="expand" for="c-42500474">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The classic example of getting this wrong is probably C# developers using IEnumerable when they should’ve used IQueryable.<p>Or literally any function from the standard library in C++, which will likely have undefined behaviour if you look at it wrong and didn&#x27;t read the docs.</div><br/></div></div></div></div><div id="42500413" class="c"><input type="checkbox" id="c-42500413" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500137">parent</a><span>|</span><a href="#42500374">prev</a><span>|</span><a href="#42499462">next</a><span>|</span><label class="collapse" for="c-42500413">[-]</label><label class="expand" for="c-42500413">[1 more]</label></div><br/><div class="children"><div class="content">I have a theory that autocomplete actually increases the API surface area. One of the reasons Java has so many classes and such a huge sprawl is because Java got good tooling pretty early compared to other languages.</div><br/></div></div></div></div><div id="42499462" class="c"><input type="checkbox" id="c-42499462" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42500137">prev</a><span>|</span><a href="#42499928">next</a><span>|</span><label class="collapse" for="c-42499462">[-]</label><label class="expand" for="c-42499462">[19 more]</label></div><br/><div class="children"><div class="content">I use Rust, so explicit imports are required. However, I fail to understand this point<p>&gt; You’ll learn where all the reference docs live for your language, libraries, and frameworks, and along the way you’ll learn more by actually reading the docs.<p>With neovim&#x2F;LSP, I have a key binding (Kg) that opens a small window within the editor with the rustdocs. Not only this is faster than going to the browser, typing the type name, opening the docs, looking up the method but also it ensures that I am looking at the docs of the correct version that my code base is using.<p>I don&#x27;t really understand the aversion to using these tools. They are &quot;auto-complete&quot; and not generative complete. This means you need to know what you are going to type for them to help you.</div><br/><div id="42500062" class="c"><input type="checkbox" id="c-42500062" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499462">parent</a><span>|</span><a href="#42499596">next</a><span>|</span><label class="collapse" for="c-42500062">[-]</label><label class="expand" for="c-42500062">[8 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I don&#x27;t really understand the aversion to using these tools</i><p>No one is yucking your yum, it&#x27;s not an aversion, it&#x27;s that we don&#x27;t <i>need</i> them, it never really occurs to us to use them, just like it never occurs to you to not use them. You make it sound like people who don&#x27;t use them are fumbling and tripping over themselves and aren&#x27;t actually writing any software.</div><br/><div id="42500329" class="c"><input type="checkbox" id="c-42500329" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500062">parent</a><span>|</span><a href="#42499596">next</a><span>|</span><label class="collapse" for="c-42500329">[-]</label><label class="expand" for="c-42500329">[7 more]</label></div><br/><div class="children"><div class="content">&gt; it never really occurs to us to use them, just like it never occurs to you to not use them.<p>This doesn&#x27;t really make sense, either. How do you not consider the right tool for the job? Do you just use whatever you learned to code and never really bothered to consider that you might be more or less productive with different tools? LSPs don&#x27;t always offer a productivity increase in all contexts—they seem to be mostly useless for dynamic languages like ruby and lisp and javascript—but I have a hard time imagining a programmer that couldn&#x27;t benefit from them in the right context.<p>And they&#x27;re just a straight-up improvement from iterative compilation and ctags, the latter of which never really worked very well in the first place.</div><br/><div id="42500351" class="c"><input type="checkbox" id="c-42500351" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500329">parent</a><span>|</span><a href="#42500404">next</a><span>|</span><label class="collapse" for="c-42500351">[-]</label><label class="expand" for="c-42500351">[3 more]</label></div><br/><div class="children"><div class="content">My great-grandmother never used a mixer when making cakes or bread, long after mixers were available, and she was able to pump out treats and full meals without batting an eye, the best anyone ever had.<p>I don&#x27;t have a problem with my &quot;productivity&quot;, whatever that means. I&#x27;m not trying to write code faster, my own experience is that writing code faster leads to shitter code.  I&#x27;m not hindered by my tools, and most of my programming time is spent thinking and understanding, and none of these tools have afforded me better thinking or understanding, and often times they get in the way of my thinking.</div><br/><div id="42500599" class="c"><input type="checkbox" id="c-42500599" checked=""/><div class="controls bullet"><span class="by">oneeyedpigeon</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500351">parent</a><span>|</span><a href="#42500463">next</a><span>|</span><label class="collapse" for="c-42500599">[-]</label><label class="expand" for="c-42500599">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not trying to write code faster, my own experience is that writing code faster leads to shitter code.<p>I&#x27;m wondering who these programmers are who are sitting down for eight hours a day, pumping out perfect code at 200wpm without any breaks. I suspect they might not exist.</div><br/></div></div><div id="42500463" class="c"><input type="checkbox" id="c-42500463" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500351">parent</a><span>|</span><a href="#42500599">prev</a><span>|</span><a href="#42500404">next</a><span>|</span><label class="collapse" for="c-42500463">[-]</label><label class="expand" for="c-42500463">[1 more]</label></div><br/><div class="children"><div class="content">Yes, very zen. How does your pairing partner feel about this?</div><br/></div></div></div></div><div id="42500404" class="c"><input type="checkbox" id="c-42500404" checked=""/><div class="controls bullet"><span class="by">dijksterhuis</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500329">parent</a><span>|</span><a href="#42500351">prev</a><span>|</span><a href="#42499596">next</a><span>|</span><label class="collapse" for="c-42500404">[-]</label><label class="expand" for="c-42500404">[3 more]</label></div><br/><div class="children"><div class="content">i avoid using autocomplete because it forces me to think about every single thing i’m doing.<p>every line of code is a liability. every line of code needs to be thought about. every line of code is precious.<p>spamming autocomplete means i’m not thinking about what i’m doing, even the simple stuff like writing a for loop statement.</div><br/><div id="42500460" class="c"><input type="checkbox" id="c-42500460" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500404">parent</a><span>|</span><a href="#42499596">next</a><span>|</span><label class="collapse" for="c-42500460">[-]</label><label class="expand" for="c-42500460">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use autocomplete, either. Most of what an LSP gives you is more data to scan semantics faster.<p>&gt; every line of code is a liability. every line of code needs to be thought about. every line of code is precious.<p>I personally think this is ridiculous. It&#x27;s code. It&#x27;s just formal instructions. You process them and move on. It&#x27;s not describing the face of god. If you need to think so much write less clever code.</div><br/><div id="42500520" class="c"><input type="checkbox" id="c-42500520" checked=""/><div class="controls bullet"><span class="by">bdhcuidbebe</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500460">parent</a><span>|</span><a href="#42499596">next</a><span>|</span><label class="collapse" for="c-42500520">[-]</label><label class="expand" for="c-42500520">[1 more]</label></div><br/><div class="children"><div class="content">Great, another pragmatic programmer producing sphagetti</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42499596" class="c"><input type="checkbox" id="c-42499596" checked=""/><div class="controls bullet"><span class="by">hirako2000</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499462">parent</a><span>|</span><a href="#42500062">prev</a><span>|</span><a href="#42499626">next</a><span>|</span><label class="collapse" for="c-42499596">[-]</label><label class="expand" for="c-42499596">[7 more]</label></div><br/><div class="children"><div class="content">If you browse through the doc, you will find yourself reading the doc.<p>If your code editor looks up the doc, you find yourself reading what the code editor shows you.<p>Wikipedia, (real) historians have some aversion to using it. No argument, it is convenient.</div><br/><div id="42499654" class="c"><input type="checkbox" id="c-42499654" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499596">parent</a><span>|</span><a href="#42499626">next</a><span>|</span><label class="collapse" for="c-42499654">[-]</label><label class="expand" for="c-42499654">[6 more]</label></div><br/><div class="children"><div class="content">Which is why I mentioned that I am coding in Rust. They are the same docs.</div><br/><div id="42499738" class="c"><input type="checkbox" id="c-42499738" checked=""/><div class="controls bullet"><span class="by">alpinisme</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499654">parent</a><span>|</span><a href="#42499626">next</a><span>|</span><label class="collapse" for="c-42499738">[-]</label><label class="expand" for="c-42499738">[5 more]</label></div><br/><div class="children"><div class="content">I think the point they are making is that you <i>only</i> read what is shown you instead of seeing the full docs and being encouraged to follow rabbit holes and browse nearby info. Speaking for myself, this has been one of the largest boosters in my own career: visits to a docs page that led to me basically reading the whole docs.</div><br/><div id="42499839" class="c"><input type="checkbox" id="c-42499839" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499738">parent</a><span>|</span><a href="#42499626">next</a><span>|</span><label class="collapse" for="c-42499839">[-]</label><label class="expand" for="c-42499839">[4 more]</label></div><br/><div class="children"><div class="content">I am not sure if we are speaking about the same thing. LSP can give you type hints. What I am doing is that I am opening a &quot;window&quot; in my editor that has the full docs. You can browse through it freely. The issue with &quot;non-Rust&quot; languages is that the docs will be on a website. On most Rust projects (90%+), the libraries will use the Docs system which makes the docs fully available on LSP.</div><br/><div id="42499963" class="c"><input type="checkbox" id="c-42499963" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499839">parent</a><span>|</span><a href="#42500531">next</a><span>|</span><label class="collapse" for="c-42499963">[-]</label><label class="expand" for="c-42499963">[2 more]</label></div><br/><div class="children"><div class="content">I believe the distinction is that if you have to manually browse the docs and navigate to the method of interest, you might see something else interesting along the way.<p>Whereas if your editor takes you directly to the method in question, you miss that opportunity.</div><br/><div id="42500452" class="c"><input type="checkbox" id="c-42500452" checked=""/><div class="controls bullet"><span class="by">powersnail</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499963">parent</a><span>|</span><a href="#42500531">next</a><span>|</span><label class="collapse" for="c-42500452">[-]</label><label class="expand" for="c-42500452">[1 more]</label></div><br/><div class="children"><div class="content">If I want to read through the doc, I&#x27;ll just do that, and I frequently do it with all dependencies that I&#x27;m directly interacting with. As fun and informative as it is, personally I don&#x27;t want to do this exercise every time I need a peek at the documentation of a class or function, in the same way I don&#x27;t take a detour into the mountain every time I get out of my house, as much as I enjoy hiking.</div><br/></div></div></div></div><div id="42500531" class="c"><input type="checkbox" id="c-42500531" checked=""/><div class="controls bullet"><span class="by">bdhcuidbebe</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499839">parent</a><span>|</span><a href="#42499963">prev</a><span>|</span><a href="#42499626">next</a><span>|</span><label class="collapse" for="c-42500531">[-]</label><label class="expand" for="c-42500531">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The issue with &quot;non-Rust&quot; languages is that the docs will be on a website.<p>We have tooling for offline docs of course. See dash (macOS) or zeal (win&#x2F;linux)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42499555" class="c"><input type="checkbox" id="c-42499555" checked=""/><div class="controls bullet"><span class="by">not-my-account</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499462">parent</a><span>|</span><a href="#42499626">prev</a><span>|</span><a href="#42499928">next</a><span>|</span><label class="collapse" for="c-42499555">[-]</label><label class="expand" for="c-42499555">[2 more]</label></div><br/><div class="children"><div class="content">Do you have your neovim config public?</div><br/><div id="42499585" class="c"><input type="checkbox" id="c-42499585" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499555">parent</a><span>|</span><a href="#42499928">next</a><span>|</span><label class="collapse" for="c-42499585">[-]</label><label class="expand" for="c-42499585">[1 more]</label></div><br/><div class="children"><div class="content">Not really, as I have API keys and other stuff in it unprotected. However, I used this as a base (<a href="https:&#x2F;&#x2F;github.com&#x2F;ayamir&#x2F;nvimdots">https:&#x2F;&#x2F;github.com&#x2F;ayamir&#x2F;nvimdots</a>) and heavily modified it. There is a user directory (lookup the user_template) where you can config everything out of the base.</div><br/></div></div></div></div></div></div><div id="42499928" class="c"><input type="checkbox" id="c-42499928" checked=""/><div class="controls bullet"><span class="by">enjo</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42499462">prev</a><span>|</span><a href="#42499474">next</a><span>|</span><label class="collapse" for="c-42499928">[-]</label><label class="expand" for="c-42499928">[8 more]</label></div><br/><div class="children"><div class="content">&gt;And you’ll learn that the speed of typing, even long method names, is not the limiting factor of your productivity.<p>This is the fundamental truth that those pushing AI as a replacement for programmers miss (intentionally or not).</div><br/><div id="42500173" class="c"><input type="checkbox" id="c-42500173" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499928">parent</a><span>|</span><a href="#42500198">next</a><span>|</span><label class="collapse" for="c-42500173">[-]</label><label class="expand" for="c-42500173">[1 more]</label></div><br/><div class="children"><div class="content">What does replacing programmers have to do with typing speed? You mean the stuff copilot does was never the limiting factor of productivity? I agree, but copilot is not replacing programmers; replacing programmers is more than typing and proponents know that. It might get there.<p>I still don&#x27;t understand how it would hurt if you can focus on the parts that do influence your productivity and have the rest appear automatically. But that&#x27;s just me.</div><br/></div></div><div id="42500198" class="c"><input type="checkbox" id="c-42500198" checked=""/><div class="controls bullet"><span class="by">motorest</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42499928">parent</a><span>|</span><a href="#42500173">prev</a><span>|</span><a href="#42499474">next</a><span>|</span><label class="collapse" for="c-42500198">[-]</label><label class="expand" for="c-42500198">[6 more]</label></div><br/><div class="children"><div class="content">&gt; This is the fundamental truth that those pushing AI as a replacement for programmers miss (intentionally or not).<p>I think this blend of comment shows a good dose of ignorance discussing the role of AI as a replacement for programmers.<p>It&#x27;s not like PMs are suddenly seeing engineers vanish from software projects. It&#x27;s that AI makes developers so much more productive that you only need a subset of them to meet your work requirements.<p>To give you an example, AI tools can indeed help you write whole modules. Yes, code can be buggy. Yet, the &quot;typing&quot; part is not what developers benefit from AI. Developers can iterate way faster on designs and implementations by prompting LLMs to generate new components based on new rewuirements, which saves you the job of refactoring any code. LLMs can instantly review changes and suggest ways to improve it, which would require either reading up on the topic or asking a fellow engineer on payroll to spend their time doing the same job. LLMs can explain entire codebases to you without asking a single question to veteran engineers in the team. LLMs can even write all your unit tests and rewrite them again and again as you see fit. LLMs can even recommend best practices, explain tradeoffs of approaches, and suggest suitable names for methods&#x2F;variables based on specific criterias.<p>This means AI can do a multitude of jobs that previously you needed a whole team to do, and for that you no longer need whole teams to do a job.</div><br/><div id="42500550" class="c"><input type="checkbox" id="c-42500550" checked=""/><div class="controls bullet"><span class="by">oneeyedpigeon</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500198">parent</a><span>|</span><a href="#42500493">next</a><span>|</span><label class="collapse" for="c-42500550">[-]</label><label class="expand" for="c-42500550">[1 more]</label></div><br/><div class="children"><div class="content">&gt; LLMs can instantly review changes and suggest ways to improve it, which would require either reading up on the topic or asking a fellow engineer on payroll to spend their time doing the same job.<p>If we train ourselves out of being able to do these tasks, won&#x27;t we find it harder to recognise when the AI makes mistakes?</div><br/></div></div><div id="42500493" class="c"><input type="checkbox" id="c-42500493" checked=""/><div class="controls bullet"><span class="by">bdhcuidbebe</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500198">parent</a><span>|</span><a href="#42500550">prev</a><span>|</span><a href="#42500349">next</a><span>|</span><label class="collapse" for="c-42500493">[-]</label><label class="expand" for="c-42500493">[1 more]</label></div><br/><div class="children"><div class="content">So what Ai models are usable for producing a navigatable structure?<p>I wasnt aware of any that could</div><br/></div></div><div id="42500349" class="c"><input type="checkbox" id="c-42500349" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500198">parent</a><span>|</span><a href="#42500493">prev</a><span>|</span><a href="#42500222">next</a><span>|</span><label class="collapse" for="c-42500349">[-]</label><label class="expand" for="c-42500349">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s that AI makes developers so much more productive that you only need a subset of them to meet your work requirements.<p>my experience so far is that it takes away the upfront thinking and leads to a mess of code that I then have to sit down with them and try to work through.</div><br/></div></div><div id="42500222" class="c"><input type="checkbox" id="c-42500222" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500198">parent</a><span>|</span><a href="#42500349">prev</a><span>|</span><a href="#42499474">next</a><span>|</span><label class="collapse" for="c-42500222">[-]</label><label class="expand" for="c-42500222">[2 more]</label></div><br/><div class="children"><div class="content">Was this comment written by a bot? The concluding paragraph style and general length suggest to me it was.</div><br/><div id="42500234" class="c"><input type="checkbox" id="c-42500234" checked=""/><div class="controls bullet"><span class="by">motorest</span><span>|</span><a href="#42499402">root</a><span>|</span><a href="#42500222">parent</a><span>|</span><a href="#42499474">next</a><span>|</span><label class="collapse" for="c-42500234">[-]</label><label class="expand" for="c-42500234">[1 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t, and if it did I would wager it would write it more elegantly and coherently than me. That goes to show how much I use Claude&#x2F;Copilot&#x2F;ChatGPT at my job.</div><br/></div></div></div></div></div></div></div></div><div id="42499474" class="c"><input type="checkbox" id="c-42499474" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42499928">prev</a><span>|</span><a href="#42500281">next</a><span>|</span><label class="collapse" for="c-42499474">[-]</label><label class="expand" for="c-42499474">[1 more]</label></div><br/><div class="children"><div class="content">Personally, the biggest benefit I get from LSPs is just proactively letting me know compiler errors before running the compiler (and I miss this working in extremely dynamic situations, like macro-heavy lisps). I definitely would side-eye someone who willingly eschewed that. But the rest of your points are well stated from my perspective</div><br/></div></div><div id="42500281" class="c"><input type="checkbox" id="c-42500281" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42499474">prev</a><span>|</span><a href="#42500004">next</a><span>|</span><label class="collapse" for="c-42500281">[-]</label><label class="expand" for="c-42500281">[1 more]</label></div><br/><div class="children"><div class="content">No but speed of lookup is definitely a limiting factor. And with rust goto definition also goes to the doc comment so I can easily read the docs in my IDE</div><br/></div></div><div id="42500004" class="c"><input type="checkbox" id="c-42500004" checked=""/><div class="controls bullet"><span class="by">CrimsonRain</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42500281">prev</a><span>|</span><a href="#42500037">next</a><span>|</span><label class="collapse" for="c-42500004">[-]</label><label class="expand" for="c-42500004">[1 more]</label></div><br/><div class="children"><div class="content">None of these need the absence of those features.<p>I do all of these, I also use auto complete, all LSP features and then some. And ofc copilot etc too.</div><br/></div></div><div id="42500037" class="c"><input type="checkbox" id="c-42500037" checked=""/><div class="controls bullet"><span class="by">1209412comb</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42500004">prev</a><span>|</span><a href="#42499988">next</a><span>|</span><label class="collapse" for="c-42500037">[-]</label><label class="expand" for="c-42500037">[1 more]</label></div><br/><div class="children"><div class="content">It is pretty bad because coworkers use LSP &#x2F; fuzzysearch and they will not do naming in a way that&#x27;s more easy for the brain.</div><br/></div></div><div id="42499988" class="c"><input type="checkbox" id="c-42499988" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#42499402">parent</a><span>|</span><a href="#42500037">prev</a><span>|</span><a href="#42500175">next</a><span>|</span><label class="collapse" for="c-42499988">[-]</label><label class="expand" for="c-42499988">[1 more]</label></div><br/><div class="children"><div class="content">Counter argument - I did this for years with neovim in all my side projects, and now I have a fast minimal autocomplete set up I enjoy it a lot more. Turns out I never did memorise the entire API surface of rust, and enjoy the editor suggesting functions.</div><br/></div></div></div></div><div id="42500175" class="c"><input type="checkbox" id="c-42500175" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#42499402">prev</a><span>|</span><a href="#42500415">next</a><span>|</span><label class="collapse" for="c-42500175">[-]</label><label class="expand" for="c-42500175">[1 more]</label></div><br/><div class="children"><div class="content">I liken this to asking people who don’t use a GPS how they drive and if they have every intersection memorized. It’s not about absolute knowledge of a codebase, but intimate familiarity.<p>I also don’t think it’s a coincidence most people in the comments seem to be using some flavor of vim. I think using an editor designed before these tools were available will make it much easier than afterwards.<p>I’m not sure I’m the best case, but I just turned off copilot, haven’t bothered to configure my autocomplete yet in my latest neovim config, and only use an LSP so my macros can be highlighted differently. I write primarily in Clojure though, so inline docs and go to definition are just a part of life.<p>I don’t really have anything against LSPs, but neovim, telescope, and the repl have always gotten me where I want to go<p>With regards to my flow, I’ll normally have 1 vim session for every 1 project, each with 1-5 tabs open, each tab with up to 12 splits. There isn’t really structure to the tabs or splits, I’m just liberal with opening splits and conservative with closing them. To me it can be really helpful to have all the recent code I’ve been working on open at one time, and if it’s not, I just pop a new tab and start fresh</div><br/></div></div><div id="42500415" class="c"><input type="checkbox" id="c-42500415" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#42500175">prev</a><span>|</span><a href="#42500616">next</a><span>|</span><label class="collapse" for="c-42500415">[-]</label><label class="expand" for="c-42500415">[1 more]</label></div><br/><div class="children"><div class="content">I use Emacs and sometimes I open a window to bring up a man page or code definition for some function, but I&#x27;ve never felt the need for a fancy IDE.  You just get used to what is going on in the code.  Like if you are a fiction writer and you&#x27;re asked to write a new Star Trek episode, after watching a few existing episodes you would get familiar enough with the characters and milieu to not need to refer to the series bible too much.  An IDE that pops up suggestions like &quot;Live long and prosper&quot; or &quot;we have 93.2357% chance of blowing up the ship, Captain&quot; when you type the name &quot;Spock&quot; sounds counterproductive.  Maybe I&#x27;m missing something though.<p>Added: it helps a lot to have real documentation, something that has gone out of fashion in recent years.  Maybe these IDE&#x27;s are being used as a substitute.  I hadn&#x27;t thought of it that way before.  Hmm.<p>Added 2: Also, Emacs has always had TAGS (this quick navigates the editor to a function&#x27;s definition given its name) and I do use that sometimes.</div><br/></div></div><div id="42500616" class="c"><input type="checkbox" id="c-42500616" checked=""/><div class="controls bullet"><span class="by">jgb1984</span><span>|</span><a href="#42500415">prev</a><span>|</span><a href="#42499911">next</a><span>|</span><label class="collapse" for="c-42500616">[-]</label><label class="expand" for="c-42500616">[2 more]</label></div><br/><div class="children"><div class="content">Been using Debian and vim for almost 25 years now. Tried many IDE&#x27;s but they&#x27;re distracting, bloated and slow.<p>My main language is python and for that I use jedi-vim (which allows me to jump to a definition), fzf with ripgrep to easily open files and search for specific things, and ALE that runs ruff formatting and linting. Tmux to keep my terminals organized and openbox to make it stylish and stay out of the way.<p>No LSP, no autocomplete, and sure as hell no AI nonsense.</div><br/><div id="42500620" class="c"><input type="checkbox" id="c-42500620" checked=""/><div class="controls bullet"><span class="by">ggggggreat</span><span>|</span><a href="#42500616">parent</a><span>|</span><a href="#42499911">next</a><span>|</span><label class="collapse" for="c-42500620">[-]</label><label class="expand" for="c-42500620">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and sure as hell no AI nonsense.<p>You&#x27;re emotionally invested. Not wise.</div><br/></div></div></div></div><div id="42499911" class="c"><input type="checkbox" id="c-42499911" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#42500616">prev</a><span>|</span><a href="#42499627">next</a><span>|</span><label class="collapse" for="c-42499911">[-]</label><label class="expand" for="c-42499911">[5 more]</label></div><br/><div class="children"><div class="content">I turn off autocomplete everywhere I can. Whether web searches, composing code, or anything else, I do not want the computer anticipating what I am about to type. I find it is often wrong, and always distracting.<p>Yes, I try to learn the language well enough that I know the parameters of common functions. If I don&#x27;t, I consult the docs. If I need to find the definition of a function in another file, I use grep.</div><br/><div id="42499935" class="c"><input type="checkbox" id="c-42499935" checked=""/><div class="controls bullet"><span class="by">cjohnson318</span><span>|</span><a href="#42499911">parent</a><span>|</span><a href="#42499627">next</a><span>|</span><label class="collapse" for="c-42499935">[-]</label><label class="expand" for="c-42499935">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing more annoying than putting my cursor on text, and then having a pop-up block that text.</div><br/><div id="42500008" class="c"><input type="checkbox" id="c-42500008" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42499911">root</a><span>|</span><a href="#42499935">parent</a><span>|</span><a href="#42499995">next</a><span>|</span><label class="collapse" for="c-42500008">[-]</label><label class="expand" for="c-42500008">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Completion, yes. <i>Auto</i>-completion, no.<p>Disclaimer: I do use LSPs extensively, but they do what they are intended to do when I explicitly ask. Offer completions. Format code. Organize imports. All that is available, but only happens when I ask. Same happens where there&#x27;s no LSP support, and basically the same commands depend on ripgrep, fzf, semantic-grep, external linters and formatters, and plainly compilers.<p>Me and my tools take turns. It&#x27;s almost 2025, practically everybody agrees that concurrent mutation of state is a source if trouble.</div><br/></div></div><div id="42499995" class="c"><input type="checkbox" id="c-42499995" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#42499911">root</a><span>|</span><a href="#42499935">parent</a><span>|</span><a href="#42500008">prev</a><span>|</span><a href="#42500344">next</a><span>|</span><label class="collapse" for="c-42499995">[-]</label><label class="expand" for="c-42499995">[1 more]</label></div><br/><div class="children"><div class="content">I find myself mashing escape regularly in PyCharm to get rid of dialogs that interrupt my view and&#x2F;or train of thought.</div><br/></div></div><div id="42500344" class="c"><input type="checkbox" id="c-42500344" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#42499911">root</a><span>|</span><a href="#42499935">parent</a><span>|</span><a href="#42499995">prev</a><span>|</span><a href="#42499627">next</a><span>|</span><label class="collapse" for="c-42500344">[-]</label><label class="expand" for="c-42500344">[1 more]</label></div><br/><div class="children"><div class="content">Why does it block it and not the adjacent area?</div><br/></div></div></div></div></div></div><div id="42499627" class="c"><input type="checkbox" id="c-42499627" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#42499911">prev</a><span>|</span><a href="#42500523">next</a><span>|</span><label class="collapse" for="c-42499627">[-]</label><label class="expand" for="c-42499627">[4 more]</label></div><br/><div class="children"><div class="content">Most of these tools are distractions. I don&#x27;t <i>want</i> suggestions or needling warnings sliding around on my screen while I compose and examine programs; I want a quiet space to write and think. Focus is essential.<p>I organize notes and action items in a paper notebook in front of me or a text file in another editor pane. I read the code. I search and diff with standard POSIX utilities that are available in every environment. In the languages which support it, I try ideas and answer my own questions in a REPL.<p>Practice leaning on tooling all day and living without it will feel unthinkable. Practice doing without, and you&#x27;ll find you need very little.</div><br/><div id="42500451" class="c"><input type="checkbox" id="c-42500451" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42499627">parent</a><span>|</span><a href="#42499636">next</a><span>|</span><label class="collapse" for="c-42500451">[-]</label><label class="expand" for="c-42500451">[1 more]</label></div><br/><div class="children"><div class="content">If you prefer not to, that&#x27;s fine; we all have our preferences. But I&#x27;d ask the person who pairs with you how much the productivity is actually impacted. In my experience engineers are very prone to romanticizing arbitrary stuff (languages, editors, tools, window paradigms, processes, debuggers, event fonts and colors or whatever). Your coworkers will see right through it, though, and won&#x27;t hesitate to be honest.</div><br/></div></div><div id="42499636" class="c"><input type="checkbox" id="c-42499636" checked=""/><div class="controls bullet"><span class="by">burnte</span><span>|</span><a href="#42499627">parent</a><span>|</span><a href="#42500451">prev</a><span>|</span><a href="#42500523">next</a><span>|</span><label class="collapse" for="c-42499636">[-]</label><label class="expand" for="c-42499636">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. I don&#x27;t need my code to turn red just because I haven&#x27;t finished writing the entire line. I&#x27;m aware this isn&#x27;t valid code, I&#x27;m not done.</div><br/><div id="42499649" class="c"><input type="checkbox" id="c-42499649" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#42499627">root</a><span>|</span><a href="#42499636">parent</a><span>|</span><a href="#42500523">next</a><span>|</span><label class="collapse" for="c-42499649">[-]</label><label class="expand" for="c-42499649">[1 more]</label></div><br/><div class="children"><div class="content">It is remarkable how much easier it is to acquire and recall relevant information  while programming if you don&#x27;t have an IDE constantly spraying distractions in your face and breaking up your train of thought.</div><br/></div></div></div></div></div></div><div id="42500523" class="c"><input type="checkbox" id="c-42500523" checked=""/><div class="controls bullet"><span class="by">bigpingo</span><span>|</span><a href="#42499627">prev</a><span>|</span><a href="#42499519">next</a><span>|</span><label class="collapse" for="c-42500523">[-]</label><label class="expand" for="c-42500523">[1 more]</label></div><br/><div class="children"><div class="content">I hate annoying distractions, be it popups, beeps, notifications, alerts, auto brace&#x2F;quotes&#x2F;etc and autocomplete prompts. I turn <i>all</i> of that off in every program because I want to be in total control of the computer.<p>When it comes to autocomplete specifically I initially turned it off because I was mainly a C++ programmer and C++ autocomplete has just never been good enough and a half-working autocomplete is just worse than nothing at all because you end up stalling and waiting for the prompt.
But eventually I just grew to hate it for all languages because it interrupts flow and &quot;pipelining&quot;.</div><br/></div></div><div id="42499519" class="c"><input type="checkbox" id="c-42499519" checked=""/><div class="controls bullet"><span class="by">scop</span><span>|</span><a href="#42500523">prev</a><span>|</span><a href="#42500572">next</a><span>|</span><label class="collapse" for="c-42499519">[-]</label><label class="expand" for="c-42499519">[3 more]</label></div><br/><div class="children"><div class="content">I have jumped around over my career: Sublime -&gt; Vim -&gt; Emacs -&gt; VSCode -&gt; Neovim -&gt; Cursor, which is now my daily driver.<p>However, I still relish in the ability to open up a nerfed Sublime or basic Vim install where it’s just me and the text. I do so when I want particular lucidity in my thought process and code composition.<p>Then I can always fire up heavier tools for code review  after the fact. How do I “do” it? I got really good at grep’n my way through a code base. It’s amazing what grep&#x2F;ack&#x2F;rg&#x2F;etc can tell you when you know what to ask. And if you don’t know what to ask, well finding <i>that answer</i> is going to teach you a lot more than just hitting Tab on autocomplete or GoToDef.</div><br/><div id="42499601" class="c"><input type="checkbox" id="c-42499601" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#42499519">parent</a><span>|</span><a href="#42500572">next</a><span>|</span><label class="collapse" for="c-42499601">[-]</label><label class="expand" for="c-42499601">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found cursor tends to muck up system internals and such when I use shells in it. There is a lot going on under that hood -- would prefer it work as a VS Code extension so it has some guardrails.</div><br/><div id="42500274" class="c"><input type="checkbox" id="c-42500274" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#42499519">root</a><span>|</span><a href="#42499601">parent</a><span>|</span><a href="#42500572">next</a><span>|</span><label class="collapse" for="c-42500274">[-]</label><label class="expand" for="c-42500274">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried the Clive or Continue extensions? AFAIK Continue is somewhat like Cursor. I prefer Clive though, it&#x27;s become an important part of my workflow - although perhaps even more important is knowing when not to teach for it.</div><br/></div></div></div></div></div></div><div id="42500572" class="c"><input type="checkbox" id="c-42500572" checked=""/><div class="controls bullet"><span class="by">herbst</span><span>|</span><a href="#42499519">prev</a><span>|</span><a href="#42500586">next</a><span>|</span><label class="collapse" for="c-42500572">[-]</label><label class="expand" for="c-42500572">[1 more]</label></div><br/><div class="children"><div class="content">I feel heavily annoyed from most IDE features. I love to code in a chill relaxed way where I just write the code that I want.<p>I actually remember all the relevant fields and I am currently working on, or just reread the relevant code when necessary.<p>I wonder if syntax and cute grammar has any relevance in a world where people basically let the IDE to the coding.<p>I honestly wouldn&#x27;t call me a good coder if I wasn&#x27;t confident I could produce the same code quality on a computer with just nano or vim and no internet.</div><br/></div></div><div id="42500586" class="c"><input type="checkbox" id="c-42500586" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42500572">prev</a><span>|</span><a href="#42500041">next</a><span>|</span><label class="collapse" for="c-42500586">[-]</label><label class="expand" for="c-42500586">[1 more]</label></div><br/><div class="children"><div class="content">Some of us learned (and later shared it) at the times when you had to <i>close</i> an editor to access digital manuals. We went through different phases of “dev envs”, some of which were not that advanced (or later died), and we invented our own stable ways to overcome the issues. Some people chose complete off-road, some found a balanced approach. It all turned into various knowledge bases, muscle memory, tools, habits - that we shared. Inadvertently that created more people who do the same but might never have the issue in the first place.<p>When someone tries to repeat that from an IDE&#x2F;LSP perspective, it obviously feels slow, akin to speaking a new language for the first time. Does one need this language? It’s hard to tell.<p>Problems show different contrast to people with different backgrounds. My personal position here is that if you shouldn’t solve non-problems. The set of problems you decide for yourself based on your experience.<p>I’m a balanced guy, btw. Sometimes I just sit and try to force upgrade my dev env. What sticks sticks. What doesn’t, goes to hell. I’m using ALE (nice multi-LSP tool) and all the tools I know since ancient times. Copilot writes what I call boilerplate, and I neither trust it nor have the need to write it. Passing my real-business functions to LLMs usually produces unfixable mess, so if someone knows another way for it to be useful, I’m all ears.</div><br/></div></div><div id="42500041" class="c"><input type="checkbox" id="c-42500041" checked=""/><div class="controls bullet"><span class="by">codazoda</span><span>|</span><a href="#42500586">prev</a><span>|</span><a href="#42492874">next</a><span>|</span><label class="collapse" for="c-42500041">[-]</label><label class="expand" for="c-42500041">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What do you do if you need to look up the definition&#x2F;implementation<p>I have these features on (more or less) and I still use grep, ag (the silver searcher), and GitHub search. I often need to look for things my editor can’t possibly figure out. I’ve never found editors to be great at this. Then again, I probably haven’t optimized for it. I’ll admit that might be a mistake. Old habits die hard sometimes.<p>BTW, I’m usually looking for other people’s work or code I wrote long ago.  Functions written somewhere in a vast code base that I don’t have completely checked out (because I’ve never coded on parts of it). I don’t think much about the obvious stuff, like a function in the standard library.</div><br/></div></div><div id="42492874" class="c"><input type="checkbox" id="c-42492874" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#42500041">prev</a><span>|</span><a href="#42499623">next</a><span>|</span><label class="collapse" for="c-42492874">[-]</label><label class="expand" for="c-42492874">[1 more]</label></div><br/><div class="children"><div class="content">I use vim with ctags. vim has good autocomplete but I don&#x27;t use it much -- I rely on memory and looking things up in the docs. With ctags I can jump to definition&#x2F;implementation of a function.<p>ctags has worked since the early 1990s.<p>Check out this video: How to do 90% of what plugins do with just vim.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;XA2WjJbmmoM" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;XA2WjJbmmoM</a></div><br/></div></div><div id="42499623" class="c"><input type="checkbox" id="c-42499623" checked=""/><div class="controls bullet"><span class="by">jez</span><span>|</span><a href="#42492874">prev</a><span>|</span><a href="#42499513">next</a><span>|</span><label class="collapse" for="c-42499623">[-]</label><label class="expand" for="c-42499623">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What do you do if you need to look up the definition&#x2F;implementation of some function which is in some other file?<p>Code search (ripgrep, GitHub search, Sourcegraph, git grep, or even just plain grep). You can use VS Code search but I prefer CLI tools so I can filter the output of my search with more searches—VS Code makes it hard to post-process&#x2F;filter project-wide search results.<p>Filename search (fzf, fd, or just find).<p>There are cases where LSP-powered Go to Def is faster, but there are also cases where it’s less accurate. I’m talking:<p>- Untyped code in a graduate typed language<p>- References of a method name in a YAML file pulled out with reflection<p>- References of that method in a comment of some other method, where that method is actually the method I’m looking for.<p>- A one-to-one mapping of method names with some enum somewhere else, but lowercase in one spot, and all caps in the other spot.<p>So yes, sometimes go to def will be faster, but you’ll lose out on so many other possible references.<p>Another case: repos where the codebase is so large that the editor tooling is slow. Repos where I’m brand new to it, because I just need to check why some code in a third-party library is going haywire.<p>Grep (code search) is just so powerful.<p>I have a post about how to do large-scale code migrations&#x2F;codemods. Everyone assumes the post is going to be about how to use high-powered, language-aware AST-based static analysis tooling. But half the post is talking about the unreasonable effectiveness of regular expressions.</div><br/></div></div><div id="42499513" class="c"><input type="checkbox" id="c-42499513" checked=""/><div class="controls bullet"><span class="by">freehorse</span><span>|</span><a href="#42499623">prev</a><span>|</span><a href="#42500494">next</a><span>|</span><label class="collapse" for="c-42499513">[-]</label><label class="expand" for="c-42499513">[1 more]</label></div><br/><div class="children"><div class="content">I do not really belong to that group, but when I am learning a new language I avoid using LSPs and anything more than a generic autocomplete because I find that too distracting while I try to learn the language. Moreover I realised that it actually slows down my learning; I may type stuff faster but I learn and gain understanding slower compared to eg typing everything and searching the docs. In stuff I am already proficient with, it makes more sense to me as such tools help me code faster, including finding and fixing bugs faster.<p>As for copilot, I find it impractically distracting and I do not understand how people are supposed to code with it tbh. While coding I spend most time thinking about the code than just typing, and having random autocomplete suggestions popping up with lag while typing disturbs my chain of thoughts. Maybe if I was writing more boilerplate I would have liked it more, or I am using it wrong somehow, or maybe one gets used to it after some time. I sometimes use copilot chat though.</div><br/></div></div><div id="42500494" class="c"><input type="checkbox" id="c-42500494" checked=""/><div class="controls bullet"><span class="by">vinc</span><span>|</span><a href="#42499513">prev</a><span>|</span><a href="#42499390">next</a><span>|</span><label class="collapse" for="c-42500494">[-]</label><label class="expand" for="c-42500494">[2 more]</label></div><br/><div class="children"><div class="content">I have code completion in vim and I try it every few years and sure it can save a few key strokes but the habit of using it never stays with me.<p>I think I just learn the code base and build a mental model of where everything is and it works for me. I spend more time thinking about how to organize my code well than to actually type it in my editor anyway. It probably helps that I&#x27;m working on Rails apps so there are strong conventions about how to do things that makes this easier.</div><br/><div id="42500532" class="c"><input type="checkbox" id="c-42500532" checked=""/><div class="controls bullet"><span class="by">welder</span><span>|</span><a href="#42500494">parent</a><span>|</span><a href="#42499390">next</a><span>|</span><label class="collapse" for="c-42500532">[-]</label><label class="expand" for="c-42500532">[1 more]</label></div><br/><div class="children"><div class="content">Same here, code completion just gets in the way and messes up what I was already planning to type.<p>But I DO use jump-to-definition in Vim and other editors. IMO LSP has been an amazing productivity boost just by that one feature.</div><br/></div></div></div></div><div id="42499390" class="c"><input type="checkbox" id="c-42499390" checked=""/><div class="controls bullet"><span class="by">patchymcnoodles</span><span>|</span><a href="#42500494">prev</a><span>|</span><a href="#42500416">next</a><span>|</span><label class="collapse" for="c-42499390">[-]</label><label class="expand" for="c-42499390">[1 more]</label></div><br/><div class="children"><div class="content">For me it is actually a disturbance, especially autocomplete. So yes, I need to remember stuff, but if I cannot or just don&#x27;t know the codebase, I look it up very quickly and then can learn more from looking at the specific code.<p>At the start of learning rust I used a bit more help from the IDE, but now not anymore.<p>For me it is just easier to have a much deeper knowledge instead of &quot;only&quot; have knowledge about the tools. A good example was when I used SVN back in the days, I only used a GUI and always struggled if something does not work out. I had basically no idea, what is really going on. So when Git became the new normal I forced myself to use the command line only and because of that I can always help myself (with Git atleast :D).<p>Certainly not something for everyone, but it works for me :).</div><br/></div></div><div id="42500416" class="c"><input type="checkbox" id="c-42500416" checked=""/><div class="controls bullet"><span class="by">ximm</span><span>|</span><a href="#42499390">prev</a><span>|</span><a href="#42499409">next</a><span>|</span><label class="collapse" for="c-42500416">[-]</label><label class="expand" for="c-42500416">[1 more]</label></div><br/><div class="children"><div class="content">I prefer using language agnostic tools where possible because that is both simpler and allows me to use the same tools with every language. For example, git, grep, or vim all work on any text file. vim has a few language specific settings though (e.g. syntax highlighting).</div><br/></div></div><div id="42499409" class="c"><input type="checkbox" id="c-42499409" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#42500416">prev</a><span>|</span><a href="#42500326">next</a><span>|</span><label class="collapse" for="c-42499409">[-]</label><label class="expand" for="c-42499409">[1 more]</label></div><br/><div class="children"><div class="content">I tried copilot for a few months, found it annoying, and uninstalled it. These tools make IDEs&#x2F;LSP unnecessary for my workflow:<p>1) regex be it grep, or equivalents built into the editor. 2) Multi-cursor editing. 3) dumb autocomplete. 4) knowing how to type fast.<p>About 70% of the code I write at work is C. Another 20% is Rust (which does have a nice LSP implementation that I use, though I wouldn&#x27;t call it essential), and the remaining 10% is the usual bash&#x2F;Python&#x2F;Ruby&#x2F;cmake&#x2F;make mumbo jumbo.</div><br/></div></div><div id="42500326" class="c"><input type="checkbox" id="c-42500326" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#42499409">prev</a><span>|</span><a href="#42499530">next</a><span>|</span><label class="collapse" for="c-42500326">[-]</label><label class="expand" for="c-42500326">[1 more]</label></div><br/><div class="children"><div class="content">As many others I do use fd&#x2F;rg&#x2F;ctags, custom scripts, some even Perl ones;  Today I’m on Kakoune but had plenty of Emacs integrations when it was my daily driver (Kakoune taught me to pipe selection through a script that echoes code fragment which works in most editors, e.g.: `|gosnip_if_err_panic.pl` with `responseErr` selected).<p>I think that the reasons I’m not using IDEs&#x2F;LSP are more worthy sharing:<p>First one is that I cannot use one. While the main language I’m using has relatively ok LSP, the codebase prevents usage - as it’s ridden with circular dependencies, macros, module aliasing and multi dispatch cast chains. Everything outside of syntax highlight it unusable.<p>Second: I noticed that assisted coding is like GPS assisted driving. I stopped internally understanding architecture of the code when using IDEs, this disconnected my mind from the code and at some point it started to feel like shoveling. Mindlessly spit out the code at let IDE handle the rest. That made me efficient at local change but unable to build up and see „big picture”. It bothered me to the point I decided to not use them anymore.<p>The third thing is that I don’t take „no” (coming from software) for an answer. I often get those specific needs for code search&#x2F;refactorings that IDEs&#x2F;LSPs refuse to work with. E.g. I need to search customized OpenAPI specifications and link it to a macros&#x2F;generated code for browsing. IDEs&#x2F;LSPs cannot help as it’s not idiomatic, so I customize. And customization is a loop. You customize, you learn how to customize better, you customize more etc.<p>When it comes to LLM-based aids I’m at point of minimum trust. I’ve experienced so many problems
with that code that I rather just disable it entirely. Example? I was setting up Ticker based waiters for Go and then in one place I accepted `time.NewTimer` local-LLM snippet instead of `time.NewTicker` in infinite loop. It was 4 lines of code and looked VERY similar as in 3 functions above (that was before code reduction phase). For those unfamiliar: Go’s ticker ticks every N time. Timer fires once. One-shot-fire in infinite loop == lock.  Took 4 hours to debug.<p>I’m not against using LSP&#x2F;IDEs. They have their use (but for Pete’s sake ask your organization leaders before feeding proprietary code into ChatGPT). They don’t work for me, I feel dumber. Maybe I’d be more efficient but I don’t care. I do this job also for fun, and GPS kills the fun part for me.</div><br/></div></div><div id="42499530" class="c"><input type="checkbox" id="c-42499530" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#42500326">prev</a><span>|</span><a href="#42500450">next</a><span>|</span><label class="collapse" for="c-42499530">[-]</label><label class="expand" for="c-42499530">[5 more]</label></div><br/><div class="children"><div class="content">I learned and worked for decades before these tools were available. If they still weren’t available today, you would find that you too could program without them.</div><br/><div id="42499929" class="c"><input type="checkbox" id="c-42499929" checked=""/><div class="controls bullet"><span class="by">brookst</span><span>|</span><a href="#42499530">parent</a><span>|</span><a href="#42500450">next</a><span>|</span><label class="collapse" for="c-42499929">[-]</label><label class="expand" for="c-42499929">[4 more]</label></div><br/><div class="children"><div class="content">Sure, but isn’t this just “why don’t you use the backup camera that all cars have had for a decade or more” &#x2F; “I learned to drive without one, and you could too”?</div><br/><div id="42500132" class="c"><input type="checkbox" id="c-42500132" checked=""/><div class="controls bullet"><span class="by">bingaweek</span><span>|</span><a href="#42499530">root</a><span>|</span><a href="#42499929">parent</a><span>|</span><a href="#42500513">next</a><span>|</span><label class="collapse" for="c-42500132">[-]</label><label class="expand" for="c-42500132">[1 more]</label></div><br/><div class="children"><div class="content">Are we trying out car analogies? How about instead of backup cameras, which are consistent and provide extra information, you have a camera that randomly guesses things around your car? Sometimes it&#x27;s right, sometimes it&#x27;s wildly wrong, but mostly it doesn&#x27;t affect your driving speed.</div><br/></div></div><div id="42500513" class="c"><input type="checkbox" id="c-42500513" checked=""/><div class="controls bullet"><span class="by">chthonicdaemon</span><span>|</span><a href="#42499530">root</a><span>|</span><a href="#42499929">parent</a><span>|</span><a href="#42500132">prev</a><span>|</span><a href="#42500516">next</a><span>|</span><label class="collapse" for="c-42500513">[-]</label><label class="expand" for="c-42500513">[1 more]</label></div><br/><div class="children"><div class="content">I drive a car that doesn&#x27;t have a backup camera and I wouldn&#x27;t pay more for a car with a backup camera. I&#x27;ve never felt like I need it. I guess this is just how these augmentations work. By the time you&#x27;ve invested the time to learn the skill, you don&#x27;t need the augmentation anymore. So you&#x27;re left a bit puzzled by people who do. The people who use augmentations, or rely on them, have a more clear differential view. They compare their augmented ability with their non-augmented ability and it&#x27;s very different.<p>I still have most of the python standard library and many of the interfaces I use often in my brain, so autocomplete saves me almost no time. I can type working code into notepad about as fast as I can type it in VS code.</div><br/></div></div><div id="42500516" class="c"><input type="checkbox" id="c-42500516" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#42499530">root</a><span>|</span><a href="#42499929">parent</a><span>|</span><a href="#42500513">prev</a><span>|</span><a href="#42500450">next</a><span>|</span><label class="collapse" for="c-42500516">[-]</label><label class="expand" for="c-42500516">[1 more]</label></div><br/><div class="children"><div class="content">A bit. But note that &quot;you could too&quot; is not a &quot;you should too&quot;.<p>I can back up without a camera, and I can &quot;drive stick&quot; as Americans call it. But a teenager learning to drive today should maybe not bother.<p>But that&#x27;s not the same question as &quot;why aren&#x27;t you installing a backup camera?&quot;. Because it wouldn&#x27;t change my ability or speed of backing up. And I can drive stick. Why not replace my car with an automatic? Because it wouldn&#x27;t improve anything.<p>In fact I dislike automatics, since they&#x27;ll suddenly and jerkily decide that another gear is best, ever though my foot didn&#x27;t move, and inclination didn&#x27;t change. But in a couple of decades it&#x27;ll all be electric and this problem will go away. The deliberate engine braking is in electric cars just the brake pedal.</div><br/></div></div></div></div></div></div><div id="42500450" class="c"><input type="checkbox" id="c-42500450" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#42499530">prev</a><span>|</span><a href="#42499936">next</a><span>|</span><label class="collapse" for="c-42500450">[-]</label><label class="expand" for="c-42500450">[1 more]</label></div><br/><div class="children"><div class="content">Just about a decade ago I switched from VIM to an IDE with auto complete. For me personally, typing it all out made me far more intimate with the code, but more importantly it forced me to be very intimate with the language.<p>Today, at the other extreme of having an LLM actually write entire methods or sometimes classes for me, I do feel that I have less of a mental model of how my software is designed. Ostensibly I still &quot;wrote&quot; all of it, but it&#x27;s just not in my mental cache.<p>Or, that&#x27;s just age ))</div><br/></div></div><div id="42499936" class="c"><input type="checkbox" id="c-42499936" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42500450">prev</a><span>|</span><a href="#42500545">next</a><span>|</span><label class="collapse" for="c-42499936">[-]</label><label class="expand" for="c-42499936">[1 more]</label></div><br/><div class="children"><div class="content">At some point in time I wrote vue.js in vim without syntax highlight. For a few months. I had to eventually  configure it, once somebody asked me if I&#x27;m color blind (I&#x27;m not).<p>&gt;So to the devs who don&#x27;t use these tools, how do you do it? Do you just remember every type and field in a codebase? What does your flow look like?<p>You don&#x27;t have to remember every field and type, because you don&#x27;t work with all the types at the same time. Ones that you work with more often, you remember.<p>Workflow is something like this: open the file, split to left and right to see two stack frames of the same code path, open another terminal tab, start test watcher. Make changes and see tests fail. If tests don&#x27;t fail -- write more tests. Then write more code. The usual TDD struggle. In case of CSS, just change it in the browser, then copy back to editor and refactor a but, then check again.<p>When in doubt about spelling, press shift 8.<p>&gt;What do you do if you need to look up the definition&#x2F;implementation of some function which is in some other file?<p>:open another file and search through it, quote simple. How do I know which file to open? I know and when I don&#x27;t git grep goes brrr. In theory you can jump to definition even in vim, use fzf to open files faster, in practice, none of that is not the limiting factor.<p>The limiting factor is iteration cost and the size of your context window.<p>That all being said, I use vs code now (at work) and use jump to definition all the time, because typescript support is just better in vs code. I think I started using it the moment I had to open more than one repo and switching between them on a regular basis.<p>Then I get back to my own fun stuff and there I use vim.</div><br/></div></div><div id="42500545" class="c"><input type="checkbox" id="c-42500545" checked=""/><div class="controls bullet"><span class="by">oytis</span><span>|</span><a href="#42499936">prev</a><span>|</span><a href="#42500260">next</a><span>|</span><label class="collapse" for="c-42500545">[-]</label><label class="expand" for="c-42500545">[1 more]</label></div><br/><div class="children"><div class="content">Pretty impossible for anything JVM-based IMO. But I am mostly working with C++, C and Python, and it&#x27;s all doable with grep and a tiling WM</div><br/></div></div><div id="42499632" class="c"><input type="checkbox" id="c-42499632" checked=""/><div class="controls bullet"><span class="by">magnetowasright</span><span>|</span><a href="#42500260">prev</a><span>|</span><a href="#42500324">next</a><span>|</span><label class="collapse" for="c-42499632">[-]</label><label class="expand" for="c-42499632">[2 more]</label></div><br/><div class="children"><div class="content">Autocomplete in code is the single most annoying thing I&#x27;ve ever experienced. While I do have a fantastic memory, I don&#x27;t feel like it makes a huge difference? I don&#x27;t quite understand the workflow using autocomplete, I suppose. If I&#x27;m typing something I know what I&#x27;m trying to achieve (with or without a more concrete implementation plan), the general context of the code I&#x27;m working with, and it is quicker and far more enjoyable for me to just type instead of dealing with a minefield of never ending pop ups from autocomplete. I know the types&#x2F;fields&#x2F;classes&#x2F;language features&#x2F;whatever because I have to in order to do whatever I&#x27;m doing. I reference the relevant code, open in other tabs in my editor. I also reference documentation. I don&#x27;t really find myself wanting for more. I don&#x27;t understand how using auto completion would impact needing to know that stuff anyway? I get that it&#x27;s annoying and maybe less efficient to have to type out all the params and types and other predictable stuff by hand but you have to know it to make sure the option you&#x27;ve chosen from the potential many options suggested is correct anyway, right? It feels like less mental and physical effort to me to just type exactly what I mean instead of having to review options and double check I&#x27;ve chosen the right one, but I can kinda understand why that&#x27;s a minority opinion. I still fuck it up or end up changing my implementation and having to revise it anyway but I definitely prefer to type.<p>Before I figured out how to configure Sublime Text (I used Atom until it was killed) to have JUST go-to-definition and no other LSP features enabled, I&#x27;d just do a quick couple of searches across a code base or file. It was fine tbh. Yes, a single key press is much nicer but it really wasn&#x27;t that annoying to not have it. I got just go-to-definition working and was able to turn literally everything else off and I&#x27;m really happy with it.<p>For context, I&#x27;ve worked in all kinds of code bases with all kinds of quality and organisation (including lack thereof) in a variety of languages and frameworks, and I&#x27;ve not really felt the NEED to change. I do try VSCode and&#x2F;or using more of these typical IDE features maybe once a year in an attempt to leverage these features that seemingly every other programmer feels they gain a lot from but I just HATE it. I can&#x27;t stand it. I really have tried! I do assume I&#x27;m leaving some quality of life and productivity gains on the table but I&#x27;ve never been able to make it work for me.</div><br/><div id="42500291" class="c"><input type="checkbox" id="c-42500291" checked=""/><div class="controls bullet"><span class="by">magnetowasright</span><span>|</span><a href="#42499632">parent</a><span>|</span><a href="#42500324">next</a><span>|</span><label class="collapse" for="c-42500291">[-]</label><label class="expand" for="c-42500291">[1 more]</label></div><br/><div class="children"><div class="content">I forgot to mention that I also have linting issues and other gutter icon things completely turned off as well. I have a code formatter installed ...I think? Those are things that I could probably turn on without wanting to pull my hair out but again I&#x27;ve not felt the need. Typing my imports manually is mildly annoying in a small handful of areas but not enough to make me do something smarter about it lol</div><br/></div></div></div></div><div id="42500324" class="c"><input type="checkbox" id="c-42500324" checked=""/><div class="controls bullet"><span class="by">Fizzadar</span><span>|</span><a href="#42499632">prev</a><span>|</span><a href="#42498714">next</a><span>|</span><label class="collapse" for="c-42500324">[-]</label><label class="expand" for="c-42500324">[1 more]</label></div><br/><div class="children"><div class="content">Long time sublime user, always has autocomplete off as it’s more a distraction than use. Recently started using LSPs for the inline error&#x2F;warning checking but avoid things like go to definition - search works just as well in my experience and is faster.<p>See lots of comments here about code organisation and developing a deeper understanding of a codebase and I could not agree more. At least for myself not having all these functions gives me a deeper understanding of the code. I’m probably slower to onboard onto a codebase but I bet long term have higher productivity on it.</div><br/></div></div><div id="42498714" class="c"><input type="checkbox" id="c-42498714" checked=""/><div class="controls bullet"><span class="by">Jugurtha</span><span>|</span><a href="#42500324">prev</a><span>|</span><label class="collapse" for="c-42498714">[-]</label><label class="expand" for="c-42498714">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use any of these out of ignorance first, laziness second, and incompetence third.<p>I didn&#x27;t know about them, and I had spent a lot of time with the documentation and code of everything I touched (language, dependencies, etc). Looking things up reinforces this. The value of a feature such as autocomplete is marginal to me as a function of the effort I have to make to learn how to use it properly, the frustration of using it improperly, and the added steps to fix a blunder, so I just don&#x27;t bother with it.<p>I also have a habit of having the documentation&#x2F;book&#x2F;code of a dependency open nearby and doing my look-ups there.<p>A lot of time is spent refining existing code, debugging, optimizing, refactoring, etc...</div><br/><div id="42500068" class="c"><input type="checkbox" id="c-42500068" checked=""/><div class="controls bullet"><span class="by">gosub100</span><span>|</span><a href="#42498714">parent</a><span>|</span><label class="collapse" for="c-42500068">[-]</label><label class="expand" for="c-42500068">[1 more]</label></div><br/><div class="children"><div class="content">I remember getting excited about zsh plugins that do this and that. More recently, fancy neovim plugins with demos on YouTube. Only to try them and they don&#x27;t fucking work. Even cloned directly from their repo, there&#x27;s always a missing dependency or font or program they need. Such a frustrating waste of time.</div><br/></div></div></div></div></div></div></div></div></div></body></html>