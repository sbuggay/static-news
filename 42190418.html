<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732093259552" as="style"/><link rel="stylesheet" href="styles.css?v=1732093259552"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://welltypedwitch.bearblog.dev/nominal-for-storing-structural-for-manipulating/">Nominal for Storing, Structural for Manipulating</a> <span class="domain">(<a href="https://welltypedwitch.bearblog.dev">welltypedwitch.bearblog.dev</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>11 comments</span></div><br/><div><div id="42191956" class="c"><input type="checkbox" id="c-42191956" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#42190446">next</a><span>|</span><label class="collapse" for="c-42191956">[-]</label><label class="expand" for="c-42191956">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What this means is that all nominal variants and records are really just nominal wrappers over structural variants or records.<p>If you have both nominal types and structural types in your language, you can already do this, while keeping the ability to be nominal only or structural only when you want.<p>In the following OCaml code variant inference in pattern matching is not automatic (although the compiler will warn you about the missing cases, which helps you figuring what to write), but the types do get refined in the corresponding branch.<p><pre><code>    type &#x27;a tree =
      Tree of
        [ `Empty
        | `Branch of (&#x27;a tree * &#x27;a * &#x27;a tree)
          (* Unfortunately, inline records are not supported here,
             so you have to use tuples, objects, or a mutually recursive record
             type. *)
        ]
      [@@unboxed]

    (* You can give aliases to subsets of constructors *)
    type &#x27;a branch =
      [ `Branch of (&#x27;a tree * &#x27;a * &#x27;a tree) ]
    
    let f (x : &#x27;a branch) = ()
    
    let f x =
      match x with
      | Tree `Empty -&gt; ()
      (* You need to be explicit about the cases you want to handle. This pattern
         could also be written `Tree (#branch as rest)`. *)
      | Tree (`Branch _ as rest) -&gt; f rest
</code></pre>
The one feature I&#x27;d really like in this space would be the ability to refer to a subset of the constructors of a nominal types as if it was a (restricted) polymorphic variant that could only be recombined with another subset of constructors of the same nominal type. It would allow some of the power of polymorphic variants without losing the efficient representation allowed by nominal types knowing the possible variants ahead of time.</div><br/></div></div><div id="42190446" class="c"><input type="checkbox" id="c-42190446" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42191956">prev</a><span>|</span><a href="#42191038">next</a><span>|</span><label class="collapse" for="c-42190446">[-]</label><label class="expand" for="c-42190446">[4 more]</label></div><br/><div class="children"><div class="content">I think is forgotten here that one of the benefits of nominal typing is that the compiler can know that data layout at run time so performance benefits.<p>There has been so much ink spilled on the question of what kind of type systems help programmers be productive but there is not such controversy on the performance side.</div><br/><div id="42191794" class="c"><input type="checkbox" id="c-42191794" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42190446">parent</a><span>|</span><a href="#42190752">next</a><span>|</span><label class="collapse" for="c-42191794">[-]</label><label class="expand" for="c-42191794">[2 more]</label></div><br/><div class="children"><div class="content">Premature optimisation is the root of all evil. If you get the semantics right then good performance will generally follow, if you make the wrong thing then it doesn&#x27;t matter how fast it is.</div><br/><div id="42191922" class="c"><input type="checkbox" id="c-42191922" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42190446">root</a><span>|</span><a href="#42191794">parent</a><span>|</span><a href="#42190752">next</a><span>|</span><label class="collapse" for="c-42191922">[-]</label><label class="expand" for="c-42191922">[1 more]</label></div><br/><div class="children"><div class="content">Performant code in the wild largely disagrees?  This is the difference between a numpy array versus a regular python list.  It is stark.<p>You are correct that you can often engineer the performance later.  But layout concerns and nominal types for performance are fairly non controversial.</div><br/></div></div></div></div><div id="42190752" class="c"><input type="checkbox" id="c-42190752" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#42190446">parent</a><span>|</span><a href="#42191794">prev</a><span>|</span><a href="#42191038">next</a><span>|</span><label class="collapse" for="c-42190752">[-]</label><label class="expand" for="c-42190752">[1 more]</label></div><br/><div class="children"><div class="content">Do you mean at compile time?<p>I’m mostly familiar with Haskell which does type erasure. I think the means that there is no type checking at run time.<p>I think dependently typed languages would the benefit of knowing structure at compile time enough to detect things like dead branches and impossible cases which can optimize by removing code. I’m not sure that all types are erased in such languages though.</div><br/></div></div></div></div><div id="42191038" class="c"><input type="checkbox" id="c-42191038" checked=""/><div class="controls bullet"><span class="by">vrotaru</span><span>|</span><a href="#42190446">prev</a><span>|</span><a href="#42191374">next</a><span>|</span><label class="collapse" for="c-42191038">[-]</label><label class="expand" for="c-42191038">[1 more]</label></div><br/><div class="children"><div class="content">I guess Modula-3 was doing it as well.<p>Records were structurally typed. But you can &quot;braid&quot;(?) a record and that will make it nominal type.</div><br/></div></div><div id="42191374" class="c"><input type="checkbox" id="c-42191374" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#42191038">prev</a><span>|</span><a href="#42190851">next</a><span>|</span><label class="collapse" for="c-42191374">[-]</label><label class="expand" for="c-42191374">[1 more]</label></div><br/><div class="children"><div class="content">ASN.1 is structurally typed too.</div><br/></div></div><div id="42190849" class="c"><input type="checkbox" id="c-42190849" checked=""/><div class="controls bullet"><span class="by">molikto</span><span>|</span><a href="#42190851">prev</a><span>|</span><a href="#42190823">next</a><span>|</span><label class="collapse" for="c-42190849">[-]</label><label class="expand" for="c-42190849">[1 more]</label></div><br/><div class="children"><div class="content">convertTree doesn&#x27;t work because Tree uses Tree type recursively.</div><br/></div></div><div id="42190823" class="c"><input type="checkbox" id="c-42190823" checked=""/><div class="controls bullet"><span class="by">readthenotes1</span><span>|</span><a href="#42190849">prev</a><span>|</span><label class="collapse" for="c-42190823">[-]</label><label class="expand" for="c-42190823">[1 more]</label></div><br/><div class="children"><div class="content">An odd to see Java thrown in there without methods...</div><br/></div></div></div></div></div></div></div></body></html>