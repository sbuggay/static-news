<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701680458663" as="style"/><link rel="stylesheet" href="styles.css?v=1701680458663"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mattwparas/steel">Steel – An embeddable and extensible Scheme dialect</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>MaximilianEmel</span> | <span>149 comments</span></div><br/><div><div id="38509141" class="c"><input type="checkbox" id="c-38509141" checked=""/><div class="controls bullet"><span class="by">_nalply</span><span>|</span><a href="#38509571">next</a><span>|</span><label class="collapse" for="c-38509141">[-]</label><label class="expand" for="c-38509141">[27 more]</label></div><br/><div class="children"><div class="content">Helix Editor plans to use Steel as a plugin language [0].<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;pull&#x2F;8675">https:&#x2F;&#x2F;github.com&#x2F;helix-editor&#x2F;helix&#x2F;pull&#x2F;8675</a></div><br/><div id="38509605" class="c"><input type="checkbox" id="c-38509605" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#38509141">parent</a><span>|</span><a href="#38510496">next</a><span>|</span><label class="collapse" for="c-38509605">[-]</label><label class="expand" for="c-38509605">[7 more]</label></div><br/><div class="children"><div class="content">emacsers looking deep from afar</div><br/><div id="38511908" class="c"><input type="checkbox" id="c-38511908" checked=""/><div class="controls bullet"><span class="by">NeutralForest</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38509605">parent</a><span>|</span><a href="#38510496">next</a><span>|</span><label class="collapse" for="c-38511908">[-]</label><label class="expand" for="c-38511908">[6 more]</label></div><br/><div class="children"><div class="content">I would use Helix in the terminal if it supported Emacs keybindings tbh but I don&#x27;t want to relearn another set of keybindings. Still I&#x27;d be interested in what it becomes.</div><br/><div id="38512129" class="c"><input type="checkbox" id="c-38512129" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511908">parent</a><span>|</span><a href="#38512366">next</a><span>|</span><label class="collapse" for="c-38512129">[-]</label><label class="expand" for="c-38512129">[3 more]</label></div><br/><div class="children"><div class="content">The keybindings is one of the major selling points of helix. It uses kakoune style object-verb action (like vim visual mode) by default with multiple selections. If you&#x27;re comfortable with emacs bindings then you&#x27;re better off with a lightweight emacs alternative.</div><br/><div id="38512877" class="c"><input type="checkbox" id="c-38512877" checked=""/><div class="controls bullet"><span class="by">Hugsun</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512129">parent</a><span>|</span><a href="#38512175">next</a><span>|</span><label class="collapse" for="c-38512877">[-]</label><label class="expand" for="c-38512877">[1 more]</label></div><br/><div class="children"><div class="content">As an evil user, this is potentially huge to me.
Emacs happens to have the best balance of easy to setup configuration (relatively), powerful package ecosystem, and proper hackability of all editors I&#x27;ve found. 
It&#x27;s not very fast though and has some conventions that feel archaic.</div><br/></div></div><div id="38512175" class="c"><input type="checkbox" id="c-38512175" checked=""/><div class="controls bullet"><span class="by">NeutralForest</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512129">parent</a><span>|</span><a href="#38512877">prev</a><span>|</span><a href="#38512366">next</a><span>|</span><label class="collapse" for="c-38512175">[-]</label><label class="expand" for="c-38512175">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough</div><br/></div></div></div></div><div id="38512366" class="c"><input type="checkbox" id="c-38512366" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511908">parent</a><span>|</span><a href="#38512129">prev</a><span>|</span><a href="#38510496">next</a><span>|</span><label class="collapse" for="c-38512366">[-]</label><label class="expand" for="c-38512366">[2 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, if you’re familiar with Emacs, what’s your motivation for wanting to use Helix? Built-in LSP support?</div><br/><div id="38512487" class="c"><input type="checkbox" id="c-38512487" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512366">parent</a><span>|</span><a href="#38510496">next</a><span>|</span><label class="collapse" for="c-38512487">[-]</label><label class="expand" for="c-38512487">[1 more]</label></div><br/><div class="children"><div class="content">I use it despite a very complete emaxs setup because:<p>- curiosity<p>- seeing if I&#x27;m missing anything<p>- haven&#x27;t had time to get tree sitter stuff configured, and wanted to see how good it is<p>- see if I want to move back to meow from vanilla (tons of previous vim, evil experience)</div><br/></div></div></div></div></div></div></div></div><div id="38510496" class="c"><input type="checkbox" id="c-38510496" checked=""/><div class="controls bullet"><span class="by">nikolay</span><span>|</span><a href="#38509141">parent</a><span>|</span><a href="#38509605">prev</a><span>|</span><a href="#38509571">next</a><span>|</span><label class="collapse" for="c-38510496">[-]</label><label class="expand" for="c-38510496">[19 more]</label></div><br/><div class="children"><div class="content">That&#x27;s ridiculous!</div><br/><div id="38511040" class="c"><input type="checkbox" id="c-38511040" checked=""/><div class="controls bullet"><span class="by">bobbyskelton41</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38510496">parent</a><span>|</span><a href="#38511754">next</a><span>|</span><label class="collapse" for="c-38511040">[-]</label><label class="expand" for="c-38511040">[2 more]</label></div><br/><div class="children"><div class="content">I saw your comment on the thread.<p>A. Most WebAssembly implementations are bigger than Helix itself.<p>B. WebAssembly is immature.<p>C. Lisp is perfectly fine. Even if you don&#x27;t like it, it&#x27;s not the end of the world if you have to use it to configure Helix.</div><br/><div id="38512614" class="c"><input type="checkbox" id="c-38512614" checked=""/><div class="controls bullet"><span class="by">nikolay</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511040">parent</a><span>|</span><a href="#38511754">next</a><span>|</span><label class="collapse" for="c-38512614">[-]</label><label class="expand" for="c-38512614">[1 more]</label></div><br/><div class="children"><div class="content">A. It&#x27;s true that Wasmer is bigger, but even my phone has 16GB of RAM and 1TB of storage space.<p>B. There are probably more computers running WebAssembly loads today than Lisp ones.<p>C. Lisp is a mature language, almost too mature. I used it extensively in the &#x27;80s and it served me well then, but that was 40 years ago. At least have the decency to use a more modern language like Lua, which is what Neovim uses.</div><br/></div></div></div></div><div id="38511754" class="c"><input type="checkbox" id="c-38511754" checked=""/><div class="controls bullet"><span class="by">CooCooCaCha</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38510496">parent</a><span>|</span><a href="#38511040">prev</a><span>|</span><a href="#38510634">next</a><span>|</span><label class="collapse" for="c-38511754">[-]</label><label class="expand" for="c-38511754">[14 more]</label></div><br/><div class="children"><div class="content">Why? The properties of lisp make it suitable for both a config file, and an extension language. It can be easily embedded into existing languages and is extremely flexible.</div><br/><div id="38511813" class="c"><input type="checkbox" id="c-38511813" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511754">parent</a><span>|</span><a href="#38510634">next</a><span>|</span><label class="collapse" for="c-38511813">[-]</label><label class="expand" for="c-38511813">[13 more]</label></div><br/><div class="children"><div class="content">Turing-completeness in a config file is an anti-pattern.  Write an external program to generate the config file instead.</div><br/><div id="38511989" class="c"><input type="checkbox" id="c-38511989" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511813">parent</a><span>|</span><a href="#38511933">next</a><span>|</span><label class="collapse" for="c-38511989">[-]</label><label class="expand" for="c-38511989">[1 more]</label></div><br/><div class="children"><div class="content">Putting arbitrary bounds on how people use their computers is an anti-pattern.</div><br/></div></div><div id="38511933" class="c"><input type="checkbox" id="c-38511933" checked=""/><div class="controls bullet"><span class="by">NeutralForest</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511813">parent</a><span>|</span><a href="#38511989">prev</a><span>|</span><a href="#38512177">next</a><span>|</span><label class="collapse" for="c-38511933">[-]</label><label class="expand" for="c-38511933">[9 more]</label></div><br/><div class="children"><div class="content">Why? Emacs has Emacs Lisp and Neovim has Lua, it&#x27;s great to be able to configure, write plugins and helper functions, in the same language.</div><br/><div id="38512640" class="c"><input type="checkbox" id="c-38512640" checked=""/><div class="controls bullet"><span class="by">nikolay</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511933">parent</a><span>|</span><a href="#38512118">next</a><span>|</span><label class="collapse" for="c-38512640">[-]</label><label class="expand" for="c-38512640">[5 more]</label></div><br/><div class="children"><div class="content">So, if I use an editor config off the Internet, I need to inspect it for malware, because it&#x27;s code, not configuration? Yes, there are languages for configuration - Jsonnet, Starlark, Dhall, which are execution safe - unlike Lisp and Lua!</div><br/><div id="38512783" class="c"><input type="checkbox" id="c-38512783" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512640">parent</a><span>|</span><a href="#38514400">next</a><span>|</span><label class="collapse" for="c-38512783">[-]</label><label class="expand" for="c-38512783">[3 more]</label></div><br/><div class="children"><div class="content">Do you inspect all the code you run on your computer? You probably got all of it off the internet, except for the firmware blobs you couldn&#x27;t even inspect if you wanted to.<p>And hell, even an &quot;execution safe&quot; configuration can contain malware if there&#x27;s a parser bug.<p>At some point you have to choose who to trust and not to trust to write code that runs on your system, and all you can really do is try to verify that they did in fact write it, and run untrusted code in isolation from sensitive data.</div><br/><div id="38514447" class="c"><input type="checkbox" id="c-38514447" checked=""/><div class="controls bullet"><span class="by">nikolay</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512783">parent</a><span>|</span><a href="#38514400">next</a><span>|</span><label class="collapse" for="c-38514447">[-]</label><label class="expand" for="c-38514447">[2 more]</label></div><br/><div class="children"><div class="content">I install software from credible sources. I do reuse configs from dotfiles off the Internet - just like most people do.<p>There are way more configs out there than there are software projects.</div><br/><div id="38514709" class="c"><input type="checkbox" id="c-38514709" checked=""/><div class="controls bullet"><span class="by">pixel8account</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38514447">parent</a><span>|</span><a href="#38514400">next</a><span>|</span><label class="collapse" for="c-38514709">[-]</label><label class="expand" for="c-38514709">[1 more]</label></div><br/><div class="children"><div class="content">You already face the same threat then. Many, if not most, nontrivial programs have at least one way to escalate to arbitrary code execution from config. For example sway has exec, basically any useful editor has &quot;on save actions&quot;, etc. No need for a Turing complete language when you can just shell out.</div><br/></div></div></div></div></div></div><div id="38514400" class="c"><input type="checkbox" id="c-38514400" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512640">parent</a><span>|</span><a href="#38512783">prev</a><span>|</span><a href="#38512118">next</a><span>|</span><label class="collapse" for="c-38514400">[-]</label><label class="expand" for="c-38514400">[1 more]</label></div><br/><div class="children"><div class="content">Why would you use an entire config off the internet?</div><br/></div></div></div></div><div id="38512118" class="c"><input type="checkbox" id="c-38512118" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511933">parent</a><span>|</span><a href="#38512640">prev</a><span>|</span><a href="#38512177">next</a><span>|</span><label class="collapse" for="c-38512118">[-]</label><label class="expand" for="c-38512118">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re target audience are not progmmers versed in your wacky config language, it&#x27;s a tremendous foot gun. Also a huge security hole.</div><br/><div id="38512347" class="c"><input type="checkbox" id="c-38512347" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512118">parent</a><span>|</span><a href="#38512354">next</a><span>|</span><label class="collapse" for="c-38512347">[-]</label><label class="expand" for="c-38512347">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to write declarative configuration in scheme. You can see that in Guix. Eventually someone will write a macro to create something purely declarative, like use-package in emacs.<p>&gt; it&#x27;s a tremendous foot gun<p>I&#x27;ve never seen this footgun in action with elisp in Emacs, lua in neovim or vimscript in vim. Is this anything more than hypothetical?<p>&gt; Also a huge security hole.<p>If you put an editor in a position where its Turing-complete configuration is a security hole, you&#x27;ll be in a lot more trouble than you imagine. Editors by definition are meant to modify stuff in a filesystem. With those privileges, it wont matter what the config language is. The plugins, even in webassembly, will cause serious issues.</div><br/></div></div><div id="38512354" class="c"><input type="checkbox" id="c-38512354" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38512118">parent</a><span>|</span><a href="#38512347">prev</a><span>|</span><a href="#38512177">next</a><span>|</span><label class="collapse" for="c-38512354">[-]</label><label class="expand" for="c-38512354">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a text editor specifically made for writing code.</div><br/></div></div></div></div></div></div><div id="38512715" class="c"><input type="checkbox" id="c-38512715" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38511813">parent</a><span>|</span><a href="#38512177">prev</a><span>|</span><a href="#38510634">next</a><span>|</span><label class="collapse" for="c-38512715">[-]</label><label class="expand" for="c-38512715">[1 more]</label></div><br/><div class="children"><div class="content">But then how do you write custom key handlers?</div><br/></div></div></div></div></div></div><div id="38510634" class="c"><input type="checkbox" id="c-38510634" checked=""/><div class="controls bullet"><span class="by">icommentedtoday</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38510496">parent</a><span>|</span><a href="#38511754">prev</a><span>|</span><a href="#38511223">next</a><span>|</span><label class="collapse" for="c-38510634">[-]</label><label class="expand" for="c-38510634">[1 more]</label></div><br/><div class="children"><div class="content">?</div><br/></div></div><div id="38511223" class="c"><input type="checkbox" id="c-38511223" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38509141">root</a><span>|</span><a href="#38510496">parent</a><span>|</span><a href="#38510634">prev</a><span>|</span><a href="#38509571">next</a><span>|</span><label class="collapse" for="c-38511223">[-]</label><label class="expand" for="c-38511223">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s perfectly viable as a MVP.  WebAssembly plugins for Helix had been proposed many times but without an actual implementation being worked on.</div><br/></div></div></div></div></div></div><div id="38509571" class="c"><input type="checkbox" id="c-38509571" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509141">prev</a><span>|</span><a href="#38511519">next</a><span>|</span><label class="collapse" for="c-38509571">[-]</label><label class="expand" for="c-38509571">[9 more]</label></div><br/><div class="children"><div class="content">This is a surprise! Steel is my project, happy to answer any questions anyone might have</div><br/><div id="38509823" class="c"><input type="checkbox" id="c-38509823" checked=""/><div class="controls bullet"><span class="by">dataangel</span><span>|</span><a href="#38509571">parent</a><span>|</span><a href="#38512583">next</a><span>|</span><label class="collapse" for="c-38509823">[-]</label><label class="expand" for="c-38509823">[5 more]</label></div><br/><div class="children"><div class="content">Any chance of seeing the things I miss the most from Racket in other langs?<p>1. Parameters and Syntax Parameters (Syntax parameters make macros more powerful)<p>2. Turing complete macros (not just syntax-case)<p>3. Typed Racket<p>I almost used <a href="https:&#x2F;&#x2F;gamelisp.rs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gamelisp.rs&#x2F;</a> for a project but the nightly feature it needs broke and it&#x27;s no longer maintained, glad to see something similar arise! You might want to consider adopting their choice of VecDeque as a list replacement, I think it makes a lot more sense than naive linked lists on modern machines.</div><br/><div id="38509921" class="c"><input type="checkbox" id="c-38509921" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509571">root</a><span>|</span><a href="#38509823">parent</a><span>|</span><a href="#38512583">next</a><span>|</span><label class="collapse" for="c-38509921">[-]</label><label class="expand" for="c-38509921">[4 more]</label></div><br/><div class="children"><div class="content">To answer each of these:<p>1. I do support parameters now, syntax parameters not yet. I would like to! But Racket has a pretty hefty head start on me so it&#x27;ll take some time.<p>2. Right now I have syntax-rules macros, I also have defmacro style macros that get used internally in the kernel during expansion, but haven&#x27;t  yet opened them up for user space yet. Syntax case will be coming soon hopefully.<p>3. The odds of me being able to come up with an implementation to match typed racket pound for pound is pretty low. I have toyed with using contracts as types (where possible), with medium&#x2F;promising success in certain situations. I have a soft spot for racket and have been modeling behavior after it, however it will take time to be able to create a macro system powerful enough to match it. It wouldn&#x27;t be impossible to create an alternative syntax to just lower to steel after type checking, but I haven&#x27;t put time into that.<p>On the list type - the list in use currently is an unrolled linked list <a href="https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;im-lists">https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;im-lists</a>, which I&#x27;ve found to yield much better performance for iteration than the naive linked lists. When possible, the vm does some in place mutation on the lists as well when consing, which helps performance as well. I also can hot swap for a vlist, but at the moment have stuck with unrolled linked lists.</div><br/><div id="38510353" class="c"><input type="checkbox" id="c-38510353" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#38509571">root</a><span>|</span><a href="#38509921">parent</a><span>|</span><a href="#38512583">next</a><span>|</span><label class="collapse" for="c-38510353">[-]</label><label class="expand" for="c-38510353">[3 more]</label></div><br/><div class="children"><div class="content">Is that based on the VList paper?</div><br/><div id="38510460" class="c"><input type="checkbox" id="c-38510460" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509571">root</a><span>|</span><a href="#38510353">parent</a><span>|</span><a href="#38512583">next</a><span>|</span><label class="collapse" for="c-38510460">[-]</label><label class="expand" for="c-38510460">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I don&#x27;t have a link handy but I based it off the Phil Bagwell paper</div><br/><div id="38511572" class="c"><input type="checkbox" id="c-38511572" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#38509571">root</a><span>|</span><a href="#38510460">parent</a><span>|</span><a href="#38512583">next</a><span>|</span><label class="collapse" for="c-38511572">[-]</label><label class="expand" for="c-38511572">[1 more]</label></div><br/><div class="children"><div class="content">I do: <a href="https:&#x2F;&#x2F;trout.me.uk&#x2F;lisp&#x2F;vlist.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;trout.me.uk&#x2F;lisp&#x2F;vlist.pdf</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="38512583" class="c"><input type="checkbox" id="c-38512583" checked=""/><div class="controls bullet"><span class="by">duttakapil</span><span>|</span><a href="#38509571">parent</a><span>|</span><a href="#38509823">prev</a><span>|</span><a href="#38511519">next</a><span>|</span><label class="collapse" for="c-38512583">[-]</label><label class="expand" for="c-38512583">[3 more]</label></div><br/><div class="children"><div class="content">May I ask, what is your personal journey of learning to code? Did you also discover Lisp&#x2F;Scheme through SICP? And what have you professionally used Scheme for?<p>I am currently going through SICP, and I am also interested in Rust, so this project is a great discovery! Maybe I can contribute to it also.</div><br/><div id="38512743" class="c"><input type="checkbox" id="c-38512743" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509571">root</a><span>|</span><a href="#38512583">parent</a><span>|</span><a href="#38511519">next</a><span>|</span><label class="collapse" for="c-38512743">[-]</label><label class="expand" for="c-38512743">[2 more]</label></div><br/><div class="children"><div class="content">I learned to code primarily through school - I had the privilege of studying at Northwestern where a lot of the Racket people teach, so my first programming class was in Racket. I have worked through some of SICP and How to Design Programs. After Racket I learned some C, C++, and C#. Then taught myself python just independently doing some projects, ended up back taking a few classes in Racket, then one in Agda that got me down the programming language rabbit hole. Took a class in Rust and that got me working on Steel.<p>I haven&#x27;t _directly_ used scheme professionally except for some steel scripts for automating some work flows and some racket programs for spark query plan analysis. I&#x27;d like to work in scheme more in my professional work, but for now I&#x27;m quite happy just working on it for fun.<p>Contributions are welcome! Feel free to either join the discord and ask questions there if you want a more chat based place, or open a discussion on github if you&#x27;d like to learn more. I have it on my TODO list to set up a matrix chat, just haven&#x27;t gotten around to it - so apologies for having discord as the only chatroom.</div><br/><div id="38513523" class="c"><input type="checkbox" id="c-38513523" checked=""/><div class="controls bullet"><span class="by">duttakapil</span><span>|</span><a href="#38509571">root</a><span>|</span><a href="#38512743">parent</a><span>|</span><a href="#38511519">next</a><span>|</span><label class="collapse" for="c-38513523">[-]</label><label class="expand" for="c-38513523">[1 more]</label></div><br/><div class="children"><div class="content">Would love to get involved!</div><br/></div></div></div></div></div></div></div></div><div id="38511519" class="c"><input type="checkbox" id="c-38511519" checked=""/><div class="controls bullet"><span class="by">SushiHippie</span><span>|</span><a href="#38509571">prev</a><span>|</span><a href="#38509876">next</a><span>|</span><label class="collapse" for="c-38511519">[-]</label><label class="expand" for="c-38511519">[19 more]</label></div><br/><div class="children"><div class="content">Can someone explain these scheme and lisp languages to me?
Every time I look at these languages, I can&#x27;t grasp what you can use them for.
And why one would use them.<p>I always feel like I&#x27;m missing something.
In the example scripts and code snippets, I can see that you can define functions, that you can use lists, mathematical operations, you can build some algorithms, you can print text, but it never goes further than that.<p>I&#x27;ve only used languages like Python, Rust, C, Java, JavaScript, and they all have a very similar vibe, you have a std lib, which can interact with many things, you can build UIs, networking libraries and all that. And I could probably start using any language that is &quot;similar&quot; to these.<p>But I could never use one of these scheme&#x2F;lisp languages, as I can&#x27;t really grasp them.<p>Sorry, this comment is all over the place, because I can&#x27;t really explain what&#x27;s going on in my head when I see languages like this.
I&#x27;d call myself a proficient programmer, but every time I look at these languages, it feels like as I&#x27;ve never seen code once in my lifetime.<p>Any help or hint at what I&#x27;m missing, is appreciated.</div><br/><div id="38512075" class="c"><input type="checkbox" id="c-38512075" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38513998">next</a><span>|</span><label class="collapse" for="c-38512075">[-]</label><label class="expand" for="c-38512075">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>it feels like as I&#x27;ve never seen code once in my lifetime.</i><p>I think you must be fixating on syntax, or have been seeing some code that is advanced or (it exists) a very confusing example by some academic to demonstrate some curiosity.<p>Except for idiomatic recursion (which you don&#x27;t have to use), Scheme semantics should initially look familiar to a Python or JavaScript programmer, like a subset of that, just with a different syntax.  (Scheme nuances are much better designed, but to a new programmer semantics will look like a subset.)<p>And the Scheme syntax is one of the simplest ever, once you understand it.<p>What should instead be confusing is a language with very different semantics, like lazy evaluation, or an OOPL with complicating dispatch rules to reason about.</div><br/></div></div><div id="38513998" class="c"><input type="checkbox" id="c-38513998" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38512075">prev</a><span>|</span><a href="#38514236">next</a><span>|</span><label class="collapse" for="c-38513998">[-]</label><label class="expand" for="c-38513998">[1 more]</label></div><br/><div class="children"><div class="content">Would strongly recommend watching the SICP video lectures: <a href="https:&#x2F;&#x2F;ocw.mit.edu&#x2F;courses&#x2F;6-001-structure-and-interpretation-of-computer-programs-spring-2005&#x2F;video_galleries&#x2F;video-lectures&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ocw.mit.edu&#x2F;courses&#x2F;6-001-structure-and-interpretati...</a></div><br/></div></div><div id="38514236" class="c"><input type="checkbox" id="c-38514236" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38513998">prev</a><span>|</span><a href="#38512533">next</a><span>|</span><label class="collapse" for="c-38514236">[-]</label><label class="expand" for="c-38514236">[1 more]</label></div><br/><div class="children"><div class="content">Most of them use most of the same core idioms you&#x27;re familiar with from other languages, they just look superficially different because of the syntax (especially the parenthesis placement)<p>Try moving the left parenthesis of each expression over to the right by one and it may become clearer<p>(my-fn 1 2)<p>my-fn (1 2)</div><br/></div></div><div id="38512533" class="c"><input type="checkbox" id="c-38512533" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38514236">prev</a><span>|</span><a href="#38511880">next</a><span>|</span><label class="collapse" for="c-38512533">[-]</label><label class="expand" for="c-38512533">[1 more]</label></div><br/><div class="children"><div class="content">At least for me, there is a certain appeal in building the world. With scheme you get a very small set of functionality, but you use that to implement the rest of the language, and build abstractions on top of abstractions. Seeing how the whole system can be built from a small set of functionality is pretty cool, and also very satisfying. There is a talk from Andy Wingo, one of the maintainers of Guile, where he describes working on Guile as akin to tending to a garden, and I think its an apt comparison. Something about it feels very organic and personal, which is part of the appeal.<p>The syntax itself doesn&#x27;t _really_ matter, it just makes it easy to do so - functions and syntax visually look the same, so it makes it easy to build.<p>Its not for everyone, but I think its worth exploring for a little bit. Similarly I think its worth really learning any language just a bit, if not to just expand your tool kit. The parenthesis do disappear at a certain point and you learn to read it, but if its not your thing that is fine.</div><br/></div></div><div id="38511880" class="c"><input type="checkbox" id="c-38511880" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38512533">prev</a><span>|</span><a href="#38511592">next</a><span>|</span><label class="collapse" for="c-38511880">[-]</label><label class="expand" for="c-38511880">[2 more]</label></div><br/><div class="children"><div class="content">Maybe look at:
<a href="https:&#x2F;&#x2F;github.com&#x2F;arclanguage&#x2F;anarki&#x2F;blob&#x2F;master&#x2F;apps&#x2F;news&#x2F;news.arc">https:&#x2F;&#x2F;github.com&#x2F;arclanguage&#x2F;anarki&#x2F;blob&#x2F;master&#x2F;apps&#x2F;news&#x2F;...</a></div><br/><div id="38512320" class="c"><input type="checkbox" id="c-38512320" checked=""/><div class="controls bullet"><span class="by">SushiHippie</span><span>|</span><a href="#38511519">root</a><span>|</span><a href="#38511880">parent</a><span>|</span><a href="#38511592">next</a><span>|</span><label class="collapse" for="c-38512320">[-]</label><label class="expand" for="c-38512320">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, good hint!</div><br/></div></div></div></div><div id="38512135" class="c"><input type="checkbox" id="c-38512135" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38511592">prev</a><span>|</span><a href="#38511747">next</a><span>|</span><label class="collapse" for="c-38512135">[-]</label><label class="expand" for="c-38512135">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not missing anything. You have two choices: a) either take it as true that there&#x27;s nothing to see here and move on, b) or if you have some spare time learn lisp and then move on. (b) avoids that nagging feeling that you&#x27;re somehow unworthy.</div><br/></div></div><div id="38511747" class="c"><input type="checkbox" id="c-38511747" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38512135">prev</a><span>|</span><a href="#38511987">next</a><span>|</span><label class="collapse" for="c-38511747">[-]</label><label class="expand" for="c-38511747">[1 more]</label></div><br/><div class="children"><div class="content">My first introduction to Lisp-like programming languages were the SICP videos with Abelson and Sussman so to me Lisps are just programming languages like any other but with a nicer syntax and great support for interactive programming.</div><br/></div></div><div id="38511987" class="c"><input type="checkbox" id="c-38511987" checked=""/><div class="controls bullet"><span class="by">dkarras</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38511747">prev</a><span>|</span><a href="#38511846">next</a><span>|</span><label class="collapse" for="c-38511987">[-]</label><label class="expand" for="c-38511987">[4 more]</label></div><br/><div class="children"><div class="content">used to be on the same camp. now I think I get it.<p>the language is malleable. because it is homoiconic. so while developing software, you are simultaneously writing a domain specific language for your problem. because macros.<p>in the end, if you like your craft, you end up with a &quot;language&quot; that is very suitable for solving the problem you have at hand, with very little noise.<p>the downside is, probably most others will not understand your code so lisps have heavy bias towards &quot;solo hackers&quot;. BUT... if that is important to you, you can code towards understandability. so much so that you can make it very hard for others to make mistakes when using the public api.<p>so with most programming languages, you program within the constraints of the syntactic rules of the language. with lisps, you define the language you want to approach the problem, that language comes out by itself iteratively. for some, that is a joy. others don&#x27;t care for it.</div><br/><div id="38512150" class="c"><input type="checkbox" id="c-38512150" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38511519">root</a><span>|</span><a href="#38511987">parent</a><span>|</span><a href="#38511846">next</a><span>|</span><label class="collapse" for="c-38512150">[-]</label><label class="expand" for="c-38512150">[3 more]</label></div><br/><div class="children"><div class="content">Homoiconicity is a gimmick and it&#x27;s a cult.</div><br/><div id="38513995" class="c"><input type="checkbox" id="c-38513995" checked=""/><div class="controls bullet"><span class="by">Hammershaft</span><span>|</span><a href="#38511519">root</a><span>|</span><a href="#38512150">parent</a><span>|</span><a href="#38512469">next</a><span>|</span><label class="collapse" for="c-38513995">[-]</label><label class="expand" for="c-38513995">[1 more]</label></div><br/><div class="children"><div class="content">Why do you think homoiconicity is a gimmick? Have you seen languages that offer metaprogramming capabilities as simple &amp; powerful as Lisp without homoiconicity?</div><br/></div></div><div id="38512469" class="c"><input type="checkbox" id="c-38512469" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#38511519">root</a><span>|</span><a href="#38512150">parent</a><span>|</span><a href="#38513995">prev</a><span>|</span><a href="#38511846">next</a><span>|</span><label class="collapse" for="c-38512469">[-]</label><label class="expand" for="c-38512469">[1 more]</label></div><br/><div class="children"><div class="content">Homoiconicity is why Lisps have rich macros and legendary metaprogramming capabilities. You don&#x27;t even have to deal with it yourself to feel its usefulness. Emacs use-package is an example.</div><br/></div></div></div></div></div></div><div id="38511846" class="c"><input type="checkbox" id="c-38511846" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38511987">prev</a><span>|</span><a href="#38511615">next</a><span>|</span><label class="collapse" for="c-38511846">[-]</label><label class="expand" for="c-38511846">[4 more]</label></div><br/><div class="children"><div class="content">Why not just program everything in assembly? High level languages give you powers of expression that lead to better programs or are simply more convenient for the particular task at hand. Lisp languages have several features that aren&#x27;t found in most other programming languages. And a lot features that are found in other languages originated in Lisp.<p>Perhaps what you are missing is the practical part. For that you should look to the two types of Lisp in widespread usage: Common Lisp and Emacs Lisp. Common Lisp is a general-purpose language with a very large standard library and rich set of third-party libraries. Emacs Lisp is a complete language, but only really used to build text editing like stuff for Emacs. There&#x27;s tons of real, effective code out there in these languages.<p>Or perhaps you are confused about the functional programming part. This is only strongly associated with Scheme as other Lisps support other paradigms like object-oriented programming. Functional programming is a thing that takes a while to understand, although my theory is it&#x27;s actually <i>more</i> natural and it&#x27;s only because you already learnt imperative programming, which is thoroughly unnatural, that you find it odd. Once grasped it will help you with other languages that support functional programming like JavaScript and Python.<p>They say learning Lisp will make you a better programmer even if you never use it again. I tend to agree with this.</div><br/><div id="38512306" class="c"><input type="checkbox" id="c-38512306" checked=""/><div class="controls bullet"><span class="by">SushiHippie</span><span>|</span><a href="#38511519">root</a><span>|</span><a href="#38511846">parent</a><span>|</span><a href="#38511615">next</a><span>|</span><label class="collapse" for="c-38512306">[-]</label><label class="expand" for="c-38512306">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Perhaps what you are missing is the practical part.<p>I think that&#x27;s it.
Thanks, I&#x27;ll take a look at common lisp, especially at projects written in it.</div><br/><div id="38512749" class="c"><input type="checkbox" id="c-38512749" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#38511519">root</a><span>|</span><a href="#38512306">parent</a><span>|</span><a href="#38511615">next</a><span>|</span><label class="collapse" for="c-38512749">[-]</label><label class="expand" for="c-38512749">[2 more]</label></div><br/><div class="children"><div class="content">Not exactly what you asked for but, if you have time, I would recommend looking at Practical Common Lisp:<p><a href="https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;</a><p>And also this blog post (which is a much smaller time commitment):<p><a href="https:&#x2F;&#x2F;mikelevins.github.io&#x2F;posts&#x2F;2020-12-18-repl-driven&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mikelevins.github.io&#x2F;posts&#x2F;2020-12-18-repl-driven&#x2F;</a></div><br/><div id="38513257" class="c"><input type="checkbox" id="c-38513257" checked=""/><div class="controls bullet"><span class="by">SushiHippie</span><span>|</span><a href="#38511519">root</a><span>|</span><a href="#38512749">parent</a><span>|</span><a href="#38511615">next</a><span>|</span><label class="collapse" for="c-38513257">[-]</label><label class="expand" for="c-38513257">[1 more]</label></div><br/><div class="children"><div class="content">Thanks this looks promising!</div><br/></div></div></div></div></div></div></div></div><div id="38511615" class="c"><input type="checkbox" id="c-38511615" checked=""/><div class="controls bullet"><span class="by">femiagbabiaka</span><span>|</span><a href="#38511519">parent</a><span>|</span><a href="#38511846">prev</a><span>|</span><a href="#38509876">next</a><span>|</span><label class="collapse" for="c-38511615">[-]</label><label class="expand" for="c-38511615">[1 more]</label></div><br/><div class="children"><div class="content">Basically the differences are in the concepts you&#x27;ll use to write code. Lisps themselves are very different from each other, but just like the languages you&#x27;re used to, many lisp distributions have standard libraries that can be called, and those building blocks can be used to build applications or whatever else. In this case specifically, Steel provides the facility to call Rust functions within a Steel program: <a href="https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel">https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel</a>.<p>So, although I haven&#x27;t used Steel, it looks like the advantage you&#x27;d get from using it is the opportunity to take advantage of features it provides like transducers and contracts, which are feature common to some other Lisps as well.<p>So, just like choosing any other language, it boils down to a series of tradeoffs.</div><br/></div></div></div></div><div id="38509876" class="c"><input type="checkbox" id="c-38509876" checked=""/><div class="controls bullet"><span class="by">ghc</span><span>|</span><a href="#38511519">prev</a><span>|</span><a href="#38509968">next</a><span>|</span><label class="collapse" for="c-38509876">[-]</label><label class="expand" for="c-38509876">[9 more]</label></div><br/><div class="children"><div class="content">Should have named it Steele since it&#x27;s dragging Rust users half-way to Lisp :).</div><br/><div id="38510060" class="c"><input type="checkbox" id="c-38510060" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38509876">parent</a><span>|</span><a href="#38510007">next</a><span>|</span><label class="collapse" for="c-38510060">[-]</label><label class="expand" for="c-38510060">[1 more]</label></div><br/><div class="children"><div class="content">Yes! I just posted<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38510054">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38510054</a></div><br/></div></div><div id="38510007" class="c"><input type="checkbox" id="c-38510007" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#38509876">parent</a><span>|</span><a href="#38510060">prev</a><span>|</span><a href="#38509968">next</a><span>|</span><label class="collapse" for="c-38510007">[-]</label><label class="expand" for="c-38510007">[7 more]</label></div><br/><div class="children"><div class="content">Why would you want to do that? Lisp is dynamically typed and has a GC.</div><br/><div id="38514012" class="c"><input type="checkbox" id="c-38514012" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38509876">root</a><span>|</span><a href="#38510007">parent</a><span>|</span><a href="#38511369">next</a><span>|</span><label class="collapse" for="c-38514012">[-]</label><label class="expand" for="c-38514012">[1 more]</label></div><br/><div class="children"><div class="content">Cases when you might prefer a garbage collected programming language rather than Rust:<p>- When garbage collection is the optimal or near optimal memory allocation pattern for your program.<p>- When you care less about minimizing memory usage than minimizing implementation complexity, development speed, and compile time speed.<p>- When your program deals with cyclic data structures.<p>- When you want green threads (like Goroutines)<p>I can say that I would rather use Lisp to write any program that manipulates tree or graph structures simply because it has a garbage collector.</div><br/></div></div><div id="38511369" class="c"><input type="checkbox" id="c-38511369" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38509876">root</a><span>|</span><a href="#38510007">parent</a><span>|</span><a href="#38514012">prev</a><span>|</span><a href="#38509968">next</a><span>|</span><label class="collapse" for="c-38511369">[-]</label><label class="expand" for="c-38511369">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a joke that you seem to have missed.<p>&gt; We were not out to win over the Lisp programmers; we were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp.<p>Guy Steele on Java</div><br/><div id="38512397" class="c"><input type="checkbox" id="c-38512397" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#38509876">root</a><span>|</span><a href="#38511369">parent</a><span>|</span><a href="#38509968">next</a><span>|</span><label class="collapse" for="c-38512397">[-]</label><label class="expand" for="c-38512397">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m familiar with the Steele quote. The manner in which C++ programmers were &quot;dragged halfway to Lisp&quot; concerns primarily manual memory management and all the bugginess attending thereto (Java came out before the STL and smart pointers were widely adopted). Concerns about memory safety were a significant part of the impetus for developing Java in the first place. Steele was responding to complaints that he had turned his back on Lisp, by countering that he was instead bringing the C++ crowd closer to Lisp with a C++-like language that had Lisp-like memory management.<p>But the reason why Rust is such revolutionary computer science and, quite possibly, the most interesting thing to happen to PL design in <i>decades</i> is because with safe Rust you get all the memory-safety advantages of Java or Lisp, without a GC because the borrow checker statically guarantees object lifetimes. So Rust programmers don&#x27;t need to be dragged halfway to Lisp the way C++ programmers were in the mid-90s, because Rust has the same memory-safety guarantees with none of the drawbacks of GC.</div><br/><div id="38514059" class="c"><input type="checkbox" id="c-38514059" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#38509876">root</a><span>|</span><a href="#38512397">parent</a><span>|</span><a href="#38512479">next</a><span>|</span><label class="collapse" for="c-38514059">[-]</label><label class="expand" for="c-38514059">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Java came out before the STL and smart pointers were widely adopted.
</code></pre>
This is a strange comment.<p>Java 1.0 was released in Jan 1996.  (Java wasn&#x27;t very useful before 1.1)  However, Stepanov proposed STL to ANSI&#x2F;ISO committee in Nov 1993, and HP released a working version to the Internet in Aug 1994.<p>&quot;[W]idely adopted&quot; is an editorial term.  It is meaningless without some backing evidence.  (&quot;Never been worse&quot; has a similar sentiment.)  How do determine what counts?<p>I worked on enterprise C++ for years in the mid-2000s that didn&#x27;t use any smart pointers.  There are many huge, old enterprise C++ projects that don&#x27;t use STL or smart pointers.  And, there are still many huge old Java enterprise projects that use shitty cast-from-Object-type to pass around typed data, instead of generics, or something better.  Not much being said here!<p><pre><code>    the most interesting thing to happen to PL design in decades
</code></pre>
&quot;[D]ecades&quot; is a wild overstatement.  In the last 10 years, I would vote for LLVM, which greatly improved the <i>velocity</i> of (experimental) programming language development.  Would Rust have developed so quickly without LLVM?  Probably not.  Look at the speed of development in Rust, Swift, Zig, and many others that use LLVM as their backend.  It is night-and-day compared to 20 years ago in a GCC-only open source compiler world.  I remember the bad old days where GCC was the elephant in the room, but so hard to add and maintain frontends, that few did it.<p><pre><code>    Rust has the same memory-safety guarantees with none of the drawbacks of GC
</code></pre>
I never saw this before.  Are there any counterpoints?</div><br/><div id="38514557" class="c"><input type="checkbox" id="c-38514557" checked=""/><div class="controls bullet"><span class="by">ColonelPhantom</span><span>|</span><a href="#38509876">root</a><span>|</span><a href="#38514059">parent</a><span>|</span><a href="#38512479">next</a><span>|</span><label class="collapse" for="c-38514557">[-]</label><label class="expand" for="c-38514557">[1 more]</label></div><br/><div class="children"><div class="content">Rust spent its entire innovation budget on zero-cost memory safety! Basically, instead of you tracking lifetimes (like in C with malloc&#x2F;free) or the runtime tracking lifetimes (like in a GC&#x27;d language), Rust lets the compiler do this with a &#x27;borrowing&#x27; system.<p>Borrowing in Rust means objects exist in two states: owned (which get dropped when they fall out of scope, like in C++), and borrowed, which means some other scope owns the object and we only have a reference to it. The compiler verifies that a borrow cannot outlive the actual object, so it statically prevents use-after-free errors.<p>Rust also has a distinction between constant and mutable values, and statically checks that any mutable references are exclusive, and that immutable references are only shared with other immutable references. With this it helps prevent race conditions or other such mistakes.<p>Finally, Rust also actually has smart pointers in case you truly don&#x27;t know when an object won&#x27;t be needed anymore, although the names are a bit different than in C++; there&#x27;s Rc&#x2F;Arc for reference counting (like shared_ptr), Box for owning pointers (like unique_ptr?), and RefCell, that&#x27;s like a runtime borrow checker.<p>Apart from these features that prevent use-after-free and aliasing, Rust also has a feature called &#x27;unsafe&#x27; with which you can bypass all these and e.g. work with raw pointers. Unsafe is generally used sparingly (and if not, attracts a lot of criticism, like happened to actix-web), and the safe abstractions on top also provide more pedestrian safety features like bounds checking. You can skip bounds checking on e.g. a Vec, but doing so actually requires you to drop into unsafe yourself, since the get_unchecked function is marked unsafe in the stdlib.<p>Small interesting side note: I&#x27;m pretty sure Rust is actually doing very little new things, PL-design wise. It&#x27;s more of a realization of theory that has been around for years if not decades.</div><br/></div></div></div></div><div id="38512479" class="c"><input type="checkbox" id="c-38512479" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38509876">root</a><span>|</span><a href="#38512397">parent</a><span>|</span><a href="#38514059">prev</a><span>|</span><a href="#38509968">next</a><span>|</span><label class="collapse" for="c-38512479">[-]</label><label class="expand" for="c-38512479">[1 more]</label></div><br/><div class="children"><div class="content">&gt; with safe Rust you get all the memory-safety advantages of Java or Lisp, without a GC<p>Safe Rust does <i>not</i> protect against memory&#x2F;resource leaks when reference cycles are present.  To avoid those, tracing GC is still needed - and most likely unavoidable in the general case.  Note that avoiding reference cycles is a global concern that can&#x27;t be localized to any single part of the program, so trying to ensure this statically is roughly as hard as proving that a random piece of C&#x2F;C++ code does not corrupt memory.<p>You can of course stick to tree-like allocation patterns where object lifecycles nest cleanly, and that&#x27;s what the borrow checker is all about.  You can also use arenas&#x2F;regions, and future Rust versions will hopefully make those easier to use.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38509968" class="c"><input type="checkbox" id="c-38509968" checked=""/><div class="controls bullet"><span class="by">CooCooCaCha</span><span>|</span><a href="#38509876">prev</a><span>|</span><a href="#38510731">next</a><span>|</span><label class="collapse" for="c-38509968">[-]</label><label class="expand" for="c-38509968">[14 more]</label></div><br/><div class="children"><div class="content">How does Steel handle garbage collection? Would it be possible to manually control the garbage collector? For example, a game that runs the GC at the end of every frame.</div><br/><div id="38510037" class="c"><input type="checkbox" id="c-38510037" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509968">parent</a><span>|</span><a href="#38510731">next</a><span>|</span><label class="collapse" for="c-38510037">[-]</label><label class="expand" for="c-38510037">[13 more]</label></div><br/><div class="children"><div class="content">Immutable values are reference counted, so for most code, things will be dropped when they exit scope. For captured mutable values, there is a fairly mundane mark and sweep collector. It is possible to manually control the garbage collector, however I have not optimized it for that kind of workload. If you were embedding Steel in a game, I don&#x27;t think it would be explicitly necessary to tune the GC as long as you aren&#x27;t using a ton of mutation. If you were using a lot of mutation and still wanted a relatively performant GC collection at the end of every frame, then the underlying GC implementation would have to be changed or swapped to a different one (which is not impossible - I just only have one GC implemented)</div><br/><div id="38510504" class="c"><input type="checkbox" id="c-38510504" checked=""/><div class="controls bullet"><span class="by">CooCooCaCha</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510037">parent</a><span>|</span><a href="#38510357">next</a><span>|</span><label class="collapse" for="c-38510504">[-]</label><label class="expand" for="c-38510504">[5 more]</label></div><br/><div class="children"><div class="content">Thanks, I think swapping and controlling the GC would be a very useful feature.<p>In the game example I gave performance is important, but what&#x27;s also important is consistency. Interactive apps rely on a steady framerate so what you want to avoid is accumulating garbage across multiple frames, then doing a single large collection pass.<p>In other words, it&#x27;s better to do a bit of GC every frame than a bunch at once and risk stuttering.</div><br/><div id="38510643" class="c"><input type="checkbox" id="c-38510643" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510504">parent</a><span>|</span><a href="#38510597">next</a><span>|</span><label class="collapse" for="c-38510643">[-]</label><label class="expand" for="c-38510643">[1 more]</label></div><br/><div class="children"><div class="content">There are concurrent GC implementations for Rust, e.g. Samsara <a href="https:&#x2F;&#x2F;redvice.org&#x2F;2023&#x2F;samsara-garbage-collector&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;redvice.org&#x2F;2023&#x2F;samsara-garbage-collector&#x2F;</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;chc4&#x2F;samsara">https:&#x2F;&#x2F;github.com&#x2F;chc4&#x2F;samsara</a> that avoid blocking, except to a minimal extent in rare cases of contention.  That fits pretty well with the pattern of &quot;doing a bit of GC every frame&quot;.<p>(Note that doing GC over large object graphs will nonetheless involve significant overhead, even with efficient implementations as seen here; GC is not at all a silver bullet, and should be avoided if at all possible.  The actual point of GC is to enable computing over highly general, possibly cyclical object graphs - if that doesn&#x27;t apply, other memory management strategies can be used instead.)</div><br/></div></div><div id="38510597" class="c"><input type="checkbox" id="c-38510597" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510504">parent</a><span>|</span><a href="#38510643">prev</a><span>|</span><a href="#38510357">next</a><span>|</span><label class="collapse" for="c-38510597">[-]</label><label class="expand" for="c-38510597">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll make a tracking issue for it - new GC work is fun! I&#x27;ll do some research, I have on my back log to integrate Steel into Bevy or some other Rust game engine, would give me a reason to make some fun GCs</div><br/><div id="38510698" class="c"><input type="checkbox" id="c-38510698" checked=""/><div class="controls bullet"><span class="by">CooCooCaCha</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510597">parent</a><span>|</span><a href="#38510357">next</a><span>|</span><label class="collapse" for="c-38510698">[-]</label><label class="expand" for="c-38510698">[2 more]</label></div><br/><div class="children"><div class="content">Nice! Hopefully my statements didn&#x27;t come off as demanding. Just providing some info on that use case.</div><br/><div id="38510761" class="c"><input type="checkbox" id="c-38510761" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510698">parent</a><span>|</span><a href="#38510357">next</a><span>|</span><label class="collapse" for="c-38510761">[-]</label><label class="expand" for="c-38510761">[1 more]</label></div><br/><div class="children"><div class="content">Not at all! I agree it is a useful feature, I&#x27;d be curious how much it is necessary if not using any mutation, but the best way for me to find out is to try it out :)</div><br/></div></div></div></div></div></div></div></div><div id="38510357" class="c"><input type="checkbox" id="c-38510357" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510037">parent</a><span>|</span><a href="#38510504">prev</a><span>|</span><a href="#38510731">next</a><span>|</span><label class="collapse" for="c-38510357">[-]</label><label class="expand" for="c-38510357">[7 more]</label></div><br/><div class="children"><div class="content">You might find the Recycler algorithm interesting - nim&#x27;s ORC collector is ARC + Recycler and seems to be working out rather well.</div><br/><div id="38510553" class="c"><input type="checkbox" id="c-38510553" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510357">parent</a><span>|</span><a href="#38510731">next</a><span>|</span><label class="collapse" for="c-38510553">[-]</label><label class="expand" for="c-38510553">[6 more]</label></div><br/><div class="children"><div class="content">Thanks for the recommendation, with some brief poking around it does seem promising! It looks like the algorithm is this? <a href="https:&#x2F;&#x2F;github.com&#x2F;fitzgen&#x2F;bacon-rajan-cc">https:&#x2F;&#x2F;github.com&#x2F;fitzgen&#x2F;bacon-rajan-cc</a><p>The link to the paper seems dead unfortunately from this blog post <a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;blog&#x2F;2020&#x2F;12&#x2F;08&#x2F;introducing-orc.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;nim-lang.org&#x2F;blog&#x2F;2020&#x2F;12&#x2F;08&#x2F;introducing-orc.html</a><p>I could see how it works as a drop in replacement for Rc</div><br/><div id="38511617" class="c"><input type="checkbox" id="c-38511617" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510553">parent</a><span>|</span><a href="#38510837">next</a><span>|</span><label class="collapse" for="c-38511617">[-]</label><label class="expand" for="c-38511617">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;trout.me.uk&#x2F;gc&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;trout.me.uk&#x2F;gc&#x2F;</a> - see recycler-overview.pdf and recycler-algorithm.pdf<p>As with &#x2F;lisp&#x2F; I tend to grab my own copies of papers I think I&#x27;ll want to refer to later in case the original URL vanishes in a puff of bitrot :)</div><br/><div id="38511725" class="c"><input type="checkbox" id="c-38511725" checked=""/><div class="controls bullet"><span class="by">j-james</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38511617">parent</a><span>|</span><a href="#38510837">next</a><span>|</span><label class="collapse" for="c-38511725">[-]</label><label class="expand" for="c-38511725">[1 more]</label></div><br/><div class="children"><div class="content">Heh, neat to see you&#x27;ve got the Perceus paper there too. That is in fact the other part (the &quot;ARC&quot;) of Nim&#x27;s memory management for those unaware - with the only differences being Nim frees memory at the end of scope, rather than last use, and and Perceus maybe might be atomic (do not fully remember. ARC isn&#x27;t atomic.)</div><br/></div></div></div></div><div id="38510837" class="c"><input type="checkbox" id="c-38510837" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510553">parent</a><span>|</span><a href="#38511617">prev</a><span>|</span><a href="#38510731">next</a><span>|</span><label class="collapse" for="c-38510837">[-]</label><label class="expand" for="c-38510837">[3 more]</label></div><br/><div class="children"><div class="content">The bacon-rajan-cc link says it&#x27;s stop-the-world.  Samsara seems to be fully concurrent.</div><br/><div id="38511604" class="c"><input type="checkbox" id="c-38511604" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38510837">parent</a><span>|</span><a href="#38510731">next</a><span>|</span><label class="collapse" for="c-38511604">[-]</label><label class="expand" for="c-38511604">[2 more]</label></div><br/><div class="children"><div class="content">The bacon-rajan-cc link has only -implemented- a stop-the-world version, but notes right at the top of the README that it -can- be concurrent, and the stop-the-world-only-ness is only &#x27;Currently.&#x27;<p><a href="https:&#x2F;&#x2F;trout.me.uk&#x2F;gc&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;trout.me.uk&#x2F;gc&#x2F;</a> has two Recycler papers if you want more details.</div><br/><div id="38512374" class="c"><input type="checkbox" id="c-38512374" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38509968">root</a><span>|</span><a href="#38511604">parent</a><span>|</span><a href="#38510731">next</a><span>|</span><label class="collapse" for="c-38512374">[-]</label><label class="expand" for="c-38512374">[1 more]</label></div><br/><div class="children"><div class="content">Samsara is implementing the same algorithm and seems to be further along.  Though there&#x27;s also &#x27;shredder&#x27; <a href="https:&#x2F;&#x2F;github.com&#x2F;Others&#x2F;shredder">https:&#x2F;&#x2F;github.com&#x2F;Others&#x2F;shredder</a> with a different overall approach.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38510731" class="c"><input type="checkbox" id="c-38510731" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38509968">prev</a><span>|</span><a href="#38511131">next</a><span>|</span><label class="collapse" for="c-38510731">[-]</label><label class="expand" for="c-38510731">[4 more]</label></div><br/><div class="children"><div class="content">Which Scheme is this implementing? R7RS? Any SRFIs? Is there a library reference document?</div><br/><div id="38510908" class="c"><input type="checkbox" id="c-38510908" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38510731">parent</a><span>|</span><a href="#38511131">next</a><span>|</span><label class="collapse" for="c-38510908">[-]</label><label class="expand" for="c-38510908">[3 more]</label></div><br/><div class="children"><div class="content">Starting with R5RS compliance, then once that is achieved moving on to R7RS.<p>I borrowed the R5RS test suite from chibi here - <a href="https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel&#x2F;blob&#x2F;master&#x2F;cogs&#x2F;r5rs.scm">https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel&#x2F;blob&#x2F;master&#x2F;cogs&#x2F;r5rs.sc...</a> - only a few of these tests don&#x27;t yet pass. Something like 135 pass, 4 fail, 20 skipped since I haven&#x27;t implemented the primitives yet.<p>I&#x27;ve only tested against a few SRFIs so far, but am also attempting to run the R7RS benchmark suite <a href="https:&#x2F;&#x2F;ecraven.github.io&#x2F;r7rs-benchmarks&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ecraven.github.io&#x2F;r7rs-benchmarks&#x2F;</a> - So far you can view the progress here <a href="https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel&#x2F;tree&#x2F;master&#x2F;r7rs-benchmarks">https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel&#x2F;tree&#x2F;master&#x2F;r7rs-benchma...</a><p>There are some more that aren&#x27;t yet checked in. I plan to get a document up with the exact state of compliance soon.<p>The biggest difference right now is that, like Racket, Steel lists are immutable, so there I need a compatibility layer when running portable scheme.</div><br/><div id="38511254" class="c"><input type="checkbox" id="c-38511254" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38510731">root</a><span>|</span><a href="#38510908">parent</a><span>|</span><a href="#38511131">next</a><span>|</span><label class="collapse" for="c-38511254">[-]</label><label class="expand" for="c-38511254">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! Was this originally a &quot;just because&quot; project, or do you expect it to offer some improvements or advantages over existing embeddable Schemes like Chibi (as you mentioned)?</div><br/><div id="38511440" class="c"><input type="checkbox" id="c-38511440" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38510731">root</a><span>|</span><a href="#38511254">parent</a><span>|</span><a href="#38511131">next</a><span>|</span><label class="collapse" for="c-38511440">[-]</label><label class="expand" for="c-38511440">[1 more]</label></div><br/><div class="children"><div class="content">Originally started it as a school project, which then during the pandemic morphed into something to work on while cooped up. It is really a passion project, working on it is fun! There are some interesting design things I wanted to explore, like how to get good performance out of safe Rust, using unrolled linked lists or vlists instead of naive linked lists, using contracts, etc.<p>Chibi is an impressive scheme implementation, and it will take a long time before Steel can hit the same level of compliance as Chibi. There is not a Chibi equivalent in native Rust that I am aware of. There are other embedded scripting languages for Rust that are pleasant - but no schemes of the maturity of Chibi. So in that regard, I&#x27;m hoping to offer a compelling scheme in native Rust to make integration with Rust applications relatively easy and painless.<p>I also don&#x27;t have a particularly strong need to be 100% completely compliant with the scheme specs. The plan is to have compatibility layers so that portable scheme code can be used, however there are things about scheme that I think Racket (for example) improved on, and I&#x27;d like to explore that as well as much as I can.</div><br/></div></div></div></div></div></div></div></div><div id="38511131" class="c"><input type="checkbox" id="c-38511131" checked=""/><div class="controls bullet"><span class="by">perrygeo</span><span>|</span><a href="#38510731">prev</a><span>|</span><a href="#38508952">next</a><span>|</span><label class="collapse" for="c-38511131">[-]</label><label class="expand" for="c-38511131">[1 more]</label></div><br/><div class="children"><div class="content">Fantastic project! If you&#x27;re looking to embed a DSL&#x2F;full programming language into your application, this seems right on point. Rhai and RustPython are two other options if you don&#x27;t dig parentheses.</div><br/></div></div><div id="38508952" class="c"><input type="checkbox" id="c-38508952" checked=""/><div class="controls bullet"><span class="by">darthrupert</span><span>|</span><a href="#38511131">prev</a><span>|</span><a href="#38510340">next</a><span>|</span><label class="collapse" for="c-38508952">[-]</label><label class="expand" for="c-38508952">[1 more]</label></div><br/><div class="children"><div class="content">This is just perfection on first glance, exactly what I&#x27;ve been looking for to augment my Rust projects that need a command&#x2F;configuration language. And with a working repl, too, apparently.<p>I hope the second and third glances will be good too.</div><br/></div></div><div id="38510340" class="c"><input type="checkbox" id="c-38510340" checked=""/><div class="controls bullet"><span class="by">I_am_tiberius</span><span>|</span><a href="#38508952">prev</a><span>|</span><a href="#38510574">next</a><span>|</span><label class="collapse" for="c-38510340">[-]</label><label class="expand" for="c-38510340">[2 more]</label></div><br/><div class="children"><div class="content">It sounds great but what is it exactly and what can I use it for? Is there an equivalent of this in other languages?</div><br/><div id="38510428" class="c"><input type="checkbox" id="c-38510428" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38510340">parent</a><span>|</span><a href="#38510574">next</a><span>|</span><label class="collapse" for="c-38510428">[-]</label><label class="expand" for="c-38510428">[1 more]</label></div><br/><div class="children"><div class="content">Hopefully the linked README provides a general overview (I know I need to write some more documentation!), but Steel is an implementation of the scheme programming language (not entirely compliant yet, but aiming for R5RS and R7RS compliance). It can be used as a standalone language via the interpreter&#x2F;repl (like Python or Racket), or it can be embedded inside applications, like Lua. There are hundreds (thousands, probably) of embeddable languages, each with their own flavor - see a list compiled here for example <a href="https:&#x2F;&#x2F;github.com&#x2F;dbohdan&#x2F;embedded-scripting-languages">https:&#x2F;&#x2F;github.com&#x2F;dbohdan&#x2F;embedded-scripting-languages</a><p>Use cases are generally for either configuration, scripting, or plugins - so scripting in games, or adding extensions to your text editor without having to use FFI or RPC + serializing a bunch of data. The advantage it has over using dynamic libraries (in general) is it runs in the same process, and can access the internal data structures directly without a lot of ceremony involved. The downside is that it is typically not as fast as native code unless a JIT is involved.<p>Javascript is an example of an embedded scripting, where the browser is the host application.</div><br/></div></div></div></div><div id="38510574" class="c"><input type="checkbox" id="c-38510574" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#38510340">prev</a><span>|</span><a href="#38509258">next</a><span>|</span><label class="collapse" for="c-38510574">[-]</label><label class="expand" for="c-38510574">[3 more]</label></div><br/><div class="children"><div class="content">Is it possible to avoid rust completely when programming using Steel?</div><br/><div id="38510621" class="c"><input type="checkbox" id="c-38510621" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38510574">parent</a><span>|</span><a href="#38509258">next</a><span>|</span><label class="collapse" for="c-38510621">[-]</label><label class="expand" for="c-38510621">[2 more]</label></div><br/><div class="children"><div class="content">Yep - you can write standalone steel code without interacting with Rust at all, just interacting with the interpreter. I&#x27;ve done the first few days of the advent of code in Steel without needing to touch any Rust. Now, I will say that Steel has gotten visibility faster than I&#x27;ve been able to keep up with, so you might find a native function missing, or something that you would like to use that isn&#x27;t implemented yet - at which point you either need to implement it yourself or open up an issue for someone to get to :)</div><br/><div id="38511292" class="c"><input type="checkbox" id="c-38511292" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#38510574">root</a><span>|</span><a href="#38510621">parent</a><span>|</span><a href="#38509258">next</a><span>|</span><label class="collapse" for="c-38511292">[-]</label><label class="expand" for="c-38511292">[1 more]</label></div><br/><div class="children"><div class="content">Solving Advent of Code problems in a language you implemented yourself should earn you an extra good star or something. Nice work, and cool project!</div><br/></div></div></div></div></div></div><div id="38509258" class="c"><input type="checkbox" id="c-38509258" checked=""/><div class="controls bullet"><span class="by">sirsuki</span><span>|</span><a href="#38510574">prev</a><span>|</span><a href="#38509620">next</a><span>|</span><label class="collapse" for="c-38509258">[-]</label><label class="expand" for="c-38509258">[41 more]</label></div><br/><div class="children"><div class="content">When I tried to introduce s-expressions to a DSL my co-workers nearly lynched me. The parenthesis were so violently hated I sunk into a deep hole and still haven’t came back out of it.</div><br/><div id="38509439" class="c"><input type="checkbox" id="c-38509439" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38509258">parent</a><span>|</span><a href="#38509455">next</a><span>|</span><label class="collapse" for="c-38509439">[-]</label><label class="expand" for="c-38509439">[29 more]</label></div><br/><div class="children"><div class="content">It really is kind of frustrating isn&#x27;t it? Because anyone who&#x27;s put any real effort into learning Lisp knows that the parentheses are not what&#x27;s hard to understand, actually. You don&#x27;t even have to read them, really.<p>So when people complain loudly about parentheses in Lisp that just tells me they probably never made any real effort to learn it, and are actively opposed to trying.<p>It&#x27;s not a productive starting point for a discussion.</div><br/><div id="38509549" class="c"><input type="checkbox" id="c-38509549" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509439">parent</a><span>|</span><a href="#38509455">next</a><span>|</span><label class="collapse" for="c-38509549">[-]</label><label class="expand" for="c-38509549">[28 more]</label></div><br/><div class="children"><div class="content">Counterpoint: why are people under any obligation to try?</div><br/><div id="38509637" class="c"><input type="checkbox" id="c-38509637" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509549">parent</a><span>|</span><a href="#38509763">next</a><span>|</span><label class="collapse" for="c-38509637">[-]</label><label class="expand" for="c-38509637">[25 more]</label></div><br/><div class="children"><div class="content">They&#x27;re not. But they&#x27;re also not required to flaunt their own ignorance as though it&#x27;s a well-formed opinion. Also, in a professional setting, I find it a bit unprofessional and rude to poo poo technical ideas over trivialities.</div><br/><div id="38511305" class="c"><input type="checkbox" id="c-38511305" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509637">parent</a><span>|</span><a href="#38509684">next</a><span>|</span><label class="collapse" for="c-38511305">[-]</label><label class="expand" for="c-38511305">[10 more]</label></div><br/><div class="children"><div class="content">I’ve written a large application in Lisp. Hated parentheses before, hate them even more now. It needlessly obscures code.<p>Maybe it’s a personal issue, idk. But it’s not out of ignorance nor is code readability a trivial point.</div><br/><div id="38511882" class="c"><input type="checkbox" id="c-38511882" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38511305">parent</a><span>|</span><a href="#38512147">next</a><span>|</span><label class="collapse" for="c-38511882">[-]</label><label class="expand" for="c-38511882">[7 more]</label></div><br/><div class="children"><div class="content">Yeah it is a personal issue, there are people who really like Lisp syntax (I&#x27;m one of them). That doesn&#x27;t mean anything bad, of course, some people like dark text on a light background, others light text on a dark background. Everyone is different and that&#x27;s what makes the world so awesome.<p>I see something like:<p><pre><code>  some-var: I64 := a * b - c ^ d ^ e;
</code></pre>
...and my brain gives out, while I find:<p><pre><code>  (let ((some-var (- (* a b)
                     (^ c d e))))
    (declare (type I64 some-var))
    ...)
</code></pre>
...to be much more readable, YMMV.</div><br/><div id="38512508" class="c"><input type="checkbox" id="c-38512508" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38511882">parent</a><span>|</span><a href="#38512147">next</a><span>|</span><label class="collapse" for="c-38512508">[-]</label><label class="expand" for="c-38512508">[6 more]</label></div><br/><div class="children"><div class="content">How do you look at the latter and know the code structure? Are you counting parentheses? Or are you relying on conventions around white space indentation. If the latter, are you not concerned a misplaced parentheses might make the code different from it appears? There could be bugs not shown in the indentation.<p>Most lispers I know code in eMacs or other smart editors that provide auto code formatting and colored parens. But why not just make the indentation (or whatever that you really rely upon) the actual syntax, so there CANNOT be hidden bugs of that sort?<p>Edit: to expand on this, I think it is no coincidence that most lisps remain untyped to this day. Strong typing is about having the compiler enforce type rules so you the developer can’t fuck it up. Weak typing is more convenient, but ultimately a source of bugs. Lisp has, effectively, weak syntax. I don’t like weak syntax for the same reasons I don’t like weak typing.</div><br/><div id="38513235" class="c"><input type="checkbox" id="c-38513235" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38512508">parent</a><span>|</span><a href="#38513713">next</a><span>|</span><label class="collapse" for="c-38513235">[-]</label><label class="expand" for="c-38513235">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But why not just make the indentation (or whatever that you really rely upon) the actual syntax, so there CANNOT be hidden bugs of that sort?<p>That&#x27;s Python. When whitespace matters, any aesthetic reformatting mistake can change the program&#x27;s meaning. With s-expressions this cannot happen. A lisp code parser is completely deterministic regardless of where the newlines, spaces, and tabs occur. You can remove all the newlines from a 10,000-line Lisp program and the compiler will parse it exactly the same as if it were formatted aesthetically.* You can also write a simple program that takes that godawful one-line program and reformats it aesthetically however you like--the meaning won&#x27;t change.<p>IOW in Lisp the <i>aesthetics</i> of the source code do not determine its meaning; aesthetics and meaning are orthogonal properties and you are free to adjust the two independently. This is also somewhat true in languages like C, but rather than several special-case punctuation characters, in Lisp there&#x27;s only one: The parenthesis. Lisp is thus similar in spirit to HTML where semantics and layout are [mostly] independent.<p>* With a few obvious exceptions like EOL comments, and newlines that are part of quoted strings.</div><br/><div id="38514648" class="c"><input type="checkbox" id="c-38514648" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38513235">parent</a><span>|</span><a href="#38513713">next</a><span>|</span><label class="collapse" for="c-38514648">[-]</label><label class="expand" for="c-38514648">[2 more]</label></div><br/><div class="children"><div class="content">&gt; any aesthetic reformatting mistake can change the program&#x27;s meaning.<p>Why would you just randomly change indentation? On the contrary, I don&#x27;t want the indentation to say something else than the code actually does.<p>&gt; You can remove all the newlines from a 10,000-line Lisp program and the compiler will parse it exactly the same as if it were formatted aesthetically.<p>But a human won’t. And that’s a problem.</div><br/><div id="38514978" class="c"><input type="checkbox" id="c-38514978" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38514648">parent</a><span>|</span><a href="#38513713">next</a><span>|</span><label class="collapse" for="c-38514978">[-]</label><label class="expand" for="c-38514978">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why would you just randomly change indentation? On the contrary, I don&#x27;t want the indentation to say something else than the code actually does.<p>Because the user may want the development environment to display snippets of code in various places: REPL, debugger, code browsers, inspectors, various editor types, ...<p>In a Lisp system the code can be data and text. Code formatters can reformat code depending on user preferences, device types (color, font, ...), view sizes, ...<p>In Lisp often code gets generated (for example via &#x27;Macros&#x27;) and this code will be automatically layouted in various view (different widths, different fonts, different detail). Code can be small or large, the system may abbreviate parts, which one can expand, if necessary.<p>Source Code is not necessary static text in a file system. Code can just be list-based data structures and layout is fluid.<p>In Common Lisp the formatted output of code is also user extensible&#x2F;customizable, a &#x27;pretty printer&#x27; is a part of the language spec:<p><a href="https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;22_ba.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;22_ba...</a><p>If we read a text in a book reading the device, one can also change for example font size and the thing will relayout the text accordingly.</div><br/></div></div></div></div></div></div><div id="38513713" class="c"><input type="checkbox" id="c-38513713" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38512508">parent</a><span>|</span><a href="#38513235">prev</a><span>|</span><a href="#38513222">next</a><span>|</span><label class="collapse" for="c-38513713">[-]</label><label class="expand" for="c-38513713">[1 more]</label></div><br/><div class="children"><div class="content">Well I don&#x27;t like indentation-based syntax because when I write code with such syntax down in a notebook I have this bad tendency to drift to the right as I go lower down the page. And then if I go training or something and return the drift causes me to lose the structure of the code.<p>With round brackets on the other hand, well... I think my brain just works with round brackets. Like my mind is coded in Lisp or something, I dunno. It would explain why I&#x27;m so slow: GC pauses. My mind should really be ported to SBCL or something.</div><br/></div></div><div id="38513222" class="c"><input type="checkbox" id="c-38513222" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38512508">parent</a><span>|</span><a href="#38513713">prev</a><span>|</span><a href="#38512147">next</a><span>|</span><label class="collapse" for="c-38513222">[-]</label><label class="expand" for="c-38513222">[1 more]</label></div><br/><div class="children"><div class="content">Auto code formatting is a must in every language at this point.</div><br/></div></div></div></div></div></div><div id="38512147" class="c"><input type="checkbox" id="c-38512147" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38511305">parent</a><span>|</span><a href="#38511882">prev</a><span>|</span><a href="#38509684">next</a><span>|</span><label class="collapse" for="c-38512147">[-]</label><label class="expand" for="c-38512147">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re clearly the exception though. It&#x27;s almost always just ignorance in my experience. That&#x27;s why I used the word probably. I assume if someone asked <i>you</i> what you thought about Lisp, you&#x27;d have a lot more interesting stuff to say than just &quot;ew, parentheses&quot;, right?<p>That&#x27;s my point, is all.<p>As for readability, I don&#x27;t think it&#x27;s trivial at all. I just don&#x27;t think syntax has all that much to do with it. It plays a role, but a very minor one compared to overall code quality. In other words it&#x27;s syntax that&#x27;s mostly a trivial point, not readablity.<p>One undeniable advantage of Lisp in terms of syntactic readability though is that other languages always end up piling on more syntax over time as the language gets older. That&#x27;s by far my least favourite thing about Rust for instance, even though I do love the language. There&#x27;s always some new syntax, keyword, or position that an existing keyword can suddenly go in. The longer I go without actively using Rust, the more work it is to start again, because I have to go learn all this new stuff now. And syntax always takes a while to feel intuitive, at least for me. But it&#x27;s still a lot easier than grokking new semantics and paradigms. I still don&#x27;t have a good handle on async rust.<p>If someone told me to go read some ALGOL 68, I could probably do just fine because there&#x27;s nothing <i>semantically</i> unfamiliar about it compared to something like C. But if someone gave me some Haskell written as sexps I would be utterly lost despite the syntax being perfectly comfortable to me. Because I never quite grokked typed FP.</div><br/><div id="38512538" class="c"><input type="checkbox" id="c-38512538" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38512147">parent</a><span>|</span><a href="#38509684">next</a><span>|</span><label class="collapse" for="c-38512538">[-]</label><label class="expand" for="c-38512538">[1 more]</label></div><br/><div class="children"><div class="content">No, the horrible syntax of lisp is pretty much all I have to say on it, honestly. I don’t care for lisp for the same reason I don’t care for perl: write-only languages are a bigger hinderence to software maintenance than whatever advantage might be obtained. And the advantages of lisp have long since been obtained by other languages.</div><br/></div></div></div></div></div></div><div id="38509684" class="c"><input type="checkbox" id="c-38509684" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509637">parent</a><span>|</span><a href="#38511305">prev</a><span>|</span><a href="#38509763">next</a><span>|</span><label class="collapse" for="c-38509684">[-]</label><label class="expand" for="c-38509684">[14 more]</label></div><br/><div class="children"><div class="content">&gt; But they&#x27;re also not required to flaunt their own ignorance as though it&#x27;s a well-formed opinion.<p>I don’t like the parenthesis. I’m not flaunting anything. Is it “flaunting” to calmly and respectfully share an opinion? To you it’s trivial, to me it’s not.<p>It seems like you’re interested in creating conflict with people that don’t like a thing that you like. Which, I would cast this behavior as unprofessional, tbh.</div><br/><div id="38509922" class="c"><input type="checkbox" id="c-38509922" checked=""/><div class="controls bullet"><span class="by">CooCooCaCha</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509684">parent</a><span>|</span><a href="#38509830">next</a><span>|</span><label class="collapse" for="c-38509922">[-]</label><label class="expand" for="c-38509922">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a fan of the parenthesis either, but when I learned about s-expressions and how lisp programs are also a data structures that piqued my interest and helped me look past them.<p>I question people&#x27;s judgement who can&#x27;t look past the syntax when there is a very good, and interesting technical reason behind them.</div><br/><div id="38510109" class="c"><input type="checkbox" id="c-38510109" checked=""/><div class="controls bullet"><span class="by">arnsholt</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509922">parent</a><span>|</span><a href="#38511321">next</a><span>|</span><label class="collapse" for="c-38510109">[-]</label><label class="expand" for="c-38510109">[2 more]</label></div><br/><div class="children"><div class="content">Code as data is interesting, but mostly orthogonal to S expressions. For example, Prolog code has the same property without S expressions, and more esoterically TeX (which is succinctly explained to a lisper as programming with defmacro but not defun).</div><br/><div id="38512282" class="c"><input type="checkbox" id="c-38512282" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38510109">parent</a><span>|</span><a href="#38511321">next</a><span>|</span><label class="collapse" for="c-38512282">[-]</label><label class="expand" for="c-38512282">[1 more]</label></div><br/><div class="children"><div class="content">Also raw machine code and XML, even.<p>Though it&#x27;s just more powerful in Lisp precisely because the code is just lists in a language designed around working with lists.<p>So you can actually leverage this property in Lisp without the code becoming inscrutable for it, which in my experience doesn&#x27;t usually happen in other languages.</div><br/></div></div></div></div><div id="38511321" class="c"><input type="checkbox" id="c-38511321" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509922">parent</a><span>|</span><a href="#38510109">prev</a><span>|</span><a href="#38510147">next</a><span>|</span><label class="collapse" for="c-38511321">[-]</label><label class="expand" for="c-38511321">[2 more]</label></div><br/><div class="children"><div class="content">A-expressions are a choice, and it is fine to argue whether it is a good one. There are plenty of other ways of achieving honiconic syntax.</div><br/><div id="38514653" class="c"><input type="checkbox" id="c-38514653" checked=""/><div class="controls bullet"><span class="by">ColonelPhantom</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38511321">parent</a><span>|</span><a href="#38510147">next</a><span>|</span><label class="collapse" for="c-38514653">[-]</label><label class="expand" for="c-38514653">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s an A-expression? I tried looking it up but didn&#x27;t find anything.<p>I have heard of M-expressions but never of an actual implementation. Scheme also seems to have some SRFIs involving alternate syntax that&#x27;s whitespace dependent, like SRFI 119 (wisp), SRFI 110 (sweet-expressions or T-expressions), or SRFI 49.</div><br/></div></div></div></div><div id="38510147" class="c"><input type="checkbox" id="c-38510147" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509922">parent</a><span>|</span><a href="#38511321">prev</a><span>|</span><a href="#38509830">next</a><span>|</span><label class="collapse" for="c-38510147">[-]</label><label class="expand" for="c-38510147">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I question people&#x27;s judgement who can&#x27;t look past the syntax when there is a very good, and interesting technical reason behind them<p>The list of things that are interesting is endless, though. I see something I’m turned off by, I move on. There are plenty of valuable things to spend time on.</div><br/></div></div></div></div><div id="38509830" class="c"><input type="checkbox" id="c-38509830" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509684">parent</a><span>|</span><a href="#38509922">prev</a><span>|</span><a href="#38509800">next</a><span>|</span><label class="collapse" for="c-38509830">[-]</label><label class="expand" for="c-38509830">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like curly braces, but I don&#x27;t let that decide which programming languages I use.</div><br/><div id="38509911" class="c"><input type="checkbox" id="c-38509911" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509830">parent</a><span>|</span><a href="#38509800">next</a><span>|</span><label class="collapse" for="c-38509911">[-]</label><label class="expand" for="c-38509911">[3 more]</label></div><br/><div class="children"><div class="content">That’s your choice!</div><br/><div id="38512995" class="c"><input type="checkbox" id="c-38512995" checked=""/><div class="controls bullet"><span class="by">hautcake</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509911">parent</a><span>|</span><a href="#38509800">next</a><span>|</span><label class="collapse" for="c-38512995">[-]</label><label class="expand" for="c-38512995">[2 more]</label></div><br/><div class="children"><div class="content">People that express strong opinions about syntax come across as dummies to professionals. Doesn’t mean they are of course. Just sayin’.</div><br/><div id="38513701" class="c"><input type="checkbox" id="c-38513701" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38512995">parent</a><span>|</span><a href="#38509800">next</a><span>|</span><label class="collapse" for="c-38513701">[-]</label><label class="expand" for="c-38513701">[1 more]</label></div><br/><div class="children"><div class="content">Similarly, people that dismiss valid criticism because it doesn&#x27;t match their personal opinions seem like dummies to grown ups.<p>Unsure if it means they are or are not dummies, though.</div><br/></div></div></div></div></div></div></div></div><div id="38509800" class="c"><input type="checkbox" id="c-38509800" checked=""/><div class="controls bullet"><span class="by">dun44</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509684">parent</a><span>|</span><a href="#38509830">prev</a><span>|</span><a href="#38509749">next</a><span>|</span><label class="collapse" for="c-38509800">[-]</label><label class="expand" for="c-38509800">[2 more]</label></div><br/><div class="children"><div class="content">Imagine someone who hates the exponentiation operator but wants to do mathematics nevertheless.  For a living.</div><br/><div id="38509912" class="c"><input type="checkbox" id="c-38509912" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509800">parent</a><span>|</span><a href="#38509749">next</a><span>|</span><label class="collapse" for="c-38509912">[-]</label><label class="expand" for="c-38509912">[1 more]</label></div><br/><div class="children"><div class="content">Interesting hyperbole.</div><br/></div></div></div></div></div></div></div></div><div id="38509763" class="c"><input type="checkbox" id="c-38509763" checked=""/><div class="controls bullet"><span class="by">physPop</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509549">parent</a><span>|</span><a href="#38509637">prev</a><span>|</span><a href="#38509746">next</a><span>|</span><label class="collapse" for="c-38509763">[-]</label><label class="expand" for="c-38509763">[1 more]</label></div><br/><div class="children"><div class="content">Have a learning mindset?</div><br/></div></div></div></div></div></div><div id="38509455" class="c"><input type="checkbox" id="c-38509455" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38509258">parent</a><span>|</span><a href="#38509439">prev</a><span>|</span><a href="#38509378">next</a><span>|</span><label class="collapse" for="c-38509455">[-]</label><label class="expand" for="c-38509455">[1 more]</label></div><br/><div class="children"><div class="content">I did it once in an internal UI because we needed to rapidly expose some functionality that could be composed&#x2F;piped in complex ways and it would take a while to implement a normal UI<p>Was met with skepticism, esp around the engineering&#x2F;maintenance overhead, until I told them the parser took me a couple hours to write and was only a hundred lines of code or so</div><br/></div></div><div id="38509378" class="c"><input type="checkbox" id="c-38509378" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#38509258">parent</a><span>|</span><a href="#38509455">prev</a><span>|</span><a href="#38512123">next</a><span>|</span><label class="collapse" for="c-38509378">[-]</label><label class="expand" for="c-38509378">[6 more]</label></div><br/><div class="children"><div class="content">It is really fun (sad) to see this, I&#x27;ve seen it so many times myself too. You show how something would be with s-expressions, compared to something, and all they can focus on is how many parenthesis there are. But when you sit down and count, they&#x27;re the same amount as the code was when it wasn&#x27;t s-expressions, just in different locations. And when you remove the parenthesis, they can kind of understand the code, kind of.</div><br/><div id="38509433" class="c"><input type="checkbox" id="c-38509433" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509378">parent</a><span>|</span><a href="#38512123">next</a><span>|</span><label class="collapse" for="c-38509433">[-]</label><label class="expand" for="c-38509433">[5 more]</label></div><br/><div class="children"><div class="content">One option that might be suitable for a DSL, is implicit parens based on whitespace. A newline opens a new paren, and the paren closes when it reaches another line with the same indentation e.g:<p><pre><code>  (defun factorial (x)
    (if (zerop x)
      1
      (* x (factorial (- x 1)))))
</code></pre>
could be rewritten as<p><pre><code>  defun factorial (x)
    if (zerop x)
      1
      * x (factorial (- x 1))</code></pre></div><br/><div id="38509701" class="c"><input type="checkbox" id="c-38509701" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509433">parent</a><span>|</span><a href="#38509624">next</a><span>|</span><label class="collapse" for="c-38509701">[-]</label><label class="expand" for="c-38509701">[3 more]</label></div><br/><div class="children"><div class="content">Existing SRFI: SRFI 49 &quot;Indentation-sensitive syntax&quot;:<p><a href="https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-49&#x2F;srfi-49.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-49&#x2F;srfi-49.html</a></div><br/><div id="38512907" class="c"><input type="checkbox" id="c-38512907" checked=""/><div class="controls bullet"><span class="by">Syzygies</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509701">parent</a><span>|</span><a href="#38511425">next</a><span>|</span><label class="collapse" for="c-38512907">[-]</label><label class="expand" for="c-38512907">[1 more]</label></div><br/><div class="children"><div class="content">I doubt that SRFI 49, or any other proposal I&#x27;ve seen online, has been battle-tested.<p>I&#x27;ve written thousands of lines of Scheme using my own preprocessor, and it&#x27;s my favorite code to look at. I prefer Haskell, for incredible ease of parallelism and a deeper mathematical foundation.<p>The two features I look for in a reduced parenthesis syntax (like looking for the bone marrow in a beef stew recipe) are:<p>1. Some constructions begin doubly parenthesized. One needs a symbol to represent the missing object one parenthesis in. I use $.<p>2. One can write more expressive lines with a flavor of open paren that autocloses at the end of the line. I use |.</div><br/></div></div><div id="38511425" class="c"><input type="checkbox" id="c-38511425" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509701">parent</a><span>|</span><a href="#38512907">prev</a><span>|</span><a href="#38509624">next</a><span>|</span><label class="collapse" for="c-38511425">[-]</label><label class="expand" for="c-38511425">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I knew that there must be prior art out there. :)</div><br/></div></div></div></div><div id="38509624" class="c"><input type="checkbox" id="c-38509624" checked=""/><div class="controls bullet"><span class="by">alwaysbeconsing</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38509433">parent</a><span>|</span><a href="#38509701">prev</a><span>|</span><a href="#38512123">next</a><span>|</span><label class="collapse" for="c-38509624">[-]</label><label class="expand" for="c-38509624">[1 more]</label></div><br/><div class="children"><div class="content">Whitespace significance might be the choice even more controversial than Lisp parens. For myself, I appreciate both, but those that do not, really do not.</div><br/></div></div></div></div></div></div><div id="38512123" class="c"><input type="checkbox" id="c-38512123" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#38509258">parent</a><span>|</span><a href="#38509378">prev</a><span>|</span><a href="#38514399">next</a><span>|</span><label class="collapse" for="c-38512123">[-]</label><label class="expand" for="c-38512123">[1 more]</label></div><br/><div class="children"><div class="content">Maybe:<p><a href="https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-49&#x2F;srfi-49.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-49&#x2F;srfi-49.html</a><p><a href="https:&#x2F;&#x2F;www.draketo.de&#x2F;software&#x2F;wisp" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.draketo.de&#x2F;software&#x2F;wisp</a></div><br/></div></div><div id="38514399" class="c"><input type="checkbox" id="c-38514399" checked=""/><div class="controls bullet"><span class="by">darthrupert</span><span>|</span><a href="#38509258">parent</a><span>|</span><a href="#38512123">prev</a><span>|</span><a href="#38509453">next</a><span>|</span><label class="collapse" for="c-38514399">[-]</label><label class="expand" for="c-38514399">[2 more]</label></div><br/><div class="children"><div class="content">The things I&#x27;m looking for in language syntax these days are<p>1. That it&#x27;s unambiguous enough that my editor can format it correctly every time (provided the code is correct, obviously). Indentation-based languages like Python fail this.<p>2. That its elements and keywords are distinct enough that my editor can apply colours on it. I sometimes feel that S-expression languages fail at this because of their small number of distinct keywords, but that might not be true.<p>Besides these two points, if the language is not a joke language, it&#x27;s probably fine.</div><br/><div id="38514769" class="c"><input type="checkbox" id="c-38514769" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#38509258">root</a><span>|</span><a href="#38514399">parent</a><span>|</span><a href="#38509453">next</a><span>|</span><label class="collapse" for="c-38514769">[-]</label><label class="expand" for="c-38514769">[1 more]</label></div><br/><div class="children"><div class="content">What is ambiguous about Python’s syntax?</div><br/></div></div></div></div></div></div><div id="38509620" class="c"><input type="checkbox" id="c-38509620" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#38509258">prev</a><span>|</span><a href="#38509298">next</a><span>|</span><label class="collapse" for="c-38509620">[-]</label><label class="expand" for="c-38509620">[2 more]</label></div><br/><div class="children"><div class="content">Rust is gradually overcoming C and Fortran and Greenspun&#x27;s tenth rule [0] is apparently inviolable.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule</a></div><br/></div></div><div id="38509298" class="c"><input type="checkbox" id="c-38509298" checked=""/><div class="controls bullet"><span class="by">oldpersonintx</span><span>|</span><a href="#38509620">prev</a><span>|</span><a href="#38510054">next</a><span>|</span><label class="collapse" for="c-38509298">[-]</label><label class="expand" for="c-38509298">[5 more]</label></div><br/><div class="children"><div class="content">I want this to succeed!! please do not let the word &quot;srfi&quot; ever appear in the packages list...naming libraries with obscure numbers no one remembers was a terrible terrible idea that all schemes seem to perpetuate</div><br/><div id="38513130" class="c"><input type="checkbox" id="c-38513130" checked=""/><div class="controls bullet"><span class="by">aag</span><span>|</span><a href="#38509298">parent</a><span>|</span><a href="#38510503">next</a><span>|</span><label class="collapse" for="c-38513130">[-]</label><label class="expand" for="c-38513130">[1 more]</label></div><br/><div class="children"><div class="content">SRFI editor here.  The numeric designations are there because, among other reasons, there is sometimes more than one SRFI for a particular general idea.  But there is nothing stopping libraries from having more than one name, including a semantically meaningful one.  In fact, there has been a SRFI standardizing how that is done since 2008 [1].<p>[1] <a href="https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-97&#x2F;srfi-97.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-97&#x2F;srfi-97.html</a></div><br/></div></div><div id="38510503" class="c"><input type="checkbox" id="c-38510503" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#38509298">parent</a><span>|</span><a href="#38513130">prev</a><span>|</span><a href="#38510303">next</a><span>|</span><label class="collapse" for="c-38510503">[-]</label><label class="expand" for="c-38510503">[2 more]</label></div><br/><div class="children"><div class="content">It is a standard. What do you expect?
But there are some or many Schemes that offer their own libs on top or below SRFI implementations, which then have readable names.</div><br/><div id="38511350" class="c"><input type="checkbox" id="c-38511350" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38509298">root</a><span>|</span><a href="#38510503">parent</a><span>|</span><a href="#38510303">next</a><span>|</span><label class="collapse" for="c-38511350">[-]</label><label class="expand" for="c-38511350">[1 more]</label></div><br/><div class="children"><div class="content">I expect people to willing not conform when nonconformance improves the art.</div><br/></div></div></div></div><div id="38510303" class="c"><input type="checkbox" id="c-38510303" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38509298">parent</a><span>|</span><a href="#38510503">prev</a><span>|</span><a href="#38510054">next</a><span>|</span><label class="collapse" for="c-38510303">[-]</label><label class="expand" for="c-38510303">[1 more]</label></div><br/><div class="children"><div class="content">At the moment I only have 1 SRFI package, and its just to check against compatibility :) - my plan is to wrap the SRFI packages with friendly names and just include the metadata in the package spec so someone searching for it can find it easily.</div><br/></div></div></div></div><div id="38510054" class="c"><input type="checkbox" id="c-38510054" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38509298">prev</a><span>|</span><label class="collapse" for="c-38510054">[-]</label><label class="expand" for="c-38510054">[11 more]</label></div><br/><div class="children"><div class="content">I wonder where the name came from. Being HN, here is my nitpicking  imperative:<p>Names are important. Our inheritance is wit, self-awareness, and irony; names that puncture ego and power and that appeal to joy: C, C++, GNU, Rust, Google, Yahoo!, Vim, Git, awk, etc. Others are beautiful, evocative images, like Apple and Amazon. Names communicate our culture and ideals to each other and to the next generation.<p>Careless, thoughtless names like Microsoft, IBM, etc. (ok it&#x27;s ironic and self-deprecating, but without self-awareness or wit!), etc. should be hated and banned. Egotistical BS, especially Tolkien plagiarists who assert they are supernatural, should be tarred and feathered and paraded around town (with wit and irony).<p>(Plenty of names fall in some middle ground.)<p>If Steel is just a derivative of &#x27;Rust&#x27; [edit: it is not, see the response below], it misses the self-awareness. Someone naming their development product - designed to build great structures - &#x27;Rust&#x27; is engaging in a little self-deprication, joy, and self-awareness. Naming the derivative project &#x27;Steel&#x27; possibly misses all that; there&#x27;s a reason the original wasn&#x27;t named Iron or Steel or Carbon Fiber. But maybe there&#x27;s more to the name.</div><br/><div id="38510127" class="c"><input type="checkbox" id="c-38510127" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38510054">parent</a><span>|</span><a href="#38510089">next</a><span>|</span><label class="collapse" for="c-38510127">[-]</label><label class="expand" for="c-38510127">[7 more]</label></div><br/><div class="children"><div class="content">So here is the history:<p>1. Guy Steele (along with Gerald Sussman) created scheme, and Steel is close to Steele, just drop the e.<p>2. Steel is a scheme, and I observed that scheme names have a tendency to be named things crime related: Scheme, Racket (racketeering), Larceny, etc - Not a scientific analysis at all, but I found it funny at the time that Steel sounds like &quot;steal&quot;.<p>3. You made the observation, Steel sounds like something that would be associated with Rust.<p>Beyond that, I just liked the name. No SEO involved, and arguably probably should have picked something more searchable, but I didn&#x27;t start making it with the intention of there being a lot of users, it started as a project for school.</div><br/><div id="38511841" class="c"><input type="checkbox" id="c-38511841" checked=""/><div class="controls bullet"><span class="by">dannyobrien</span><span>|</span><a href="#38510054">root</a><span>|</span><a href="#38510127">parent</a><span>|</span><a href="#38510405">next</a><span>|</span><label class="collapse" for="c-38511841">[-]</label><label class="expand" for="c-38511841">[2 more]</label></div><br/><div class="children"><div class="content">No judgement (I think great puns bring great minds together so namespace clashes are inevitable), but this was similar to the thinking behind a name for &quot;Guile Steel&quot;, the low-level Scheme being plotted about by some of the Guile Scheme folks here: <a href="https:&#x2F;&#x2F;dustycloud.org&#x2F;blog&#x2F;guile-steel-proposal&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dustycloud.org&#x2F;blog&#x2F;guile-steel-proposal&#x2F;</a></div><br/><div id="38511909" class="c"><input type="checkbox" id="c-38511909" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38510054">root</a><span>|</span><a href="#38511841">parent</a><span>|</span><a href="#38510405">next</a><span>|</span><label class="collapse" for="c-38511909">[-]</label><label class="expand" for="c-38511909">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes I remember seeing that when it was posted on HN - I think Steel predated that post by a few years :)<p>All of the work done by the guile folks is incredible, I wouldn&#x27;t mind the name clash at all if there is a Guile steel that comes about.</div><br/></div></div></div></div><div id="38510405" class="c"><input type="checkbox" id="c-38510405" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#38510054">root</a><span>|</span><a href="#38510127">parent</a><span>|</span><a href="#38511841">prev</a><span>|</span><a href="#38514276">next</a><span>|</span><label class="collapse" for="c-38510405">[-]</label><label class="expand" for="c-38510405">[2 more]</label></div><br/><div class="children"><div class="content">Triple pun score!<p>(I always try and cram as many simultaneous jokes as possible into project names - and have a soft spot for lisp - so I wish you much joy and whatever level of success is most fun for you)</div><br/><div id="38510629" class="c"><input type="checkbox" id="c-38510629" checked=""/><div class="controls bullet"><span class="by">mattparas</span><span>|</span><a href="#38510054">root</a><span>|</span><a href="#38510405">parent</a><span>|</span><a href="#38514276">next</a><span>|</span><label class="collapse" for="c-38510629">[-]</label><label class="expand" for="c-38510629">[1 more]</label></div><br/><div class="children"><div class="content">Thank you - I appreciate the kind words :)</div><br/></div></div></div></div><div id="38514276" class="c"><input type="checkbox" id="c-38514276" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38510054">root</a><span>|</span><a href="#38510127">parent</a><span>|</span><a href="#38510405">prev</a><span>|</span><a href="#38510252">next</a><span>|</span><label class="collapse" for="c-38514276">[-]</label><label class="expand" for="c-38514276">[1 more]</label></div><br/><div class="children"><div class="content">An extra cheeky name might have been &quot;stainless&quot; (steel that doesn&#x27;t rust) ;)</div><br/></div></div><div id="38510252" class="c"><input type="checkbox" id="c-38510252" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38510054">root</a><span>|</span><a href="#38510127">parent</a><span>|</span><a href="#38514276">prev</a><span>|</span><a href="#38510089">next</a><span>|</span><label class="collapse" for="c-38510252">[-]</label><label class="expand" for="c-38510252">[1 more]</label></div><br/><div class="children"><div class="content">Awesome! Thank you. Someone else pointed out the Steele&#x2F;Steel relationship and I was hopeful:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38510060">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38510060</a></div><br/></div></div></div></div><div id="38510089" class="c"><input type="checkbox" id="c-38510089" checked=""/><div class="controls bullet"><span class="by">pasabagi</span><span>|</span><a href="#38510054">parent</a><span>|</span><a href="#38510127">prev</a><span>|</span><a href="#38510969">next</a><span>|</span><label class="collapse" for="c-38510089">[-]</label><label class="expand" for="c-38510089">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s particularly careless: SBCL is short for &#x27;Steel Bank Common Lisp&#x27;, which is a reference to how the CMU university, named after Carnegie Mellon, could be respectively substituted with &#x27;Steel&#x27; (Carnegie) and &#x27;Bank&#x27; (Mellon).</div><br/><div id="38512304" class="c"><input type="checkbox" id="c-38512304" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#38510054">root</a><span>|</span><a href="#38510089">parent</a><span>|</span><a href="#38510969">next</a><span>|</span><label class="collapse" for="c-38512304">[-]</label><label class="expand" for="c-38512304">[1 more]</label></div><br/><div class="children"><div class="content">I, somehow, never put together the SB -&gt; CM link! That&#x27;s awesome, thanks for sharing</div><br/></div></div></div></div><div id="38510969" class="c"><input type="checkbox" id="c-38510969" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#38510054">parent</a><span>|</span><a href="#38510089">prev</a><span>|</span><label class="collapse" for="c-38510969">[-]</label><label class="expand" for="c-38510969">[1 more]</label></div><br/><div class="children"><div class="content">&gt; beautiful, evocative images, like Apple<p>Is this a joke?</div><br/></div></div></div></div></div></div></div></div></div></body></html>