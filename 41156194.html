<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722869859016" as="style"/><link rel="stylesheet" href="styles.css?v=1722869859016"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://dmitry.gr/?r=06.%20Thoughts&amp;proj=10.%20RomRam">Romram: Using QSPI RAM with RP2040&#x27;s SSI in read-write mode</a> <span class="domain">(<a href="http://dmitry.gr">dmitry.gr</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>18 comments</span></div><br/><div><div id="41156627" class="c"><input type="checkbox" id="c-41156627" checked=""/><div class="controls bullet"><span class="by">mrlambchop</span><span>|</span><a href="#41157619">next</a><span>|</span><label class="collapse" for="c-41156627">[-]</label><label class="expand" for="c-41156627">[1 more]</label></div><br/><div class="children"><div class="content">I recently worked on a product (Realtek 200MHz MCU + integraiton wifi&#x2F;ble) that had a similar setup - QSPI connected PSRAM and QSPI connected Flash (with read&#x2F;write).<p>The PSRAM had a reasonable size page cache in the chip that made this memory quite responsive from a CPU perspective - a few rare cache flushes were needed, but things like DMA and bus masters (onboard radios etc..) were completely coherent and it made development much easier to manage.<p>My takeaway was that PSRAM was surprisingly capable (with the right can of hardware controller in place). Kudos to Realtek for getting the hardware to work without a thousand impossible to debug CPU lock ups...</div><br/></div></div><div id="41157619" class="c"><input type="checkbox" id="c-41157619" checked=""/><div class="controls bullet"><span class="by">cellularmitosis</span><span>|</span><a href="#41156627">prev</a><span>|</span><a href="#41156743">next</a><span>|</span><label class="collapse" for="c-41157619">[-]</label><label class="expand" for="c-41157619">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Our HardFault handler can now ... quickly interpret the faulting instruction, emulate the write, flush the cache line, and resume.<p>This sounds similar to the approach taken by yocto-8<p><a href="https:&#x2F;&#x2F;github.com&#x2F;yocto-8&#x2F;yocto-8&#x2F;blob&#x2F;main&#x2F;doc&#x2F;extmem.md">https:&#x2F;&#x2F;github.com&#x2F;yocto-8&#x2F;yocto-8&#x2F;blob&#x2F;main&#x2F;doc&#x2F;extmem.md</a></div><br/></div></div><div id="41156743" class="c"><input type="checkbox" id="c-41156743" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#41157619">prev</a><span>|</span><a href="#41157716">next</a><span>|</span><label class="collapse" for="c-41156743">[-]</label><label class="expand" for="c-41156743">[14 more]</label></div><br/><div class="children"><div class="content">I think the successor to the RP2040 needs to features to absolutely clobber the market:<p>1. A true, ulta-super-duper-low-power mode, and
2. Proper external memory support.</div><br/><div id="41157067" class="c"><input type="checkbox" id="c-41157067" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41156743">parent</a><span>|</span><a href="#41161216">next</a><span>|</span><label class="collapse" for="c-41157067">[-]</label><label class="expand" for="c-41157067">[11 more]</label></div><br/><div class="children"><div class="content">We&#x27;ll probably find out soon-ish, they dropped the name in their last investors report and said it&#x27;s coming in the second half of the year. It&#x27;s going to be the RP235x, which going by the naming scheme they established would be two Cortex-M3 cores with around 512k of SRAM and &quot;X&quot; onboard flash, whatever that means, as opposed to &quot;0&quot; flash (none) on the RP2040. Maybe multiple SKUs with different amounts of onboard flash this time?</div><br/><div id="41161543" class="c"><input type="checkbox" id="c-41161543" checked=""/><div class="controls bullet"><span class="by">pantalaimon</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41157067">parent</a><span>|</span><a href="#41157969">next</a><span>|</span><label class="collapse" for="c-41161543">[-]</label><label class="expand" for="c-41161543">[3 more]</label></div><br/><div class="children"><div class="content">Cortex-M3 would be an odd choice in this day and age - the core is 20 years old at this point.</div><br/><div id="41161619" class="c"><input type="checkbox" id="c-41161619" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41161543">parent</a><span>|</span><a href="#41161587">next</a><span>|</span><label class="collapse" for="c-41161619">[-]</label><label class="expand" for="c-41161619">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be perfectly happy with a low-power Cortex-M3 if it keeps the same price point as the RP2040. We all don&#x27;t need screaming fast cores and the associated price adder.</div><br/></div></div><div id="41161587" class="c"><input type="checkbox" id="c-41161587" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41161543">parent</a><span>|</span><a href="#41161619">prev</a><span>|</span><a href="#41157969">next</a><span>|</span><label class="collapse" for="c-41161587">[-]</label><label class="expand" for="c-41161587">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;3&quot; meaning M3 is an extrapolation from the first &quot;0&quot; in RP2040 meaning M0+, but if the core is that old then yeah maybe it&#x27;s something else. M33 perhaps?</div><br/></div></div></div></div><div id="41157969" class="c"><input type="checkbox" id="c-41157969" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41157067">parent</a><span>|</span><a href="#41161543">prev</a><span>|</span><a href="#41158908">next</a><span>|</span><label class="collapse" for="c-41157969">[-]</label><label class="expand" for="c-41157969">[4 more]</label></div><br/><div class="children"><div class="content">Onboard flash would be welcome. External flash makes things unnecessarily hard for beginners. You either need to investigate their complicated boot scheme and work with built-in SPI even before you can blink the led, or use their overcomplicated SDK with overcomplicated build tools. Both alternatives are terrible. I can write blink led application using few lines of assembly with STM32 and that&#x27;s how it should be.</div><br/><div id="41158905" class="c"><input type="checkbox" id="c-41158905" checked=""/><div class="controls bullet"><span class="by">jononor</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41157969">parent</a><span>|</span><a href="#41158908">next</a><span>|</span><label class="collapse" for="c-41158905">[-]</label><label class="expand" for="c-41158905">[3 more]</label></div><br/><div class="children"><div class="content">Beginners use Arduino or MicroPython. For a microcontroller SDK, picolib is also quite simple. No need to deal with the boot or SPI manually. 
But of course built in flash will be a welcomed addition :)</div><br/><div id="41160175" class="c"><input type="checkbox" id="c-41160175" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41158905">parent</a><span>|</span><a href="#41158908">next</a><span>|</span><label class="collapse" for="c-41160175">[-]</label><label class="expand" for="c-41160175">[2 more]</label></div><br/><div class="children"><div class="content">I was beginner one year ago and I didn&#x27;t use Arduino or MicroPython. I don&#x27;t even know Python and I don&#x27;t want to know it. I really liked RP2040 datasheet, it&#x27;s miles ahead of everything I&#x27;ve read so far, but this issue with inability to write simplest program without loads of bloated libraries and tools led me to STM32. Now I have some experience dealing with STM32, nRF52 chips, I learned to use UART, SPI, USB, BLE and I probably would be able to write blink program for RP2040, but I&#x27;m not a beginner anymore, I think.<p>I understand what you&#x27;re talking about, but I think it&#x27;s wrong to shoehorn beginners into one size. I, for one, prefer to start simple. Simple start for MCU is assembly code or very basic C code, linker script and programmer. Those are necessary and can&#x27;t be dismissed. Programming MCU with Python is like writing website with C. Could be done, but feels wrong.</div><br/><div id="41161149" class="c"><input type="checkbox" id="c-41161149" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41160175">parent</a><span>|</span><a href="#41158908">next</a><span>|</span><label class="collapse" for="c-41161149">[-]</label><label class="expand" for="c-41161149">[1 more]</label></div><br/><div class="children"><div class="content">I agree, the whole draw to modern mcu for me is that it resembles 80s personal computers in ram constraints. The bloated libraries run counter to that.</div><br/></div></div></div></div></div></div></div></div><div id="41158908" class="c"><input type="checkbox" id="c-41158908" checked=""/><div class="controls bullet"><span class="by">jononor</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41157067">parent</a><span>|</span><a href="#41157969">prev</a><span>|</span><a href="#41158761">next</a><span>|</span><label class="collapse" for="c-41158908">[-]</label><label class="expand" for="c-41158908">[2 more]</label></div><br/><div class="children"><div class="content">Wondering why they did not go for M4F. Probably this means they will keep the non-standard FPU which is also on the RP2040?</div><br/><div id="41159577" class="c"><input type="checkbox" id="c-41159577" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41158908">parent</a><span>|</span><a href="#41158761">next</a><span>|</span><label class="collapse" for="c-41159577">[-]</label><label class="expand" for="c-41159577">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t have an FPU in the RP2040, what they have is a collection of optimized <i>software</i> FP routines baked into the chips ROM. You can see the code here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;pico-bootrom&#x2F;blob&#x2F;master&#x2F;bootrom&#x2F;mufplib.S">https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;pico-bootrom&#x2F;blob&#x2F;master&#x2F;boot...</a></div><br/></div></div></div></div><div id="41158761" class="c"><input type="checkbox" id="c-41158761" checked=""/><div class="controls bullet"><span class="by">TaylorAlexander</span><span>|</span><a href="#41156743">root</a><span>|</span><a href="#41157067">parent</a><span>|</span><a href="#41158908">prev</a><span>|</span><a href="#41161216">next</a><span>|</span><label class="collapse" for="c-41158761">[-]</label><label class="expand" for="c-41158761">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the tip this is wonderful!</div><br/></div></div></div></div><div id="41161216" class="c"><input type="checkbox" id="c-41161216" checked=""/><div class="controls bullet"><span class="by">crest</span><span>|</span><a href="#41156743">parent</a><span>|</span><a href="#41157067">prev</a><span>|</span><a href="#41159775">next</a><span>|</span><label class="collapse" for="c-41161216">[-]</label><label class="expand" for="c-41161216">[1 more]</label></div><br/><div class="children"><div class="content">The first comes with a lot of trade-offs, but I would love to see two QSPI controllers or at least two chip select lines that can be controlled by an extra address bit. I also want the DMA engine to be able to address the SIO block to access the GPIOs and interpolators without having to &quot;tunnel&quot; through a different peripheral like PIO or PWM timers.</div><br/></div></div><div id="41159775" class="c"><input type="checkbox" id="c-41159775" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#41156743">parent</a><span>|</span><a href="#41161216">prev</a><span>|</span><a href="#41157716">next</a><span>|</span><label class="collapse" for="c-41159775">[-]</label><label class="expand" for="c-41159775">[1 more]</label></div><br/><div class="children"><div class="content">I agree, but am amazed that you didn&#x27;t include on-board flash, too. I definitely miss that in the feature set (but have barely used the RP2040 so perhaps I&#x27;m just shouting at the clouds).</div><br/></div></div></div></div><div id="41157716" class="c"><input type="checkbox" id="c-41157716" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#41156743">prev</a><span>|</span><label class="collapse" for="c-41157716">[-]</label><label class="expand" for="c-41157716">[1 more]</label></div><br/><div class="children"><div class="content">SSI is a very useful (and underdocumented!) RPi feature - it’s how socket-compatible Raspberry Pi 68k emulators work with the ~60ish latches that interface with the 68k bus.</div><br/></div></div></div></div></div></div></div></body></html>