<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710752451890" as="style"/><link rel="stylesheet" href="styles.css?v=1710752451890"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html">The return of the frame pointers</a> <span class="domain">(<a href="https://www.brendangregg.com">www.brendangregg.com</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>204 comments</span></div><br/><div><div id="39733167" class="c"><input type="checkbox" id="c-39733167" checked=""/><div class="controls bullet"><span class="by">dsign</span><span>|</span><a href="#39733170">next</a><span>|</span><label class="collapse" for="c-39733167">[-]</label><label class="expand" for="c-39733167">[5 more]</label></div><br/><div class="children"><div class="content">I remember when the omission of stack frame pointers started spreading at the beginning of the 2000s. I was in college at the time, studying computer sciences in a very poor third-world country. Our computers were old and far from powerful. So, for most course projects, we would eschew interprets and use compilers. Mind you, what my college lacked in money it compensated by having interesting course work. We studied and implemented low level data-structures, compilers, assembly-code numerical routines and even a device driver for Minix.<p>During my first two years in college, if one of our programs did something funny, I would attach gdb and see what was happening at assembly level. I got used to &quot;walking the stack&quot; manually, though the debugger often helped a lot. Happy times, until all of the sudden, &quot;-fomit-frame-pointer&quot; was all the rage, and stack traces stopped making sense. Just like that, debugging that segfault or illegal instruction became exponentially harder. A short time later, I started using Python for almost everything to avoid broken debugging sessions. So, I lost an order of magnitude or two with &quot;-fomit-frame-pointer&quot;. But learning Python served me well for other adventures.</div><br/><div id="39739257" class="c"><input type="checkbox" id="c-39739257" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#39733167">parent</a><span>|</span><a href="#39736685">next</a><span>|</span><label class="collapse" for="c-39739257">[-]</label><label class="expand" for="c-39739257">[2 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t you know about -fno-omit-frame-pointer?</div><br/><div id="39739637" class="c"><input type="checkbox" id="c-39739637" checked=""/><div class="controls bullet"><span class="by">e40</span><span>|</span><a href="#39733167">root</a><span>|</span><a href="#39739257">parent</a><span>|</span><a href="#39736685">next</a><span>|</span><label class="collapse" for="c-39739637">[-]</label><label class="expand" for="c-39739637">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps they were talking about libraries they didn’t compile, and with languages with callbacks this can be a real problem.</div><br/></div></div></div></div></div></div><div id="39733170" class="c"><input type="checkbox" id="c-39733170" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39733167">prev</a><span>|</span><a href="#39732893">next</a><span>|</span><label class="collapse" for="c-39733170">[-]</label><label class="expand" for="c-39733170">[35 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad he mentioned Fedora because it&#x27;s been a tiresome battle to keep frame pointers enabled in the whole distribution (eg <a href="https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;3084" rel="nofollow">https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;3084</a>).<p>There&#x27;s a persistent myth that frame pointers have a huge overhead, because there was a single Python case that had a +10% slow down (now fixed).  The actual measured overhead is under 1%, which is far outweighed by the benefits we&#x27;ve been able to make in certain applications.</div><br/><div id="39733904" class="c"><input type="checkbox" id="c-39733904" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39733170">parent</a><span>|</span><a href="#39734001">next</a><span>|</span><label class="collapse" for="c-39733904">[-]</label><label class="expand" for="c-39733904">[23 more]</label></div><br/><div class="children"><div class="content">I believe it&#x27;s a misrepresentation to say that &quot;actual measured overhead is under 1%&quot;. I don&#x27;t think such a claim can be universally applied because this depends on the very workload you&#x27;re measuring the overhead with.<p>FWIW your results don&#x27;t quite match the measurements from Linux kernel folks who claim that the overhead is anywhere between 5-10%. Source: <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;20170602104048.jkkzssljsompjdwy@suse.de&#x2F;T&#x2F;#u" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;20170602104048.jkkzssljsompjdwy...</a><p><pre><code>   I didn&#x27;t preserve the data involved but in a variety of workloads including netperf, page allocator microbenchmark, pgbench and sqlite, enabling framepointer introduced overhead of around the 5-10% mark.
</code></pre>
Significance in their results IMO is in the fact that they measured the impact by using PostgreSQL and SQLite. If anything, DBMS are one of the best ways to really stress out the system.</div><br/><div id="39734169" class="c"><input type="checkbox" id="c-39734169" checked=""/><div class="controls bullet"><span class="by">babel_</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733904">parent</a><span>|</span><a href="#39738028">next</a><span>|</span><label class="collapse" for="c-39734169">[-]</label><label class="expand" for="c-39734169">[11 more]</label></div><br/><div class="children"><div class="content">Those are numbers from 7 years ago, so they&#x27;re beginning to get a bit stale as people start to put more weight behind having frame pointers and make upstream contributions to their compilers to improve their output. People put it at &lt;1% from much more recent testing by the very R.W.M. Jones you&#x27;re replying to [0] and separate testing by others like Brendan Gregg [1b], whose post this is commenting on (and included [1b] in the Appendix as well), with similar accounts by others in the last couple years. Oh, and if you use flamegraph, you might want to check the repo for a familiar name.<p>Some programs, like Python, have reported worse, 2-7% [2], but there is traction on tackling that [1a] (see both rwmj&#x27;s and brendangregg&#x27;s replies to sibling comments, they&#x27;ve both done a lot of upstreamed work wrt. frame pointers, performance, and profiling).<p>As has been frequently pointed out, the benefits from improved profiling cannot be understated, even a 10% cost to having frame pointers can be well worth it when you leverage that information to target the actual bottlenecks that are eating up your cycles. Plus, you can always disable it in specific hotspots later when needed, which is much easier than the reverse.<p>Something, something, premature optimisation -- though in seriousness, this information benefits actual optimisation, exactly because we don&#x27;t have the information and understanding that would allow truly universal claims, precisely because things like this haven&#x27;t been available, and so haven&#x27;t been widely used. We know frame pointers, from additional register pressure and extended function prologue&#x2F;epilogue, can be a detriment in certain hotspots; that&#x27;s why we have granular control. But without them, we often don&#x27;t know which hotspots are actually affected, so I&#x27;m sure even the databases would benefit... though the &quot;my database is the fastest database&quot; problem has always been the result of endless micro-benchmarking, rather than actual end-to-end program performance and latency, so even a claimed &quot;10%&quot; drop there probably doesn&#x27;t impact actual real-world usage, but that&#x27;s a reason why some of the most interesting profiling work lately has been from ideas like causal profilers and continuous profilers, which answer exactly that.<p>[0]: <a href="https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2023&#x2F;02&#x2F;14&#x2F;frame-pointers-vs-dwarf-my-verdict&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2023&#x2F;02&#x2F;14&#x2F;frame-pointers-vs-dwar...</a>
[1a]: <a href="https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;2817#comment-826636" rel="nofollow">https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;2817#comment-826636</a>
[1b]: <a href="https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;2817#comment-826805" rel="nofollow">https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;2817#comment-826805</a>
[2]: <a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;the-performance-of-python-with-perf-support-is-not-great-and-is-going-to-get-a-lot-worse&#x2F;25280&#x2F;1" rel="nofollow">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;the-performance-of-python-with-...</a></div><br/><div id="39735355" class="c"><input type="checkbox" id="c-39735355" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39734169">parent</a><span>|</span><a href="#39735392">next</a><span>|</span><label class="collapse" for="c-39735355">[-]</label><label class="expand" for="c-39735355">[1 more]</label></div><br/><div class="children"><div class="content">While improved profiling is useful, achieving it by wasting a register is annoying, because it is just a very dumb solution.<p>The choice made by Intel when they have designed 8086 to use 2 separate registers for the stack pointer and for the frame pointer was a big mistake.<p>It is very easy to use a single register as both the stack pointer and the frame pointer, as it is standard for instance in IBM POWER.<p>Unfortunately in the Intel&#x2F;AMD CPUs using a single register is difficult, because the simplest implementation is unreliable since interrupts may occur between 2 instructions that must form an atomic sequence (and they may clobber the stack before new space is allocated after writing the old frame pointer value in the stack).<p>It would have been very easy to correct this in new CPUs by detecting that instruction sequence and blocking the interrupts between them.<p>Intel had already done this once early in the history of the x86 CPUs, when they have discovered a mistake in the design of the ISA, that interrupts could occur between updating the stack segment and the stack pointer. Then they had corrected this by detecting such an instruction sequence and blocking the interrupts at the boundary between those instructions.<p>The same could have been done now, to enable the use of the stack pointer as also the frame pointer. (This would be done by always saving the stack pointer in the top of the stack whenever stack space is allocated, so that the stack pointer always points to the previous frame pointer, i.e. to the start of the linked list containing all stack frames.)</div><br/></div></div><div id="39735392" class="c"><input type="checkbox" id="c-39735392" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39734169">parent</a><span>|</span><a href="#39735355">prev</a><span>|</span><a href="#39738028">next</a><span>|</span><label class="collapse" for="c-39735392">[-]</label><label class="expand" for="c-39735392">[9 more]</label></div><br/><div class="children"><div class="content">&gt; As has been frequently pointed out, the benefits from improved profiling cannot be understated, even a 10% cost to having frame pointers can be well worth it when you leverage that information to target the actual bottlenecks that are eating up your cycles.<p>Few can leverage that information because the open source software you are talking about lacks telemetry in the self hosted case.<p>The profiling issue really comes down to the cultural opposition in these communities to collecting telemetry and opening it for anyone to see and use. The average user struggles to ally with a trustworthy actor who will share the information like profiling freely and anonymize it at a per-user level, the level that is actually useful. Such things exist, like the Linux hardware site, but only because they have not attracted the attention of agitators.<p>Basically users are okay with profiling, so long as it is quietly done by Amazon or Microsoft or Google, and not by the guy actually writing the code and giving it out for everyone to use for free. It’s one of the most moronic cultural trends, and blame can be put squarely on product growth grifters who equivocate telemetry with privacy violations; open source maintainers, who have enough responsibilities as is, besides educating their users; and Apple, who have made their essentially vaporous claims about privacy a central part of their brand.<p>Of course people know the answer to your question. Why doesn’t Google publish every profile of every piece of open source software? What exactly is sensitive about their workloads? Meta publishes a whole library about every single one of its customers, for anyone to freely read. I don’t buy into the holiness of the backend developer’s “cleverness” or whatever is deemed sensitive, and it’s so hypocritical.</div><br/><div id="39736822" class="c"><input type="checkbox" id="c-39736822" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39735392">parent</a><span>|</span><a href="#39737552">next</a><span>|</span><label class="collapse" for="c-39736822">[-]</label><label class="expand" for="c-39736822">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Basically users are okay with profiling, so long as it is quietly done by Amazon or Microsoft or Google, and not by the guy actually writing the code and giving it out for everyone to use for free.<p>No; the groups are approximately &quot;cares whether software respects the user, including privacy&quot;, or &quot;doesn&#x27;t know or doesn&#x27;t care&quot;. I seriously doubt that any meaningful number of people are okay with companies invading their privacy but not smaller projects.</div><br/></div></div><div id="39737552" class="c"><input type="checkbox" id="c-39737552" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39735392">parent</a><span>|</span><a href="#39736822">prev</a><span>|</span><a href="#39737269">next</a><span>|</span><label class="collapse" for="c-39737552">[-]</label><label class="expand" for="c-39737552">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Agitators&quot;. We don&#x27;t trust telemetry precisely because of comments like that. World is full of people like you who apparently see absolutely nothing wrong with exfiltrating identifying information from other people&#x27;s computers. We have to actively resist such attempts, they are constant, never ending and it only seems to get worse over time but you dismiss it all as &quot;cultural opposition&quot; to telemetry.<p>For the record I&#x27;m NOT OK with being profiled, measured or otherwise studied in any way without my explicit consent. That even extends to the unethical human experiments that corporations run on people and which they euphemistically call A&#x2F;B tests. I don&#x27;t care if it&#x27;s Google or a hobbyist developer, I will block it if I can and I will not lose a second of sleep over it.</div><br/><div id="39738127" class="c"><input type="checkbox" id="c-39738127" checked=""/><div class="controls bullet"><span class="by">rstuart4133</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39737552">parent</a><span>|</span><a href="#39737269">next</a><span>|</span><label class="collapse" for="c-39738127">[-]</label><label class="expand" for="c-39738127">[2 more]</label></div><br/><div class="children"><div class="content">&gt; World is full of people like you who apparently see absolutely nothing wrong with exfiltrating identifying information from other people&#x27;s computers.<p>True.  But such people are like cockroaches.  They know what they are doing will be unpopular with their targets, so they keep it hidden.  This is easy enough to do in closed designs, car manufacturers selling your driving habits to insurance companies and health monitoring app selling menstrual cycle data to retailers selling to women.<p>Compare that do say Debian and RedHat.  They too collect performance data.  But the code is open source, Debian has repeatable builds so you can be 100% sure that is the code in use, and every so often someone takes a look it.  Guess what, the data they send back is so unidentifiable it satisfies even the most paranoid of their 1000&#x27;s of members.<p>All it takes is a little bit of sunlight to keep the cockroaches at bay, and then we can safely let the devs collect the data they need to improve code.  And everyone benefits.</div><br/><div id="39739511" class="c"><input type="checkbox" id="c-39739511" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39738127">parent</a><span>|</span><a href="#39737269">next</a><span>|</span><label class="collapse" for="c-39739511">[-]</label><label class="expand" for="c-39739511">[1 more]</label></div><br/><div class="children"><div class="content">I fully support the schemes for telemetry that already happens. It’s just obnoxious that there’s no apparent reason behind the support of one kind of anonymous telemetry versus another. For every 1 person who digests the package repo’s explanation of the telemetry strategy, there are 19 who feel okay with GitHub having all the telemetry and none of the open source repos they host because of vibes.</div><br/></div></div></div></div></div></div><div id="39737269" class="c"><input type="checkbox" id="c-39737269" checked=""/><div class="controls bullet"><span class="by">babel_</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39735392">parent</a><span>|</span><a href="#39737552">prev</a><span>|</span><a href="#39738028">next</a><span>|</span><label class="collapse" for="c-39737269">[-]</label><label class="expand" for="c-39737269">[4 more]</label></div><br/><div class="children"><div class="content">I think the kind of profiling information you&#x27;re imagining is a little different from what I am.<p>Continuous profiling of your system that gets relayed to someone else by telemetry is very different from continuous profiling of your own system, handled only by yourself (or, generalising, your community&#x2F;group&#x2F;company). You seem to be imagining we&#x27;re operating more in the former, whereas I am imagining more in the latter.<p>When it&#x27;s our own system, better instrumented for our own uses, and we&#x27;re the only ones getting the information, then there&#x27;s nothing to worry about, and we can get much more meaningful and informative profiling done when more information about the system is available. I don&#x27;t even need telemetry. When it&#x27;s &quot;someone else&#x27;s&quot; system, in other words, when we have no say in telemetry (or have to exercise a right to opt-out, rather than a more self-executing contract around opt-in), then we start to have exactly the kinds of issues you&#x27;re envisaging.<p>When it&#x27;s not completely out of our hands, then we need to recognise different users, different demands, different contexts. Catering to the user matters, and when it comes to sensitive information, well, people have different priorities and threat models.<p>If I&#x27;m opening a calendar on my phone, I don&#x27;t expect it to be heavily instrumented and relaying all of that, I just want to see my calendar. When I open a calendar on my phone, and it is unreasonably slow, then I might want to submit relevant telemetry back in some capacity. Meanwhile, if I&#x27;m running the calendar server, I&#x27;m absolutely wanting to have all my instrumentation available and recording every morsel I reasonably can about that server, otherwise improving it or fixing it becomes much harder.<p>From the other side, if I&#x27;m running the server, I may <i>want</i> telemetry from users, but if it&#x27;s not essential, then I can &quot;make do&quot; with only the occasional opt-in telemetry. I also have other means of profiling real usage, not just scooping it all up from unknowing users (or begrudging users). Those often have some other &quot;cost&quot;, but in turn, they don&#x27;t have the &quot;cost&quot; of demanding it from users. For people to freely choose requires acknowledging the asymmetries present, and that means we can&#x27;t just take the path of least resistance, as we may have to pay for it later.<p>In short, it&#x27;s a consent issue. Many violate that, knowingly, because they care not for the consequences. Many others don&#x27;t even seem to think about it, and just go ahead regardless. And it&#x27;s so much easier behind closed doors. Open source in comparison, even if not everything is public, must contend with the fact that the actions and consequences are (PRs, telemetry traffic, etc), so it inhabits a space in which violating consent is much more easily held accountable (though no guarantee).<p>Of course, this does not mean it&#x27;s always done properly in open source. It&#x27;s often an uphill battle to get telemetry that&#x27;s off-by-default, where users explicitly consent via opt-in, as people see how that could easily be undermined, or later invalidated. Many opt-in mechanisms (e.g. a toggle in the settings menu) often do not have expiration built in, so fail to check at a later point that someone still consents. Not to say that&#x27;s the way you must do it, just giving an example of a way that people seem to be more in favour of, as with the generally favourable response to such features making their way into &quot;permissions&quot; on mobile.<p>We can see how the suspicion creeps in, informed by experience... but that&#x27;s also known by another word: vigilance.<p>So, users are not &quot;okay&quot; with it. There&#x27;s a power imbalance where these companies are afforded the impunity because many are left to conclude they have no choice but to let them get away with it. That hasn&#x27;t formed in a vacuum, and it&#x27;s not so simple that we just pull back the curtain and reveal the wizard for what he is. Most seem to already know.<p>It&#x27;s proven extremely difficult to push alternatives. One reason is that information is frequently not ready-to-hand for more typical users, but another is that said alternatives may not actually fulfil the needs of some users: notably, accessibility remains hugely inconsistent in open source, and is usually not funded on par with, say, projects that affect &quot;backend&quot; performance.<p>The result? Many people just give their grandma an iPhone. That&#x27;s what&#x27;s telling about the state of open source, and of the actual cultural trends that made it this way. The threat model is fraudsters and scammers, not nation-state actors or corporate malfeasance. This app has tons of profiling and privacy issues? So what? At least grandma can use it, and we can stay in contact, dealing with the very real cultural trends towards isolation. On a certain level, it&#x27;s just pragmatic. They&#x27;d choose differently if they could, but they don&#x27;t feel like they can, and they&#x27;ve got bigger worries.<p>Unless we <i>do</i> different, the status quo will remain. If there&#x27;s any agitation to be had, it&#x27;s in getting more people to care about improving things and then actually doing them, even if it&#x27;s just taking small steps. There won&#x27;t be a perfect solution that appears out of nowhere tomorrow, but we only have a low bar to clear. Besides, we&#x27;ve all thought &quot;I could do better than that&quot;, so why not? Why not just aim for better?<p>Who knows, we might actually achieve it.</div><br/><div id="39739540" class="c"><input type="checkbox" id="c-39739540" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39737269">parent</a><span>|</span><a href="#39738028">next</a><span>|</span><label class="collapse" for="c-39739540">[-]</label><label class="expand" for="c-39739540">[3 more]</label></div><br/><div class="children"><div class="content">Telemetry is an essential piece of much software, especially of engineering innovation focused software.<p>I love Pion for example. Both it and libwebrtc are open source in most ways that matter. However Google Chrome collects telemetry that the libwebrtc developers can use that isn’t even useful to the Pion team, even if it were shared which it is not. That telemetry is why libwebrtc is adopted by Mobile Safari and Firefox too, and therefore is the only standard for WebRTC that matters, and also why it will forever have fewer bugs than Pion, even though the Pion developers are truthfully brilliant and hard working people.<p>Could Pion convince its users to enable the same level of telemetry Google Chrome gets? No chance. I think this is a huge shame. It has nothing to do with consent. They consented, they let google chrome do this. Why not Pion? I agree that they won’t consent but that doesn’t make sense.</div><br/><div id="39740093" class="c"><input type="checkbox" id="c-39740093" checked=""/><div class="controls bullet"><span class="by">babel_</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39739540">parent</a><span>|</span><a href="#39738028">next</a><span>|</span><label class="collapse" for="c-39740093">[-]</label><label class="expand" for="c-39740093">[2 more]</label></div><br/><div class="children"><div class="content">Telemetry is exceedingly useful, and it&#x27;s basically a guaranteed boon when you operate your own systems. But telemetry isn&#x27;t essential, and it&#x27;s not the heart of the matter I was addressing. Again, the crux of this is consent, as an imbalance of power easily distorts the nature of consent.<p>Suppose Chrome added new telemetry, for example, like it did when WebRTC was added in Chrome 28, so we really can just track this against something we&#x27;re all familiar (enough with). When a user clicks &quot;Update&quot;, or it auto-updated and &quot;seamlessly&quot; switched version in the background &#x2F; between launches, well, did the user consent to the newly added telemetry?<p>Perhaps most importantly: did they even know? After all, the headline feature of Chrome 28 was Blink, not some feature that had only really been shown off in a few demos, and was still a little while away from mass adoption. No reporting on Chrome 28 that I could find from the time even mentions WebRTC, despite entire separate articles going out just based on seeing WebRTC demos! Notifications got more<p>So, capabilities to alter software like this are, knowingly or unknowingly, undermine the nature of consent that many find implicit in downloading a browser, since what you download and what you end up using may be two very different things.<p>Now, let&#x27;s consider a second imbalance. Did you even download Chrome? Most Android devices often have it preinstalled, or some similar &quot;open-core&quot; browser (often a Chromium-derivative). Some are even protected from being uninstalled, so you can&#x27;t opt out that way, and Apple only just had to open up iOS to non-Safari backed browsers.<p>So the notion of consent via the choice to install is easily undermined.<p>Lastly, because we really could go on all day with examples, what about when you do use it? Didn&#x27;t you consent then?<p>Well, they may try to onboard you, and have you pretend to read some EULA, or just have it linked and give up the charade. If you don&#x27;t tick the box for &quot;I read and agree to this EULA&quot;, you don&#x27;t progress. Of course, this is hardly a robust system. Enforceability aside, the moment you had it over to someone else to look at a webpage, did they consent to the same EULA you did?<p>... Basically, all the &quot;default&quot; ways to consider consent are nebulous, potentially non-binding, and may be self-defeating. After all, you generally don&#x27;t consent to every single line of code, every single feature, and so on, you are usually assumed to consent to the entire thing or nothing. Granularity with permissions has improved that somewhat, but there is usually still a bulk core you must accept before everything else; otherwise the software is usually kept in a non-functional state.<p>I&#x27;m not focused too specifically on Chrome here, but rather the broad patterns of how user consent typically assumed in software don&#x27;t quite pan out as is often claimed. Was that telemetry the specific reason why libwebrtc was adopted by others? I&#x27;m not privy to the conversations that occurred with these decisions, but I imagine it&#x27;s more one factor among many (not to mention, Pion is in&#x2F;for Go, which was only 4 years old then, and the pion git repo only goes back to 2018). People were excited out of the gate, and libwebrtc being available (and C++) would have kept them in-step (all had support within 2013). But, again, really this is nothing to do with the actual topic at hand, so let&#x27;s not get distracted.<p>The user has no opportunity to meaningfully consent to this. Ask most people about these things, and they wouldn&#x27;t even recognise the features by now (as WebRTC or whatever is ubiquitous), let alone any mechanisms they may have to control how it engages with them.<p>Yet, the onus is put on the user. Why do we not ask about anything&#x2F;anyone else in the equation, or consider what influences the user?<p>A recent example I think illustrates the imbalance and how it affects and warps consent is the recent snafu with a vending machine with limited facial recognition capabilities. In other words, the vending machine had a camera, ostensibly to know when to turn on or not and save power. When this got noticed at a university, it was removed, and everyone made a huge fuss, as they had not consented to this!<p>What I&#x27;d like to put in juxtaposition with that is how, in all likelihood, this vending machine was probably being monitored by CCTV, and even if not, that there is certainly CCTV at the university, and nearby, and everywhere else for that matter.<p>So what changed? The scale. CCTV everywhere does not feel like something you can, individually, do anything about; the imbalance of power is such that you have no recourse if you did not consent to it. A single vending machine? That scale and imbalance has shifted, it&#x27;s now one machine, not put in place by your established security contracts, and not something ubiquitous. It&#x27;s also something easily sabotaged without clear consequence (students at the university covered the cameras of it quite promptly upon realising), ironically, perhaps, given that this was not their own property and potentially in clear view of CCTV, but despite having all the same qualities as CCTV, the context it embedded in was such that they took action against it.<p>This is the difference between Chrome demanding user consent and someone else asking for it. When the imbalance of power is against you, even just being asked feels like being demanded, whereas when it doesn&#x27;t quite feel that way, well, users often take a chance to prevent such an imbalance forming, and so work against something that may (in the case of some telemetry) actually be in their favour. However, part and parcel with meeting user needs is respecting their own desires -- as some say, the customer is always right in matters of taste.<p>To re-iterate myself from before, there are other ways of getting profiling information, or anything you might relay via telemetry, that do not have to conform to the Google&#x2F;Meta&#x2F;Amazon&#x2F;Microsoft&#x2F;etc model of user consent. They choose the way they do because, to them, it&#x27;s the most efficient way. At their scale, they get the benefits of ubiquitous presence and leverage of the imbalance of power, and so what you view as your system, they view as theirs, altering with impunity, backed by enough power to prevent many taking meaningful action to the contrary.<p>For the rest of us, however, that might just be the wrong way to go about it. If we&#x27;re trying to avoid all the nightmares that such companies have wrought, and to do it right by one another, then the first step is to evaluate how we engage with users, what the relationship (&quot;contract&quot;) we intend to form is, and how we might inspire mutual respect.<p>In ethical user studies, users are remunerated for their participation, and must explicitly give knowing consent, with the ability to withdraw at any time. Online, they&#x27;re continually A&#x2F;B tested, frequently without consent. On one hand, the user is placed in control, informed, and provided with the affordances and impunity to consent entirely according to their own will and discretion. On the other, the user is controlled, their agency taken away by the impunity of another, often without the awareness that this is ongoing, or that they might have been able to leverage consent (and often ignored even if they did, after all, it&#x27;s easy to do so when you hold the power). I know which I&#x27;d rather be on the other end of, at least personally speaking.<p>So, if we want to enable telemetry, or other approaches to collaborating with users to improve our software, then we need to do just that. Collaborate. Rethink how we engage, respect them, respect their consent. It&#x27;s not just that we can&#x27;t replicate Google, but that maybe we shouldn&#x27;t, maybe that approach is what&#x27;s poisoned the well for others wanting to use it, and what&#x27;s forcing us to try something else. Maybe not, after all, that&#x27;s not for us to judge at this point, it&#x27;s only with hindsight that we might truly know. Either way, I think there&#x27;s some chance for people to come in, make something that actually fits with people, something that regards them as a person, not simply a user, and respects their consent. Stuff like that might start to shift the needle, not by trying to replace Google or libwebrtc or whatever and get the next billion users, but by paving a way and meeting the needs of those who need it, even if it&#x27;s just a handful of customers or even just friends and family. Who knows, we might start solving some of the problems we&#x27;re all complaining about yet never seem to fix. At the very least, it feels like a breath of fresh air.</div><br/><div id="39740261" class="c"><input type="checkbox" id="c-39740261" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39740093">parent</a><span>|</span><a href="#39738028">next</a><span>|</span><label class="collapse" for="c-39740261">[-]</label><label class="expand" for="c-39740261">[1 more]</label></div><br/><div class="children"><div class="content">You’re agreeing with me.<p>&gt; Rethink how we engage, respect them, respect their consent.<p>One way to characterize this is leadership. Most open source software authors are terrible leaders!<p>You’re way too polite. Brother, who is making a mistake and deserves blame? Users? Open source non corporate software maintainers? Google employees? Someone does. It can’t be “we.” I don’t make any of these mistakes, leave me out of it! I tell every non corporate open source maintainer to add basic anonymized telemetry, PR a specific opt-out solution with my preferred Plausible, and argue relentlessly with users to probe the vapors they base their telemetry fears on. We’re both trying to engage on the issue, but the average HN reader is downvoting me. Because “vibes.” Vibes are dumb! Just don’t be afraid to say it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39733926" class="c"><input type="checkbox" id="c-39733926" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733904">parent</a><span>|</span><a href="#39738028">prev</a><span>|</span><a href="#39734173">next</a><span>|</span><label class="collapse" for="c-39733926">[-]</label><label class="expand" for="c-39733926">[8 more]</label></div><br/><div class="children"><div class="content">Those are microbenchmarks.</div><br/><div id="39733939" class="c"><input type="checkbox" id="c-39733939" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733926">parent</a><span>|</span><a href="#39734173">next</a><span>|</span><label class="collapse" for="c-39733939">[-]</label><label class="expand" for="c-39733939">[7 more]</label></div><br/><div class="children"><div class="content">pgbench is not a microbenchmark.</div><br/><div id="39733999" class="c"><input type="checkbox" id="c-39733999" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733939">parent</a><span>|</span><a href="#39734173">next</a><span>|</span><label class="collapse" for="c-39733999">[-]</label><label class="expand" for="c-39733999">[6 more]</label></div><br/><div class="children"><div class="content">From the docs: &quot;pgbench is a simple program for running benchmark tests on PostgreSQL. It runs the same sequence of SQL commands over and over&quot;<p>While it might call itself a benchmark, it behaves very microbenchmark-y.<p>The other numbers I and others have shared have been from actual production workloads. Not a simple program that tests same sequence of commands over and over.</div><br/><div id="39734421" class="c"><input type="checkbox" id="c-39734421" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733999">parent</a><span>|</span><a href="#39735091">next</a><span>|</span><label class="collapse" for="c-39734421">[-]</label><label class="expand" for="c-39734421">[1 more]</label></div><br/><div class="children"><div class="content">While pgbench might be &quot;simple&quot; program, as in a test-runner, workloads that are run by it are far from it. It runs TPC-B by default but can also run your own arbitrary script that defines whatever the workload is? It also allows to run queries concurrently so I fail to understand the reasoning of it &quot;being simple&quot; or &quot;microbenchmarkey&quot;. It&#x27;s far from the truth I think.</div><br/></div></div><div id="39735091" class="c"><input type="checkbox" id="c-39735091" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733999">parent</a><span>|</span><a href="#39734421">prev</a><span>|</span><a href="#39736807">next</a><span>|</span><label class="collapse" for="c-39735091">[-]</label><label class="expand" for="c-39735091">[3 more]</label></div><br/><div class="children"><div class="content">Anything running a full database server is not micro.</div><br/><div id="39738786" class="c"><input type="checkbox" id="c-39738786" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39735091">parent</a><span>|</span><a href="#39736807">next</a><span>|</span><label class="collapse" for="c-39738786">[-]</label><label class="expand" for="c-39738786">[2 more]</label></div><br/><div class="children"><div class="content">If I call the same &quot;get statistics&quot; command over and over in a loop (with zero queries), or 100% the same invalid query (to test the error path performance), I believe we&#x27;d call that a micro-benchmark, despite involving a full database. It&#x27;s a completely unrealistic artificial workload to test a particular type of operation.<p>The pgbench docs make it sound microbenchmark-y by describing making the same call over and over. If people find that this simulates actual production workloads, then yes, it can be considered a macro-benchmark.</div><br/><div id="39741514" class="c"><input type="checkbox" id="c-39741514" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39738786">parent</a><span>|</span><a href="#39736807">next</a><span>|</span><label class="collapse" for="c-39741514">[-]</label><label class="expand" for="c-39741514">[1 more]</label></div><br/><div class="children"><div class="content">&quot;get statistics&quot; is not what TPC-B does. Nor the invalid queries nor ...<p>From <a href="https:&#x2F;&#x2F;www.tpc.org&#x2F;tpcb&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tpc.org&#x2F;tpcb&#x2F;</a>, a TPC-B workload that pgbench runs by default:<p><pre><code>    In August 1990, the TPC approved its second benchmark, TPC-B. In contrast to TPC-A, TPC-B is not an OLTP benchmark. Rather, TPC-B can be looked at as a database stress test, characterized by:

      Significant disk input&#x2F;output
      Moderate system and application execution time
      Transaction integrity

    TPC-B measures throughput in terms of how many transactions per second a system can perform. Because there are substantial differences between the two benchmarks (OLTP vs. database stress test), TPC-B results cannot be compared to TPC-A.

    ...

    Transactions are submitted by programs all executing concurrently.</code></pre></div><br/></div></div></div></div></div></div><div id="39736807" class="c"><input type="checkbox" id="c-39736807" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733999">parent</a><span>|</span><a href="#39735091">prev</a><span>|</span><a href="#39734173">next</a><span>|</span><label class="collapse" for="c-39736807">[-]</label><label class="expand" for="c-39736807">[1 more]</label></div><br/><div class="children"><div class="content">The are loads of real world workloads that have similar patterns to pgbench, particularly read only pgbench.</div><br/></div></div></div></div></div></div></div></div><div id="39734173" class="c"><input type="checkbox" id="c-39734173" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733904">parent</a><span>|</span><a href="#39733926">prev</a><span>|</span><a href="#39734001">next</a><span>|</span><label class="collapse" for="c-39734173">[-]</label><label class="expand" for="c-39734173">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t an argument for a default.</div><br/><div id="39734454" class="c"><input type="checkbox" id="c-39734454" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39734173">parent</a><span>|</span><a href="#39734001">next</a><span>|</span><label class="collapse" for="c-39734454">[-]</label><label class="expand" for="c-39734454">[1 more]</label></div><br/><div class="children"><div class="content">I was not even trying to make one. I was questioning the validity of &quot;1% overhead&quot; claim by providing the counter-example from respectable source.</div><br/></div></div></div></div></div></div><div id="39734001" class="c"><input type="checkbox" id="c-39734001" checked=""/><div class="controls bullet"><span class="by">edwintorok</span><span>|</span><a href="#39733170">parent</a><span>|</span><a href="#39733904">prev</a><span>|</span><a href="#39734826">next</a><span>|</span><label class="collapse" for="c-39734001">[-]</label><label class="expand" for="c-39734001">[3 more]</label></div><br/><div class="children"><div class="content">You probably already know, but with OCaml 5 the only way to get flamegraphs working is to either:<p>* use framepointers [1]<p>* use LBR (but LBR has a limited depth, and may not work on on all CPUs, I&#x27;m assuming due to bugs in perf)<p>* implement some deep changes in how perf works to handle the 2 stacks in OCaml (I don&#x27;t even know if this would be possible), or write&#x2F;adapt some eBPF code to do it<p>OCaml 5 has a separate stack for OCaml code and C code, and although GDB can link them based on DWARF info, perf DWARF call-graphs cannot (<a href="https:&#x2F;&#x2F;github.com&#x2F;ocaml&#x2F;ocaml&#x2F;issues&#x2F;12563#issuecomment-1932999879">https:&#x2F;&#x2F;github.com&#x2F;ocaml&#x2F;ocaml&#x2F;issues&#x2F;12563#issuecomment-193...</a>)<p>If you need more evidence to keep it enabled in future releases, you can use OCaml 5 as an example (unfortunately there aren&#x27;t many OCaml applications, so that may not carry too much weight on its own).<p>[1]: I haven&#x27;t actually realised that Fedora39 has already enabled FP by default, nice! (I still do most of my day-to-day profiling on an ~CentOS 7 system with &#x27;perf record --call-graph dwarf -F 47 -a&#x27;, I was aware that there was a discussion to enable FP by default, but haven&#x27;t noticed it has actually been done already)</div><br/><div id="39735592" class="c"><input type="checkbox" id="c-39735592" checked=""/><div class="controls bullet"><span class="by">namibj</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39734001">parent</a><span>|</span><a href="#39734826">next</a><span>|</span><label class="collapse" for="c-39735592">[-]</label><label class="expand" for="c-39735592">[2 more]</label></div><br/><div class="children"><div class="content">No, LBR is an Intel-only feature.</div><br/><div id="39739387" class="c"><input type="checkbox" id="c-39739387" checked=""/><div class="controls bullet"><span class="by">edwintorok</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39735592">parent</a><span>|</span><a href="#39734826">next</a><span>|</span><label class="collapse" for="c-39739387">[-]</label><label class="expand" for="c-39739387">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;AMD-Zen-4-LbrExtV2" rel="nofollow">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;AMD-Zen-4-LbrExtV2</a> LBR is supposed to work on AMD too, except it doesn&#x27;t. I&#x27;ll have to open a bug report (it records the data, it just can&#x27;t parse it afterwards)</div><br/></div></div></div></div></div></div><div id="39734826" class="c"><input type="checkbox" id="c-39734826" checked=""/><div class="controls bullet"><span class="by">awaythrow999</span><span>|</span><a href="#39733170">parent</a><span>|</span><a href="#39734001">prev</a><span>|</span><a href="#39733677">next</a><span>|</span><label class="collapse" for="c-39734826">[-]</label><label class="expand" for="c-39734826">[5 more]</label></div><br/><div class="children"><div class="content">Frame pointers are still a no-go on 32bit so anything that is IoT today.<p>The reason we removed them was not a myth but comes from the pre-64 bit days. Not that long ago actually.<p>Even today if you want to repurpose older 64 bit systems with a new life then this of optimization still makes sense.<p>Ideally it should be the default also for security critical systems because not everything needs to be optimized for &quot;observability&quot;</div><br/><div id="39734843" class="c"><input type="checkbox" id="c-39734843" checked=""/><div class="controls bullet"><span class="by">Narishma</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39734826">parent</a><span>|</span><a href="#39733677">next</a><span>|</span><label class="collapse" for="c-39734843">[-]</label><label class="expand" for="c-39734843">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  Frame pointers are still a no-go on 32bit so anything that is IoT today.<p>Isn&#x27;t that just 32-bit x86, which isn&#x27;t used in IoT? The other 32-bit ISAs aren&#x27;t register-starved like x86.</div><br/><div id="39735149" class="c"><input type="checkbox" id="c-39735149" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39734843">parent</a><span>|</span><a href="#39733677">next</a><span>|</span><label class="collapse" for="c-39735149">[-]</label><label class="expand" for="c-39735149">[3 more]</label></div><br/><div class="children"><div class="content">It would be, yes. x86 had very few registers, so anything you could do to free them up was vital. Arm 32bit has 32 general purpose registers I think, and RISC V certainly does. In fact there&#x27;s no difference between 32 and 64 bit in that respect. If anything, 64-bit frame pointers make it marginally worse.</div><br/><div id="39735342" class="c"><input type="checkbox" id="c-39735342" checked=""/><div class="controls bullet"><span class="by">CountSessine</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39735149">parent</a><span>|</span><a href="#39733677">next</a><span>|</span><label class="collapse" for="c-39735342">[-]</label><label class="expand" for="c-39735342">[2 more]</label></div><br/><div class="children"><div class="content">Sadly, no. 32-bit ARM only has 16 GPR’s (two of which are zero and link), mostly because of the stupid predication bits in the instruction encoding.<p>That said, I don’t know how valuable getting rid of FP on ARM is - I once benchmarked ffmpeg on 32-bit x86 before and after enabling FP and PIC (basically removing 2 GPRs) and the difference was huge (&gt;10%) but that’s an extreme example.</div><br/><div id="39736418" class="c"><input type="checkbox" id="c-39736418" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39735342">parent</a><span>|</span><a href="#39733677">next</a><span>|</span><label class="collapse" for="c-39736418">[-]</label><label class="expand" for="c-39736418">[1 more]</label></div><br/><div class="children"><div class="content">Arm32 doesn’t have a zero-value register. Its non-general-purpose registers are PC, LR, SP, FP – tho the link register can be used for temporary values.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39733677" class="c"><input type="checkbox" id="c-39733677" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#39733170">parent</a><span>|</span><a href="#39734826">prev</a><span>|</span><a href="#39732893">next</a><span>|</span><label class="collapse" for="c-39733677">[-]</label><label class="expand" for="c-39733677">[3 more]</label></div><br/><div class="children"><div class="content">Thanks; what was the Python fix?</div><br/><div id="39733773" class="c"><input type="checkbox" id="c-39733773" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733677">parent</a><span>|</span><a href="#39732893">next</a><span>|</span><label class="collapse" for="c-39733773">[-]</label><label class="expand" for="c-39733773">[2 more]</label></div><br/><div class="children"><div class="content">This was the investigation: <a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;python-3-11-performance-with-frame-pointers&#x2F;22507" rel="nofollow">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;python-3-11-performance-with-fr...</a><p>Initially we just turned off frame pointers for the Python 3.9 interpreter in Fedora.    They are back on in Python 3.12 where it seems the upstream bug has been fixed, although I can&#x27;t find the actual fix right now.<p>Fedora tracking bug: <a href="https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;2158729" rel="nofollow">https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;2158729</a><p>Fedora change in Python 3.9 to disable frame pointers: <a href="https:&#x2F;&#x2F;src.fedoraproject.org&#x2F;rpms&#x2F;python3.9&#x2F;c&#x2F;9b71f8369141c1840c8d87db1655fcefc576ddff?branch=rawhide" rel="nofollow">https:&#x2F;&#x2F;src.fedoraproject.org&#x2F;rpms&#x2F;python3.9&#x2F;c&#x2F;9b71f8369141c...</a></div><br/><div id="39733955" class="c"><input type="checkbox" id="c-39733955" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#39733170">root</a><span>|</span><a href="#39733773">parent</a><span>|</span><a href="#39732893">next</a><span>|</span><label class="collapse" for="c-39733955">[-]</label><label class="expand" for="c-39733955">[1 more]</label></div><br/><div class="children"><div class="content">Ah right, thanks, I remember I saw Andrii&#x27;s analysis in the other thread. <a href="https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;2817#comment-826636" rel="nofollow">https:&#x2F;&#x2F;pagure.io&#x2F;fesco&#x2F;issue&#x2F;2817#comment-826636</a></div><br/></div></div></div></div></div></div></div></div><div id="39732893" class="c"><input type="checkbox" id="c-39732893" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39733170">prev</a><span>|</span><a href="#39731989">next</a><span>|</span><label class="collapse" for="c-39732893">[-]</label><label class="expand" for="c-39732893">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one thing Apple did do right on ARM:<p>&gt; The frame pointer register (x29) must always address a valid frame record. Some functions — such as leaf functions or tail calls — may opt not to create an entry in this list. As a result, stack traces are always meaningful, even without debug information.<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;xcode&#x2F;writing-arm64-code-for-apple-platforms" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;xcode&#x2F;writing-arm6...</a></div><br/><div id="39733499" class="c"><input type="checkbox" id="c-39733499" checked=""/><div class="controls bullet"><span class="by">microtherion</span><span>|</span><a href="#39732893">parent</a><span>|</span><a href="#39731989">next</a><span>|</span><label class="collapse" for="c-39733499">[-]</label><label class="expand" for="c-39733499">[3 more]</label></div><br/><div class="children"><div class="content">On Apple platforms, there is often an interpretability problem of another kind: Because of the prevalence of deeply nested blocks &#x2F; closures, backtraces for Objective C &#x2F; Swift apps are often spread across numerous threads. I don&#x27;t know of a good solution for that yet.</div><br/><div id="39733850" class="c"><input type="checkbox" id="c-39733850" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#39732893">root</a><span>|</span><a href="#39733499">parent</a><span>|</span><a href="#39731989">next</a><span>|</span><label class="collapse" for="c-39733850">[-]</label><label class="expand" for="c-39733850">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not very familiar with Objective C and Swift, so this might not make sense. But JS used to have a similar problem with async&#x2F;await. The v8 engine solved it by walking the chain of JS promises to recover the &quot;logical stack&quot; developers are interested in [1].<p>[1] <a href="https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;fast-async" rel="nofollow">https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;fast-async</a></div><br/><div id="39734913" class="c"><input type="checkbox" id="c-39734913" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#39732893">root</a><span>|</span><a href="#39733850">parent</a><span>|</span><a href="#39731989">next</a><span>|</span><label class="collapse" for="c-39734913">[-]</label><label class="expand" for="c-39734913">[1 more]</label></div><br/><div class="children"><div class="content">Swift concurrency does a similar thing. For the older dispatch blocks, Xcode injects a library that records backtraces over thread hops.</div><br/></div></div></div></div></div></div></div></div><div id="39731989" class="c"><input type="checkbox" id="c-39731989" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39732893">prev</a><span>|</span><a href="#39735457">next</a><span>|</span><label class="collapse" for="c-39731989">[-]</label><label class="expand" for="c-39731989">[39 more]</label></div><br/><div class="children"><div class="content">I was at Google in 2005 on the other side of the argument. My view back then was simple:<p>Even if $BIG_COMPANY makes a decision to compile everything with frame pointers, the rest of the community is not. So we&#x27;ll be stuck fighting an unwinnable argument with a much larger community. Turns out that it was a ~20 year argument.<p>I ended up writing some patches to make libunwind work for gperftools and maintained libunwind for some number of years as a consequence of that work.<p>Having moved on to other areas of computing, I&#x27;m now a passive observer. But it&#x27;s fascinating to read history from the other perspective.</div><br/><div id="39732079" class="c"><input type="checkbox" id="c-39732079" checked=""/><div class="controls bullet"><span class="by">starspangled</span><span>|</span><a href="#39731989">parent</a><span>|</span><a href="#39735694">next</a><span>|</span><label class="collapse" for="c-39732079">[-]</label><label class="expand" for="c-39732079">[21 more]</label></div><br/><div class="children"><div class="content">&gt; So we&#x27;ll be stuck fighting an unwinnable argument with a much larger community.<p>In what way would you be stuck? What functional problems does <i>adding</i> frame pointers introduce?</div><br/><div id="39733185" class="c"><input type="checkbox" id="c-39733185" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732079">parent</a><span>|</span><a href="#39732211">next</a><span>|</span><label class="collapse" for="c-39733185">[-]</label><label class="expand" for="c-39733185">[1 more]</label></div><br/><div class="children"><div class="content">You do get occasional regressions.  eg. We found an extremely obscure bug involving enabling frame pointers, valgrind, glibc ifuncs and inlining (all at the same time):<p><a href="https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2267598" rel="nofollow">https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2267598</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;tukaani-project&#x2F;xz&#x2F;commit&#x2F;82ecc538193b380a21622aea02b0ba078e7ade92">https:&#x2F;&#x2F;github.com&#x2F;tukaani-project&#x2F;xz&#x2F;commit&#x2F;82ecc538193b380...</a></div><br/></div></div><div id="39732211" class="c"><input type="checkbox" id="c-39732211" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732079">parent</a><span>|</span><a href="#39733185">prev</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39732211">[-]</label><label class="expand" for="c-39732211">[7 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t talking about functional problems. It was a simple observation that big companies were not going to convince Linux distributors to add frame pointers anytime soon and that what those distributors do is relevant.<p>All of the companies involved believed that they were special and decided to build their own (poorly managed) distribution called &quot;third party code&quot; and having to deal with it was not my best experience working at these companies.</div><br/><div id="39732264" class="c"><input type="checkbox" id="c-39732264" checked=""/><div class="controls bullet"><span class="by">starspangled</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732211">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39732264">[-]</label><label class="expand" for="c-39732264">[6 more]</label></div><br/><div class="children"><div class="content">Oh, I just assumed you were talking about Google&#x27;s Linux distribution and applications it runs on its fleet. I must have mis-assumed. Re-reading... maybe you weren&#x27;t talking about any builds but just whether or not to oppose kernel and toolchain defaulting to omit frame pointers?</div><br/><div id="39732290" class="c"><input type="checkbox" id="c-39732290" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732264">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39732290">[-]</label><label class="expand" for="c-39732290">[5 more]</label></div><br/><div class="children"><div class="content">Google didn&#x27;t have a Linux distribution for a long time (the one everyone used on the desktop was an outdated rpm based distro, we mostly ignored it for development purposes).<p>What existed was a x86 to x86 cross compilation environment and the libraries involved were manually imported by developers who needed that particular library.<p>My argument was about the cost of ensuring that those libraries were compiled with frame pointers when much of the open source community was defaulting to omit-fp.</div><br/><div id="39734189" class="c"><input type="checkbox" id="c-39734189" checked=""/><div class="controls bullet"><span class="by">dooglius</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732290">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39734189">[-]</label><label class="expand" for="c-39734189">[4 more]</label></div><br/><div class="children"><div class="content">Would it not be easier to patch compilers to always assume the equivalent of -fno-omit-frame-pointer</div><br/><div id="39736313" class="c"><input type="checkbox" id="c-39736313" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39734189">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39736313">[-]</label><label class="expand" for="c-39736313">[3 more]</label></div><br/><div class="children"><div class="content">That was done in 2005. But the task of auditing the supply chain to ensure that every single shared library you ever linked with was compiled a certain way was still hard. Nothing prevented an intern or a new employee from checking in a library without frame pointers into the third-party repo.<p>In 2024, you&#x27;d probably create a &quot;build container&quot; that all developers are required to use to build binaries or pay a linux distributor to build that container.<p>But cross compilation was the preferred approach back then. So all binaries had a rpath (run time search path to look for shared library) that ignored the distributor supplied libraries.<p>Having come from a open source background, I found this system hard to digest. But there was a lot of social pressure to work as a bee in a system that thousands of other very competent engineers are using (quite successfully).<p>I remember briefly talking to a chrome OS related group who were using the &quot;build your own custom distro&quot; approach, before deciding to move to another faang.</div><br/><div id="39736995" class="c"><input type="checkbox" id="c-39736995" checked=""/><div class="controls bullet"><span class="by">cruffle_duffle</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39736313">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39736995">[-]</label><label class="expand" for="c-39736995">[2 more]</label></div><br/><div class="children"><div class="content">&gt; or pay a linux distributor to build that container.<p>What does this mean?</div><br/><div id="39737350" class="c"><input type="checkbox" id="c-39737350" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39736995">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39737350">[-]</label><label class="expand" for="c-39737350">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t mean anything nefarious here :)<p>Since Google would rather have the best brains in the industry build the next search indexing algorithm or the browser, they didn&#x27;t have the time to invest human capital into building a better open source friendly dev environment.<p>A natural alternative is to contract out the work. Linux distributors were good candidates for such contract work.<p>But the vibe back then was Google could build better alternatives to some of these libraries and therefore bridging the gap between dev experience as an open source dev vs in house software engineer wasn&#x27;t important.<p>You could see the same argument play out in git vs monorepo etc, where people take up strong positions on a particular narrow tech topic, whereas the larger issue gets ignored as a result of these belief systems.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39732112" class="c"><input type="checkbox" id="c-39732112" checked=""/><div class="controls bullet"><span class="by">tempay</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732079">parent</a><span>|</span><a href="#39732211">prev</a><span>|</span><a href="#39732523">next</a><span>|</span><label class="collapse" for="c-39732112">[-]</label><label class="expand" for="c-39732112">[11 more]</label></div><br/><div class="children"><div class="content">It “wastes” a register when you’re not actively using them. On x86 that can make a big difference, though with the added registers of x86_64 it much less significant.</div><br/><div id="39732182" class="c"><input type="checkbox" id="c-39732182" checked=""/><div class="controls bullet"><span class="by">charleshn</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732112">parent</a><span>|</span><a href="#39732138">next</a><span>|</span><label class="collapse" for="c-39732182">[-]</label><label class="expand" for="c-39732182">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just the loss of an architectural register, it&#x27;s also the added cost to the prologue&#x2F;epilogue.
Even on x86_64, it can make a difference, in particular for small functions, which might not be inlined for a variety of reasons.</div><br/><div id="39735010" class="c"><input type="checkbox" id="c-39735010" checked=""/><div class="controls bullet"><span class="by">Asooka</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732182">parent</a><span>|</span><a href="#39736669">next</a><span>|</span><label class="collapse" for="c-39735010">[-]</label><label class="expand" for="c-39735010">[2 more]</label></div><br/><div class="children"><div class="content">If your small function is not getting inlined, you should investigate why that is instead of globally breaking performance analysis of your code.</div><br/><div id="39738701" class="c"><input type="checkbox" id="c-39738701" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39735010">parent</a><span>|</span><a href="#39736669">next</a><span>|</span><label class="collapse" for="c-39738701">[-]</label><label class="expand" for="c-39738701">[1 more]</label></div><br/><div class="children"><div class="content">A typical case would be C++ virtual member functions. (They can sometimes be devirtualized, or speculatively partially devirtualized, using LTO+PGO, but there are lots of legitimate cases where they cannot.)</div><br/></div></div></div></div><div id="39736669" class="c"><input type="checkbox" id="c-39736669" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732182">parent</a><span>|</span><a href="#39735010">prev</a><span>|</span><a href="#39732138">next</a><span>|</span><label class="collapse" for="c-39736669">[-]</label><label class="expand" for="c-39736669">[2 more]</label></div><br/><div class="children"><div class="content">CPUs spend an enormous amount of time waiting for IO and memory, and push&#x2F;pop and similar are just insanely well optimized. As the article also claims, I would be very surprised to see any effect, unless that more instructions themselves would spill the I-cache.</div><br/><div id="39737138" class="c"><input type="checkbox" id="c-39737138" checked=""/><div class="controls bullet"><span class="by">charleshn</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39736669">parent</a><span>|</span><a href="#39732138">next</a><span>|</span><label class="collapse" for="c-39737138">[-]</label><label class="expand" for="c-39737138">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen around 1-3% on non micro benchmarks, real applications.<p>Aee also this benchmark from Phoronix [0]:<p><pre><code>  Of the 100 tests carried out for this article, when taking the geometric mean of all these benchmarks it equated to about a 14% performance penalty of the software with -O2 compared to when adding -fno-omit-frame-pointer.
</code></pre>
I&#x27;m not saying these benchmarks or the workloads I&#x27;ve seen are representative of the &quot;real world&quot;, but people keep repeating that frame pointers are basically free, which is just not the case.<p>[0] <a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;review&#x2F;fedora-frame-pointer" rel="nofollow">https:&#x2F;&#x2F;www.phoronix.com&#x2F;review&#x2F;fedora-frame-pointer</a></div><br/></div></div></div></div></div></div><div id="39732138" class="c"><input type="checkbox" id="c-39732138" checked=""/><div class="controls bullet"><span class="by">starspangled</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732112">parent</a><span>|</span><a href="#39732182">prev</a><span>|</span><a href="#39733485">next</a><span>|</span><label class="collapse" for="c-39732138">[-]</label><label class="expand" for="c-39732138">[1 more]</label></div><br/><div class="children"><div class="content">Right, but I was asking about functional problems (being &quot;stuck&quot;), which sounded like a big issue for the choice.</div><br/></div></div><div id="39733485" class="c"><input type="checkbox" id="c-39733485" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732112">parent</a><span>|</span><a href="#39732138">prev</a><span>|</span><a href="#39732131">next</a><span>|</span><label class="collapse" for="c-39733485">[-]</label><label class="expand" for="c-39733485">[3 more]</label></div><br/><div class="children"><div class="content">Wasting a register on comparatively more modern ISA&#x27;s (PA-RISC 2.0, MIPS64, POWER, aarch64 etc – they are all more modern and have an abundance of general purpose registers) is not a concern.<p>The actual «wastage» is in having to generate a prologue and an epilogue for each function – 2x instructions to preserve the old frame pointer and set a new one up, and 2x instruction at the point of return – to restore the previous frame pointer.<p>Generally, it is not a big deal with an exception of a pathological case of a very large number of very small functions calling each other frequently where the extra 4x instructions per each such a function will be filling up the L1 instruction cache «unnessarily».</div><br/><div id="39735189" class="c"><input type="checkbox" id="c-39735189" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39733485">parent</a><span>|</span><a href="#39732131">next</a><span>|</span><label class="collapse" for="c-39735189">[-]</label><label class="expand" for="c-39735189">[2 more]</label></div><br/><div class="children"><div class="content">Those pathological cases are really what inlining is for, with the exception of any tiny recursive functions that can&#x27;t be tail call optimised.</div><br/><div id="39739150" class="c"><input type="checkbox" id="c-39739150" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39735189">parent</a><span>|</span><a href="#39732131">next</a><span>|</span><label class="collapse" for="c-39739150">[-]</label><label class="expand" for="c-39739150">[1 more]</label></div><br/><div class="children"><div class="content">Yes, inlining (and LTO can take it a notch or two higher) does away with the problem altogether, however the number of projects that default to «-Os» (or even to «-O2») to build a release product is substantial to large.<p>There is also a significant number of projects that go to great lengths to force-override CFLAGS&#x2F;CXXFLAGS (usually with «-O2 -g» or even with «-O») or make it extraordinary difficult to change the project&#x27;s default CFLAGS, for no apparent reasons which eliminates a number of advanced optimisations in builds with default build settings.</div><br/></div></div></div></div></div></div><div id="39732131" class="c"><input type="checkbox" id="c-39732131" checked=""/><div class="controls bullet"><span class="by">nlewycky</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732112">parent</a><span>|</span><a href="#39733485">prev</a><span>|</span><a href="#39732523">next</a><span>|</span><label class="collapse" for="c-39732131">[-]</label><label class="expand" for="c-39732131">[1 more]</label></div><br/><div class="children"><div class="content">It caused a problem when building inline assembly heavy code that tried to use all the registers, frame pointer register included.</div><br/></div></div></div></div></div></div><div id="39735694" class="c"><input type="checkbox" id="c-39735694" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#39731989">parent</a><span>|</span><a href="#39732079">prev</a><span>|</span><a href="#39732339">next</a><span>|</span><label class="collapse" for="c-39735694">[-]</label><label class="expand" for="c-39735694">[1 more]</label></div><br/><div class="children"><div class="content">What area?</div><br/></div></div></div></div><div id="39735457" class="c"><input type="checkbox" id="c-39735457" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#39731989">prev</a><span>|</span><a href="#39732311">next</a><span>|</span><label class="collapse" for="c-39735457">[-]</label><label class="expand" for="c-39735457">[6 more]</label></div><br/><div class="children"><div class="content">Virgil doesn&#x27;t use frame pointers. If you don&#x27;t have dynamic stack allocation, the frame of a given function has a fixed size can be found with a simple (binary-search) table lookup. Virgil&#x27;s technique uses an additional page-indexed range that further restricts the lookup to be a few comparisons on average (O(log(# retpoints per page)). It combines the unwind info with stackmaps for GC. It takes very little space.<p>The main driver is in (<a href="https:&#x2F;&#x2F;github.com&#x2F;titzer&#x2F;virgil&#x2F;blob&#x2F;master&#x2F;rt&#x2F;native&#x2F;NativeStackWalker.v3);">https:&#x2F;&#x2F;github.com&#x2F;titzer&#x2F;virgil&#x2F;blob&#x2F;master&#x2F;rt&#x2F;native&#x2F;Nativ...</a> the rest of the code in the directory implements the decoding of metadata.<p>I think frame pointers only make sense if frames are dynamically-sized (i.e. have stack allocation of data). Otherwise it seems weird to me that a dynamic mechanism is used when a static mechanism would suffice; mostly because no one agreed on an ABI for the metadata encoding, or an unwind routine.<p>I believe the 1-2% measurement number. That&#x27;s in the same ballpark as pervasive checks for array bounds checks. It&#x27;s weird that the odd debugging and profiling task gets special pleading for a 1% cost but adding a layer of security gets the finger. Very bizarre priorities.</div><br/><div id="39739227" class="c"><input type="checkbox" id="c-39739227" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#39735457">parent</a><span>|</span><a href="#39732311">next</a><span>|</span><label class="collapse" for="c-39739227">[-]</label><label class="expand" for="c-39739227">[5 more]</label></div><br/><div class="children"><div class="content">You can add bounds checks to c, but that costs a hell of a lot more than 1-2%.  C++ has them off by default for std::vector because c++ is designed by and for the utterly insane.  Other than that, I can&#x27;t off the top of my head think of a language that doesn&#x27;t have them.</div><br/><div id="39739289" class="c"><input type="checkbox" id="c-39739289" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#39735457">root</a><span>|</span><a href="#39739227">parent</a><span>|</span><a href="#39732311">next</a><span>|</span><label class="collapse" for="c-39739289">[-]</label><label class="expand" for="c-39739289">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>C++ has them off by default for std::vector because c++ is designed by and for the utterly insane.</i><p>And for those who value performance and don&#x27;t want to pay the cost of &quot;a lot more than 1-2%&quot; ;p</div><br/><div id="39741251" class="c"><input type="checkbox" id="c-39741251" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39735457">root</a><span>|</span><a href="#39739289">parent</a><span>|</span><a href="#39739649">next</a><span>|</span><label class="collapse" for="c-39741251">[-]</label><label class="expand" for="c-39741251">[1 more]</label></div><br/><div class="children"><div class="content">std::regexp, std::map, fronzen ABI.... apparently the value for performance is relative at WG21.</div><br/></div></div><div id="39739649" class="c"><input type="checkbox" id="c-39739649" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#39735457">root</a><span>|</span><a href="#39739289">parent</a><span>|</span><a href="#39741251">prev</a><span>|</span><a href="#39732311">next</a><span>|</span><label class="collapse" for="c-39739649">[-]</label><label class="expand" for="c-39739649">[2 more]</label></div><br/><div class="children"><div class="content">std::vector falls into the category of things that are easy to bounds check, st the cost, even under today&#x27;s primitive compilers, is low.  It&#x27;s direct pointer accesses—which are common in c but not in c++ or most other languages—that are hard to and therefore cost more to bounds check.</div><br/><div id="39740220" class="c"><input type="checkbox" id="c-39740220" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#39735457">root</a><span>|</span><a href="#39739649">parent</a><span>|</span><a href="#39732311">next</a><span>|</span><label class="collapse" for="c-39740220">[-]</label><label class="expand" for="c-39740220">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s assuming you&#x27;re keeping no metadata about your C array(s) that you&#x27;re bounds-checking, which would be very slow indeed. :o You&#x27;d be traversing pointers until you hit a tombstone value or something. But would anyone do this in performance-chasing code? Cuz, otherwise, <i>with</i> metadata to support your bounds checks, you&#x27;re doing the same thing that I assume std::vector is doing: asking your array metadata about whether something&#x27;s in bounds. And that&#x27;s extra cycles, which can add up depending on what you&#x27;re doing!<p>Btw, in my experience, std::vector is <i>fast</i>. Insanely fast. &quot;I don&#x27;t understand how it can be so fast&quot;, &quot;barely distinguishable from raw arrays in C&quot; fast. Not doing bounds checking is probably part of that, though far from the whole story.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39732311" class="c"><input type="checkbox" id="c-39732311" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39735457">prev</a><span>|</span><a href="#39732022">next</a><span>|</span><label class="collapse" for="c-39732311">[-]</label><label class="expand" for="c-39732311">[15 more]</label></div><br/><div class="children"><div class="content">Of course, if you cede RBP to be a frame pointer, you may as well have two stacks, one which is pointed into by RBP and stores the activation frames, and the other one which is pointed into by RSP and stores the return addresses only. At this point, you don&#x27;t even need to &quot;walk the stack&quot; because the call stack is literally just a flat array of return addresses.<p>Why do we normally store the return addresses near to the local variables in the first place, again? There are so many downsides.</div><br/><div id="39732481" class="c"><input type="checkbox" id="c-39732481" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39732311">parent</a><span>|</span><a href="#39733127">next</a><span>|</span><label class="collapse" for="c-39732481">[-]</label><label class="expand" for="c-39732481">[3 more]</label></div><br/><div class="children"><div class="content">It simplifies storage management. A stack frame is a simple bump pointer which is always in cache and only one guard page for overflow, in your proposal you need two guard pages and double the stack manipulations and doubling the chance of a cache miss.</div><br/><div id="39732616" class="c"><input type="checkbox" id="c-39732616" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39732481">parent</a><span>|</span><a href="#39733766">next</a><span>|</span><label class="collapse" for="c-39732616">[-]</label><label class="expand" for="c-39732616">[1 more]</label></div><br/><div class="children"><div class="content">Yes, two guard pages are needed. No, the stack management stays the same: it&#x27;s just &quot;CALL func&quot; at the call site, &quot;SUB RBP, &lt;frame_size&gt;&quot; at the prologue and &quot;ADD RBP, &lt;frame_size&gt;; RET&quot; at the epilogue. As for chances of a cache miss... probably, but I guess you also double them up when you enable CFET&#x2F;Shadow Stack so eh.<p>In exchange, it becomes very difficult for the stack smashing to corrupt the return address.</div><br/></div></div><div id="39733766" class="c"><input type="checkbox" id="c-39733766" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39732481">parent</a><span>|</span><a href="#39732616">prev</a><span>|</span><a href="#39733127">next</a><span>|</span><label class="collapse" for="c-39733766">[-]</label><label class="expand" for="c-39733766">[1 more]</label></div><br/><div class="children"><div class="content">The reduceron had five stacks and it was faster because of it.</div><br/></div></div></div></div><div id="39733127" class="c"><input type="checkbox" id="c-39733127" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#39732311">parent</a><span>|</span><a href="#39732481">prev</a><span>|</span><a href="#39732956">next</a><span>|</span><label class="collapse" for="c-39733127">[-]</label><label class="expand" for="c-39733127">[5 more]</label></div><br/><div class="children"><div class="content">You may be ready for Forth [1] ;-). Strangely, the Wikipedia article apparently doesn&#x27;t put forward that Forth allows access both to the parameter and the return stack, which is a major feature of the model.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forth_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forth_(programming_language)</a></div><br/><div id="39735729" class="c"><input type="checkbox" id="c-39735729" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39733127">parent</a><span>|</span><a href="#39735812">next</a><span>|</span><label class="collapse" for="c-39735729">[-]</label><label class="expand" for="c-39735729">[3 more]</label></div><br/><div class="children"><div class="content">Forth has a parameter stack, return stack, vocabulary stack<p>STOIC, a variant of Forth, includes a file stack when loading words</div><br/><div id="39735826" class="c"><input type="checkbox" id="c-39735826" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39735729">parent</a><span>|</span><a href="#39735812">next</a><span>|</span><label class="collapse" for="c-39735826">[-]</label><label class="expand" for="c-39735826">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re referring to with &quot;vocabulary stack&quot; here, perhaps the dictionary? More of a linked list, really a distinctive data structure of its own.</div><br/><div id="39737159" class="c"><input type="checkbox" id="c-39737159" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39735826">parent</a><span>|</span><a href="#39735812">next</a><span>|</span><label class="collapse" for="c-39737159">[-]</label><label class="expand" for="c-39737159">[1 more]</label></div><br/><div class="children"><div class="content">Maybe OP refers to vocabulary search order manipulation [1]. It&#x27;s sort of like namespaces, but &quot;stacked&quot;. There&#x27;s also the old MARKER and FORGET pair [2].<p>The dictionary pointer can also be manipulated in some dialects. That can be used directly as the stack variant of the arena allocator idea. It is particularly useful for text concatenation.<p>[1] <a href="https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;search" rel="nofollow">https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;search</a>
[2] <a href="https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;MARKER" rel="nofollow">https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;MARKER</a></div><br/></div></div></div></div></div></div><div id="39735812" class="c"><input type="checkbox" id="c-39735812" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39733127">parent</a><span>|</span><a href="#39735729">prev</a><span>|</span><a href="#39732956">next</a><span>|</span><label class="collapse" for="c-39735812">[-]</label><label class="expand" for="c-39735812">[1 more]</label></div><br/><div class="children"><div class="content">That does seem like a significant oversight. &gt;r and r&gt;, and cousins, are part of ANSI Forth, and I&#x27;ve never used a Forth which doesn&#x27;t have them.</div><br/></div></div></div></div><div id="39732956" class="c"><input type="checkbox" id="c-39732956" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#39732311">parent</a><span>|</span><a href="#39733127">prev</a><span>|</span><a href="#39734581">next</a><span>|</span><label class="collapse" for="c-39732956">[-]</label><label class="expand" for="c-39732956">[3 more]</label></div><br/><div class="children"><div class="content">Note the ‘shadow stacks’ CPU feature mentioned briefly in the article, though it’s more for security reasons. It’s pretty similar to what you describe.</div><br/><div id="39733215" class="c"><input type="checkbox" id="c-39733215" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39732956">parent</a><span>|</span><a href="#39734581">next</a><span>|</span><label class="collapse" for="c-39733215">[-]</label><label class="expand" for="c-39733215">[2 more]</label></div><br/><div class="children"><div class="content">Shadow stacks have been proposed as an alternative, although it&#x27;s my understanding that in current CPUs they hold only a limited number of frames, like 16 or 32?</div><br/><div id="39733491" class="c"><input type="checkbox" id="c-39733491" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39733215">parent</a><span>|</span><a href="#39734581">next</a><span>|</span><label class="collapse" for="c-39733491">[-]</label><label class="expand" for="c-39733491">[1 more]</label></div><br/><div class="children"><div class="content">You may be thinking of the return stack buffer.  The shadow stack holds every return address.</div><br/></div></div></div></div></div></div><div id="39734581" class="c"><input type="checkbox" id="c-39734581" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#39732311">parent</a><span>|</span><a href="#39732956">prev</a><span>|</span><a href="#39733645">next</a><span>|</span><label class="collapse" for="c-39734581">[-]</label><label class="expand" for="c-39734581">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Why do we normally store the return addresses near to the local variables in the first place, again? There are so many downsides.<p>The advantage of storing them elsewhere is not quite clear (unless you have hardware support for things like shadow stacks).<p>You&#x27;d have to argue that the cost of moving things to this other page and managing two pointers (where one is less powerful in the ISA) is meaningfully cheaper than the other equally effective mitigation of stack cookies&#x2F;protectors which are already able to provide protection only where needed. There is no real security benefit to doing this over what we currently have with stack protectors since an arbitrary read&#x2F;write will still lead to a CFI bypass.</div><br/><div id="39735242" class="c"><input type="checkbox" id="c-39735242" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39734581">parent</a><span>|</span><a href="#39733645">next</a><span>|</span><label class="collapse" for="c-39735242">[-]</label><label class="expand" for="c-39735242">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The advantage of storing them elsewhere is not quite clear (unless you have hardware support for things like shadow stacks).<p>The classic buffer overflow issue should spring immediately to mind. By having a separate return address stack it&#x27;s far less vulnerable to corruption through overflowing your data structures. This stops a bunch of attacks which purposely put crafted return addresses into position that will jump the program to malicious code.<p>It&#x27;s not a panacea, but generally keeping code pointers away from data structures is a good idea.</div><br/></div></div></div></div><div id="39733645" class="c"><input type="checkbox" id="c-39733645" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#39732311">parent</a><span>|</span><a href="#39734581">prev</a><span>|</span><a href="#39732022">next</a><span>|</span><label class="collapse" for="c-39733645">[-]</label><label class="expand" for="c-39733645">[1 more]</label></div><br/><div class="children"><div class="content">While here, why do we grow the stack the wrong way so misbehaved programs cause security issues? I know the reason of course, like so many things it last made sense 30 years ago, but the effects have been interesting.</div><br/></div></div></div></div><div id="39732022" class="c"><input type="checkbox" id="c-39732022" checked=""/><div class="controls bullet"><span class="by">dap</span><span>|</span><a href="#39732311">prev</a><span>|</span><a href="#39734144">next</a><span>|</span><label class="collapse" for="c-39732022">[-]</label><label class="expand" for="c-39732022">[4 more]</label></div><br/><div class="children"><div class="content">Good post!<p>&gt; Profiling has been broken for 20 years and we&#x27;ve only now just fixed it.<p>It was a shame when they went away.  Lots of people, certainly on other systems and probably Linux too, have found the absence of frame pointers painful this whole time and tried to keep them available in as many environments as possible.  It’s validating (if also kind of frustrating) to see mainstream Linux bring them back.</div><br/><div id="39738651" class="c"><input type="checkbox" id="c-39738651" checked=""/><div class="controls bullet"><span class="by">trws</span><span>|</span><a href="#39732022">parent</a><span>|</span><a href="#39734144">next</a><span>|</span><label class="collapse" for="c-39738651">[-]</label><label class="expand" for="c-39738651">[3 more]</label></div><br/><div class="children"><div class="content">I’m sincerely curious. While I realize that using dwarf for unwinding is annoying, why is it so bad that it’s worth pessimizing all code on the system? It’s slow on Debian derivatives because they package only the slow unwinding path for perf for example, for license reasons, but with decent tooling I barely notice the difference. What am I missing?</div><br/><div id="39740181" class="c"><input type="checkbox" id="c-39740181" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#39732022">root</a><span>|</span><a href="#39738651">parent</a><span>|</span><a href="#39739181">prev</a><span>|</span><a href="#39734144">next</a><span>|</span><label class="collapse" for="c-39740181">[-]</label><label class="expand" for="c-39740181">[1 more]</label></div><br/><div class="children"><div class="content">Which is the slow unwinding path? The one from libbfd?</div><br/></div></div></div></div></div></div><div id="39734144" class="c"><input type="checkbox" id="c-39734144" checked=""/><div class="controls bullet"><span class="by">javierhonduco</span><span>|</span><a href="#39732022">prev</a><span>|</span><a href="#39736213">next</a><span>|</span><label class="collapse" for="c-39734144">[-]</label><label class="expand" for="c-39734144">[5 more]</label></div><br/><div class="children"><div class="content">Overall, I am for frame pointers, but after some years working in this space, I thought I would share some thoughts:<p>* Many frame pointer unwinders don&#x27;t account for a problem they have that DWARF unwind info doesn&#x27;t have: the fact that the frame set-up is not atomic, it&#x27;s done in two instructions, `push $rbp` and `mov $rsp $rbp`, and if when a snapshot is taken we are in the `push`, we&#x27;ll miss the parent frame. I think this might be able to be fired by inspecting the code, but I think this might only be as good as a heuristic as there could be other `push %rbp` unrelated to the stack frame. I would love to hear if there&#x27;s a better approach!<p>* I developed the solution Brendan mentions which allows faster, in-kernel unwinding without frame pointers using BPF [0]. This doesn&#x27;t use DWARF CFI (the unwind info) as-is but converts it into a random-access format that we can use in BPF. He mentions not supporting JVM languages, and while it&#x27;s true that right now it only supports JIT sections that have frame pointers, I planned to implement a full JVM interpreter unwinder. I have left Polar Signals since and shifted priorities but it&#x27;s feasible to get a JVM unwinder to work in lockstep with the native unwinder.<p>* In an ideal world, enabling frame pointers should be done on a case-by-case. Benchmarking is key, and the tradeoffs that you make might change a lot depending on the industry you are in, and what your software is doing. In the past I have seen large projects enabling&#x2F;disabling frame pointers not doing an in-depth assessment of losses&#x2F;gains of performance, observability, and how they connect to business metrics. The Fedora folks have done a superb and rigorous job here.<p>* Related to the previous point, having a build system that enables you to change this system-wide, including libraries your software depends on can be awesome to not only test these changes but also put them in production.<p>* Lastly, I am quite excited about SFrame that Indu is working on. It&#x27;s going to solve a lot of the problems we are facing right now while letting users decide whether they use frame pointers. I can&#x27;t wait for it, but I am afraid it might take several years until all the infrastructure is in place and everybody upgrades to it.<p>- [0]: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231222054207&#x2F;https:&#x2F;&#x2F;www.polarsignals.com&#x2F;blog&#x2F;posts&#x2F;2022&#x2F;11&#x2F;29&#x2F;dwarf-based-stack-walking-using-ebpf" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20231222054207&#x2F;https:&#x2F;&#x2F;www.polar...</a></div><br/><div id="39740280" class="c"><input type="checkbox" id="c-39740280" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#39734144">parent</a><span>|</span><a href="#39734300">next</a><span>|</span><label class="collapse" for="c-39740280">[-]</label><label class="expand" for="c-39740280">[1 more]</label></div><br/><div class="children"><div class="content">It could be one instruction: ENTER N,0 (where N is the amount of stack space to reserve for locals)---this is the same as:<p><pre><code>    PUSH EBP
    MOV  ESP,ESP
    SUB  SP,N
</code></pre>
(I don&#x27;t recall if ENTER is x86-64 or not).  But even with this, the frame setup isn&#x27;t atomic with respect to CALL, and if the snapshot is taken after the CALL but before the ENTER, we still don&#x27;t get the fame setup.<p>As for the reason why ENTER isn&#x27;t used, it was deemed too slow.  LEAVE (MOV SP,BP; POP BP) is used as it&#x27;s just as fast as, if not faster, than the sequence it replaces.  If ENTER were just the PUSH&#x2F;MOV&#x2F;SUB sequence, it probably would be used, but it&#x27;s that other operand (which is 0 above in my example) that kills it performance wise (it&#x27;s for nested functions to gain access to upper stack frames and is every expensive to use).</div><br/></div></div><div id="39734300" class="c"><input type="checkbox" id="c-39734300" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39734144">parent</a><span>|</span><a href="#39740280">prev</a><span>|</span><a href="#39734349">next</a><span>|</span><label class="collapse" for="c-39734300">[-]</label><label class="expand" for="c-39734300">[1 more]</label></div><br/><div class="children"><div class="content">On the third point, you have to do frame pointers across the whole Linux distro in order to be able to get good flamegraphs.  You have to do whole system analysis to really understand what&#x27;s going on.  The way that current binary Linux distros (like Fedora and Debian) works makes any alternative impossible.</div><br/></div></div><div id="39734349" class="c"><input type="checkbox" id="c-39734349" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#39734144">parent</a><span>|</span><a href="#39734300">prev</a><span>|</span><a href="#39735601">next</a><span>|</span><label class="collapse" for="c-39734349">[-]</label><label class="expand" for="c-39734349">[1 more]</label></div><br/><div class="children"><div class="content">Great comments, thanks for sharing. The non-atomic frame setup is indeed problematic for CPU profilers, but it&#x27;s not an issue for allocation profiling, Off-CPU profiling or other types off non-interrupt driven profiling. But as you mentioned, there might be ways to solve that problem.</div><br/></div></div><div id="39735601" class="c"><input type="checkbox" id="c-39735601" checked=""/><div class="controls bullet"><span class="by">brancz</span><span>|</span><a href="#39734144">parent</a><span>|</span><a href="#39734349">prev</a><span>|</span><a href="#39736213">next</a><span>|</span><label class="collapse" for="c-39735601">[-]</label><label class="expand" for="c-39735601">[1 more]</label></div><br/><div class="children"><div class="content">Great comment! Just want to add we are making good progress on the JVM unwinder!</div><br/></div></div></div></div><div id="39736213" class="c"><input type="checkbox" id="c-39736213" checked=""/><div class="controls bullet"><span class="by">boulos</span><span>|</span><a href="#39734144">prev</a><span>|</span><a href="#39735377">next</a><span>|</span><label class="collapse" for="c-39736213">[-]</label><label class="expand" for="c-39736213">[1 more]</label></div><br/><div class="children"><div class="content">JIT&#x27;ed code is sadly poorly supported, but LLVM has had great hooks for noting each method that is produced and its address. So you can build a simple mixed-mode unwinder, pretty easily, but mostly in process.<p>I think Intel&#x27;s DNN things dump their info out to some common file that perf can read instead, but because the *kernels* themselves reuse rbp throughout oneDNN, it&#x27;s totally useless.<p>Finally, can any JVM folks explain this claim about DWARF info from the article:<p>&gt; Doesn&#x27;t exist for JIT&#x27;d runtimes like the Java JVM<p>that just sounds surprising to me. Is it off by default or literally not available? (Google searches have mostly pointed to people wanting to include the JNI&#x2F;C side of a JVM stack, like <a href="https:&#x2F;&#x2F;github.com&#x2F;async-profiler&#x2F;async-profiler&#x2F;issues&#x2F;215">https:&#x2F;&#x2F;github.com&#x2F;async-profiler&#x2F;async-profiler&#x2F;issues&#x2F;215</a>).</div><br/></div></div><div id="39735377" class="c"><input type="checkbox" id="c-39735377" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#39736213">prev</a><span>|</span><a href="#39732360">next</a><span>|</span><label class="collapse" for="c-39735377">[-]</label><label class="expand" for="c-39735377">[4 more]</label></div><br/><div class="children"><div class="content">Just as a general comment on this topic...<p>The fact that people complain about the performance of the mechanism that enables the system to be profiled, and so performance problems be identified, is beyond ironic. Surely the epitome of premature optimisation.</div><br/><div id="39735660" class="c"><input type="checkbox" id="c-39735660" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39735377">parent</a><span>|</span><a href="#39735488">next</a><span>|</span><label class="collapse" for="c-39735660">[-]</label><label class="expand" for="c-39735660">[2 more]</label></div><br/><div class="children"><div class="content">So what are these other techniques the 2004 migration from frame pointers assumed would work for stack walking? Why don&#x27;t they work today? I get that _64 has a lot more registers, so there&#x27;s minimal value to +1 the register?</div><br/><div id="39736147" class="c"><input type="checkbox" id="c-39736147" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39735377">root</a><span>|</span><a href="#39735660">parent</a><span>|</span><a href="#39735488">next</a><span>|</span><label class="collapse" for="c-39736147">[-]</label><label class="expand" for="c-39736147">[1 more]</label></div><br/><div class="children"><div class="content">In 2004, the assumption made by the GCC developers was that you would be walking stacks very infrequently, in a debugger like GDB.  Not sampling stacks 1000s of times a second for profiling.</div><br/></div></div></div></div><div id="39735488" class="c"><input type="checkbox" id="c-39735488" checked=""/><div class="controls bullet"><span class="by">doubloon</span><span>|</span><a href="#39735377">parent</a><span>|</span><a href="#39735660">prev</a><span>|</span><a href="#39732360">next</a><span>|</span><label class="collapse" for="c-39735488">[-]</label><label class="expand" for="c-39735488">[1 more]</label></div><br/><div class="children"><div class="content">im sure in ancient mesopotamia there was somebody arguing about you could brew beer faster if you stop measuring the hops so carefully but then someone else was saying yes but if you dont measure the hops carefully then you dont know the efficiency of your overall beer making process so you cant isolate the bottlenecks.<p>the funny thing is i am not sure if the world would actually work properly if we didn&#x27;t have both of these kinds of people.</div><br/></div></div></div></div><div id="39732360" class="c"><input type="checkbox" id="c-39732360" checked=""/><div class="controls bullet"><span class="by">claytonwramsey</span><span>|</span><a href="#39735377">prev</a><span>|</span><a href="#39732497">next</a><span>|</span><label class="collapse" for="c-39732360">[-]</label><label class="expand" for="c-39732360">[13 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very interesting to me - I had seen the `[unknown]` mountain in my profiles but never knew why. I think it&#x27;s a tough thing to justify: 2% performance is actually a pretty big difference.<p>It would be really nice to have fine-grained control over frame pointer inclusion: provided fine-grained profiling, we could determine whether we needed the frame pointers for a given function or compilation unit. I wouldn&#x27;t be surprised if we see that only a handful of operations are dramatically slowed by frame pointer inclusion while the rest don&#x27;t really care.</div><br/><div id="39732491" class="c"><input type="checkbox" id="c-39732491" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39732360">parent</a><span>|</span><a href="#39733595">next</a><span>|</span><label class="collapse" for="c-39732491">[-]</label><label class="expand" for="c-39732491">[7 more]</label></div><br/><div class="children"><div class="content">&gt; 2% performance is actually a pretty big difference.<p>No it&#x27;s not, particularly when it can help you identify hotspots via profiling that can net you improvements of 10% or more.</div><br/><div id="39733114" class="c"><input type="checkbox" id="c-39733114" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#39732360">root</a><span>|</span><a href="#39732491">parent</a><span>|</span><a href="#39733595">next</a><span>|</span><label class="collapse" for="c-39733114">[-]</label><label class="expand" for="c-39733114">[6 more]</label></div><br/><div class="children"><div class="content">Sure, but how many of the people running distro compiled code do perf analysis? And how many of the people who need to do perf analysis are unable to use a with-frame-pointers version when they need to? And how many of those 10% perf improvements are in common distro code that get upstreamed to improve general user experience, as opposed to being in private application code?<p>If you&#x27;re netflix then &quot;enable frame pointers&quot; is a no-brainer. But if you&#x27;re a distro who&#x27;s building code for millions of users, many of whom will likely never need to fire up a profiler, I think the question is at least a little trickier. The overall best tradeoff might end up being still to enable frame pointers, but I can see the other side too.</div><br/><div id="39735640" class="c"><input type="checkbox" id="c-39735640" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39732360">root</a><span>|</span><a href="#39733114">parent</a><span>|</span><a href="#39735876">next</a><span>|</span><label class="collapse" for="c-39735640">[-]</label><label class="expand" for="c-39735640">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a technical tradeoff, it&#x27;s a refusal to compromise. Lack of frame pointers prevents many groups from using software built by distros altogether. If a distro decides that they&#x27;d rather make things go 1% faster for grandma, at the cost of alienating thousands of engineers at places like Netflix and Google who simply want to volunteer millions of dollars of their employers resources helping distros to find 10x performance improvements, then the distros are doing a great disservice to both grandma and themselves.</div><br/><div id="39738573" class="c"><input type="checkbox" id="c-39738573" checked=""/><div class="controls bullet"><span class="by">alerighi</span><span>|</span><a href="#39732360">root</a><span>|</span><a href="#39735640">parent</a><span>|</span><a href="#39738288">next</a><span>|</span><label class="collapse" for="c-39738573">[-]</label><label class="expand" for="c-39738573">[2 more]</label></div><br/><div class="children"><div class="content">I mean if you need to do performance analysis on a software just recompile it. Why it&#x27;s such a big deal?<p>In the end a 2% of performance of every application it&#x27;s a big deal. On a single computer may not be that significant, think about all the computers, servers, clusters, that run a Linux distro. And yes, I would ask a Google engineer that if scaled on the I don&#x27;t know how many servers and computers that Google has a 2% increase in CPU usage is not a big deal: we are probably talking about hundreds of kW more of energy consumption!<p>We talk a lot of energy efficiency these days, to me wasting a 2% only to make the performance analysis of some software easier (that is that you can analyze directly the package shipped by the distro and you don&#x27;t have to recompile it) it&#x27;s something stupid.</div><br/><div id="39740742" class="c"><input type="checkbox" id="c-39740742" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39732360">root</a><span>|</span><a href="#39738573">parent</a><span>|</span><a href="#39738288">next</a><span>|</span><label class="collapse" for="c-39740742">[-]</label><label class="expand" for="c-39740742">[1 more]</label></div><br/><div class="children"><div class="content">The average European home consumes 400 watts at any given moment. Modern digital smart meters can consume 4 watts on average, which is 1% of a household&#x27;s power consumption. On the grand scheme of society, these 1% losses in each home add up. If we consider all the grid monitoring equipment that&#x27;s typically employed by electrical companies outside the home, the problem becomes much greater. In order to maximize energy efficiency and improve our environmental footprint, we must remove these metering and monitoring devices, which don&#x27;t actually contribute to the delivery and consumption of power.</div><br/></div></div></div></div><div id="39738288" class="c"><input type="checkbox" id="c-39738288" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#39732360">root</a><span>|</span><a href="#39735640">parent</a><span>|</span><a href="#39738573">prev</a><span>|</span><a href="#39735876">next</a><span>|</span><label class="collapse" for="c-39738288">[-]</label><label class="expand" for="c-39738288">[1 more]</label></div><br/><div class="children"><div class="content">Presenting people with false dichotomies is no way to build something worthwhile</div><br/></div></div></div></div><div id="39735876" class="c"><input type="checkbox" id="c-39735876" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39732360">root</a><span>|</span><a href="#39733114">parent</a><span>|</span><a href="#39735640">prev</a><span>|</span><a href="#39733595">next</a><span>|</span><label class="collapse" for="c-39735876">[-]</label><label class="expand" for="c-39735876">[1 more]</label></div><br/><div class="children"><div class="content">I would say the question here is what should be the default, and that the answer is clearly &quot;frame pointers&quot;, from my point of view.<p>Code eking out every possible cycle of performance can enable a no-frame-pointer optimization and see if it helps. But it&#x27;s a bad default for libc, and for the kernel.</div><br/></div></div></div></div></div></div><div id="39733595" class="c"><input type="checkbox" id="c-39733595" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39732360">parent</a><span>|</span><a href="#39732491">prev</a><span>|</span><a href="#39733224">next</a><span>|</span><label class="collapse" for="c-39733595">[-]</label><label class="expand" for="c-39733595">[2 more]</label></div><br/><div class="children"><div class="content">You can turn it on&#x2F;off per function by attaching one of these GCC attribute to the function declaration (although it doesn&#x27;t work on LLVM):<p><pre><code>  __attribute__((optimize(&quot;no-omit-frame-pointer&quot;)))
  __attribute__((optimize(&quot;omit-frame-pointer&quot;)))</code></pre></div><br/><div id="39738667" class="c"><input type="checkbox" id="c-39738667" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#39732360">root</a><span>|</span><a href="#39733595">parent</a><span>|</span><a href="#39733224">next</a><span>|</span><label class="collapse" for="c-39738667">[-]</label><label class="expand" for="c-39738667">[1 more]</label></div><br/><div class="children"><div class="content">The optimize fn attr causes other unintended side effects. Its usage is banned on the Linux kernel.</div><br/></div></div></div></div><div id="39733224" class="c"><input type="checkbox" id="c-39733224" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39732360">parent</a><span>|</span><a href="#39733595">prev</a><span>|</span><a href="#39732514">next</a><span>|</span><label class="collapse" for="c-39733224">[-]</label><label class="expand" for="c-39733224">[1 more]</label></div><br/><div class="children"><div class="content">The measured overhead is slightly less than 1%.  There have been some rare historical cases where frame pointers have caused performance to blow up but those are fixed.</div><br/></div></div><div id="39732514" class="c"><input type="checkbox" id="c-39732514" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39732360">parent</a><span>|</span><a href="#39733224">prev</a><span>|</span><a href="#39733102">next</a><span>|</span><label class="collapse" for="c-39732514">[-]</label><label class="expand" for="c-39732514">[1 more]</label></div><br/><div class="children"><div class="content">It’s usually a lot less than 2%.</div><br/></div></div><div id="39733102" class="c"><input type="checkbox" id="c-39733102" checked=""/><div class="controls bullet"><span class="by">inglor_cz</span><span>|</span><a href="#39732360">parent</a><span>|</span><a href="#39732514">prev</a><span>|</span><a href="#39732497">next</a><span>|</span><label class="collapse" for="c-39733102">[-]</label><label class="expand" for="c-39733102">[1 more]</label></div><br/><div class="children"><div class="content">The performance cost in your case may be much smaller than 2 per cent.<p>Don&#x27;t completely trust the benchmarks on this; they are a bit synthetic and real-world applications tend to produce very different results.<p>Plus, profiling is important. I was able to speed up various segments of my code by up to 20 per cent by profiling them carefully.<p>And, at the end of the day, if your application is so sensitive about any loss of performance, you <i>can</i> simply profile your code in your lab using frame pointers, then omit them in the version released to your customers.</div><br/></div></div></div></div><div id="39732497" class="c"><input type="checkbox" id="c-39732497" checked=""/><div class="controls bullet"><span class="by">tdullien</span><span>|</span><a href="#39732360">prev</a><span>|</span><a href="#39732938">next</a><span>|</span><label class="collapse" for="c-39732497">[-]</label><label class="expand" for="c-39732497">[16 more]</label></div><br/><div class="children"><div class="content">As much as the return of frame pointers is a good thing, it&#x27;s largely unnecessary -- it arrives at a point where multiple eBPF-based profilers are available that do fine using .eh_frame and also manually unwinding high level language runtime stacks: Both Parca from PolarSignals as well the artist formerly known as Prodfiler (now Elastic Universal Profiling) do fine.<p>So this is a solution for a problem, and it arrives just at the moment that people have solved the problem more generically ;)<p>(Prodfiler coauthor here, we had solved all of this by the time we launched in Summer 2021)</div><br/><div id="39733320" class="c"><input type="checkbox" id="c-39733320" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#39732497">parent</a><span>|</span><a href="#39733065">next</a><span>|</span><label class="collapse" for="c-39733320">[-]</label><label class="expand" for="c-39733320">[1 more]</label></div><br/><div class="children"><div class="content">First of all, I think the .eh_frame unwinding y&#x27;all pioneered is great.<p>But I think you&#x27;re only thinking about CPU profiling at &lt;= 100 Hz &#x2F; core. However, Brendan&#x27;s article is also talking about Off-CPU profiling, and as far as I can tell, all known techniques (scheduler tracing, wall clock sampling) require stack unwinding to occur 1-3 orders of magnitude more often than for CPU profiling.<p>For those use cases, I don&#x27;t think .eh_frame unwinding will be good enough, at least not for continuous profiling. E.g. see [1][2] for an example of how frame pointer unwinding allowed the Go runtime to lower execution tracing overhead from 10-20% to 1-2%, even so it was already using a relatively fast lookup table approach.<p>[1] <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;execution-traces-2024" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;execution-traces-2024</a><p>[2] <a href="https:&#x2F;&#x2F;blog.felixge.de&#x2F;reducing-gos-execution-tracer-overhead-with-frame-pointer-unwinding&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.felixge.de&#x2F;reducing-gos-execution-tracer-overhe...</a></div><br/></div></div><div id="39733065" class="c"><input type="checkbox" id="c-39733065" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#39732497">parent</a><span>|</span><a href="#39733320">prev</a><span>|</span><a href="#39732998">next</a><span>|</span><label class="collapse" for="c-39733065">[-]</label><label class="expand" for="c-39733065">[5 more]</label></div><br/><div class="children"><div class="content">Also I&#x27;ve heard that the whole .eh_frame unwinding is more fragile than a simple frame pointer. I&#x27;ve seen enough broken stack traces myself, but honestly I never tried if -fno-omit-frame-pointer would have helped.</div><br/><div id="39733091" class="c"><input type="checkbox" id="c-39733091" checked=""/><div class="controls bullet"><span class="by">tdullien</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39733065">parent</a><span>|</span><a href="#39732998">next</a><span>|</span><label class="collapse" for="c-39733091">[-]</label><label class="expand" for="c-39733091">[4 more]</label></div><br/><div class="children"><div class="content">Yes and no. A simple frame pointer needs to be present in all libraries, and depending on build settings, this might not be the case. .eh_frame tends to be emitted almost everywhere...<p>So it&#x27;s both similarly fragile, but one is almost never disabled.<p>The broader point is: For HLL runtimes you need to be able to switch between native and interpreted unwinds anyhow, so you&#x27;ll always do some amount of lifting in eBPF land.<p>And yes, having frame pointers removes a <i>lot</i> of complexity, so it&#x27;s net a very good thing. It&#x27;s just that the situation wasnt nearly as dire as described, because people that care about profiling had built solutions.</div><br/><div id="39733129" class="c"><input type="checkbox" id="c-39733129" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39733091">parent</a><span>|</span><a href="#39732998">next</a><span>|</span><label class="collapse" for="c-39733129">[-]</label><label class="expand" for="c-39733129">[3 more]</label></div><br/><div class="children"><div class="content">Forget eBPF even -- why do the job of userspace in the kernel? Instead of unwinding via eBPF, we should ask userspace to unwind itself using a synchronous signal delivered to userspace whenever we&#x27;ve requested a stack sample.</div><br/><div id="39734661" class="c"><input type="checkbox" id="c-39734661" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39733129">parent</a><span>|</span><a href="#39732998">next</a><span>|</span><label class="collapse" for="c-39734661">[-]</label><label class="expand" for="c-39734661">[2 more]</label></div><br/><div class="children"><div class="content">Context switches are incredibly expensive. Given the sampling rate of eBPF profilers all the useful information would get lost in the context switch noise.<p>Things get even more complicated because context switches can mean CPU migrations, making many of your data useless.</div><br/><div id="39734995" class="c"><input type="checkbox" id="c-39734995" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39734661">parent</a><span>|</span><a href="#39732998">next</a><span>|</span><label class="collapse" for="c-39734995">[-]</label><label class="expand" for="c-39734995">[1 more]</label></div><br/><div class="children"><div class="content">What makes you think doing unwinding in userspace would do any more context switches (by which I think you mean privilege level transitions) than we do today? See my other comment on the subject.<p>&gt; Things get even more complicated because context switches can mean CPU migrations, making many of your data useless.<p>No it doesn&#x27;t. If a user space thread is blocked on doing kernel work, its stack isn&#x27;t going to change, not even if that thread ends up resuming on a different thread.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39732998" class="c"><input type="checkbox" id="c-39732998" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39732497">parent</a><span>|</span><a href="#39733065">prev</a><span>|</span><a href="#39733725">next</a><span>|</span><label class="collapse" for="c-39732998">[-]</label><label class="expand" for="c-39732998">[4 more]</label></div><br/><div class="children"><div class="content">PolarSignals is specifically discussed in the linked threads, and they conclude that their approach is not good enough for perf reasons.</div><br/><div id="39733968" class="c"><input type="checkbox" id="c-39733968" checked=""/><div class="controls bullet"><span class="by">javierhonduco</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39732998">parent</a><span>|</span><a href="#39733097">next</a><span>|</span><label class="collapse" for="c-39733968">[-]</label><label class="expand" for="c-39733968">[2 more]</label></div><br/><div class="children"><div class="content">Curious to hear more about this. Full disclosure: I designed and implemented .eh_frame unwinding when I worked at Polar Signals.</div><br/><div id="39737633" class="c"><input type="checkbox" id="c-39737633" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39733968">parent</a><span>|</span><a href="#39733097">next</a><span>|</span><label class="collapse" for="c-39737633">[-]</label><label class="expand" for="c-39737633">[1 more]</label></div><br/><div class="children"><div class="content">I think I might have confused two unrelated posts. The one that references Polar Signals is this one:<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;freedesktop-sdk&#x2F;freedesktop-sdk&#x2F;-&#x2F;issues&#x2F;1437#note_1191710138" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;freedesktop-sdk&#x2F;freedesktop-sdk&#x2F;-&#x2F;issues&#x2F;...</a><p>So not a perf issue there, but they don&#x27;t think the workflow is suitable for whole-system profiling. Perf issues were in the context of `perf` using DWARF:<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;freedesktop-sdk&#x2F;freedesktop-sdk&#x2F;-&#x2F;issues&#x2F;1437#note_1027058853" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;freedesktop-sdk&#x2F;freedesktop-sdk&#x2F;-&#x2F;issues&#x2F;...</a></div><br/></div></div></div></div><div id="39733097" class="c"><input type="checkbox" id="c-39733097" checked=""/><div class="controls bullet"><span class="by">tdullien</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39732998">parent</a><span>|</span><a href="#39733968">prev</a><span>|</span><a href="#39733725">next</a><span>|</span><label class="collapse" for="c-39733097">[-]</label><label class="expand" for="c-39733097">[1 more]</label></div><br/><div class="children"><div class="content">Oh nice, I can&#x27;t find that - can you post a link?</div><br/></div></div></div></div><div id="39733725" class="c"><input type="checkbox" id="c-39733725" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#39732497">parent</a><span>|</span><a href="#39732998">prev</a><span>|</span><a href="#39732515">next</a><span>|</span><label class="collapse" for="c-39733725">[-]</label><label class="expand" for="c-39733725">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re sufficiently in control of your deployment details to ensure that BPF is available at all. CAP_SYS_PTRACE is available ~everywhere for everyone.</div><br/></div></div><div id="39732515" class="c"><input type="checkbox" id="c-39732515" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#39732497">parent</a><span>|</span><a href="#39733725">prev</a><span>|</span><a href="#39733174">next</a><span>|</span><label class="collapse" for="c-39732515">[-]</label><label class="expand" for="c-39732515">[3 more]</label></div><br/><div class="children"><div class="content">You mean we don‘t need accessible profiling in free software because there are companies selling it to us. Cool.</div><br/><div id="39732930" class="c"><input type="checkbox" id="c-39732930" checked=""/><div class="controls bullet"><span class="by">tdullien</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39732515">parent</a><span>|</span><a href="#39732646">next</a><span>|</span><label class="collapse" for="c-39732930">[-]</label><label class="expand" for="c-39732930">[1 more]</label></div><br/><div class="children"><div class="content">Parca is open-source, Prodfiler&#x27;s eBPF code is GPL, and the rest of Prodfiler is currently going through OTel donation, so my point is: There&#x27;s now multiple FOSS implementations of a more generic and powerful technique.</div><br/></div></div><div id="39732646" class="c"><input type="checkbox" id="c-39732646" checked=""/><div class="controls bullet"><span class="by">brancz</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39732515">parent</a><span>|</span><a href="#39732930">prev</a><span>|</span><a href="#39733174">next</a><span>|</span><label class="collapse" for="c-39732646">[-]</label><label class="expand" for="c-39732646">[1 more]</label></div><br/><div class="children"><div class="content">Parca&#x27;s user-space code is apache2 and the eBPF code is GPL.</div><br/></div></div></div></div><div id="39733174" class="c"><input type="checkbox" id="c-39733174" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#39732497">parent</a><span>|</span><a href="#39732515">prev</a><span>|</span><a href="#39732938">next</a><span>|</span><label class="collapse" for="c-39733174">[-]</label><label class="expand" for="c-39733174">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m under the impression that eh_frame stack traces are much slower than frame pointer stack traces, which makes always-on profiling, such as seen in tcmalloc, impractical.</div><br/></div></div></div></div><div id="39732938" class="c"><input type="checkbox" id="c-39732938" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#39732497">prev</a><span>|</span><a href="#39734014">next</a><span>|</span><label class="collapse" for="c-39732938">[-]</label><label class="expand" for="c-39732938">[3 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t detract from the content at all but the register counts are off; SI and DI count as GPRs on i686 bringing it to 6+BP (not 4+BP) meanwhile x86_64 has 14+BP (not 16+BP).</div><br/><div id="39733921" class="c"><input type="checkbox" id="c-39733921" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#39732938">parent</a><span>|</span><a href="#39734014">next</a><span>|</span><label class="collapse" for="c-39733921">[-]</label><label class="expand" for="c-39733921">[2 more]</label></div><br/><div class="children"><div class="content">&gt; [...] on i686 bringing it to 6+BP (not 4+BP) meanwhile x86_64 has 14+BP (not 16+BP).<p>That is, on i686 you have 7 GPRs without frame pointers, while on x86_64 you have 14 GPRs even with frame pointers.<p>Copying a comment of mine from an older related discussion (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38632848">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38632848</a>):<p>&quot;To emphasize this point: on 64-bit x86 with frame pointers, you have twice as many registers as on 32-bit x86 without frame pointers, and these registers are twice as wide. A 64-bit value (more common than you&#x27;d expect even when pointers are 32 bits) takes two registers on 32-bit x86, but only a single register on 64-bit x86.&quot;</div><br/><div id="39734125" class="c"><input type="checkbox" id="c-39734125" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#39732938">root</a><span>|</span><a href="#39733921">parent</a><span>|</span><a href="#39734014">next</a><span>|</span><label class="collapse" for="c-39734125">[-]</label><label class="expand" for="c-39734125">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div></div></div><div id="39734014" class="c"><input type="checkbox" id="c-39734014" checked=""/><div class="controls bullet"><span class="by">shaggie76</span><span>|</span><a href="#39732938">prev</a><span>|</span><a href="#39735642">next</a><span>|</span><label class="collapse" for="c-39734014">[-]</label><label class="expand" for="c-39734014">[6 more]</label></div><br/><div class="children"><div class="content">I thought we&#x27;d been using &#x2F;Oy (Frame-Pointer Omission) for years on Windows and that there was a pdata section on x64 that was used for stack-walking however to my great surprise I just read on MSDN that &quot;In x64 compilers, &#x2F;Oy and &#x2F;Oy- are not available.&quot;<p>Does this mean Microsoft decided they weren&#x27;t going to support breaking profilers and debuggers OR is there some magic in the pdata section that makes it work even if you omit the frame-pointer?</div><br/><div id="39734383" class="c"><input type="checkbox" id="c-39734383" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#39734014">parent</a><span>|</span><a href="#39735920">next</a><span>|</span><label class="collapse" for="c-39734383">[-]</label><label class="expand" for="c-39734383">[1 more]</label></div><br/><div class="children"><div class="content">Some Google found this: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20130906-00&#x2F;?p=3303" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20130906-00&#x2F;?p=33...</a><p>“Recovering a broken stack on x64 machines on Windows is trickier because the x64 uses unwind codes for stack walking rather than a frame pointer chain.”<p>More details are here: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;exception-handling-x64?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;exception-handli...</a></div><br/></div></div><div id="39735920" class="c"><input type="checkbox" id="c-39735920" checked=""/><div class="controls bullet"><span class="by">musjleman</span><span>|</span><a href="#39734014">parent</a><span>|</span><a href="#39734383">prev</a><span>|</span><a href="#39740226">next</a><span>|</span><label class="collapse" for="c-39735920">[-]</label><label class="expand" for="c-39735920">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In x64 compilers<p>The default is omission. If you have a Windows machine, in all likelihood almost no 64 bit code running on it has frame pointers.<p>&gt; OR is there some magic in the pdata section that makes it work even if you omit the frame-pointer<p>You haven&#x27;t ever needed frame pointers to unwind using ... unwind information. The same thing exists for linux as `.eh_frame` section.</div><br/></div></div><div id="39740226" class="c"><input type="checkbox" id="c-39740226" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#39734014">parent</a><span>|</span><a href="#39735920">prev</a><span>|</span><a href="#39735038">next</a><span>|</span><label class="collapse" for="c-39740226">[-]</label><label class="expand" for="c-39740226">[1 more]</label></div><br/><div class="children"><div class="content">MS had unwinding support done right for a LONG time, 32 and 64, starting with structured C exceptions</div><br/></div></div><div id="39735038" class="c"><input type="checkbox" id="c-39735038" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#39734014">parent</a><span>|</span><a href="#39740226">prev</a><span>|</span><a href="#39735642">next</a><span>|</span><label class="collapse" for="c-39735038">[-]</label><label class="expand" for="c-39735038">[2 more]</label></div><br/><div class="children"><div class="content">Microsoft has had excellent universal unwinding support for decades now. I&#x27;m disappointed to see someone as prominent as this article&#x27;s author present as infeasible what Microsoft has had working for so long.</div><br/><div id="39740227" class="c"><input type="checkbox" id="c-39740227" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#39734014">root</a><span>|</span><a href="#39735038">parent</a><span>|</span><a href="#39735642">next</a><span>|</span><label class="collapse" for="c-39740227">[-]</label><label class="expand" for="c-39740227">[1 more]</label></div><br/><div class="children"><div class="content">exactly! starting with C structured exceptions</div><br/></div></div></div></div></div></div><div id="39735642" class="c"><input type="checkbox" id="c-39735642" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#39734014">prev</a><span>|</span><a href="#39733477">next</a><span>|</span><label class="collapse" for="c-39735642">[-]</label><label class="expand" for="c-39735642">[4 more]</label></div><br/><div class="children"><div class="content">All of this information is static, there&#x27;s no need to sacrifice a whole CPU register only to store data that&#x27;s already known. A simple lookup data structure that maps an instruction address range to the stack offset of the return address should be enough to recover the stack layout. On Windows, you&#x27;d precompute that from PDB files, I&#x27;m sure you can do the same thing with whatever the equivalent debug data structure is on Linux.</div><br/><div id="39736222" class="c"><input type="checkbox" id="c-39736222" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39735642">parent</a><span>|</span><a href="#39735657">next</a><span>|</span><label class="collapse" for="c-39736222">[-]</label><label class="expand" for="c-39736222">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t entirely static because of alloca().</div><br/></div></div><div id="39735657" class="c"><input type="checkbox" id="c-39735657" checked=""/><div class="controls bullet"><span class="by">fsmv</span><span>|</span><a href="#39735642">parent</a><span>|</span><a href="#39736222">prev</a><span>|</span><a href="#39733477">next</a><span>|</span><label class="collapse" for="c-39735657">[-]</label><label class="expand" for="c-39735657">[2 more]</label></div><br/><div class="children"><div class="content">[deleted]</div><br/></div></div></div></div><div id="39733477" class="c"><input type="checkbox" id="c-39733477" checked=""/><div class="controls bullet"><span class="by">tkiolp4</span><span>|</span><a href="#39735642">prev</a><span>|</span><a href="#39732154">next</a><span>|</span><label class="collapse" for="c-39733477">[-]</label><label class="expand" for="c-39733477">[3 more]</label></div><br/><div class="children"><div class="content">Are his books (the one about Systems Performance and eBPF) relevant for normal software engineers who want to improve performance in normal services? I don’t work for faang, and our usual performance issues are solved by adding indexes here and there, caching, and simple code analysis. Tools like Datadog help a lot already.</div><br/><div id="39735625" class="c"><input type="checkbox" id="c-39735625" checked=""/><div class="controls bullet"><span class="by">polio</span><span>|</span><a href="#39733477">parent</a><span>|</span><a href="#39735536">next</a><span>|</span><label class="collapse" for="c-39735625">[-]</label><label class="expand" for="c-39735625">[1 more]</label></div><br/><div class="children"><div class="content">Profiling is a pretty basic technique that is applicable to all software engineering. I&#x27;m not sure what a &quot;normal&quot; service is here, but I think we all have an obligation to understand what&#x27;s happening in the systems we own.<p>Some people may believe that 100ms latency is acceptable for a CLI tool, but what if it could be 3ms? On some aesthetic level, it also feels good to be able to eliminate excess. Finally, you should learn it because you won&#x27;t necessarily have that job forever.</div><br/></div></div><div id="39735536" class="c"><input type="checkbox" id="c-39735536" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#39733477">parent</a><span>|</span><a href="#39735625">prev</a><span>|</span><a href="#39732154">next</a><span>|</span><label class="collapse" for="c-39735536">[-]</label><label class="expand" for="c-39735536">[1 more]</label></div><br/><div class="children"><div class="content">Diving into flame graphs being worthwhile for optimization, assumes that your workload is CPU-bound. Most business software does not have such workloads, and rather (as you yourself have noted) spend most of their time waiting for I&#x2F;O (database, network, filesystem, etc).<p>And so, (as you again have noted), your best bet is to just use plain old logging and tracing (like what datadog provides) to find out where the waiting is happening.</div><br/></div></div></div></div><div id="39732154" class="c"><input type="checkbox" id="c-39732154" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39733477">prev</a><span>|</span><a href="#39735777">next</a><span>|</span><label class="collapse" for="c-39732154">[-]</label><label class="expand" for="c-39732154">[1 more]</label></div><br/><div class="children"><div class="content">Guess I&#x27;ll add it back in to the DMD code generator!</div><br/></div></div><div id="39735777" class="c"><input type="checkbox" id="c-39735777" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#39732154">prev</a><span>|</span><a href="#39738238">next</a><span>|</span><label class="collapse" for="c-39735777">[-]</label><label class="expand" for="c-39735777">[1 more]</label></div><br/><div class="children"><div class="content">I started programming in 1979, and I can&#x27;t believe I&#x27;ve managed to avoid learning about stack frames all those EBP register tricks until now. I always had parameters to functions in registers, not on the stack, for the most part. The compiler hid a lot of things from me.<p>Is it because I avoided Linux and C most of my life? Perhaps it&#x27;s because I used debug, and Periscope before that... and never gdb?</div><br/></div></div><div id="39738238" class="c"><input type="checkbox" id="c-39738238" checked=""/><div class="controls bullet"><span class="by">BinaryRage</span><span>|</span><a href="#39735777">prev</a><span>|</span><a href="#39732010">next</a><span>|</span><label class="collapse" for="c-39738238">[-]</label><label class="expand" for="c-39738238">[1 more]</label></div><br/><div class="children"><div class="content">I remember talking to Brendan about the PreserveFramePointer patch during my first months at Netflix in 2015. As of JDK 21, unfortunately it is no longer a general purpose solution for the JVM, because it prevents a fast path being taken for stack thawing for virtual threads: <a href="https:&#x2F;&#x2F;github.com&#x2F;openjdk&#x2F;jdk&#x2F;blob&#x2F;d32ce65781c1d7815a69ceac720cdf3ae39caa9e&#x2F;src&#x2F;hotspot&#x2F;share&#x2F;runtime&#x2F;continuationFreezeThaw.cpp#L1807">https:&#x2F;&#x2F;github.com&#x2F;openjdk&#x2F;jdk&#x2F;blob&#x2F;d32ce65781c1d7815a69ceac...</a></div><br/></div></div><div id="39732010" class="c"><input type="checkbox" id="c-39732010" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#39738238">prev</a><span>|</span><a href="#39733721">next</a><span>|</span><label class="collapse" for="c-39732010">[-]</label><label class="expand" for="c-39732010">[13 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another option: <a href="https:&#x2F;&#x2F;lesenechal.fr&#x2F;en&#x2F;linux&#x2F;unwinding-the-stack-the-hard-way" rel="nofollow">https:&#x2F;&#x2F;lesenechal.fr&#x2F;en&#x2F;linux&#x2F;unwinding-the-stack-the-hard-...</a></div><br/><div id="39732056" class="c"><input type="checkbox" id="c-39732056" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39732010">parent</a><span>|</span><a href="#39733233">next</a><span>|</span><label class="collapse" for="c-39732056">[-]</label><label class="expand" for="c-39732056">[9 more]</label></div><br/><div class="children"><div class="content">Brendan mentions DWARF unwinding, actually, and briefly mentions why he considers it insufficient.</div><br/><div id="39732199" class="c"><input type="checkbox" id="c-39732199" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732056">parent</a><span>|</span><a href="#39733233">next</a><span>|</span><label class="collapse" for="c-39732199">[-]</label><label class="expand" for="c-39732199">[8 more]</label></div><br/><div class="children"><div class="content">The biggest objection seems to be the Java&#x2F;JIT case.  eh_frame supports a &quot;personality function&quot; which is AIUI basically a callback for performing custom unwinding.  If the personality function could also support custom logic for producing backtraces, then the profiling sampler could effectively read the JVM&#x27;s own metadata about the JIT&#x27;ted code, which I assume it must have in order to produce backtraces for the JVM itself.</div><br/><div id="39732340" class="c"><input type="checkbox" id="c-39732340" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732199">parent</a><span>|</span><a href="#39733233">next</a><span>|</span><label class="collapse" for="c-39732340">[-]</label><label class="expand" for="c-39732340">[7 more]</label></div><br/><div class="children"><div class="content">This also seems like a big objection:<p>&gt; The overhead to walk DWARF is also too high, as it was designed for non-realtime use.</div><br/><div id="39732769" class="c"><input type="checkbox" id="c-39732769" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732340">parent</a><span>|</span><a href="#39735331">next</a><span>|</span><label class="collapse" for="c-39732769">[-]</label><label class="expand" for="c-39732769">[4 more]</label></div><br/><div class="children"><div class="content">Not a problem in practice. The way you solve it is to just translate DWARF into a simpler representation that doesn&#x27;t require you to walk anything. (But I understand why people don&#x27;t want to do it. DWARF is insanely complex and annoying to deal with.)<p>Source: I wrote multiple profilers.</div><br/><div id="39739687" class="c"><input type="checkbox" id="c-39739687" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732769">parent</a><span>|</span><a href="#39735950">next</a><span>|</span><label class="collapse" for="c-39739687">[-]</label><label class="expand" for="c-39739687">[1 more]</label></div><br/><div class="children"><div class="content">For a busy 64-CPU production JVM, I tested Google&#x27;s Java symbol logging agent that just logged timestamp, symbol, address, size. The c2 compiler was so busy, constantly, that the overhead of this was too high to be practical (beyond startup analysis). And all this was generating was a timestamp log to do symbol lookup. For DWARF to walk stacks there&#x27;s a lot more steps, so while I could see it work for light workloads I doubt it&#x27;s practical for the heavy production workloads I typically analyze. What do you think? Have you tested on a large production server where c2 is a measurable portion of CPU constantly, the code cache is &gt;1Gbyte and under heavy load?</div><br/></div></div><div id="39735950" class="c"><input type="checkbox" id="c-39735950" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732769">parent</a><span>|</span><a href="#39739687">prev</a><span>|</span><a href="#39735331">next</a><span>|</span><label class="collapse" for="c-39735950">[-]</label><label class="expand" for="c-39735950">[2 more]</label></div><br/><div class="children"><div class="content">In this thread[1] we&#x27;re discussing problems with using DWARF directly for unwinding, not possible translations of the metadata into other formats (like ORC or whatever).<p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39732010">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39732010</a></div><br/><div id="39736324" class="c"><input type="checkbox" id="c-39736324" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39735950">parent</a><span>|</span><a href="#39735331">next</a><span>|</span><label class="collapse" for="c-39736324">[-]</label><label class="expand" for="c-39736324">[1 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t talking about other formats. I was talking about preloading the information contained in DWARF into a more efficient in-memory representation once when your profiler starts, and then the problem of &quot;the overhead is too high for realtime use&quot; disappears.</div><br/></div></div></div></div></div></div><div id="39735331" class="c"><input type="checkbox" id="c-39735331" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732340">parent</a><span>|</span><a href="#39732769">prev</a><span>|</span><a href="#39733131">next</a><span>|</span><label class="collapse" for="c-39735331">[-]</label><label class="expand" for="c-39735331">[1 more]</label></div><br/><div class="children"><div class="content">But that one has at least some potential mitigation.  Per his analysis, the Java&#x2F;JIT case is the only one that has no mitigation:<p>&gt; Javier Honduvilla Coto (Polar Signals) did some interesting work using an eBPF walker to reduce the overhead, but...Java.</div><br/></div></div><div id="39733131" class="c"><input type="checkbox" id="c-39733131" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732340">parent</a><span>|</span><a href="#39735331">prev</a><span>|</span><a href="#39733233">next</a><span>|</span><label class="collapse" for="c-39733131">[-]</label><label class="expand" for="c-39733131">[1 more]</label></div><br/><div class="children"><div class="content">From <a href="https:&#x2F;&#x2F;fzn.fr&#x2F;projects&#x2F;frdwarf&#x2F;frdwarf-oopsla19.pdf" rel="nofollow">https:&#x2F;&#x2F;fzn.fr&#x2F;projects&#x2F;frdwarf&#x2F;frdwarf-oopsla19.pdf</a><p><pre><code>    DWARF-based unwinding can be a bottleneck for time-sensitive program analysis tools. For instance the perf profiler is forced to copy the whole stack on taking each sample and to build the backtraces offline: this solution has a memory and time overhead but also serious confidentiality and security flaws.
</code></pre>
So if I get this correctly, the problem with DWARF is that building the backtrace online (on each sample) in comparison to frame pointers is an expensive operation which, however, can be mitigated by building the backtrace offline at the expense of copying the stack.<p>However, paper also mentions<p><pre><code>    Similarly, the Linux kernel by default relies on a frame pointer to provide reliable backtraces. This incurs in a space and time overhead; for instance it has been reported (https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;727553&#x2F;) that the kernel’s .text size increases by about 3.2%, resulting in a broad kernel-wide slowdown.
</code></pre>
and<p><pre><code>    Measurements have shown a slowdown of 5-10% for some workloads (https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;20170602104048.jkkzssljsompjdwy@suse.de&#x2F;T&#x2F;#u).</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="39733233" class="c"><input type="checkbox" id="c-39733233" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39732010">parent</a><span>|</span><a href="#39732056">prev</a><span>|</span><a href="#39733721">next</a><span>|</span><label class="collapse" for="c-39733233">[-]</label><label class="expand" for="c-39733233">[3 more]</label></div><br/><div class="children"><div class="content">DWARF unwinding isn&#x27;t practical: <a href="https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2023&#x2F;02&#x2F;14&#x2F;frame-pointers-vs-dwarf-my-verdict&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2023&#x2F;02&#x2F;14&#x2F;frame-pointers-vs-dwar...</a></div><br/><div id="39733439" class="c"><input type="checkbox" id="c-39733439" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39733233">parent</a><span>|</span><a href="#39733721">next</a><span>|</span><label class="collapse" for="c-39733439">[-]</label><label class="expand" for="c-39733439">[2 more]</label></div><br/><div class="children"><div class="content">TBH this sounds more like perf&#x27;s implementation is bad.<p>I&#x27;m waiting for this to happen: <a href="https:&#x2F;&#x2F;github.com&#x2F;open-telemetry&#x2F;community&#x2F;issues&#x2F;1918">https:&#x2F;&#x2F;github.com&#x2F;open-telemetry&#x2F;community&#x2F;issues&#x2F;1918</a></div><br/><div id="39734016" class="c"><input type="checkbox" id="c-39734016" checked=""/><div class="controls bullet"><span class="by">javierhonduco</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39733439">parent</a><span>|</span><a href="#39733721">next</a><span>|</span><label class="collapse" for="c-39734016">[-]</label><label class="expand" for="c-39734016">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s always room for improvement, for example, Samply [0] is a wonderful profiler that uses the same APIs that `perf` uses, but unwinds the stacks as they come rather than dumping them all to disk and then having to process them in bulk.<p>Samply unwinds significantly faster than `perf` because it caches unwind information.<p>That being said, this approach still has some limitations, such as that very deep stacks won&#x27;t be unwound, as the size of the process stack the kernel sends is quite limited.<p>- [0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;mstange&#x2F;samply">https:&#x2F;&#x2F;github.com&#x2F;mstange&#x2F;samply</a></div><br/></div></div></div></div></div></div></div></div><div id="39733721" class="c"><input type="checkbox" id="c-39733721" checked=""/><div class="controls bullet"><span class="by">tzot</span><span>|</span><a href="#39732010">prev</a><span>|</span><a href="#39733200">next</a><span>|</span><label class="collapse" for="c-39733721">[-]</label><label class="expand" for="c-39733721">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure, but I believe -fomit-frame-pointer in x86-64 allows the compiler to use a _thirteenth_ register, not a _seventeenth_ .</div><br/></div></div><div id="39733200" class="c"><input type="checkbox" id="c-39733200" checked=""/><div class="controls bullet"><span class="by">zzbn00</span><span>|</span><a href="#39733721">prev</a><span>|</span><a href="#39732661">next</a><span>|</span><label class="collapse" for="c-39733200">[-]</label><label class="expand" for="c-39733200">[1 more]</label></div><br/><div class="children"><div class="content">NiX (and I assume Guix) are very convenient for this as it is fairly easy to turn frame pointers on or off for parts or whole of the system.</div><br/></div></div><div id="39732661" class="c"><input type="checkbox" id="c-39732661" checked=""/><div class="controls bullet"><span class="by">5-</span><span>|</span><a href="#39733200">prev</a><span>|</span><a href="#39737785">next</a><span>|</span><label class="collapse" for="c-39732661">[-]</label><label class="expand" for="c-39732661">[9 more]</label></div><br/><div class="children"><div class="content">so what is the downside to using e.g. dwarf-based stack walking (supported by perf) for libc, which was the original stated problem?<p>in the discussion the issue gets conflated with jit-ted languages, but that has nothing to do with the crusade to enable frame pointer for system libraries.<p>and if you care that much for dwarf overhead... just cache the unwind information in your system-level profiler? no need to rebuild everything.</div><br/><div id="39732842" class="c"><input type="checkbox" id="c-39732842" checked=""/><div class="controls bullet"><span class="by">brancz</span><span>|</span><a href="#39732661">parent</a><span>|</span><a href="#39733238">next</a><span>|</span><label class="collapse" for="c-39732842">[-]</label><label class="expand" for="c-39732842">[5 more]</label></div><br/><div class="children"><div class="content">The way perf does it is slow, as the entire stack is copied into user-space and is then asynchronously unwound.<p>This is solvable as Brendan calls out, we’ve created an eBPF-based profiler at Polar Signals, that essentially does what you said, it optimized the unwind tables, caches them in bpf maps, and then synchronously unwinds as opposed to copying the whole stack into user-space.</div><br/><div id="39733930" class="c"><input type="checkbox" id="c-39733930" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#39732661">root</a><span>|</span><a href="#39732842">parent</a><span>|</span><a href="#39733674">next</a><span>|</span><label class="collapse" for="c-39733930">[-]</label><label class="expand" for="c-39733930">[2 more]</label></div><br/><div class="children"><div class="content">It should also be said that you need some sort of DWARF-like information to understand inlining. If I have a function A that inlines B that in turn inlines C, I&#x27;d often like to understand that C takes a bunch of time, and with frame pointers only, that information gets lost.</div><br/><div id="39733989" class="c"><input type="checkbox" id="c-39733989" checked=""/><div class="controls bullet"><span class="by">javierhonduco</span><span>|</span><a href="#39732661">root</a><span>|</span><a href="#39733930">parent</a><span>|</span><a href="#39733674">next</a><span>|</span><label class="collapse" for="c-39733989">[-]</label><label class="expand" for="c-39733989">[1 more]</label></div><br/><div class="children"><div class="content">Inlined functions can be symbolized using DWARF line information[0] while unwinding requires DWARF unwind information (CFI), which the x86_64 ABI mandates in every single ELF in the `.eh_frame` section<p>- [0] This line information might or might not be present in an executable but luckily there&#x27;s debuginfod (<a href="https:&#x2F;&#x2F;sourceware.org&#x2F;elfutils&#x2F;Debuginfod.html" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;elfutils&#x2F;Debuginfod.html</a>)</div><br/></div></div></div></div><div id="39733674" class="c"><input type="checkbox" id="c-39733674" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#39732661">root</a><span>|</span><a href="#39732842">parent</a><span>|</span><a href="#39733930">prev</a><span>|</span><a href="#39733238">next</a><span>|</span><label class="collapse" for="c-39733674">[-]</label><label class="expand" for="c-39733674">[2 more]</label></div><br/><div class="children"><div class="content">This conveniently sidesteps the whole issue of getting DWARF data in the first place, which is also still a broken disjointed mess on Linux. Hell, <i>Windows</i> solved this many many years ago.</div><br/><div id="39734707" class="c"><input type="checkbox" id="c-39734707" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#39732661">root</a><span>|</span><a href="#39733674">parent</a><span>|</span><a href="#39733238">next</a><span>|</span><label class="collapse" for="c-39734707">[-]</label><label class="expand" for="c-39734707">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d need a pretty special distro to have enabled -fno-asynchronous-unwind-tables by default in its toolchain.<p>By default on most Linux distros the frame tables are built into all the binaries, and end up in the GNU_EH_FRAME segment, which is always available in any running process. Doesn&#x27;t sound a broken and disjointed mess to me. Sounds more like a smoothly running solved problem.</div><br/></div></div></div></div></div></div><div id="39733238" class="c"><input type="checkbox" id="c-39733238" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39732661">parent</a><span>|</span><a href="#39732842">prev</a><span>|</span><a href="#39732828">next</a><span>|</span><label class="collapse" for="c-39733238">[-]</label><label class="expand" for="c-39733238">[1 more]</label></div><br/><div class="children"><div class="content">The downside is it doesn&#x27;t work at all: <a href="https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2023&#x2F;02&#x2F;14&#x2F;frame-pointers-vs-dwarf-my-verdict&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rwmj.wordpress.com&#x2F;2023&#x2F;02&#x2F;14&#x2F;frame-pointers-vs-dwar...</a></div><br/></div></div><div id="39732828" class="c"><input type="checkbox" id="c-39732828" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#39732661">parent</a><span>|</span><a href="#39733238">prev</a><span>|</span><a href="#39737785">next</a><span>|</span><label class="collapse" for="c-39732828">[-]</label><label class="expand" for="c-39732828">[2 more]</label></div><br/><div class="children"><div class="content">The article explains why DWARF is not an option.</div><br/><div id="39733010" class="c"><input type="checkbox" id="c-39733010" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#39732661">root</a><span>|</span><a href="#39732828">parent</a><span>|</span><a href="#39737785">next</a><span>|</span><label class="collapse" for="c-39733010">[-]</label><label class="expand" for="c-39733010">[1 more]</label></div><br/><div class="children"><div class="content">Extremely light on the details, and also conflates it with the JIT which makes it harder to understand the point, so I was wondering about the same thing as well.</div><br/></div></div></div></div></div></div><div id="39737785" class="c"><input type="checkbox" id="c-39737785" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39732661">prev</a><span>|</span><a href="#39739239">next</a><span>|</span><label class="collapse" for="c-39737785">[-]</label><label class="expand" for="c-39737785">[3 more]</label></div><br/><div class="children"><div class="content">To this day I still believe that there should be a dedicated protected separate stack region for the call stack that only the CPU can write to&#x2F;read from. Walking the stack then becomes trivially fast because you just need to do a very small memcpy. And stack memory overflows can never overwrite the return address.</div><br/><div id="39738671" class="c"><input type="checkbox" id="c-39738671" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#39737785">parent</a><span>|</span><a href="#39739239">next</a><span>|</span><label class="collapse" for="c-39738671">[-]</label><label class="expand" for="c-39738671">[2 more]</label></div><br/><div class="children"><div class="content">This is a thing; it&#x27;s called shadow call stack. Both ARM and now Intel have extensions for it.</div><br/><div id="39738761" class="c"><input type="checkbox" id="c-39738761" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39737785">root</a><span>|</span><a href="#39738671">parent</a><span>|</span><a href="#39739239">next</a><span>|</span><label class="collapse" for="c-39738761">[-]</label><label class="expand" for="c-39738761">[1 more]</label></div><br/><div class="children"><div class="content">But the shadow stack concept seems much dumber to me. Why write the address to the regular stack and the shadow stack and then compare? Why not only use the shadow stack and not put return addresses on the main stack at all.</div><br/></div></div></div></div></div></div><div id="39739239" class="c"><input type="checkbox" id="c-39739239" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#39737785">prev</a><span>|</span><a href="#39733531">next</a><span>|</span><label class="collapse" for="c-39739239">[-]</label><label class="expand" for="c-39739239">[1 more]</label></div><br/><div class="children"><div class="content">-fomit-frame-pointer Had serious performance improvements back in the day. I would always compile my own MySQL and PHP and save money on hardware.<p>But those days has 32bit processors with few registers.<p>Times change.</div><br/></div></div><div id="39733531" class="c"><input type="checkbox" id="c-39733531" checked=""/><div class="controls bullet"><span class="by">DaveFlater</span><span>|</span><a href="#39739239">prev</a><span>|</span><a href="#39733935">next</a><span>|</span><label class="collapse" for="c-39733531">[-]</label><label class="expand" for="c-39733531">[4 more]</label></div><br/><div class="children"><div class="content">GCC optimization causes the frame pointer push to move around, resulting in wrong call stacks.  &quot;Wontfix&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38896343">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38896343</a></div><br/><div id="39733567" class="c"><input type="checkbox" id="c-39733567" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#39733531">parent</a><span>|</span><a href="#39733935">next</a><span>|</span><label class="collapse" for="c-39733567">[-]</label><label class="expand" for="c-39733567">[3 more]</label></div><br/><div class="children"><div class="content">That was in 2012.  Does it still occur on modern GCC?<p>There definitely have been regressions with frame pointers being enabled, although we&#x27;ve fixed all the ones we&#x27;ve found in current (2024) Fedora.</div><br/><div id="39735194" class="c"><input type="checkbox" id="c-39735194" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39733531">root</a><span>|</span><a href="#39733567">parent</a><span>|</span><a href="#39738696">next</a><span>|</span><label class="collapse" for="c-39735194">[-]</label><label class="expand" for="c-39735194">[1 more]</label></div><br/><div class="children"><div class="content">I think so and I vaguely seem to recall -fno-schedule-insns2 being the only thing that fixes it. To get the full power of frame pointers and hackable binary, what I use is:<p><pre><code>    -fno-schedule-insns2
    -fno-omit-frame-pointers
    -fno-optimize-sibling-calls
    -mno-omit-leaf-frame-pointer
    -fpatchable-function-entry=18,16
    -fno-inline-functions-called-once
</code></pre>
The only flag that&#x27;s potentially problematic is -fno-optimize-sibling-calls since it breaks the optimal approach to writing interpreters and slows down code that&#x27;s written in a more mathematical style.</div><br/></div></div><div id="39738696" class="c"><input type="checkbox" id="c-39738696" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#39733531">root</a><span>|</span><a href="#39733567">parent</a><span>|</span><a href="#39735194">prev</a><span>|</span><a href="#39733935">next</a><span>|</span><label class="collapse" for="c-39738696">[-]</label><label class="expand" for="c-39738696">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure unwinding thumb generated by GCC is still non-unwindable via FPs. That&#x27;s been a pain.</div><br/></div></div></div></div></div></div><div id="39732949" class="c"><input type="checkbox" id="c-39732949" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#39733935">prev</a><span>|</span><a href="#39733839">next</a><span>|</span><label class="collapse" for="c-39732949">[-]</label><label class="expand" for="c-39732949">[1 more]</label></div><br/><div class="children"><div class="content">Brendan is such a treasure to the community (buy his book it’s great).<p>I wasn’t doing extreme performance stuff when -fomit-frame-pointer became the norm, so maybe it was a big win for enough people to be a sane default, but even that seems dubious: “just works” profiling is how you figure out when you’re in an extreme performance scenario (if you’re an SG14 WG type, you know it and are used to all the defaults being wrong for you).<p>I’m deeply grateful for all the legends who have worked on libunwind, gperf stuff, perftool, DTrace, eBPF: these are the too-often-unsung heroes of software that is still fast after decades of Moore’s law free-riding.<p>But they’ve been fighting an uphill battle against a weird alliance of people trying to game compiler benchmarks and the really irresponsible posture that “developer time is more expensive” which is only sometimes true and never true if you care about people on low-spec gear, which is the community of users who that is already the least-resourced part of the global community.<p>I’m fortunate enough to have a fairly modern desktop, laptop, and phone: for me it’s merely annoying that chat applications and music players and windowing systems offer nothing new except enshittification in terms of features while needing 10-100x the resources they did a decade ago.<p>But for half of my career and 2&#x2F;3rds of my time coding, I was on low-spec gear most of the time, and I would have been largely excluded if people didn’t care a lot about old computers back then.<p>I’m trying to help a couple of aspiring hackers get started right now it’s a real struggle to get their environments set up with limitations like Intel Macs and WSL2 as the Linux option (WSL2 is very cool but it’s not loved up enough by e.g. yarn projects).<p>If you want new hackers, you need to make things work well on older computers.<p>Thanks again Brendan et al!</div><br/></div></div><div id="39733839" class="c"><input type="checkbox" id="c-39733839" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#39732949">prev</a><span>|</span><a href="#39735410">next</a><span>|</span><label class="collapse" for="c-39733839">[-]</label><label class="expand" for="c-39733839">[2 more]</label></div><br/><div class="children"><div class="content">I disagree with this sentence of the article:<p>&quot;I could say that times have changed and now the original 2004 reasons for omitting frame pointers are no longer valid in 2024.&quot;<p>The original 2004 reason for omitting frame pointers is still valid in 2024: it&#x27;s still a big performance win on the register-starved 32-bit x86 architecture. What has changed is that the 32-bit x86 architecture is much less relevant nowadays (other than legacy software, for most people it&#x27;s only used for a small instant while starting up the firmware), and other common 32-bit architectures (like embedded 32-bit ARM) are not as register-starved as the 32-bit x86.</div><br/><div id="39734370" class="c"><input type="checkbox" id="c-39734370" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39733839">parent</a><span>|</span><a href="#39735410">next</a><span>|</span><label class="collapse" for="c-39734370">[-]</label><label class="expand" for="c-39734370">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what they were saying. You&#x27;re not disagreeing at all.</div><br/></div></div></div></div><div id="39735410" class="c"><input type="checkbox" id="c-39735410" checked=""/><div class="controls bullet"><span class="by">Cold_Miserable</span><span>|</span><a href="#39733839">prev</a><span>|</span><label class="collapse" for="c-39735410">[-]</label><label class="expand" for="c-39735410">[1 more]</label></div><br/><div class="children"><div class="content">Not interesting. Enter&#x2F;leave also does the same thing as your save&#x2F;restore rbp.<p>Far more interesting I recall there might be an instruction where rbp isn&#x27;t allowed.</div><br/></div></div></div></div></div></div></div></body></html>