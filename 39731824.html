<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710666065876" as="style"/><link rel="stylesheet" href="styles.css?v=1710666065876"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html">The return of the frame pointers</a> <span class="domain">(<a href="https://www.brendangregg.com">www.brendangregg.com</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>48 comments</span></div><br/><div><div id="39732893" class="c"><input type="checkbox" id="c-39732893" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39731989">next</a><span>|</span><label class="collapse" for="c-39732893">[-]</label><label class="expand" for="c-39732893">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one thing Apple did do right on ARM:<p>&gt; The frame pointer register (x29) must always address a valid frame record. Some functions — such as leaf functions or tail calls — may opt not to create an entry in this list. As a result, stack traces are always meaningful, even without debug information.<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;xcode&#x2F;writing-arm64-code-for-apple-platforms" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;xcode&#x2F;writing-arm6...</a></div><br/></div></div><div id="39731989" class="c"><input type="checkbox" id="c-39731989" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39732893">prev</a><span>|</span><a href="#39732311">next</a><span>|</span><label class="collapse" for="c-39731989">[-]</label><label class="expand" for="c-39731989">[11 more]</label></div><br/><div class="children"><div class="content">I was at Google in 2005 on the other side of the argument. My view back then was simple:<p>Even if $BIG_COMPANY makes a decision to compile everything with frame pointers, the rest of the community is not. So we&#x27;ll be stuck fighting an unwinnable argument with a much larger community. Turns out that it was a ~20 year argument.<p>I ended up writing some patches to make libunwind work for gperftools and maintained libunwind for some number of years as a consequence of that work.<p>Having moved on to other areas of computing, I&#x27;m now a passive observer. But it&#x27;s fascinating to read history from the other perspective.</div><br/><div id="39732079" class="c"><input type="checkbox" id="c-39732079" checked=""/><div class="controls bullet"><span class="by">starspangled</span><span>|</span><a href="#39731989">parent</a><span>|</span><a href="#39732339">next</a><span>|</span><label class="collapse" for="c-39732079">[-]</label><label class="expand" for="c-39732079">[9 more]</label></div><br/><div class="children"><div class="content">&gt; So we&#x27;ll be stuck fighting an unwinnable argument with a much larger community.<p>In what way would you be stuck? What functional problems does <i>adding</i> frame pointers introduce?</div><br/><div id="39732211" class="c"><input type="checkbox" id="c-39732211" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732079">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39732211">[-]</label><label class="expand" for="c-39732211">[3 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t talking about functional problems. It was a simple observation that big companies were not going to convince Linux distributors to add frame pointers anytime soon and that what those distributors do is relevant.<p>All of the companies involved believed that they were special and decided to build their own (poorly managed) distribution called &quot;third party code&quot; and having to deal with it was not my best experience working at these companies.</div><br/><div id="39732264" class="c"><input type="checkbox" id="c-39732264" checked=""/><div class="controls bullet"><span class="by">starspangled</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732211">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39732264">[-]</label><label class="expand" for="c-39732264">[2 more]</label></div><br/><div class="children"><div class="content">Oh, I just assumed you were talking about Google&#x27;s Linux distribution and applications it runs on its fleet. I must have mis-assumed. Re-reading... maybe you weren&#x27;t talking about any builds but just whether or not to oppose kernel and toolchain defaulting to omit frame pointers?</div><br/><div id="39732290" class="c"><input type="checkbox" id="c-39732290" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732264">parent</a><span>|</span><a href="#39732112">next</a><span>|</span><label class="collapse" for="c-39732290">[-]</label><label class="expand" for="c-39732290">[1 more]</label></div><br/><div class="children"><div class="content">Google didn&#x27;t have a Linux distribution for a long time (the one everyone used on the desktop was an outdated rpm based distro, we mostly ignored it for development purposes).<p>What existed was a x86 to x86 cross compilation environment and the libraries involved were manually imported by developers who needed that particular library.<p>My argument was about the cost of ensuring that those libraries were compiled with frame pointers when much of the open source community was defaulting to omit-fp.</div><br/></div></div></div></div></div></div><div id="39732112" class="c"><input type="checkbox" id="c-39732112" checked=""/><div class="controls bullet"><span class="by">tempay</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732079">parent</a><span>|</span><a href="#39732211">prev</a><span>|</span><a href="#39732523">next</a><span>|</span><label class="collapse" for="c-39732112">[-]</label><label class="expand" for="c-39732112">[4 more]</label></div><br/><div class="children"><div class="content">It “wastes” a register when you’re not actively using them. On x86 that can make a big difference, though with the added registers of x86_64 it much less significant.</div><br/><div id="39732182" class="c"><input type="checkbox" id="c-39732182" checked=""/><div class="controls bullet"><span class="by">charleshn</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732112">parent</a><span>|</span><a href="#39732138">next</a><span>|</span><label class="collapse" for="c-39732182">[-]</label><label class="expand" for="c-39732182">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just the loss of an architectural register, it&#x27;s also the added cost to the prologue&#x2F;epilogue.
Even on x86_64, it can make a difference, in particular for small functions, which might not be inlined for a variety of reasons.</div><br/></div></div><div id="39732138" class="c"><input type="checkbox" id="c-39732138" checked=""/><div class="controls bullet"><span class="by">starspangled</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732112">parent</a><span>|</span><a href="#39732182">prev</a><span>|</span><a href="#39732131">next</a><span>|</span><label class="collapse" for="c-39732138">[-]</label><label class="expand" for="c-39732138">[1 more]</label></div><br/><div class="children"><div class="content">Right, but I was asking about functional problems (being &quot;stuck&quot;), which sounded like a big issue for the choice.</div><br/></div></div><div id="39732131" class="c"><input type="checkbox" id="c-39732131" checked=""/><div class="controls bullet"><span class="by">nlewycky</span><span>|</span><a href="#39731989">root</a><span>|</span><a href="#39732112">parent</a><span>|</span><a href="#39732138">prev</a><span>|</span><a href="#39732523">next</a><span>|</span><label class="collapse" for="c-39732131">[-]</label><label class="expand" for="c-39732131">[1 more]</label></div><br/><div class="children"><div class="content">It caused a problem when building inline assembly heavy code that tried to use all the registers, frame pointer register included.</div><br/></div></div></div></div></div></div><div id="39732339" class="c"><input type="checkbox" id="c-39732339" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#39731989">parent</a><span>|</span><a href="#39732079">prev</a><span>|</span><a href="#39732311">next</a><span>|</span><label class="collapse" for="c-39732339">[-]</label><label class="expand" for="c-39732339">[1 more]</label></div><br/><div class="children"><div class="content">Please name the individuals who are blocking progress on frame pointers. It&#x27;s such a clear and obvious win that the rest of us should have the opportunity to persuade them. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34660813">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34660813</a></div><br/></div></div></div></div><div id="39732311" class="c"><input type="checkbox" id="c-39732311" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39731989">prev</a><span>|</span><a href="#39732938">next</a><span>|</span><label class="collapse" for="c-39732311">[-]</label><label class="expand" for="c-39732311">[4 more]</label></div><br/><div class="children"><div class="content">Of course, if you cede RBP to be a frame pointer, you may as well have two stacks, one which is pointed into by RBP and stores the activation frames, and the other one which is pointed into by RSP and stores the return addresses only. At this point, you don&#x27;t even need to &quot;walk the stack&quot; because the call stack is literally just a flat array of return addresses.<p>Why do we normally store the return addresses near to the local variables in the first place, again? There are so many downsides.</div><br/><div id="39732956" class="c"><input type="checkbox" id="c-39732956" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#39732311">parent</a><span>|</span><a href="#39732481">next</a><span>|</span><label class="collapse" for="c-39732956">[-]</label><label class="expand" for="c-39732956">[1 more]</label></div><br/><div class="children"><div class="content">Note the ‘shadow stacks’ CPU feature mentioned briefly in the article, though it’s more for security reasons. It’s pretty similar to what you describe.</div><br/></div></div><div id="39732481" class="c"><input type="checkbox" id="c-39732481" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39732311">parent</a><span>|</span><a href="#39732956">prev</a><span>|</span><a href="#39732938">next</a><span>|</span><label class="collapse" for="c-39732481">[-]</label><label class="expand" for="c-39732481">[2 more]</label></div><br/><div class="children"><div class="content">It simplifies storage management. A stack frame is a simple bump pointer which is always in cache and only one guard page for overflow, in your proposal you need two guard pages and double the stack manipulations and doubling the chance of a cache miss.</div><br/><div id="39732616" class="c"><input type="checkbox" id="c-39732616" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39732311">root</a><span>|</span><a href="#39732481">parent</a><span>|</span><a href="#39732938">next</a><span>|</span><label class="collapse" for="c-39732616">[-]</label><label class="expand" for="c-39732616">[1 more]</label></div><br/><div class="children"><div class="content">Yes, two guard pages are needed. No, the stack management stays the same: it&#x27;s just &quot;CALL func&quot; at the call site, &quot;SUB RBP, &lt;frame_size&gt;&quot; at the prologue and &quot;ADD RBP, &lt;frame_size&gt;; RET&quot; at the epilogue. As for chances of a cache miss... probably, but I guess you also double them up when you enable CFET&#x2F;Shadow Stack so eh.<p>In exchange, it becomes very difficult for the stack smashing to corrupt the return address.</div><br/></div></div></div></div></div></div><div id="39732938" class="c"><input type="checkbox" id="c-39732938" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#39732311">prev</a><span>|</span><a href="#39732949">next</a><span>|</span><label class="collapse" for="c-39732938">[-]</label><label class="expand" for="c-39732938">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t detract from the content at all but the register counts are off; SI and DI count as GPRs on i686 bringing it to 6+BP (not 4+BP) meanwhile x86_64 has 14+BP (not 16+BP).</div><br/></div></div><div id="39732949" class="c"><input type="checkbox" id="c-39732949" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#39732938">prev</a><span>|</span><a href="#39732360">next</a><span>|</span><label class="collapse" for="c-39732949">[-]</label><label class="expand" for="c-39732949">[1 more]</label></div><br/><div class="children"><div class="content">Brendan is such a treasure to the community (buy his book it’s great).<p>I wasn’t doing extreme performance stuff when -fomit-frame-pointer became the norm, so maybe it was a big win for enough people to be a sane default, but even that seems dubious: “just works” profiling is how you figure out when you’re in an extreme performance scenario (if you’re an SG14 WG type, you know it and are used to all the defaults being wrong for you).<p>I’m deeply grateful for all the legends who have worked on libunwind, gperf stuff, perftool, DTrace, eBPF: these are the too-often-unsung heroes of software that is still fast after decades of Moore’s law free-riding.<p>But they’ve been fighting an uphill battle against a weird alliance of people trying to game compiler benchmarks and the really irresponsible posture that “developer time is more expensive” which is only sometimes true and never true if you care about people on low-spec gear, which is the community of users who that is already the least-resourced part of the global community.<p>I’m fortunate enough to have a fairly modern desktop, laptop, and phone: for me it’s merely annoying that chat applications and music players and windowing systems offer nothing new except enshittification in terms of features while needing 10-100x the resources they did a decade ago.<p>But for half of my career and 2&#x2F;3rds of my time coding, I was on low-spec gear most of the time, and I would have been largely excluded if people didn’t care a lot about old computers back then.<p>I’m trying to help a couple of aspiring hackers get started right now it’s a real struggle to get their environments set up with limitations like Intel Macs and WSL2 as the Linux option (WSL2 is very cool but it’s not loved up enough by e.g. yarn projects).<p>If you want new hackers, you need to make things work well on older computers.<p>Thanks again Brendan et al!</div><br/></div></div><div id="39732360" class="c"><input type="checkbox" id="c-39732360" checked=""/><div class="controls bullet"><span class="by">claytonwramsey</span><span>|</span><a href="#39732949">prev</a><span>|</span><a href="#39732022">next</a><span>|</span><label class="collapse" for="c-39732360">[-]</label><label class="expand" for="c-39732360">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very interesting to me - I had seen the `[unknown]` mountain in my profiles but never knew why. I think it&#x27;s a tough thing to justify: 2% performance is actually a pretty big difference.<p>It would be really nice to have fine-grained control over frame pointer inclusion: provided fine-grained profiling, we could determine whether we needed the frame pointers for a given function or compilation unit. I wouldn&#x27;t be surprised if we see that only a handful of operations are dramatically slowed by frame pointer inclusion while the rest don&#x27;t really care.</div><br/><div id="39732491" class="c"><input type="checkbox" id="c-39732491" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39732360">parent</a><span>|</span><a href="#39732514">next</a><span>|</span><label class="collapse" for="c-39732491">[-]</label><label class="expand" for="c-39732491">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 2% performance is actually a pretty big difference.<p>No it&#x27;s not, particularly when it can help you identify hotspots via profiling that can net you improvements of 10% or more.</div><br/></div></div><div id="39732514" class="c"><input type="checkbox" id="c-39732514" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39732360">parent</a><span>|</span><a href="#39732491">prev</a><span>|</span><a href="#39732022">next</a><span>|</span><label class="collapse" for="c-39732514">[-]</label><label class="expand" for="c-39732514">[1 more]</label></div><br/><div class="children"><div class="content">It’s usually a lot less than 2%.</div><br/></div></div></div></div><div id="39732022" class="c"><input type="checkbox" id="c-39732022" checked=""/><div class="controls bullet"><span class="by">dap</span><span>|</span><a href="#39732360">prev</a><span>|</span><a href="#39732497">next</a><span>|</span><label class="collapse" for="c-39732022">[-]</label><label class="expand" for="c-39732022">[1 more]</label></div><br/><div class="children"><div class="content">Good post!<p>&gt; Profiling has been broken for 20 years and we&#x27;ve only now just fixed it.<p>It was a shame when they went away.  Lots of people, certainly on other systems and probably Linux too, have found the absence of frame pointers painful this whole time and tried to keep them available in as many environments as possible.  It’s validating (if also kind of frustrating) to see mainstream Linux bring them back.</div><br/></div></div><div id="39732497" class="c"><input type="checkbox" id="c-39732497" checked=""/><div class="controls bullet"><span class="by">tdullien</span><span>|</span><a href="#39732022">prev</a><span>|</span><a href="#39732010">next</a><span>|</span><label class="collapse" for="c-39732497">[-]</label><label class="expand" for="c-39732497">[4 more]</label></div><br/><div class="children"><div class="content">As much as the return of frame pointers is a good thing, it&#x27;s largely unnecessary -- it arrives at a point where multiple eBPF-based profilers are available that do fine using .eh_frame and also manually unwinding high level language runtime stacks: Both Parca from PolarSignals as well the artist formerly known as Prodfiler (now Elastic Universal Profiling) do fine.<p>So this is a solution for a problem, and it arrives just at the moment that people have solved the problem more generically ;)<p>(Prodfiler coauthor here, we had solved all of this by the time we launched in Summer 2021)</div><br/><div id="39732515" class="c"><input type="checkbox" id="c-39732515" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#39732497">parent</a><span>|</span><a href="#39732010">next</a><span>|</span><label class="collapse" for="c-39732515">[-]</label><label class="expand" for="c-39732515">[3 more]</label></div><br/><div class="children"><div class="content">You mean we don‘t need accessible profiling in free software because there are companies selling it to us. Cool.</div><br/><div id="39732930" class="c"><input type="checkbox" id="c-39732930" checked=""/><div class="controls bullet"><span class="by">tdullien</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39732515">parent</a><span>|</span><a href="#39732646">next</a><span>|</span><label class="collapse" for="c-39732930">[-]</label><label class="expand" for="c-39732930">[1 more]</label></div><br/><div class="children"><div class="content">Parca is open-source, Prodfiler&#x27;s eBPF code is GPL, and the rest of Prodfiler is currently going through OTel donation, so my point is: There&#x27;s now multiple FOSS implementations of a more generic and powerful technique.</div><br/></div></div><div id="39732646" class="c"><input type="checkbox" id="c-39732646" checked=""/><div class="controls bullet"><span class="by">brancz</span><span>|</span><a href="#39732497">root</a><span>|</span><a href="#39732515">parent</a><span>|</span><a href="#39732930">prev</a><span>|</span><a href="#39732010">next</a><span>|</span><label class="collapse" for="c-39732646">[-]</label><label class="expand" for="c-39732646">[1 more]</label></div><br/><div class="children"><div class="content">Parca&#x27;s user-space code is apache2 and the eBPF code is GPL.</div><br/></div></div></div></div></div></div><div id="39732010" class="c"><input type="checkbox" id="c-39732010" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#39732497">prev</a><span>|</span><a href="#39732661">next</a><span>|</span><label class="collapse" for="c-39732010">[-]</label><label class="expand" for="c-39732010">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another option: <a href="https:&#x2F;&#x2F;lesenechal.fr&#x2F;en&#x2F;linux&#x2F;unwinding-the-stack-the-hard-way" rel="nofollow">https:&#x2F;&#x2F;lesenechal.fr&#x2F;en&#x2F;linux&#x2F;unwinding-the-stack-the-hard-...</a></div><br/><div id="39732056" class="c"><input type="checkbox" id="c-39732056" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39732010">parent</a><span>|</span><a href="#39732661">next</a><span>|</span><label class="collapse" for="c-39732056">[-]</label><label class="expand" for="c-39732056">[4 more]</label></div><br/><div class="children"><div class="content">Brendan mentions DWARF unwinding, actually, and briefly mentions why he considers it insufficient.</div><br/><div id="39732199" class="c"><input type="checkbox" id="c-39732199" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732056">parent</a><span>|</span><a href="#39732661">next</a><span>|</span><label class="collapse" for="c-39732199">[-]</label><label class="expand" for="c-39732199">[3 more]</label></div><br/><div class="children"><div class="content">The biggest objection seems to be the Java&#x2F;JIT case.  eh_frame supports a &quot;personality function&quot; which is AIUI basically a callback for performing custom unwinding.  If the personality function could also support custom logic for producing backtraces, then the profiling sampler could effectively read the JVM&#x27;s own metadata about the JIT&#x27;ted code, which I assume it must have in order to produce backtraces for the JVM itself.</div><br/><div id="39732340" class="c"><input type="checkbox" id="c-39732340" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732199">parent</a><span>|</span><a href="#39732661">next</a><span>|</span><label class="collapse" for="c-39732340">[-]</label><label class="expand" for="c-39732340">[2 more]</label></div><br/><div class="children"><div class="content">This also seems like a big objection:<p>&gt; The overhead to walk DWARF is also too high, as it was designed for non-realtime use.</div><br/><div id="39732769" class="c"><input type="checkbox" id="c-39732769" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#39732010">root</a><span>|</span><a href="#39732340">parent</a><span>|</span><a href="#39732661">next</a><span>|</span><label class="collapse" for="c-39732769">[-]</label><label class="expand" for="c-39732769">[1 more]</label></div><br/><div class="children"><div class="content">Not a problem in practice. The way you solve it is to just translate DWARF into a simpler representation that doesn&#x27;t require you to walk anything. (But I understand why people don&#x27;t want to do it. DWARF is insanely complex and annoying to deal with.)<p>Source: I wrote multiple profilers.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39732661" class="c"><input type="checkbox" id="c-39732661" checked=""/><div class="controls bullet"><span class="by">5-</span><span>|</span><a href="#39732010">prev</a><span>|</span><a href="#39732154">next</a><span>|</span><label class="collapse" for="c-39732661">[-]</label><label class="expand" for="c-39732661">[3 more]</label></div><br/><div class="children"><div class="content">so what is the downside to using e.g. dwarf-based stack walking (supported by perf) for libc, which was the original stated problem?<p>in the discussion the issue gets conflated with jit-ted languages, but that has nothing to do with the crusade to enable frame pointer for system libraries.<p>and if you care that much for dwarf overhead... just cache the unwind information in your system-level profiler? no need to rebuild everything.</div><br/><div id="39732842" class="c"><input type="checkbox" id="c-39732842" checked=""/><div class="controls bullet"><span class="by">brancz</span><span>|</span><a href="#39732661">parent</a><span>|</span><a href="#39732828">next</a><span>|</span><label class="collapse" for="c-39732842">[-]</label><label class="expand" for="c-39732842">[1 more]</label></div><br/><div class="children"><div class="content">The way perf does it is slow, as the entire stack is copied into user-space and is then asynchronously unwound.<p>This is solvable as Brendan calls out, we’ve created an eBPF-based profiler at Polar Signals, that essentially does what you said, it optimized the unwind tables, caches them in bpf maps, and then synchronously unwinds as opposed to copying the whole stack into user-space.</div><br/></div></div><div id="39732828" class="c"><input type="checkbox" id="c-39732828" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#39732661">parent</a><span>|</span><a href="#39732842">prev</a><span>|</span><a href="#39732154">next</a><span>|</span><label class="collapse" for="c-39732828">[-]</label><label class="expand" for="c-39732828">[1 more]</label></div><br/><div class="children"><div class="content">The article explains why DWARF is not an option.</div><br/></div></div></div></div><div id="39732154" class="c"><input type="checkbox" id="c-39732154" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39732661">prev</a><span>|</span><a href="#39732073">next</a><span>|</span><label class="collapse" for="c-39732154">[-]</label><label class="expand" for="c-39732154">[1 more]</label></div><br/><div class="children"><div class="content">Guess I&#x27;ll add it back in to the DMD code generator!</div><br/></div></div><div id="39732073" class="c"><input type="checkbox" id="c-39732073" checked=""/><div class="controls bullet"><span class="by">ngcc_hk</span><span>|</span><a href="#39732154">prev</a><span>|</span><a href="#39732105">next</a><span>|</span><label class="collapse" for="c-39732073">[-]</label><label class="expand" for="c-39732073">[2 more]</label></div><br/><div class="children"><div class="content">It said gcc.  I noted the default of llvm said to default with framepounter from 2011.  Is this mainly a gcc issue?</div><br/><div id="39732522" class="c"><input type="checkbox" id="c-39732522" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#39732073">parent</a><span>|</span><a href="#39732105">next</a><span>|</span><label class="collapse" for="c-39732522">[-]</label><label class="expand" for="c-39732522">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t really matter what the default of the compiler is, but what distros chose.</div><br/></div></div></div></div></div></div></div></div></div></body></html>