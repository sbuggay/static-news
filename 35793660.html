<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683104453332" as="style"/><link rel="stylesheet" href="styles.css?v=1683104453332"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://questdb.io/blog/investigating-linux-phantom-disk-reads/">Investigating Linux phantom disk reads</a> <span class="domain">(<a href="https://questdb.io">questdb.io</a>)</span></div><div class="subtext"><span>kamaraju</span> | <span>44 comments</span></div><br/><div><div id="35795129" class="c"><input type="checkbox" id="c-35795129" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#35795181">next</a><span>|</span><label class="collapse" for="c-35795129">[-]</label><label class="expand" for="c-35795129">[8 more]</label></div><br/><div class="children"><div class="content">Going through mmap for bulk-ingest sucks because the kernel has to fault in the contents to make what&#x27;s in-core reflect what&#x27;s on-disk before your write access to the mapped memory occurs. It&#x27;s basically a read-modify-write pattern even when all you intended to do was write the entire page.<p>When you just use a write call you provide a unit of arbitrary size, and if you&#x27;ve done your homework that size is a multiple of page size and the offset page-aligned.  Then there&#x27;s no need for the kernel to load anything in for the written pages; you&#x27;re providing everything in the single call.  Then you go down the O_DIRECT rabbithole every fast linux database has historically gone down.</div><br/><div id="35798248" class="c"><input type="checkbox" id="c-35798248" checked=""/><div class="controls bullet"><span class="by">ritcgab</span><span>|</span><a href="#35795129">parent</a><span>|</span><a href="#35795740">next</a><span>|</span><label class="collapse" for="c-35798248">[-]</label><label class="expand" for="c-35798248">[1 more]</label></div><br/><div class="children"><div class="content">For (sequentially) writing a file this is true. But a database might be more complex, as the underlying I&#x2F;O is transparent to the user. The database needs a semantics to indicate that &quot;this ingestion will produce a large bulk of sequential writes&quot;.</div><br/></div></div><div id="35795740" class="c"><input type="checkbox" id="c-35795740" checked=""/><div class="controls bullet"><span class="by">bluestreak</span><span>|</span><a href="#35795129">parent</a><span>|</span><a href="#35798248">prev</a><span>|</span><a href="#35795181">next</a><span>|</span><label class="collapse" for="c-35795740">[-]</label><label class="expand" for="c-35795740">[6 more]</label></div><br/><div class="children"><div class="content">It is not always read-write-modify. There is no evidence of this pattern in Ubuntu when there is no memory pressure. Merge occurs when block is partially updated after kenel had lost state of the block, which can happen under memory pressure.</div><br/><div id="35796610" class="c"><input type="checkbox" id="c-35796610" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#35795129">root</a><span>|</span><a href="#35795740">parent</a><span>|</span><a href="#35795181">next</a><span>|</span><label class="collapse" for="c-35796610">[-]</label><label class="expand" for="c-35796610">[5 more]</label></div><br/><div class="children"><div class="content">Sorry, try again.<p>On x86, and I think every architecture, when you write to a memory mapping that is not already backed by a writable page, the kernel is notified that user code is trying to write. And the kernel needs to fill in the contents of the page, which requires a read if the page isn’t already loaded.<p>It has to be this way!  The write could be a read-modify-write instruction. Or it could be a plain store, but I’ve never heard of hardware with write-only memory with fine enough granularity to make this work.<p>The sole exception is if the page in question is all zeros and the kernel can know this without needing to read the file. This might sometimes be the case for an append-only database. I don’t know exactly what QuestDB does.<p>Also:<p>&gt; As soon as you mmap a file, the kernel allocates page table entries (PTEs) for the virtual memory to reserve an address range for your file,<p>Nope. It just makes a record of the existence of the mapping. This is called a VMA in Linux. No PTEs are created unless you set MAP_POPULATE.<p>&gt; but it doesn&#x27;t read the file contents at this point. The actual data is read into the page when you access the allocated memory, i.e. start reading (LOAD instruction in x86) or writing (STORE instruction in x86) the memory.<p>What are these LOAD and STORE instructions in x86?  There are architectures reasonably described as load-store architectures, and x86 isn’t one of them.</div><br/><div id="35799645" class="c"><input type="checkbox" id="c-35799645" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#35795129">root</a><span>|</span><a href="#35796610">parent</a><span>|</span><a href="#35796738">next</a><span>|</span><label class="collapse" for="c-35799645">[-]</label><label class="expand" for="c-35799645">[1 more]</label></div><br/><div class="children"><div class="content">I’m assuming the LOAD and STORE were not actual instructions but euphemisms for the variety of operations that touch memory.</div><br/></div></div><div id="35796738" class="c"><input type="checkbox" id="c-35796738" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#35795129">root</a><span>|</span><a href="#35796610">parent</a><span>|</span><a href="#35799645">prev</a><span>|</span><a href="#35795181">next</a><span>|</span><label class="collapse" for="c-35796738">[-]</label><label class="expand" for="c-35796738">[3 more]</label></div><br/><div class="children"><div class="content">&gt; What are these LOAD and STORE instructions in x86?<p>The RISC core of every x86 since PPro is a load&#x2F;store machine.</div><br/><div id="35798098" class="c"><input type="checkbox" id="c-35798098" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#35795129">root</a><span>|</span><a href="#35796738">parent</a><span>|</span><a href="#35795181">next</a><span>|</span><label class="collapse" for="c-35798098">[-]</label><label class="expand" for="c-35798098">[2 more]</label></div><br/><div class="children"><div class="content">Those instructions still aren&#x27;t exposed to the user, are they?</div><br/><div id="35798909" class="c"><input type="checkbox" id="c-35798909" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#35795129">root</a><span>|</span><a href="#35798098">parent</a><span>|</span><a href="#35795181">next</a><span>|</span><label class="collapse" for="c-35798909">[-]</label><label class="expand" for="c-35798909">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t matter. The core doesn&#x27;t see the x86 instructions either. MOVs are decoded into simpler operations to facilitate reordering.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="35795181" class="c"><input type="checkbox" id="c-35795181" checked=""/><div class="controls bullet"><span class="by">addisonj</span><span>|</span><a href="#35795129">prev</a><span>|</span><a href="#35796594">next</a><span>|</span><label class="collapse" for="c-35795181">[-]</label><label class="expand" for="c-35795181">[11 more]</label></div><br/><div class="children"><div class="content">I am going to write this comment with a large preface: I don&#x27;t think it is ever helpful to be an absolutist. For every best-practice&#x2F;&quot;right way&quot; to do things, there are circumstances when doing it another way makes sense. That can be a ton of reasons for that, be it technical, money&#x2F;time, etc. The best engineering teams aren&#x27;t those that just blindly follow what others say is a best practice but understand the options and make an informed choice. None of the following comment is at all commentary on questDB, as they mention in the article, <i>many</i> databases use similar tools.<p>With that said, after reading the first paragraph I immediately searched the article for &quot;mmap&quot; and had a good sense of where the rest of this was going. Put simply, it is just really hard to consider what the OS is going to do in all situations when using mmap. Based on my experience, I would guess that a <i>ton</i> of people reading this comment have hit issues that, I would argue, is due to using mmap. (Particularly looking at you prometheus).<p>All things told, this is a pretty innocuous incident of mmap causing problems, but I would encourage any aspiring DB engineers to read <a href="https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022" rel="nofollow">https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022</a> as it gives a great overview of the range of problems that can occur when using mmap<p>I think some would argue that mmap is &quot;fine&quot; for append only workloads (and is certainly more reasonable compared to a DB with arbitrary updates) but even here, lots of factors like metadata, scaling number of tables, etc will <i>eventually</i> bring you to hit some fundamental problems when using mmap.<p>The interesting opportunity in my mind, especially with improvements in async IO (both at FS level and in tools like rust), is to build higher level abstractions that bring the &quot;simplicity&quot; of mmap, but with more purpose-built semantics ideal for databases.</div><br/><div id="35796867" class="c"><input type="checkbox" id="c-35796867" checked=""/><div class="controls bullet"><span class="by">justin66</span><span>|</span><a href="#35795181">parent</a><span>|</span><a href="#35795532">next</a><span>|</span><label class="collapse" for="c-35796867">[-]</label><label class="expand" for="c-35796867">[2 more]</label></div><br/><div class="children"><div class="content">&gt; All things told, this is a pretty innocuous incident of mmap causing problems, but I would encourage any aspiring DB engineers to read <a href="https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022" rel="nofollow">https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022</a> as it gives a great overview of the range of problems that can occur when using mmap<p>At first glance (doing a few text finds and a really quick read through the paper after clicking through that intro page with the poop emoji at the top and disregarding <i>Recommended Music for this Paper:
Dr. Dre – High Powered (featuring RBX)</i>) that paper seems too short to adequately explore the topic.<p>On the other hand these same guys (the CMU Database Group) are an amazing resource and their youtube channel offers some great stuff [1] that would allow a curious person to explore the topic in greater depth if they dug into the papers of everyone who gave presentations at CMU.<p>clickbait: <i>How many of the world&#x27;s leading software engineers who addressed CMU students and professors about their successful database products rely on mmap? The answer may surprise you.</i><p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;@CMUDatabaseGroup">https:&#x2F;&#x2F;www.youtube.com&#x2F;@CMUDatabaseGroup</a></div><br/><div id="35798487" class="c"><input type="checkbox" id="c-35798487" checked=""/><div class="controls bullet"><span class="by">ayende</span><span>|</span><a href="#35795181">root</a><span>|</span><a href="#35796867">parent</a><span>|</span><a href="#35795532">next</a><span>|</span><label class="collapse" for="c-35798487">[-]</label><label class="expand" for="c-35798487">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a response to this article, because that is a <i>bad</i> comparison.<p><a href="https:&#x2F;&#x2F;ravendb.net&#x2F;articles&#x2F;re-are-you-sure-you-want-to-use-mmap-in-your-database-management-system" rel="nofollow">https:&#x2F;&#x2F;ravendb.net&#x2F;articles&#x2F;re-are-you-sure-you-want-to-use...</a><p>Agree on CMU being a great resource.</div><br/></div></div></div></div><div id="35795532" class="c"><input type="checkbox" id="c-35795532" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#35795181">parent</a><span>|</span><a href="#35796867">prev</a><span>|</span><a href="#35796401">next</a><span>|</span><label class="collapse" for="c-35795532">[-]</label><label class="expand" for="c-35795532">[6 more]</label></div><br/><div class="children"><div class="content">When I read they were using mmap I immediately thought of Andy Pavlo since he warns against it every time he can in the CMU videos. Enough that I thought it was somewhat of a concensus now that mmap should be avoided specially for databases, guess I was wrong.</div><br/><div id="35799131" class="c"><input type="checkbox" id="c-35799131" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#35795181">root</a><span>|</span><a href="#35795532">parent</a><span>|</span><a href="#35797274">next</a><span>|</span><label class="collapse" for="c-35799131">[-]</label><label class="expand" for="c-35799131">[2 more]</label></div><br/><div class="children"><div class="content">mmap should generally be avoided, not just for databases. It&#x27;s useful for quick prototyping and for the specific case of demand-paging executables (which is really what it&#x27;s made for!), but there are so many pitfalls overall. You can&#x27;t mmap large files relative to your memory (you crash into either address space limits or PTE memory usage), you have absolutely no hope of recovering from errors, you can&#x27;t do large sequential I&#x2F;O reliably, it&#x27;s a really difficult problem to order your writes, and so on.<p>There are corner cases where it&#x27;s great, like when you have a file that you know is 90% in-core already and you don&#x27;t care about errors. But overall, read() and write() are simpler, faster, more reliable primitives.</div><br/><div id="35799751" class="c"><input type="checkbox" id="c-35799751" checked=""/><div class="controls bullet"><span class="by">citrin_ru</span><span>|</span><a href="#35795181">root</a><span>|</span><a href="#35799131">parent</a><span>|</span><a href="#35797274">next</a><span>|</span><label class="collapse" for="c-35799751">[-]</label><label class="expand" for="c-35799751">[1 more]</label></div><br/><div class="children"><div class="content">Here is a good use case for mmap - a process-a performs data processing and writes results to a disk (or tmpfs), next you need to repeatedly read in a process-b (or read once but not sequentially). If you&#x27;ll use read() you will: 1. double RAM usage - the file will be in a VM cache anyway (unless you&#x27;ll use O_DIRECT which would make this pipeline slower) and without mmap() you&#x27;ll have to create 2nd copy inside the process-b 2. add unnecessary kernel-&gt;userspace copy while reading data in process-b.<p>But for saving data from process-a I would still use write() using MAXPHYS sized blocks: I&#x27;m not sure mmap would use optimal write block size, and with write it is easier detect errors (like ENOSPC).</div><br/></div></div></div></div><div id="35797274" class="c"><input type="checkbox" id="c-35797274" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#35795181">root</a><span>|</span><a href="#35795532">parent</a><span>|</span><a href="#35799131">prev</a><span>|</span><a href="#35795633">next</a><span>|</span><label class="collapse" for="c-35797274">[-]</label><label class="expand" for="c-35797274">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Enough that I thought it was somewhat of a concensus now that mmap should be avoided specially for databases<p>I have to remind myself regularly that the world is larger than it seems.<p>The other day someone on r&#x2F;rust said &quot;Surely everyone knows what the rust programming language is by now. Can we stop introducing rust every time we mention it in a paper?&quot;. But no, obviously everyone in your circles knows what rust is. But you don&#x27;t know most developers. And I wouldn&#x27;t be surprised if less than half of working developers have heard of rust, even if everyone you know knows about it.<p>I used to rant against using socket.io at every possible opportunity. The library has (had) crazy bugs in its reconnection code. In the right circumstances the library would violate ordering and delivery guarantees, or it would lie about messages being received when they hadn&#x27;t been. But no matter how much I ranted about it, and no matter how many hundreds of issues there were on github, far more people used socket.io than the (much more reliable) alternatives because socket.io had a pretty website, good documentation and it was taught at coding bootcamps. I think the only reason its not as popular now is that you don&#x27;t need it now that websockets are available everywhere.<p>My partner says she imagines asking questions of our families when she tries to imagine what the average person thinks. But our immediate families are still a really weird bubble - every single one of the adults has graduated from college. (And weirdly, over half of that group have also <i>taught</i> at college.) That&#x27;s still a really biased set of people. Finding an unbiased set is wildly difficult.</div><br/></div></div><div id="35795633" class="c"><input type="checkbox" id="c-35795633" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#35795181">root</a><span>|</span><a href="#35795532">parent</a><span>|</span><a href="#35797274">prev</a><span>|</span><a href="#35796401">next</a><span>|</span><label class="collapse" for="c-35795633">[-]</label><label class="expand" for="c-35795633">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a concensus now that mmap should be avoided specially for databases<p>Maybe, but table 1 in Andy Pavlo&#x27;s paper shows 7 of 10 databases surveyed do still use mmap.<p>Furthermore, that paper clearly demonstrating the issues with mmap came out in 2022 and most databases have been around longer than that.<p>That mmap isn&#x27;t the future is maybe more certain than that mmap isn&#x27;t common practice today (because it does sorta seem to be).</div><br/><div id="35796745" class="c"><input type="checkbox" id="c-35796745" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#35795181">root</a><span>|</span><a href="#35795633">parent</a><span>|</span><a href="#35796401">next</a><span>|</span><label class="collapse" for="c-35796745">[-]</label><label class="expand" for="c-35796745">[1 more]</label></div><br/><div class="children"><div class="content">My impression is that databases have known of the shortcomings of mmap since, like, the 90s.  A critical flaw is the lack of error handling -- in addition to the unpredictable performance characteristics and naive caching.  I&#x27;m looking forward to reading the paper.</div><br/></div></div></div></div></div></div><div id="35796401" class="c"><input type="checkbox" id="c-35796401" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#35795181">parent</a><span>|</span><a href="#35795532">prev</a><span>|</span><a href="#35796594">next</a><span>|</span><label class="collapse" for="c-35796401">[-]</label><label class="expand" for="c-35796401">[2 more]</label></div><br/><div class="children"><div class="content">So a dbms probable has intimate knowledge about its data that probably can&#x27;t be hinted via madvise.<p>But I wonder when there are decent reasons to let the OS handle file I&#x2F;O through the demand paging system, since it&#x27;s good at it.</div><br/><div id="35796727" class="c"><input type="checkbox" id="c-35796727" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#35795181">root</a><span>|</span><a href="#35796401">parent</a><span>|</span><a href="#35796594">next</a><span>|</span><label class="collapse" for="c-35796727">[-]</label><label class="expand" for="c-35796727">[1 more]</label></div><br/><div class="children"><div class="content">&gt; since it&#x27;s good at it.<p>This is generous. At least, it&#x27;s not a great working assumption.  If you know anything about your workload, it&#x27;s often possible to do better by specializing slightly.</div><br/></div></div></div></div></div></div><div id="35796594" class="c"><input type="checkbox" id="c-35796594" checked=""/><div class="controls bullet"><span class="by">dmazin</span><span>|</span><a href="#35795181">prev</a><span>|</span><a href="#35795138">next</a><span>|</span><label class="collapse" for="c-35796594">[-]</label><label class="expand" for="c-35796594">[11 more]</label></div><br/><div class="children"><div class="content">Am I the only one surprised to read that this database relies on periodic flushing (every 30s by default) with no manual syncs at all? I guess it’s metrics so 30s of data loss is fine? I dunno about that. Data loss is usually due to a power failure, and the metrics collected right before a power failure are important.</div><br/><div id="35796629" class="c"><input type="checkbox" id="c-35796629" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#35796594">parent</a><span>|</span><a href="#35799607">next</a><span>|</span><label class="collapse" for="c-35796629">[-]</label><label class="expand" for="c-35796629">[6 more]</label></div><br/><div class="children"><div class="content">I was surprised by this too. I asked the author about it on Twitter [0]. At the very least it seems like fsync is something you can opt into in their configuration, even if it&#x27;s not the default.<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;eatonphil&#x2F;status&#x2F;1653373246929027075" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;eatonphil&#x2F;status&#x2F;1653373246929027075</a></div><br/><div id="35796772" class="c"><input type="checkbox" id="c-35796772" checked=""/><div class="controls bullet"><span class="by">dmazin</span><span>|</span><a href="#35796594">root</a><span>|</span><a href="#35796629">parent</a><span>|</span><a href="#35799607">next</a><span>|</span><label class="collapse" for="c-35796772">[-]</label><label class="expand" for="c-35796772">[5 more]</label></div><br/><div class="children"><div class="content">Nice. Glad you asked.<p>From a developer:<p>“As long as the OS &amp; the HW doesn&#x27;t crash, the data is safe thanks to the page cache”<p>This is so strange to me. A database that is non-durable by default. OK…</div><br/><div id="35797714" class="c"><input type="checkbox" id="c-35797714" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#35796594">root</a><span>|</span><a href="#35796772">parent</a><span>|</span><a href="#35798507">next</a><span>|</span><label class="collapse" for="c-35797714">[-]</label><label class="expand" for="c-35797714">[2 more]</label></div><br/><div class="children"><div class="content">A few years ago I was doing some consulting for a medical tech startup run by an ex-doctor. They were thinking of using mongodb until I explained how it had a reputation for losing data. I&#x27;ll never forget the look of horror, disgust and confusion on his face. He turned to me and said &quot;A database that forgets things!? Why would anyone want that??&quot;.<p>I still don&#x27;t have an answer for him. It sounds just as strange to me too.</div><br/><div id="35799110" class="c"><input type="checkbox" id="c-35799110" checked=""/><div class="controls bullet"><span class="by">matthews2</span><span>|</span><a href="#35796594">root</a><span>|</span><a href="#35797714">parent</a><span>|</span><a href="#35798507">next</a><span>|</span><label class="collapse" for="c-35799110">[-]</label><label class="expand" for="c-35799110">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like Snapchat, but for databases!</div><br/></div></div></div></div><div id="35798507" class="c"><input type="checkbox" id="c-35798507" checked=""/><div class="controls bullet"><span class="by">ayende</span><span>|</span><a href="#35796594">root</a><span>|</span><a href="#35796772">parent</a><span>|</span><a href="#35797714">prev</a><span>|</span><a href="#35798015">next</a><span>|</span><label class="collapse" for="c-35798507">[-]</label><label class="expand" for="c-35798507">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that <i>fsync</i> is <i>super</i> expensive.
Like, it&#x27;s not even funny.<p>There are many cases, and ingest is one of them, where no being durable is fine.
If you can either:<p>* Repeat the whole process on failure (which is assumed to be rare)
* Recover from the failure without data corruption (distinct from data loss, mind)<p>In those cases, being 10x faster is very compelling.<p>Note that this is about ingest for bulk loads, while online transactions not being durable is a really bad idea.<p>For bulk load ingest, you can usually retry the whole operation. Not so for transactions.</div><br/></div></div><div id="35798015" class="c"><input type="checkbox" id="c-35798015" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#35796594">root</a><span>|</span><a href="#35796772">parent</a><span>|</span><a href="#35798507">prev</a><span>|</span><a href="#35799607">next</a><span>|</span><label class="collapse" for="c-35798015">[-]</label><label class="expand" for="c-35798015">[1 more]</label></div><br/><div class="children"><div class="content">At least given the append-only nature, the data loss should be bounded.<p>For some reason, many databases that overwrite data support disabling journaling and&#x2F;or fsync. E.g. SQLite has &quot;pragma journal = off&quot;. You can lose the entire database from an ill-timed crash, if one important page gets written but another doesn&#x27;t. To their credit, it&#x27;s not the default, and the documentation is explicit about this:<p>&gt; If the application crashes in the middle of a transaction when the OFF journaling mode is set, then the database file will very likely go corrupt.<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;pragma.html#pragma_journal_mode" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;pragma.html#pragma_journal_mode</a></div><br/></div></div></div></div></div></div><div id="35799607" class="c"><input type="checkbox" id="c-35799607" checked=""/><div class="controls bullet"><span class="by">ddorian43</span><span>|</span><a href="#35796594">parent</a><span>|</span><a href="#35796629">prev</a><span>|</span><a href="#35796713">next</a><span>|</span><label class="collapse" for="c-35799607">[-]</label><label class="expand" for="c-35799607">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what ~every &quot;cloud&quot; database does because disks in the cloud are slow.</div><br/></div></div><div id="35796713" class="c"><input type="checkbox" id="c-35796713" checked=""/><div class="controls bullet"><span class="by">tkhattra</span><span>|</span><a href="#35796594">parent</a><span>|</span><a href="#35799607">prev</a><span>|</span><a href="#35795138">next</a><span>|</span><label class="collapse" for="c-35796713">[-]</label><label class="expand" for="c-35796713">[3 more]</label></div><br/><div class="children"><div class="content">it supports different commit modes (see [1]) - nosync, async, and sync. you can choose the more expensive but safer async or sync modes if you&#x27;re willing to tolerate higher commit latency.<p>[1] <a href="https:&#x2F;&#x2F;questdb.io&#x2F;docs&#x2F;reference&#x2F;configuration&#x2F;#cairo-engine">https:&#x2F;&#x2F;questdb.io&#x2F;docs&#x2F;reference&#x2F;configuration&#x2F;#cairo-engin...</a></div><br/><div id="35796742" class="c"><input type="checkbox" id="c-35796742" checked=""/><div class="controls bullet"><span class="by">dmazin</span><span>|</span><a href="#35796594">root</a><span>|</span><a href="#35796713">parent</a><span>|</span><a href="#35795138">next</a><span>|</span><label class="collapse" for="c-35796742">[-]</label><label class="expand" for="c-35796742">[2 more]</label></div><br/><div class="children"><div class="content">Yeah it’s just… it’s a database. Weird default.</div><br/><div id="35798520" class="c"><input type="checkbox" id="c-35798520" checked=""/><div class="controls bullet"><span class="by">AlfeG</span><span>|</span><a href="#35796594">root</a><span>|</span><a href="#35796742">parent</a><span>|</span><a href="#35795138">next</a><span>|</span><label class="collapse" for="c-35798520">[-]</label><label class="expand" for="c-35798520">[1 more]</label></div><br/><div class="children"><div class="content">Because otherwise competitive benchmarks will show not so great results against other dbses</div><br/></div></div></div></div></div></div></div></div><div id="35795138" class="c"><input type="checkbox" id="c-35795138" checked=""/><div class="controls bullet"><span class="by">davidhyde</span><span>|</span><a href="#35796594">prev</a><span>|</span><a href="#35794737">next</a><span>|</span><label class="collapse" for="c-35795138">[-]</label><label class="expand" for="c-35795138">[1 more]</label></div><br/><div class="children"><div class="content">Seems like using memory mapped files for a write-only load is the sub optimal choice. Maybe I’m mistaken but surely using an append-only file handle would be simpler than changing the behaviour of how memory mapped files are cached like they did for their solution?</div><br/></div></div><div id="35794737" class="c"><input type="checkbox" id="c-35794737" checked=""/><div class="controls bullet"><span class="by">sytse</span><span>|</span><a href="#35795138">prev</a><span>|</span><a href="#35795190">next</a><span>|</span><label class="collapse" for="c-35794737">[-]</label><label class="expand" for="c-35794737">[9 more]</label></div><br/><div class="children"><div class="content">TLDR; &quot;Ingestion of a high number of column files under memory pressure led to the kernel starting readahead disk read operations, which you wouldn&#x27;t expect from a write-only load. The rest was as simple as using madvise in our code to disable the readahead in table writers.&quot;</div><br/><div id="35794968" class="c"><input type="checkbox" id="c-35794968" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#35794737">parent</a><span>|</span><a href="#35795190">next</a><span>|</span><label class="collapse" for="c-35794968">[-]</label><label class="expand" for="c-35794968">[8 more]</label></div><br/><div class="children"><div class="content">The article kind of dances around it, but AIUI the reason that their &quot;weite-only load&quot; caused reads (and thus readahead) was because they were writing to a mapped page that had already been evicted - so the kernel <i>was</i> reading&#x2F;faulting those pages because it can only write in block&#x2F;page sized chunks.<p>In some sense maybe this could be thought of as readahead in preparation for writing to those pages, which is undesirable in this case.<p>However, what confused be about this article was if the data files are append only, how is there a &quot;next&quot; block to read ahead to? I guess maybe the files are pre-allocated or the kernel is reading previous pages.</div><br/><div id="35795095" class="c"><input type="checkbox" id="c-35795095" checked=""/><div class="controls bullet"><span class="by">bremac</span><span>|</span><a href="#35794737">root</a><span>|</span><a href="#35794968">parent</a><span>|</span><a href="#35795169">next</a><span>|</span><label class="collapse" for="c-35795095">[-]</label><label class="expand" for="c-35795095">[4 more]</label></div><br/><div class="children"><div class="content">Reading between the lines, it sounds as if they&#x27;re using mmap. There is no &quot;append&quot; operation on a memory mapping, so the file would need to be preallocated before mapping it.<p>If the preallocation is done using fallocate or just writing zeros, then by default it&#x27;s backed by blocks on disk, and readahead must hit the disk since there is data there. On the other hand, preallocating with fallocate using FALLOC_FL_ZERO_RANGE or (often) with ftruncate() will just update the logical file length, and even if readahead is triggered it won&#x27;t actually hit the disk.</div><br/><div id="35798516" class="c"><input type="checkbox" id="c-35798516" checked=""/><div class="controls bullet"><span class="by">ayende</span><span>|</span><a href="#35794737">root</a><span>|</span><a href="#35795095">parent</a><span>|</span><a href="#35795175">next</a><span>|</span><label class="collapse" for="c-35798516">[-]</label><label class="expand" for="c-35798516">[1 more]</label></div><br/><div class="children"><div class="content">Using _ftruncate_ or FALLOC_FL_ZERO_RANGE is a bad idea for a database.
The problem is that you may get an out of disk space error mid operation.<p>If you are using mmap, that will express itself as a segmentation fault, which you <i>really</i> don&#x27;t want.<p>You _need_ to allocate the file ahead of time, so you can properly behave there.</div><br/></div></div><div id="35795175" class="c"><input type="checkbox" id="c-35795175" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#35794737">root</a><span>|</span><a href="#35795095">parent</a><span>|</span><a href="#35798516">prev</a><span>|</span><a href="#35795169">next</a><span>|</span><label class="collapse" for="c-35795175">[-]</label><label class="expand" for="c-35795175">[2 more]</label></div><br/><div class="children"><div class="content">For the file being entirely pre-allocated case I understand, but for the file hole case I&#x27;m not sure I understand why you&#x27;d get such high disk activity.<p>If the index block also got evicted from the page cache, then could reading into a file hole still trigger a fault? Or is the &quot;holiness&quot; of a page for a mapping stored in the page table?</div><br/><div id="35796815" class="c"><input type="checkbox" id="c-35796815" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#35794737">root</a><span>|</span><a href="#35795175">parent</a><span>|</span><a href="#35795169">next</a><span>|</span><label class="collapse" for="c-35796815">[-]</label><label class="expand" for="c-35796815">[1 more]</label></div><br/><div class="children"><div class="content">I suspect page size&#x2F;aligned file holes could be backed by a read-only zero page via PTE as an optimization, but they might not be (I&#x27;m not as familiar with Linux mmap&#x2F;filesystems as with FreeBSD).<p>It is quite possible the filesystem caches, e.g., the file extent tree (including holiness) separately from the backing inode&#x2F;on-disk sectors for the tree.</div><br/></div></div></div></div></div></div><div id="35795169" class="c"><input type="checkbox" id="c-35795169" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#35794737">root</a><span>|</span><a href="#35794968">parent</a><span>|</span><a href="#35795095">prev</a><span>|</span><a href="#35795058">next</a><span>|</span><label class="collapse" for="c-35795169">[-]</label><label class="expand" for="c-35795169">[2 more]</label></div><br/><div class="children"><div class="content">The readahead is a bit of a readaround when I last checked, as in it&#x27;ll pull in some stuff before the fault as well.<p>There used to be a sys-wide tunable in &#x2F;sys to control how large an area readahead would extend to, but I&#x27;m not seeing it anymore on this 6.1 laptop.  I think there&#x27;s been some work changing stuff to be more clever in this area in recent years.  It used to be interesting to make that value small vs. large and see how things like uncached journalctl (heavy mmap user) were affected in terms of performance vs. IO generated.</div><br/><div id="35795214" class="c"><input type="checkbox" id="c-35795214" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#35794737">root</a><span>|</span><a href="#35795169">parent</a><span>|</span><a href="#35795058">next</a><span>|</span><label class="collapse" for="c-35795214">[-]</label><label class="expand" for="c-35795214">[1 more]</label></div><br/><div class="children"><div class="content">The article distinguishes &quot;readaround&quot; from a linear predicted &quot;readahead&quot;, but then says the output of blktrace indicates a &quot;potential readahead&quot;, which is where I got confused.<p>Does MADV_RANDOM disable both &quot;readahead&quot; and &quot;readaround&quot;?</div><br/></div></div></div></div></div></div></div></div><div id="35795190" class="c"><input type="checkbox" id="c-35795190" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#35794737">prev</a><span>|</span><a href="#35797774">next</a><span>|</span><label class="collapse" for="c-35795190">[-]</label><label class="expand" for="c-35795190">[1 more]</label></div><br/><div class="children"><div class="content">There are other methods you can use to increase performance under memory pressure, but you&#x27;d end up handling i&#x2F;o directly and maintaining your own index of memory and disk accesses, page-aligned reads&#x2F;writes, etc. It would be easier to just require your users buy more memory, but when there&#x27;s a hack like this available, that seems preferable to implementing your own VMM and disk i&#x2F;o subsystem.</div><br/></div></div><div id="35797930" class="c"><input type="checkbox" id="c-35797930" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#35797774">prev</a><span>|</span><label class="collapse" for="c-35797930">[-]</label><label class="expand" for="c-35797930">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s also important to note that the above percentages…<p>Has this article being written using ChatGPT by any chance ?</div><br/></div></div></div></div></div></div></div></body></html>