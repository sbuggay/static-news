<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704531656404" as="style"/><link rel="stylesheet" href="styles.css?v=1704531656404"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dcreager.net/wirth/1968-closing-word/">Closing word at Zürich Colloquium (1968)</a> <span class="domain">(<a href="https://dcreager.net">dcreager.net</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>16 comments</span></div><br/><div><div id="38887373" class="c"><input type="checkbox" id="c-38887373" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#38887232">next</a><span>|</span><label class="collapse" for="c-38887373">[-]</label><label class="expand" for="c-38887373">[2 more]</label></div><br/><div class="children"><div class="content">(background I implemented Algol68 as an MSc project in the early 80s)<p>So Wirth was a big part of the Algol68 working group but grew disillusioned by it&#x27;s resulting complexity - he went off and invented Pascal, essentially taking the easy to implement parts of Algol68 and put them in a language.<p>Almost everything new (or newly borrowed) in Algol68 is common today, often reinvented many times over: structs, unions, pointers, a full type system, threads, a standard library, procedure pointers, a heap with garbage collection etc etc<p>The things we don&#x27;t have from it are largely different fonts for reserved words and&#x2F;or types (something largely forced on them by using cards with only upper case), and A68&#x27;s standard which I guess is what happens when you let the maths guys go wild - they invented a language to describe the language and its semantics, a language that&#x27;s largely incomprehensible to most mortals (and then reinvented it for the revised standard) .... it made the spec really hard to read.<p>All in all it was a great effort considering the times, people were still figuring out how to do stuff at the time, it&#x27;s not surprising they made some mistakes. It was also a time when compilers and OSs were largely owned by hardware companies, it was much harder for a language to get traction outside of academia (you expected to pay tens of thousands for a compiler, a free one couldn&#x27;t be any good right?)</div><br/><div id="38887672" class="c"><input type="checkbox" id="c-38887672" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#38887373">parent</a><span>|</span><a href="#38887232">next</a><span>|</span><label class="collapse" for="c-38887672">[-]</label><label class="expand" for="c-38887672">[1 more]</label></div><br/><div class="children"><div class="content">Actually when Wirth split from the Algol68 working group, he first created his own alternate successor to Algol60 - AlgolW (W=Wirth), which was still in use in 1979 when I took CS in college.<p>It seems odd for Wirth to be arguing so much for user needs and then come out with a language like Pascal which favored minimalism over practicality.</div><br/></div></div></div></div><div id="38887232" class="c"><input type="checkbox" id="c-38887232" checked=""/><div class="controls bullet"><span class="by">scrubs</span><span>|</span><a href="#38887373">prev</a><span>|</span><a href="#38887122">next</a><span>|</span><label class="collapse" for="c-38887232">[-]</label><label class="expand" for="c-38887232">[3 more]</label></div><br/><div class="children"><div class="content">Quoting: &quot;The emphasis on a simple and didactically appealing language would automatically have resulted in the development of a nucleus of a self-extendible language, perhaps the most promising approach of development. Such a language provides a facility for programmers to define data structure patterns, and operators which apply to these patterns. The crucial point here is that the language nucleus must be of utmost simplicity, and every aspect of the nucleus language must be very efficiently implementable on any reasonable computer organisation.&quot;<p>Such a simple language I suppose would be LISP. And an application of extending the language, say, could be hashmaps where ... what? ... something like?:<p>* define new language keywords, types, and operators in LISP plus a canonical implementation<p>* then have application programmers use those contructs?<p>This is similar in spirit to fix it &quot;in a library not with new keywords&quot; except in addition to the canonical implementation the inclusion of this new work would introduce new (valid) LISP tokens that programmers would re-use?</div><br/><div id="38889350" class="c"><input type="checkbox" id="c-38889350" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#38887232">parent</a><span>|</span><a href="#38887122">next</a><span>|</span><label class="collapse" for="c-38889350">[-]</label><label class="expand" for="c-38889350">[2 more]</label></div><br/><div class="children"><div class="content">But LISP was already 10 years old at the time, so why did it not get traction?<p>Maybe too minimal syntax? I kind of liked LISP, but figuring out whether you looked at the 5th or 6th closing parenthesis somewhere in the code was not fun. In other words the code gets unnecessarily hard to read. A mandatory formatter might haver helped a bit, but that came only with Python. (Still with too much freedom because everyone chooses their own indentation level.)<p>LISP is interpreted, not strongly typed, so definitely another class anyway.</div><br/><div id="38889622" class="c"><input type="checkbox" id="c-38889622" checked=""/><div class="controls bullet"><span class="by">_ph_</span><span>|</span><a href="#38887232">root</a><span>|</span><a href="#38889350">parent</a><span>|</span><a href="#38887122">next</a><span>|</span><label class="collapse" for="c-38889622">[-]</label><label class="expand" for="c-38889622">[1 more]</label></div><br/><div class="children"><div class="content">No, Lisp is not interpreted. Lisp compilers exist for long times. Lisp is dynamic typed. &quot;Strong&quot; typing often is wrongly used as a term for static typing.<p>When programming, Lisp certainly benefits from good editor support - as most other languages do too. And remarkably, the Lisp community pretty much agreed on a formatting and indentation style, so support in editors like Emacs is pretty good.<p>But its dynamic nature together with automatic memory management certainly limited the performance especially on the weak hardware back then. In comparison, it is almost trivial to write a small compiler for a language like Pascal which will produce efficient code. 
Fun fact: the back then popular UCSD Pascal (I used it on the Apple II) was using a bytecode engine as the compilation task.</div><br/></div></div></div></div></div></div><div id="38887122" class="c"><input type="checkbox" id="c-38887122" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38887232">prev</a><span>|</span><a href="#38883924">next</a><span>|</span><label class="collapse" for="c-38887122">[-]</label><label class="expand" for="c-38887122">[1 more]</label></div><br/><div class="children"><div class="content"><i>&quot;I pulled out my copy of the draft report on Algol 68 and showed it to her. She fainted.&quot;</i><p>This is that document in final form.[1] There is also an &quot;Informal introduction&quot; and an &quot;Very informal introduction&quot;, because the spec is incomprehensible. They had a terrible time talking about syntax back then. They were also trying to talk about semantics of parallelism, but it didn&#x27;t go well. This was the &quot;do this to all that stuff&quot; era of parallelism, which maps well to some number-crunching problems.<p>The funny thing is that the Algol-60 Report is very simple.<p>[1] <a href="https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;ALGOL&#x2F;report&#x2F;Algol68_revised_report-AB.pdf" rel="nofollow">https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;ALGOL&#x2F;report&#x2F;A...</a></div><br/></div></div><div id="38883924" class="c"><input type="checkbox" id="c-38883924" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#38887122">prev</a><span>|</span><a href="#38887870">next</a><span>|</span><label class="collapse" for="c-38883924">[-]</label><label class="expand" for="c-38883924">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.</i> — AJP<p>&gt; <i>31. Simplicity does not precede complexity, but follows it.</i> — AJP<p>&gt; <i>&quot;[Algol 60] is a language so far ahead of its time that it was not only an improvement on its predecessors but also on nearly all its successors.&quot;</i> —CARH<p>as to universal languages, cf <a href="http:&#x2F;&#x2F;cdent.org&#x2F;examples&#x2F;hello-world&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;cdent.org&#x2F;examples&#x2F;hello-world&#x2F;index.html</a></div><br/></div></div><div id="38887870" class="c"><input type="checkbox" id="c-38887870" checked=""/><div class="controls bullet"><span class="by">microtherion</span><span>|</span><a href="#38883924">prev</a><span>|</span><a href="#38887319">next</a><span>|</span><label class="collapse" for="c-38887870">[-]</label><label class="expand" for="c-38887870">[2 more]</label></div><br/><div class="children"><div class="content">Word I learned today: &quot;Knuthput&quot;.<p>Apparently it refers to one proposal for I&#x2F;O in Algol 60 (which left I&#x2F;O unspecified): <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;364099.364222" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;364099.364222</a></div><br/><div id="38889373" class="c"><input type="checkbox" id="c-38889373" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#38887870">parent</a><span>|</span><a href="#38887319">next</a><span>|</span><label class="collapse" for="c-38889373">[-]</label><label class="expand" for="c-38889373">[1 more]</label></div><br/><div class="children"><div class="content">Had never heard that either. At least Knuth did not take it personally, he used Pascal later :)</div><br/></div></div></div></div><div id="38887319" class="c"><input type="checkbox" id="c-38887319" checked=""/><div class="controls bullet"><span class="by">vincent-manis</span><span>|</span><a href="#38887870">prev</a><span>|</span><a href="#38886831">next</a><span>|</span><label class="collapse" for="c-38887319">[-]</label><label class="expand" for="c-38887319">[3 more]</label></div><br/><div class="children"><div class="content">I said this on another forum recently. There were good reasons for rejecting ALGOL 68, both because of the language&#x27;s complexity, and because of the incomprehensible 2-level grammars of the Report. (Disclaimer: my grad supervisor was one of the editors of the Report, and I did a small amount of ALGOL68-related work then.) Languages like Oberon exemplify simplicity; at a different abstraction level, so does Scheme. But the complexity battle has been lost: for example, C++ is arguably far more complex than ALGOL68.</div><br/><div id="38888863" class="c"><input type="checkbox" id="c-38888863" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#38887319">parent</a><span>|</span><a href="#38888256">next</a><span>|</span><label class="collapse" for="c-38888863">[-]</label><label class="expand" for="c-38888863">[1 more]</label></div><br/><div class="children"><div class="content">I was interested to check how various languages compare in complexity to ALGOL 68. As a rough proxy for complexity let&#x27;s look at the number of pages in their language specifications (excluding glossaries, examples, libraries, etc.):<p>* ALGOL 68 spec: 209 pages<p>* C: 418 pages<p>* C++: 457 pages<p>* Python: 148 pages (but doesn&#x27;t include a lot of things in PEPs)<p>* Rust: doesn&#x27;t have a specification but does have a 600 page book<p>* Lisp: 48 pages<p>* Go: 109 pages<p>Some of these have more detail than others - the C spec is very detailed and the Go one is clearly intended to be more human readable than detail oriented. Also I&#x27;ve excluded core library specs here and they add a lot to some of these specs, but arguably some are &quot;more core&quot; than others so they&#x27;re not really comparable.</div><br/></div></div><div id="38888256" class="c"><input type="checkbox" id="c-38888256" checked=""/><div class="controls bullet"><span class="by">angiosperm</span><span>|</span><a href="#38887319">parent</a><span>|</span><a href="#38888863">prev</a><span>|</span><a href="#38886831">next</a><span>|</span><label class="collapse" for="c-38888256">[-]</label><label class="expand" for="c-38888256">[1 more]</label></div><br/><div class="children"><div class="content">And correspondingly more useful. The lesson of Wirth&#x27;s speech is that it is hard to get people to give up what is useful.</div><br/></div></div></div></div><div id="38886831" class="c"><input type="checkbox" id="c-38886831" checked=""/><div class="controls bullet"><span class="by">tcbawo</span><span>|</span><a href="#38887319">prev</a><span>|</span><a href="#38886514">next</a><span>|</span><label class="collapse" for="c-38886831">[-]</label><label class="expand" for="c-38886831">[2 more]</label></div><br/><div class="children"><div class="content">It is interesting that he elevates the use case of computer science education as the most important use case for a programming language to satisfy.  It seems to presage his later works, including Oberon.</div><br/><div id="38887921" class="c"><input type="checkbox" id="c-38887921" checked=""/><div class="controls bullet"><span class="by">glompers</span><span>|</span><a href="#38886831">parent</a><span>|</span><a href="#38886514">next</a><span>|</span><label class="collapse" for="c-38887921">[-]</label><label class="expand" for="c-38887921">[1 more]</label></div><br/><div class="children"><div class="content">Universities have always been about correctly incubating the future practictioners of each field.  The recent rush to relate each field&#x27;s research projects to making commerce more efficient is putting (not in all cases, but in many) the cart before the horse.</div><br/></div></div></div></div><div id="38886514" class="c"><input type="checkbox" id="c-38886514" checked=""/><div class="controls bullet"><span class="by">rantingdemon</span><span>|</span><a href="#38886831">prev</a><span>|</span><label class="collapse" for="c-38886514">[-]</label><label class="expand" for="c-38886514">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a very interesting piece.  Thanks for sharing.<p>I&#x27;m going through a bit of Pascal renewal now, years after school.  The spirit of the language seems to come through in this posting by Nicklaus Wirth.</div><br/></div></div></div></div></div></div></div></body></html>