<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714467680628" as="style"/><link rel="stylesheet" href="styles.css?v=1714467680628"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://sqlite.org/draft/whybytecode.html">Why SQLite Uses Bytecode</a> <span class="domain">(<a href="https://sqlite.org">sqlite.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>69 comments</span></div><br/><div><div id="40207533" class="c"><input type="checkbox" id="c-40207533" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#40207124">next</a><span>|</span><label class="collapse" for="c-40207533">[-]</label><label class="expand" for="c-40207533">[8 more]</label></div><br/><div class="children"><div class="content">The page is the result of this exchange on Twitter:<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;gorilla0513&#x2F;status&#x2F;1784756577465200740" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;gorilla0513&#x2F;status&#x2F;1784756577465200740</a><p>I was surprised to receive a reply from you, the author. Thank you :)
Since I&#x27;m a novice with both compilers and databases, could you tell me what the advantages and disadvantages are of using a VM with SQLite?<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;DRichardHipp&#x2F;status&#x2F;1784783482788413491" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;DRichardHipp&#x2F;status&#x2F;1784783482788413491</a><p>It is difficult to summarize the advantages and disadvantages of byte-code versus AST for SQL in a tweet.  I need to write a new page on this topic for the SQLite documentation.  Please remind me if something does not appear in about a week.</div><br/><div id="40207746" class="c"><input type="checkbox" id="c-40207746" checked=""/><div class="controls bullet"><span class="by">coolandsmartrr</span><span>|</span><a href="#40207533">parent</a><span>|</span><a href="#40207587">next</a><span>|</span><label class="collapse" for="c-40207746">[-]</label><label class="expand" for="c-40207746">[3 more]</label></div><br/><div class="children"><div class="content">I am amazed that the author (D Richard Hipp) made an effort to find and respond to a tweet that was (1) not directed&#x2F;&quot;@tted&quot; at him or (2) written in his native language of English (original tweet is in Japanese[1]).<p>[1] <a href="https:&#x2F;&#x2F;twitter.com&#x2F;gorilla0513&#x2F;status&#x2F;1784623660193677762" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;gorilla0513&#x2F;status&#x2F;1784623660193677762</a></div><br/><div id="40208271" class="c"><input type="checkbox" id="c-40208271" checked=""/><div class="controls bullet"><span class="by">jonp888</span><span>|</span><a href="#40207533">root</a><span>|</span><a href="#40207746">parent</a><span>|</span><a href="#40207587">next</a><span>|</span><label class="collapse" for="c-40208271">[-]</label><label class="expand" for="c-40208271">[2 more]</label></div><br/><div class="children"><div class="content">Side note, but I&#x27;m amazed that anyone that is not a journalist or a politician still actively uses X&#x2F;twitter. Everyone I used to follow has stopped.</div><br/><div id="40208644" class="c"><input type="checkbox" id="c-40208644" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#40207533">root</a><span>|</span><a href="#40208271">parent</a><span>|</span><a href="#40207587">next</a><span>|</span><label class="collapse" for="c-40208644">[-]</label><label class="expand" for="c-40208644">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen more people use it, as in being actually active on it, and it pops up everywhere due to the community note memes. But yeah I really need to get around creating a Mastodon account since some very good posters moved there too.</div><br/></div></div></div></div></div></div><div id="40207587" class="c"><input type="checkbox" id="c-40207587" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40207533">parent</a><span>|</span><a href="#40207746">prev</a><span>|</span><a href="#40207124">next</a><span>|</span><label class="collapse" for="c-40207587">[-]</label><label class="expand" for="c-40207587">[4 more]</label></div><br/><div class="children"><div class="content">There are three approaches:<p>1. interpreted code<p>2. compiled then interpreted bytecode<p>3. compiled machine code<p>The further up, the simpler.<p>The further down, the faster.</div><br/><div id="40207964" class="c"><input type="checkbox" id="c-40207964" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#40207533">root</a><span>|</span><a href="#40207587">parent</a><span>|</span><a href="#40207686">next</a><span>|</span><label class="collapse" for="c-40207964">[-]</label><label class="expand" for="c-40207964">[1 more]</label></div><br/><div class="children"><div class="content">4. lots of small building blocks of static machine code precompiled&#x2F;shipped with DB software binary, later iterated &amp; looped through based on the query plan the optimizer came up with. Oracle does this with their columnar&#x2F;vector&#x2F;SIMD processing In-Memory Database option (it&#x27;s not like LLVM as it doesn&#x27;t compile&#x2F;link&#x2F;rearrange the existing binary building blocks, just jumps &amp; loops through the existing ones in the required order)<p>Edit: It&#x27;s worth clarifying that the <i>entire</i> codebase does <i>not</i> run like that, not even the entire plan tree - just the scans and tight vectorized aggregation&#x2F;join loops on the columns&#x2F;data ranges that happen to be held in RAM in a columnar format.</div><br/></div></div><div id="40207686" class="c"><input type="checkbox" id="c-40207686" checked=""/><div class="controls bullet"><span class="by">branko_d</span><span>|</span><a href="#40207533">root</a><span>|</span><a href="#40207587">parent</a><span>|</span><a href="#40207964">prev</a><span>|</span><a href="#40207962">next</a><span>|</span><label class="collapse" for="c-40207686">[-]</label><label class="expand" for="c-40207686">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 2. compiled then interpreted bytecode<p>You can also compile to bytecode (when building), and then compile that bytecode to the machine code (when running). That way, you can take advantage of the exact processor that is running your program.<p>This is the approach taken by .NET and Java, and I presume most other runtime environments that use bytecode.</div><br/></div></div><div id="40207962" class="c"><input type="checkbox" id="c-40207962" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#40207533">root</a><span>|</span><a href="#40207587">parent</a><span>|</span><a href="#40207686">prev</a><span>|</span><a href="#40207124">next</a><span>|</span><label class="collapse" for="c-40207962">[-]</label><label class="expand" for="c-40207962">[1 more]</label></div><br/><div class="children"><div class="content">There is also JIT bytecode.</div><br/></div></div></div></div></div></div><div id="40207124" class="c"><input type="checkbox" id="c-40207124" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40207533">prev</a><span>|</span><a href="#40208284">next</a><span>|</span><label class="collapse" for="c-40207124">[-]</label><label class="expand" for="c-40207124">[3 more]</label></div><br/><div class="children"><div class="content"><i>The problem of rendering a tree-of-objects as a table is sufficiently difficult that nobody does it, as far as I know. Hence, no tree-of-objects database engine provides the level of detail in their &quot;EXPLAIN&quot; output that SQLite provides.</i><p>I believe Microsoft SQL Server uses an object tree internally, and yet its query plan output is a table:<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;t-sql&#x2F;statements&#x2F;set-showplan-all-transact-sql" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;t-sql&#x2F;statements&#x2F;set-s...</a></div><br/><div id="40207688" class="c"><input type="checkbox" id="c-40207688" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#40207124">parent</a><span>|</span><a href="#40207214">next</a><span>|</span><label class="collapse" for="c-40207688">[-]</label><label class="expand" for="c-40207688">[1 more]</label></div><br/><div class="children"><div class="content">It can also execute a query incrementally. In fact, certain features rely on this behavior. “Watch live data” (in SSMS) for extended events is actually an infinite table-valued function. It’s not exactly rocket science to do in a database, you just need to model data sources and operators as iterators.</div><br/></div></div><div id="40207214" class="c"><input type="checkbox" id="c-40207214" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40207124">parent</a><span>|</span><a href="#40207688">prev</a><span>|</span><a href="#40208284">next</a><span>|</span><label class="collapse" for="c-40207214">[-]</label><label class="expand" for="c-40207214">[1 more]</label></div><br/><div class="children"><div class="content">Typically you get XML for showplan because it can represent the tree structure better.</div><br/></div></div></div></div><div id="40208284" class="c"><input type="checkbox" id="c-40208284" checked=""/><div class="controls bullet"><span class="by">manx</span><span>|</span><a href="#40207124">prev</a><span>|</span><a href="#40208662">next</a><span>|</span><label class="collapse" for="c-40208284">[-]</label><label class="expand" for="c-40208284">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering if one could write this bytecode directly (or with a higher level imperative language) instead of SQL. Often, the programmer knows exactly which index lookups need to happen in a loop, while it seems like a burden to express that in SQL. This might also be an opportunity to create a different type safe dsl for database access.</div><br/><div id="40208339" class="c"><input type="checkbox" id="c-40208339" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#40208284">parent</a><span>|</span><a href="#40208662">next</a><span>|</span><label class="collapse" for="c-40208339">[-]</label><label class="expand" for="c-40208339">[1 more]</label></div><br/><div class="children"><div class="content">I was wondering the same thing. And in particular if a new query language that avoided many of the pitfalls of SQL could compile down to that bytecode and avoid having to deal with SQL as an intermediate representation. Also, if you can compile to bytecode ahead of time, then that could save the time needed to parse the text of a sql query to bytecode at runtime.</div><br/></div></div></div></div><div id="40208662" class="c"><input type="checkbox" id="c-40208662" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40208284">prev</a><span>|</span><a href="#40208704">next</a><span>|</span><label class="collapse" for="c-40208662">[-]</label><label class="expand" for="c-40208662">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Hence, no tree-of-objects database engine provides the level of detail in their &quot;EXPLAIN&quot; output that SQLite provides.<p>I&#x27;ve seen some cool graphical visualisation tools for postgres <a href="http:&#x2F;&#x2F;tatiyants.com&#x2F;postgres-query-plan-visualization&#x2F;" rel="nofollow">http:&#x2F;&#x2F;tatiyants.com&#x2F;postgres-query-plan-visualization&#x2F;</a></div><br/></div></div><div id="40208704" class="c"><input type="checkbox" id="c-40208704" checked=""/><div class="controls bullet"><span class="by">chucke1992</span><span>|</span><a href="#40208662">prev</a><span>|</span><a href="#40207603">next</a><span>|</span><label class="collapse" for="c-40208704">[-]</label><label class="expand" for="c-40208704">[1 more]</label></div><br/><div class="children"><div class="content">Well SQLite is basically a religious cult at this point. I am always impressed by it.</div><br/></div></div><div id="40207603" class="c"><input type="checkbox" id="c-40207603" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#40208704">prev</a><span>|</span><a href="#40206950">next</a><span>|</span><label class="collapse" for="c-40207603">[-]</label><label class="expand" for="c-40207603">[4 more]</label></div><br/><div class="children"><div class="content">I recently implemented my own expression evaluator in java for in-memory data frames, and once you think about doing that deeply, you very quickly understand the need for bytecode. If you directly evaluate the expression using a tree representation, you basically have to do a whole lot of branching (either via switch statements or polymorphism) for every single line of useful operation. Yes, the branch predictor kicks in and it means that your code wouldn’t be as slow as if it didn’t, but it is still measurably slower than if you converted the expression into bytecode once and just ran that on all rows instead.</div><br/><div id="40208538" class="c"><input type="checkbox" id="c-40208538" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#40207603">parent</a><span>|</span><a href="#40207921">next</a><span>|</span><label class="collapse" for="c-40208538">[-]</label><label class="expand" for="c-40208538">[1 more]</label></div><br/><div class="children"><div class="content">You should look at <a href="https:&#x2F;&#x2F;janino-compiler.github.io&#x2F;janino&#x2F;" rel="nofollow">https:&#x2F;&#x2F;janino-compiler.github.io&#x2F;janino&#x2F;</a> it can compile Java into class files in memory that can be directly executed.</div><br/></div></div><div id="40207921" class="c"><input type="checkbox" id="c-40207921" checked=""/><div class="controls bullet"><span class="by">eklavya</span><span>|</span><a href="#40207603">parent</a><span>|</span><a href="#40208538">prev</a><span>|</span><a href="#40206950">next</a><span>|</span><label class="collapse" for="c-40207921">[-]</label><label class="expand" for="c-40207921">[2 more]</label></div><br/><div class="children"><div class="content">Bytecode will only impact packing, so more efficient ram, cache and cpu wise. But I don&#x27;t understand how it would help with branching? You still have to make the same decisions? As in the bytecode executor still needs to do differnt things based on the op code, its not in hardware.</div><br/><div id="40208331" class="c"><input type="checkbox" id="c-40208331" checked=""/><div class="controls bullet"><span class="by">hickelpickle</span><span>|</span><a href="#40207603">root</a><span>|</span><a href="#40207921">parent</a><span>|</span><a href="#40206950">next</a><span>|</span><label class="collapse" for="c-40208331">[-]</label><label class="expand" for="c-40208331">[1 more]</label></div><br/><div class="children"><div class="content">There is threaded bytecode as well, which uses direct jumping vs a switch for dispatch. This can improve branch prediction, though it is a debated topic and may not offer much improvement for modern processors.</div><br/></div></div></div></div></div></div><div id="40206950" class="c"><input type="checkbox" id="c-40206950" checked=""/><div class="controls bullet"><span class="by">chrisaycock</span><span>|</span><a href="#40207603">prev</a><span>|</span><a href="#40208077">next</a><span>|</span><label class="collapse" for="c-40206950">[-]</label><label class="expand" for="c-40206950">[20 more]</label></div><br/><div class="children"><div class="content">SQLite&#x27;s design docs were the first time I had seen a database use a virtual machine instead of walking a tree. I later noticed VMs in libraries, embedded DSLs, and other applications outside of large general-purpose programming languages. That really drove home for me that VMs could be anywhere and were often a useful step in handling a user&#x27;s expressions.</div><br/><div id="40207416" class="c"><input type="checkbox" id="c-40207416" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#40206950">parent</a><span>|</span><a href="#40207215">next</a><span>|</span><label class="collapse" for="c-40207416">[-]</label><label class="expand" for="c-40207416">[4 more]</label></div><br/><div class="children"><div class="content">Stack-based VMs, like SQLite&#x27;s (I think), ARE trees. A stack based VM&#x27;s bytecode (without DUP and POP) is just the post-order depth-first traversal of the corresponding expression tree. With DUP you have a connected acyclic DAG. With POP you have an acyclic DAG with one or more components. With loops you have a full graph.<p>When looked at this way, a VM makes the most sense actually because a pointer-heavy tree implementation is just terrible for caching and is super wasteful. Also, most SQL plans are trees (Until you get to WITH RECURSIVE).<p>I&#x27;m working on a CEP in C right now and a stack-based bytecode is simply the most &#x27;obvious&#x27; way to represent a tree when you don&#x27;t want to have to deal with lots of memory allocations. Just pre-allocate a buffer large enough and increment and go.<p>Either way, try taking something like the following and printing an expression tree like the one below<p><pre><code>  LITERAL 2
  LITERAL 3
  LITERAL 4
  MUL
  PLUS
</code></pre>
now, write something to produce on a terminal, the following:<p><pre><code>  Plus
    Mul
      3
      4
    2
</code></pre>
You should be able to do this in a simple iteration through the ops. Try it! Then try it with the variations above.<p>Now, try writing ops to manipulate and rewrite it. It&#x27;s actually really a fun way to represent trees.</div><br/><div id="40207507" class="c"><input type="checkbox" id="c-40207507" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207416">parent</a><span>|</span><a href="#40207215">next</a><span>|</span><label class="collapse" for="c-40207507">[-]</label><label class="expand" for="c-40207507">[3 more]</label></div><br/><div class="children"><div class="content">SQLite&#x27;s VM is register-based, not stack-based.</div><br/><div id="40207923" class="c"><input type="checkbox" id="c-40207923" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207507">parent</a><span>|</span><a href="#40207868">next</a><span>|</span><label class="collapse" for="c-40207923">[-]</label><label class="expand" for="c-40207923">[1 more]</label></div><br/><div class="children"><div class="content">It’s been both - was stack, converted to register[0][1].<p>[0] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;vdbe.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;vdbe.html</a><p>[1] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;src&#x2F;info&#x2F;051ec01f2799e095" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;src&#x2F;info&#x2F;051ec01f2799e095</a></div><br/></div></div><div id="40207868" class="c"><input type="checkbox" id="c-40207868" checked=""/><div class="controls bullet"><span class="by">ojosilva</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207507">parent</a><span>|</span><a href="#40207923">prev</a><span>|</span><a href="#40207215">next</a><span>|</span><label class="collapse" for="c-40207868">[-]</label><label class="expand" for="c-40207868">[1 more]</label></div><br/><div class="children"><div class="content">Does SQLite&#x27;s VM have an API? I mean, one where I can build and issue opcodes into directly.</div><br/></div></div></div></div></div></div><div id="40207215" class="c"><input type="checkbox" id="c-40207215" checked=""/><div class="controls bullet"><span class="by">bane</span><span>|</span><a href="#40206950">parent</a><span>|</span><a href="#40207416">prev</a><span>|</span><a href="#40207255">next</a><span>|</span><label class="collapse" for="c-40207215">[-]</label><label class="expand" for="c-40207215">[5 more]</label></div><br/><div class="children"><div class="content">VMs really can be. They have a long history in code portability. In the old days it really wasn&#x27;t uncommon to use an approach centered around some interpretable byte code running in a vm, where the reusable vm was all that needed porting to different architectures and operating systems. This all happened well before Java.<p>It was really big in gaming, Zork, Sierra games, LucasArts games, and even a few more &quot;action&quot; games like Flashback were all designed around VMs to make porting somewhat sane. Running the byte code is usually not the performance bottleneck in these cases but drawing stuff to the screen is, and the VM had to handle that.</div><br/><div id="40207478" class="c"><input type="checkbox" id="c-40207478" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207215">parent</a><span>|</span><a href="#40207255">next</a><span>|</span><label class="collapse" for="c-40207478">[-]</label><label class="expand" for="c-40207478">[4 more]</label></div><br/><div class="children"><div class="content">And Pascal p-code! Not the first, I’ve heard, but I believe it’s close to being the first.</div><br/><div id="40207664" class="c"><input type="checkbox" id="c-40207664" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207478">parent</a><span>|</span><a href="#40207255">next</a><span>|</span><label class="collapse" for="c-40207664">[-]</label><label class="expand" for="c-40207664">[3 more]</label></div><br/><div class="children"><div class="content">One of the first was Burroughs B5000,<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Burroughs_Large_Systems" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Burroughs_Large_Systems</a><p>It used an almost memory safe systems language, ESPOL, zero Assembly, all CPU capabilities are exposed via intrisics, one of the first recoded uses of unsafe code blocks, there was tagging and capabilities support, the CPUs were microcoded. All of this in 1961, a decade before C came to be.<p>ESPOL was quickly replaced by NEWP, although there are very little data when it happened, probly a couple of years later.<p>Nowadays it is still sold by Unisys under the guise of being a mainframe system for those that value security above all, as ClearPath MCP, and you can get NEWP manual.<p><a href="https:&#x2F;&#x2F;www.unisys.com&#x2F;solutions&#x2F;enterprise-computing&#x2F;clearpath-forward&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.unisys.com&#x2F;solutions&#x2F;enterprise-computing&#x2F;clearp...</a><p><a href="https:&#x2F;&#x2F;public.support.unisys.com&#x2F;aseries&#x2F;docs&#x2F;ClearPath-MCP-18.0&#x2F;86002003-408.pdf" rel="nofollow">https:&#x2F;&#x2F;public.support.unisys.com&#x2F;aseries&#x2F;docs&#x2F;ClearPath-MCP...</a></div><br/><div id="40207715" class="c"><input type="checkbox" id="c-40207715" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207664">parent</a><span>|</span><a href="#40207255">next</a><span>|</span><label class="collapse" for="c-40207715">[-]</label><label class="expand" for="c-40207715">[2 more]</label></div><br/><div class="children"><div class="content">the b5000 was one of the first <i>non</i>-virtual stack machines, but its instruction set isn&#x27;t any more of a virtual machine than the 8088&#x27;s or the pdp-10&#x27;s. there were a number of interpreted stack languages in the 50s, though not nearly as many as there would be later</div><br/><div id="40207810" class="c"><input type="checkbox" id="c-40207810" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207715">parent</a><span>|</span><a href="#40207255">next</a><span>|</span><label class="collapse" for="c-40207810">[-]</label><label class="expand" for="c-40207810">[1 more]</label></div><br/><div class="children"><div class="content">When one does digital archeology is it quite common to see Assembly referred to as bytecode, when the CPUs are actually interpreters written in microcode.<p>Another example, all the Xerox PARC workstations, which loaded the respective interpreter (Smalltalk, Interlisp, Mesa, Mesa&#x2F;Cedar) into the CPU as first step during the boot process.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40207255" class="c"><input type="checkbox" id="c-40207255" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#40206950">parent</a><span>|</span><a href="#40207215">prev</a><span>|</span><a href="#40207190">next</a><span>|</span><label class="collapse" for="c-40207255">[-]</label><label class="expand" for="c-40207255">[1 more]</label></div><br/><div class="children"><div class="content">VMs are a persistently underrated tool by people who think the conversation begins and ends at VirtualBox. They are a phenomenal way to constrain the surface area of what one&#x27;s own code has to target, and that&#x27;s always a plus.</div><br/></div></div><div id="40207190" class="c"><input type="checkbox" id="c-40207190" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#40206950">parent</a><span>|</span><a href="#40207255">prev</a><span>|</span><a href="#40207333">next</a><span>|</span><label class="collapse" for="c-40207190">[-]</label><label class="expand" for="c-40207190">[2 more]</label></div><br/><div class="children"><div class="content">Everything is either a compiler or interpreter</div><br/><div id="40207253" class="c"><input type="checkbox" id="c-40207253" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207190">parent</a><span>|</span><a href="#40207333">next</a><span>|</span><label class="collapse" for="c-40207253">[-]</label><label class="expand" for="c-40207253">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why SICP is often brought up in contexts that are not explicitly about interpreters :)</div><br/></div></div></div></div><div id="40207333" class="c"><input type="checkbox" id="c-40207333" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#40206950">parent</a><span>|</span><a href="#40207190">prev</a><span>|</span><a href="#40207439">next</a><span>|</span><label class="collapse" for="c-40207333">[-]</label><label class="expand" for="c-40207333">[1 more]</label></div><br/><div class="children"><div class="content">Or indeed any time complexity need to be layered. A VM design doesn&#x27;t even have to have an explicit bytecode compilation stage -- you can write an interpreter that runs as the instructions are issued.<p>David Parnas talks a lot about this as a way to reliable modularisation: <a href="https:&#x2F;&#x2F;two-wrongs.com&#x2F;deliberate-abstraction.html" rel="nofollow">https:&#x2F;&#x2F;two-wrongs.com&#x2F;deliberate-abstraction.html</a></div><br/></div></div><div id="40207439" class="c"><input type="checkbox" id="c-40207439" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#40206950">parent</a><span>|</span><a href="#40207333">prev</a><span>|</span><a href="#40207056">next</a><span>|</span><label class="collapse" for="c-40207439">[-]</label><label class="expand" for="c-40207439">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t MS Word internally run a Forth-like VM? I remember reading an article by someone who decompiled an early MS-DOS version of Word only to discover that there was a VM inside.</div><br/><div id="40208671" class="c"><input type="checkbox" id="c-40208671" checked=""/><div class="controls bullet"><span class="by">jpfr</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207439">parent</a><span>|</span><a href="#40207056">next</a><span>|</span><label class="collapse" for="c-40208671">[-]</label><label class="expand" for="c-40208671">[1 more]</label></div><br/><div class="children"><div class="content">They called it p-code at the time. The purpose was (purported) to simplify the porting between architectures.<p><a href="https:&#x2F;&#x2F;casadevall.pro&#x2F;articles&#x2F;2020&#x2F;11&#x2F;compiling-word-for-windows-from-os&#x2F;2-1.2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;casadevall.pro&#x2F;articles&#x2F;2020&#x2F;11&#x2F;compiling-word-for-w...</a></div><br/></div></div></div></div><div id="40207056" class="c"><input type="checkbox" id="c-40207056" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#40206950">parent</a><span>|</span><a href="#40207439">prev</a><span>|</span><a href="#40208077">next</a><span>|</span><label class="collapse" for="c-40207056">[-]</label><label class="expand" for="c-40207056">[4 more]</label></div><br/><div class="children"><div class="content">SQLite is the first one I’ve looked at the internals of. Do others walk an AST of the query instead?</div><br/><div id="40207072" class="c"><input type="checkbox" id="c-40207072" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207056">parent</a><span>|</span><a href="#40207151">next</a><span>|</span><label class="collapse" for="c-40207072">[-]</label><label class="expand" for="c-40207072">[1 more]</label></div><br/><div class="children"><div class="content">FTA:<p>&gt; Tree-Of-Objects → The input SQL is translated in a tree of objects that represent the processing to be done. The SQL is executed by walking this tree. This is the technique used by MySQL and PostgreSQL.</div><br/></div></div><div id="40207151" class="c"><input type="checkbox" id="c-40207151" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207056">parent</a><span>|</span><a href="#40207072">prev</a><span>|</span><a href="#40207070">next</a><span>|</span><label class="collapse" for="c-40207151">[-]</label><label class="expand" for="c-40207151">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I’d read the article a couple years ago and forgot he goes into depth on the other approaches. My bad.</div><br/></div></div><div id="40207070" class="c"><input type="checkbox" id="c-40207070" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#40206950">root</a><span>|</span><a href="#40207056">parent</a><span>|</span><a href="#40207151">prev</a><span>|</span><a href="#40208077">next</a><span>|</span><label class="collapse" for="c-40207070">[-]</label><label class="expand" for="c-40207070">[1 more]</label></div><br/><div class="children"><div class="content">Yes, postgres for example. It maps pretty close to what you see from `explain` where the ops are pretty high level, reducing interpreter overhead. JIT&#x27;s big gain is speeding up reading values out of row data</div><br/></div></div></div></div></div></div><div id="40208077" class="c"><input type="checkbox" id="c-40208077" checked=""/><div class="controls bullet"><span class="by">jiehong</span><span>|</span><a href="#40206950">prev</a><span>|</span><a href="#40207245">next</a><span>|</span><label class="collapse" for="c-40208077">[-]</label><label class="expand" for="c-40208077">[2 more]</label></div><br/><div class="children"><div class="content">SQLite EXPLAIN plan is indeed represented as a table, but I don’t find it necessarily that much easier to read and understand.<p>I often miss having the cardinality and the amount of bytes read for each part of the query like Oracle query plans provide.<p>Or is everyone really that happy with SQLite query plans?</div><br/><div id="40208112" class="c"><input type="checkbox" id="c-40208112" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#40208077">parent</a><span>|</span><a href="#40207245">next</a><span>|</span><label class="collapse" for="c-40208112">[-]</label><label class="expand" for="c-40208112">[1 more]</label></div><br/><div class="children"><div class="content">There is EXPLAIN QUERY PLAN which outputs usual high level plan description. But there is no easily reached disk&#x2F;cache usage stats.</div><br/></div></div></div></div><div id="40207245" class="c"><input type="checkbox" id="c-40207245" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40208077">prev</a><span>|</span><a href="#40207444">next</a><span>|</span><label class="collapse" for="c-40207245">[-]</label><label class="expand" for="c-40207245">[6 more]</label></div><br/><div class="children"><div class="content">Running bytecode is much lower latency than compiling into native code.  If you&#x27;re not bottlenecked by running the bytecode (as opposed to memory or disk speed), you don&#x27;t really have to JIT it any further into native code.</div><br/><div id="40207614" class="c"><input type="checkbox" id="c-40207614" checked=""/><div class="controls bullet"><span class="by">rhdunn</span><span>|</span><a href="#40207245">parent</a><span>|</span><a href="#40207282">next</a><span>|</span><label class="collapse" for="c-40207614">[-]</label><label class="expand" for="c-40207614">[1 more]</label></div><br/><div class="children"><div class="content">Which is why JavaScript engines (and JIT compilers for other languages) are typically designed to:<p>1. start interpreting the code once it has been parsed, and start jitting a function being called;<p>2.  generate naive bytecode for the function that generates native code equivalents of the run actions of the AST (including some fast-path code for simple cases such as adding two 32-bit integers, and falling back to function calls to perform the add on more complex types);<p>3.  generate more optimal code for sequences of instructions in the background, such as entire for&#x2F;while loops, then patch in calls to those fast-path versions when ready.<p>That way you can start running the code immediately after parsing it, and can switch to the faster versions when they are ready if the code takes longer to run in the slower version.</div><br/></div></div><div id="40207282" class="c"><input type="checkbox" id="c-40207282" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40207245">parent</a><span>|</span><a href="#40207614">prev</a><span>|</span><a href="#40207444">next</a><span>|</span><label class="collapse" for="c-40207282">[-]</label><label class="expand" for="c-40207282">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, but nobody is seriously considering that unless maybe for huge prepared statements. The argument is usually bytecode vs parser and associated data structures.</div><br/><div id="40207623" class="c"><input type="checkbox" id="c-40207623" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#40207245">root</a><span>|</span><a href="#40207282">parent</a><span>|</span><a href="#40207444">next</a><span>|</span><label class="collapse" for="c-40207623">[-]</label><label class="expand" for="c-40207623">[3 more]</label></div><br/><div class="children"><div class="content">PostgreSQL is not only considering it, they&#x27;re doing it! <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;jit-reason.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;jit-reason.html</a><p>I don&#x27;t have personal experience on it, but I&#x27;ve read that in practice it&#x27;s not worth the effort—at least not yet. Apparently there are some issues with it and it barely speeds up queries (except perhaps certain ones?). I imagine this could be in big part because LLVM is not really a good fit for JIT where you want to spend very little time to do the compilation itself.</div><br/><div id="40208640" class="c"><input type="checkbox" id="c-40208640" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40207245">root</a><span>|</span><a href="#40207623">parent</a><span>|</span><a href="#40207749">next</a><span>|</span><label class="collapse" for="c-40208640">[-]</label><label class="expand" for="c-40208640">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, thanks. I imagine they will have a query planner for the query planner to determine to JIT or not :)</div><br/></div></div><div id="40207749" class="c"><input type="checkbox" id="c-40207749" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40207245">root</a><span>|</span><a href="#40207623">parent</a><span>|</span><a href="#40208640">prev</a><span>|</span><a href="#40207444">next</a><span>|</span><label class="collapse" for="c-40207749">[-]</label><label class="expand" for="c-40207749">[1 more]</label></div><br/><div class="children"><div class="content">Yeah my experience of the pg jit is mostly negative, it’s quite slow and it has a hard time estimating the cost of interpreted v compilation + compiled execution so more often than not it’s actively detrimental. It might fare better if you make heavy use of a limited number of prepared statements.</div><br/></div></div></div></div></div></div></div></div><div id="40207444" class="c"><input type="checkbox" id="c-40207444" checked=""/><div class="controls bullet"><span class="by">megadal</span><span>|</span><a href="#40207245">prev</a><span>|</span><a href="#40208036">next</a><span>|</span><label class="collapse" for="c-40207444">[-]</label><label class="expand" for="c-40207444">[11 more]</label></div><br/><div class="children"><div class="content">Perhaps my understanding is off, but I am pretty sure parsing and translating SQL into bytecode still involves an AST.<p>Just that query processing itself is done from the bytecode (produced presumably from an AST or something similar) rather than directly from the AST itself.<p>If I&#x27;m right I can&#x27;t really see how this performs better unless you&#x27;re excluding the parsing step from benchmarks</div><br/><div id="40207469" class="c"><input type="checkbox" id="c-40207469" checked=""/><div class="controls bullet"><span class="by">miloignis</span><span>|</span><a href="#40207444">parent</a><span>|</span><a href="#40207556">next</a><span>|</span><label class="collapse" for="c-40207469">[-]</label><label class="expand" for="c-40207469">[3 more]</label></div><br/><div class="children"><div class="content">An AST being generated as an intermediate step is mentioned in the article, at least in passing in section 2.4.<p>The reason bytecode is generally faster (not just for SQL, but in most interpreted languages you may use (Python, etc)) is that walking the AST is relatively expensive and doesn&#x27;t treat caches nicely. Bytecode is generally located next to each other in memory, and you can make the bytecode fetch&#x2F;dispatch pretty tight, relative to indirect function calls on an object in an AST.</div><br/><div id="40207540" class="c"><input type="checkbox" id="c-40207540" checked=""/><div class="controls bullet"><span class="by">rhdunn</span><span>|</span><a href="#40207444">root</a><span>|</span><a href="#40207469">parent</a><span>|</span><a href="#40207556">next</a><span>|</span><label class="collapse" for="c-40207540">[-]</label><label class="expand" for="c-40207540">[2 more]</label></div><br/><div class="children"><div class="content">Another advantage to that is that it avoids the branching of the while loop in the interpreter that iterates over the AST, providing better instruction pipelining with having all the run code next to each other.<p>The downside -- especially for dynamic languages like JavaScript -- is that you need to keep all of the type checks and fast-paths in the code, resulting in larger code blocks. With more type analysis you could group fast-path instructions together (e.g. within a while or for loop) but that takes time, which is typically why a JIT engine uses multiple passes -- generate the slower machine code first, then improve the fast-path blocks for code that is long running.</div><br/><div id="40208442" class="c"><input type="checkbox" id="c-40208442" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#40207444">root</a><span>|</span><a href="#40207540">parent</a><span>|</span><a href="#40207556">next</a><span>|</span><label class="collapse" for="c-40208442">[-]</label><label class="expand" for="c-40208442">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another advantage to that is that it avoids the branching of the while loop in the interpreter that iterates over the AST<p>Huh? A bytecode interpreter still ends up branching based on the decoded value of the byte codes. The VM bytecodes are not directly executed by the CPU (at least not usually, Jazelle and some older P-code stuff being rare exceptions).<p>This is what it looks like for the example being discussed (&quot;a massive switch statement&quot;): <a href="https:&#x2F;&#x2F;github.com&#x2F;sqlite&#x2F;sqlite&#x2F;blob&#x2F;b11daa50f9ea11c332bb5913a071c5a0fd6c9993&#x2F;src&#x2F;vdbe.c#L975">https:&#x2F;&#x2F;github.com&#x2F;sqlite&#x2F;sqlite&#x2F;blob&#x2F;b11daa50f9ea11c332bb59...</a><p>Perhaps confusing bytecode generation and interpretation with JIT? JIT is often paired with a bytecode but neither is dependent on the other.</div><br/></div></div></div></div></div></div><div id="40207556" class="c"><input type="checkbox" id="c-40207556" checked=""/><div class="controls bullet"><span class="by">katzenversteher</span><span>|</span><a href="#40207444">parent</a><span>|</span><a href="#40207469">prev</a><span>|</span><a href="#40207457">next</a><span>|</span><label class="collapse" for="c-40207556">[-]</label><label class="expand" for="c-40207556">[1 more]</label></div><br/><div class="children"><div class="content">Quote from the article:<p>&quot;The bytecode generated by SQLite is usually smaller than the corresponding AST coming out of the parser. During initial processing of SQL text (during the call to sqlite3_prepare() and similar) both the AST and the bytecode exist in memory at the same time and so more memory is used then. But that is a transient state. The AST is quickly discarded and its memory recycled [...]&quot;</div><br/></div></div><div id="40207457" class="c"><input type="checkbox" id="c-40207457" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40207444">parent</a><span>|</span><a href="#40207556">prev</a><span>|</span><a href="#40208036">next</a><span>|</span><label class="collapse" for="c-40207457">[-]</label><label class="expand" for="c-40207457">[6 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need one, Lua is another example where no AST is ever generated. In some sense the resulting bytecode closely corresponds to the AST that would have been generated though.</div><br/><div id="40207518" class="c"><input type="checkbox" id="c-40207518" checked=""/><div class="controls bullet"><span class="by">megadal</span><span>|</span><a href="#40207444">root</a><span>|</span><a href="#40207457">parent</a><span>|</span><a href="#40208036">next</a><span>|</span><label class="collapse" for="c-40207518">[-]</label><label class="expand" for="c-40207518">[5 more]</label></div><br/><div class="children"><div class="content">Genuinely asking as parsing without an AST is something I&#x27;ve never seen explained:
How do you go from source code to bytecode without an AST?<p>Isn&#x27;t the bytecode just a flattened representation of an AST obtained by some sort of tree traversal?<p>This seems to imply an AST is involved in the generation of the bytecode</div><br/><div id="40207584" class="c"><input type="checkbox" id="c-40207584" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40207444">root</a><span>|</span><a href="#40207518">parent</a><span>|</span><a href="#40207927">next</a><span>|</span><label class="collapse" for="c-40207584">[-]</label><label class="expand" for="c-40207584">[1 more]</label></div><br/><div class="children"><div class="content">Have you used any parser generator like yacc&#x2F;bison? They have &quot;actions&quot;, which are arbitrary codes that will be executed when some grammar production is detected. For example, `expr ::= expr mulop expr { some code }` will execute `some code` when a multiplicative expression is detected, where intermediate results from two `expr`s and `mulop` are available to that code. This concept of actions generally applies to all sort of parsers, not just generated parsers.<p>Those actions would typically allocate and build (partial) ASTs, but you can do anything with them. You can for example directly evaluate the subexpression if your grammar is simple enough. Likewise bytecodes can be generated on the fly; the only concern here is a backward reference, which has to be patched after the whole expression block gets generated, but otherwise you don&#x27;t have to build any tree-like structure here. (Most practical parsers only need a stack to function.)</div><br/></div></div><div id="40207927" class="c"><input type="checkbox" id="c-40207927" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40207444">root</a><span>|</span><a href="#40207518">parent</a><span>|</span><a href="#40207584">prev</a><span>|</span><a href="#40207675">next</a><span>|</span><label class="collapse" for="c-40207927">[-]</label><label class="expand" for="c-40207927">[1 more]</label></div><br/><div class="children"><div class="content">Another way to think about this is to imagine you are working in a lazy-by-default language like Haskell. The code might seem to build up an AST and then evaluate it, but (disregarding parse errors) the AST is never materialized in memory at once: the tree might only have one level, with its children represented by thunks that continue to parse more of the source code. (If you are unfamiliar with Haskell laziness, imagine that the so-called tree has children that are <i>functions</i> to produce the next level of the tree.) Of course you will need a carefully designed bytecode in order to generate bytecode from AST where the children is not yet known.</div><br/></div></div><div id="40207675" class="c"><input type="checkbox" id="c-40207675" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40207444">root</a><span>|</span><a href="#40207518">parent</a><span>|</span><a href="#40207927">prev</a><span>|</span><a href="#40207728">next</a><span>|</span><label class="collapse" for="c-40207675">[-]</label><label class="expand" for="c-40207675">[1 more]</label></div><br/><div class="children"><div class="content">How you go from source to target code without an AST is that the syntax-directed translation step in your implementation (that which would build the AST) doesn&#x27;t bother with that and just builds the output code instead. The extra traversal is skipped; replaced by the original parser&#x27;s traversal of the raw syntax.<p>E.g. pseudo-Yacc rules for compiling the while loop in a C-like notation.<p><pre><code>  while_loop : WHILE &#x27;(&#x27; expr &#x27;)&#x27; statement
               {
                   let back = get_label();
                   let fwd = get_label();
                   let expr = $3; &#x2F;&#x2F; code for expr recursively generated
                   let stmt = $5; &#x2F;&#x2F; code for statement, recursively generated
                   $$ = make_code(stmt.reg(),
                                  `$back:\n`
                                  `${expr.code()}\n`
                                  `BF ${expr.reg}, $fwd\n`  &#x2F;&#x2F; branch if false
                                  `${stmt.code()}\n`
                                  `JMP $back\n`
                                  `$fwd:\n`)                                
               }
               ;

</code></pre>
Every code fragment coming out of a rule has .code() and .reg(): the generated code, which is just a string, and the output register where it leaves its value. Such representational details are decided by the compiler writer.<p>The while statement produces no value, so we just borrow the statement&#x27;s .reg() as a dummy in the call to make_code; our rule is that every code fragment has an output register, whether it produces a value or not.<p>When the LALR(1) parser reduces this while loop rule to the while_loop grammar symbol, the expr and statements have already been processed; so the rule action has ready access to the code objects for them. We just synthesize a new code object. We grab a pair of labels that we need for the forward and back jump.<p>I&#x27;m assuming we have a vaguely JS-like programming language being used for the grammar rule actions, in which we have template strings with interpolation, and adjacent strings get merged into one. The bytecode assembly is line oriented, so we have \n breaks.<p>One possible kind of expression is a simple integer constant, INTEGER:<p><pre><code>  expr : INTEGER 
         {
           let reg = allocate_reg();
           let val = $1
           $$ = make_code(reg,
                          `LOAD $reg, #$val\n`)
         }
</code></pre>
One possible statement is an empty statement dented by empty curly braces:<p><pre><code>  statement : &#x27;{&#x27; &#x27;}&#x27;
              {
                $$ = make_code(R0,  &#x2F;&#x2F; dedicated zero register
                               &quot;&quot;); &#x2F;&#x2F; no-code solution
              }
</code></pre>
So then when we have    while (1) { }   we might get R1 allocated in the expr rule, like this:<p><pre><code>  LOAD R1, #1\n   ; output register is R1
</code></pre>
then in the while loop, things get put together like this:<p><pre><code>  L0:\n           ; back label
  LOAD R1, #1\n   ; code for expr
  BF R1, L1\n     ; branch if false to L1
                  ; no code came from empty statement
  JMP L0          ; back branch
  L1:\n           ; fwd label</code></pre></div><br/></div></div><div id="40207728" class="c"><input type="checkbox" id="c-40207728" checked=""/><div class="controls bullet"><span class="by">thewakalix</span><span>|</span><a href="#40207444">root</a><span>|</span><a href="#40207518">parent</a><span>|</span><a href="#40207675">prev</a><span>|</span><a href="#40208036">next</a><span>|</span><label class="collapse" for="c-40207728">[-]</label><label class="expand" for="c-40207728">[1 more]</label></div><br/><div class="children"><div class="content">See also: DOM versus streaming.</div><br/></div></div></div></div></div></div></div></div><div id="40208036" class="c"><input type="checkbox" id="c-40208036" checked=""/><div class="controls bullet"><span class="by">bambax</span><span>|</span><a href="#40207444">prev</a><span>|</span><a href="#40207740">next</a><span>|</span><label class="collapse" for="c-40208036">[-]</label><label class="expand" for="c-40208036">[2 more]</label></div><br/><div class="children"><div class="content">Typo: <i>A prepared statement is an object that represents the steps needed</i> [to] <i>accomplish the input SQL</i>.</div><br/><div id="40208241" class="c"><input type="checkbox" id="c-40208241" checked=""/><div class="controls bullet"><span class="by">sgbeal</span><span>|</span><a href="#40208036">parent</a><span>|</span><a href="#40207740">next</a><span>|</span><label class="collapse" for="c-40208241">[-]</label><label class="expand" for="c-40208241">[1 more]</label></div><br/><div class="children"><div class="content">Fixed, thank you for the report. It won&#x27;t be visible on the site until the next time it&#x27;s rebuilt.</div><br/></div></div></div></div><div id="40207740" class="c"><input type="checkbox" id="c-40207740" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#40208036">prev</a><span>|</span><a href="#40207412">next</a><span>|</span><label class="collapse" for="c-40207740">[-]</label><label class="expand" for="c-40207740">[1 more]</label></div><br/><div class="children"><div class="content">Looks like SQLite could benefit from copy-and-patch JIT compiler.</div><br/></div></div><div id="40207412" class="c"><input type="checkbox" id="c-40207412" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#40207740">prev</a><span>|</span><a href="#40207194">next</a><span>|</span><label class="collapse" for="c-40207412">[-]</label><label class="expand" for="c-40207412">[4 more]</label></div><br/><div class="children"><div class="content">I was surprised the text didn’t mention one major difference between the byte code approach vs AST: coupling.<p>When your database engine runs in-process, there is no possibility of the server and the client library having diverging versions. But this is common with traditional databases.<p>Once you bake in the execution steps („how to execute“) instead of describing the query via AST („what to execute“), an important part of the execution logic now lives in the driver.<p>I suspect this complicates version upgrades and bugfixes, because the database is less self-contained.<p>Not an issue for sqlite, potentially disastrous for mysql.</div><br/><div id="40207505" class="c"><input type="checkbox" id="c-40207505" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40207412">parent</a><span>|</span><a href="#40207194">next</a><span>|</span><label class="collapse" for="c-40207505">[-]</label><label class="expand" for="c-40207505">[3 more]</label></div><br/><div class="children"><div class="content">Do clients typically communicate with the server in some AST representation instead of, well, SQL? I&#x27;d be surprised if that much parsing&#x2F;planning happens on the client.</div><br/><div id="40207537" class="c"><input type="checkbox" id="c-40207537" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#40207412">root</a><span>|</span><a href="#40207505">parent</a><span>|</span><a href="#40207194">next</a><span>|</span><label class="collapse" for="c-40207537">[-]</label><label class="expand" for="c-40207537">[2 more]</label></div><br/><div class="children"><div class="content">Since prepared statements are created by the driver, I was assuming this was the case - but I might be completely wrong here.</div><br/><div id="40207663" class="c"><input type="checkbox" id="c-40207663" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#40207412">root</a><span>|</span><a href="#40207537">parent</a><span>|</span><a href="#40207194">next</a><span>|</span><label class="collapse" for="c-40207663">[-]</label><label class="expand" for="c-40207663">[1 more]</label></div><br/><div class="children"><div class="content">Converting a SELECT to a PRPEPARE does not really require parsing the complete query—or even it it did, some small concessions for this could be implemented in the line protocol to enable the server to do the prepared statement out of client query.<p>I don&#x27;t believe *any* SQL client library actually tries to parse e.g. PostgreSQL itself at any point of processing. You can read what the PostgreSQL protocol does here: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;protocol-flow.html#PROTOCOL-FLOW-SIMPLE-QUERY" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;protocol-flow.html#P...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>