<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685696458384" as="style"/><link rel="stylesheet" href="styles.css?v=1685696458384"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://hsivonen.fi/string-length/">It‚Äôs not wrong that &quot;ü§¶üèº‚Äç‚ôÇÔ∏è&quot;.length == 7 (2019)</a>¬†<span class="domain">(<a href="https://hsivonen.fi">hsivonen.fi</a>)</span></div><div class="subtext"><span>triyambakam</span> | <span>149 comments</span></div><br/><div><div id="36159641" class="c"><input type="checkbox" id="c-36159641" checked=""/><div class="controls bullet"><span class="by">grayhatter</span><span>|</span><a href="#36160221">next</a><span>|</span><label class="collapse" for="c-36159641">[-]</label><label class="expand" for="c-36159641">[45 more]</label></div><br/><div class="children"><div class="content">&gt; Python 3‚Äôs approach is unambiguously the worst one, though.<p>Did I miss the part where he explains this take? It&#x27;s made up of 5 valid unicode code units. For a language where you&#x27;re not supposed to need to know the byte size semantics, the correct length should be 5. What am I missing?<p>The close second being 17, because length in bytes. Is another fine way to represent this data, e.g. what a successful write of some sort would look like. Network or file.<p>I guess I&#x27;m basing this all on the idea that it&#x27;s almost always a mistake to confuse how a program manages some data, vs how a drawing lib might. Your language shouldn&#x27;t concern it self with how many glyphs it needs to draw... until you actually try to draw them.</div><br/><div id="36159878" class="c"><input type="checkbox" id="c-36159878" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36159641">parent</a><span>|</span><a href="#36159979">next</a><span>|</span><label class="collapse" for="c-36159878">[-]</label><label class="expand" for="c-36159878">[26 more]</label></div><br/><div class="children"><div class="content">It is wrong that &quot;{emoji}&quot;.length == 7 -- but it&#x27;s wrong because there&#x27;s no such thing as the &#x27;length&#x27; of a string out of context.<p>A string should be viewed as an opaque data type with views into it depending on what you&#x27;re trying to do. You can have its length in the context of storage&#x2F;retrieval&#x2F;transmission (UTF-8 byte count), its length in the context of parsing (code points), its length in the context of editing (grapheme clusters) or length in the context of display (a bounding box in points when used in conjunction with a specific font and paragraph style attributes).<p>Claiming to provide an out-of-context length is strictly wrong because there&#x27;s no such thing. This is where people get confused.<p>The attribute shouldn&#x27;t be &#x27;length&#x27; it should be something like &#x27;countOfCodePoints&#x27; or exposed via a `CodePoints` type view.<p>It&#x27;s particularly bad because so often (esp. for western programmers) &#x27;countOfCodePoints&#x27; == &#x27;countOfBytesInUTF8&#x27; == &#x27;countOfGraphemeClusters&#x27; == &quot;&quot;&quot;length&quot;&quot;&quot; so it&#x27;s hella easy to accidentally write buggy software. Especially for people who don&#x27;t know the above about unicode, which let&#x27;s face it, most people don&#x27;t. Not until they have to explain to their designer why they can&#x27;t limit a label to &#x27;10 characters.&#x27; (&quot;What do you mean there&#x27;s no such thing as a character, and what am I trying to do?&quot;).<p>This is basically the tl;dr of the article but it&#x27;s also my personal opinion.<p>All of this isn&#x27;t about &#x27;wrong&#x27; so much as &#x27;imprecise and overloaded terminology making it easy to write buggy software through poor abstractions.&#x27;<p>If python explained which length you were getting, then this article wouldn&#x27;t exist.</div><br/><div id="36162675" class="c"><input type="checkbox" id="c-36162675" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36162211">next</a><span>|</span><label class="collapse" for="c-36162675">[-]</label><label class="expand" for="c-36162675">[1 more]</label></div><br/><div class="children"><div class="content">There are three notions of length that make sense:<p>1. UTF-8 byte length<p>2. Code point count<p>3. Extended grapheme cluster count<p>#3 makes sense for users but it doesn‚Äôt make sense for <i>programs</i> which often need to work at the code point level.<p>I expect programming language string length to obey the law:<p><pre><code>  len(a ++ b) = len(a) + len(b)
</code></pre>
For example, if I concatenate a two strings, one containing an ‚Äúe‚Äù and one containing a combining acute accent, then I expect the length to be <i>longer</i> than a string containing a precomposed ‚Äò√©‚Äô character. It‚Äôs in fact useful if strings that look the same but have different code points have <i>different</i> lengths, because it tells you that they‚Äôre not the same (and maybe you forgot to normalize something etc).<p>Code point length is the most useful for people who are actually writing string algorithms based upon Unicode.<p>UTF-8 length is useful for people who are treating strings as opaque byte sequences, but in that case they should be using a bytes&#x2F;buffer object and not a string object, except in very low-level languages that don‚Äôt want to pay an encoding&#x2F;decoding cost.<p>Extended grapheme cluster count is useful for people who are constructing certain kinds of user interfaces, where the number of characters is limited for a policy rather than memory or width reason.<p>i.e. when length limits are imposed by human policy, grapheme cluster count is the way to go. Length limits for memory reasons should rather be in UTF-8 bytes. If you need a limit for visual width reasons then you need to go measure the string in pixels, otherwise I‚Äôm going to put a U+FDFD in there and ruin your day.<p>UTF-16 length can GTFO.</div><br/></div></div><div id="36162211" class="c"><input type="checkbox" id="c-36162211" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36162675">prev</a><span>|</span><a href="#36160030">next</a><span>|</span><label class="collapse" for="c-36162211">[-]</label><label class="expand" for="c-36162211">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not until they have to explain to their designer why they can&#x27;t limit a label to &#x27;10 characters.&#x27;<p>Or in a single font. It&#x27;s impossible to render any mixed combination of simplified Chinese, traditional Chinese and Japanese with a single font (Korean might be also involved, but not sure about that). Even in Unicode, characters might share the the same space which don&#x27;t have anything common in their looks, nor in their meaning. That applies to the shared CJK space as well.
Btw. Japanese has halfwidth and fullwidth characters.</div><br/></div></div><div id="36160030" class="c"><input type="checkbox" id="c-36160030" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36162211">prev</a><span>|</span><a href="#36162081">next</a><span>|</span><label class="collapse" for="c-36160030">[-]</label><label class="expand" for="c-36160030">[7 more]</label></div><br/><div class="children"><div class="content">I agree, &quot;length&quot; is an ambiguous function name.  It should probably not exist and instead you have functions with units in the name: .sizeBytes, .widthCharacters, .widthResAdjPixels, and so on.  Back when the world was ASCII you could get away with just .length because the numbers would always be the same, but with Unicode and all of the other complications of the modern world it isn&#x27;t sufficient.</div><br/><div id="36160202" class="c"><input type="checkbox" id="c-36160202" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36160030">parent</a><span>|</span><a href="#36161426">next</a><span>|</span><label class="collapse" for="c-36160202">[-]</label><label class="expand" for="c-36160202">[1 more]</label></div><br/><div class="children"><div class="content">Seeing a .length on something makes me think it‚Äôs an iterable without looking more deeply.<p>In JS, for(i in emoji) will iterate twice, but for(i of emoji) will iterate once.<p>;)</div><br/></div></div><div id="36161426" class="c"><input type="checkbox" id="c-36161426" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36160030">parent</a><span>|</span><a href="#36160202">prev</a><span>|</span><a href="#36162081">next</a><span>|</span><label class="collapse" for="c-36161426">[-]</label><label class="expand" for="c-36161426">[5 more]</label></div><br/><div class="children"><div class="content">length is not ambiguous at all. Its the number of elements in the array. A string in python3 is an array of unicode code points, so the length of a string is the number of unicode code points. If you want the number of bytes, you need to encode the string in a unicode format (utf8, utf16 or utf32) to get a bytes object, which is an array of bytes. Then you can get the length of that.<p>Remember, one of the big accomplishments (breaking changes) of python 3 is that all strings are Unicode, not byte arrays. If you want to view a dtring as bytes, you need to convert the string to bytes. But note the number of bytes depends on the ancoding u use (utf8, ‚Ä¶).</div><br/><div id="36161850" class="c"><input type="checkbox" id="c-36161850" checked=""/><div class="controls bullet"><span class="by">sirsinsalot</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36161426">parent</a><span>|</span><a href="#36162431">next</a><span>|</span><label class="collapse" for="c-36161850">[-]</label><label class="expand" for="c-36161850">[1 more]</label></div><br/><div class="children"><div class="content">Exactly this. People conflate unicode with encoding quite a bit. I think it was plan9 and early Go that used &quot;runes&quot; as a unit, where one or more runes formed a character and an array of runes could be encoded into bytes using a given encoding.<p>The in memory size of a rune was just an implementation detail, and while it could be important for the programmer that the size of a rune was 2 bytes,  this didn&#x27;t mean the length of an array of 2 runes was 4.<p>I always liked the rune unit, and while my memory is hazy I think it was just code points.<p>I think part of the issue is programmers and apis mixing bit units for in memory representation of a conceptual value mapping (unicode), conceptual characters, stored size when encoded and so on ... without firming up those abstractions with interfaces. It gets lossy.</div><br/></div></div><div id="36162431" class="c"><input type="checkbox" id="c-36162431" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36161426">parent</a><span>|</span><a href="#36161850">prev</a><span>|</span><a href="#36162025">next</a><span>|</span><label class="collapse" for="c-36162431">[-]</label><label class="expand" for="c-36162431">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, the number of Unicode codepoints is probably the only measure of a string that is unlikely to ever be relevant to anyone in practice except when it happens to coincide with a different measure.<p>It can&#x27;t be used to determine length in bytes (important for storage or network transmission), it can&#x27;t be used to determine number of displayed characters, it can&#x27;t be used to safely split a string at some position.<p>The only reason it has caught on is that it is easy to encode into UTF-8 and UTF-16, and that anything more interesting generally requires a language context and even a font.<p>I hope that future languages will get rid of this single string abstraction, and instead offer two completely separate types:<p>- symbol strings, which would only be usable for programming purposes and should probably be limited to ASCII<p>- text strings, which would be intended for human display purposes, with full Unicode support, and have APIs which answer things like &quot;in the specified Culture, what is the length of human-recognizable characters of this string&quot; or &quot;what is the seventh human-recognizable characters in this string in the specified culture&quot;<p>There&#x27;s no reason to pay the conceptual cost of Unicode for representing field names or enums (and yes, I don&#x27;t believe supporting Unicode identifiers is a good idea for a programming language; and note that I am not a native English speaker, and while I do use an alphabet, ASCII is missing some of the letters&amp;symbols I use in my native Romanian). And there&#x27;s no reason to settle for the misleading safety of Unicode code points when trying to process human displayable text.</div><br/></div></div><div id="36162025" class="c"><input type="checkbox" id="c-36162025" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36161426">parent</a><span>|</span><a href="#36162431">prev</a><span>|</span><a href="#36162615">next</a><span>|</span><label class="collapse" for="c-36162025">[-]</label><label class="expand" for="c-36162025">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>length is not ambiguous at all. Its the number of elements in the array</i><p>That&#x27;s because you defined it first as &quot;the number of elements in the array&quot;.<p>It is ambiguous however because that&#x27;s not how people understand it when it comes to strings, and there are several counter-intuitive ways they expect it to behave.<p>Not to mention there might not be any &quot;array&quot;. A string (whatever the encoding &#x2F; representation) is a chunk of memory, not an array. That you can often use a method to traverse it doesn&#x27;t mean it&#x27;s in an array.</div><br/></div></div><div id="36162615" class="c"><input type="checkbox" id="c-36162615" checked=""/><div class="controls bullet"><span class="by">amake</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36161426">parent</a><span>|</span><a href="#36162025">prev</a><span>|</span><a href="#36162081">next</a><span>|</span><label class="collapse" for="c-36162615">[-]</label><label class="expand" for="c-36162615">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ambiguous because it&#x27;s not clear what elements go into separate cells of the array.</div><br/></div></div></div></div></div></div><div id="36162081" class="c"><input type="checkbox" id="c-36162081" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36160030">prev</a><span>|</span><a href="#36161780">next</a><span>|</span><label class="collapse" for="c-36162081">[-]</label><label class="expand" for="c-36162081">[7 more]</label></div><br/><div class="children"><div class="content">&gt; for western programmers<p>And by western you mean american, right? You can&#x27;t even use ASCII in the UK --- &#x27;¬£&#x27;.</div><br/><div id="36162234" class="c"><input type="checkbox" id="c-36162234" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162081">parent</a><span>|</span><a href="#36162252">next</a><span>|</span><label class="collapse" for="c-36162234">[-]</label><label class="expand" for="c-36162234">[1 more]</label></div><br/><div class="children"><div class="content">Yes I was using western as synonymous with ASCII users, and it‚Äôs not. My bad.</div><br/></div></div><div id="36162252" class="c"><input type="checkbox" id="c-36162252" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162081">parent</a><span>|</span><a href="#36162234">prev</a><span>|</span><a href="#36161780">next</a><span>|</span><label class="collapse" for="c-36162252">[-]</label><label class="expand" for="c-36162252">[5 more]</label></div><br/><div class="children"><div class="content">¬£ is still just a byte</div><br/><div id="36162322" class="c"><input type="checkbox" id="c-36162322" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162252">parent</a><span>|</span><a href="#36162751">next</a><span>|</span><label class="collapse" for="c-36162322">[-]</label><label class="expand" for="c-36162322">[1 more]</label></div><br/><div class="children"><div class="content">When using latin-1&#x2F;latin-15&#x2F;iso-8859-1&#x2F;iso-8859-15&#x2F;cp1252 that statement is true. With utf-8 it is two bytes (c2 a3), if a software uses utf-16, ucs-2, etc. it may be more.</div><br/></div></div><div id="36162751" class="c"><input type="checkbox" id="c-36162751" checked=""/><div class="controls bullet"><span class="by">tuukkah</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162252">parent</a><span>|</span><a href="#36162322">prev</a><span>|</span><a href="#36162374">next</a><span>|</span><label class="collapse" for="c-36162751">[-]</label><label class="expand" for="c-36162751">[1 more]</label></div><br/><div class="children"><div class="content">Nope, says UTF-8.</div><br/></div></div><div id="36162374" class="c"><input type="checkbox" id="c-36162374" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162252">parent</a><span>|</span><a href="#36162751">prev</a><span>|</span><a href="#36162320">next</a><span>|</span><label class="collapse" for="c-36162374">[-]</label><label class="expand" for="c-36162374">[1 more]</label></div><br/><div class="children"><div class="content">Not in any modern encoding and certainly not in ASCII either. Having the highest order bit set makes that kind of problematic.</div><br/></div></div><div id="36162320" class="c"><input type="checkbox" id="c-36162320" checked=""/><div class="controls bullet"><span class="by">edent</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162252">parent</a><span>|</span><a href="#36162374">prev</a><span>|</span><a href="#36161780">next</a><span>|</span><label class="collapse" for="c-36162320">[-]</label><label class="expand" for="c-36162320">[1 more]</label></div><br/><div class="children"><div class="content">And yet it is reasonably common to see &quot;√Ç¬£&quot; when the UTF-8 is misinterpreted.</div><br/></div></div></div></div></div></div><div id="36161780" class="c"><input type="checkbox" id="c-36161780" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36162081">prev</a><span>|</span><a href="#36160244">next</a><span>|</span><label class="collapse" for="c-36161780">[-]</label><label class="expand" for="c-36161780">[1 more]</label></div><br/><div class="children"><div class="content">I wanted to brainfart about that length in the typical assumed usage should be 1 ignoring the inner encoding of Unicode of emoji ... But your comment was spot on and showed me my own assumption would fall into exactly this view scheme.<p>Thank you. Have my upvote.</div><br/></div></div><div id="36160244" class="c"><input type="checkbox" id="c-36160244" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36161780">prev</a><span>|</span><a href="#36160241">next</a><span>|</span><label class="collapse" for="c-36160244">[-]</label><label class="expand" for="c-36160244">[6 more]</label></div><br/><div class="children"><div class="content">What do you mean there is no such thing as a character when grapheme cluster is exactly that? This is also the out-of-context , and people get confused because instead of this human context attribute they&#x27;ve been forced to use all the other alternatives that require more knowledge</div><br/><div id="36160286" class="c"><input type="checkbox" id="c-36160286" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36160244">parent</a><span>|</span><a href="#36160254">next</a><span>|</span><label class="collapse" for="c-36160286">[-]</label><label class="expand" for="c-36160286">[4 more]</label></div><br/><div class="children"><div class="content">Characters in context are printable or non-printable&#x2F;formatting marks right? I agree they probably meant grapheme clusters, but grapheme clusters can vary dramatically in width so the point of the conversation was to explain why a bounding box was a better approximation of their goals.</div><br/><div id="36160849" class="c"><input type="checkbox" id="c-36160849" checked=""/><div class="controls bullet"><span class="by">cameldrv</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36160286">parent</a><span>|</span><a href="#36161522">next</a><span>|</span><label class="collapse" for="c-36160849">[-]</label><label class="expand" for="c-36160849">[2 more]</label></div><br/><div class="children"><div class="content">They do very in width, but with a proportional font that‚Äôs true even with ASCII text.  What grapheme clusters tells you is how many times you have to press the arrow key&#x2F;backspace to get to the beginning of the string.</div><br/><div id="36162570" class="c"><input type="checkbox" id="c-36162570" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36160849">parent</a><span>|</span><a href="#36161522">next</a><span>|</span><label class="collapse" for="c-36162570">[-]</label><label class="expand" for="c-36162570">[1 more]</label></div><br/><div class="children"><div class="content">Only if the text editor made some bad assumptions. You&#x27;re forgetting about non-printable characters, such as the LTR mark. These are not part of grapheme clusters (or are their own grapheme cluster), but the cursor shouldn&#x27;t probably stop at them.</div><br/></div></div></div></div><div id="36161522" class="c"><input type="checkbox" id="c-36161522" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36160286">parent</a><span>|</span><a href="#36160849">prev</a><span>|</span><a href="#36160254">next</a><span>|</span><label class="collapse" for="c-36161522">[-]</label><label class="expand" for="c-36161522">[1 more]</label></div><br/><div class="children"><div class="content">&gt; grapheme clusters can vary dramatically<p>so do &#x27;www&#x27; and &#x27;iii&#x27; (though less dramatically), that&#x27;t not a foreign concept to designers, not sure they&#x27;d want to bound &#x27;www&#x27; to the width of &#x27;iii&#x27;</div><br/></div></div></div></div></div></div><div id="36160241" class="c"><input type="checkbox" id="c-36160241" checked=""/><div class="controls bullet"><span class="by">prng2021</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36160244">prev</a><span>|</span><a href="#36160337">next</a><span>|</span><label class="collapse" for="c-36160241">[-]</label><label class="expand" for="c-36160241">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A string should be viewed as an opaque data type with views into it depending on what you&#x27;re trying to do.<p>&gt; The attribute shouldn&#x27;t be &#x27;length&#x27; it should be something like &#x27;countOfCodePoints&#x27; or exposed via a `CodePoints` type view.<p>That‚Äôs a great way to explain it and something I‚Äôll keep with me. Thanks</div><br/></div></div><div id="36160337" class="c"><input type="checkbox" id="c-36160337" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159878">parent</a><span>|</span><a href="#36160241">prev</a><span>|</span><a href="#36159979">next</a><span>|</span><label class="collapse" for="c-36160337">[-]</label><label class="expand" for="c-36160337">[1 more]</label></div><br/><div class="children"><div class="content">Counting graphene clusters is a hard problem because it depends on the font that is being used. It only exists at render time in the context of a specific client.<p>If the user can freely change a font it is impossible to send a string of 3 graphene clusters because you won&#x27;t know if it actually will show up as 3 to client or a different number.</div><br/></div></div></div></div><div id="36159979" class="c"><input type="checkbox" id="c-36159979" checked=""/><div class="controls bullet"><span class="by">BeefWellington</span><span>|</span><a href="#36159641">parent</a><span>|</span><a href="#36159878">prev</a><span>|</span><a href="#36162490">next</a><span>|</span><label class="collapse" for="c-36159979">[-]</label><label class="expand" for="c-36159979">[4 more]</label></div><br/><div class="children"><div class="content">5 makes perfect sense to me; the author&#x27;s complaints seem kinda silly.<p>An area this makes sense is, what do you expect to get if you do something like:<p><pre><code>    emoji = &quot; &quot;
    print(emoji[:3])
</code></pre>
Should this throw an error because there&#x27;s only one displayed &quot;character&quot;? Should it return only a partial codepoint by returning only the byte data for the first 3 bytes?<p>Modern strings are complex objects that have evolved a bit past char[] or byte[].</div><br/><div id="36161915" class="c"><input type="checkbox" id="c-36161915" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159979">parent</a><span>|</span><a href="#36162064">next</a><span>|</span><label class="collapse" for="c-36161915">[-]</label><label class="expand" for="c-36161915">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Should this throw an error because there&#x27;s only one displayed &quot;character&quot;?<p>Why should it not? You‚Äôre literally breaking the content.<p>Though in reality, indexing strings is a broken operation. That you‚Äôre using it at all is the core issue.<p>&gt; Modern strings are complex objects that have evolved a bit past char[] or byte[].<p>And yet that‚Äôs exactly what you‚Äôre advocating, just with 21 bit chars.</div><br/></div></div><div id="36162064" class="c"><input type="checkbox" id="c-36162064" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159979">parent</a><span>|</span><a href="#36161915">prev</a><span>|</span><a href="#36162183">next</a><span>|</span><label class="collapse" for="c-36162064">[-]</label><label class="expand" for="c-36162064">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Should this throw an error because there&#x27;s only one displayed &quot;character&quot;?</i><p>Absolutely.</div><br/></div></div><div id="36162183" class="c"><input type="checkbox" id="c-36162183" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159979">parent</a><span>|</span><a href="#36162064">prev</a><span>|</span><a href="#36162490">next</a><span>|</span><label class="collapse" for="c-36162183">[-]</label><label class="expand" for="c-36162183">[1 more]</label></div><br/><div class="children"><div class="content">Well, an index into a string is not necessarily another string, nor a character.</div><br/></div></div></div></div><div id="36162490" class="c"><input type="checkbox" id="c-36162490" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36159641">parent</a><span>|</span><a href="#36159979">prev</a><span>|</span><a href="#36160270">next</a><span>|</span><label class="collapse" for="c-36162490">[-]</label><label class="expand" for="c-36162490">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>For a language where you&#x27;re not supposed to need to know the byte size semantics, the correct length should be 5. What am I missing?</i><p>In the words of the article: ‚ÄúThe choice of UTF-32 (or Python 3-style code point sequences) arises from wanting the wrong thing.‚Äù<p>‚ÄúNot needing to know the byte size semantics‚Äù seems reasonable, but it simply isn‚Äôt a <i>useful</i> goal. The things it makes easier or faster (knowing how many code points there are, and O(1) indexing by code point) are things you shouldn‚Äôt be doing‚Äîand when you have to interact with the rest of the world, you now have a more expensive encoding step that is <i>always</i> needed, rather than just sometimes if you‚Äôd chosen UTF-8 or even UTF-16.</div><br/></div></div><div id="36160270" class="c"><input type="checkbox" id="c-36160270" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#36159641">parent</a><span>|</span><a href="#36162490">prev</a><span>|</span><a href="#36159714">next</a><span>|</span><label class="collapse" for="c-36160270">[-]</label><label class="expand" for="c-36160270">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m basing this all on the idea that it&#x27;s almost always a mistake to confuse how a program manages some data, vs how a drawing lib might. Your language shouldn&#x27;t concern it self with how many glyphs it needs to draw... until you actually try to draw them.<p>Well, why not? There are a lot of things that people would want to call string.length for ‚Äî drawing little equals signs under text in a terminal, for a frivolous example ‚Äî where that‚Äôs the whole reason they‚Äôre making the call. Off the top of my head I‚Äôm not really sure how you solve that with variable-width characters if there‚Äôs no way to separate out or count them.</div><br/><div id="36162067" class="c"><input type="checkbox" id="c-36162067" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36160270">parent</a><span>|</span><a href="#36159714">next</a><span>|</span><label class="collapse" for="c-36162067">[-]</label><label class="expand" for="c-36162067">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Well, why not?</i><p>Separation of concerns?</div><br/></div></div></div></div><div id="36159714" class="c"><input type="checkbox" id="c-36159714" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36159641">parent</a><span>|</span><a href="#36160270">prev</a><span>|</span><a href="#36160221">next</a><span>|</span><label class="collapse" for="c-36159714">[-]</label><label class="expand" for="c-36159714">[11 more]</label></div><br/><div class="children"><div class="content">I think he meant to bring out defensiveness with that quip. He never says that it&#x27;s a big deal, just that it&#x27;s the worst way to get the length of a string containing emoji, presumably of the mainstream languages.</div><br/><div id="36159850" class="c"><input type="checkbox" id="c-36159850" checked=""/><div class="controls bullet"><span class="by">tehsauce</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159714">parent</a><span>|</span><a href="#36160221">next</a><span>|</span><label class="collapse" for="c-36159850">[-]</label><label class="expand" for="c-36159850">[10 more]</label></div><br/><div class="children"><div class="content">Why is it the worst way though?</div><br/><div id="36161769" class="c"><input type="checkbox" id="c-36161769" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159850">parent</a><span>|</span><a href="#36159928">next</a><span>|</span><label class="collapse" for="c-36161769">[-]</label><label class="expand" for="c-36161769">[5 more]</label></div><br/><div class="children"><div class="content">Because it‚Äôs never actually useful.<p>You can‚Äôt use that information to know how much actual space it takes (in storage) as nobody sane stores UTF-32, you can‚Äôt use it to know much much <i>logical</i> space it takes (aka the user‚Äôs interpretation), you can‚Äôt use it to know how much visual space it takes (not that you can ever get that), and you can‚Äôt use it to segment or process the text.<p>A length in codepoints gives you nothing that‚Äôs really actionable, at least not that you‚Äôd need outside of a context where you could easily obtain it otherwise.</div><br/><div id="36162339" class="c"><input type="checkbox" id="c-36162339" checked=""/><div class="controls bullet"><span class="by">L3viathan</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36161769">parent</a><span>|</span><a href="#36159928">next</a><span>|</span><label class="collapse" for="c-36162339">[-]</label><label class="expand" for="c-36162339">[4 more]</label></div><br/><div class="children"><div class="content">It is useful: When iterating over a string in Python (which I hope you agree _is_ useful?), you get that many parts.</div><br/><div id="36162377" class="c"><input type="checkbox" id="c-36162377" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162339">parent</a><span>|</span><a href="#36162423">next</a><span>|</span><label class="collapse" for="c-36162377">[-]</label><label class="expand" for="c-36162377">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is useful: When iterating over a string in Python (which I hope you agree _is_ useful?), you get that many parts.<p>That‚Äôs‚Ä¶ not useful?<p>I can‚Äôt say I remember ever caring knowing how many items I would be getting during an iteration[0]. If I want to set an iteration limit I can just‚Ä¶ do that, using `islice` or some such.<p>[0] in python anyway, in lower level language there can be a utility in order to pre-allocate an output collection</div><br/></div></div><div id="36162423" class="c"><input type="checkbox" id="c-36162423" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36162339">parent</a><span>|</span><a href="#36162377">prev</a><span>|</span><a href="#36162402">next</a><span>|</span><label class="collapse" for="c-36162423">[-]</label><label class="expand" for="c-36162423">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>When iterating over a string in Python (which I hope you agree _is_ useful?)</i><p>Not often. There‚Äôs almost nothing useful you can correctly do with a sequence of code points.</div><br/></div></div></div></div></div></div><div id="36159928" class="c"><input type="checkbox" id="c-36159928" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159850">parent</a><span>|</span><a href="#36161769">prev</a><span>|</span><a href="#36159861">next</a><span>|</span><label class="collapse" for="c-36159928">[-]</label><label class="expand" for="c-36159928">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Note about Python 3 added on 2019-09-09: Originally this article claimed that Python 3 guaranteed UTF-32 validity. This was in error. Python 3 guarantees that the units of the string stay within the Unicode code point range but does not guarantee the absence of surrogates. It not only allows unpaired surrogates, which might be explained by wishing to be compatible with the value space of potentially-invalid UTF-16, but Python 3 allows materializing even surrogate pairs, which is a truly bizarre design. The previous conclusions stand with the added conclusion that Python 3 is even more messed up than I thought!</div><br/></div></div><div id="36159973" class="c"><input type="checkbox" id="c-36159973" checked=""/><div class="controls bullet"><span class="by">markmark</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159850">parent</a><span>|</span><a href="#36159861">prev</a><span>|</span><a href="#36160221">next</a><span>|</span><label class="collapse" for="c-36159973">[-]</label><label class="expand" for="c-36159973">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps the part about it needing lookups of the unicode database and being dependent on the version of the database used?</div><br/><div id="36160032" class="c"><input type="checkbox" id="c-36160032" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36159641">root</a><span>|</span><a href="#36159973">parent</a><span>|</span><a href="#36160221">next</a><span>|</span><label class="collapse" for="c-36160032">[-]</label><label class="expand" for="c-36160032">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not true though. It just counts the number of code units, that&#x27;s not version dependent. It&#x27;s certainly no worse than counting the number of UTF-16 points (I&#x27;d argue it&#x27;s better since it&#x27;s less arbitrary - whether something is a unicode scalar is a design decision, whether something is in the BMP or not is mostly an accident of implementation).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36160221" class="c"><input type="checkbox" id="c-36160221" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#36159641">prev</a><span>|</span><a href="#36159984">next</a><span>|</span><label class="collapse" for="c-36160221">[-]</label><label class="expand" for="c-36160221">[3 more]</label></div><br/><div class="children"><div class="content">Ruby gives you the choice to iterate over all types, via `each_byte`, `each_char`, `each_codepoint`, or `each_grapheme_cluster`.<p><a href="https:&#x2F;&#x2F;ruby-doc.org&#x2F;3.2.2&#x2F;String.html#class-String-label-Methods+for+Iterating" rel="nofollow">https:&#x2F;&#x2F;ruby-doc.org&#x2F;3.2.2&#x2F;String.html#class-String-label-Me...</a></div><br/><div id="36161417" class="c"><input type="checkbox" id="c-36161417" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#36160221">parent</a><span>|</span><a href="#36162119">next</a><span>|</span><label class="collapse" for="c-36161417">[-]</label><label class="expand" for="c-36161417">[1 more]</label></div><br/><div class="children"><div class="content">Elixir also makes this distinction:<p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.12&#x2F;String.html#module-code-points-and-grapheme-cluster" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;1.12&#x2F;String.html#module-code-point...</a></div><br/></div></div><div id="36162119" class="c"><input type="checkbox" id="c-36162119" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36160221">parent</a><span>|</span><a href="#36161417">prev</a><span>|</span><a href="#36159984">next</a><span>|</span><label class="collapse" for="c-36162119">[-]</label><label class="expand" for="c-36162119">[1 more]</label></div><br/><div class="children"><div class="content">Python would benefit from this significantly IMO.</div><br/></div></div></div></div><div id="36159984" class="c"><input type="checkbox" id="c-36159984" checked=""/><div class="controls bullet"><span class="by">xeeeeeeeeeeenu</span><span>|</span><a href="#36160221">prev</a><span>|</span><a href="#36162017">next</a><span>|</span><label class="collapse" for="c-36159984">[-]</label><label class="expand" for="c-36159984">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a fan of &quot;everything you know about X is wrong&quot; articles. Very often they try to present some little tidbit of knowledge as a revelation and mislead the reader in the process.<p>In this case, the tidbit is: &quot;grapheme clusters exist and they are useful&quot;.<p>The misleading part is that the article draws a false equivalence between what the author calls &quot;UTF-32 code units&quot; and UTF-16 code units.<p>UTF-32 code units are Unicode code points. This is a general Unicode concept that exists in all Unicode encodings. UTF-16 code units, on the other hand, are an implementation detail of UTF-16. It is wrong to present them as equally arbitrary concepts.</div><br/><div id="36162194" class="c"><input type="checkbox" id="c-36162194" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36159984">parent</a><span>|</span><a href="#36161792">next</a><span>|</span><label class="collapse" for="c-36162194">[-]</label><label class="expand" for="c-36162194">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>UTF-16 code units, on the other hand, are an implementation detail of UTF-16.</i><p>Would that it were only so. Instead, UTF-16 ruined Unicode for everyone with the abomination that is <i>surrogates</i>, and almost nothing that deals with UTF-16 actually asserts well-formedness, and ill-formed UTF-16 cannot be represented in UTF-8 or UTF-32.<p>UTF-32 and UTF-8 code units are truly implementation details of their encodings, as other encodings don‚Äôt need to know about them in any way. UTF-32‚Äôs code units are a trivial mapping between scalar values and 32-bit values (<i>not</i> four-byte values, given the big- and little-endian variants), but that still causes UTF-32 code units to be <i>semantically distinct</i> from Unicode scalar values. U+12345 is a Unicode scalar value and doesn‚Äôt have any ‚Äúsize‚Äù: it‚Äôs an abstract value. 0x00012345 is a UTF-32 code unit, a 32-bit value.<p>If you‚Äôre talking about encoding of Unicode scalar values, you talk about code units. Even when talking about UTF-32, the code unit&#x2F;scalar value semantic distinction is worth maintaining.</div><br/><div id="36162626" class="c"><input type="checkbox" id="c-36162626" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#36159984">root</a><span>|</span><a href="#36162194">parent</a><span>|</span><a href="#36161792">next</a><span>|</span><label class="collapse" for="c-36162626">[-]</label><label class="expand" for="c-36162626">[1 more]</label></div><br/><div class="children"><div class="content">WTF-8 is bridging the gap here. I don&#x27;t know of a UTF-32 equivalent, maybe it&#x27;s impossible.</div><br/></div></div></div></div><div id="36161792" class="c"><input type="checkbox" id="c-36161792" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36159984">parent</a><span>|</span><a href="#36162194">prev</a><span>|</span><a href="#36162017">next</a><span>|</span><label class="collapse" for="c-36161792">[-]</label><label class="expand" for="c-36161792">[1 more]</label></div><br/><div class="children"><div class="content">&gt; UTF-32 code units are Unicode code points.<p>They‚Äôre not. UTF-32 code units have a 1:1 mapping to <i>USVs</i>, surrogates are not valid.<p>&gt; It is wrong to present them as equally arbitrary concepts.<p>Is it? It‚Äôs not like they‚Äôre any more useful. Arguably less so, UTF-16 is at least a somewhat common storage medium.</div><br/></div></div></div></div><div id="36162017" class="c"><input type="checkbox" id="c-36162017" checked=""/><div class="controls bullet"><span class="by">frou_dh</span><span>|</span><a href="#36159984">prev</a><span>|</span><a href="#36162096">next</a><span>|</span><label class="collapse" for="c-36162017">[-]</label><label class="expand" for="c-36162017">[2 more]</label></div><br/><div class="children"><div class="content">I encountered some real world unicode&#x2F;emoji breakdown recently. I set my surname in a webapp to an emoji country flag because I needed a way to communicate where I was. Elsewhere in the app, it showed surnames as just their  initial, e.g. &quot;John S&quot;. There, mine showed as a featureless black flag rather than the flag I set. Presumably because that is the first codepoint of several that make up the flag.</div><br/><div id="36162424" class="c"><input type="checkbox" id="c-36162424" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36162017">parent</a><span>|</span><a href="#36162096">next</a><span>|</span><label class="collapse" for="c-36162424">[-]</label><label class="expand" for="c-36162424">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There, mine showed as a featureless black flag rather than the flag I set. Presumably because that is the first codepoint of several that make up the flag.<p>The country flags are each made of two Unicode code points, which Unicode calls Regional Indicator Symbols. There are twenty six, one for each of the Latin capital letters A through Z. These are used to encode a flag by writing the ISO two letter country code from ISO-3166-1 e.g. F + R is France, you get a French flag.<p>Given your black flag experience, and the fact this is an English language forum, I&#x27;d guess maybe you wanted a flag for some entity that isn&#x27;t a UN member state or some sort of recognised similar entity (e.g. the European flag EU symbolising the continent of Europe) and thus doesn&#x27;t have an ISO two letter code, such as California or Wales. <i>Those</i> are built from a waving black flag plus their long ISO-3166-2 region code</div><br/></div></div></div></div><div id="36162096" class="c"><input type="checkbox" id="c-36162096" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#36162017">prev</a><span>|</span><a href="#36159921">next</a><span>|</span><label class="collapse" for="c-36162096">[-]</label><label class="expand" for="c-36162096">[3 more]</label></div><br/><div class="children"><div class="content">I have read somewhere that you should learn 2 or 3 programming languages from the get go. If you learn one, you run the risk of letting it&#x27;s shape dictate how you mentally model computation. At some point someone who learned a dynamically typed programming language first is bound to find out why data types matter.</div><br/><div id="36162125" class="c"><input type="checkbox" id="c-36162125" checked=""/><div class="controls bullet"><span class="by">Firmwarrior</span><span>|</span><a href="#36162096">parent</a><span>|</span><a href="#36159921">next</a><span>|</span><label class="collapse" for="c-36162125">[-]</label><label class="expand" for="c-36162125">[2 more]</label></div><br/><div class="children"><div class="content">I started with JavaScript and went to c&#x2F;logic gates&#x2F;assembly, and it wasn&#x27;t too bad<p>I had to learn what pointers were, but it was OK, haha.<p>That said, maybe people who don&#x27;t have &quot;The Knack&quot; would be better off learning a slightly harder language first..</div><br/><div id="36162516" class="c"><input type="checkbox" id="c-36162516" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#36162096">root</a><span>|</span><a href="#36162125">parent</a><span>|</span><a href="#36159921">next</a><span>|</span><label class="collapse" for="c-36162516">[-]</label><label class="expand" for="c-36162516">[1 more]</label></div><br/><div class="children"><div class="content">I definitely don&#x27;t have talent for logic and quantitative thinking. It takes a long time and many iterations for even simple concepts in mathematics to sink in for me. I benefited greatly from learning first Scheme and also making sense of C and OS internals before trying to grok interpreted languages. I&#x27;m currently trying to get some proficiency in Go and it&#x27;s been great fun!</div><br/></div></div></div></div></div></div><div id="36159921" class="c"><input type="checkbox" id="c-36159921" checked=""/><div class="controls bullet"><span class="by">dahfizz</span><span>|</span><a href="#36162096">prev</a><span>|</span><a href="#36162256">next</a><span>|</span><label class="collapse" for="c-36159921">[-]</label><label class="expand" for="c-36159921">[14 more]</label></div><br/><div class="children"><div class="content">Maybe not wrong, but it&#x27;s the worst option.<p>5 is the number of code points, and 17 is the number of bytes. Both are reasonable answers.<p>7 is the number of code units for utf-16. Seems like the least useful option.</div><br/><div id="36160146" class="c"><input type="checkbox" id="c-36160146" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#36159921">parent</a><span>|</span><a href="#36159954">next</a><span>|</span><label class="collapse" for="c-36160146">[-]</label><label class="expand" for="c-36160146">[2 more]</label></div><br/><div class="children"><div class="content">It makes just as much sense as 17 (for utf8) in a JavaScript context, where charCodeAt(i) returns a utf-16 code point, and strings at least behave as though the implementation uses an array of uint16_t for the storage. Utf 16 is definitely not my favorite representation, but given that context (which the language imposes) 7 is an important number to be able to know.</div><br/><div id="36162571" class="c"><input type="checkbox" id="c-36162571" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36160146">parent</a><span>|</span><a href="#36159954">next</a><span>|</span><label class="collapse" for="c-36162571">[-]</label><label class="expand" for="c-36162571">[1 more]</label></div><br/><div class="children"><div class="content">Correction: ‚Äúutf-16 code point‚Äù should read ‚ÄúUTF-16 code <i>unit</i>‚Äù.</div><br/></div></div></div></div><div id="36159954" class="c"><input type="checkbox" id="c-36159954" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36159921">parent</a><span>|</span><a href="#36160146">prev</a><span>|</span><a href="#36161888">next</a><span>|</span><label class="collapse" for="c-36159954">[-]</label><label class="expand" for="c-36159954">[10 more]</label></div><br/><div class="children"><div class="content">That means 7 is also a measure of bytes, just slightly more awkward.  So it&#x27;s roughly on par with 17.<p>For 5, the idea is that while you might want to iterate code points, the total number of code points is less useful than either grapheme count or byte count.  I think that argument makes sense.</div><br/><div id="36162084" class="c"><input type="checkbox" id="c-36162084" checked=""/><div class="controls bullet"><span class="by">temac</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36159954">parent</a><span>|</span><a href="#36160058">next</a><span>|</span><label class="collapse" for="c-36162084">[-]</label><label class="expand" for="c-36162084">[1 more]</label></div><br/><div class="children"><div class="content">I think that argument makes as much sense as saying that an engine is less useful than a car. And pretending that engine.weight should return the weight of the car.</div><br/></div></div><div id="36160058" class="c"><input type="checkbox" id="c-36160058" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36159954">parent</a><span>|</span><a href="#36162084">prev</a><span>|</span><a href="#36162196">next</a><span>|</span><label class="collapse" for="c-36160058">[-]</label><label class="expand" for="c-36160058">[7 more]</label></div><br/><div class="children"><div class="content">&gt; That means 7 is also a measure of bytes, just slightly more awkward.<p>It&#x27;s not a real measure of bytes though. It&#x27;s the count of bytes in an encoding scheme that is (probably) neither what you use to communicate with the outside world nor what your language runtime uses. (And certainly it&#x27;s no better than 5, since that&#x27;s also a measure of bytes in a particular encoding).</div><br/><div id="36160360" class="c"><input type="checkbox" id="c-36160360" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36160058">parent</a><span>|</span><a href="#36160171">next</a><span>|</span><label class="collapse" for="c-36160360">[-]</label><label class="expand" for="c-36160360">[5 more]</label></div><br/><div class="children"><div class="content">Lots of systems use UTF-16 internally and externally.  Counting bytes in UTF-16 is, on average, almost as useful as counting bytes in UTF-8.<p>I don&#x27;t think just about anything communicates in UTF-32.  5 is basically just a codepoint count, and as such I don&#x27;t think its usefulness rating should be between the byte counts.</div><br/><div id="36161685" class="c"><input type="checkbox" id="c-36161685" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36160360">parent</a><span>|</span><a href="#36160171">next</a><span>|</span><label class="collapse" for="c-36161685">[-]</label><label class="expand" for="c-36161685">[4 more]</label></div><br/><div class="children"><div class="content">Only Windows and Java come to mind - and BOTH of those are insane for sticking to it when the entire rest of the world has moved on.</div><br/><div id="36161847" class="c"><input type="checkbox" id="c-36161847" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36161685">parent</a><span>|</span><a href="#36160171">next</a><span>|</span><label class="collapse" for="c-36161847">[-]</label><label class="expand" for="c-36161847">[3 more]</label></div><br/><div class="children"><div class="content">Windows, Java, C#, javascript, a surprising number of XML documents (though less so as time marches on thankfully), ICU I think uses UTF-16 internally (for the same historical reasons as the other 4), JOLIET file names are UCS2, some phones interpret ‚Äú16-bit‚Äù SMS as UTF-16 (the spec says UCS2).<p>&gt; and BOTH of those are insane for sticking to it<p>They don‚Äôt really have much of a choice because they exposed those semantics as part of the string interface (or for Windows the interaction is slow low level it can‚Äôt be hidden), they have performance guarantees and behaviours which matches that.<p>It‚Äôs also why Python uses UTF-32, and went through the entire PEP-393 &#x2F; FS complication to try and stop blowing up memory left and right: the core team considered that switching strings to UTF8 was a bridge too far.<p>There are approximate solutions, but they come with their own costs and complications (e.g. pypy uses UTF8 strings with lazily constructed indices to emulate UTF-32 strings).</div><br/><div id="36162047" class="c"><input type="checkbox" id="c-36162047" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36161847">parent</a><span>|</span><a href="#36160171">next</a><span>|</span><label class="collapse" for="c-36162047">[-]</label><label class="expand" for="c-36162047">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a Windows based programmer, but couldn&#x27;t they leave the old API&#x27;s in place, but make UTF-8 safe versions available for everyone and switch to that... E.G. with Win 11?</div><br/><div id="36162229" class="c"><input type="checkbox" id="c-36162229" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36162047">parent</a><span>|</span><a href="#36160171">next</a><span>|</span><label class="collapse" for="c-36162229">[-]</label><label class="expand" for="c-36162229">[1 more]</label></div><br/><div class="children"><div class="content">You can set the system codepage to CP_UTF8 since Win 10, I guess, although IIRC it still doesn&#x27;t work for input. But a) there is a <i>lot</i> of programs using A() functions that don&#x27;t expect that and break in subtle ways, e.g. DBCS-encoding-aware programs suddenly break because they don&#x27;t expect a codepoint to span for more than 2 bytes; b) most of the sanely written programs either use UTF-16 explicitly, or use UTF-8 internally and convert between UTF-8 and UTF-16 before&#x2F;after calling W() functions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36160171" class="c"><input type="checkbox" id="c-36160171" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36160058">parent</a><span>|</span><a href="#36160360">prev</a><span>|</span><a href="#36162196">next</a><span>|</span><label class="collapse" for="c-36160171">[-]</label><label class="expand" for="c-36160171">[1 more]</label></div><br/><div class="children"><div class="content">The JavaScript language forces utf16 (whether or not v8 uses that representation under the hood). For instance if you want to substring the indexes you pass are for utf16 codepoints</div><br/></div></div></div></div><div id="36162196" class="c"><input type="checkbox" id="c-36162196" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36159921">root</a><span>|</span><a href="#36159954">parent</a><span>|</span><a href="#36160058">prev</a><span>|</span><a href="#36161888">next</a><span>|</span><label class="collapse" for="c-36162196">[-]</label><label class="expand" for="c-36162196">[1 more]</label></div><br/><div class="children"><div class="content">7 cannot be a measure of bytes because a UTF-16 point takes 2 bytes, so the number has to be even. Did you mean 14?</div><br/></div></div></div></div></div></div><div id="36162256" class="c"><input type="checkbox" id="c-36162256" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#36159921">prev</a><span>|</span><a href="#36159791">next</a><span>|</span><label class="collapse" for="c-36162256">[-]</label><label class="expand" for="c-36162256">[1 more]</label></div><br/><div class="children"><div class="content">Really the correct way to design string APIs would be to not have an ambiguous &quot;length&quot; at all, but to always require specifying whether you want UTF8-bytes, memory bytes, code points, graphemes, whatever.<p>However such an API would be pretty cumbersome because for all non-edge cases (read: a western language and a reasonable encoding that language - which when looking at world demographics is a very narrow way of saying non-edge case) we just want to ignore all that fancy stuff and assume it&#x27;s latin-1&#x2F;ascii and use &quot;Length&quot; and get on with it, usually accepting that it doesn&#x27;t work for many scripts or emoji.<p>So almost every api I have encountered has both the dangerous or ambiguous &quot;length&quot; and any number of the more specific counts. Good? No. But good enough, I guess.<p>A much worse related API that exists every where is that for parsing and formatting numbers to and from text. How that&#x27;s done &quot;depends&quot; but most languages I have seen - unfortunately - offers a &quot;default way&quot;. In the worst examples - looking at you .NET - this default uses the system env and assumes formatting and parsing numbers should us the OS locale. Horrible horrible idea when used in conjunction with automatic type conversions.  WriteLine($&quot;The size is {3.5}&quot;); shouldn&#x27;t print &quot;3.5&quot; in the US and &quot;3,5&quot; somewhere else.</div><br/></div></div><div id="36159791" class="c"><input type="checkbox" id="c-36159791" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#36162256">prev</a><span>|</span><a href="#36162559">next</a><span>|</span><label class="collapse" for="c-36159791">[-]</label><label class="expand" for="c-36159791">[14 more]</label></div><br/><div class="children"><div class="content">Python 3&#x27;s approach is the most correct: Unicode defines text as a sequence of code points. UTF-whatever is an implementation detail.</div><br/><div id="36162336" class="c"><input type="checkbox" id="c-36162336" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36159791">parent</a><span>|</span><a href="#36160012">next</a><span>|</span><label class="collapse" for="c-36162336">[-]</label><label class="expand" for="c-36162336">[1 more]</label></div><br/><div class="children"><div class="content">Python 3‚Äôs approach snatched defeat from the jaws of victory.<p>They aimed to work with a nice, clean, abstract concept, untrammelled by encoding squabbles. They failed badly by choosing code units rather than scalar values (Unicode strings are sequences of <i>scalar values</i>, not code points‚Äî&#x27;\udead&#x27; is a valid Python string, but you can‚Äôt encode it into any UTF-* format since [U+DEAD] is not a valid Unicode string).<p>Then they also neglected to observe that they were optimising for something that you should practically never be doing, so that now <i>everyone</i> has to pay the costs. As the article summarises it part-way through: ‚ÄúThe choice of UTF-32 (or Python 3-style code point sequences) arises from wanting the wrong thing.‚Äù<p>Seriously, Python 3‚Äôs approach is almost the worst of all available worlds. I loathe UTF-16 with such fiery passion that I can‚Äôt <i>quite</i> bring myself to say Python 3‚Äôs approach is worse than weak UTF-16, but it‚Äôs of similar badness in practical terms. The decisions were very clearly made by people that were not expert in the domain and who were caught up in a Concept of Mathematical Purity. They‚Äôve since walked some of it back as far as they could, and I think did recognise it all as a mistake (no citation, just a vague memory of seeing such an admission), but they can‚Äôt fix it all properly without a breaking change.</div><br/></div></div><div id="36160012" class="c"><input type="checkbox" id="c-36160012" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36159791">parent</a><span>|</span><a href="#36162336">prev</a><span>|</span><a href="#36159835">next</a><span>|</span><label class="collapse" for="c-36160012">[-]</label><label class="expand" for="c-36160012">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Unicode defines text as a sequence of code points.<p>Does it? Do you have a link?<p>[edit] I looked up the spec and here is what it says.<p>&gt; The Unicode Standard does not define what is and is not a text element in different processes; instead, it defines elements called encoded characters. An encoded character is represented by a number from 0 to 10FFFF_16, called a code point. A text element, in turn, is represented by a sequence of one or more encoded characters. [1]<p>The definition of &#x27;text&#x27; in the context of Unicode seems to explicitly not be defined as a sequence of code points, but rather a more nebulous sequence of aggregations of code points. It&#x27;s probably <i>closest</i> to a grapheme cluster but they seem to want to avoid pinning it down.<p>[1] <a href="https:&#x2F;&#x2F;www.unicode.org&#x2F;versions&#x2F;Unicode15.0.0&#x2F;UnicodeStandard-15.0.pdf" rel="nofollow">https:&#x2F;&#x2F;www.unicode.org&#x2F;versions&#x2F;Unicode15.0.0&#x2F;UnicodeStanda...</a> p. 7 (1.3 - Text Handling), PDF page 33.</div><br/><div id="36160094" class="c"><input type="checkbox" id="c-36160094" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36160012">parent</a><span>|</span><a href="#36159835">next</a><span>|</span><label class="collapse" for="c-36160094">[-]</label><label class="expand" for="c-36160094">[6 more]</label></div><br/><div class="children"><div class="content">Review chapter 2.2 Unicode Design Principles in the Unicode Standard: &quot;Plain text is a pure sequence of character codes; plain Unicode-encoded text is therefore a sequence of Unicode character codes.&quot;<p>Text elements are an abstract concept whose definition depends upon what is being processed. It might be a grapheme, it might be word, etc...</div><br/><div id="36160104" class="c"><input type="checkbox" id="c-36160104" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36160094">parent</a><span>|</span><a href="#36159835">next</a><span>|</span><label class="collapse" for="c-36160104">[-]</label><label class="expand" for="c-36160104">[5 more]</label></div><br/><div class="children"><div class="content">There might be something a little imprecise here: code points vs code units vs character codes.<p>I&#x27;m open to being wrong but I would be very surprised if they defined text as a &quot;series of code units&quot; the count of which can vary by encoding even for the same character. IMO in this context &#x27;character codes&#x27; would likely be far more consistent with &#x27;code points&#x27; and they&#x27;re just trying to differentiate between styled and un-styled text. Whereas the 1.3 definition appears to be trying to make an authoritative definition of &#x27;text.&#x27;<p>If we read 2.2&#x27;s &quot;character codes&quot; as code points, then that can be multiple code points as referenced in 1.3<p>[edit] I originally flipped &#x27;units&#x27; and &#x27;codes&#x27; - cleaned it up.</div><br/><div id="36160150" class="c"><input type="checkbox" id="c-36160150" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36160104">parent</a><span>|</span><a href="#36159835">next</a><span>|</span><label class="collapse" for="c-36160150">[-]</label><label class="expand" for="c-36160150">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Character code&quot; is short for &quot;character code point&quot; or just code point. All Unicode algorithms and properties are defined in terms of the code point. UTF encodings are just a way of encoding a code point. From Unicode&#x27;s perspective, you care about <i>what</i> is encoded (i.e. the code point) and not <i>how</i> it is encoded (i.e. UTF-8).<p>Unicode is one of the most poorly understood topics. I think the confusion stems from 1. most programming languages getting the abstraction wrong, and 2. programmers trying to reconcile their non-technical interpretation of what &quot;character&quot; means.</div><br/><div id="36160179" class="c"><input type="checkbox" id="c-36160179" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36160150">parent</a><span>|</span><a href="#36159835">next</a><span>|</span><label class="collapse" for="c-36160179">[-]</label><label class="expand" for="c-36160179">[3 more]</label></div><br/><div class="children"><div class="content">I agree with everything you said, I think I&#x27;m just trying to reconcile that with the top of thread saying python was the most correct because it was returning &#x27;7 code points&#x27; and that &#x27;UTF-whatever is an implementation detail&#x27;<p>But 7 is not the number of code points&#x2F;USVs - that&#x27;s the number of UTF-16 code units. The string is 5 USVs. If UTF-whatever is an implementation detail, wouldn&#x27;t the correct answer to length be 5?<p>What am I missing haha.</div><br/><div id="36160230" class="c"><input type="checkbox" id="c-36160230" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36160179">parent</a><span>|</span><a href="#36159835">next</a><span>|</span><label class="collapse" for="c-36160230">[-]</label><label class="expand" for="c-36160230">[2 more]</label></div><br/><div class="children"><div class="content">Python does return 5. JavaScript returns 7. Python is returning the number of code points, JavaScript is returning the number of UTF-16 code units.</div><br/><div id="36160237" class="c"><input type="checkbox" id="c-36160237" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36160230">parent</a><span>|</span><a href="#36159835">next</a><span>|</span><label class="collapse" for="c-36160237">[-]</label><label class="expand" for="c-36160237">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s my mistake. Thank you. Flipped them in my head, it&#x27;s ben a long day.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36159835" class="c"><input type="checkbox" id="c-36159835" checked=""/><div class="controls bullet"><span class="by">pjscott</span><span>|</span><a href="#36159791">parent</a><span>|</span><a href="#36160012">prev</a><span>|</span><a href="#36159832">next</a><span>|</span><label class="collapse" for="c-36159835">[-]</label><label class="expand" for="c-36159835">[4 more]</label></div><br/><div class="children"><div class="content">Treating Unicode strings as a sequence of code points is a completely valid thing to do, but is usually not what you actually care about when dealing with text. Really, are code points any less of an implementation detail?</div><br/><div id="36162678" class="c"><input type="checkbox" id="c-36162678" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36159835">parent</a><span>|</span><a href="#36161288">next</a><span>|</span><label class="collapse" for="c-36162678">[-]</label><label class="expand" for="c-36162678">[1 more]</label></div><br/><div class="children"><div class="content">Code points are what you care about when you do any kind of text-based format encoding or decoding. Any of JSON, XML, HTML, YAML or whatever is defined by sequence of code points. There is no reason to complicate these with visual representation-specific concepts.<p>If you have to care about the visual representation of text then you probably need to be familiar with other concepts as well.</div><br/></div></div><div id="36161288" class="c"><input type="checkbox" id="c-36161288" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36159835">parent</a><span>|</span><a href="#36162678">prev</a><span>|</span><a href="#36160062">next</a><span>|</span><label class="collapse" for="c-36161288">[-]</label><label class="expand" for="c-36161288">[1 more]</label></div><br/><div class="children"><div class="content">Yes.<p>They are less of an implementation detail.<p>Grapheme &gt; Code point &gt; Encoding &gt; Endianness &gt; Media<p>It&#x27;s all &quot;implementations&quot; but some are lower then others</div><br/></div></div><div id="36160062" class="c"><input type="checkbox" id="c-36160062" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#36159791">root</a><span>|</span><a href="#36159835">parent</a><span>|</span><a href="#36161288">prev</a><span>|</span><a href="#36159832">next</a><span>|</span><label class="collapse" for="c-36160062">[-]</label><label class="expand" for="c-36160062">[1 more]</label></div><br/><div class="children"><div class="content">I think parent means most correct of the three given examples from Rust, JS and Python.<p>Especially because the article says that Python&#x27;s take is the worst.</div><br/></div></div></div></div><div id="36159832" class="c"><input type="checkbox" id="c-36159832" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#36159791">parent</a><span>|</span><a href="#36159835">prev</a><span>|</span><a href="#36162559">next</a><span>|</span><label class="collapse" for="c-36159832">[-]</label><label class="expand" for="c-36159832">[1 more]</label></div><br/><div class="children"><div class="content">Unicode defines text as a number of different types of things. They are sequences of codepoints, sequences of graphemes, sequences of graphime clusters. Furthermore, codepoints are different depending on how you normalize them. Accented characters can be written two different ways and have a different number of codepoints depending on how you write them (and if normalization is used)</div><br/></div></div></div></div><div id="36162559" class="c"><input type="checkbox" id="c-36162559" checked=""/><div class="controls bullet"><span class="by">kolibril13</span><span>|</span><a href="#36159791">prev</a><span>|</span><a href="#36161714">next</a><span>|</span><label class="collapse" for="c-36162559">[-]</label><label class="expand" for="c-36162559">[1 more]</label></div><br/><div class="children"><div class="content">In python, `print(&quot;-&quot;.join(f&quot;{ord(c):x}&quot; for c in emoji))` will give `&#x27;1f926-1f3fc-200d-2642-fe0f&#x27;`.
That can be useful to request emojis, see
<a href="https:&#x2F;&#x2F;github.com&#x2F;hfg-gmuend&#x2F;openmoji&#x2F;blob&#x2F;ad588c8fb4b028d71c5743347ef5dc6968b97579&#x2F;FAQ.md?plain=1#L141-L157">https:&#x2F;&#x2F;github.com&#x2F;hfg-gmuend&#x2F;openmoji&#x2F;blob&#x2F;ad588c8fb4b028d7...</a></div><br/></div></div><div id="36161714" class="c"><input type="checkbox" id="c-36161714" checked=""/><div class="controls bullet"><span class="by">farhanhubble</span><span>|</span><a href="#36162559">prev</a><span>|</span><a href="#36159624">next</a><span>|</span><label class="collapse" for="c-36161714">[-]</label><label class="expand" for="c-36161714">[1 more]</label></div><br/><div class="children"><div class="content">Why should length in programming be devoid of units? Why can&#x27;t we have length be (8, UTF32_CODEPOINTS) &lt;class UTF32_CODEPOINT_SZ(8)&gt;?</div><br/></div></div><div id="36159624" class="c"><input type="checkbox" id="c-36159624" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#36161714">prev</a><span>|</span><a href="#36160702">next</a><span>|</span><label class="collapse" for="c-36159624">[-]</label><label class="expand" for="c-36159624">[3 more]</label></div><br/><div class="children"><div class="content">Measuring the length of text is really hard. Font fallback is hard. All of these things, you take for granted till you write your own game engine.<p>Apparently the thing to use is a library with a very strange name, which does glyph placement. I‚Äôll go look for it.<p>EDIT: harfbuzz <a href="https:&#x2F;&#x2F;harfbuzz.github.io&#x2F;why-do-i-need-a-shaping-engine.html" rel="nofollow">https:&#x2F;&#x2F;harfbuzz.github.io&#x2F;why-do-i-need-a-shaping-engine.ht...</a></div><br/><div id="36159715" class="c"><input type="checkbox" id="c-36159715" checked=""/><div class="controls bullet"><span class="by">missblit</span><span>|</span><a href="#36159624">parent</a><span>|</span><a href="#36159723">next</a><span>|</span><label class="collapse" for="c-36159715">[-]</label><label class="expand" for="c-36159715">[1 more]</label></div><br/><div class="children"><div class="content">Measuring the length of text is easy. Now measuring the length of text before actually printing it &#x2F; running the shaping engine, now that&#x27;s hard.</div><br/></div></div></div></div><div id="36160702" class="c"><input type="checkbox" id="c-36160702" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#36159624">prev</a><span>|</span><a href="#36160183">next</a><span>|</span><label class="collapse" for="c-36160702">[-]</label><label class="expand" for="c-36160702">[3 more]</label></div><br/><div class="children"><div class="content">Unsurprising that (at least some implementation of) Swift does the least wrong thing in returning 1. I think it&#x27;s also one of the few languages that will return a count of 1 for the madness that is country flag emojis <a href="https:&#x2F;&#x2F;docs.swift.org&#x2F;swift-book&#x2F;documentation&#x2F;the-swift-programming-language&#x2F;stringsandcharacters#Extended-Grapheme-Clusters" rel="nofollow">https:&#x2F;&#x2F;docs.swift.org&#x2F;swift-book&#x2F;documentation&#x2F;the-swift-pr...</a></div><br/><div id="36161839" class="c"><input type="checkbox" id="c-36161839" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#36160702">parent</a><span>|</span><a href="#36161512">next</a><span>|</span><label class="collapse" for="c-36161839">[-]</label><label class="expand" for="c-36161839">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;least wrong length method&#x27; for strings is not providing one in the first place.</div><br/></div></div><div id="36161512" class="c"><input type="checkbox" id="c-36161512" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#36160702">parent</a><span>|</span><a href="#36161839">prev</a><span>|</span><a href="#36160183">next</a><span>|</span><label class="collapse" for="c-36161512">[-]</label><label class="expand" for="c-36161512">[1 more]</label></div><br/><div class="children"><div class="content">‚ÄúLeast wrong‚Äù sounds very silly. Its like programmers are discovering theres a difference between bytes, unicode code points and grapheme clusters and are unsure about how their favorite programming language represents strings, and then decide there should be some behavior that doesnt follow from the documentation.<p>The ‚Äúlength of an emoji‚Äù depends on the data type used to represent it. Its that simple and that correct.</div><br/></div></div></div></div><div id="36160183" class="c"><input type="checkbox" id="c-36160183" checked=""/><div class="controls bullet"><span class="by">secret-noun</span><span>|</span><a href="#36160702">prev</a><span>|</span><a href="#36159688">next</a><span>|</span><label class="collapse" for="c-36160183">[-]</label><label class="expand" for="c-36160183">[2 more]</label></div><br/><div class="children"><div class="content">Related: I wrote a little web app that lets you see the codepoints for text like this<p><a href="https:&#x2F;&#x2F;unicode-x-ray.com&#x2F;?t=%F0%9F%A4%A6%F0%9F%8F%BC%E2%80%8D%E2%99%82%EF%B8%8F" rel="nofollow">https:&#x2F;&#x2F;unicode-x-ray.com&#x2F;?t=%F0%9F%A4%A6%F0%9F%8F%BC%E2%80%...</a> (sorry if link looks scary, that&#x27;s just the URL encoding of this emoji)</div><br/><div id="36162224" class="c"><input type="checkbox" id="c-36162224" checked=""/><div class="controls bullet"><span class="by">farhanhubble</span><span>|</span><a href="#36160183">parent</a><span>|</span><a href="#36159688">next</a><span>|</span><label class="collapse" for="c-36162224">[-]</label><label class="expand" for="c-36162224">[1 more]</label></div><br/><div class="children"><div class="content">I worked on Unicode parsers for several years and the single most indispensable tool was <a href="https:&#x2F;&#x2F;r12a.github.io&#x2F;app-conversion&#x2F;" rel="nofollow">https:&#x2F;&#x2F;r12a.github.io&#x2F;app-conversion&#x2F;</a></div><br/></div></div></div></div><div id="36159688" class="c"><input type="checkbox" id="c-36159688" checked=""/><div class="controls bullet"><span class="by">paddw</span><span>|</span><a href="#36160183">prev</a><span>|</span><a href="#36160121">next</a><span>|</span><label class="collapse" for="c-36159688">[-]</label><label class="expand" for="c-36159688">[4 more]</label></div><br/><div class="children"><div class="content">I think this is a really a naming convention issue. Len() is ambiguous, you really want either num_chars() or utfxx_len(). Of course, the issue of what counts as a character is confusing in its own right...</div><br/><div id="36159873" class="c"><input type="checkbox" id="c-36159873" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#36159688">parent</a><span>|</span><a href="#36160121">next</a><span>|</span><label class="collapse" for="c-36159873">[-]</label><label class="expand" for="c-36159873">[3 more]</label></div><br/><div class="children"><div class="content">In Python len() on a bytes type gives you the number of bytes, and len() on a str type gives you the number of codepoints. I think that makes sense, as strings are only intended to deal with text, and you should never have to worry about byte indexing at all.</div><br/><div id="36160060" class="c"><input type="checkbox" id="c-36160060" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36159688">root</a><span>|</span><a href="#36159873">parent</a><span>|</span><a href="#36160121">next</a><span>|</span><label class="collapse" for="c-36160060">[-]</label><label class="expand" for="c-36160060">[2 more]</label></div><br/><div class="children"><div class="content">The argument is that indexing by codepoint is even less useful than indexing by byte.</div><br/><div id="36161598" class="c"><input type="checkbox" id="c-36161598" checked=""/><div class="controls bullet"><span class="by">chasontherobot</span><span>|</span><a href="#36159688">root</a><span>|</span><a href="#36160060">parent</a><span>|</span><a href="#36160121">next</a><span>|</span><label class="collapse" for="c-36161598">[-]</label><label class="expand" for="c-36161598">[1 more]</label></div><br/><div class="children"><div class="content">As someone who has done both, I&#x27;d say that argument is wrong. It is <i>much</i> more convenient to index by code point. Indexing by bytes is almost always what you don&#x27;t want to do, and leads to a lot of errors.</div><br/></div></div></div></div></div></div></div></div><div id="36160121" class="c"><input type="checkbox" id="c-36160121" checked=""/><div class="controls bullet"><span class="by">jlebar</span><span>|</span><a href="#36159688">prev</a><span>|</span><a href="#36160351">next</a><span>|</span><label class="collapse" for="c-36160121">[-]</label><label class="expand" for="c-36160121">[2 more]</label></div><br/><div class="children"><div class="content">I was 100% prepared to believe that the length of empty string in js is 7.<p>Then upon opening the post I was 100% ready to believe that js has three different string length functions that all handle Unicode differently.</div><br/><div id="36161843" class="c"><input type="checkbox" id="c-36161843" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#36160121">parent</a><span>|</span><a href="#36160351">next</a><span>|</span><label class="collapse" for="c-36161843">[-]</label><label class="expand" for="c-36161843">[1 more]</label></div><br/><div class="children"><div class="content">and the gist of the problem is that it doesn&#x27;t.</div><br/></div></div></div></div><div id="36160351" class="c"><input type="checkbox" id="c-36160351" checked=""/><div class="controls bullet"><span class="by">ceeam</span><span>|</span><a href="#36160121">prev</a><span>|</span><a href="#36159862">next</a><span>|</span><label class="collapse" for="c-36160351">[-]</label><label class="expand" for="c-36160351">[3 more]</label></div><br/><div class="children"><div class="content">These emoticons should never have been a part of Unicode in the first place. Second big mistake of that org after the Unihan fiasco.</div><br/><div id="36162291" class="c"><input type="checkbox" id="c-36162291" checked=""/><div class="controls bullet"><span class="by">dchest</span><span>|</span><a href="#36160351">parent</a><span>|</span><a href="#36160667">next</a><span>|</span><label class="collapse" for="c-36162291">[-]</label><label class="expand" for="c-36162291">[1 more]</label></div><br/><div class="children"><div class="content">If not for emoji, lots of software wouldn&#x27;t care about correctly processing strings in other languages, so it&#x27;s good that we have them.</div><br/></div></div><div id="36160667" class="c"><input type="checkbox" id="c-36160667" checked=""/><div class="controls bullet"><span class="by">themerone</span><span>|</span><a href="#36160351">parent</a><span>|</span><a href="#36162291">prev</a><span>|</span><a href="#36159862">next</a><span>|</span><label class="collapse" for="c-36160667">[-]</label><label class="expand" for="c-36160667">[1 more]</label></div><br/><div class="children"><div class="content">Emoji&#x27;s are a fun way to illustrate a problem that happens with languages too.</div><br/></div></div></div></div><div id="36160212" class="c"><input type="checkbox" id="c-36160212" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36160356">prev</a><span>|</span><a href="#36160321">next</a><span>|</span><label class="collapse" for="c-36160212">[-]</label><label class="expand" for="c-36160212">[1 more]</label></div><br/><div class="children"><div class="content">Very good and informative article, though still not convincing that the nudge to make the shortest &quot;len&quot; command use the human readable size of grapheme clusters like in Swift isn&#x27;t the best design approach, all the non-intuitive sizes should be special</div><br/></div></div><div id="36160321" class="c"><input type="checkbox" id="c-36160321" checked=""/><div class="controls bullet"><span class="by">justinator</span><span>|</span><a href="#36160212">prev</a><span>|</span><a href="#36160268">next</a><span>|</span><label class="collapse" for="c-36160321">[-]</label><label class="expand" for="c-36160321">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    perl -e &#x27;use utf8; print length(&quot;&quot;). &quot;\n&quot;;&#x27;
    1</code></pre></div><br/><div id="36160332" class="c"><input type="checkbox" id="c-36160332" checked=""/><div class="controls bullet"><span class="by">justinator</span><span>|</span><a href="#36160321">parent</a><span>|</span><a href="#36160268">next</a><span>|</span><label class="collapse" for="c-36160332">[-]</label><label class="expand" for="c-36160332">[1 more]</label></div><br/><div class="children"><div class="content">Should be the emoji char between the double q&#x27;s in, &#x27;length(&quot;&quot;)&#x27; but whatcha gonna do.</div><br/></div></div></div></div><div id="36160268" class="c"><input type="checkbox" id="c-36160268" checked=""/><div class="controls bullet"><span class="by">chefandy</span><span>|</span><a href="#36160321">prev</a><span>|</span><a href="#36160427">next</a><span>|</span><label class="collapse" for="c-36160268">[-]</label><label class="expand" for="c-36160268">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s 1 in elixir which measures graphemes by default.<p><pre><code>  iex(3)&gt; String.length(&quot; &quot;)
  1
</code></pre>
Edit: looks like HN doesn&#x27;t support that emoji in code blocks, at least.</div><br/><div id="36161674" class="c"><input type="checkbox" id="c-36161674" checked=""/><div class="controls bullet"><span class="by">jnsaff2</span><span>|</span><a href="#36160268">parent</a><span>|</span><a href="#36160427">next</a><span>|</span><label class="collapse" for="c-36161674">[-]</label><label class="expand" for="c-36161674">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s also 5 if you like:<p>&gt; length(&#x27; &#x27;)<p>Which is: [129318, 127996, 8205, 9794, 65039]</div><br/></div></div></div></div><div id="36160427" class="c"><input type="checkbox" id="c-36160427" checked=""/><div class="controls bullet"><span class="by">neallindsay</span><span>|</span><a href="#36160268">prev</a><span>|</span><a href="#36160996">next</a><span>|</span><label class="collapse" for="c-36160427">[-]</label><label class="expand" for="c-36160427">[3 more]</label></div><br/><div class="children"><div class="content">Until reading this I had never heard of UTF-32. It doesn&#x27;t seem like a good way to encode strings.</div><br/><div id="36162146" class="c"><input type="checkbox" id="c-36162146" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36160427">parent</a><span>|</span><a href="#36160996">next</a><span>|</span><label class="collapse" for="c-36162146">[-]</label><label class="expand" for="c-36162146">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s useful if you want array-like semantics (e.g. O(1) lookup) on Unicode text strings, because you have a fixed size for every codepoint, unliked UTF-8. Python for example uses it internally.</div><br/><div id="36162281" class="c"><input type="checkbox" id="c-36162281" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#36160427">root</a><span>|</span><a href="#36162146">parent</a><span>|</span><a href="#36160996">next</a><span>|</span><label class="collapse" for="c-36162281">[-]</label><label class="expand" for="c-36162281">[1 more]</label></div><br/><div class="children"><div class="content">And it compresses just as well as UTF-8 for transfer&#x2F;storage purposes.</div><br/></div></div></div></div></div></div><div id="36160996" class="c"><input type="checkbox" id="c-36160996" checked=""/><div class="controls bullet"><span class="by">quaintdev</span><span>|</span><a href="#36160427">prev</a><span>|</span><a href="#36160978">next</a><span>|</span><label class="collapse" for="c-36160996">[-]</label><label class="expand" for="c-36160996">[3 more]</label></div><br/><div class="children"><div class="content">How the hell you inserted an emoji in title? Afaik we cant use emoji on this website</div><br/><div id="36161483" class="c"><input type="checkbox" id="c-36161483" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36160996">parent</a><span>|</span><a href="#36161677">prev</a><span>|</span><a href="#36160978">next</a><span>|</span><label class="collapse" for="c-36161483">[-]</label><label class="expand" for="c-36161483">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36160029" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36160029</a></div><br/></div></div></div></div><div id="36159703" class="c"><input type="checkbox" id="c-36159703" checked=""/><div class="controls bullet"><span class="by">geoffpado</span><span>|</span><a href="#36160978">prev</a><span>|</span><a href="#36160001">next</a><span>|</span><label class="collapse" for="c-36159703">[-]</label><label class="expand" for="c-36159703">[2 more]</label></div><br/><div class="children"><div class="content">(2019), for what it&#x27;s worth.</div><br/><div id="36159748" class="c"><input type="checkbox" id="c-36159748" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#36159703">parent</a><span>|</span><a href="#36160001">next</a><span>|</span><label class="collapse" for="c-36159748">[-]</label><label class="expand" for="c-36159748">[1 more]</label></div><br/><div class="children"><div class="content">In 2023 we should be able to see that Python&#x27;s isn&#x27;t the worst, or rather is tied for the worst, and that they&#x27;re all a little bit tricky but fine.</div><br/></div></div></div></div><div id="36160001" class="c"><input type="checkbox" id="c-36160001" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#36159703">prev</a><span>|</span><a href="#36160557">next</a><span>|</span><label class="collapse" for="c-36160001">[-]</label><label class="expand" for="c-36160001">[4 more]</label></div><br/><div class="children"><div class="content">Is there a situation where I am going to try to get the length of an emoji and I care about the outcome?</div><br/><div id="36160339" class="c"><input type="checkbox" id="c-36160339" checked=""/><div class="controls bullet"><span class="by">justinator</span><span>|</span><a href="#36160001">parent</a><span>|</span><a href="#36160409">next</a><span>|</span><label class="collapse" for="c-36160339">[-]</label><label class="expand" for="c-36160339">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s most definitely a situation where you want the length of string that contains an emoji character and perhaps dumb things happen if you get that wrong.</div><br/></div></div><div id="36160409" class="c"><input type="checkbox" id="c-36160409" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#36160001">parent</a><span>|</span><a href="#36160339">prev</a><span>|</span><a href="#36160557">next</a><span>|</span><label class="collapse" for="c-36160409">[-]</label><label class="expand" for="c-36160409">[2 more]</label></div><br/><div class="children"><div class="content">Enforcing a character limit on user input.</div><br/><div id="36160601" class="c"><input type="checkbox" id="c-36160601" checked=""/><div class="controls bullet"><span class="by">hermitdev</span><span>|</span><a href="#36160001">root</a><span>|</span><a href="#36160409">parent</a><span>|</span><a href="#36160557">next</a><span>|</span><label class="collapse" for="c-36160601">[-]</label><label class="expand" for="c-36160601">[1 more]</label></div><br/><div class="children"><div class="content">Now I want to know: how much does this emoji count towards password strength?</div><br/></div></div></div></div></div></div><div id="36160557" class="c"><input type="checkbox" id="c-36160557" checked=""/><div class="controls bullet"><span class="by">foxes</span><span>|</span><a href="#36160001">prev</a><span>|</span><a href="#36159888">next</a><span>|</span><label class="collapse" for="c-36160557">[-]</label><label class="expand" for="c-36160557">[3 more]</label></div><br/><div class="children"><div class="content">All these abominations are because of non strict typing<p>String = List ( Char )<p>Chars don‚Äôt have a length, like a number doesn‚Äôt have a length - unless you talk about number of bits. If you are working with strings stick with strings. The string of a single character should be ‚Äú1‚Äù. Just enforce proper typing.  Anything else is not consistent.</div><br/><div id="36161844" class="c"><input type="checkbox" id="c-36161844" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#36160557">parent</a><span>|</span><a href="#36161622">next</a><span>|</span><label class="collapse" for="c-36161844">[-]</label><label class="expand" for="c-36161844">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s caused by cost. For example Java has a char type. It&#x27;s a 16 bit numeric value because Java uses UTF-16 internally for encoding strings. Java Strings are basically immutable char arrays with some fluff around them. If you ask for the String length, it returns the length of the underlying array. Nice and simple and unsurprising. And relatively cheap. Most more recent languages use 8 bit bytes and UTF-8 instead because that is emerged as the most common character encoding. But UTF-16 was a reasonable choice a quarter century ago and the practical difference doesn&#x27;t matter that much and changing it would be disruptive.<p>If you put unicode characters consisting of multiple data points into a String, it necessarily increases the amount of chars. There&#x27;s no way around that. Because there is no such thing as a UnicodeChar type in Java. You can&#x27;t actually assign multi data point unicode characters to a char.<p>Essentially all the workarounds for a &#x27;correct&#x27; unicode character count in a String would either end up using a different and probably way more expensive data structure (e.g. a list of a list of chars or bytes where each list is a unicode character) or implementing some expensive logic for counting characters that is O(n) instead O(1). Most languages ranging from extremely strictly typed to weakly typed don&#x27;t do that for cost reasons. The tradeoff is simply not worth the price it takes.<p>This stackoverflow post provides a few suggestions for how you could count &#x27;correctly&#x27;.
<a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;15947992&#x2F;java-unicode-string-length" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;15947992&#x2F;java-unicode-st...</a> that illustrates the point nicely.</div><br/></div></div><div id="36161622" class="c"><input type="checkbox" id="c-36161622" checked=""/><div class="controls bullet"><span class="by">chasontherobot</span><span>|</span><a href="#36160557">parent</a><span>|</span><a href="#36161844">prev</a><span>|</span><a href="#36159888">next</a><span>|</span><label class="collapse" for="c-36161622">[-]</label><label class="expand" for="c-36161622">[1 more]</label></div><br/><div class="children"><div class="content">Python has strong typing which seems to be what you mean here rather than strict typing.<p>A &quot;character&quot; is not a well defined term in Unicode, rather the &quot;base&quot; that does not vary across implementations is code points, which is what Python measures when you get the length of a string.</div><br/></div></div></div></div><div id="36159888" class="c"><input type="checkbox" id="c-36159888" checked=""/><div class="controls bullet"><span class="by">2h</span><span>|</span><a href="#36160557">prev</a><span>|</span><a href="#36159971">next</a><span>|</span><label class="collapse" for="c-36159888">[-]</label><label class="expand" for="c-36159888">[12 more]</label></div><br/><div class="children"><div class="content">this one one of those things that people point to when comparing languages, but in reality rarely matters. with Go, you just get the number of bytes, which the the correct default thing to do:<p><a href="https:&#x2F;&#x2F;godocs.io&#x2F;builtin#len" rel="nofollow">https:&#x2F;&#x2F;godocs.io&#x2F;builtin#len</a><p>if the language default was anything other than this, THAT WOULD BE WRONG and unexpected. I would prefer the default to be the dumb, fast thing. then if I want the slow, fancy thing, I can import some first or third party package.</div><br/><div id="36160051" class="c"><input type="checkbox" id="c-36160051" checked=""/><div class="controls bullet"><span class="by">ladberg</span><span>|</span><a href="#36159888">parent</a><span>|</span><a href="#36160537">next</a><span>|</span><label class="collapse" for="c-36160051">[-]</label><label class="expand" for="c-36160051">[1 more]</label></div><br/><div class="children"><div class="content">I think to some extent it depends on the language. In the article they talk about Swift&#x27;s implementation, which by default does the slow, fancy thing (but makes it easy to do the dumb, fast thing). String manipulation in Swift is almost certainly  going to be used for a GUI for end users of many possible languages &#x2F; locales, so it makes sense to spend the extra cycles to get the fancy version by default. If it isn&#x27;t the default then you&#x27;ll end up with half the apps on the App Store displaying broken text on line breaks, ellipses, wrapping, etc. on their hand-rolled UI stack.</div><br/></div></div><div id="36160537" class="c"><input type="checkbox" id="c-36160537" checked=""/><div class="controls bullet"><span class="by">chromoblob</span><span>|</span><a href="#36159888">parent</a><span>|</span><a href="#36160051">prev</a><span>|</span><a href="#36161075">next</a><span>|</span><label class="collapse" for="c-36160537">[-]</label><label class="expand" for="c-36160537">[1 more]</label></div><br/><div class="children"><div class="content">This is only if you want strings to be sequences of bytes. If you want strings to be sequences of code points, it is more sensible to define string length as the length of the sequence. I prefer the latter (for coded text) because it is closer to the meaning of the string. Sequence of code points is always sequence of code points, but a sequence of bytes may not correctly encode a sequence of code points, and bytes in encoding are not in one-to-one correspondence with code points in string. So I see no reason to care about individual bytes per se in the string&#x27;s code.</div><br/></div></div><div id="36161075" class="c"><input type="checkbox" id="c-36161075" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#36159888">parent</a><span>|</span><a href="#36160537">prev</a><span>|</span><a href="#36160306">next</a><span>|</span><label class="collapse" for="c-36161075">[-]</label><label class="expand" for="c-36161075">[5 more]</label></div><br/><div class="children"><div class="content">Nah, that&#x27;s just dumb. Rust&#x27;s way of all strings being utf-8 and providing the different lengths depending on your needs is far superior.<p>If you want something else than utf-8 you can use another data type, like a vector of bytes.</div><br/><div id="36161372" class="c"><input type="checkbox" id="c-36161372" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#36159888">root</a><span>|</span><a href="#36161075">parent</a><span>|</span><a href="#36160306">next</a><span>|</span><label class="collapse" for="c-36161372">[-]</label><label class="expand" for="c-36161372">[4 more]</label></div><br/><div class="children"><div class="content">According to the article, Rust does the same thing - &quot;&lt;emoji&gt;&quot;.len() == 17.</div><br/><div id="36161791" class="c"><input type="checkbox" id="c-36161791" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36159888">root</a><span>|</span><a href="#36161372">parent</a><span>|</span><a href="#36160306">next</a><span>|</span><label class="collapse" for="c-36161791">[-]</label><label class="expand" for="c-36161791">[3 more]</label></div><br/><div class="children"><div class="content">&quot;&lt;emoji&gt;&quot;.chars().count() == 5<p>Rust gives you the freedom to specify what you mean.</div><br/><div id="36162637" class="c"><input type="checkbox" id="c-36162637" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36159888">root</a><span>|</span><a href="#36161791">parent</a><span>|</span><a href="#36160306">next</a><span>|</span><label class="collapse" for="c-36162637">[-]</label><label class="expand" for="c-36162637">[2 more]</label></div><br/><div class="children"><div class="content">Sure, however that&#x27;s actually decoding the string into Unicode scalar values, and then counting them whereas the length of the string is a direct property of the string reference (it&#x27;s a fat pointer [address + length])<p>I don&#x27;t remember, but I <i>think</i> the size hint is set on the Chars iterator, so it can see it has 17 bytes of data, it knows that can&#x27;t encode more than 17 Unicode scalar values, nor can it encode fewer than five. But since we ask for an exact count that hint is unused, the actual decoding will take place.</div><br/><div id="36162730" class="c"><input type="checkbox" id="c-36162730" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36159888">root</a><span>|</span><a href="#36162637">parent</a><span>|</span><a href="#36160306">next</a><span>|</span><label class="collapse" for="c-36162730">[-]</label><label class="expand" for="c-36162730">[1 more]</label></div><br/><div class="children"><div class="content">Yes, your point? That is the same thing which happens in Swift if you request the length of a string and it gives you the number of glyphs (1, in this case).<p>Rust doesn&#x27;t take sides here. It exposes all the different ways you might want to calculate the &quot;length&quot; of a string, and lets you pick which one you mean. The non-zero-cost choices involve a multi-step specification (like `.chars().count()`), which states explicitly the calculation involved.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36160306" class="c"><input type="checkbox" id="c-36160306" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36159888">parent</a><span>|</span><a href="#36161075">prev</a><span>|</span><a href="#36159971">next</a><span>|</span><label class="collapse" for="c-36160306">[-]</label><label class="expand" for="c-36160306">[4 more]</label></div><br/><div class="children"><div class="content">Why would you want dumb???<p>(and it&#x27;s not expected that a character&#x27;s length is&gt;1 unless you&#x27;ve been conditioned to excpect it)</div><br/><div id="36161391" class="c"><input type="checkbox" id="c-36161391" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#36159888">root</a><span>|</span><a href="#36160306">parent</a><span>|</span><a href="#36159971">next</a><span>|</span><label class="collapse" for="c-36161391">[-]</label><label class="expand" for="c-36161391">[3 more]</label></div><br/><div class="children"><div class="content">Because whenever you want to store or transmit a string only the byte count matters (the size of the string). All the fancy unicode stuff on top of bytes is for the display layers to handle. The default should be grounded to the reality of the programmer.</div><br/><div id="36162847" class="c"><input type="checkbox" id="c-36162847" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#36159888">root</a><span>|</span><a href="#36161391">parent</a><span>|</span><a href="#36161624">next</a><span>|</span><label class="collapse" for="c-36162847">[-]</label><label class="expand" for="c-36162847">[1 more]</label></div><br/><div class="children"><div class="content">Storing and transmitting is always going to work with low-level storage units like bytes, so your string will need to be converted to that first. But string manipulation is extremely common in programming, and I would think graphemes are the most useful unit here - i.e. as a programmer my preference would be for swift&#x27;s behaviour.</div><br/></div></div><div id="36161624" class="c"><input type="checkbox" id="c-36161624" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#36159888">root</a><span>|</span><a href="#36161391">parent</a><span>|</span><a href="#36162847">prev</a><span>|</span><a href="#36159971">next</a><span>|</span><label class="collapse" for="c-36161624">[-]</label><label class="expand" for="c-36161624">[1 more]</label></div><br/><div class="children"><div class="content">Human interaction is a more grounded reality for programmers vs. the dumb land of pure bytes, so even at that conceptual level the default should be smart<p>And bytes is the only thing that matter for a specific type of string, conveniently named, sequence of bytes</div><br/></div></div></div></div></div></div></div></div><div id="36159971" class="c"><input type="checkbox" id="c-36159971" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#36159888">prev</a><span>|</span><a href="#36159826">next</a><span>|</span><label class="collapse" for="c-36159971">[-]</label><label class="expand" for="c-36159971">[2 more]</label></div><br/><div class="children"><div class="content">Once again, <i>strings are not simple sequences of characters</i>. It&#x27;s also useless to &quot;index&quot; into a string without specifying what you&#x27;re indexing for the same reason.</div><br/><div id="36160043" class="c"><input type="checkbox" id="c-36160043" checked=""/><div class="controls bullet"><span class="by">astrea</span><span>|</span><a href="#36159971">parent</a><span>|</span><a href="#36159826">next</a><span>|</span><label class="collapse" for="c-36160043">[-]</label><label class="expand" for="c-36160043">[1 more]</label></div><br/><div class="children"><div class="content">This is like when you first dive into date-time and slowly unravel the maddening complexity of it all.</div><br/></div></div></div></div><div id="36159826" class="c"><input type="checkbox" id="c-36159826" checked=""/><div class="controls bullet"><span class="by">ars</span><span>|</span><a href="#36159971">prev</a><span>|</span><label class="collapse" for="c-36159826">[-]</label><label class="expand" for="c-36159826">[6 more]</label></div><br/><div class="children"><div class="content">Am I wrong for assuming the .length should return a length in bytes? If you want to use 32bit units, then multiply your output by 4.<p>If you want to do Unicode string manipulation and length counting, then use specific functions for that - but the base internal .length function should just output bytes.</div><br/><div id="36162058" class="c"><input type="checkbox" id="c-36162058" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36159826">parent</a><span>|</span><a href="#36161504">next</a><span>|</span><label class="collapse" for="c-36162058">[-]</label><label class="expand" for="c-36162058">[2 more]</label></div><br/><div class="children"><div class="content">The most obvious use case for length is iterating over the string and indexing it. In JS (or Go, Rust, Python) indexing and iteration is not byte based. As has been said elsewhere, length depends on the context&#x2F;way you use it.</div><br/><div id="36162706" class="c"><input type="checkbox" id="c-36162706" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36159826">root</a><span>|</span><a href="#36162058">parent</a><span>|</span><a href="#36161504">next</a><span>|</span><label class="collapse" for="c-36162706">[-]</label><label class="expand" for="c-36162706">[1 more]</label></div><br/><div class="children"><div class="content">In Rust you need to specify what it is you think you&#x27;re going to &quot;iterate over&quot; in a string.<p>You can&#x27;t just &quot;iterate over a string&quot; because that&#x27;s not a thing. You can get an iterator over the <i>bytes</i> in the string, with &quot;foo&quot;.bytes() or you can get an iterator over the Unicode scalar values in the string with &quot;foo&quot;.chars(), or you can iterate over a UTF-16 encoding of the string with &quot;foo&quot;.encode_utf16()<p>You can index into Rust&#x27;s strings, but you need to specify slice indexes, you can&#x27;t just treat this like it&#x27;s a array because that&#x27;s not what it is. If you wanted a slice of bytes you can have one cheaply, it&#x27;s as_bytes() which is a [u8] and you can index directly into that slice as with any array of bytes, but you can&#x27;t mutate that and those aren&#x27;t characters, they&#x27;re just bytes.</div><br/></div></div></div></div><div id="36161504" class="c"><input type="checkbox" id="c-36161504" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36159826">parent</a><span>|</span><a href="#36162058">prev</a><span>|</span><label class="collapse" for="c-36161504">[-]</label><label class="expand" for="c-36161504">[3 more]</label></div><br/><div class="children"><div class="content">&gt;then multiply your output by 4.<p>That is not how UTF-32 works.<p>&gt;but the base internal .length function should just output bytes.<p>Do you think the length of an `int64_t[3]` array should be 3 or 24?</div><br/><div id="36161695" class="c"><input type="checkbox" id="c-36161695" checked=""/><div class="controls bullet"><span class="by">ars</span><span>|</span><a href="#36159826">root</a><span>|</span><a href="#36161504">parent</a><span>|</span><label class="collapse" for="c-36161695">[-]</label><label class="expand" for="c-36161695">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Do you think the length of an `int64_t[3]` array should be 3 or 24?<p>There should be functions to do both: sizeof(int64_t[3]) * sizeof(int64_t) for example to get bytes.<p>In this example, the base function should do bytes, and there should be a unicode function to count it in other ways.<p>I could be sizing to fit in a database, or send over the wire, or I might want visible space on the screen, or I might want to know how to move the cursor.<p>Each of those types of length should be supported.</div><br/><div id="36162753" class="c"><input type="checkbox" id="c-36162753" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36159826">root</a><span>|</span><a href="#36161695">parent</a><span>|</span><label class="collapse" for="c-36162753">[-]</label><label class="expand" for="c-36162753">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There should be functions to do both: sizeof(int64_t[3]) * sizeof(int64_t) for example to get bytes.<p>That&#x27;s not what that does, the answer to the code you wrote is 192 because you&#x27;re multiplying the same size factor twice.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>