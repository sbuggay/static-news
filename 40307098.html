<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715331711272" as="style"/><link rel="stylesheet" href="styles.css?v=1715331711272"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Hirrolot/datatype99">Algebraic Data Types for C99</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>bondant</span> | <span>192 comments</span></div><br/><div><div id="40314385" class="c"><input type="checkbox" id="c-40314385" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40307802">next</a><span>|</span><label class="collapse" for="c-40314385">[-]</label><label class="expand" for="c-40314385">[1 more]</label></div><br/><div class="children"><div class="content">If I ever implement a product from scratch again, discriminated unions with compiler enforced exhaustive pattern matching is a hard requirement. It’s too powerful to not have.</div><br/></div></div><div id="40307802" class="c"><input type="checkbox" id="c-40307802" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40314385">prev</a><span>|</span><a href="#40314438">next</a><span>|</span><label class="collapse" for="c-40307802">[-]</label><label class="expand" for="c-40307802">[25 more]</label></div><br/><div class="children"><div class="content">Interesting.<p>Algebraic Data Types are almost always one of the things I miss when I use imperative languages.  I have to do Java at work, and while I&#x27;ve kind of come around on Java and I don&#x27;t think it&#x27;s quite as bad as I have accused it of being, there&#x27;s been several dozen instances of &quot;man I wish Java had F#&#x27;s discriminated unions&quot;.<p>Obviously I&#x27;m aware that you can spoof it with a variety of techniques, and often enums are enough for what you need, but most of those techniques lack the flexibility and terseness of proper ADTs; if nothing else those techniques don&#x27;t have the sexy pattern matching that you get with a functional language.<p>This C extension looks pretty sweet since it appears to have the pattern matching I want; I&#x27;ll see if I can use it for my Arduino projects.</div><br/><div id="40308170" class="c"><input type="checkbox" id="c-40308170" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#40307802">parent</a><span>|</span><a href="#40307821">next</a><span>|</span><label class="collapse" for="c-40308170">[-]</label><label class="expand" for="c-40308170">[15 more]</label></div><br/><div class="children"><div class="content">Everyone who <i>hasn&#x27;t</i> used ADTs and pattern matching doesn&#x27;t get what the big deal is all about. Everyone who <i>is</i> used to ADTs and pattern matching doesn&#x27;t get what the big deal is all about, until they have to work in a language that doesn&#x27;t have them. And everyone who <i>just</i> found out about them can&#x27;t shut up about them being the best thing since sliced bread.<p>:)</div><br/><div id="40313390" class="c"><input type="checkbox" id="c-40313390" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308170">parent</a><span>|</span><a href="#40308830">next</a><span>|</span><label class="collapse" for="c-40313390">[-]</label><label class="expand" for="c-40313390">[2 more]</label></div><br/><div class="children"><div class="content">I’m in the latter camp (from Ocaml) and now using Go. Go feels clunky and awkward.</div><br/><div id="40313900" class="c"><input type="checkbox" id="c-40313900" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40313390">parent</a><span>|</span><a href="#40308830">next</a><span>|</span><label class="collapse" for="c-40313900">[-]</label><label class="expand" for="c-40313900">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because Go is intentionally clunky and awkward in the name of &quot;simplicity&quot;. IMO it&#x27;s <i>charming</i> to some degree, but it&#x27;s far from perfect and I think you&#x27;d need some pretty serious threats to get me to describe it as &quot;elegant&quot; in any way.<p>Rust somehow has more elegance than Go, if only in small parts. Nothing compares to Scheme in the elegance category IMO :)</div><br/></div></div></div></div><div id="40308830" class="c"><input type="checkbox" id="c-40308830" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308170">parent</a><span>|</span><a href="#40313390">prev</a><span>|</span><a href="#40307821">next</a><span>|</span><label class="collapse" for="c-40308830">[-]</label><label class="expand" for="c-40308830">[12 more]</label></div><br/><div class="children"><div class="content">I have mainly used them in Rust. They are nice I suppose, but nothing mindblowing.<p>To me it feels very similar to an interface (trait) implemented by a bunch of classes (structs). I have multiple times wondered which of those two approaches would be better in a given situation, often wanting some aspects of both.<p>Being able to exhaustively pattern match is nice. But being able to define my classes in different places is also nice. And being able to define methods on the classes is nice. And defining a function that will only accept particular variant is nice.<p>From my perspective a discriminant vs a vtable pointer is a boring implementation detail the compiler should just figure out for me based on what would be more optimal in a given situation.</div><br/><div id="40310133" class="c"><input type="checkbox" id="c-40310133" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308830">parent</a><span>|</span><a href="#40315671">next</a><span>|</span><label class="collapse" for="c-40310133">[-]</label><label class="expand" for="c-40310133">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I have multiple times wondered which of those two approaches would be better in a given situation, often wanting some aspects of both.<p>ADTs are closed to extension with new cases but open to extension with new functions, eg. anytime you want to add new cases, you have to update all functions that depend on the ADT, but you can add as many functions for that ADT as you like with no issues.<p>Traits are open to extension with new cases but closed to extension with new functions, eg. you can add as many impl as you like with no issues (new cases), but if you want to add a new function to the trait you have to update all impl to support it.<p>They are logical duals, and the problem of designing systems that are open to extension in both cases and functions is known as the expression problem:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expression_problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expression_problem</a></div><br/><div id="40313561" class="c"><input type="checkbox" id="c-40313561" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40310133">parent</a><span>|</span><a href="#40310353">next</a><span>|</span><label class="collapse" for="c-40313561">[-]</label><label class="expand" for="c-40313561">[2 more]</label></div><br/><div class="children"><div class="content">I suppose this is a genuine dichotomy, but I feel like it’s missing a more critical difference: ADTs cleanly represent <i>data</i>, even when nothing can be, or needs to be, extended from outside.<p>For example, a result is a success value or an error.  A stock order is a market order or a limit order, and <i>nothing else</i>, at least until someone updates the spec and recompiles the code. Situations like this happen <i>all the time</i>.  I don’t want to extend a result to include gizmos in addition to success value or errors, nor do I generally want to extend the set of functions that operate on a certain sort of result.  But I very, very frequently want to represent values with a specific, simple schema, and ADTs fit the bill. A bunch of structs&#x2F;classes, interfaces&#x2F;traits and getters&#x2F;setters <i>can</i> do this, but the result would look like the worst stereotypes of enterprise Java code to accomplish what a language with nice ADTs can do with basically no boilerplate.</div><br/><div id="40313988" class="c"><input type="checkbox" id="c-40313988" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40313561">parent</a><span>|</span><a href="#40310353">next</a><span>|</span><label class="collapse" for="c-40313988">[-]</label><label class="expand" for="c-40313988">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example, a result is a success value or an error. A stock order is a market order or a limit order, and nothing else, at least until someone updates the spec and recompiles the code.<p>But that&#x27;s just it, specs are rarely complete because reality is fluid. For example, a result is a success or an error, until maybe you want an errors to prompt the user to correct something and then the computation can be <i>resumed</i> (see resumable exceptions).<p>Should you even have to recompile your code to handle new cases? Why can&#x27;t you just add the new case, and define new handlers for the functions that depend on your ADT without recompiling that code? That&#x27;s the expression problem.</div><br/></div></div></div></div><div id="40310353" class="c"><input type="checkbox" id="c-40310353" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40310133">parent</a><span>|</span><a href="#40313561">prev</a><span>|</span><a href="#40315671">next</a><span>|</span><label class="collapse" for="c-40310353">[-]</label><label class="expand" for="c-40310353">[1 more]</label></div><br/><div class="children"><div class="content">I want more syntax sugar for my ADTs that mirror what traits have. I don&#x27;t need that kind of double extensibility.</div><br/></div></div></div></div><div id="40315671" class="c"><input type="checkbox" id="c-40315671" checked=""/><div class="controls bullet"><span class="by">bPspGiJT8Y</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308830">parent</a><span>|</span><a href="#40310133">prev</a><span>|</span><a href="#40310730">next</a><span>|</span><label class="collapse" for="c-40315671">[-]</label><label class="expand" for="c-40315671">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And defining a function that will only accept particular variant is nice<p>This is possible to achieve (or hack your way through, if you will) by parameterizing the type and using a nullary type (a type which is impossible to have) to exclude specific cases of a sum type. In Haskell this would look like this:<p><pre><code>    data Weather a b c = Sunny a | Rainy b | Snowy c

    -- can&#x27;t snow in the summer!
    onlySummerWeather :: forall a b. Weather a b Void -&gt; String
    onlySummerWeather weather = case weather of
      Sunny _ -&gt; &quot;Got sunny weather&quot;
      Rainy _ -&gt; &quot;Got rainy weather&quot;
      Snowy v -&gt; absurd v
</code></pre>
where `absurd :: forall a. Void -&gt; a` &quot;if you give me something you can&#x27;t ever have, I will give you anything in return&quot;.</div><br/></div></div><div id="40310730" class="c"><input type="checkbox" id="c-40310730" checked=""/><div class="controls bullet"><span class="by">beltsazar</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308830">parent</a><span>|</span><a href="#40315671">prev</a><span>|</span><a href="#40309628">next</a><span>|</span><label class="collapse" for="c-40310730">[-]</label><label class="expand" for="c-40310730">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To me it feels very similar to an interface (trait) implemented by a bunch of classes (structs)<p>Then you might not fully grok sum types yet.<p>&gt; From my perspective a discriminant vs a vtable pointer is a boring implementation detail the compiler should just figure out for me based on what would be more optimal in a given situation.<p>Disagree. It&#x27;s a design choice that should be decided by the programmers. There&#x27;s a tradeoff—choosing which should be easier: adding a new variant or adding a new function&#x2F;method. It&#x27;s called the Expression Problem: <a href="https:&#x2F;&#x2F;wiki.c2.com&#x2F;?ExpressionProblem" rel="nofollow">https:&#x2F;&#x2F;wiki.c2.com&#x2F;?ExpressionProblem</a></div><br/></div></div><div id="40309628" class="c"><input type="checkbox" id="c-40309628" checked=""/><div class="controls bullet"><span class="by">bmoxb</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308830">parent</a><span>|</span><a href="#40310730">prev</a><span>|</span><a href="#40309054">next</a><span>|</span><label class="collapse" for="c-40309628">[-]</label><label class="expand" for="c-40309628">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in taking a look at OCaml&#x27;s extensible sum types which may straddle the line in the way you&#x27;re describing.</div><br/></div></div><div id="40309054" class="c"><input type="checkbox" id="c-40309054" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308830">parent</a><span>|</span><a href="#40309628">prev</a><span>|</span><a href="#40307821">next</a><span>|</span><label class="collapse" for="c-40309054">[-]</label><label class="expand" for="c-40309054">[4 more]</label></div><br/><div class="children"><div class="content">Enums are closed sets and trait objects are open sets. They <i>are</i> conceptually related concepts, but the language puts syntactic distance between the two, and I don&#x27;t think it should.<p>There are lots of open design questions for every feature you propose, but all of them have been discussed and have higher or lower chance of making it into the language.</div><br/><div id="40309442" class="c"><input type="checkbox" id="c-40309442" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40309054">parent</a><span>|</span><a href="#40307821">next</a><span>|</span><label class="collapse" for="c-40309442">[-]</label><label class="expand" for="c-40309442">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kind of greek to me, but shouldn&#x27;t promising the compiler that my set is closed unlock more features instead of taking features away?</div><br/><div id="40309791" class="c"><input type="checkbox" id="c-40309791" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40309442">parent</a><span>|</span><a href="#40307821">next</a><span>|</span><label class="collapse" for="c-40309791">[-]</label><label class="expand" for="c-40309791">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand your point, but I&#x27;ll elaborate on ways that we could &quot;homogenize&quot; the two features:<p>---<p>We could add implicit enums to impl Trait, so that you could return different types from a function:<p><pre><code>    fn foo() -&gt; enum impl Display {
        if rand() &gt; 0.5 {
            &quot;str&quot;
        } else {
            42
        }
    }
</code></pre>
which would let you get around the problem of returning a type erased object for a Trait that isn&#x27;t object safe:<p><pre><code>    trait Trait {
        const C: i32 = 0;
    }
    impl Trait for i32 {}
    impl Trait for &amp;&#x27;static str {}
    fn foo() -&gt; Box&lt;dyn Trait&gt; {
        if true {
            Box::new(&quot;&quot;)
        } else {
            Box::new(42)
        }
    }

    error[E0038]: the trait `Trait` cannot be made into an object
     --&gt; f500.rs:6:17
      |
    6 | fn foo() -&gt; Box&lt;dyn Trait&gt; {
      |                 ^^^^^^^^^ `Trait` cannot be made into an object
      |
    note: for a trait to be &quot;object safe&quot; it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;traits.html#object-safety&gt;
     --&gt; f500.rs:2:11
      |
    1 | trait Trait {
      |       ----- this trait cannot be made into an object...
    2 |     const C: i32 = 0;
      |           ^ ...because it contains this associated `const`
      = help: consider moving `C` to another trait
      = help: the following types implement the trait, consider defining an enum where each variant holds one of these types, implementing `Trait` for this new enum and using it instead:
                &amp;&#x27;static str
                i32
</code></pre>
---<p>Relax object safety rules, like making all assoc consts implicitly `where Self: Sized`.<p>---<p>We could make enum variants types on their own right, allowing you to write<p><pre><code>    fn foo() -&gt; Result&lt;i32, i32&gt;::Ok { Ok(42) }

    let Ok(val) = foo();
</code></pre>
There&#x27;s some work on this, under the umbrella of &quot;patterns in types&quot;. For now the only supported part of it is specifying a value range for integers, but will likely grow to support arbitrary patterns.<p>---<p>Having a way to express `impl Trait for Enum {}` when every `Enum` variant already implement `Trait` without having to write the whole `impl`.<p>---<p>Anonymous enums:<p><pre><code>    fn foo() -&gt; Foo | Bar | Baz
</code></pre>
---<p>Being able to match on Box&lt;dyn Any&gt; or anonymous enums<p><pre><code>    match foo() {
        x: Foo =&gt; ...,
        x: Bar =&gt; ...,
        _ =&gt; ...,
    }
</code></pre>
---<p>Stop needing to create a new struct type in order to box a single variant<p><pre><code>    enum Foo {
        Bar(Box&lt;struct { a: i32, b: i32 }&gt;),
    }
</code></pre>
---<p>These are of the top of my head, there are many things that you can do to make trait objects and enums feel closer than they do today, to make changing the way your code works a &quot;gradient&quot; instead of a &quot;jump&quot;. My go-to example for this is: if you have a type where every field is Debug, you can derive it. As soon as you add one field that isn&#x27;t Debug, you have to implement the whole impl for your type. That&#x27;s a &quot;jump&quot;. If we had default values for structs you could still use the derive by specifying a default value in the definition. That makes the syntactic change &quot;distance&quot; be as far as the conceptual change &quot;distance&quot;.</div><br/><div id="40309991" class="c"><input type="checkbox" id="c-40309991" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40309791">parent</a><span>|</span><a href="#40307821">next</a><span>|</span><label class="collapse" for="c-40309991">[-]</label><label class="expand" for="c-40309991">[1 more]</label></div><br/><div class="children"><div class="content">A trait is a collection of variants that may or may not have unknown members. An enum is a collection of variants that may not have unknown implementations. So enums are in some sense a subset of traits. Hence every property of traits is also a property of enums. Does that make sense?<p>Those suggestion of your look interesting, but I haven&#x27;t thought them through enough to have an opinion.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40307821" class="c"><input type="checkbox" id="c-40307821" checked=""/><div class="controls bullet"><span class="by">AlecBG</span><span>|</span><a href="#40307802">parent</a><span>|</span><a href="#40308170">prev</a><span>|</span><a href="#40307980">next</a><span>|</span><label class="collapse" for="c-40307821">[-]</label><label class="expand" for="c-40307821">[3 more]</label></div><br/><div class="children"><div class="content">Sealed interfaces in java 21 allow pattern matching</div><br/><div id="40307857" class="c"><input type="checkbox" id="c-40307857" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40307821">parent</a><span>|</span><a href="#40307980">next</a><span>|</span><label class="collapse" for="c-40307857">[-]</label><label class="expand" for="c-40307857">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I know, we just don&#x27;t use Java 21 at work yet.  I&#x27;m super excited for that update, and it actually looks like we will be transitioning to that by the end of the year, but I haven&#x27;t had a chance to play with it just yet.<p>I do find it a little annoying that it&#x27;s taken so long for Java to get a feature that, in my opinion, was so clearly useful; it feels like they were about a decade later on this than they should have been, but I&#x27;ll take whatever victories I can get.</div><br/><div id="40310564" class="c"><input type="checkbox" id="c-40310564" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40307857">parent</a><span>|</span><a href="#40307980">next</a><span>|</span><label class="collapse" for="c-40310564">[-]</label><label class="expand" for="c-40310564">[1 more]</label></div><br/><div class="children"><div class="content">If you can enable preview features, you can use pattern matching since Java 17 (though the final syntax in Java 21 was slightly changed - still you may want to use preview features, it&#x27;s mostly fine in Java as they tend to change very little, and when you do upgrade, the compiler will tell you where you need to update your code).</div><br/></div></div></div></div></div></div><div id="40307980" class="c"><input type="checkbox" id="c-40307980" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40307802">parent</a><span>|</span><a href="#40307821">prev</a><span>|</span><a href="#40314438">next</a><span>|</span><label class="collapse" for="c-40307980">[-]</label><label class="expand" for="c-40307980">[6 more]</label></div><br/><div class="children"><div class="content">Kotlin is JVM compatible and has ADTs.<p>Java has <a href="https:&#x2F;&#x2F;github.com&#x2F;functionaljava&#x2F;functionaljava">https:&#x2F;&#x2F;github.com&#x2F;functionaljava&#x2F;functionaljava</a><p>which is unsupported but stable.</div><br/><div id="40308077" class="c"><input type="checkbox" id="c-40308077" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40307980">parent</a><span>|</span><a href="#40310620">next</a><span>|</span><label class="collapse" for="c-40308077">[-]</label><label class="expand" for="c-40308077">[2 more]</label></div><br/><div class="children"><div class="content">Sure, and Scala has had ADTs since its inception as well I think, and that&#x27;s also JVM.  It&#x27;s not ADTs, but Clojure does have some level of pattern matching&#x2F;destructuring as well.<p>It wasn&#x27;t that I though that the JVM was incapable of doing something like an ADT, just that vanilla Java didn&#x27;t support it. While it&#x27;s easy to say that &quot;companies should just use Kotlin&quot;, that&#x27;s a bit of a big ordeal if you already have a 15 year old codebase that&#x27;s written in Java.<p>I&#x27;ve heard of but never used the Functional Java library, though it&#x27;d be a tough sell to get my work to let me import a library that hasn&#x27;t been updated in two years.</div><br/><div id="40311297" class="c"><input type="checkbox" id="c-40311297" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40308077">parent</a><span>|</span><a href="#40310620">next</a><span>|</span><label class="collapse" for="c-40311297">[-]</label><label class="expand" for="c-40311297">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that&#x27;s a bit of a big ordeal if you already have a 15 year old codebase that&#x27;s written in Java.<p>JetBrains has prioritised compatibility with Java and it shows. Of course, there are some gotchas (such as nullability or checked exceptions which don&#x27;t exist in Kotlin), but you can really mix Kotlin and Java code relatively freely.</div><br/></div></div></div></div><div id="40310620" class="c"><input type="checkbox" id="c-40310620" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40307980">parent</a><span>|</span><a href="#40308077">prev</a><span>|</span><a href="#40314438">next</a><span>|</span><label class="collapse" for="c-40310620">[-]</label><label class="expand" for="c-40310620">[3 more]</label></div><br/><div class="children"><div class="content">Java 21&#x27;s pattern matching (you don&#x27;t need functionaljava, and shouldn&#x27;t really use that unless you&#x27;re really into FP) is kind of nicer than Kotlin&#x27;s, because you can automatically &quot;destruct&quot; records in your matches.<p>For Java, see <a href="https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-lts-21-new-features" rel="nofollow">https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-lts-21-new-features</a><p>Kotlin&#x27;s: <a href="https:&#x2F;&#x2F;www.baeldung.com&#x2F;kotlin&#x2F;when" rel="nofollow">https:&#x2F;&#x2F;www.baeldung.com&#x2F;kotlin&#x2F;when</a><p>Make up your own mind.</div><br/><div id="40315618" class="c"><input type="checkbox" id="c-40315618" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#40307802">root</a><span>|</span><a href="#40310620">parent</a><span>|</span><a href="#40314438">next</a><span>|</span><label class="collapse" for="c-40315618">[-]</label><label class="expand" for="c-40315618">[2 more]</label></div><br/><div class="children"><div class="content">&gt; kind of nicer than Kotlin&#x27;s, because you can automatically &quot;destruct&quot; records in your matches.<p>I find positional destructuring of records a bad idea.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31399737">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31399737</a></div><br/></div></div></div></div></div></div></div></div><div id="40314438" class="c"><input type="checkbox" id="c-40314438" checked=""/><div class="controls bullet"><span class="by">drycabinet</span><span>|</span><a href="#40307802">prev</a><span>|</span><a href="#40307412">next</a><span>|</span><label class="collapse" for="c-40314438">[-]</label><label class="expand" for="c-40314438">[2 more]</label></div><br/><div class="children"><div class="content">Wikipedia has something interesting on this (how unions can be implemented using &quot;class hierarchy in object-oriented programming&quot;): 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tagged_union#Class_hierarchies_as_tagged_unions" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tagged_union#Class_hierarchies...</a><p>There is a lengthy blog post about the same stuff, except that the author doesn&#x27;t seem to have come across the said wiki section yet: 
<a href="https:&#x2F;&#x2F;nandakumar.org&#x2F;blog&#x2F;2023&#x2F;12&#x2F;paradigms-in-disguise.html" rel="nofollow">https:&#x2F;&#x2F;nandakumar.org&#x2F;blog&#x2F;2023&#x2F;12&#x2F;paradigms-in-disguise.ht...</a><p>Kudos to the dev of datatype99 for showing the problem with such ad-hoc methods in the readme right away.</div><br/></div></div><div id="40307412" class="c"><input type="checkbox" id="c-40307412" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40314438">prev</a><span>|</span><a href="#40307747">next</a><span>|</span><label class="collapse" for="c-40307412">[-]</label><label class="expand" for="c-40307412">[3 more]</label></div><br/><div class="children"><div class="content">Definitely looks nicer and probably works better than my older attempt [1], but uses 8x more code and depends on the awesome but kinda scary Metalang9 macro toolkit. I think libsum is a good intro if you want to see how algebraic data types work underneath.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;naasking&#x2F;libsum">https:&#x2F;&#x2F;github.com&#x2F;naasking&#x2F;libsum</a></div><br/><div id="40309436" class="c"><input type="checkbox" id="c-40309436" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40307412">parent</a><span>|</span><a href="#40307747">next</a><span>|</span><label class="collapse" for="c-40309436">[-]</label><label class="expand" for="c-40309436">[2 more]</label></div><br/><div class="children"><div class="content">I have a star on your repository, so it seems I was looking into it while designing Datatype99 :)</div><br/><div id="40311537" class="c"><input type="checkbox" id="c-40311537" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40307412">root</a><span>|</span><a href="#40309436">parent</a><span>|</span><a href="#40307747">next</a><span>|</span><label class="collapse" for="c-40311537">[-]</label><label class="expand" for="c-40311537">[1 more]</label></div><br/><div class="children"><div class="content">GH stars kinda function as a bookmark system, except I never go looking at what all I&#x27;ve starred, so it&#x27;s more of an optimistic bookmark system.<p>I only sometimes use it as a &quot;I would recommend this repo&quot; -- how can one do that anyways, given that the repo could morph into something one would no longer recommend?</div><br/></div></div></div></div></div></div><div id="40307747" class="c"><input type="checkbox" id="c-40307747" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#40307412">prev</a><span>|</span><a href="#40312855">next</a><span>|</span><label class="collapse" for="c-40307747">[-]</label><label class="expand" for="c-40307747">[5 more]</label></div><br/><div class="children"><div class="content">This is the work of a wizard.<p>I&#x27;ve known C for almost 20 years, and never would I have thought the macro system was powerful enough to allow such black magic.<p>This is awesome!</div><br/><div id="40309097" class="c"><input type="checkbox" id="c-40309097" checked=""/><div class="controls bullet"><span class="by">cl91</span><span>|</span><a href="#40307747">parent</a><span>|</span><a href="#40308068">next</a><span>|</span><label class="collapse" for="c-40309097">[-]</label><label class="expand" for="c-40309097">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve known C for almost 20 years<p>The author is only 19 years old. I feel really dumb now.</div><br/></div></div><div id="40308068" class="c"><input type="checkbox" id="c-40308068" checked=""/><div class="controls bullet"><span class="by">clnhlzmn</span><span>|</span><a href="#40307747">parent</a><span>|</span><a href="#40309097">prev</a><span>|</span><a href="#40308231">next</a><span>|</span><label class="collapse" for="c-40308068">[-]</label><label class="expand" for="c-40308068">[1 more]</label></div><br/><div class="children"><div class="content">You might also be interested in metalang99 by the same author.</div><br/></div></div><div id="40308231" class="c"><input type="checkbox" id="c-40308231" checked=""/><div class="controls bullet"><span class="by">jacoblambda</span><span>|</span><a href="#40307747">parent</a><span>|</span><a href="#40308068">prev</a><span>|</span><a href="#40308016">next</a><span>|</span><label class="collapse" for="c-40308231">[-]</label><label class="expand" for="c-40308231">[1 more]</label></div><br/><div class="children"><div class="content">Yeah xmacros (the style of macro use) are pretty fancy. &quot;Classically&quot; they are used for creating and accessing type safe generics or for reducing boilerplate for hardware register and interrupt definitions.<p>They are kind of cursed but at their core they are actually incredibly simple and a reliable tool for reducing cognitive complexity and boilerplate in C based projects.</div><br/></div></div><div id="40308016" class="c"><input type="checkbox" id="c-40308016" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40307747">parent</a><span>|</span><a href="#40308231">prev</a><span>|</span><a href="#40312855">next</a><span>|</span><label class="collapse" for="c-40308016">[-]</label><label class="expand" for="c-40308016">[1 more]</label></div><br/><div class="children"><div class="content">ADTs are mostly string replacement on generic structs and unions, plus tagging on the union. It&#x27;s not a complicated use of macros.</div><br/></div></div></div></div><div id="40312855" class="c"><input type="checkbox" id="c-40312855" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#40307747">prev</a><span>|</span><a href="#40311204">next</a><span>|</span><label class="collapse" for="c-40312855">[-]</label><label class="expand" for="c-40312855">[5 more]</label></div><br/><div class="children"><div class="content">&gt; PLEASE, do not use top-level break&#x2F;continue inside statements provided to of and ifLet; use goto labels instead.<p>Seems like a pretty big footgun. But otherwise, very cool.</div><br/><div id="40313378" class="c"><input type="checkbox" id="c-40313378" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#40312855">parent</a><span>|</span><a href="#40314804">next</a><span>|</span><label class="collapse" for="c-40313378">[-]</label><label class="expand" for="c-40313378">[1 more]</label></div><br/><div class="children"><div class="content">Using goto instead isn&#x27;t a problem, but knowing not to use break&#x2F;continue inside of such blocks is something that you will have to be aware of.<p>I had written a immediate mode UI out of macros, and this reminded me of that although in my case it is not a problem, although some blocks are ones that you can use &quot;break&quot;. For example, you can use &quot;break&quot; to exit out of a win_form block (&quot;goto&quot; also works), while a win_command block does not capture &quot;break&quot; so using break (or goto) inside of a win_command block will break out of whatever block the win_command is in (probably a win_form block; for example, this would commonly be used in the case of a &quot;Cancel&quot; button).</div><br/></div></div><div id="40314804" class="c"><input type="checkbox" id="c-40314804" checked=""/><div class="controls bullet"><span class="by">392</span><span>|</span><a href="#40312855">parent</a><span>|</span><a href="#40313378">prev</a><span>|</span><a href="#40313260">next</a><span>|</span><label class="collapse" for="c-40314804">[-]</label><label class="expand" for="c-40314804">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s neat about Rust is that in its macro land, writing the code that checked for this condition would be not only possible, but doable, imaginable, and aided by easily installable OSS libraries.<p>So it&#x27;s not just about being slightly better in some ways, but smoothing over so many paper cuts that it can be hard to see how they have added up overtime across ecosystems, like CPython and co having so many of its own vocab types, or HPC libs.<p>For example, the problem with this macro that causes this wouldn&#x27;t even be problems in a well written Rust macro. They&#x27;re artifacts of smart people trying to work around C&#x27;s limitations.<p>But then the macro wouldn&#x27;t have been written anyway because this is a port of a native Rust feature (which means it gets taken advantage of in community software).</div><br/></div></div><div id="40313260" class="c"><input type="checkbox" id="c-40313260" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#40312855">parent</a><span>|</span><a href="#40314804">prev</a><span>|</span><a href="#40311204">next</a><span>|</span><label class="collapse" for="c-40313260">[-]</label><label class="expand" for="c-40313260">[2 more]</label></div><br/><div class="children"><div class="content">goto is a footgun only if you use it to move from function to function, which btw was what &quot;goto considered harmful&quot; was about. That practice has disappeared, and now goto, within a function, is pretty harmless and quite identical to break&#x2F;continue in fact.</div><br/><div id="40313577" class="c"><input type="checkbox" id="c-40313577" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#40312855">root</a><span>|</span><a href="#40313260">parent</a><span>|</span><a href="#40311204">next</a><span>|</span><label class="collapse" for="c-40313577">[-]</label><label class="expand" for="c-40313577">[1 more]</label></div><br/><div class="children"><div class="content">Goto isn&#x27;t the footgun. The footgun is if you use break&#x2F;continue by accident then some unspecified bad thing will happen, silently I&#x27;m guessing.</div><br/></div></div></div></div></div></div><div id="40311204" class="c"><input type="checkbox" id="c-40311204" checked=""/><div class="controls bullet"><span class="by">mingodad</span><span>|</span><a href="#40312855">prev</a><span>|</span><a href="#40309926">next</a><span>|</span><label class="collapse" for="c-40311204">[-]</label><label class="expand" for="c-40311204">[1 more]</label></div><br/><div class="children"><div class="content">There is also <a href="https:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;melt.cs.umn.edu&#x2F;</a> that has an extension that add templates and algebraic data types to C : <a href="https:&#x2F;&#x2F;github.com&#x2F;melt-umn&#x2F;ableC-template-algebraic-data-types">https:&#x2F;&#x2F;github.com&#x2F;melt-umn&#x2F;ableC-template-algebraic-data-ty...</a></div><br/></div></div><div id="40309926" class="c"><input type="checkbox" id="c-40309926" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#40311204">prev</a><span>|</span><a href="#40311460">next</a><span>|</span><label class="collapse" for="c-40309926">[-]</label><label class="expand" for="c-40309926">[1 more]</label></div><br/><div class="children"><div class="content">What a madlad. Kudos for implementing this.</div><br/></div></div><div id="40312278" class="c"><input type="checkbox" id="c-40312278" checked=""/><div class="controls bullet"><span class="by">WhereIsTheTruth</span><span>|</span><a href="#40311460">prev</a><span>|</span><a href="#40310894">next</a><span>|</span><label class="collapse" for="c-40312278">[-]</label><label class="expand" for="c-40312278">[1 more]</label></div><br/><div class="children"><div class="content">Tagged Union is a must have in a programming language</div><br/></div></div><div id="40310894" class="c"><input type="checkbox" id="c-40310894" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#40312278">prev</a><span>|</span><a href="#40308526">next</a><span>|</span><label class="collapse" for="c-40310894">[-]</label><label class="expand" for="c-40310894">[3 more]</label></div><br/><div class="children"><div class="content">Anyone considering using this should be strongly looking at using Swift or Rust instead. You can build almost any given language idea using the C macro preprocessor, but that doesn&#x27;t mean it&#x27;s a good idea to ship production code using it.<p>The worst codebases to inherit as a maintenance programmer are the ones where people got clever with the C preprocessor. Impossible to debug and impossible to maintain.</div><br/><div id="40315702" class="c"><input type="checkbox" id="c-40315702" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#40310894">parent</a><span>|</span><a href="#40314623">next</a><span>|</span><label class="collapse" for="c-40315702">[-]</label><label class="expand" for="c-40315702">[1 more]</label></div><br/><div class="children"><div class="content">C99 is a stable target for writing bootstrappable software: there are multiple mature compiler implementations, at least one of which is bootstrappable down to hex0, and the bootstrap chain is not too long.</div><br/></div></div><div id="40314623" class="c"><input type="checkbox" id="c-40314623" checked=""/><div class="controls bullet"><span class="by">392</span><span>|</span><a href="#40310894">parent</a><span>|</span><a href="#40315702">prev</a><span>|</span><a href="#40308526">next</a><span>|</span><label class="collapse" for="c-40314623">[-]</label><label class="expand" for="c-40314623">[1 more]</label></div><br/><div class="children"><div class="content">I find that most abuses of the preprocessor are by folks unwilling&#x2F;unable to simplify their design into a form that&#x27;s (a) native to the C language&#x2F;runtime or (b) not repetitive to type.<p>This library on the other hand addresses a nasty papercut whose presence usually stops folks with modern language experience from choosing C when it might otherwise be valid. Plus you can&#x27;t beat C&#x27;s long-term stability.<p>Though I agree that 90+% who _think_ they still need C should probably move on to making Rust work for them, instead.</div><br/></div></div></div></div><div id="40308526" class="c"><input type="checkbox" id="c-40308526" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40310894">prev</a><span>|</span><a href="#40308293">next</a><span>|</span><label class="collapse" for="c-40308526">[-]</label><label class="expand" for="c-40308526">[7 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s say you have a C program to write, and you really want exhaustive pattern matching on the tags of unions (which is what Datatype99 provides: &quot;Put simply, Datatype99 is just a syntax sugar over tagged unions&quot;).<p>Let&#x27;s say further that you already know Rust exists, and aren&#x27;t going to use it for reasons that anyone writing a C program already knows.<p>At least consider Zig. Here&#x27;s a little something I wrote in Zig two days ago:<p><pre><code>    &#x2F;&#x2F;&#x2F; Adjust a label-bearing OpCode by `l`. No-op if no label.
    pub fn adjust(self: *OpCode, l: i16) void {
        switch (self.*) {
            inline else =&gt; |*op| {
                const PayType = @TypeOf(op.*);
                if (PayType != void and @hasField(PayType, &quot;l&quot;)) {
                    op.*.l += l;
                }
            },
        }
    }
</code></pre>
This uses comptime (inline else) to generate all branches of a switch statement over a tagged union, and add an offset to members of that union which have an &quot;l&quot; field.  You can vary the nature of the branches on any comptime-available type info, which is a lot, and all the conditions are compile-time, each branch of the switch has only the logic needed to handle that variant.<p>&quot;But my program is already in C, I just need it for one file&quot; right. Try Zig. You might like it.</div><br/><div id="40309670" class="c"><input type="checkbox" id="c-40309670" checked=""/><div class="controls bullet"><span class="by">pajko</span><span>|</span><a href="#40308526">parent</a><span>|</span><a href="#40308293">next</a><span>|</span><label class="collapse" for="c-40309670">[-]</label><label class="expand" for="c-40309670">[6 more]</label></div><br/><div class="children"><div class="content">Seems like Nim can be useful too, plus it compiles to C.<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;unclechu&#x2F;eb37cc81e80afbbb5e74990b62ea21f6" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;unclechu&#x2F;eb37cc81e80afbbb5e74990b62e...</a></div><br/><div id="40310679" class="c"><input type="checkbox" id="c-40310679" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40308526">root</a><span>|</span><a href="#40309670">parent</a><span>|</span><a href="#40312316">next</a><span>|</span><label class="collapse" for="c-40310679">[-]</label><label class="expand" for="c-40310679">[2 more]</label></div><br/><div class="children"><div class="content">In Nim, ADTs are painful still (as your example clearly shows), but they are working on adding proper ADTs to the language (I can&#x27;t find where I read that, but I am sure I did!).</div><br/><div id="40314809" class="c"><input type="checkbox" id="c-40314809" checked=""/><div class="controls bullet"><span class="by">j-james</span><span>|</span><a href="#40308526">root</a><span>|</span><a href="#40310679">parent</a><span>|</span><a href="#40312316">next</a><span>|</span><label class="collapse" for="c-40314809">[-]</label><label class="expand" for="c-40314809">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;nim-lang&#x2F;RFCs&#x2F;issues&#x2F;548">https:&#x2F;&#x2F;github.com&#x2F;nim-lang&#x2F;RFCs&#x2F;issues&#x2F;548</a></div><br/></div></div></div></div><div id="40312316" class="c"><input type="checkbox" id="c-40312316" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40308526">root</a><span>|</span><a href="#40309670">parent</a><span>|</span><a href="#40310679">prev</a><span>|</span><a href="#40308293">next</a><span>|</span><label class="collapse" for="c-40312316">[-]</label><label class="expand" for="c-40312316">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been a Nim respecter for many years, it&#x27;s slept on in general as a language.<p>The difference here is that Nim compiles to C and you can turn the garbage collector off: Zig <i>compiles C</i> and there&#x27;s no garbage collector.  That means the entire standard library is available when generating object code. It&#x27;s also trivial to opt-in to the C ABI on a fine-grained basis, by defining a function or struct with the extern keyword.<p>I believe this is still fairly current about the difficulties of building Nim dylibs for C programs: <a href="https:&#x2F;&#x2F;peterme.net&#x2F;dynamic-libraries-in-nim.html" rel="nofollow">https:&#x2F;&#x2F;peterme.net&#x2F;dynamic-libraries-in-nim.html</a><p>I expect Nim will stabilize about where D has: it will have a dialect of the language which, with relatively painless accommodations, is able to produce object code which speaks C ABI.  Zig is different. The language is relentlessly focused on providing a better alternative to C while occupying the same niche, and a lot of design time has been spent on making it practical to take an existing C program and start writing the new parts of it in Zig.<p>It&#x27;s a good language, Nim, and getting better. I&#x27;d recommend it for someone who is considering Go, for example.</div><br/><div id="40315919" class="c"><input type="checkbox" id="c-40315919" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#40308526">root</a><span>|</span><a href="#40312316">parent</a><span>|</span><a href="#40314834">next</a><span>|</span><label class="collapse" for="c-40315919">[-]</label><label class="expand" for="c-40315919">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s say further that you already know Zig exists, and aren&#x27;t going to use it for reasons that anyone writing a C&#x2F;Rust&#x2F;D&#x2F;C++ program already knows.<p>At least give Nim a try.</div><br/></div></div><div id="40314834" class="c"><input type="checkbox" id="c-40314834" checked=""/><div class="controls bullet"><span class="by">j-james</span><span>|</span><a href="#40308526">root</a><span>|</span><a href="#40312316">parent</a><span>|</span><a href="#40315919">prev</a><span>|</span><a href="#40308293">next</a><span>|</span><label class="collapse" for="c-40314834">[-]</label><label class="expand" for="c-40314834">[1 more]</label></div><br/><div class="children"><div class="content">I think this is all true. Though with regard to your earlier example, it should be noted that Nim, too, has an extraordinarily powerful compile-time programming system: but it takes the form of typed macros and generics (as opposed to Zig&#x27;s dislike for such abstractions).</div><br/></div></div></div></div></div></div></div></div><div id="40308293" class="c"><input type="checkbox" id="c-40308293" checked=""/><div class="controls bullet"><span class="by">jackling</span><span>|</span><a href="#40308526">prev</a><span>|</span><a href="#40307717">next</a><span>|</span><label class="collapse" for="c-40308293">[-]</label><label class="expand" for="c-40308293">[8 more]</label></div><br/><div class="children"><div class="content">Could you not get most of the benefits of ADTs using structs + unions + enums? I&#x27;ve used the pattern where I had a union of several types and an enum to differentiate which one to pick. Something like std::variant seems to work a bit like a sum type.<p>The only issue is you can&#x27;t do a clean switch statement that matches on the specific value of a field, but nested switch statements aren&#x27;t that messy.</div><br/><div id="40308700" class="c"><input type="checkbox" id="c-40308700" checked=""/><div class="controls bullet"><span class="by">acuozzo</span><span>|</span><a href="#40308293">parent</a><span>|</span><a href="#40312577">next</a><span>|</span><label class="collapse" for="c-40308700">[-]</label><label class="expand" for="c-40308700">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and you can also get many of the benefits of OOP with convention and discipline, but doing so requires you to frequently get down in the weeds since, e.g., vtables must be dealt with manually.<p>The trouble with this approach is that there&#x27;s a lot of mental overhead in dotting all of your i&#x27;s and crossing all of your t&#x27;s. It&#x27;s draining, so you start to, e.g., shoehorn additional functionality into existing classes instead of making new ones.<p>You eventually wind up perceiving the abstraction as costly which lessons your use of it at the expense of producing a more elegant solution to the problem(s) you&#x27;re solving.<p>tl,dr? The ability to just state &quot;Darmok and Jalad at Tanagra&quot; is transformative when the alternative is telling an entire story every time you want to reference a complex idea.</div><br/></div></div><div id="40312577" class="c"><input type="checkbox" id="c-40312577" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40308293">parent</a><span>|</span><a href="#40308700">prev</a><span>|</span><a href="#40310179">next</a><span>|</span><label class="collapse" for="c-40312577">[-]</label><label class="expand" for="c-40312577">[1 more]</label></div><br/><div class="children"><div class="content">The absolutely critical thing is to have checked every alternative when dealing with a sum type value.  This is hard to do with macros, though not impossible (basically you&#x27;d need a macro to start a matching context and which introduces a variable in which to keep track of all the alternatives checked, then you need to arrange for the end of the matching context to check that all alternatives were checked).</div><br/></div></div><div id="40310179" class="c"><input type="checkbox" id="c-40310179" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40308293">parent</a><span>|</span><a href="#40312577">prev</a><span>|</span><a href="#40309037">next</a><span>|</span><label class="collapse" for="c-40310179">[-]</label><label class="expand" for="c-40310179">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Could you not get most of the benefits of ADTs using structs + unions + enums?<p>The modelling aspects can be simulated, yes, but that&#x27;s barely half of the benefits of ADTs. Pattern matching is a big ergonomic benefit.</div><br/><div id="40312583" class="c"><input type="checkbox" id="c-40312583" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40308293">root</a><span>|</span><a href="#40310179">parent</a><span>|</span><a href="#40309037">next</a><span>|</span><label class="collapse" for="c-40312583">[-]</label><label class="expand" for="c-40312583">[2 more]</label></div><br/><div class="children"><div class="content">TFA gets pattern matching.<p>The critical thing is that the compiler (or macro system) needs to check that you&#x27;ve checked all the alternatives.</div><br/><div id="40313934" class="c"><input type="checkbox" id="c-40313934" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40308293">root</a><span>|</span><a href="#40312583">parent</a><span>|</span><a href="#40309037">next</a><span>|</span><label class="collapse" for="c-40313934">[-]</label><label class="expand" for="c-40313934">[1 more]</label></div><br/><div class="children"><div class="content">Yes TFA is pretty close, but note that it&#x27;s not just &quot;structs + unions + enums&quot; getting you &quot;most of the benefits&quot;, which is what I was responding to. There&#x27;s a buttload of macros hiding allocation and switch statements.</div><br/></div></div></div></div></div></div><div id="40309037" class="c"><input type="checkbox" id="c-40309037" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#40308293">parent</a><span>|</span><a href="#40310179">prev</a><span>|</span><a href="#40307717">next</a><span>|</span><label class="collapse" for="c-40309037">[-]</label><label class="expand" for="c-40309037">[2 more]</label></div><br/><div class="children"><div class="content">I generally don&#x27;t mind C++ for most code when it&#x27;s absolutely necessary, but I&#x27;m not a huge fan of std::variant. Using std::visit to exhaustively match all cases feels hacky. It really would benefit from being a first-class language feature. It&#x27;s more impactful to a lot of day-to-day code than other things they&#x27;ve worked on, such as coroutines.</div><br/><div id="40313199" class="c"><input type="checkbox" id="c-40313199" checked=""/><div class="controls bullet"><span class="by">TheBicPen</span><span>|</span><a href="#40308293">root</a><span>|</span><a href="#40309037">parent</a><span>|</span><a href="#40307717">next</a><span>|</span><label class="collapse" for="c-40313199">[-]</label><label class="expand" for="c-40313199">[1 more]</label></div><br/><div class="children"><div class="content">The 4th example at <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;variant&#x2F;visit" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;variant&#x2F;visit</a>
that uses a class template makes the feature a bit nicer, but still not as ergonomic as something like Rust.</div><br/></div></div></div></div></div></div><div id="40307717" class="c"><input type="checkbox" id="c-40307717" checked=""/><div class="controls bullet"><span class="by">different_base</span><span>|</span><a href="#40308293">prev</a><span>|</span><label class="collapse" for="c-40307717">[-]</label><label class="expand" for="c-40307717">[128 more]</label></div><br/><div class="children"><div class="content">One of the crimes of modern imperative programming languages is not having ADTs (except maybe Rust) built-in. It is such a basic mental model of how humans think and solve problems. But instead we got inheritance and enums which are practically very primitive.</div><br/><div id="40308133" class="c"><input type="checkbox" id="c-40308133" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40307899">next</a><span>|</span><label class="collapse" for="c-40308133">[-]</label><label class="expand" for="c-40308133">[2 more]</label></div><br/><div class="children"><div class="content">Moreover, they have already been proposed by John McCarthy in October 1964, 60 years ago, for inclusion in the successor of ALGOL 60, which makes even more weird the lack of widespread support.<p>(And in fact Algol 68 had a better implementation than most later languages, but Algol 68 was missing completely any documentation suitable for newbies, like tutorials and programming examples, while not being promoted by any hardware vendor, like IBM or DEC, so it was doomed.)</div><br/><div id="40309256" class="c"><input type="checkbox" id="c-40309256" checked=""/><div class="controls bullet"><span class="by">floxy</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308133">parent</a><span>|</span><a href="#40307899">next</a><span>|</span><label class="collapse" for="c-40309256">[-]</label><label class="expand" for="c-40309256">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The more I ponder the principles of language design, and the techniques which put them into practice, the more is my amazement and admiration of ALGOL 60. Here is a language so far ahead of its time, that it was not only an improvement on its predecessors, but also on nearly all its successors.<p><a href="https:&#x2F;&#x2F;web.eecs.umich.edu&#x2F;~bchandra&#x2F;courses&#x2F;papers&#x2F;Hoare_Hints.pdf" rel="nofollow">https:&#x2F;&#x2F;web.eecs.umich.edu&#x2F;~bchandra&#x2F;courses&#x2F;papers&#x2F;Hoare_Hi...</a></div><br/></div></div></div></div><div id="40307899" class="c"><input type="checkbox" id="c-40307899" checked=""/><div class="controls bullet"><span class="by">jjice</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40308133">prev</a><span>|</span><a href="#40307807">next</a><span>|</span><label class="collapse" for="c-40307899">[-]</label><label class="expand" for="c-40307899">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never written Swift, but it seems like they have it too <a href="https:&#x2F;&#x2F;docs.swift.org&#x2F;swift-book&#x2F;documentation&#x2F;the-swift-programming-language&#x2F;enumerations&#x2F;#Associated-Values" rel="nofollow">https:&#x2F;&#x2F;docs.swift.org&#x2F;swift-book&#x2F;documentation&#x2F;the-swift-pr...</a><p>I also would love a future where ADTs are more common in imperative languages</div><br/><div id="40307991" class="c"><input type="checkbox" id="c-40307991" checked=""/><div class="controls bullet"><span class="by">odyssey7</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40307899">parent</a><span>|</span><a href="#40307807">next</a><span>|</span><label class="collapse" for="c-40307991">[-]</label><label class="expand" for="c-40307991">[1 more]</label></div><br/><div class="children"><div class="content">Swift “enumerations” are <i>very</i> nice.</div><br/></div></div></div></div><div id="40307807" class="c"><input type="checkbox" id="c-40307807" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40307899">prev</a><span>|</span><a href="#40309251">next</a><span>|</span><label class="collapse" for="c-40307807">[-]</label><label class="expand" for="c-40307807">[40 more]</label></div><br/><div class="children"><div class="content">Zig is a modern imperative programming language with ADTs: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#Tagged-union" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#Tagged-union</a></div><br/><div id="40309239" class="c"><input type="checkbox" id="c-40309239" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40307807">parent</a><span>|</span><a href="#40308754">next</a><span>|</span><label class="collapse" for="c-40309239">[-]</label><label class="expand" for="c-40309239">[24 more]</label></div><br/><div class="children"><div class="content">While this is a step up from C, it is still a long way from the full power and generality of algebraic data types. The key word here is algebraic. In a language with ADTs, such as Haskell, you can pattern match on an arbitrarily complex types, not just the outermost tag. A contrived example (from [1]):<p><pre><code>    contrived :: ([a], Char, (Int, Float), String, Bool) -&gt; Bool
    contrived    ([],  &#x27;b&#x27;,  (1,   2.0),   &quot;hi&quot;,   True) = False
</code></pre>
To achieve a result like this using Zig&#x27;s switch syntax would seem to involve a huge amount of boilerplate code and nested switch statements.<p>[1] <a href="https:&#x2F;&#x2F;www.haskell.org&#x2F;tutorial&#x2F;patterns.html" rel="nofollow">https:&#x2F;&#x2F;www.haskell.org&#x2F;tutorial&#x2F;patterns.html</a></div><br/><div id="40309400" class="c"><input type="checkbox" id="c-40309400" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309239">parent</a><span>|</span><a href="#40308754">next</a><span>|</span><label class="collapse" for="c-40309400">[-]</label><label class="expand" for="c-40309400">[23 more]</label></div><br/><div class="children"><div class="content">This is more of syntax sugar than power and generality, since nested pattern matching can be mechanically translated into &quot;top-level&quot; matching (e.g., see [1] and [2]).<p>[1] L. Augustsson. Compiling Pattern Matching. In Functional
Programming Languages and Computer Architecture, pages 368–
381, 1985.<p>[2] P. Wadler. Efficient Compilation of Pattern Matching. In S.L. Peyton
Jones, editor, The Implementation of Functional Programming
Languages, pages 78–103. Prentice Hall, 1987.</div><br/><div id="40311293" class="c"><input type="checkbox" id="c-40311293" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309400">parent</a><span>|</span><a href="#40309478">next</a><span>|</span><label class="collapse" for="c-40311293">[-]</label><label class="expand" for="c-40311293">[6 more]</label></div><br/><div class="children"><div class="content">This is where I like to cite Dijstra&#x27;s &quot;Go To Statement Considered Harmful&quot;.<p>What a lot of people miss about that paper is that he wasn&#x27;t <i>just</i> talking about goto statements. He was also making a more general observation about how more powerful and general programming language features are not necessarily desirable, because they tend to adversely impact developer productivity.<p>The reason I, as a user, prefer structured control flow statements over goto is not that I believe they are powerful. It&#x27;s precisely because they are <i>less</i> powerful. The resulting constraints on how the program can be structured make it easier for me to read and reason about existing code. That makes maintaining code easier. It also makes optimization and static analysis easier. And it makes writing tests easier, too.<p>I have similar feelings about ADTs. The reason I prefer them to other ways of doing composite data types is not that I think they&#x27;re more powerful. It&#x27;s that they create constraints that tend to reduce the semantic complexity of the domain models people create in programming languages that use them. And that makes my job easier.<p>The corollary to that, though, is that I&#x27;m not actually all that hype about adding ADTs to existing languages. For reasons that are similar to how the mere availability of structured, reentrant function calls is small consolation in a codebase that&#x27;s already riddled with goto statements. The real win doesn&#x27;t come from using ADTs, it comes from not having to worry about all those other confusing overpowered things that aren&#x27;t ADTs.</div><br/><div id="40311729" class="c"><input type="checkbox" id="c-40311729" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40311293">parent</a><span>|</span><a href="#40309478">next</a><span>|</span><label class="collapse" for="c-40311729">[-]</label><label class="expand" for="c-40311729">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly where I am.  Pattern matched sum types &quot;feel great&quot; to code in to an expert because they are a concise and reasonably tight way to express the otherwise boring &quot;enumerate over possibilities&quot; code.<p>But <i>they&#x27;re hard to read</i> for anyone who isn&#x27;t an expert on not just the language but the type in question (c.f. Rust&#x27;s Option() idioms all looks like line noise to newbies, etc...).  And that&#x27;s a bad trade.<p>In essence, this stuff is just Perl all over again.  It&#x27;s a language feature that  prioritizes concision over comprehension.  And I say that as someone who really likes coding in perl. But &quot;people&quot; don&#x27;t like perl, and the community moved on, and the reasons are... the same reason that uptake in ADTs is lagging where the experts want it to be.</div><br/><div id="40312028" class="c"><input type="checkbox" id="c-40312028" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40311729">parent</a><span>|</span><a href="#40312350">next</a><span>|</span><label class="collapse" for="c-40312028">[-]</label><label class="expand" for="c-40312028">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve got to distinguish syntax from semantics, though. I agree, it&#x27;s easy to turn a big semantic win into a net readability loss if you choose to represent it with an overly terse syntax that promotes code golf.</div><br/><div id="40313394" class="c"><input type="checkbox" id="c-40313394" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40312028">parent</a><span>|</span><a href="#40312350">next</a><span>|</span><label class="collapse" for="c-40313394">[-]</label><label class="expand" for="c-40313394">[1 more]</label></div><br/><div class="children"><div class="content">Compilers are really smart.  It&#x27;s easy enough in the modern world to demand that a &quot;type&quot; field be checked against all enumerants, preserving the &quot;semantic win&quot;.  A plain old C switch statement with gcc -Wall will do this today, in fact.</div><br/></div></div></div></div><div id="40312350" class="c"><input type="checkbox" id="c-40312350" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40311729">parent</a><span>|</span><a href="#40312028">prev</a><span>|</span><a href="#40309478">next</a><span>|</span><label class="collapse" for="c-40312350">[-]</label><label class="expand" for="c-40312350">[2 more]</label></div><br/><div class="children"><div class="content">Pattern matching on the &quot;top level branch&quot; of the ADT, whatever you call it, is pretty darned useful.<p>Pattern matching on the next level down is a power tool to be used with care.<p>Having used some pattern matching languages for quite some time, I find anything much deeper than that is a code smell at best and pathological at worst. Pattern matching creates coupling proportional to the depth&#x2F;complexity&#x2F;precision of the pattern match. The top-level coupling is often unavoidable; if you&#x27;re pattern matching at all, you certainly care which &quot;branch&quot; you are on and there is likely no refactoring that away. But the danger rises rapidly the deeper in you go. It&#x27;s just so easy to pattern match on a third-level part of the complex object when you really ought to be wrapping that behind a function somewhere, possibly itself emitting a sum type value.<p>... but if all you really <i>need</i> is that &quot;top level&quot; match, a lot of pattern matching syntax and features are not really necessary (if not positively dangerous).</div><br/><div id="40312806" class="c"><input type="checkbox" id="c-40312806" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40312350">parent</a><span>|</span><a href="#40309478">next</a><span>|</span><label class="collapse" for="c-40312806">[-]</label><label class="expand" for="c-40312806">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Pattern matching on the &quot;top level branch&quot; of the ADT, whatever you call it, is pretty darned useful. Pattern matching on the next level down is a power tool to be used with care.<p>Which is <i>exactly</i> how Perl apologia arguments went.</div><br/></div></div></div></div></div></div></div></div><div id="40309478" class="c"><input type="checkbox" id="c-40309478" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309400">parent</a><span>|</span><a href="#40311293">prev</a><span>|</span><a href="#40309525">next</a><span>|</span><label class="collapse" for="c-40309478">[-]</label><label class="expand" for="c-40309478">[14 more]</label></div><br/><div class="children"><div class="content">This argument is the most common fallacy I see in programming language discussions. I might as well give it a name right here: &quot;Turing equivalence fallacy&quot; or perhaps &quot;syntax sugar fallacy.&quot;<p>All Turing Complete programming languages are Turing equivalent to one another. Programs written in one language can be mechanically transformed into those written in another. This is irrelevant to the discussion of programming languages. The whole point of creating different programming languages is to explore different ways to express the same program!</div><br/><div id="40309576" class="c"><input type="checkbox" id="c-40309576" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309478">parent</a><span>|</span><a href="#40310403">next</a><span>|</span><label class="collapse" for="c-40309576">[-]</label><label class="expand" for="c-40309576">[9 more]</label></div><br/><div class="children"><div class="content">In programming language design, we tend to distinguish between global and local analysis. While type checking and elaboration is an example of global analysis, desugaring is inherently local to some piece of code. Therefore, &quot;power&quot; or &quot;expressiveness&quot; usually mean that something cannot be syntactically &quot;expanded&quot;; e.g., while type classes elaborate into explicit dictionaries, they still require information from the type checker, and therefore considered a &quot;real&quot; feature of a programming language. On the other hand, nested pattern matching can be formulated as local syntax transformation, and therefore it doesn&#x27;t bring anything fundamentally new to the type system or dynamic semantics.<p>There&#x27;s also a great talk on the matter [1], if somebody is interested in formalities.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=43XaZEn2aLc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=43XaZEn2aLc</a></div><br/><div id="40310217" class="c"><input type="checkbox" id="c-40310217" checked=""/><div class="controls bullet"><span class="by">mitt_romney_12</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309576">parent</a><span>|</span><a href="#40310403">next</a><span>|</span><label class="collapse" for="c-40310217">[-]</label><label class="expand" for="c-40310217">[8 more]</label></div><br/><div class="children"><div class="content">You&#x27;re approaching this from a PL design standpoint where the distinction is important, but from a user perspective it doesn&#x27;t matter if it&#x27;s just &quot;syntax sugar&quot; or if it&#x27;s a super complicated to implement all that matters is whether the feature is available or not.</div><br/><div id="40310356" class="c"><input type="checkbox" id="c-40310356" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310217">parent</a><span>|</span><a href="#40310403">next</a><span>|</span><label class="collapse" for="c-40310356">[-]</label><label class="expand" for="c-40310356">[7 more]</label></div><br/><div class="children"><div class="content">Typing features affect the way we design APIs. Libraries written in languages with type classes and without them can have completely different designs. If nested pattern matching is not available, this will not affect the APIs, only the function bodies -- because desugaring is local by definition.</div><br/><div id="40310501" class="c"><input type="checkbox" id="c-40310501" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310356">parent</a><span>|</span><a href="#40310665">next</a><span>|</span><label class="collapse" for="c-40310501">[-]</label><label class="expand" for="c-40310501">[5 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t matter in practice. If two programming languages have the same underlying feature but one has syntactic sugar to make it very easy to use and the other does not (so is quite cumbersome to use) then you&#x27;ll find that the library ecosystem for the former language will see the feature in widespread use whereas the ecosystem of the latter will tend to shun the feature.<p>This is one of the social factors of programming language design and it&#x27;s one of the main reasons successful programming languages work so hard to establish a coherent philosophy and a set of best practices or idioms within the language. For similar reasons, I believe this is why &quot;anything goes&quot; languages such as LISP have struggled to gain widespread adoption: with no philosophy every programmer becomes an island unto themselves.</div><br/><div id="40316228" class="c"><input type="checkbox" id="c-40316228" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310501">parent</a><span>|</span><a href="#40316728">next</a><span>|</span><label class="collapse" for="c-40316228">[-]</label><label class="expand" for="c-40316228">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;anything goes&quot; languages such as LISP have struggled to gain widespread adoption: with no philosophy every programmer becomes an island unto themselves.<p>There are already two misconceptions.<p>First: &quot;Lisp has no programming philosophies&quot; and styles.<p>Not every program starts by zero. Since Lisp exists since the end 1950s, it has seen quite a lot in programming styles over the years and it may contain traces of several. Generally it may support more than one programming paradigm. For example during the Common Lisp standardization there was a wish to have a standardized object system. So instead of the multiple possible approaches (actors, message passing, prototype-based, ...), Common Lisp has just one: CLOS, the Common Lisp Object System. So, much of the object-oriented code written in CL is implemented in one particular object system: CLOS. Object Lisp, Flavors, LOOPs, Common Objects, and a bunch of other once had thus been replaced by one standard.<p>CLOS also defines a bunch of user-level macros: DEFCLASS, DEFMETHOD, DEFGENERIC, ... Everyone using CL &amp; CLOS will use those macros.<p>Second: &quot;every programmer becomes an island unto themselves&quot;. If we look at the way CLOS was designed: there was a core group of six people from three companies. Around that there was a mailing-list based communication with a large group of interested people. Early on a prototype was implemented as a portable implementation of CLOS. This was widely distributed among interested parties: implementors, companies, research groups, ... Then reports about the language extension and its layers were published, books were published, application &amp; library code was published.<p>One of famous books coming out of this effort: &quot;The Art of the Meta-Object Protocol&quot;. It contained also a toy implementation of CLOS in Common Lisp. Book and the implementation of CLOS (both the larger prototype and the toy implementation) showed in excellent quality how to write object-oriented Lisp code.<p><a href="https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262610742&#x2F;the-art-of-the-metaobject-protocol&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262610742&#x2F;the-art-of-the-metaob...</a><p>So, there are communities, which share code and coding styles. Not every programmer is alone and starts from zero.</div><br/></div></div><div id="40316728" class="c"><input type="checkbox" id="c-40316728" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310501">parent</a><span>|</span><a href="#40316228">prev</a><span>|</span><a href="#40310836">next</a><span>|</span><label class="collapse" for="c-40316728">[-]</label><label class="expand" for="c-40316728">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I believe this is why &quot;anything goes&quot; languages such as LISP<p>Why do you think that Lisp is an &quot;anything goes&quot; language? What&#x27;s your baseline? I think that C is no less an &quot;anything goes&quot; language, but with a much less pleasant UI.<p>&gt; with no philosophy every programmer becomes an island unto themselves<p>Some people actually think that Lispers tend to be <i>too</i> philosophical</div><br/></div></div><div id="40310836" class="c"><input type="checkbox" id="c-40310836" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310501">parent</a><span>|</span><a href="#40316728">prev</a><span>|</span><a href="#40310665">next</a><span>|</span><label class="collapse" for="c-40310836">[-]</label><label class="expand" for="c-40310836">[2 more]</label></div><br/><div class="children"><div class="content">Yes, features that are easy to use will be more often used, while inconvenient features will be less used. I don&#x27;t quite see any controversy with my comment.</div><br/><div id="40312727" class="c"><input type="checkbox" id="c-40312727" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310836">parent</a><span>|</span><a href="#40310665">next</a><span>|</span><label class="collapse" for="c-40312727">[-]</label><label class="expand" for="c-40312727">[1 more]</label></div><br/><div class="children"><div class="content">The point is that in both cases the underlying feature is present, so APIs will be compatible. However, the lack of syntactic sugar in the one case will make any API that uses the feature cumbersome to use in that language, so in practice it will be avoided.</div><br/></div></div></div></div></div></div><div id="40310665" class="c"><input type="checkbox" id="c-40310665" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310356">parent</a><span>|</span><a href="#40310501">prev</a><span>|</span><a href="#40310403">next</a><span>|</span><label class="collapse" for="c-40310665">[-]</label><label class="expand" for="c-40310665">[1 more]</label></div><br/><div class="children"><div class="content">Abstractly this is true, but software development is a human practice, so it matters not what&#x27;s technically possible but what people actually do.<p>That&#x27;s why the <i>most important</i> difference between C++ and Rust isn&#x27;t some technicality even though the technical differences are huge, it&#x27;s <i>cultural</i>. Rust has a Safety Culture and everything else is subservient to that difference.<p>Sugar matters, Rust&#x27;s familiar looking loops are just sugar, it only &quot;really&quot; has a single way to do loops, the loop construct, an infinite loop you can break out of. But despite that, people deliberately write the other loops - and the linter strongly recommends that they write them, because the programs aren&#x27;t just for machines to compile, they&#x27;re for other humans to read, and a while let loop is an intuitive thing to read for example, so is the traditional for-each style iterator loop.</div><br/></div></div></div></div></div></div></div></div><div id="40310403" class="c"><input type="checkbox" id="c-40310403" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309478">parent</a><span>|</span><a href="#40309576">prev</a><span>|</span><a href="#40310201">next</a><span>|</span><label class="collapse" for="c-40310403">[-]</label><label class="expand" for="c-40310403">[3 more]</label></div><br/><div class="children"><div class="content">Of course the syntax sugar is a good thing if it makes it easier to write the code, but if the question is about &quot;expressive power of the type system&quot;, it&#x27;s not really relevant: Zig&#x27;s type system can properly express a sum type. In addition: pattern matching is orthogonal to ADT, you can have pattern matching in both languages with and without algebraic types. Neither one implies the other.</div><br/><div id="40310587" class="c"><input type="checkbox" id="c-40310587" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310403">parent</a><span>|</span><a href="#40310201">next</a><span>|</span><label class="collapse" for="c-40310587">[-]</label><label class="expand" for="c-40310587">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Zig&#x27;s type system can properly express a sum type.<p>Surely any Turing complete PL can express a sum type? I can&#x27;t imagine a language that can support products but not sums.</div><br/><div id="40311127" class="c"><input type="checkbox" id="c-40311127" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310587">parent</a><span>|</span><a href="#40310201">next</a><span>|</span><label class="collapse" for="c-40311127">[-]</label><label class="expand" for="c-40311127">[1 more]</label></div><br/><div class="children"><div class="content">Turing completeness has nothing to do with static type checking. Dynamically typed PLs can&#x27;t express any type (except Any) yet are still Turing complete.</div><br/></div></div></div></div></div></div><div id="40310201" class="c"><input type="checkbox" id="c-40310201" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309478">parent</a><span>|</span><a href="#40310403">prev</a><span>|</span><a href="#40309525">next</a><span>|</span><label class="collapse" for="c-40310201">[-]</label><label class="expand" for="c-40310201">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Turing equivalence fallacy<p>Better known as the Turing Tar Pit.</div><br/></div></div></div></div><div id="40309525" class="c"><input type="checkbox" id="c-40309525" checked=""/><div class="controls bullet"><span class="by">xdavidliu</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309400">parent</a><span>|</span><a href="#40309478">prev</a><span>|</span><a href="#40311430">next</a><span>|</span><label class="collapse" for="c-40309525">[-]</label><label class="expand" for="c-40309525">[1 more]</label></div><br/><div class="children"><div class="content">syntax sugar IS power. also if the mechanical transformation is nontrivial, then so is the power of the sugar</div><br/></div></div><div id="40311430" class="c"><input type="checkbox" id="c-40311430" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309400">parent</a><span>|</span><a href="#40309525">prev</a><span>|</span><a href="#40308754">next</a><span>|</span><label class="collapse" for="c-40311430">[-]</label><label class="expand" for="c-40311430">[1 more]</label></div><br/><div class="children"><div class="content">I once explored the Epigram dependently typed programming language. It used to preclude many types of free form pattern matches, due to heavy dependence on structured editor (you speciy a type, it generates pattern matching, you cannot change the structure), so it was almost completely unuseable for many, many tasks.<p>So, while you are formally right, the need of shortcuts in pattern matching is undeniable to me.</div><br/></div></div></div></div></div></div><div id="40308754" class="c"><input type="checkbox" id="c-40308754" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40307807">parent</a><span>|</span><a href="#40309239">prev</a><span>|</span><a href="#40309251">next</a><span>|</span><label class="collapse" for="c-40308754">[-]</label><label class="expand" for="c-40308754">[15 more]</label></div><br/><div class="children"><div class="content">Also Typescript <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;everyday-types.html#union-types" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;everyday-type...</a></div><br/><div id="40308962" class="c"><input type="checkbox" id="c-40308962" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308754">parent</a><span>|</span><a href="#40309024">next</a><span>|</span><label class="collapse" for="c-40308962">[-]</label><label class="expand" for="c-40308962">[13 more]</label></div><br/><div class="children"><div class="content">Union types are not the same as sum types.</div><br/><div id="40309119" class="c"><input type="checkbox" id="c-40309119" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308962">parent</a><span>|</span><a href="#40309024">next</a><span>|</span><label class="collapse" for="c-40309119">[-]</label><label class="expand" for="c-40309119">[12 more]</label></div><br/><div class="children"><div class="content">TS narrows union types cases based on conditionals like &quot;if&quot; (called discriminated unions in the docs in the past), and supports exhaustiveness checks. How do they differ in functionality from sum types?</div><br/><div id="40310143" class="c"><input type="checkbox" id="c-40310143" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309119">parent</a><span>|</span><a href="#40309333">next</a><span>|</span><label class="collapse" for="c-40310143">[-]</label><label class="expand" for="c-40310143">[10 more]</label></div><br/><div class="children"><div class="content">Sum types are <i>disjoint</i> unions. This `T` has three cases<p><pre><code>     L = { tag: &quot;a&quot;, payload: string } | { tag: &quot;b&quot;, payload: number }
     R = { tag: &quot;b&quot;, payload: number } | { tag: &quot;c&quot;, payload: boolean }
     T = L | R  
</code></pre>
whereas a proper sum type `L + R` would have four.</div><br/><div id="40312147" class="c"><input type="checkbox" id="c-40312147" checked=""/><div class="controls bullet"><span class="by">akavi</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310143">parent</a><span>|</span><a href="#40310384">next</a><span>|</span><label class="collapse" for="c-40312147">[-]</label><label class="expand" for="c-40312147">[1 more]</label></div><br/><div class="children"><div class="content">As you&#x27;ve demonstrated, you can always <i>construct</i> sum types in typescript with the use of explicit discriminants:<p><pre><code>    T = {tag: &quot;L&quot;, payload: L} | {tag: &quot;R&quot;, payload: R}
</code></pre>
The real issue is typescript doesn&#x27;t have pattern-matching, which make operating on these sum types inelegant</div><br/></div></div><div id="40310384" class="c"><input type="checkbox" id="c-40310384" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310143">parent</a><span>|</span><a href="#40312147">prev</a><span>|</span><a href="#40309333">next</a><span>|</span><label class="collapse" for="c-40310384">[-]</label><label class="expand" for="c-40310384">[8 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that a completely useless distinction?<p>For all purposes and intents, the &quot;b&quot; type in L and R should be treated the same, no? What do you gain by not doing that??</div><br/><div id="40310612" class="c"><input type="checkbox" id="c-40310612" checked=""/><div class="controls bullet"><span class="by">hexane360</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310384">parent</a><span>|</span><a href="#40312137">next</a><span>|</span><label class="collapse" for="c-40310612">[-]</label><label class="expand" for="c-40310612">[5 more]</label></div><br/><div class="children"><div class="content">This often comes up when writing a function which returns a wrapper over a generic type (like Option&lt;T&gt;). If your Option type is T | null, then there&#x27;s no way to distinguish between a null returned by the function or a null that is part of T.<p>As a concrete example, consider a map with a method get(key: K) -&gt; Option&lt;V&gt;. How do you tell the difference between a missing key and a key which contains `null` as a value?</div><br/><div id="40312111" class="c"><input type="checkbox" id="c-40312111" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310612">parent</a><span>|</span><a href="#40311290">next</a><span>|</span><label class="collapse" for="c-40312111">[-]</label><label class="expand" for="c-40312111">[1 more]</label></div><br/><div class="children"><div class="content">`T | null` is equivalent to T. You can assign null to `T`&gt;<p>It&#x27;s like saying `string | &quot;foo&quot;` it is simply `string` due to subtyping.</div><br/></div></div><div id="40311290" class="c"><input type="checkbox" id="c-40311290" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310612">parent</a><span>|</span><a href="#40312111">prev</a><span>|</span><a href="#40312137">next</a><span>|</span><label class="collapse" for="c-40311290">[-]</label><label class="expand" for="c-40311290">[3 more]</label></div><br/><div class="children"><div class="content">This is trivial to model by making your type `T | null | Missing`.</div><br/><div id="40312078" class="c"><input type="checkbox" id="c-40312078" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40311290">parent</a><span>|</span><a href="#40312068">next</a><span>|</span><label class="collapse" for="c-40312078">[-]</label><label class="expand" for="c-40312078">[1 more]</label></div><br/><div class="children"><div class="content">Or just using Option since you would have Some&lt;null&gt; or None in that case.</div><br/></div></div><div id="40312068" class="c"><input type="checkbox" id="c-40312068" checked=""/><div class="controls bullet"><span class="by">efnx</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40311290">parent</a><span>|</span><a href="#40312078">prev</a><span>|</span><a href="#40312137">next</a><span>|</span><label class="collapse" for="c-40312068">[-]</label><label class="expand" for="c-40312068">[1 more]</label></div><br/><div class="children"><div class="content">Maybe trivial to “work around” but there is a difference, ay?<p>With this type you would have to check&#x2F;match an extra case!<p>The type you use there also takes more memory than Option&lt;T&gt; or Maybe&lt;T&gt;. So it has some other downsides.</div><br/></div></div></div></div></div></div><div id="40312137" class="c"><input type="checkbox" id="c-40312137" checked=""/><div class="controls bullet"><span class="by">Twisol</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310384">parent</a><span>|</span><a href="#40310612">prev</a><span>|</span><a href="#40309333">next</a><span>|</span><label class="collapse" for="c-40312137">[-]</label><label class="expand" for="c-40312137">[2 more]</label></div><br/><div class="children"><div class="content">No, it isn&#x27;t &quot;completely useless&quot;.<p>If you have a function that will normally return a string, but can sometimes fail due to reasons, you may wish to yield an error message in the latter case. So you&#x27;re going to be returning a string, or a string.<p>It&#x27;s not what the content of the data is; it&#x27;s how you&#x27;re supposed to interpret it. You have two cases, success and failure, and control will flow differently depending on <i>that</i>, not based strictly on the type of data at hand. We just model those cases in a type.</div><br/><div id="40315924" class="c"><input type="checkbox" id="c-40315924" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40312137">parent</a><span>|</span><a href="#40309333">next</a><span>|</span><label class="collapse" for="c-40315924">[-]</label><label class="expand" for="c-40315924">[1 more]</label></div><br/><div class="children"><div class="content">No disrespect, but that still sounds entirely useless to me. I would never model something as `String | String` as that makes zero sense. You should use a `Result` or `Either` type for that like everyone does.</div><br/></div></div></div></div></div></div></div></div><div id="40309333" class="c"><input type="checkbox" id="c-40309333" checked=""/><div class="controls bullet"><span class="by">mpawelski</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309119">parent</a><span>|</span><a href="#40310143">prev</a><span>|</span><a href="#40309024">next</a><span>|</span><label class="collapse" for="c-40309333">[-]</label><label class="expand" for="c-40309333">[1 more]</label></div><br/><div class="children"><div class="content">Supports exhaustiveness checks only if you explicitly opt-in it (by coding to pattern where you use helper function that accepts `never` type). &quot;Dicriminated Unions Type&quot;&#x2F;&quot;Sum Types&quot; feels very hacky there, at least syntax-wise, because it is constraint by being &quot;JS + types&quot; language. It&#x27;s remarkable what Typescript can do, but having native Discriminated Unions in JS (hence in TS too) would be much more ergonomic and powerful.</div><br/></div></div></div></div></div></div><div id="40309024" class="c"><input type="checkbox" id="c-40309024" checked=""/><div class="controls bullet"><span class="by">chem83</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308754">parent</a><span>|</span><a href="#40308962">prev</a><span>|</span><a href="#40309251">next</a><span>|</span><label class="collapse" for="c-40309024">[-]</label><label class="expand" for="c-40309024">[1 more]</label></div><br/><div class="children"><div class="content">F# too. And Elm. But I get your point.</div><br/></div></div></div></div></div></div><div id="40309251" class="c"><input type="checkbox" id="c-40309251" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40307807">prev</a><span>|</span><a href="#40308556">next</a><span>|</span><label class="collapse" for="c-40309251">[-]</label><label class="expand" for="c-40309251">[22 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; not having ADTs (except maybe Rust) built-in<p>Most of the common languages today have product types.<p>Java[1], Rust, Haskell, etc. have sum types.<p>I think it gets a bit more escoteric beyond that though - i don&#x27;t doubt that there&#x27;s probably some haskell extension for quotient types[2] or some other category theory high-jinx.<p>Most languages have ADTs built in.<p>[1] <a href="https:&#x2F;&#x2F;blogs.oracle.com&#x2F;javamagazine&#x2F;post&#x2F;inside-the-language-sealed-types" rel="nofollow">https:&#x2F;&#x2F;blogs.oracle.com&#x2F;javamagazine&#x2F;post&#x2F;inside-the-langua...</a>
[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Quotient_type" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Quotient_type</a></div><br/><div id="40309834" class="c"><input type="checkbox" id="c-40309834" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309251">parent</a><span>|</span><a href="#40310453">next</a><span>|</span><label class="collapse" for="c-40309834">[-]</label><label class="expand" for="c-40309834">[6 more]</label></div><br/><div class="children"><div class="content">Does Java sealed classes enable something like an exhaustive pattern matching? (A form of pattern matching that will fail at compile time if you add a new class that extends the sealed class)</div><br/><div id="40310296" class="c"><input type="checkbox" id="c-40310296" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309834">parent</a><span>|</span><a href="#40310348">next</a><span>|</span><label class="collapse" for="c-40310296">[-]</label><label class="expand" for="c-40310296">[2 more]</label></div><br/><div class="children"><div class="content">Yes, since Java 21.<p>Example:<p><pre><code>    sealed interface BinaryTree {
      record Leaf(int value) implements BinaryTree {}
      record Node(BinaryTree lhs,
                BinaryTree rhs,
                int value) implements BinaryTree {}
    }

    public class Hello {
      static int sum(BinaryTree tree) {
        return switch (tree) {
        case BinaryTree.Leaf(var value) -&gt; value;
        case BinaryTree.Node(var lhs, var rhs, var value) -&gt; sum(lhs) + value + sum(rhs);
        };
      }
    
      public static void main(String... args) {
        var tree = new BinaryTree.Node(
                                       new BinaryTree.Leaf(1),
                                       new BinaryTree.Node(
                                                           new BinaryTree.Leaf(2),
                                                           new BinaryTree.Leaf(3),
                                                           4),
                                       5);
        System.out.println(tree);
        System.out.println(&quot;Sum: &quot; + sum(tree));
      }
    }
</code></pre>
If you added a new subtype to BinaryTree you would need to fix the switch.<p>EDIT: I didn&#x27;t handle the `null` case above... so it would be a NullPointerException if someone passed null... apparently, Java decided to make handling `null` optional. More information: <a href="https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-lts-21-new-features" rel="nofollow">https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-lts-21-new-features</a></div><br/><div id="40310332" class="c"><input type="checkbox" id="c-40310332" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310296">parent</a><span>|</span><a href="#40310348">next</a><span>|</span><label class="collapse" for="c-40310332">[-]</label><label class="expand" for="c-40310332">[1 more]</label></div><br/><div class="children"><div class="content">Okay that&#x27;s better than I expected!</div><br/></div></div></div></div><div id="40310348" class="c"><input type="checkbox" id="c-40310348" checked=""/><div class="controls bullet"><span class="by">davidalayachew</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309834">parent</a><span>|</span><a href="#40310296">prev</a><span>|</span><a href="#40309914">next</a><span>|</span><label class="collapse" for="c-40310348">[-]</label><label class="expand" for="c-40310348">[1 more]</label></div><br/><div class="children"><div class="content">It absolutely does. Here is a (modified) snippet of my Java code from yesterday.<p><pre><code>    final boolean hasUncollectedSecret =
       switch (each)
       {
               
          case Wall()    -&gt; false;
          case Goal()    -&gt; false;
          case Player p  -&gt; false;
          case BasicCell(Underneath(_, var collectible), _)
             -&gt;
                switch (collectible)
                {
                        
                   case NONE, KEY -&gt; false;
                   case SECRET -&gt; true;
                        
                };
          case Lock()    -&gt; false;
               
       };</code></pre></div><br/></div></div><div id="40309914" class="c"><input type="checkbox" id="c-40309914" checked=""/><div class="controls bullet"><span class="by">thewakalix</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309834">parent</a><span>|</span><a href="#40310348">prev</a><span>|</span><a href="#40310453">next</a><span>|</span><label class="collapse" for="c-40309914">[-]</label><label class="expand" for="c-40309914">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The intent is to introduce a more-advanced construction called pattern matching in a later release.</div><br/><div id="40310337" class="c"><input type="checkbox" id="c-40310337" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309914">parent</a><span>|</span><a href="#40310453">next</a><span>|</span><label class="collapse" for="c-40310337">[-]</label><label class="expand" for="c-40310337">[1 more]</label></div><br/><div class="children"><div class="content">You read that in a blog post from 2019.<p>Java has had comprehensive pattern matching since Java 21, like one year ago (current Java version is 22).<p>I posted an answer to the same parent comment with the C example written in Java...<p>You can read more about it here: <a href="https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-lts-21-new-features" rel="nofollow">https:&#x2F;&#x2F;www.baeldung.com&#x2F;java-lts-21-new-features</a></div><br/></div></div></div></div></div></div><div id="40310453" class="c"><input type="checkbox" id="c-40310453" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309251">parent</a><span>|</span><a href="#40309834">prev</a><span>|</span><a href="#40310147">next</a><span>|</span><label class="collapse" for="c-40310453">[-]</label><label class="expand" for="c-40310453">[1 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t forget Dart!<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;dartlang&#x2F;dart-3-1-a-retrospective-on-functional-style-programming-in-dart-3-a1f4b3a7cdda" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;dartlang&#x2F;dart-3-1-a-retrospective-on-func...</a></div><br/></div></div><div id="40310147" class="c"><input type="checkbox" id="c-40310147" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309251">parent</a><span>|</span><a href="#40310453">prev</a><span>|</span><a href="#40309921">next</a><span>|</span><label class="collapse" for="c-40310147">[-]</label><label class="expand" for="c-40310147">[7 more]</label></div><br/><div class="children"><div class="content">Java&#x27;s sealed classes are still somewhat more limited than Rust&#x27;s or Haskell&#x27;s sum types, in that each instance of the superclass holds a fixed variant (i.e., subclass), so you can&#x27;t change the variant without creating a new instance. Clearly, this limitation is necessary for references to stay intact, but I&#x27;ve personally ran into this issue when trying to represent a sum type in an ORM.</div><br/><div id="40310338" class="c"><input type="checkbox" id="c-40310338" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310147">parent</a><span>|</span><a href="#40310505">next</a><span>|</span><label class="collapse" for="c-40310338">[-]</label><label class="expand" for="c-40310338">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; so you can&#x27;t change the variant without creating a new instance. </i><p>Isn&#x27;t that true of ADTs in all languages? I can&#x27;t think of a single language with ADTs that lets you change the tag&#x2F;variant of an existing value.</div><br/><div id="40311285" class="c"><input type="checkbox" id="c-40311285" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310338">parent</a><span>|</span><a href="#40310505">next</a><span>|</span><label class="collapse" for="c-40311285">[-]</label><label class="expand" for="c-40311285">[3 more]</label></div><br/><div class="children"><div class="content">In Rust [0]:<p><pre><code>  #[derive(Debug)]
  pub enum Example {
      Foo(i32),
      Bar(&amp;&#x27;static str),
  }

  let mut ex: Example = Example::Foo(42);
  println!(&quot;{ex:?}&quot;); &#x2F;&#x2F; Foo(42)

  let ex_ref: &amp;mut Example = &amp;mut ex;
  *ex_ref = Example::Bar(&quot;hello&quot;);

  println!(&quot;{ex:?}&quot;); &#x2F;&#x2F; Bar(&quot;hello&quot;)
</code></pre>
Given a mutable reference to a value of enum type, you can replace it with another variant. Or you can swap it out with any other value of the same type, even if the variants are different. This is most commonly used for Option&lt;T&gt;, where you can insert or remove the contained value as long as you have a reference.<p>The limitation here is that for as long as the mutable reference is live, no other code can access the value. So when you do change the variant, you can&#x27;t have any other references sitting around that point to the removed subfields.<p>[0] <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0371824536f6b9050f96379ddb966c7c" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a></div><br/><div id="40312840" class="c"><input type="checkbox" id="c-40312840" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40311285">parent</a><span>|</span><a href="#40310505">next</a><span>|</span><label class="collapse" for="c-40312840">[-]</label><label class="expand" for="c-40312840">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t have anything to do with ADTs. It&#x27;s because Rust has both in-place variables and references. You aren&#x27;t changing the variant of an existing ADT, you&#x27;re replacing the entire ADT value with a new one. That replacement is visible in multiple places because the language allows you to take references to variables (the `&amp;mut ex` expression).<p>You can accomplish the same thing in C and C++ because they also have in-place value semantics and allow you to take the address of any variable. You can&#x27;t do that in Java only because Java doesn&#x27;t let you take references to variables.</div><br/><div id="40313959" class="c"><input type="checkbox" id="c-40313959" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40312840">parent</a><span>|</span><a href="#40310505">next</a><span>|</span><label class="collapse" for="c-40313959">[-]</label><label class="expand" for="c-40313959">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You aren&#x27;t changing the variant of an existing ADT, you&#x27;re replacing the entire ADT value with a new one.<p>&#x27;Values&#x27; in Rust have no identity, except for their address. They&#x27;re just a bunch of bytes in a row. What could it mean for a value to exist, except for it to be present at a set place in memory? If I have an instance of a Java class, and I change all the fields, I&#x27;d hardly say the instance has been replaced with a new instance.<p>If you insist, I&#x27;d say &quot;Java&#x27;s sealed classes are more limited in that when you have a bunch of references to the same thing, you can change the values in the fields of that thing (and have it be reflected in other references), but you can&#x27;t change which variant it is.&quot; Call that thing a &#x27;value&#x27; or a &#x27;variable&#x27;, it doesn&#x27;t change the visible outcome compared to enums in Rust, or discriminated unions in C&#x2F;C++.</div><br/></div></div></div></div></div></div></div></div><div id="40310505" class="c"><input type="checkbox" id="c-40310505" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310147">parent</a><span>|</span><a href="#40310338">prev</a><span>|</span><a href="#40309921">next</a><span>|</span><label class="collapse" for="c-40310505">[-]</label><label class="expand" for="c-40310505">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really think it&#x27;s useful to do that though?? Can you give an example?<p>By the way, I would claim Java&#x27;s sum types are less limited than Rust because in Rust, variants don&#x27;t have their own type. The consequence is that you can&#x27;t have functions that only accept some variant, as far as I know (I remember having this problem once),  or add &quot;methods&quot; only to one variant... while in Java, because variants are just normal types, you can do both, and doing that is pretty damn useful.</div><br/><div id="40311404" class="c"><input type="checkbox" id="c-40311404" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310505">parent</a><span>|</span><a href="#40309921">next</a><span>|</span><label class="collapse" for="c-40311404">[-]</label><label class="expand" for="c-40311404">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t really think it&#x27;s useful to do that though?? Can you give an example?<p>For an exercise, I had to write a system with Admins and Customers, with the ability to upgrade a Customer into an Admin, or vice versa.<p>My thought was to put them as two subclasses under a User superclass, so that I could put them under a single Users table, and not have to link and unlink things over the conversion. Hibernate ORM supports storing subclasses by adding an implicit discriminator field.<p>However, its object model specifies that a single row always corresponds to a particular instance, so it has no support for changing the subclass of a row. Ultimately, I ended up with a hacky solution of creating a new record with the primary key copied over.<p>&gt; By the way, I would claim Java&#x27;s sum types are less limited than Rust because in Rust, variants don&#x27;t have their own type. The consequence is that you can&#x27;t have functions that only accept some variant, as far as I know (I remember having this problem once), or add &quot;methods&quot; only to one variant... while in Java, because variants are just normal types, you can do both, and doing that is pretty damn useful.<p>At least in Rust, you can simulate this pretty trivially by having each variant store a struct value with all the data and methods you want. See proc_macro::TokenTree [0] for an example of this. Of course, it&#x27;s not ideal in how verbose it is (though not much worse than Java!), but it can be workable on the consumer&#x27;s side if you add some extra From impls.<p>[0] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;proc_macro&#x2F;enum.TokenTree.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;proc_macro&#x2F;enum.TokenTree.html</a></div><br/></div></div></div></div></div></div><div id="40309921" class="c"><input type="checkbox" id="c-40309921" checked=""/><div class="controls bullet"><span class="by">thewakalix</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309251">parent</a><span>|</span><a href="#40310147">prev</a><span>|</span><a href="#40309488">next</a><span>|</span><label class="collapse" for="c-40309921">[-]</label><label class="expand" for="c-40309921">[1 more]</label></div><br/><div class="children"><div class="content">Java doesn&#x27;t have pattern-matching yet. Haskell is not an imperative language.</div><br/></div></div><div id="40309488" class="c"><input type="checkbox" id="c-40309488" checked=""/><div class="controls bullet"><span class="by">speed_spread</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309251">parent</a><span>|</span><a href="#40309921">prev</a><span>|</span><a href="#40310000">next</a><span>|</span><label class="collapse" for="c-40309488">[-]</label><label class="expand" for="c-40309488">[2 more]</label></div><br/><div class="children"><div class="content">Java sum types work but still need a bit of syntax sugar on the declaration side, IMHO.</div><br/></div></div><div id="40310000" class="c"><input type="checkbox" id="c-40310000" checked=""/><div class="controls bullet"><span class="by">j2kun</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309251">parent</a><span>|</span><a href="#40309488">prev</a><span>|</span><a href="#40308556">next</a><span>|</span><label class="collapse" for="c-40310000">[-]</label><label class="expand" for="c-40310000">[4 more]</label></div><br/><div class="children"><div class="content">Your examples, on the TIOBE index, are #4, #18, and #28. <a href="https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;</a></div><br/><div id="40313131" class="c"><input type="checkbox" id="c-40313131" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310000">parent</a><span>|</span><a href="#40308556">next</a><span>|</span><label class="collapse" for="c-40313131">[-]</label><label class="expand" for="c-40313131">[3 more]</label></div><br/><div class="children"><div class="content">Product types are one kind of algebraic data type, only 5 languages from that TIOBE page don’t have them so most common langs have ADTs</div><br/><div id="40313483" class="c"><input type="checkbox" id="c-40313483" checked=""/><div class="controls bullet"><span class="by">dannymi</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40313131">parent</a><span>|</span><a href="#40308556">next</a><span>|</span><label class="collapse" for="c-40313483">[-]</label><label class="expand" for="c-40313483">[2 more]</label></div><br/><div class="children"><div class="content">When you have natural numbers and a multiplication operation (product) would you say that those form an algebra? (ADT means algebraic data type)</div><br/><div id="40316050" class="c"><input type="checkbox" id="c-40316050" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40313483">parent</a><span>|</span><a href="#40308556">next</a><span>|</span><label class="collapse" for="c-40316050">[-]</label><label class="expand" for="c-40316050">[1 more]</label></div><br/><div class="children"><div class="content">You’ve got both a carrier (the set of natural numbers) and a morphism (product operation) so yeah you have an algebra.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40308556" class="c"><input type="checkbox" id="c-40308556" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40309251">prev</a><span>|</span><a href="#40308193">next</a><span>|</span><label class="collapse" for="c-40308556">[-]</label><label class="expand" for="c-40308556">[1 more]</label></div><br/><div class="children"><div class="content">NAND is a universal circuit primitive because it can be used to create all of the other circuit primitives.  But if you think about it, this is more of an argument of manufacturing than it is in comprehensibility.  Only needing to manufacture NAND is easy, but if you could only create your circuit this way, then you would have an unmaintainable mess.<p>You can do the same thing with boolean logic and just have not-and, but thankfully we have and, or, not, xor.  Similarly, you don&#x27;t need greater-than-or-equal because you can just write &#x27;x &gt; y || x == y&#x27;.<p>Comprehension is linked to how closely you can express the idea of what you&#x27;re doing in the object language that you have to look at.  It might be convenient to compile everything down to SK combinators so that your optimizer and evaluator can be simpler, but people should never look at that level (at least not until you suspect a compiler defect).<p>So we get to object oriented programming.  Where our data expression has an AND property (a class has an INT field AND a STRING field), an existential property (interfaces:  there exists some object with these methods), and inheritance (a truly bizarre feature where we duck tape subtyping to a method and field grouping mechanism with a bunch of hooks).<p>With interfaces and inheritance you can simulate both a universal property (generic) and an OR property.  But because it&#x27;s not a direct expression, we leave this giant gap for what people intended to happen to diverge from what actually happens.  Especially after time passes, defects are found, and requirements change.  [For example, when using interfaces to simulate an OR property, there really isn&#x27;t any mechanism to let everyone know that this construct is closed.  So if something erroneously gets added, you won&#x27;t know to check the entire code base.  And if requirement change and you need to add a new case, then you have to check the entire code base.  Completeness checking of ADTs give you this for free in your pattern matches.]<p>Too many non-trivial architectural messes that I&#x27;ve encountered in my career have been due to either someone trying to solve all of their problems with interfaces or the same with inheritance* when a simple OR data structure would have made everything simple, clear, and correct.<p>[*] - Inheritance being more problematic when someone tries to create a non-trivially sized category hierarchy, which ruins the day when requirements change and suddenly the tree needs to be reorganized but doing so would invalidate entire swaths of the code base already accepting types with a different assumed (and undocumented) hierarchal tree structure.  Thankfully most people have gotten the memo and switched to interfaces.</div><br/></div></div><div id="40308193" class="c"><input type="checkbox" id="c-40308193" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40308556">prev</a><span>|</span><a href="#40311298">next</a><span>|</span><label class="collapse" for="c-40308193">[-]</label><label class="expand" for="c-40308193">[7 more]</label></div><br/><div class="children"><div class="content">ADT feels like an unfortunately acronym-collision with &quot;Abstract data types.&quot;</div><br/><div id="40315986" class="c"><input type="checkbox" id="c-40315986" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308193">parent</a><span>|</span><a href="#40308644">next</a><span>|</span><label class="collapse" for="c-40315986">[-]</label><label class="expand" for="c-40315986">[1 more]</label></div><br/><div class="children"><div class="content">ADT feels like an unfortunately acronym-collision with &quot;algebraic data types.&quot;<p>They were both introduced in the same decade.</div><br/></div></div><div id="40308644" class="c"><input type="checkbox" id="c-40308644" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308193">parent</a><span>|</span><a href="#40315986">prev</a><span>|</span><a href="#40308217">next</a><span>|</span><label class="collapse" for="c-40308644">[-]</label><label class="expand" for="c-40308644">[2 more]</label></div><br/><div class="children"><div class="content">More often than not, when I say ADT to someone outside of the FP world, they assume I mean abstract data type.</div><br/><div id="40309068" class="c"><input type="checkbox" id="c-40309068" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308644">parent</a><span>|</span><a href="#40308217">next</a><span>|</span><label class="collapse" for="c-40309068">[-]</label><label class="expand" for="c-40309068">[1 more]</label></div><br/><div class="children"><div class="content">Or the company that sells the security stickers, for houses.</div><br/></div></div></div></div><div id="40308217" class="c"><input type="checkbox" id="c-40308217" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308193">parent</a><span>|</span><a href="#40308644">prev</a><span>|</span><a href="#40311298">next</a><span>|</span><label class="collapse" for="c-40308217">[-]</label><label class="expand" for="c-40308217">[3 more]</label></div><br/><div class="children"><div class="content">Yep, people that eventually buy a Modula-2 ADT book, when hunting old stuff, are in for a surprise. :)</div><br/><div id="40308379" class="c"><input type="checkbox" id="c-40308379" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308217">parent</a><span>|</span><a href="#40311298">next</a><span>|</span><label class="collapse" for="c-40308379">[-]</label><label class="expand" for="c-40308379">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a term that is commonly used in computer science education to refer to any data type independent of its concrete implementation (so, basically, its interface.) I don&#x27;t think it&#x27;s just restricted to Modula-2?</div><br/><div id="40308407" class="c"><input type="checkbox" id="c-40308407" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308379">parent</a><span>|</span><a href="#40311298">next</a><span>|</span><label class="collapse" for="c-40308407">[-]</label><label class="expand" for="c-40308407">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, however CLU and Modula-2 were the ones used mostly for practical teaching purposes, until ML became widespread enough for ADT to gain yet another meaning.</div><br/></div></div></div></div></div></div></div></div><div id="40311298" class="c"><input type="checkbox" id="c-40311298" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40308193">prev</a><span>|</span><a href="#40307897">next</a><span>|</span><label class="collapse" for="c-40311298">[-]</label><label class="expand" for="c-40311298">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Haskell is the best imperative language,&quot; (C) various software engineers.<p>Also, algebraic data types can be seen as hierarchy consisting of abstract base class and several final children classes. So it is an inheritance model, just restricted one.</div><br/></div></div><div id="40307897" class="c"><input type="checkbox" id="c-40307897" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40311298">prev</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40307897">[-]</label><label class="expand" for="c-40307897">[9 more]</label></div><br/><div class="children"><div class="content">Yeah, when I first learned Haskell a million years ago, and Erlang slightly less than a million years ago, the pattern matching was so plainly obviously the &quot;correct&quot; way to do things; it just felt like it was exactly how I thought about problems, and all the constructs with if&#x2F;switch&#x2F;enums had been an attempt to force my brain thinking into something that executes.<p>It honestly does annoy me that a lot of mainstream languages still haven&#x27;t really adopted ADTs; when Java 8 added a lot of (well-needed) new syntax, it felt like that was an ideal opportunity to add ADTs and pattern matching (though I&#x27;m sure that was easier said than done).</div><br/><div id="40308201" class="c"><input type="checkbox" id="c-40308201" checked=""/><div class="controls bullet"><span class="by">kaashif</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40307897">parent</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40308201">[-]</label><label class="expand" for="c-40308201">[8 more]</label></div><br/><div class="children"><div class="content">&gt; when Java 8 added a lot of (well-needed) new syntax, it felt like that was an ideal opportunity to add ADTs and pattern matching<p>Well at least Java does now (as of Java 21) have pattern matching (including nested record destructuring) and sealed classes, which let you have decent sum types.<p>The one issue is that everything is nullable, but that&#x27;s a wider Java issue.</div><br/><div id="40308401" class="c"><input type="checkbox" id="c-40308401" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308201">parent</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40308401">[-]</label><label class="expand" for="c-40308401">[7 more]</label></div><br/><div class="children"><div class="content">Yeah, but the annoying part of Java is that people stick with old versions for a long time.  Java 21 looks pretty great but most companies are still using Java 17, or even Java 11 still.</div><br/><div id="40309274" class="c"><input type="checkbox" id="c-40309274" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308401">parent</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40309274">[-]</label><label class="expand" for="c-40309274">[6 more]</label></div><br/><div class="children"><div class="content">Some have even older Java versions in &#x27;prod&#x27;. 6 is still alive in some places out there, because management refuses to pay for either upgrade, replacement or dismantling.<p>I have a mid-sized application I built on 17 that&#x27;s used to deliver a particular project, really looking forward to finish the project so I get to move to 21 and refactor it with these new features and make it more general.</div><br/><div id="40309846" class="c"><input type="checkbox" id="c-40309846" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309274">parent</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40309846">[-]</label><label class="expand" for="c-40309846">[5 more]</label></div><br/><div class="children"><div class="content">Oof, I didn&#x27;t know that anyone still used Java 6 anywhere.  I have to think that it&#x27;s a potential security nightmare at this point isn&#x27;t it?</div><br/><div id="40311207" class="c"><input type="checkbox" id="c-40311207" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309846">parent</a><span>|</span><a href="#40312421">next</a><span>|</span><label class="collapse" for="c-40311207">[-]</label><label class="expand" for="c-40311207">[1 more]</label></div><br/><div class="children"><div class="content">It is. We run an old version of our application on Java 6. Apparently multiple people have tried to upgrade it in the past but it proved too difficult because it&#x27;s using a bunch of completely obsolete technology with little available documentation that seems to randomly break when you upgrade even minor things.<p>The plan has been to gradually replace it with the new version of the software (which runs on Java 17), unfortunately this plan has been ongoing for 10 years and it&#x27;s not gonna be done anytime soon.<p>Such are the sad realities of working on legacy code sometimes.</div><br/></div></div><div id="40312421" class="c"><input type="checkbox" id="c-40312421" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309846">parent</a><span>|</span><a href="#40311207">prev</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40312421">[-]</label><label class="expand" for="c-40312421">[3 more]</label></div><br/><div class="children"><div class="content">Absolutely, so you try to seal it in hermetically, only talk to it over a special message bus or something.<p>Sometimes the upgrade path from 6 onwards isn&#x27;t as nice as it usually is from 8 up, especially if you built with some old undead libraries that require an heroic effort to understand well enough to reimplement. Takes a very special organisation to divert some person-years to pull it off, and as some middle or other manager it&#x27;s highly unlikely to catch you a new, better job even if it goes well.</div><br/><div id="40312675" class="c"><input type="checkbox" id="c-40312675" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40312421">parent</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40312675">[-]</label><label class="expand" for="c-40312675">[2 more]</label></div><br/><div class="children"><div class="content">It makes me sad, but I totally understand <i>why</i> someone would stay with Java 6, for the same reason that there&#x27;s still COBOL stuff hanging around: the stuff &quot;works&quot; as is, upgrading is expensive, and some business person decided that the cost of the upgrade isn&#x27;t worth it for the value they&#x27;d receive.<p>I do worry that there&#x27;s &quot;Y2K-esque&quot; bugs hiding in Java 6 programs somewhere. I don&#x27;t think java.util.date uses 32 bit integers for time so the 2038 problem probably won&#x27;t be an issue, but I do wonder if there&#x27;s other stuff hiding.</div><br/><div id="40312856" class="c"><input type="checkbox" id="c-40312856" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40312675">parent</a><span>|</span><a href="#40308716">next</a><span>|</span><label class="collapse" for="c-40312856">[-]</label><label class="expand" for="c-40312856">[1 more]</label></div><br/><div class="children"><div class="content">There might be some limit or bug like that in Java 6, but I think time stuff has been backported, so it&#x27;d likely be something else. I don&#x27;t know enough about the JVM internals to speculate on whether the old ones were simpler and less likely to be defective, or not.<p>By now most types of issues ought to have popped up though, since it was so widely used for such a long time.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40308716" class="c"><input type="checkbox" id="c-40308716" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40307897">prev</a><span>|</span><a href="#40311088">next</a><span>|</span><label class="collapse" for="c-40308716">[-]</label><label class="expand" for="c-40308716">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious on supporting evidence for it being a basic mental model of how humans think?  That sounds like a fairly strong claim.</div><br/><div id="40309146" class="c"><input type="checkbox" id="c-40309146" checked=""/><div class="controls bullet"><span class="by">Verdex</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308716">parent</a><span>|</span><a href="#40309477">next</a><span>|</span><label class="collapse" for="c-40309146">[-]</label><label class="expand" for="c-40309146">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a huge proponent of ADTs being a more comprehensible way to write code than some of the alternatives.  But I do have to agree with you that there isn&#x27;t really evidence that this is a basic mental model.<p>However<p>What we do see is a bunch of mathematical disciplines that end up creating properties like:  AND, OR, Universal, Existential, Implication, (and a few others).  They end up in places like:  set theory, type theory, category theory, various logics, lattice theory, etc.<p>Now, maybe they&#x27;re only copying one another and this is more of a memetic phenomena.  Or maybe they&#x27;ve hit upon something that&#x27;s important for human comprehensibility.<p>That would be the &#x27;evidence&#x27; of the positive effect of ADTs (scare quotes because it might just be math memes and not fundamental).  But we can also think about what I feel is legit evidence for the negative effect of lacking ADTs.<p>Consider what happens if instead of having the standard boolean logic operators and, or, not, xor, we only have the universal not-and operator.  Now a straightforward statement like:  A &amp;&amp; B || C becomes (((A !&amp; B) !&amp; (A !&amp; B)) !&amp; ((A !&amp; B) !&amp; (A !&amp; B))) !&amp; (B !&amp; B) [I think...].  It&#x27;s more complicated to tell what&#x27;s actually supposed to be going on AND the &#x27;&amp;&amp;&#x27; simulation can get intertwined with the &#x27;||&#x27; simulation.  The result being that requirements changes or defect fixes end up modifying the object level expression in a way where there is no longer any mapping back to standard boolean logic.  Comprehensibility approaches zero.<p>And we&#x27;ve seen this happen with interfaces and inheritance being used to implement what would otherwise be a relatively simple OR property (with the added benefit that pattern matching ADTs often comes with totality checking; not something you can do with interfaces which can always have another instance even up to and including objects loaded at runtime).</div><br/><div id="40310079" class="c"><input type="checkbox" id="c-40310079" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309146">parent</a><span>|</span><a href="#40309477">next</a><span>|</span><label class="collapse" for="c-40310079">[-]</label><label class="expand" for="c-40310079">[2 more]</label></div><br/><div class="children"><div class="content">Appearing in symbolic reasoning tools we have invented doesn&#x27;t really support them being how brains work, though?  This is akin to saying that gears are how nature works because gears are everywhere in how we build things.  I could maybe buy that with &quot;friction&quot; being a fundamental thing, but feels like a stretch for the other.<p>Now, I should add that I did not mean my question to be a criticism of them!  I&#x27;m genuinely curious on evidence that they are a basic building block.  Feels save to say they are a good building block, and those aren&#x27;t the same thing.<p>As an easy example for them not being basic building blocks, I can&#x27;t remember ever seeing anything like them in any assembly instructions for things.  Put together a batting net for the kids.  Lots of instructions, but nothing algebraic, in this sense.  Looking at recipes for food.  Nothing algebraic, really?  Maybe I can squint and see some, but it would be hard.  Exercise plans?  Music lessons?  Playbooks for a sport?<p>Again, though, I &#x2F;do not&#x2F; intend this as a criticism of them.  Genuinely curious on any investigation into them.</div><br/><div id="40312095" class="c"><input type="checkbox" id="c-40312095" checked=""/><div class="controls bullet"><span class="by">humzashahid98</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310079">parent</a><span>|</span><a href="#40309477">next</a><span>|</span><label class="collapse" for="c-40312095">[-]</label><label class="expand" for="c-40312095">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re right to point out that it&#x27;s too strong a claim to say that sum types are a basic building block of thought, although I believe they are very useful in coding regardless of that claim.<p>There is the still the ongoing debate about how much human perception and human reason are shaped by cultural forces vs. universal forces (where the latter asserts humans reason in the same&#x2F;similar ways).<p>There&#x27;s evidence that certain optical illusions don&#x27;t work across cultures for example (I seem to remember those in Western countries have a tendency to mentally group things in rectangular boxes). The exact balance between cultural and universal forces isn&#x27;t known and I doubt we could say anything about sum types in that regard.</div><br/></div></div></div></div></div></div><div id="40309477" class="c"><input type="checkbox" id="c-40309477" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308716">parent</a><span>|</span><a href="#40309146">prev</a><span>|</span><a href="#40311088">next</a><span>|</span><label class="collapse" for="c-40309477">[-]</label><label class="expand" for="c-40309477">[9 more]</label></div><br/><div class="children"><div class="content">Verdex&#x27;s explanation is detailed but too long IMO. The short version is that ADTs&#x2F;sum types formally correspond to the OR-logical connective, and records&#x2F;product types formally correspond to AND-logical connective. I think you&#x27;d be hard-pressed to argue that people don&#x27;t think in terms of &quot;X AND Y OR Z&quot;. These are core primitives of any kind of reasoning.</div><br/><div id="40310146" class="c"><input type="checkbox" id="c-40310146" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309477">parent</a><span>|</span><a href="#40311088">next</a><span>|</span><label class="collapse" for="c-40310146">[-]</label><label class="expand" for="c-40310146">[8 more]</label></div><br/><div class="children"><div class="content">I can easily argue that people don&#x27;t think in terms of boolean logic.  For one, the evidence seems as strong that people generally think backwards from the answer far more than they do forwards from the ingredients.  This is often why new things are so long to be discovered.  It isn&#x27;t that people couldn&#x27;t have gotten there, but they didn&#x27;t know to go for it.<p>For two, addition is a wildly disparate thing everywhere we use it.  We like to joke that computers made that hard, but literally half of intro chemistry is learning how to get thing to add together in a meaningful way, no?  Balancing a chemical equation is a thing.</div><br/><div id="40310219" class="c"><input type="checkbox" id="c-40310219" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310146">parent</a><span>|</span><a href="#40311088">next</a><span>|</span><label class="collapse" for="c-40310219">[-]</label><label class="expand" for="c-40310219">[7 more]</label></div><br/><div class="children"><div class="content">&gt; For one, the evidence seems as strong that people generally think backwards from the answer far more than they do forwards from the ingredients.<p>Logic doesn&#x27;t really have a direction, it works backwards or forwards. Even if you&#x27;re solving a system &quot;backwards&quot;, whatever that means, you still have to satisfy all of the necessary AND and OR constraints for a solution to be valid, so you&#x27;re effectively still building ADTs or records just using a different evaluation order.</div><br/><div id="40312588" class="c"><input type="checkbox" id="c-40312588" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310219">parent</a><span>|</span><a href="#40314200">next</a><span>|</span><label class="collapse" for="c-40312588">[-]</label><label class="expand" for="c-40312588">[4 more]</label></div><br/><div class="children"><div class="content">And this logic is how folks convince themselves that ball players are doing trigonometry when playing. It is just wrong.<p>You can &#x2F;model&#x2F; it that way.  But you are making a symbolic model to justify how a solution is reached.<p>Now, it can be frustrating to consider that this model could produce an agent that is better at the ball game than the players. But it is silly to think that means you have mirrored them.</div><br/><div id="40314066" class="c"><input type="checkbox" id="c-40314066" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40312588">parent</a><span>|</span><a href="#40314200">next</a><span>|</span><label class="collapse" for="c-40314066">[-]</label><label class="expand" for="c-40314066">[3 more]</label></div><br/><div class="children"><div class="content">&gt; And this logic is how folks convince themselves that ball players are doing trigonometry when playing. It is just wrong.<p>You&#x27;re attempting a sleight of hand here by saying &quot;they&#x27;re&quot; not &quot;doing trig&quot;. Clearly <i>they</i> are not doing anything like that <i>consciously</i>, but equally clearly <i>some part of their brain is</i> triangulating objects and predicting trajectories based on gradients, meaning <i>that</i> part is &quot;doing trig and calculus&quot; <i>subconsciously</i>. What else does it mean to &quot;do something&quot; if not &quot;process X is isomorphic to process Y&quot;?<p>&gt; You can &#x2F;model&#x2F; it that way. But you are making a symbolic model to justify how a solution is reached.<p>I really don&#x27;t understand what you think people are doing when they&#x27;re compiling a grocery list. They&#x27;re clearly thinking, &quot;I need x AND y OR I can substitute z&quot;.<p>Or if they&#x27;re planning to paint their fence, they&#x27;re thinking, &quot;I need paint AND brushes AND I have to start before lunch OR I won&#x27;t finish before dinner&quot;.</div><br/><div id="40314862" class="c"><input type="checkbox" id="c-40314862" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40314066">parent</a><span>|</span><a href="#40314200">next</a><span>|</span><label class="collapse" for="c-40314862">[-]</label><label class="expand" for="c-40314862">[2 more]</label></div><br/><div class="children"><div class="content">No.  You are confusing the model for the reality.  Again, our model may lead to a more impressive reality, but ball players are not doing trig. They are almost certainly simulating things, but that does not require trig.  Indeed, it only loosely requires math.  Models can be very informal with loose approximations.<p>You seem to think I have to prove your model false to show others don&#x27;t do that.  But I am specifically not claiming your model is false.  I&#x27;m saying folks don&#x27;t think that way, necessarily.  For example, many build lists for shopping that they were taught.  Not that they reasoned.</div><br/><div id="40315503" class="c"><input type="checkbox" id="c-40315503" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40314862">parent</a><span>|</span><a href="#40314200">next</a><span>|</span><label class="collapse" for="c-40315503">[-]</label><label class="expand" for="c-40315503">[1 more]</label></div><br/><div class="children"><div class="content">The ability to build lists requires reasoning. It requires enumeration, inclusion&#x2F;exclusion conditions, and stop conditions, which necessarily requires logic. This argument is pointless, you go on believing that some people can&#x27;t use basic logical connectives, I&#x27;m sure next you&#x27;ll say they can&#x27;t even count.</div><br/></div></div></div></div></div></div></div></div><div id="40314200" class="c"><input type="checkbox" id="c-40314200" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310219">parent</a><span>|</span><a href="#40312588">prev</a><span>|</span><a href="#40311088">next</a><span>|</span><label class="collapse" for="c-40314200">[-]</label><label class="expand" for="c-40314200">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Logic doesn&#x27;t really have a direction, it works backwards or forwards.</i><p>Implication is one of the primitives in logic, and gives us several of the classic logical fallacies: affirming the consequent, denying the antecedent, fallacy of the converse, and fallacy of the inverse.<p>All of which are examples of trying to work logic as though it doesn&#x27;t have a direction.</div><br/><div id="40315473" class="c"><input type="checkbox" id="c-40315473" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40314200">parent</a><span>|</span><a href="#40311088">next</a><span>|</span><label class="collapse" for="c-40315473">[-]</label><label class="expand" for="c-40315473">[1 more]</label></div><br/><div class="children"><div class="content">Implication is not primitive, &quot;x-&gt;y&quot; is reducible to &quot;not(x) or y&quot;. None of those fallacies derive from a lack of direction, but from not being invalid logical deductions.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40311088" class="c"><input type="checkbox" id="c-40311088" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40308716">prev</a><span>|</span><a href="#40308074">next</a><span>|</span><label class="collapse" for="c-40311088">[-]</label><label class="expand" for="c-40311088">[1 more]</label></div><br/><div class="children"><div class="content">&gt; except maybe Rust<p>Swift, Kotlin and Scala all have had ADTs for a while, even Java has it now.</div><br/></div></div><div id="40308074" class="c"><input type="checkbox" id="c-40308074" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40311088">prev</a><span>|</span><a href="#40308828">next</a><span>|</span><label class="collapse" for="c-40308074">[-]</label><label class="expand" for="c-40308074">[11 more]</label></div><br/><div class="children"><div class="content">Pascal has had variant records since the 1970s.</div><br/><div id="40308216" class="c"><input type="checkbox" id="c-40308216" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308074">parent</a><span>|</span><a href="#40308828">next</a><span>|</span><label class="collapse" for="c-40308216">[-]</label><label class="expand" for="c-40308216">[10 more]</label></div><br/><div class="children"><div class="content">But Pascal&#x27;s variant records (1970-11) had very ugly design errors in comparison with the unions of Algol 68 (1968-12), which made them either useless or annoying for most applicatons.<p>Niklaus Wirth is well known as a critic of Algol 68 (before the design of Algol 68 was finalized), but in the case of his variant records he has completely failed to create something competitive.</div><br/><div id="40313572" class="c"><input type="checkbox" id="c-40313572" checked=""/><div class="controls bullet"><span class="by">mzs</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308216">parent</a><span>|</span><a href="#40308222">next</a><span>|</span><label class="collapse" for="c-40313572">[-]</label><label class="expand" for="c-40313572">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t look too bad particually the <i>match</i> tagged version last:<p><pre><code>  MyType= (Scalar4, Real4, NullTerminatedStringC);
  
  MyUntaggedRecType=
      RECORD
      CASE MyType OF
      Scalar4: (longC:  ARRAY[1..150] OF longint);
      Real4:   (floatC: ARRAY[1..150] OF real);
      END;
  
  MyTaggedRecType=
      RECORD
      CASE tag: MyType OF
      Scalar4: (longC:  ARRAY[1..150] OF longint);
      Real4:   (floatC: ARRAY[1..150] OF real);
      END;
  
  ...
  
  { set all to 0.0 without running through the MC68881 }
  FOR j := 1 TO 150 DO
      longC[j]:= 0;
  
  ...
  
  CASE tag OF
      Scalar4: percentReal = longC[1];
      floatC:  percentReal = floatC[1]*100;
  ELSE
      percentReal = 0.0&#x2F;0.0;
</code></pre>
edit: don&#x27;t have a pascal compiler handy, but that&#x27;s the idea</div><br/></div></div><div id="40308222" class="c"><input type="checkbox" id="c-40308222" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308216">parent</a><span>|</span><a href="#40313572">prev</a><span>|</span><a href="#40308828">next</a><span>|</span><label class="collapse" for="c-40308222">[-]</label><label class="expand" for="c-40308222">[8 more]</label></div><br/><div class="children"><div class="content">Given where Algol 68 ended up, I would say Wirth was quite right.</div><br/><div id="40308255" class="c"><input type="checkbox" id="c-40308255" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308222">parent</a><span>|</span><a href="#40308828">next</a><span>|</span><label class="collapse" for="c-40308255">[-]</label><label class="expand" for="c-40308255">[7 more]</label></div><br/><div class="children"><div class="content">Algol 68 was a failure mainly due to its inappropriate documentation, not due to the quality of the language.<p>It included many innovations that appeared again in other programming languages only decades later.<p>Niklaus Wirth was a good teacher and writer and the success of his languages is due mostly to his books and due to his languages being used for teaching in many universities, not due to their technical qualities.</div><br/><div id="40311493" class="c"><input type="checkbox" id="c-40311493" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308255">parent</a><span>|</span><a href="#40308392">next</a><span>|</span><label class="collapse" for="c-40311493">[-]</label><label class="expand" for="c-40311493">[1 more]</label></div><br/><div class="children"><div class="content">Algol 68 may have been a failure because it was ahead of its time, which meant it was hard to write a compiler for it.  For example, Algol 68 had closures (apparently Knuth snuck them in).</div><br/></div></div><div id="40308392" class="c"><input type="checkbox" id="c-40308392" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308255">parent</a><span>|</span><a href="#40311493">prev</a><span>|</span><a href="#40308364">next</a><span>|</span><label class="collapse" for="c-40308392">[-]</label><label class="expand" for="c-40308392">[1 more]</label></div><br/><div class="children"><div class="content">I beg to differ, after Modula-2 and Object Pascal (Apple designed it with Wirth&#x27;s feedback).<p>Most of his languages ended up losing, because they weren&#x27;t being shipped with a free beer OS, coupled with a free beer compiler.</div><br/></div></div><div id="40308364" class="c"><input type="checkbox" id="c-40308364" checked=""/><div class="controls bullet"><span class="by">peoplefromibiza</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308255">parent</a><span>|</span><a href="#40308392">prev</a><span>|</span><a href="#40308828">next</a><span>|</span><label class="collapse" for="c-40308364">[-]</label><label class="expand" for="c-40308364">[4 more]</label></div><br/><div class="children"><div class="content">&gt; not due to their technical qualities<p>AFAIK Pascal is C and Algol 68 is C++<p>people used Pascal because the compiler was blazing fast, it was easier to implement and learn and the features it lacked against Algol did not really matter most of the time (at the time)<p>More features doesn&#x27;t automatically means &quot;better&quot;<p>Also Pascal had quite strong technical qualities, not very common among other contemporary languages<p>edit: can I ask the reason for the downvote? I would really like to hear an opinion on what Pascal did wrong, having used it extensively in the late 80s until the end of the 90s and why my comment was awarded with a negative score.</div><br/><div id="40309587" class="c"><input type="checkbox" id="c-40309587" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308364">parent</a><span>|</span><a href="#40308828">next</a><span>|</span><label class="collapse" for="c-40309587">[-]</label><label class="expand" for="c-40309587">[3 more]</label></div><br/><div class="children"><div class="content">Extended variants of Pascal, like Turbo Pascal, should not be confused with the Pascal language as designed by Niklaus Wirth.<p>Wirth&#x27;s Pascal was a language designed for the purpose of teaching programming and it was adequate for that, but it was completely inappropriate for any serious work.<p>It had no means for writing big programs that must be divided into multiple source files and it had a lot of design errors, like including the size of an array in its data type (which made impossible the writing of any linear algebra library) or the way of handling the variant records (which was insecure and verbose).<p>The well known paper &quot;Why Pascal Is Not My Favorite Programming Language&quot; by Brian W. Kernighan contains valid arguments against Pascal (against Wirth&#x27;s Pascal, there have been many extended Pascals, especially following Turbo Pascal, which have corrected some of the most egregious defects of the original Pascal).</div><br/><div id="40310100" class="c"><input type="checkbox" id="c-40310100" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309587">parent</a><span>|</span><a href="#40310368">next</a><span>|</span><label class="collapse" for="c-40310100">[-]</label><label class="expand" for="c-40310100">[1 more]</label></div><br/><div class="children"><div class="content">People keep playing this tired song, while clearly ignoring that until ISO C89, even C was full of dialects, a mix of K&amp;R C and whatever the compiler writer felt like, filled with tons of Assembly.<p>Small-C, RatC,....<p>Additionally forgetting that Modula-2 came out in 1978, as means the sort out all those issues, a language designed for systems programming, instead of the &quot;Python&quot; from 1970, designed for teaching.<p>With features that C is yet to have, 50 years later, while HN is hypping for having them in a   C like syntax delivered in a Zig package.</div><br/></div></div><div id="40310368" class="c"><input type="checkbox" id="c-40310368" checked=""/><div class="controls bullet"><span class="by">peoplefromibiza</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309587">parent</a><span>|</span><a href="#40310100">prev</a><span>|</span><a href="#40308828">next</a><span>|</span><label class="collapse" for="c-40310368">[-]</label><label class="expand" for="c-40310368">[1 more]</label></div><br/><div class="children"><div class="content">I know that paper and personally I think some of the critiques are actually qualities of pascal, making it, while certainly not a completely refined language, a more modern language than C<p>- no escape (AKA no casting): good!<p>- no default clause in case: good idea, not so good implementation (undefined behaviour)<p>- no break outside for loops: inconvenient, but that&#x27;s how FP works. it is still debated today if breaking loops is considered a good or a bad practice<p>- no separated compilation: I will quote Kernighan on this <i>Theoretically, there is no need for separate compilation - if one&#x27;s compiler is very fast</i> Pascal compiler was fast, maybe not <i>very</i> fast, but speed was one of the primary goals for Wirth.<p>many other issues were similar in other languages and in C<p>Pascal had obviously its faults, but every language back then had some<p>Pascal was simple enough to make it easy to compile and implement. That&#x27;s what Wirth thaught, he&#x27;s the author of <i>Compiler Construction</i> after all, it wasn&#x27;t like learning Python today as a data scientist<p>make the language more complex (and more useful&#x2F;interesting) and you&#x27;re stuck with a very slow or very buggy compiler that very few people would know how to implement<p>I think there&#x27;s a reason why we had Turbo Pascal and not Turbo Algol 68</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40308828" class="c"><input type="checkbox" id="c-40308828" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40308074">prev</a><span>|</span><a href="#40310389">next</a><span>|</span><label class="collapse" for="c-40308828">[-]</label><label class="expand" for="c-40308828">[8 more]</label></div><br/><div class="children"><div class="content">C has always had them, it&#x27;s called union.<p>In practice you need to couple it with an enum, and your visitation mechanism is a switch statement. But C doesn&#x27;t impose that on you and lets you do it as you see fit.</div><br/><div id="40308956" class="c"><input type="checkbox" id="c-40308956" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308828">parent</a><span>|</span><a href="#40309164">next</a><span>|</span><label class="collapse" for="c-40308956">[-]</label><label class="expand" for="c-40308956">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re confusing semantics for implementation. The point of union and discriminated union <i>types</i> (not what C calls union) is to enable compiler checked pattern matching, which  tagged enums in C plus a switch statement do not get you.</div><br/></div></div><div id="40309164" class="c"><input type="checkbox" id="c-40309164" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308828">parent</a><span>|</span><a href="#40308956">prev</a><span>|</span><a href="#40308971">next</a><span>|</span><label class="collapse" for="c-40309164">[-]</label><label class="expand" for="c-40309164">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>C has always had them, it&#x27;s called union</i><p>It also has all the features of Haskell, since you can implement a Haskell compiler in C.</div><br/></div></div><div id="40308971" class="c"><input type="checkbox" id="c-40308971" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308828">parent</a><span>|</span><a href="#40309164">prev</a><span>|</span><a href="#40309389">next</a><span>|</span><label class="collapse" for="c-40308971">[-]</label><label class="expand" for="c-40308971">[1 more]</label></div><br/><div class="children"><div class="content">Tagged unions + pattern matching is what gp wants. You can always encode whatever model you want using any programming language, but language features&#x2F;ergonomics matter.</div><br/></div></div><div id="40309389" class="c"><input type="checkbox" id="c-40309389" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308828">parent</a><span>|</span><a href="#40308971">prev</a><span>|</span><a href="#40310623">next</a><span>|</span><label class="collapse" for="c-40309389">[-]</label><label class="expand" for="c-40309389">[1 more]</label></div><br/><div class="children"><div class="content">That you can <i>sort of</i> simulate the <i>skeleton</i> of algebraic data types does not mean that C has algebraic data types. The whole point of the <i>algebra</i> part is that the syntax has a compositional semantics which is completely absent in C, unless you go to great lengths as with this macro header.</div><br/></div></div><div id="40310623" class="c"><input type="checkbox" id="c-40310623" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308828">parent</a><span>|</span><a href="#40309389">prev</a><span>|</span><a href="#40309572">next</a><span>|</span><label class="collapse" for="c-40310623">[-]</label><label class="expand" for="c-40310623">[2 more]</label></div><br/><div class="children"><div class="content">lol this is like saying C doesn&#x27;t need structs, you can just declare the variables with a common prefix separately! See ma, product types!</div><br/><div id="40310712" class="c"><input type="checkbox" id="c-40310712" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310623">parent</a><span>|</span><a href="#40309572">next</a><span>|</span><label class="collapse" for="c-40310712">[-]</label><label class="expand" for="c-40310712">[1 more]</label></div><br/><div class="children"><div class="content">Yep, or C doesn&#x27;t need arrays just use pointers! And C doesn&#x27;t need strings, just use a pointer to the first byte and assume it&#x27;s ASCII!</div><br/></div></div></div></div><div id="40309572" class="c"><input type="checkbox" id="c-40309572" checked=""/><div class="controls bullet"><span class="by">bmoxb</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40308828">parent</a><span>|</span><a href="#40310623">prev</a><span>|</span><a href="#40310389">next</a><span>|</span><label class="collapse" for="c-40309572">[-]</label><label class="expand" for="c-40309572">[1 more]</label></div><br/><div class="children"><div class="content">That is not a proper alternative to real pattern matching.</div><br/></div></div></div></div><div id="40310389" class="c"><input type="checkbox" id="c-40310389" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40308828">prev</a><span>|</span><a href="#40312050">next</a><span>|</span><label class="collapse" for="c-40310389">[-]</label><label class="expand" for="c-40310389">[4 more]</label></div><br/><div class="children"><div class="content">Isn’t ADT abbreviation for Abstract Data Type? Or does it depend in context nowadays?</div><br/><div id="40310471" class="c"><input type="checkbox" id="c-40310471" checked=""/><div class="controls bullet"><span class="by">Jaxan</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310389">parent</a><span>|</span><a href="#40310435">next</a><span>|</span><label class="collapse" for="c-40310471">[-]</label><label class="expand" for="c-40310471">[1 more]</label></div><br/><div class="children"><div class="content">You answered your own question: it depends and the context and is confusing imo. Both are very common in compsci</div><br/></div></div><div id="40310435" class="c"><input type="checkbox" id="c-40310435" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310389">parent</a><span>|</span><a href="#40310471">prev</a><span>|</span><a href="#40314606">next</a><span>|</span><label class="collapse" for="c-40310435">[-]</label><label class="expand" for="c-40310435">[1 more]</label></div><br/><div class="children"><div class="content">Context. It means algebraic data type here.</div><br/></div></div><div id="40314606" class="c"><input type="checkbox" id="c-40314606" checked=""/><div class="controls bullet"><span class="by">drycabinet</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40310389">parent</a><span>|</span><a href="#40310435">prev</a><span>|</span><a href="#40312050">next</a><span>|</span><label class="collapse" for="c-40314606">[-]</label><label class="expand" for="c-40314606">[1 more]</label></div><br/><div class="children"><div class="content">Wait until you switch to unions in rust and ask yourself whether it is a union or a struct.</div><br/></div></div></div></div><div id="40312050" class="c"><input type="checkbox" id="c-40312050" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40310389">prev</a><span>|</span><a href="#40309982">next</a><span>|</span><label class="collapse" for="c-40312050">[-]</label><label class="expand" for="c-40312050">[1 more]</label></div><br/><div class="children"><div class="content">May not be built in but many mainstream languages such as typescript have libraries or the tools to easily implement them.</div><br/></div></div><div id="40309982" class="c"><input type="checkbox" id="c-40309982" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40307717">parent</a><span>|</span><a href="#40312050">prev</a><span>|</span><a href="#40312779">next</a><span>|</span><label class="collapse" for="c-40309982">[-]</label><label class="expand" for="c-40309982">[4 more]</label></div><br/><div class="children"><div class="content">&gt; [Algebraic Data Types are] such a basic mental model of how humans think and solve problems<p>I think that&#x27;s actually wrong for &quot;Sum types&quot;.  Product types, sure.  The idea of storing a bunch of fields in a single thing matches the way we&#x27;ve been organizing information since we started writing things down.<p>But I genuinely don&#x27;t think I&#x27;ve seen an attempt at a sum&#x2F;union&#x2F;enumerant&#x2F;whatever syntax in a programming language that wasn&#x27;t horrifyingly confusing.<p>Where by extension: class-based inheritance is actually pretty simple to understand.  The classic &quot;IS-A&quot; relationship isn&#x27;t as simple as &quot;fields in a struct&quot;, but it&#x27;s not hard to understand (c.f. all the animal analogies), and the syntax for expressing it is pretty clean in most languages.<p>Is it the &quot;best&quot; way to solve a problem?  Maybe not.  Neither are ADT sum types.  But I think there&#x27;s a major baby-in-the-bathwater problem with trying to be different.  I really don&#x27;t think, for the case of typical coders writing typical code, that ADTs are bringing as much to the table as the experts think.</div><br/><div id="40314612" class="c"><input type="checkbox" id="c-40314612" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40309982">parent</a><span>|</span><a href="#40312779">next</a><span>|</span><label class="collapse" for="c-40314612">[-]</label><label class="expand" for="c-40314612">[3 more]</label></div><br/><div class="children"><div class="content">&gt; class-based inheritance is actually pretty simple to understand<p>Simple to understand, a nightmare to debug, as you&#x27;ll be chasing where your data and data contracts across a ton of files.</div><br/><div id="40315159" class="c"><input type="checkbox" id="c-40315159" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40314612">parent</a><span>|</span><a href="#40312779">next</a><span>|</span><label class="collapse" for="c-40315159">[-]</label><label class="expand" for="c-40315159">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a bit much.  Type inheritance has been a core abstraction in software development since before most working developers were born.  We as a society know how to do this.  The idea that one oddball new idea is a revolution that turns a &quot;nightmare&quot; into sunshine is way too hyperbolized.<p>Sum typing might be better!  But frankly the jury is still out, and the impact is clearly going to be smaller than what you&#x27;re imagining.</div><br/><div id="40315391" class="c"><input type="checkbox" id="c-40315391" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#40307717">root</a><span>|</span><a href="#40315159">parent</a><span>|</span><a href="#40312779">next</a><span>|</span><label class="collapse" for="c-40315391">[-]</label><label class="expand" for="c-40315391">[1 more]</label></div><br/><div class="children"><div class="content">The new lowest level pls (zig, rust) have ditched class based inheritance.  Higher level PLs are going more functional, to include JS, where entire frameworks are encouraging functional (not to mention how everyone complains about the opacity of trying to use inheritance in place of declarative i.e. Amazon CDK)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>