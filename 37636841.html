<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695632463156" as="style"/><link rel="stylesheet" href="styles.css?v=1695632463156"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://adriano.fyi/posts/2023-09-24-choose-postgres-queue-technology/">Choose Postgres queue technology</a> <span class="domain">(<a href="https://adriano.fyi">adriano.fyi</a>)</span></div><div class="subtext"><span>bo0tzz</span> | <span>169 comments</span></div><br/><div><div id="37640856" class="c"><input type="checkbox" id="c-37640856" checked=""/><div class="controls bullet"><span class="by">ritzaco</span><span>|</span><a href="#37636973">next</a><span>|</span><label class="collapse" for="c-37640856">[-]</label><label class="expand" for="c-37640856">[2 more]</label></div><br/><div class="children"><div class="content">I often see the &quot;engineers copy FAANG infrastructure because they want to be cool, even though their needs are completely different&quot; take as a kind of attack on engineers.<p>But I think a lot of it is also about knowledge and documentation. If I want to copy FAANG or another startup, and set up an infinitely scalable queue-based architecture, I can find dozens of high quality guides, tutorials, white papers etc, showing me exactly how to do it. Yes maintenance is higher, but I can get set up with redis, SQS, any of the &#x27;scalable&#x27; solutions within a few hours of copy-pasting commands and code and configuration from a reputable source.<p>If I want to use NOTIFY in postgres? I googled &quot;SQLALchemy notify listen postgres&quot; and I find a few unanswered stackoverflow questions and a github gist that has some code but no context.<p>I would honestly love to use this approach for a side project, but I don&#x27;t have 2-3 days to figure it out on my own. The direct choice for me might seem to be<p>* simple, but not scalable (ie just use postgres)<p>* complex, but scalable (ie redis, sqs, whatever)<p>and then it&#x27;s a tradeoff, and the argument goes that I am blinded by cool tech and FAANG and I&#x27;m choosing complex but scalable, even though I don&#x27;t need scalable.<p>But taking into account guides and other resources, the choice for me is actually<p>* complex and not scalable (this, because I don&#x27;t know how to implement it and I can&#x27;t predict what pitfalls I might face if I try)<p>* simple and scalable (what everyone actually does)<p>and that makes the engineer&#x27;s choice to follow faang look a lot more reasonable.</div><br/><div id="37640975" class="c"><input type="checkbox" id="c-37640975" checked=""/><div class="controls bullet"><span class="by">natmaka</span><span>|</span><a href="#37640856">parent</a><span>|</span><a href="#37636973">next</a><span>|</span><label class="collapse" for="c-37640975">[-]</label><label class="expand" for="c-37640975">[1 more]</label></div><br/><div class="children"><div class="content">Another point is: you don&#x27;t need scalable now, but may (or even hope) to need it later, and you know that when you will need it you probably won&#x27;t have time to invest into migrating this component.<p>Also: you may think that you may one day want to be hired by a FAANG.</div><br/></div></div></div></div><div id="37636973" class="c"><input type="checkbox" id="c-37636973" checked=""/><div class="controls bullet"><span class="by">aduffy</span><span>|</span><a href="#37640856">prev</a><span>|</span><a href="#37638683">next</a><span>|</span><label class="collapse" for="c-37636973">[-]</label><label class="expand" for="c-37636973">[65 more]</label></div><br/><div class="children"><div class="content">For several projects I’ve opted for the even dumber approach, that works out of the box with every ORM&#x2F;Query DSL framework in every language: using a normal table with SELECT FOR UPDATE SKIP LOCKED<p><a href="https:&#x2F;&#x2F;www.pgcasts.com&#x2F;episodes&#x2F;the-skip-locked-feature-in-postgres-9-5" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pgcasts.com&#x2F;episodes&#x2F;the-skip-locked-feature-in-...</a><p>It’s not “web scale” but it easily extends to several thousand background jobs in my experience</div><br/><div id="37636998" class="c"><input type="checkbox" id="c-37636998" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37637860">next</a><span>|</span><label class="collapse" for="c-37636998">[-]</label><label class="expand" for="c-37636998">[30 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done even simpler without locks (as no transaction logic), where I select a row, and then try to update a field about it being taken. If 1 row is affected, it&#x27;s mine. If 0, someone else did it before me and I select a new row.<p>I&#x27;ve used this for tasks at big organizations without issue. No need for any special deployments or new infra. Just spin up a few worker threads in your app. Perhaps a thread to reset abandoned tasks. But in three years this never actually happened, as everything was contained in try&#x2F;catch that would add it back to the queue, and our java app was damn stable.</div><br/><div id="37638500" class="c"><input type="checkbox" id="c-37638500" checked=""/><div class="controls bullet"><span class="by">refibrillator</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37636998">parent</a><span>|</span><a href="#37638481">next</a><span>|</span><label class="collapse" for="c-37638500">[-]</label><label class="expand" for="c-37638500">[7 more]</label></div><br/><div class="children"><div class="content">PSA: This is a read-modify-write pattern, thus it is not safe under concurrency unless a transaction isolation level of SERIALIZABLE is specified, or <i>some</i> locking mechanism is used (select for update etc).</div><br/><div id="37640242" class="c"><input type="checkbox" id="c-37640242" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638500">parent</a><span>|</span><a href="#37639066">next</a><span>|</span><label class="collapse" for="c-37640242">[-]</label><label class="expand" for="c-37640242">[5 more]</label></div><br/><div class="children"><div class="content">The part about checking the number of affected rows hints at using `UPDATE ... WHERE ...` which should act as an atomic CAS regardless of isolation level.<p>Edit: To clarify, I mean `SELECT id WHERE used = 0` followed by `UPDATE ... SET used = 1 WHERE id = ... AND used = 0`</div><br/><div id="37640426" class="c"><input type="checkbox" id="c-37640426" checked=""/><div class="controls bullet"><span class="by">RichieAHB</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640242">parent</a><span>|</span><a href="#37640329">next</a><span>|</span><label class="collapse" for="c-37640426">[-]</label><label class="expand" for="c-37640426">[3 more]</label></div><br/><div class="children"><div class="content">This works fine as long as you’re happy to do the same task multiple times. I.e. the task is idempotent and cheap.</div><br/><div id="37640845" class="c"><input type="checkbox" id="c-37640845" checked=""/><div class="controls bullet"><span class="by">kdps</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640426">parent</a><span>|</span><a href="#37640329">next</a><span>|</span><label class="collapse" for="c-37640845">[-]</label><label class="expand" for="c-37640845">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it :(. Why could the same task be executed more than once? From my understanding, if the UPDATE is atomic, only one worker will be able to set `used = 1`. If the update statement is not successful (affected != 1), then the worker should drop the task and do another select.</div><br/><div id="37641104" class="c"><input type="checkbox" id="c-37641104" checked=""/><div class="controls bullet"><span class="by">klauserc</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640845">parent</a><span>|</span><a href="#37640329">next</a><span>|</span><label class="collapse" for="c-37641104">[-]</label><label class="expand" for="c-37641104">[1 more]</label></div><br/><div class="children"><div class="content">With a transaction isolation level below SERIALIZABLE you can have two transactions that both read the old row (with `used = 0`) at the time they perform the update (but before they commit the transaction). In that case, both transactions will have performed an update (rows affected = 1).<p>Why would both transactions see `used = 0`? The DB server tries to isolate transactions and actively hides effects of other transactions that have not committed yet.</div><br/></div></div></div></div></div></div><div id="37640329" class="c"><input type="checkbox" id="c-37640329" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640242">parent</a><span>|</span><a href="#37640426">prev</a><span>|</span><a href="#37639066">next</a><span>|</span><label class="collapse" for="c-37640329">[-]</label><label class="expand" for="c-37640329">[1 more]</label></div><br/><div class="children"><div class="content">This is spot on! We let the db provide the atomics.</div><br/></div></div></div></div><div id="37639066" class="c"><input type="checkbox" id="c-37639066" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638500">parent</a><span>|</span><a href="#37640242">prev</a><span>|</span><a href="#37638481">next</a><span>|</span><label class="collapse" for="c-37639066">[-]</label><label class="expand" for="c-37639066">[1 more]</label></div><br/><div class="children"><div class="content">This should be safe under SI (other than the ABA issue, which isn&#x27;t even fixed with serializable). The update forces a W-W conflict, which is sufficient to make the behavior serializable under SI (and therefore, I think but am not sure, PG&#x27;s RR level too).</div><br/></div></div></div></div><div id="37638481" class="c"><input type="checkbox" id="c-37638481" checked=""/><div class="controls bullet"><span class="by">valzam</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37636998">parent</a><span>|</span><a href="#37638500">prev</a><span>|</span><a href="#37637037">next</a><span>|</span><label class="collapse" for="c-37638481">[-]</label><label class="expand" for="c-37638481">[1 more]</label></div><br/><div class="children"><div class="content">The reason why you want to use skip locked is so that Postgres can automatically skip rows that are being concurrently accessed for updating the &quot;status&quot;. You are right, if you update a &quot;status&quot; field you don&#x27;t really need to worry about advisory locks and skipping rows that are locked but it still helps with performance if you have a decent amount of concurrent consumers polling the table.</div><br/></div></div><div id="37637037" class="c"><input type="checkbox" id="c-37637037" checked=""/><div class="controls bullet"><span class="by">andrelaszlo</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37636998">parent</a><span>|</span><a href="#37638481">prev</a><span>|</span><a href="#37638009">next</a><span>|</span><label class="collapse" for="c-37637037">[-]</label><label class="expand" for="c-37637037">[14 more]</label></div><br/><div class="children"><div class="content">I guess you update it with the assigned worker id, where the &quot;taken by&quot; field is currently null? Does it mean that workers have persistent identities, something like an index? How do you deal with workers being replaced, scaled down, etc?<p>Just curious. We maintained a custom background processing system for years but recently replaced it with off the shelf stuff, so I&#x27;m really interested in how others are doing similar stuff.</div><br/><div id="37637084" class="c"><input type="checkbox" id="c-37637084" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637037">parent</a><span>|</span><a href="#37638052">next</a><span>|</span><label class="collapse" for="c-37637084">[-]</label><label class="expand" for="c-37637084">[12 more]</label></div><br/><div class="children"><div class="content">No, just update set taken=1. If it was a change to the row, you updated it. If it wasn&#x27;t, someone updated before you.<p>Our tasks were quick enough so that all fetched tasks would always be able to be completed before a scale down &#x2F; new deploy etc, but we  stopped fetching new ones when the signal came so it just finished what it had. I updated above, we did have logic to monitor if a task got taken but never got a finished status, but I can&#x27;t remember it ever actually reporting on anything.</div><br/><div id="37637114" class="c"><input type="checkbox" id="c-37637114" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637084">parent</a><span>|</span><a href="#37637305">next</a><span>|</span><label class="collapse" for="c-37637114">[-]</label><label class="expand" for="c-37637114">[7 more]</label></div><br/><div class="children"><div class="content">I would set the taken field to a timestamp. Then you could have a cleanup job that looks for any lingering jobs aged past a reasonable timeout and null out the field.</div><br/><div id="37640954" class="c"><input type="checkbox" id="c-37640954" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637114">parent</a><span>|</span><a href="#37639462">next</a><span>|</span><label class="collapse" for="c-37640954">[-]</label><label class="expand" for="c-37640954">[1 more]</label></div><br/><div class="children"><div class="content">We have a &quot;status flag&quot; column which is either Available, Locked or Processed (A, L and P), an Updated column with a timestamp of when it was last updated, and a Version counter.<p>When grabbing a new message it selects &quot;Available or (Locked with Updated timestamp older than configured timeout)&quot;. If successful it immediately tries to set the Locked status, Updated timestamp and bumps the Version counter, where the previous values of Status and Version has to match. If the update fails it retries getting a new message.<p>If the Version counter is too high, it moves the message to the associated dead-letter table, and retries getting a new message.<p>This isn&#x27;t for high performance. I tested it and got 1000 messages&#x2F;sec throughput with handful of producers and consumers against test db instance (limited hardware), which would be <i>plenty</i> for us.<p>I wrote it to be simple and so we could easily move to something AMPQ&#x27;ish like RabbitMQ or Azure Service Bus when needed. Overall quite easy to implement and has served us well so far.</div><br/></div></div><div id="37639462" class="c"><input type="checkbox" id="c-37639462" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637114">parent</a><span>|</span><a href="#37640954">prev</a><span>|</span><a href="#37637168">next</a><span>|</span><label class="collapse" for="c-37639462">[-]</label><label class="expand" for="c-37639462">[1 more]</label></div><br/><div class="children"><div class="content">We do it with two columns, one is an integer identifying which process took the job and the second is the timestamp for when it was taken.</div><br/></div></div><div id="37637168" class="c"><input type="checkbox" id="c-37637168" checked=""/><div class="controls bullet"><span class="by">tylergetsay</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637114">parent</a><span>|</span><a href="#37639462">prev</a><span>|</span><a href="#37637305">next</a><span>|</span><label class="collapse" for="c-37637168">[-]</label><label class="expand" for="c-37637168">[4 more]</label></div><br/><div class="children"><div class="content">it wont work with a timestamp because each write will have an affected row of 1 beacuse the writes happen at different times. setting a boolean is static</div><br/><div id="37637263" class="c"><input type="checkbox" id="c-37637263" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637168">parent</a><span>|</span><a href="#37637559">next</a><span>|</span><label class="collapse" for="c-37637263">[-]</label><label class="expand" for="c-37637263">[1 more]</label></div><br/><div class="children"><div class="content">You can do something like UPDATE row SET timeout = NOW() WHERE NOW() - taskTimeout &gt; row.timestamp.  You&#x27;re not stuck with comparing bools.</div><br/></div></div><div id="37637559" class="c"><input type="checkbox" id="c-37637559" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637168">parent</a><span>|</span><a href="#37637263">prev</a><span>|</span><a href="#37638322">next</a><span>|</span><label class="collapse" for="c-37637559">[-]</label><label class="expand" for="c-37637559">[1 more]</label></div><br/><div class="children"><div class="content">update tasks set taken_timestamp = now() where task_id = ? and taken_timestamp is null</div><br/></div></div><div id="37638322" class="c"><input type="checkbox" id="c-37638322" checked=""/><div class="controls bullet"><span class="by">AdamJacobMuller</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637168">parent</a><span>|</span><a href="#37637559">prev</a><span>|</span><a href="#37637305">next</a><span>|</span><label class="collapse" for="c-37638322">[-]</label><label class="expand" for="c-37638322">[1 more]</label></div><br/><div class="children"><div class="content">update row set taken=true,taken_by=my_id,taken_at=now() where taken is false;</div><br/></div></div></div></div></div></div><div id="37637305" class="c"><input type="checkbox" id="c-37637305" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637084">parent</a><span>|</span><a href="#37637114">prev</a><span>|</span><a href="#37637249">next</a><span>|</span><label class="collapse" for="c-37637305">[-]</label><label class="expand" for="c-37637305">[3 more]</label></div><br/><div class="children"><div class="content">That is the sort of thing that bites you hard when it bites. It might run perfectly for years but that one period of flappy downtime at a third party or slightly misconfigured DNS will bite you hard.</div><br/><div id="37637516" class="c"><input type="checkbox" id="c-37637516" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637305">parent</a><span>|</span><a href="#37637249">next</a><span>|</span><label class="collapse" for="c-37637516">[-]</label><label class="expand" for="c-37637516">[2 more]</label></div><br/><div class="children"><div class="content">But compared to our rabbit setup where I work now, it was dead stable. No losing tasks or extra engineering effort on maintaining yet another piece of tech. Our rabbit cluster acting up has led to multiple disasters lately.</div><br/><div id="37637630" class="c"><input type="checkbox" id="c-37637630" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637516">parent</a><span>|</span><a href="#37637249">next</a><span>|</span><label class="collapse" for="c-37637630">[-]</label><label class="expand" for="c-37637630">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I&#x27;ve had my own rabbit nightmares. But setting up a more robust queue on postgresql is easy, so you can easily gain a lot more guarantees without more complexity.</div><br/></div></div></div></div></div></div><div id="37637249" class="c"><input type="checkbox" id="c-37637249" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637084">parent</a><span>|</span><a href="#37637305">prev</a><span>|</span><a href="#37638052">next</a><span>|</span><label class="collapse" for="c-37637249">[-]</label><label class="expand" for="c-37637249">[1 more]</label></div><br/><div class="children"><div class="content">You can combine this &quot;update&quot; with a &quot;where taken = 0&quot; to directly skip taken rows.</div><br/></div></div></div></div><div id="37638052" class="c"><input type="checkbox" id="c-37638052" checked=""/><div class="controls bullet"><span class="by">calrain</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637037">parent</a><span>|</span><a href="#37637084">prev</a><span>|</span><a href="#37638009">next</a><span>|</span><label class="collapse" for="c-37638052">[-]</label><label class="expand" for="c-37638052">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done this successfully with a web service front that retrieves jobs to send to workers for processing, by using a SQL table queue. That web service ran without a hitch for a long time, serving about 10 to 50 job consumers for fast and highly concurrent queues.<p>My approach was:<p>- Accept the inbound call<p>- Generate a 20 character random string (used as a signature)<p>- Execute a sql query that selects the oldest job without a signature and write the signature, return the primary key of the job that was updated.<p>- If it errors for any reason, loop back and attempt again, but only 10 times, as some underlying issue exists (10 collisions is statistically improbable for my use case)<p>- Read the primary key returned by that sql query and read it, comparing it&#x27;s signature to my random one.<p>- If a hit, return the job to the caller<p>- If a miss, loop back and start again, incrementing attempts by 1.<p>The caller has to handle the possibility that a call to this web service won&#x27;t return anything, either due to no jobs existing, or the collision&#x2F;error threshold being reached.<p>In either case, the caller backs for it&#x27;s configured time, then calls again.<p>Callers are usually in &#x27;while true&#x27; loops, only existing if they get an external signal to close or an uncontrolled crash.<p>If you take this approach, you will have a function or a web service that converts the SQL table into a job queue service. When you do that, you can build metrics on the amount of collisions you get while trying to pull and assign jobs to workers.<p>I had inbuilt processes that would sweep through jobs that were assigned (had a job signature) and weren&#x27;t marked as complete, it actioned those to handle the condition of a crashed worker.<p>There are many many other services the proper job queues offer, but that usually means more dependencies, and code libraries &#x2F; containers, so just build in the functionality you need.<p>If it is accurate, fast enough, and stable, you&#x27;ve got the best solution for you.<p>&#x2F;edited for formatting</div><br/></div></div></div></div><div id="37638009" class="c"><input type="checkbox" id="c-37638009" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37636998">parent</a><span>|</span><a href="#37637037">prev</a><span>|</span><a href="#37637732">next</a><span>|</span><label class="collapse" for="c-37638009">[-]</label><label class="expand" for="c-37638009">[2 more]</label></div><br/><div class="children"><div class="content">I recently got introduced to this system at work, and also built a new job using it. It works fine, but since I had to implement work stealing to deal with abandoned jobs in a timely manner, I wouldn&#x27;t dare to use it for actions that absolutely must not happen twice.</div><br/><div id="37640937" class="c"><input type="checkbox" id="c-37640937" checked=""/><div class="controls bullet"><span class="by">A1kmm</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638009">parent</a><span>|</span><a href="#37637732">next</a><span>|</span><label class="collapse" for="c-37640937">[-]</label><label class="expand" for="c-37640937">[1 more]</label></div><br/><div class="children"><div class="content">Exactly-once is only meaningfully possible if you have a rollback for tasks of unknown completion state - for example if the task involves manipulating the same database as the one controlling the task execution. Otherwise, it becomes the (impossible to solve) two-generals problem between updating the task status and performing the task.</div><br/></div></div></div></div><div id="37637732" class="c"><input type="checkbox" id="c-37637732" checked=""/><div class="controls bullet"><span class="by">mbb70</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37636998">parent</a><span>|</span><a href="#37638009">prev</a><span>|</span><a href="#37637984">next</a><span>|</span><label class="collapse" for="c-37637732">[-]</label><label class="expand" for="c-37637732">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done the same with MongoDB with findOneAndModify, simple and solid</div><br/><div id="37638971" class="c"><input type="checkbox" id="c-37638971" checked=""/><div class="controls bullet"><span class="by">dminor</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637732">parent</a><span>|</span><a href="#37638736">next</a><span>|</span><label class="collapse" for="c-37638971">[-]</label><label class="expand" for="c-37638971">[1 more]</label></div><br/><div class="children"><div class="content">Agenda uses this, and we found the hard way on mongo 4 that it can lead to mongo spinning the CPU at 100% if it gets too many at once. No idea if they&#x27;ve fixed it in later versions.</div><br/></div></div><div id="37638736" class="c"><input type="checkbox" id="c-37638736" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637732">parent</a><span>|</span><a href="#37638971">prev</a><span>|</span><a href="#37637984">next</a><span>|</span><label class="collapse" for="c-37638736">[-]</label><label class="expand" for="c-37638736">[1 more]</label></div><br/><div class="children"><div class="content">I think you mean findOneAndUpdate, and while simple, I wouldn&#x27;t call it solid.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;76821755" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;76821755</a></div><br/></div></div></div></div><div id="37637984" class="c"><input type="checkbox" id="c-37637984" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37636998">parent</a><span>|</span><a href="#37637732">prev</a><span>|</span><a href="#37637097">next</a><span>|</span><label class="collapse" for="c-37637984">[-]</label><label class="expand" for="c-37637984">[1 more]</label></div><br/><div class="children"><div class="content">With what transaction isolation level?</div><br/></div></div><div id="37637097" class="c"><input type="checkbox" id="c-37637097" checked=""/><div class="controls bullet"><span class="by">bushbaba</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37636998">parent</a><span>|</span><a href="#37637984">prev</a><span>|</span><a href="#37637860">next</a><span>|</span><label class="collapse" for="c-37637097">[-]</label><label class="expand" for="c-37637097">[1 more]</label></div><br/><div class="children"><div class="content">You could even use a timestamp for handling what if this task was never finished by the worker who locked the row.</div><br/></div></div></div></div><div id="37637860" class="c"><input type="checkbox" id="c-37637860" checked=""/><div class="controls bullet"><span class="by">surprisetalk</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37636998">prev</a><span>|</span><a href="#37640093">next</a><span>|</span><label class="collapse" for="c-37637860">[-]</label><label class="expand" for="c-37637860">[6 more]</label></div><br/><div class="children"><div class="content">I recently published a manifesto and code snippets for exactly this in Postgres!<p><pre><code>  delete from task
  where task_id in
  ( select task_id
    from task
    order by random() -- use tablesample for better performance
    for update
    skip locked
    limit 1
  )
  returning task_id, task_type, params::jsonb as params
</code></pre>
[1] <a href="https:&#x2F;&#x2F;taylor.town&#x2F;pg-task" rel="nofollow noreferrer">https:&#x2F;&#x2F;taylor.town&#x2F;pg-task</a></div><br/><div id="37638983" class="c"><input type="checkbox" id="c-37638983" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637860">parent</a><span>|</span><a href="#37640093">next</a><span>|</span><label class="collapse" for="c-37638983">[-]</label><label class="expand" for="c-37638983">[5 more]</label></div><br/><div class="children"><div class="content">Presumably it&#x27;s okay that this loses work if your task runner has an error?</div><br/><div id="37639031" class="c"><input type="checkbox" id="c-37639031" checked=""/><div class="controls bullet"><span class="by">surprisetalk</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638983">parent</a><span>|</span><a href="#37639030">next</a><span>|</span><label class="collapse" for="c-37639031">[-]</label><label class="expand" for="c-37639031">[3 more]</label></div><br/><div class="children"><div class="content">If you read my guide, you’ll see that I embed it in a transaction that doesn’t COMMIT until the companion code is complete :)<p>For example, I run the above query to grab a queued email, send it using mailgun, then COMMIT. Nothing is changed in the DB unless the email is sent.</div><br/><div id="37641039" class="c"><input type="checkbox" id="c-37641039" checked=""/><div class="controls bullet"><span class="by">w23j</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37639031">parent</a><span>|</span><a href="#37639985">next</a><span>|</span><label class="collapse" for="c-37641039">[-]</label><label class="expand" for="c-37641039">[1 more]</label></div><br/><div class="children"><div class="content">Long running transactions can lead to an accumulation of dead tuples: <a href="https:&#x2F;&#x2F;brandur.org&#x2F;postgres-queues" rel="nofollow noreferrer">https:&#x2F;&#x2F;brandur.org&#x2F;postgres-queues</a></div><br/></div></div><div id="37639985" class="c"><input type="checkbox" id="c-37639985" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37639031">parent</a><span>|</span><a href="#37641039">prev</a><span>|</span><a href="#37639030">next</a><span>|</span><label class="collapse" for="c-37639985">[-]</label><label class="expand" for="c-37639985">[1 more]</label></div><br/><div class="children"><div class="content">Holding a transaction open for the duration of a request to an external service makes me nervous. I&#x27;ve seen similar code lock up the database and bring down production. Are you using timeouts and circuit breakers to control the length of the transactions?</div><br/></div></div></div></div><div id="37639030" class="c"><input type="checkbox" id="c-37639030" checked=""/><div class="controls bullet"><span class="by">muti</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638983">parent</a><span>|</span><a href="#37639031">prev</a><span>|</span><a href="#37640093">next</a><span>|</span><label class="collapse" for="c-37639030">[-]</label><label class="expand" for="c-37639030">[1 more]</label></div><br/><div class="children"><div class="content">From the linked article<p>&gt; The task row will not be deleted if sendEmail fails. The PG transaction will be rolled back. The row and sendEmail will be retried.</div><br/></div></div></div></div></div></div><div id="37640093" class="c"><input type="checkbox" id="c-37640093" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37637860">prev</a><span>|</span><a href="#37638124">next</a><span>|</span><label class="collapse" for="c-37640093">[-]</label><label class="expand" for="c-37640093">[6 more]</label></div><br/><div class="children"><div class="content">In my experience, a queue system is the worst thing to find out isn&#x27;t scaling properly because once you find out your queue system can&#x27;t architecturally scale, there&#x27;s no easy fix to avoid data loss. You talk about &quot;several thousand background jobs&quot; but generally, queues are measured in terms of Little&#x27;s Law [1] for which you need to be talking about rates; according to Little&#x27;s Law namely average task enqueue rate per second and average task duration per second. Raw numbers don&#x27;t mean that much.<p>In the beginning you can do a naive UPDATE ... SET, which locks way too much. While you can make your locking more efficient, doing UPDATE with SELECT subqueries for dequeues and SELECT FOR UPDATE SKIP LOCKED, eventually your dequeue queries will throttle each other&#x27;s locks and your queue will grind to a halt. You can try to disable enqueues at that point to give your DB more breathing room but you&#x27;ll have data loss on lost enqueues and it&#x27;ll mostly be your dequeues locking each other out.<p>You can try very quickly to shard out your task tables to avoid locking and that may work but it&#x27;s brittle to roll out across multiple workers and can result in data loss. You can of course drop a random subset of tasks but this will cause data loss. Any of these options is not only highly stressful in a production scenario but also very hard to recover from without a ground-up rearchitecture.<p>Is this kind of a nightmare production scenario really worth choosing Boring Technology? Maybe if you have a handful of customers and are confident you&#x27;ll be working at tens of tasks per second forever. Having been in the hot seat for one of these I will <i>always</i> choose a real queue technology over a database when possible.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Little%27s_law" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Little%27s_law</a></div><br/><div id="37640286" class="c"><input type="checkbox" id="c-37640286" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640093">parent</a><span>|</span><a href="#37640585">next</a><span>|</span><label class="collapse" for="c-37640286">[-]</label><label class="expand" for="c-37640286">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  and are confident you&#x27;ll be working at tens of tasks per second forever.<p>It&#x27;s more like a few thousand per second, and enqueues win, not dequeues like you say... on very small hardware without tuning.  If you&#x27;re at tens of tasks per second, you have a whole lot of breathing room: don&#x27;t build for 100x current requirements.<p><a href="https:&#x2F;&#x2F;chbussler.medium.com&#x2F;implementing-queues-in-postgresql-3f6e9ab724fa" rel="nofollow noreferrer">https:&#x2F;&#x2F;chbussler.medium.com&#x2F;implementing-queues-in-postgres...</a><p>&gt; eventually your dequeue queries will throttle each other&#x27;s locks a<p>This doesn&#x27;t really make sense to me.  To me, the main problem seems to be that you end up with having a lot of snapshots around.</div><br/><div id="37640552" class="c"><input type="checkbox" id="c-37640552" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640286">parent</a><span>|</span><a href="#37640585">next</a><span>|</span><label class="collapse" for="c-37640552">[-]</label><label class="expand" for="c-37640552">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <a href="https:&#x2F;&#x2F;chbussler.medium.com&#x2F;implementing-queues-in-postgresql-3f6e9ab724fa" rel="nofollow noreferrer">https:&#x2F;&#x2F;chbussler.medium.com&#x2F;implementing-queues-in-postgres...</a><p>This link is simply raw enqueue&#x2F;dequeue performance. Factor in workers that perform work or execute remote calls and the numbers change. Also, I find when your jobs have high variance in times, performance degrades significantly.<p>&gt; This doesn&#x27;t really make sense to me. To me, the main problem seems to be that you end up with having a lot of snapshots around.<p>The dequeuer needs to know which tasks to &quot;claim&quot;, so this requires some form of locking. Eventually this becomes a bottleneck.<p>&gt; don&#x27;t build for 100x current requirements<p>What happens if you get 100x traffic? Popularity spikes can do it, so can attacks. Is the answer to just accept data loss in those situations? Queue systems are super simple to use. I&#x27;m counting &quot;NOTIFY&#x2F;LISTEN&quot; on Postgres as a queue, because it is a queue from the bottom up.</div><br/><div id="37640685" class="c"><input type="checkbox" id="c-37640685" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640552">parent</a><span>|</span><a href="#37640692">next</a><span>|</span><label class="collapse" for="c-37640685">[-]</label><label class="expand" for="c-37640685">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Factor in workers that perform work or execute remote calls and the numbers change.<p>These don&#x27;t occur on the database server, though... This merely affects the number of rows currently claimed.<p>&gt; The dequeuer needs to know which tasks to &quot;claim&quot;, so this requires some form of locking. Eventually this becomes a bottleneck.<p>These are just try locks, though-- the row locks are not contended.  The big thing you run into is having lots of snapshots around and having to skip a lot of claimed rows for each dequeue.<p>&gt; What happens if you get 100x traffic? Popularity spikes can do it, so can attacks.<p>If you get 100x the queueing activity for batch jobs, you&#x27;re going to have stuff break well before the queue.  It&#x27;s probably not too easy to get 100x the drain rate, even if your queue system can handle it.<p>This scales well beyond 100M batch tasks per day, which gets you to 1M users with 100 tasks&#x2F;day each.</div><br/></div></div><div id="37640692" class="c"><input type="checkbox" id="c-37640692" checked=""/><div class="controls bullet"><span class="by">asdfaoeu</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640552">parent</a><span>|</span><a href="#37640685">prev</a><span>|</span><a href="#37640585">next</a><span>|</span><label class="collapse" for="c-37640692">[-]</label><label class="expand" for="c-37640692">[1 more]</label></div><br/><div class="children"><div class="content">NOTIFY&#x2F;LISTEN isn&#x27;t a queue it has broadcast semantics. Postgres queueing is really just the SELECT FOR UPDATE SKIP LOCKED, the NOTIFY&#x2F;LISTEN allows you to reduce the latency a bit but not essential.</div><br/></div></div></div></div></div></div><div id="37640585" class="c"><input type="checkbox" id="c-37640585" checked=""/><div class="controls bullet"><span class="by">asdfaoeu</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37640093">parent</a><span>|</span><a href="#37640286">prev</a><span>|</span><a href="#37638124">next</a><span>|</span><label class="collapse" for="c-37640585">[-]</label><label class="expand" for="c-37640585">[1 more]</label></div><br/><div class="children"><div class="content">You are going to have the same scaling issues with your datastore. I don&#x27;t really understand why you say that your dequeue queries will throttle each others locks and grind it to a half? Isn&#x27;t that the whole point of SKIP LOCKED?</div><br/></div></div></div></div><div id="37638124" class="c"><input type="checkbox" id="c-37638124" checked=""/><div class="controls bullet"><span class="by">adatta02</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37640093">prev</a><span>|</span><a href="#37640554">next</a><span>|</span><label class="collapse" for="c-37638124">[-]</label><label class="expand" for="c-37638124">[1 more]</label></div><br/><div class="children"><div class="content">This is more or less how graphile, <a href="https:&#x2F;&#x2F;github.com&#x2F;graphile&#x2F;worker">https:&#x2F;&#x2F;github.com&#x2F;graphile&#x2F;worker</a> is implemented.</div><br/></div></div><div id="37640554" class="c"><input type="checkbox" id="c-37640554" checked=""/><div class="controls bullet"><span class="by">boruto</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37638124">prev</a><span>|</span><a href="#37639804">next</a><span>|</span><label class="collapse" for="c-37640554">[-]</label><label class="expand" for="c-37640554">[1 more]</label></div><br/><div class="children"><div class="content">Skip locked is useful till you have to maintain order for a group of messages with some &quot;group_id&quot;, so that set of related messages are sent one after the other.<p>Then you probably have to write complicated queries or use partitions in some sort.<p>Or Just stick to one thread polling the messages.</div><br/></div></div><div id="37639804" class="c"><input type="checkbox" id="c-37639804" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37640554">prev</a><span>|</span><a href="#37637261">next</a><span>|</span><label class="collapse" for="c-37639804">[-]</label><label class="expand" for="c-37639804">[1 more]</label></div><br/><div class="children"><div class="content">I’ve used this for a queue with millions of items and some indexes. It “just works”.</div><br/></div></div><div id="37637261" class="c"><input type="checkbox" id="c-37637261" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37639804">prev</a><span>|</span><a href="#37637804">next</a><span>|</span><label class="collapse" for="c-37637261">[-]</label><label class="expand" for="c-37637261">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what&#x27;s in the article.</div><br/></div></div><div id="37637804" class="c"><input type="checkbox" id="c-37637804" checked=""/><div class="controls bullet"><span class="by">somsak2</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37637261">prev</a><span>|</span><a href="#37639832">next</a><span>|</span><label class="collapse" for="c-37637804">[-]</label><label class="expand" for="c-37637804">[1 more]</label></div><br/><div class="children"><div class="content">Fourth paragraph of the post:<p>&gt;Applied to job records, this feature enables simple queue processing queries, e.g. SELECT * FROM jobs ORDER BY created_at FOR UPDATE SKIP LOCKED LIMIT 1.</div><br/></div></div><div id="37639832" class="c"><input type="checkbox" id="c-37639832" checked=""/><div class="controls bullet"><span class="by">johnthescott</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37637804">prev</a><span>|</span><a href="#37637364">next</a><span>|</span><label class="collapse" for="c-37639832">[-]</label><label class="expand" for="c-37639832">[1 more]</label></div><br/><div class="children"><div class="content">skip lock works well on many Ks&#x2F;sec message queues.</div><br/></div></div><div id="37637364" class="c"><input type="checkbox" id="c-37637364" checked=""/><div class="controls bullet"><span class="by">orangepanda</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37639832">prev</a><span>|</span><a href="#37637399">next</a><span>|</span><label class="collapse" for="c-37637364">[-]</label><label class="expand" for="c-37637364">[15 more]</label></div><br/><div class="children"><div class="content">As I understand, with SKIP LOCKED rows would no longer be processed in-order?</div><br/><div id="37638201" class="c"><input type="checkbox" id="c-37638201" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637364">parent</a><span>|</span><a href="#37637993">next</a><span>|</span><label class="collapse" for="c-37638201">[-]</label><label class="expand" for="c-37638201">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but if you&#x27;re going through the queue with multiple workers in parallel, you lose ordering guarantees anyway.</div><br/></div></div><div id="37637993" class="c"><input type="checkbox" id="c-37637993" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637364">parent</a><span>|</span><a href="#37638201">prev</a><span>|</span><a href="#37637793">next</a><span>|</span><label class="collapse" for="c-37637993">[-]</label><label class="expand" for="c-37637993">[2 more]</label></div><br/><div class="children"><div class="content">Depends on how many consumers you have. If you need order guarantees, then something like the outbox pattern is probably a better fit.</div><br/><div id="37639142" class="c"><input type="checkbox" id="c-37639142" checked=""/><div class="controls bullet"><span class="by">LennyWhiteJr</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637993">parent</a><span>|</span><a href="#37637793">next</a><span>|</span><label class="collapse" for="c-37639142">[-]</label><label class="expand" for="c-37639142">[1 more]</label></div><br/><div class="children"><div class="content">Nothing about the outbox pattern guarantees ordering.</div><br/></div></div></div></div><div id="37637793" class="c"><input type="checkbox" id="c-37637793" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637364">parent</a><span>|</span><a href="#37637993">prev</a><span>|</span><a href="#37637399">next</a><span>|</span><label class="collapse" for="c-37637793">[-]</label><label class="expand" for="c-37637793">[11 more]</label></div><br/><div class="children"><div class="content">article says he also uses &quot;order by&quot; clause, but I am wondering if it will severely limit throughput since all messages will need to be sorted on each lookup, but this probably can be solved by introducing index.</div><br/><div id="37638197" class="c"><input type="checkbox" id="c-37638197" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37637793">parent</a><span>|</span><a href="#37637399">next</a><span>|</span><label class="collapse" for="c-37638197">[-]</label><label class="expand" for="c-37638197">[10 more]</label></div><br/><div class="children"><div class="content">It seems strictly worse to use ORDER BY in this case, since if you&#x27;re using SKIP LOCKED you should be doing parallel processing anyway, and if you&#x27;re doing parallel processing, ordering is already going out the window.</div><br/><div id="37638277" class="c"><input type="checkbox" id="c-37638277" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638197">parent</a><span>|</span><a href="#37637399">next</a><span>|</span><label class="collapse" for="c-37638277">[-]</label><label class="expand" for="c-37638277">[9 more]</label></div><br/><div class="children"><div class="content">Parallel or not, the order is of importance in any queue system.</div><br/><div id="37638891" class="c"><input type="checkbox" id="c-37638891" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638277">parent</a><span>|</span><a href="#37638868">next</a><span>|</span><label class="collapse" for="c-37638891">[-]</label><label class="expand" for="c-37638891">[4 more]</label></div><br/><div class="children"><div class="content">Unless you can guarantee that the processing time of each job is exactly the same, if you have multiple workers processing the same queue, you can’t order anything except the start time.<p>You can use locks to effectively break the queue into sub queues so that each sub queue is only being processed by 1 worker. Then you can order that sub queue.</div><br/><div id="37639106" class="c"><input type="checkbox" id="c-37639106" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638891">parent</a><span>|</span><a href="#37638868">next</a><span>|</span><label class="collapse" for="c-37639106">[-]</label><label class="expand" for="c-37639106">[3 more]</label></div><br/><div class="children"><div class="content">job should be attempted inthe same order&#x2F;priority they are enqueued, that&#x27;s the  meaning of the word &quot;queue&quot;. That they take varrying amounts of time is another matter.</div><br/><div id="37639404" class="c"><input type="checkbox" id="c-37639404" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37639106">parent</a><span>|</span><a href="#37638868">next</a><span>|</span><label class="collapse" for="c-37639404">[-]</label><label class="expand" for="c-37639404">[2 more]</label></div><br/><div class="children"><div class="content">Queue can clearly mean &quot;work that needs to be completed&quot; not necessarily &#x27;work completed in order&#x27;.  Your definition is much stricter than it needs to be for most use cases.</div><br/><div id="37640908" class="c"><input type="checkbox" id="c-37640908" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37639404">parent</a><span>|</span><a href="#37638868">next</a><span>|</span><label class="collapse" for="c-37640908">[-]</label><label class="expand" for="c-37640908">[1 more]</label></div><br/><div class="children"><div class="content">There is clearly a conceptual difference between a set of things from which you pull things out randomly, and a queue. A queue always has intrinsic criteria to select the next item to be pulled out.</div><br/></div></div></div></div></div></div></div></div><div id="37638868" class="c"><input type="checkbox" id="c-37638868" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638277">parent</a><span>|</span><a href="#37638891">prev</a><span>|</span><a href="#37637399">next</a><span>|</span><label class="collapse" for="c-37638868">[-]</label><label class="expand" for="c-37638868">[4 more]</label></div><br/><div class="children"><div class="content">You have no ordering guarantees, so how can order be important? If 4 work items are scheduled on 4 independent workers, you have no guarantee which will start first or finish first.</div><br/><div id="37639080" class="c"><input type="checkbox" id="c-37639080" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37638868">parent</a><span>|</span><a href="#37637399">next</a><span>|</span><label class="collapse" for="c-37639080">[-]</label><label class="expand" for="c-37639080">[3 more]</label></div><br/><div class="children"><div class="content">The order matters in the sense that the 5th jobs should not be atempted before those 4.</div><br/><div id="37640467" class="c"><input type="checkbox" id="c-37640467" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37639080">parent</a><span>|</span><a href="#37639768">next</a><span>|</span><label class="collapse" for="c-37640467">[-]</label><label class="expand" for="c-37640467">[1 more]</label></div><br/><div class="children"><div class="content">Then I think what you actually care about is scheduling fairness, and a strict ordering of execution of job 5 after job 4 is unimportant.</div><br/></div></div><div id="37639768" class="c"><input type="checkbox" id="c-37639768" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37636973">root</a><span>|</span><a href="#37639080">parent</a><span>|</span><a href="#37640467">prev</a><span>|</span><a href="#37637399">next</a><span>|</span><label class="collapse" for="c-37639768">[-]</label><label class="expand" for="c-37639768">[1 more]</label></div><br/><div class="children"><div class="content">I think the order matter at least because you want to have some FIFO approximation, otherwise some tasks can forever stuck in queue and never be picked up.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37637399" class="c"><input type="checkbox" id="c-37637399" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#37636973">parent</a><span>|</span><a href="#37637364">prev</a><span>|</span><a href="#37638683">next</a><span>|</span><label class="collapse" for="c-37637399">[-]</label><label class="expand" for="c-37637399">[1 more]</label></div><br/><div class="children"><div class="content">batch inserts
process tasks in batches and it is pretty much webscale</div><br/></div></div></div></div><div id="37638683" class="c"><input type="checkbox" id="c-37638683" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#37636973">prev</a><span>|</span><a href="#37637508">next</a><span>|</span><label class="collapse" for="c-37638683">[-]</label><label class="expand" for="c-37638683">[23 more]</label></div><br/><div class="children"><div class="content">Skype used postgres as queue with a small plugin to process all their CDR many years ago. I have no idea if it used these days but it was &#x27;web scale&#x27;, 10 years ago. Just working, while people on the internet argued about using a database as a queue is an anti-pattern.<p>Having transactions is quite handy.<p><a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;SkyTools" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;SkyTools</a><p>I did a few talks on this at Sydpy as I used it at work quite a bit.
It&#x27;s handy when you already have postgresql running well and supported.<p>This said, I&#x27;d use a dedicated queue these days. Anything but RabbitMQ.</div><br/><div id="37639035" class="c"><input type="checkbox" id="c-37639035" checked=""/><div class="controls bullet"><span class="by">reubenbond</span><span>|</span><a href="#37638683">parent</a><span>|</span><a href="#37639350">next</a><span>|</span><label class="collapse" for="c-37639035">[-]</label><label class="expand" for="c-37639035">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Anything but RabbitMQ.<p>Would you mind elaborating on this? I&#x27;d be happy for others to chime in with their experiences&#x2F;opinions, too.</div><br/><div id="37639346" class="c"><input type="checkbox" id="c-37639346" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639035">parent</a><span>|</span><a href="#37639971">next</a><span>|</span><label class="collapse" for="c-37639346">[-]</label><label class="expand" for="c-37639346">[1 more]</label></div><br/><div class="children"><div class="content">The software works excellently in a development environment and performs well when running as a single instance. However, I encountered issues when scaling it up for high availability in a clustered setup. The system would fail inconsistently, with two masters consuming messages simultaneously, which wasn&#x27;t ideal for my use case. Eventually, I switched to Kafka and haven&#x27;t revisited the original solution since.<p>It&#x27;s worth noting that these issues might have been due to my improper configuration. Nevertheless, if the configuration process is fraught with pitfalls, that&#x27;s problematic in itself. I&#x27;ve had these experiences more than once.<p>Additionally, I found a critical race condition in the Python library, rendering it practically unusable for me. I submitted a bug report with a minimal example demonstrating the issue. I considered fixing it myself, but since using RabbitMQ wasn&#x27;t crucial for my project, I switched to ZeroMQ, which didn&#x27;t require a broker. The issue was acknowledged and fixed about a year later. At the time, I had to assume that nobody else was using the Python bindings.<p>Three years ago, I worked on a project that used the software for a Celery queue. Messages would occasionally go missing, although this could have been a configuration issue on our part. Ultimately, we replaced it with a Redis queue (not the best practice, I admit) and didn&#x27;t look back. This was for a lower-availability use case where a single instance of Redis sufficed.</div><br/></div></div><div id="37639971" class="c"><input type="checkbox" id="c-37639971" checked=""/><div class="controls bullet"><span class="by">boyter</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639035">parent</a><span>|</span><a href="#37639346">prev</a><span>|</span><a href="#37639584">next</a><span>|</span><label class="collapse" for="c-37639971">[-]</label><label class="expand" for="c-37639971">[1 more]</label></div><br/><div class="children"><div class="content">I used RabbitMQ for a while and nothing but problems.<p>Admittedly I probably shouldn&#x27;t have used it the way I did. I dumped many millions of tasks into it, then fanned out processes pulling from that queue that took a variable amount of time to run. Some ran in seconds, some hours.<p>I had picked RabbitMQ because I wanted that queue to be durable and resist workers dying, or being restarted. However long lived tasks like this is not really what it was designed for (in my opinion). I kept running into issues where it would take a long time to restart, and stop answering connections and need a restart to continue. I ended up having to write monitoring code to check for this and handle it to have it be slightly reliable.<p>Im sure it works well for smaller short lived messages, but considering the issues I bumped into I would be hesitant to try it. Id probably reach to redis first with wrappers allowing me to swap out to any other queue as required first.</div><br/></div></div><div id="37639584" class="c"><input type="checkbox" id="c-37639584" checked=""/><div class="controls bullet"><span class="by">phamilton</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639035">parent</a><span>|</span><a href="#37639971">prev</a><span>|</span><a href="#37639350">next</a><span>|</span><label class="collapse" for="c-37639584">[-]</label><label class="expand" for="c-37639584">[6 more]</label></div><br/><div class="children"><div class="content">I can share our experience with RabbitMQ&#x2F;SQS&#x2F;Sidekiq. Our two major issues have been around the retry mechanism and resource bottlenecks.<p>The key retry problem is &quot;What happens when a worker crashes?&quot;.<p>RabbitMQ solves this problem by tying &quot;unacknowledged messages&quot; to a tcp connection. If the connection dies, the in-flight messages are made available to other connections. This is a decent approach, but we hit a lot of issues with bugs in our code that would fail to acknowledge a message and the message would get stuck until that handler cycled. They&#x27;ve improved this over the past year or so with consumer timeouts, but we&#x27;ve already moved on.<p>The second problem we hit with RabbitMQ was that it uses one-erlang-process-per-queue and we found that big bursts of traffic could saturate a single CPU. There are ways to use sharded queues or re-architect to use dynamically created queues but the complexity led us towards SQS.<p>Sidekiq solves &quot;What happens when a worker crashes?&quot; by just not solving it. In the free version, those jobs are just lost. In Sidekiq Pro there are features that provide some guarantees that the jobs will not be lost, but no guarantees about when they will be processed (nor where they will be processed). Simply put, some worker sometime will see the orphaned job and decide to give it another shot. It&#x27;s not super common, but it is worse in containerized environments where memory limits can trigger the OOM killer and cause a worker to die immediately.<p>The other issue with Sidekiq has been a general lack of hard constraints around resources. A single event thread in redis means that when things go sideways it breaks everything. We&#x27;ve had errant jobs enqueued with 100MB of json and seen it jam things up badly when Sidekiq tries to parse that with a lua script (on the event thread). While it&#x27;s obvious that 100MB is too big to shove into a queue, mistakes happen and tools that limit the blast radius add a lot of value.<p>We&#x27;ve been leaning heavily on SQS the past few years and it is indeed Simple. It blocks us from doing even marginally dumb things (max message size of 256gb). The visibility timeout approach for handling crashing workers is easy to reason about. DLQ tooling has finally improved so you can redrive through standard aws  tools. There are some gaps we struggle with (e.g. firing callbacks when a set of messages are fully processed) but sometimes simple tools force you to simplify things on your end and that ends up being a good thing.</div><br/><div id="37641094" class="c"><input type="checkbox" id="c-37641094" checked=""/><div class="controls bullet"><span class="by">chucke</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639584">parent</a><span>|</span><a href="#37639826">next</a><span>|</span><label class="collapse" for="c-37641094">[-]</label><label class="expand" for="c-37641094">[1 more]</label></div><br/><div class="children"><div class="content">SQS limits you further in other ways. For instance, scheduled tasks are capped to 15m (delaySconds knob), so you&#x27;ll be stuck when implementing the &quot;cancel account if not verified in 7 days&quot; workflow. You&#x27;ll either reenqueue a message every 15m until its ready (and eat your the SQS costs), or build a bespoke solution only for scheduled tasks using some other store (the database usually) and another polling loop (at a fraction of the quality of any other OSS tool). This is a problem well solved by sidekiq, despite the other drawbacks you mention.<p>Bottom line, there is no silver bullet.</div><br/></div></div><div id="37639826" class="c"><input type="checkbox" id="c-37639826" checked=""/><div class="controls bullet"><span class="by">pqdbr</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639584">parent</a><span>|</span><a href="#37641094">prev</a><span>|</span><a href="#37639901">next</a><span>|</span><label class="collapse" for="c-37639826">[-]</label><label class="expand" for="c-37639826">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Sidekiq solves &quot;What happens when a worker crashes?&quot; by just not solving it. In the free version, those jobs are just lost.<p>I&#x27;ve been using Sidekiq for 11+ years in production and I&#x27;ve never seen this happen. Sidekiq (free version) has a very robust retry workflow. What are you talking about here?</div><br/><div id="37639867" class="c"><input type="checkbox" id="c-37639867" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639826">parent</a><span>|</span><a href="#37639901">next</a><span>|</span><label class="collapse" for="c-37639867">[-]</label><label class="expand" for="c-37639867">[1 more]</label></div><br/><div class="children"><div class="content">He is talking about the case when the worker itself die for some reason. It can be due to for example when the worker died due to using too much memory or if it hits a segfault or whatever.</div><br/></div></div></div></div><div id="37639901" class="c"><input type="checkbox" id="c-37639901" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639584">parent</a><span>|</span><a href="#37639826">prev</a><span>|</span><a href="#37639350">next</a><span>|</span><label class="collapse" for="c-37639901">[-]</label><label class="expand" for="c-37639901">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very insightful, thanks for sharing.<p>Do you have any experience with NATS, and how would you compare it to RMQ&#x2F;SQS?<p>The authors claim it guarantees exactly-once delivery with its JetStream component, and it looks very alluring from the documentation, but looks can be deceiving.</div><br/><div id="37639967" class="c"><input type="checkbox" id="c-37639967" checked=""/><div class="controls bullet"><span class="by">kureikain</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639901">parent</a><span>|</span><a href="#37639350">next</a><span>|</span><label class="collapse" for="c-37639967">[-]</label><label class="expand" for="c-37639967">[1 more]</label></div><br/><div class="children"><div class="content">It has multiple mode. One of them is explicitly acknowlede mode. If the worker finished process the job but doesn&#x27;t ack, the message will appear again.</div><br/></div></div></div></div></div></div></div></div><div id="37639350" class="c"><input type="checkbox" id="c-37639350" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#37638683">parent</a><span>|</span><a href="#37639035">prev</a><span>|</span><a href="#37639065">next</a><span>|</span><label class="collapse" for="c-37639350">[-]</label><label class="expand" for="c-37639350">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This said, I&#x27;d use a dedicated queue these days.<p>I agree, primary reason being that if you&#x27;re in the cloud (thus this applies to a lot of people but obviously not everyone), all the cloud providers have extremely easy to use, and <i>cheap</i>, hosted queueing tech. Even if you&#x27;re worried about vendor lockin, queueing primitives are so small (basically push and pop), that it&#x27;s relatively easy to write things in a way so it would be easy to migrate if necessary.</div><br/><div id="37639621" class="c"><input type="checkbox" id="c-37639621" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639350">parent</a><span>|</span><a href="#37639065">next</a><span>|</span><label class="collapse" for="c-37639621">[-]</label><label class="expand" for="c-37639621">[1 more]</label></div><br/><div class="children"><div class="content">Is it cheap if you already using Postgres though?</div><br/></div></div></div></div><div id="37639065" class="c"><input type="checkbox" id="c-37639065" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#37638683">parent</a><span>|</span><a href="#37639350">prev</a><span>|</span><a href="#37639125">next</a><span>|</span><label class="collapse" for="c-37639065">[-]</label><label class="expand" for="c-37639065">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Anything but RabbitMQ.<p>Bad experiences?  If so, was it the tech itself or surrounding stuff? (aka maybe docs, maybe community, etc)</div><br/></div></div><div id="37639125" class="c"><input type="checkbox" id="c-37639125" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37638683">parent</a><span>|</span><a href="#37639065">prev</a><span>|</span><a href="#37637508">next</a><span>|</span><label class="collapse" for="c-37639125">[-]</label><label class="expand" for="c-37639125">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Skype used postgres as queue with a small plugin to process all their CDR many years ago. I have no idea if it used these days but it was &#x27;web scale&#x27;, 10 years ago. Just working, while people on the internet argued about using a database as a queue is an anti-pattern.<p>It works great until it doesn&#x27;t, and the way it breaks puts you in a state that&#x27;s very difficult to recover from. And if your excuse for using a database as a queue was that you were already running a database, that cuts both ways: congratulations, your queue mess has now brought down your primary datastore too.</div><br/><div id="37639364" class="c"><input type="checkbox" id="c-37639364" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639125">parent</a><span>|</span><a href="#37639255">next</a><span>|</span><label class="collapse" for="c-37639364">[-]</label><label class="expand" for="c-37639364">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It works great until it doesn&#x27;t, and the way it breaks puts you in a state that&#x27;s very difficult to recover from.<p>This is similar to saying, &#x27;if I mess up all the tables in one database I wreck the rest&#x27;. Just my opinion, but this is not actually a thing in databases.<p>Maybe compromised the performance of one database due to another loading things up? I think database are developed with this as an important consideration. I can&#x27;t say I have seen this, but admit it&#x27;s a possibility.<p>Also, if you run one postgres, you won&#x27;t have of an issue running another if you have the experience in production.</div><br/><div id="37639401" class="c"><input type="checkbox" id="c-37639401" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639364">parent</a><span>|</span><a href="#37639255">next</a><span>|</span><label class="collapse" for="c-37639401">[-]</label><label class="expand" for="c-37639401">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is similar to saying, &#x27;if I mess up all the tables in one database I wreck the rest&#x27;. Just my opinion, but this is not actually a thing in databases.<p>If you mess up the tables in one database it doesn&#x27;t affect others, but if you lock up the server where it can&#x27;t respond to queries, that affects every database running on that server.<p>&gt; Also, if you run one postgres, you won&#x27;t have of an issue running another if you have the experience in production.<p>We&#x27;re talking about using a different feature that you presumably haven&#x27;t used before, so you won&#x27;t necessarily know about the admin side of that.</div><br/><div id="37639845" class="c"><input type="checkbox" id="c-37639845" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639401">parent</a><span>|</span><a href="#37639255">next</a><span>|</span><label class="collapse" for="c-37639845">[-]</label><label class="expand" for="c-37639845">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you mess up the tables in one database it doesn&#x27;t affect others, but if you lock up the server where it can&#x27;t respond to queries, that affects every database running on that server.<p>How is it different from: putting multiple queues on same redis, when one queue is locked up, others queue are affected?<p>If that&#x27;s a real risk, you can always put them into different instances.
The solution is exactly the same for redis or postgresql</div><br/></div></div></div></div></div></div><div id="37639255" class="c"><input type="checkbox" id="c-37639255" checked=""/><div class="controls bullet"><span class="by">dventimi</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639125">parent</a><span>|</span><a href="#37639364">prev</a><span>|</span><a href="#37639312">next</a><span>|</span><label class="collapse" for="c-37639255">[-]</label><label class="expand" for="c-37639255">[5 more]</label></div><br/><div class="children"><div class="content">I wonder if it would be possible to have more than just one PostgreSQL database.</div><br/><div id="37639352" class="c"><input type="checkbox" id="c-37639352" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639255">parent</a><span>|</span><a href="#37639312">next</a><span>|</span><label class="collapse" for="c-37639352">[-]</label><label class="expand" for="c-37639352">[4 more]</label></div><br/><div class="children"><div class="content">It is, but it comes with a lot of the same costs as having a PostgreSQL database and a proper queue system.</div><br/><div id="37639374" class="c"><input type="checkbox" id="c-37639374" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639352">parent</a><span>|</span><a href="#37639312">next</a><span>|</span><label class="collapse" for="c-37639374">[-]</label><label class="expand" for="c-37639374">[3 more]</label></div><br/><div class="children"><div class="content">No, you already know how to run and manager a postgres database.<p>If have you large teams, for sure, pick a proper queue that someone in the team knows well.</div><br/><div id="37639395" class="c"><input type="checkbox" id="c-37639395" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639374">parent</a><span>|</span><a href="#37639715">next</a><span>|</span><label class="collapse" for="c-37639395">[-]</label><label class="expand" for="c-37639395">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No, you already know how to run and manager a postgres database.<p>Well, maybe. Postgres is large and has lots of features. NOTIFY&#x2F;LISTEN is a distinct thing with its own quirks, and just because you&#x27;ve been running a postgres database up until now doesn&#x27;t mean you&#x27;re going to know about the admin side of these other features.</div><br/></div></div><div id="37639715" class="c"><input type="checkbox" id="c-37639715" checked=""/><div class="controls bullet"><span class="by">dventimi</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639374">parent</a><span>|</span><a href="#37639395">prev</a><span>|</span><a href="#37639312">next</a><span>|</span><label class="collapse" for="c-37639715">[-]</label><label class="expand" for="c-37639715">[1 more]</label></div><br/><div class="children"><div class="content">Now, you&#x27;re making a different argument.</div><br/></div></div></div></div></div></div></div></div><div id="37639312" class="c"><input type="checkbox" id="c-37639312" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#37638683">root</a><span>|</span><a href="#37639125">parent</a><span>|</span><a href="#37639255">prev</a><span>|</span><a href="#37637508">next</a><span>|</span><label class="collapse" for="c-37639312">[-]</label><label class="expand" for="c-37639312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; congratulations, your queue mess has now brought down your primary datastore too.<p>Just don&#x27;t put your queue tables&#x2F;logic in the same DB instance as your datastore. There are still <i>a lot</i> of benefits to using the same tech even if you have segregated instances.</div><br/></div></div></div></div></div></div><div id="37637508" class="c"><input type="checkbox" id="c-37637508" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#37638683">prev</a><span>|</span><a href="#37640827">next</a><span>|</span><label class="collapse" for="c-37637508">[-]</label><label class="expand" for="c-37637508">[4 more]</label></div><br/><div class="children"><div class="content">Few things.<p>1. The main downside to using PostgreSQL as a pub&#x2F;sub bus with LISTEN&#x2F;NOTIFY is that LISTEN is a session feature, making it incompatible with statement level connection pooling.<p>2. If you are going to do this use advisory locks [0].
Other forms of explicit locking put more pressure on the database while advisory locks are deliberately very lightweight.<p>My favorite example implementation is que [1] which is ported to several languages.<p>[0] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.html#ADVISORY-LOCKS" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;explicit-locking.htm...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;que-rb&#x2F;que">https:&#x2F;&#x2F;github.com&#x2F;que-rb&#x2F;que</a></div><br/><div id="37639068" class="c"><input type="checkbox" id="c-37639068" checked=""/><div class="controls bullet"><span class="by">MrPowerGamerBR</span><span>|</span><a href="#37637508">parent</a><span>|</span><a href="#37639397">next</a><span>|</span><label class="collapse" for="c-37639068">[-]</label><label class="expand" for="c-37639068">[2 more]</label></div><br/><div class="children"><div class="content">One reason that makes me dislike NOTIFY&#x2F;LISTEN is that issues with it are hard to diagnose.<p>Recently I had to stop using it because after a while all NOTIFY&#x2F;LISTENS would stop working, and only a database restart would fix the issue <a href="https:&#x2F;&#x2F;dba.stackexchange.com&#x2F;questions&#x2F;325104&#x2F;error-could-not-access-status-of-transaction-could-not-open-file-pg-xact-0029" rel="nofollow noreferrer">https:&#x2F;&#x2F;dba.stackexchange.com&#x2F;questions&#x2F;325104&#x2F;error-could-n...</a></div><br/><div id="37640862" class="c"><input type="checkbox" id="c-37640862" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#37637508">root</a><span>|</span><a href="#37639068">parent</a><span>|</span><a href="#37639397">next</a><span>|</span><label class="collapse" for="c-37640862">[-]</label><label class="expand" for="c-37640862">[1 more]</label></div><br/><div class="children"><div class="content">At my previous company, they switched from using NOTIFY&#x2F;LISTEN for Postgres notifications to a custom solution built on top of logical replication. As I understand it, part of the reason was reliability. I never touched that part of the code, but I believe the idea was to subscribe to logical replication updates and send out notifications based on these.</div><br/></div></div></div></div><div id="37639397" class="c"><input type="checkbox" id="c-37639397" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#37637508">parent</a><span>|</span><a href="#37639068">prev</a><span>|</span><a href="#37640827">next</a><span>|</span><label class="collapse" for="c-37639397">[-]</label><label class="expand" for="c-37639397">[1 more]</label></div><br/><div class="children"><div class="content">Is there a Node version of Que?</div><br/></div></div></div></div><div id="37640827" class="c"><input type="checkbox" id="c-37640827" checked=""/><div class="controls bullet"><span class="by">afhammad</span><span>|</span><a href="#37637508">prev</a><span>|</span><a href="#37637419">next</a><span>|</span><label class="collapse" for="c-37640827">[-]</label><label class="expand" for="c-37640827">[1 more]</label></div><br/><div class="children"><div class="content">There are a few mentions of Oban [1] here. Most people don&#x27;t realise that Oban in fact uses SKIP LOCKED [2] as well.<p>Oban&#x27;s been great, especially if you pay for Web UI and Pro for the extra features [3]<p>The main issue we&#x27;ve noticed though is that due to its simple fetching mechanism using locks, jobs aren&#x27;t distributed evenly across your workers due to the greedy `SELECT...LIMIT X` [2]<p>If you have long running and&#x2F;or resource intensive jobs, this can be problematic. Lets say you have 3 workers with a local limit of 10 per node. If there are only 10 jobs in the queue, the first node to fetch available jobs will grab and lock all 10, with the other 2 nodes sitting idle.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban">https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban&#x2F;blob&#x2F;main&#x2F;lib&#x2F;oban&#x2F;engines&#x2F;basic.ex#L86-L96">https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban&#x2F;blob&#x2F;main&#x2F;lib&#x2F;oban&#x2F;engines&#x2F;...</a>
[3] <a href="https:&#x2F;&#x2F;getoban.pro&#x2F;#feature-comparison" rel="nofollow noreferrer">https:&#x2F;&#x2F;getoban.pro&#x2F;#feature-comparison</a></div><br/></div></div><div id="37637419" class="c"><input type="checkbox" id="c-37637419" checked=""/><div class="controls bullet"><span class="by">5id</span><span>|</span><a href="#37640827">prev</a><span>|</span><a href="#37638333">next</a><span>|</span><label class="collapse" for="c-37637419">[-]</label><label class="expand" for="c-37637419">[10 more]</label></div><br/><div class="children"><div class="content">One of the biggest benefits imo of using Postgres as your application queue, is that any async work you schedule benefits from transactionality.<p>That is, say you have a relatively complex backend mutation that needs to schedule some async work (eg sending an email after signup). With a Postgres queue, if you insert the job to send the email and then in a later part of the transaction, something fails and the transaction rollbacks, the email is never queued to be sent.</div><br/><div id="37637846" class="c"><input type="checkbox" id="c-37637846" checked=""/><div class="controls bullet"><span class="by">theptip</span><span>|</span><a href="#37637419">parent</a><span>|</span><a href="#37637927">next</a><span>|</span><label class="collapse" for="c-37637846">[-]</label><label class="expand" for="c-37637846">[3 more]</label></div><br/><div class="children"><div class="content">Worth being clear that bridging to another non-idempotent system necessarily requires you to pick at-least-once or at-most-once semantics. So for emails, if you fail awaiting confirmation of your email you still need to pick between failing your transaction and potentially duplicating the email, or continuing and potentially dropping it.<p>The big advantage is for code paths which async modify your DB; these can be done fully transactionally with exactly-once semantics since the Job consumption and DB update are in the same transaction.</div><br/><div id="37638058" class="c"><input type="checkbox" id="c-37638058" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37637419">root</a><span>|</span><a href="#37637846">parent</a><span>|</span><a href="#37637927">next</a><span>|</span><label class="collapse" for="c-37638058">[-]</label><label class="expand" for="c-37638058">[2 more]</label></div><br/><div class="children"><div class="content">Email might never arrive, though. The only way to know they got it is to have them follow a link to confirm.</div><br/><div id="37639464" class="c"><input type="checkbox" id="c-37639464" checked=""/><div class="controls bullet"><span class="by">collinvandyck76</span><span>|</span><a href="#37637419">root</a><span>|</span><a href="#37638058">parent</a><span>|</span><a href="#37637927">next</a><span>|</span><label class="collapse" for="c-37639464">[-]</label><label class="expand" for="c-37639464">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kind of missing the parent&#x27;s point. If you wanted to ensure emails arrive, that sounds like another queue that could be backed by a different table that is also produced into as part of the original transaction.</div><br/></div></div></div></div></div></div><div id="37637927" class="c"><input type="checkbox" id="c-37637927" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#37637419">parent</a><span>|</span><a href="#37637846">prev</a><span>|</span><a href="#37640785">next</a><span>|</span><label class="collapse" for="c-37637927">[-]</label><label class="expand" for="c-37637927">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One of the biggest benefits imo of using Postgres as your application queue, is that any async work you schedule benefits from transactionality.<p>This is a really important point. I often end up using a combination of Postgres and SQS since SQS makes it easy to autoscale the job processing cluster.<p>In Postgres I have a transaction log table that includes columns for triggered events and the pg_current_xact_id() for the transaction. (You can also use the built in xmin of the row but then you have to worry about transaction wrap around.) Inserting into this row triggers a NOTIFY.<p>A background process runs in a loop. Selects all rows in the transaction table with a transaction id between the last run&#x27;s xmin and the current pg_snapshot_xmin(pg_current_snapshot()). Maps those events to jobs and submits them to SQS. Records the xmin. LISTEN&#x27;s to await the next NOTIFY.</div><br/></div></div><div id="37640785" class="c"><input type="checkbox" id="c-37640785" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37637419">parent</a><span>|</span><a href="#37637927">prev</a><span>|</span><a href="#37640619">next</a><span>|</span><label class="collapse" for="c-37640785">[-]</label><label class="expand" for="c-37640785">[1 more]</label></div><br/><div class="children"><div class="content">I agree - having to tell a database that something was processed, and fire off a message into RabbitMQ, say, is never 100% transactional. This would be my top reason to use this approach.<p>&gt; With a Postgres queue, if you insert the job to send the email and then in a later part of the transaction, something fails and the transaction rollbacks, the email is never queued to be sent.<p>This is true - definitely worth isolating what should be totally separate database code into different transactions. On the other hand, if your user is not created in the DB, you might not want your signup email. Just depends on the situation.</div><br/></div></div><div id="37640619" class="c"><input type="checkbox" id="c-37640619" checked=""/><div class="controls bullet"><span class="by">vb-8448</span><span>|</span><a href="#37637419">parent</a><span>|</span><a href="#37640785">prev</a><span>|</span><a href="#37637542">next</a><span>|</span><label class="collapse" for="c-37640619">[-]</label><label class="expand" for="c-37640619">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With a Postgres queue, if you insert the job to send the email and then in a later part of the transaction, something fails and the transaction rollbacks, the email is never queued to be sent.<p>An option could be use a second connection and a separate transaction to insert data in the queue table.</div><br/></div></div><div id="37637542" class="c"><input type="checkbox" id="c-37637542" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#37637419">parent</a><span>|</span><a href="#37640619">prev</a><span>|</span><a href="#37638233">next</a><span>|</span><label class="collapse" for="c-37637542">[-]</label><label class="expand" for="c-37637542">[1 more]</label></div><br/><div class="children"><div class="content">Good point. We alleviate that a bit by scheduling our queue adds to not run until after commit. But then we still have some unsafety, and if connection to rabbit is down we&#x27;re in trouble.</div><br/></div></div><div id="37638233" class="c"><input type="checkbox" id="c-37638233" checked=""/><div class="controls bullet"><span class="by">ryanbrunner</span><span>|</span><a href="#37637419">parent</a><span>|</span><a href="#37637542">prev</a><span>|</span><a href="#37638077">next</a><span>|</span><label class="collapse" for="c-37638233">[-]</label><label class="expand" for="c-37638233">[1 more]</label></div><br/><div class="children"><div class="content">Another benefit of this is that you&#x27;re guaranteed that the transaction is completed before the job is picked up. With redis-backed queues (or really anything else), you very quickly run into the situation where your queue executes a job depending on a database record existing prior to the transaction being committed (and the fix for this is usually awkward &#x2F; complex code).</div><br/></div></div><div id="37638077" class="c"><input type="checkbox" id="c-37638077" checked=""/><div class="controls bullet"><span class="by">__jem</span><span>|</span><a href="#37637419">parent</a><span>|</span><a href="#37638233">prev</a><span>|</span><a href="#37638333">next</a><span>|</span><label class="collapse" for="c-37638077">[-]</label><label class="expand" for="c-37638077">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure this is really an issue with transactionality as a single request can obviously be split up into multiple transactions, but rather that even if you correctly flag the email as pending&#x2F;errored, you either need to process these manually, or have some other kind of background task that looks for them, at which point why not just process them asynchronously.</div><br/></div></div></div></div><div id="37638333" class="c"><input type="checkbox" id="c-37638333" checked=""/><div class="controls bullet"><span class="by">vhiremath4</span><span>|</span><a href="#37637419">prev</a><span>|</span><a href="#37637667">next</a><span>|</span><label class="collapse" for="c-37638333">[-]</label><label class="expand" for="c-37638333">[6 more]</label></div><br/><div class="children"><div class="content">We used postgres for some of our queues back when we were at ~10 msg&#x2F;s. It scaled quite a bit, but, honestly, setting up SQS or some other queue stack in AWS, GCP, or Azure is so simple and purpose built for the task (with DL queues and the like built in), I don’t know why you wouldn’t just go that route and not have to worry about that system shitting the bed and affecting the rest of the DB’s health.<p>It seems foolish. I am a big fan of “use the dumbest tool”, but sometimes engineers take it too far and you’re left with the dumbest tool with caveats that don’t seem worth it given the mainstream alternative is relatively cheap and simple.</div><br/><div id="37638438" class="c"><input type="checkbox" id="c-37638438" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37638333">parent</a><span>|</span><a href="#37639897">next</a><span>|</span><label class="collapse" for="c-37638438">[-]</label><label class="expand" for="c-37638438">[2 more]</label></div><br/><div class="children"><div class="content">What I&#x27;ve settled on is &quot;store most job state in the DB, use task queues just to poke workers into working on the jobs&quot;.<p>Storing the job state in the DB means you can query state nicely. It&#x27;s not going to exactly show the state of things but it&#x27;s helpful for working through a live incident (especially when most job queues just delete records as work is processed).<p>And if you make all the background tasks idempotent anyways then you&#x27;re almost always safe with running a thing like &quot;send a job to the task queue to handle this job&quot;.<p>If you rely _just_ on message queues, there are a lot of times where you can have performance issues, yet have a lot of trouble knowing what&#x27;s going on (for example, rabbitMQ might tell you the size of your queues, but offer little-to-no inspection of the data inside them).</div><br/><div id="37639061" class="c"><input type="checkbox" id="c-37639061" checked=""/><div class="controls bullet"><span class="by">vhiremath4</span><span>|</span><a href="#37638333">root</a><span>|</span><a href="#37638438">parent</a><span>|</span><a href="#37639897">next</a><span>|</span><label class="collapse" for="c-37639061">[-]</label><label class="expand" for="c-37639061">[1 more]</label></div><br/><div class="children"><div class="content">Ultimately you have to figure out the separation of concerns of the job state and other core state. Ranging from “all state stored in message and will never become out of sync” to “no state stored in message and will never become out of sync”. In between you have “some state stored in db and some in message” and what I’ve found to be useful is keeping stuff in the db that needs to have high end state integrity (or as you said just making sure jobs are cancellable&#x2F;idempotent).<p>Tangible example:<p>We have a video transcoder queue. The state of the video model in our db can change as the video is being finalized in various ways. The transcoder generates thumbnails and assets from the video and also updates its state in the db. So we store job information in the message about what thumbnails we want to generate and the video ID but nothing else. This allows us to look up the video row, see if the same media was already transcoded from the video (and cancel the job), and, if not, run the job and update the video row.<p>Also (and I know you’re not saying this), but I’ve never understood the argument that keeping queues in Postgres leads to higher data integrity via transaction guarantees. The job is still running on another process outside of the db. The only time this could be true is if the job itself mostly updates state in the db, in which case it’s the small minority of queued workloads (with the majority needing to do non-db compute work).</div><br/></div></div></div></div><div id="37639897" class="c"><input type="checkbox" id="c-37639897" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#37638333">parent</a><span>|</span><a href="#37638438">prev</a><span>|</span><a href="#37638373">next</a><span>|</span><label class="collapse" for="c-37639897">[-]</label><label class="expand" for="c-37639897">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don’t know why you wouldn’t just go that route and not have to worry about that system shitting the bed<p>Because different software has different requirements. Not having an external service requirement other than Postgres might be a feature of an on-prem&#x2F;b2b appliance.<p>Because some software may be projected never outgrow the capabilities of Postgres, and if it does moving to another service can be made very easy.<p>Because you want a transitional job system and the simplicity of doing it in Postgres.</div><br/></div></div><div id="37638373" class="c"><input type="checkbox" id="c-37638373" checked=""/><div class="controls bullet"><span class="by">bicijay</span><span>|</span><a href="#37638333">parent</a><span>|</span><a href="#37639897">prev</a><span>|</span><a href="#37637667">next</a><span>|</span><label class="collapse" for="c-37638373">[-]</label><label class="expand" for="c-37638373">[2 more]</label></div><br/><div class="children"><div class="content">Transactions, data consistency. This is the answer that you will not find in SQS.</div><br/><div id="37639090" class="c"><input type="checkbox" id="c-37639090" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37638333">root</a><span>|</span><a href="#37638373">parent</a><span>|</span><a href="#37637667">next</a><span>|</span><label class="collapse" for="c-37639090">[-]</label><label class="expand" for="c-37639090">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t do better than At Least Once if you&#x27;re having side effects outside the database, so it&#x27;s not clear that SQS&#x27;s weaker semantics have any practical effect.</div><br/></div></div></div></div></div></div><div id="37637667" class="c"><input type="checkbox" id="c-37637667" checked=""/><div class="controls bullet"><span class="by">rubenfiszel</span><span>|</span><a href="#37638333">prev</a><span>|</span><a href="#37638458">next</a><span>|</span><label class="collapse" for="c-37637667">[-]</label><label class="expand" for="c-37637667">[1 more]</label></div><br/><div class="children"><div class="content">We use exactly this for windmill (OSS Retool alternative + modern airflow) and run benchmarks everyday. On a modest github CI instance where one windmill worker and postgres run as containers, our benchmarks run at 1200jobs&#x2F;s. Workers can be added and it will scale gracefully up to 5000jobs&#x2F;s. We are exploring using Citus to cross the barrier of 5000j&#x2F;s on our multi-tenant instance.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;windmill-labs&#x2F;windmill&#x2F;tree&#x2F;benchmarks">https:&#x2F;&#x2F;github.com&#x2F;windmill-labs&#x2F;windmill&#x2F;tree&#x2F;benchmarks</a></div><br/></div></div><div id="37638458" class="c"><input type="checkbox" id="c-37638458" checked=""/><div class="controls bullet"><span class="by">Ozzie_osman</span><span>|</span><a href="#37637667">prev</a><span>|</span><a href="#37637547">next</a><span>|</span><label class="collapse" for="c-37638458">[-]</label><label class="expand" for="c-37638458">[3 more]</label></div><br/><div class="children"><div class="content">One thing I love about Kafka is... It&#x27;s just an append-only log, and a client is essentially just holding an offset. This is conceptually very simple to reason about. It&#x27;s also persistent and pretty fault-tolerant (you can just go back and read any offset).<p>Unfortunately, Kafka carries with it enough complexity (due to the distributed nature) that it ends up not being worth it for most use-cases.<p>Personally I&#x27;d love something similar that&#x27;s easier to operate. You&#x27;d probably be able to handle hundreds (if not thousands) of events per second on a single node, and without distributed complexity it&#x27;d be really nice.<p>And yes, in theory you could still use postgres for this (and just never delete rows). And maybe that&#x27;s the answer.</div><br/><div id="37638471" class="c"><input type="checkbox" id="c-37638471" checked=""/><div class="controls bullet"><span class="by">valzam</span><span>|</span><a href="#37638458">parent</a><span>|</span><a href="#37637547">next</a><span>|</span><label class="collapse" for="c-37638471">[-]</label><label class="expand" for="c-37638471">[2 more]</label></div><br/><div class="children"><div class="content">Considering that you have a native &quot;offset&quot; (auto incrementing id) and the ability to partition by date I would say postgres is a great candidate for a simple Kafka replacement. It will also be significantly simpler to set up consumers if you don&#x27;t really need to whole consumer group, partition etc. functionality.</div><br/><div id="37639882" class="c"><input type="checkbox" id="c-37639882" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37638458">root</a><span>|</span><a href="#37638471">parent</a><span>|</span><a href="#37637547">next</a><span>|</span><label class="collapse" for="c-37639882">[-]</label><label class="expand" for="c-37639882">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately `serial` is not sufficient on it&#x27;s own for that use case. If you observe the values 1, 2, and 4, you can&#x27;t actually conclude whether 3 exists or not. That transaction may have failed after incrementing the serial, meaning 3 does not exist, or it may be an ongoing transaction which hasn&#x27;t yet committed, meaning 3 exists but is not yet visible to you.<p>So if you update your offset to 4 before the transaction for 3 commits, you&#x27;ll lose 3 forever (unless you control for this, eg by periodically detecting &amp; requeueing orphaned jobs, or by using a strictly serial&#x2F;gap free integer rather than the built in auto incrementing type).</div><br/></div></div></div></div></div></div><div id="37637547" class="c"><input type="checkbox" id="c-37637547" checked=""/><div class="controls bullet"><span class="by">scraplab</span><span>|</span><a href="#37638458">prev</a><span>|</span><a href="#37638390">next</a><span>|</span><label class="collapse" for="c-37637547">[-]</label><label class="expand" for="c-37637547">[1 more]</label></div><br/><div class="children"><div class="content">Yep, we process hundreds of thousands and sometimes a few million jobs daily inside Postgres, using Oban in Elixir.<p>Having transactional semantics around background jobs is incredibly convenient for things like scheduling email only if the transaction is successful, and so on.<p>You do need to do a little bit of autovacuum tuning, but once sorted it’s been great for us.</div><br/></div></div><div id="37638390" class="c"><input type="checkbox" id="c-37638390" checked=""/><div class="controls bullet"><span class="by">MattIPv4</span><span>|</span><a href="#37637547">prev</a><span>|</span><a href="#37640207">next</a><span>|</span><label class="collapse" for="c-37638390">[-]</label><label class="expand" for="c-37638390">[6 more]</label></div><br/><div class="children"><div class="content">We process around 1 million events a day using a queue like this in Postgres, and have processed over 400 million events since the system this is used in went live. Only issue we&#x27;ve had was slow queries due to the table size, as we keep an archive of all the events processed, but some scheduled vacuums every so often kept that under control.</div><br/><div id="37638675" class="c"><input type="checkbox" id="c-37638675" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#37638390">parent</a><span>|</span><a href="#37638882">next</a><span>|</span><label class="collapse" for="c-37638675">[-]</label><label class="expand" for="c-37638675">[3 more]</label></div><br/><div class="children"><div class="content">Active Queue table and then archive jobs to a JobDone table?  I do that. Queue table is small but archive goes back many months</div><br/><div id="37638871" class="c"><input type="checkbox" id="c-37638871" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37638390">root</a><span>|</span><a href="#37638675">parent</a><span>|</span><a href="#37638862">next</a><span>|</span><label class="collapse" for="c-37638871">[-]</label><label class="expand" for="c-37638871">[1 more]</label></div><br/><div class="children"><div class="content">In modern PG you can use partitioned table for a similar effect.</div><br/></div></div><div id="37638862" class="c"><input type="checkbox" id="c-37638862" checked=""/><div class="controls bullet"><span class="by">MattIPv4</span><span>|</span><a href="#37638390">root</a><span>|</span><a href="#37638675">parent</a><span>|</span><a href="#37638871">prev</a><span>|</span><a href="#37638882">next</a><span>|</span><label class="collapse" for="c-37638862">[-]</label><label class="expand" for="c-37638862">[1 more]</label></div><br/><div class="children"><div class="content">We just have a single table, with a column indicating if the job has been taken by a worker or not. Probably could get a bit more performance out of it by splitting into two tables, but it works as it is for now.</div><br/></div></div></div></div><div id="37638882" class="c"><input type="checkbox" id="c-37638882" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37638390">parent</a><span>|</span><a href="#37638675">prev</a><span>|</span><a href="#37640207">next</a><span>|</span><label class="collapse" for="c-37638882">[-]</label><label class="expand" for="c-37638882">[2 more]</label></div><br/><div class="children"><div class="content">Partial indexes might help.</div><br/><div id="37639494" class="c"><input type="checkbox" id="c-37639494" checked=""/><div class="controls bullet"><span class="by">emilsedgh</span><span>|</span><a href="#37638390">root</a><span>|</span><a href="#37638882">parent</a><span>|</span><a href="#37640207">next</a><span>|</span><label class="collapse" for="c-37639494">[-]</label><label class="expand" for="c-37639494">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. A partial index should make things fly here.</div><br/></div></div></div></div></div></div><div id="37640207" class="c"><input type="checkbox" id="c-37640207" checked=""/><div class="controls bullet"><span class="by">figassis</span><span>|</span><a href="#37638390">prev</a><span>|</span><a href="#37637151">next</a><span>|</span><label class="collapse" for="c-37640207">[-]</label><label class="expand" for="c-37640207">[2 more]</label></div><br/><div class="children"><div class="content">The way I implement my queues (usually as part of my monolith application) is as go routines. Each instance of the app launches with a unique id, and also a role. It can be a worker or the app itself. So when the app generates a queue item, it simply adds it to a table as pending. A worker will then, via transaction, update a set of items to add its instance id as well as an expiration for this lock. If that succeeds, no other worker will pull a queue item with a non null id or with an id different that it’s instance id that is not expired. Worker can then start processing and update item status accordingly. If it crashes, another worker will just repeat the process after the lock expires.<p>The code that does this is maybe 100 lines at most. It’s very effective especially if you deploy your app in kubernetes where you can expect instances to be ephemeral. It’s one of the components of my apps that has never needed any updates since I first wrote it circa 2017.</div><br/><div id="37640260" class="c"><input type="checkbox" id="c-37640260" checked=""/><div class="controls bullet"><span class="by">perfmode</span><span>|</span><a href="#37640207">parent</a><span>|</span><a href="#37637151">next</a><span>|</span><label class="collapse" for="c-37640260">[-]</label><label class="expand" for="c-37640260">[1 more]</label></div><br/><div class="children"><div class="content">How are workers notified of new work? Or do they poll and sleep?</div><br/></div></div></div></div><div id="37637151" class="c"><input type="checkbox" id="c-37637151" checked=""/><div class="controls bullet"><span class="by">levkk</span><span>|</span><a href="#37640207">prev</a><span>|</span><a href="#37637726">next</a><span>|</span><label class="collapse" for="c-37637151">[-]</label><label class="expand" for="c-37637151">[5 more]</label></div><br/><div class="children"><div class="content">Running this exact implementation with 47M jobs processed and counting. SKIP LOCKED is great for VACUUM, and having durable storage with indexes make otherwise expensive patterns like delayed jobs, retries, status updates, &quot;at least once&quot;, etc. really easy to implement.</div><br/><div id="37637342" class="c"><input type="checkbox" id="c-37637342" checked=""/><div class="controls bullet"><span class="by">dlisboa</span><span>|</span><a href="#37637151">parent</a><span>|</span><a href="#37637726">next</a><span>|</span><label class="collapse" for="c-37637342">[-]</label><label class="expand" for="c-37637342">[4 more]</label></div><br/><div class="children"><div class="content">Do you have some idea of how many jobs per minute or hour do you have? Just want to compare with what we have on Redis at work.<p>Do you also have any idea on the concurrency? How many workers you have pulling from Postgres.<p>I’ve used this approach before (ages ago) when Redis wasn’t even a thing, though not at high throughout requirements.</div><br/><div id="37637796" class="c"><input type="checkbox" id="c-37637796" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#37637151">root</a><span>|</span><a href="#37637342">parent</a><span>|</span><a href="#37638099">next</a><span>|</span><label class="collapse" for="c-37637796">[-]</label><label class="expand" for="c-37637796">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure Redis is much faster than an RDBMS w&#x2F; all the ACID features turned on.  The biggest concern I always have with Redis is simply overwhelming the in-memory storage limits when someone wants to do process a large number of good-sized messages at an inconvenient time.  #tradeoffs</div><br/></div></div><div id="37638099" class="c"><input type="checkbox" id="c-37638099" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#37637151">root</a><span>|</span><a href="#37637342">parent</a><span>|</span><a href="#37637796">prev</a><span>|</span><a href="#37639662">next</a><span>|</span><label class="collapse" for="c-37638099">[-]</label><label class="expand" for="c-37638099">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen it used for up to 1000 jobs per second with concurrency of 3-12</div><br/></div></div><div id="37639662" class="c"><input type="checkbox" id="c-37639662" checked=""/><div class="controls bullet"><span class="by">cle</span><span>|</span><a href="#37637151">root</a><span>|</span><a href="#37637342">parent</a><span>|</span><a href="#37638099">prev</a><span>|</span><a href="#37637726">next</a><span>|</span><label class="collapse" for="c-37639662">[-]</label><label class="expand" for="c-37639662">[1 more]</label></div><br/><div class="children"><div class="content">I recently did the same thing but without LISTEN&#x2F;NOTIFY and with a partial index. Pushed about 700 jobs&#x2F;sec with 1000 workers (via pgbouncer).</div><br/></div></div></div></div></div></div><div id="37637726" class="c"><input type="checkbox" id="c-37637726" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#37637151">prev</a><span>|</span><a href="#37637277">next</a><span>|</span><label class="collapse" for="c-37637726">[-]</label><label class="expand" for="c-37637726">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always surprised that when I see people talk about queues I never see anyone mention beanstalkd. I&#x27;ve been using it for basically everything for 10 years and it&#x27;s solid as a rock, incredibly simple and requires basically no maintenance. It Just Works™</div><br/><div id="37639843" class="c"><input type="checkbox" id="c-37639843" checked=""/><div class="controls bullet"><span class="by">arthurbrown</span><span>|</span><a href="#37637726">parent</a><span>|</span><a href="#37637277">next</a><span>|</span><label class="collapse" for="c-37639843">[-]</label><label class="expand" for="c-37639843">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used beanstalkd for personal projects previously with a similar experience to you.<p>For one such project, the message &#x27;priority&#x27; feature was a life saver and a feature that is not super common in competing solutions.</div><br/></div></div></div></div><div id="37637277" class="c"><input type="checkbox" id="c-37637277" checked=""/><div class="controls bullet"><span class="by">xdanger</span><span>|</span><a href="#37637726">prev</a><span>|</span><a href="#37639519">next</a><span>|</span><label class="collapse" for="c-37637277">[-]</label><label class="expand" for="c-37637277">[1 more]</label></div><br/><div class="children"><div class="content">I do enjoy using <a href="https:&#x2F;&#x2F;github.com&#x2F;graphile&#x2F;worker">https:&#x2F;&#x2F;github.com&#x2F;graphile&#x2F;worker</a> for my postgresql queuing needs. Very scalable, the next release 0.14 even more so, and easy to use.</div><br/></div></div><div id="37639519" class="c"><input type="checkbox" id="c-37639519" checked=""/><div class="controls bullet"><span class="by">zacksiri</span><span>|</span><a href="#37637277">prev</a><span>|</span><a href="#37637060">next</a><span>|</span><label class="collapse" for="c-37639519">[-]</label><label class="expand" for="c-37639519">[7 more]</label></div><br/><div class="children"><div class="content">During my tenure as CTO at a fintech company I built a banking engine using postgres backed queue system using Elixir &#x2F; Phoenix. It&#x27;s still in use today. The company processed large volumes of transactions and we were able to do things in real-time in terms of payments. Our system reached a point where I realized that we can scale almost infinitely just using a 2 tier architecture (Elixir &#x2F; Phoenix &#x2F; Oban and PostgreSQL)<p>The industry standard for real-time was anything under 30s end-to-end. We hit many scaling limits as our platform grew. We worked on improving the system instead of looking at postgresql as a problem. We measured and measured and postgresql was never the problem when it came to scaling. Most of the problems that existed was mostly due to design decisions in the system or some technical debt that needed to be solved. When we solved those problems the system flew.<p>There was one incident where our PostgreSQL instance CPU usage went up to 100% during peak hours and would cause problems in the system. We wondered why, there was a lot of debate around the topic, PostgreSQL doesn&#x27;t scale, we need a larger instance, or move to a dedicated queue system etc...<p>I didn&#x27;t believe the hypothesis that PostgreSQL didn&#x27;t scale. So I conducted a performance audit on the system myself I discovered one of the engineers forgot to add an index on one of the columns on a major table with &gt; 60m records. There was a lot of back and forth between engineers that discussed whether we should add the index. I simply conducted a small experiment and PG analyze clearly showed a missing index in one of the key tables. After we added a single line of code and deployed the index, during peak hours DB CPU usage would not even exceed 20% we had to scale down our DB to save some $$.<p>PostgreSQL backed queue system does work.<p>I&#x27;ve been building distributed systems in large and small scales for over a decade. Before building systems with Elixir &#x2F; Phoenix I also used to work with Rails where the default is as mentioned in this article is you just adopt Redis. While Redis does have additional overhead when it comes to management of the infrastructure, it also worked well.<p>Having been through both I&#x27;d say a simple PostgreSQL backed solution is the clear winner when it came to not having to manage a 3rd dependency when you already have a complex system. There was no 3rd or 4th piece of the puzzle to theorize hypothesize or experiment with. You just had 2 pieces it is either your application or your database that&#x27;s the problem. That simplicity saved us a lot of time for debate and doing experiments also squashed any dogmatic values and opinions that just didn&#x27;t hold any water.</div><br/><div id="37639819" class="c"><input type="checkbox" id="c-37639819" checked=""/><div class="controls bullet"><span class="by">SanderNL</span><span>|</span><a href="#37639519">parent</a><span>|</span><a href="#37640009">next</a><span>|</span><label class="collapse" for="c-37639819">[-]</label><label class="expand" for="c-37639819">[2 more]</label></div><br/><div class="children"><div class="content">Interesting how the immediate reaction is “postgres does not scale” when there is a single table lacking an index.<p>This also tells how important competence and knowledge of the system is. People that came in new and didn’t know the system like you do probably lacked the confidence&#x2F;skills to just “get in” like that.</div><br/><div id="37640271" class="c"><input type="checkbox" id="c-37640271" checked=""/><div class="controls bullet"><span class="by">zacksiri</span><span>|</span><a href="#37639519">root</a><span>|</span><a href="#37639819">parent</a><span>|</span><a href="#37640009">next</a><span>|</span><label class="collapse" for="c-37640271">[-]</label><label class="expand" for="c-37640271">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I think though what happened in this scenario probably happens a lot everywhere else also. In my entire career, this type of scenario is very typical. Lots of Meetings &#x2F; discussions, standups and talking uselessly without jumping in face to face with the actual problem. Things get in the way of the science and facts. Which is why it&#x27;s important to remove fear, think from first principles and break things down and get your hands dirty.</div><br/></div></div></div></div><div id="37640009" class="c"><input type="checkbox" id="c-37640009" checked=""/><div class="controls bullet"><span class="by">ansc</span><span>|</span><a href="#37639519">parent</a><span>|</span><a href="#37639819">prev</a><span>|</span><a href="#37637060">next</a><span>|</span><label class="collapse" for="c-37640009">[-]</label><label class="expand" for="c-37640009">[4 more]</label></div><br/><div class="children"><div class="content">&gt;There was a lot of back and forth between engineers that discussed whether we should add the index.<p>Jeez. What was the idea behind not adding? Disk space I presume?</div><br/><div id="37640258" class="c"><input type="checkbox" id="c-37640258" checked=""/><div class="controls bullet"><span class="by">zacksiri</span><span>|</span><a href="#37639519">root</a><span>|</span><a href="#37640009">parent</a><span>|</span><a href="#37640299">next</a><span>|</span><label class="collapse" for="c-37640258">[-]</label><label class="expand" for="c-37640258">[1 more]</label></div><br/><div class="children"><div class="content">There was a fear that having to create an index on a table that large would take a long time, and I think some of it was also ego &quot;I intentionally didn&#x27;t add it in, because so and so reason&quot;. This was why I dug in and did my thing, debunk all the fear &#x2F; opinions &#x2F; rationalization. Sometimes you just gotta be able to tell people they&#x27;re wrong supported with empirical evidence. That&#x27;s how the team will grow. There is just no need to dance around facts. I remember having to tell the team, &quot;taking a long time to run an index is no reason to avoid creating the index&quot;.</div><br/></div></div><div id="37640299" class="c"><input type="checkbox" id="c-37640299" checked=""/><div class="controls bullet"><span class="by">ezekiel68</span><span>|</span><a href="#37639519">root</a><span>|</span><a href="#37640009">parent</a><span>|</span><a href="#37640258">prev</a><span>|</span><a href="#37637060">next</a><span>|</span><label class="collapse" for="c-37640299">[-]</label><label class="expand" for="c-37640299">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; I simply conducted a small experiment and PG analyze clearly showed a missing index in one of the key tables.<p>Based on this sentence, I interpreted that part as representing that the engineers did not believe the missing index was causing the problem (until the experiment was run).</div><br/><div id="37640337" class="c"><input type="checkbox" id="c-37640337" checked=""/><div class="controls bullet"><span class="by">zacksiri</span><span>|</span><a href="#37639519">root</a><span>|</span><a href="#37640299">parent</a><span>|</span><a href="#37637060">next</a><span>|</span><label class="collapse" for="c-37640337">[-]</label><label class="expand" for="c-37640337">[1 more]</label></div><br/><div class="children"><div class="content">Yes, one of the theory was that the index wasn&#x27;t the problem because there was already a multi column index on that particular column. However the PG analyze tool showed some particular query didn&#x27;t utilize the index, so there needed to be a separate index just for that particular column.</div><br/></div></div></div></div></div></div></div></div><div id="37637060" class="c"><input type="checkbox" id="c-37637060" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#37639519">prev</a><span>|</span><a href="#37640645">next</a><span>|</span><label class="collapse" for="c-37637060">[-]</label><label class="expand" for="c-37637060">[1 more]</label></div><br/><div class="children"><div class="content">For running queues on Postgres with Node.js backend(s), I highly recommend <a href="https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss">https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss</a>. I&#x27;m sure it has it scale limits. But if you&#x27;re one of the 90% of the apps that never needs any kind of scale that a modern server can&#x27;t easily handle then it&#x27;s fantastic. You get transactional queueing of jobs, and it automatically handles syncing across multiple job processing servers using Postgres locks.</div><br/></div></div><div id="37640645" class="c"><input type="checkbox" id="c-37640645" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#37637060">prev</a><span>|</span><a href="#37637414">next</a><span>|</span><label class="collapse" for="c-37640645">[-]</label><label class="expand" for="c-37640645">[1 more]</label></div><br/><div class="children"><div class="content">The official JDBC driver for PostgreSQL provides no way for the database to push events to the client. So you need a dedicated connection to continuously poll the database to see if there are any events available. This seems half-baked and does not give me the warm and fuzzy feeling I crave when making architectural choices. Not to mention, it causes undesirable latency in event delivery unless I flood the database with queries.</div><br/></div></div><div id="37637414" class="c"><input type="checkbox" id="c-37637414" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37640645">prev</a><span>|</span><a href="#37638747">next</a><span>|</span><label class="collapse" for="c-37637414">[-]</label><label class="expand" for="c-37637414">[9 more]</label></div><br/><div class="children"><div class="content">USE. ADVISORY. LOCKS.<p>Do not use SKIP LOCKED unless it is a toy&#x2F;low throughout.<p>Row locks require transactions and disk writes.<p>Advisory locks require neither. (However, you do have to stay inside the configurable memory budget.)</div><br/><div id="37638014" class="c"><input type="checkbox" id="c-37638014" checked=""/><div class="controls bullet"><span class="by">sorentwo</span><span>|</span><a href="#37637414">parent</a><span>|</span><a href="#37637742">next</a><span>|</span><label class="collapse" for="c-37638014">[-]</label><label class="expand" for="c-37638014">[2 more]</label></div><br/><div class="children"><div class="content">To do anything safe and interesting you’ll need transactions. Using SKIP LOCKED won’t be your bottleneck, your application will. Job queues are about side effects and the rest of your application needs to keep up.<p>Oban is able to run over 1m jobs a minute, and the ultimate bottleneck is throttling in application code  to prevent thrashing the database: <a href="https:&#x2F;&#x2F;getoban.pro&#x2F;articles&#x2F;one-million-jobs-a-minute-with-oban" rel="nofollow noreferrer">https:&#x2F;&#x2F;getoban.pro&#x2F;articles&#x2F;one-million-jobs-a-minute-with-...</a></div><br/><div id="37638811" class="c"><input type="checkbox" id="c-37638811" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37637414">root</a><span>|</span><a href="#37638014">parent</a><span>|</span><a href="#37637742">next</a><span>|</span><label class="collapse" for="c-37638811">[-]</label><label class="expand" for="c-37638811">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true.<p>However in the <i>empty poll case</i>, you can avoid a transaction.</div><br/></div></div></div></div><div id="37637742" class="c"><input type="checkbox" id="c-37637742" checked=""/><div class="controls bullet"><span class="by">mikeocool</span><span>|</span><a href="#37637414">parent</a><span>|</span><a href="#37638014">prev</a><span>|</span><a href="#37637639">next</a><span>|</span><label class="collapse" for="c-37637742">[-]</label><label class="expand" for="c-37637742">[2 more]</label></div><br/><div class="children"><div class="content">Pretty common advice for scaling Postgres is to deploy pgbouncer in transaction mode in front of it to handle connection pooling.<p>Advisory locks don’t work in this setup (and will start behaving in strange ways if you do try to use them.) Something to consider if you go this route.</div><br/><div id="37637959" class="c"><input type="checkbox" id="c-37637959" checked=""/><div class="controls bullet"><span class="by">ris</span><span>|</span><a href="#37637414">root</a><span>|</span><a href="#37637742">parent</a><span>|</span><a href="#37637639">next</a><span>|</span><label class="collapse" for="c-37637959">[-]</label><label class="expand" for="c-37637959">[1 more]</label></div><br/><div class="children"><div class="content">Transaction-scoped advisory locks are very much a thing too.</div><br/></div></div></div></div><div id="37637639" class="c"><input type="checkbox" id="c-37637639" checked=""/><div class="controls bullet"><span class="by">ukd1</span><span>|</span><a href="#37637414">parent</a><span>|</span><a href="#37637742">prev</a><span>|</span><a href="#37638152">next</a><span>|</span><label class="collapse" for="c-37637639">[-]</label><label class="expand" for="c-37637639">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s changed in the last year or so, but from benchmarking and writing &#x2F; running queue software for Postgres - SKIP LOCKED was&#x2F;is significantly faster. Is that different for MySQL?</div><br/></div></div><div id="37638152" class="c"><input type="checkbox" id="c-37638152" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#37637414">parent</a><span>|</span><a href="#37637639">prev</a><span>|</span><a href="#37638747">next</a><span>|</span><label class="collapse" for="c-37638152">[-]</label><label class="expand" for="c-37638152">[3 more]</label></div><br/><div class="children"><div class="content">Not all use cases are high throughput. That’s not what makes it a toy</div><br/><div id="37638222" class="c"><input type="checkbox" id="c-37638222" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37637414">root</a><span>|</span><a href="#37638152">parent</a><span>|</span><a href="#37638747">next</a><span>|</span><label class="collapse" for="c-37638222">[-]</label><label class="expand" for="c-37638222">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Toy&#x2F;low throughput&quot; = &quot;Toy or low throughout&quot;</div><br/><div id="37639996" class="c"><input type="checkbox" id="c-37639996" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#37637414">root</a><span>|</span><a href="#37638222">parent</a><span>|</span><a href="#37638747">next</a><span>|</span><label class="collapse" for="c-37639996">[-]</label><label class="expand" for="c-37639996">[1 more]</label></div><br/><div class="children"><div class="content">Can you define &quot;low throughput&quot;? I think people have significantly different ideas of what that means.</div><br/></div></div></div></div></div></div></div></div><div id="37638747" class="c"><input type="checkbox" id="c-37638747" checked=""/><div class="controls bullet"><span class="by">codeadict</span><span>|</span><a href="#37637414">prev</a><span>|</span><a href="#37637643">next</a><span>|</span><label class="collapse" for="c-37638747">[-]</label><label class="expand" for="c-37638747">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly what the Oban <a href="https:&#x2F;&#x2F;getoban.pro&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;getoban.pro&#x2F;</a> Elixir library uses and combining postgres plus actors for queues scales pretty great for 90% of the needs out there. I have used it at my last few jobs at pretty decent scale and would take it over 10 years using Celery to manage queues + supervisord, setting up RabbitMQ or Redis. Its so simple you only need Elixir and Postgres and not 3 or 4 infrastructure pieces to manage a queue.</div><br/></div></div><div id="37637643" class="c"><input type="checkbox" id="c-37637643" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37638747">prev</a><span>|</span><a href="#37637626">next</a><span>|</span><label class="collapse" for="c-37637643">[-]</label><label class="expand" for="c-37637643">[6 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even need a database to make a message queue. The Linux file system makes a perfectly good basis for a message queue since file moves are atomic.<p>My guess is that many people are implementing queuing mechanisms just for sending email.<p>You can see how this works in Arnie SMTP buffer server, a super simple queue just for emails, no database at all, just the file system.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bootrino&#x2F;arniesmtpbufferserver">https:&#x2F;&#x2F;github.com&#x2F;bootrino&#x2F;arniesmtpbufferserver</a></div><br/><div id="37637748" class="c"><input type="checkbox" id="c-37637748" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37637643">parent</a><span>|</span><a href="#37637892">next</a><span>|</span><label class="collapse" for="c-37637748">[-]</label><label class="expand" for="c-37637748">[3 more]</label></div><br/><div class="children"><div class="content">This is true, and I’ve worked on systems that use this, but it’s a lot more work than just a rename.<p>I’d recommend that, if you have a Postgres database already, definitely use that instead. Your queues will be transactional and they will get backed up when the rest of your database does.</div><br/><div id="37637774" class="c"><input type="checkbox" id="c-37637774" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37637643">root</a><span>|</span><a href="#37637748">parent</a><span>|</span><a href="#37637892">next</a><span>|</span><label class="collapse" for="c-37637774">[-]</label><label class="expand" for="c-37637774">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; but it’s a lot more work than just a rename<p>Such as?</div><br/><div id="37638334" class="c"><input type="checkbox" id="c-37638334" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37637643">root</a><span>|</span><a href="#37637774">parent</a><span>|</span><a href="#37637892">next</a><span>|</span><label class="collapse" for="c-37638334">[-]</label><label class="expand" for="c-37638334">[1 more]</label></div><br/><div class="children"><div class="content">Well, if you have multiple writers then you need to decide who’s responsible for rotating the queues, and you need to serialise writes; or if each writer has its own queue then the reader has to do more work. And then you need to worry about fsync, and backup. And of course you need to be careful to flush to the queue after each write to avoid partial writes.<p>Basically I’m saying that there are just a number of potential footguns when using files as queues - I speak from experience! - which are trivially taken care of by a database, especially if you have one already.<p>I’m not saying that it’s not possible, just that for non trivial applications, it’s certainly more complex than just an atomic file move.</div><br/></div></div></div></div></div></div><div id="37637892" class="c"><input type="checkbox" id="c-37637892" checked=""/><div class="controls bullet"><span class="by">repiret</span><span>|</span><a href="#37637643">parent</a><span>|</span><a href="#37637748">prev</a><span>|</span><a href="#37637626">next</a><span>|</span><label class="collapse" for="c-37637892">[-]</label><label class="expand" for="c-37637892">[2 more]</label></div><br/><div class="children"><div class="content">That’s a key property leveraged in the Maildir mailbox format.</div><br/><div id="37638275" class="c"><input type="checkbox" id="c-37638275" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37637643">root</a><span>|</span><a href="#37637892">parent</a><span>|</span><a href="#37637626">next</a><span>|</span><label class="collapse" for="c-37638275">[-]</label><label class="expand" for="c-37638275">[1 more]</label></div><br/><div class="children"><div class="content">It was learning about this that led to me understanding file systems make perfectly acceptable queues.</div><br/></div></div></div></div></div></div><div id="37637626" class="c"><input type="checkbox" id="c-37637626" checked=""/><div class="controls bullet"><span class="by">ukd1</span><span>|</span><a href="#37637643">prev</a><span>|</span><a href="#37637005">next</a><span>|</span><label class="collapse" for="c-37637626">[-]</label><label class="expand" for="c-37637626">[1 more]</label></div><br/><div class="children"><div class="content">I maintain QueueClassic (<a href="https:&#x2F;&#x2F;github.com&#x2F;QueueClassic&#x2F;queue_classic">https:&#x2F;&#x2F;github.com&#x2F;QueueClassic&#x2F;queue_classic</a>) for Rails&#x2F;Ruby folks; which is basically what you&#x27;re talking about - a queuing system for Postgres. A bonus reason, and why I originally wanted this was the ability to use transactions fully - i.e. I can start one, do some stuff, add a job in to the queue (to send an email), .....and either commit, or roll back - avoiding sending the email. If you use resque, I found sometimes either you can&#x27;t see the record (still doing other stuff and it&#x27;s not committed), or it&#x27;s not there (rollback) - so either way you had to deal with it.<p>QC (and equivs) use the same db, and same connection, so same transaction. Saves quite a bit of cruft.</div><br/></div></div><div id="37637005" class="c"><input type="checkbox" id="c-37637005" checked=""/><div class="controls bullet"><span class="by">andrelaszlo</span><span>|</span><a href="#37637626">prev</a><span>|</span><a href="#37640479">next</a><span>|</span><label class="collapse" for="c-37637005">[-]</label><label class="expand" for="c-37637005">[2 more]</label></div><br/><div class="children"><div class="content">One issue with Redis as a queue backend seems to be that persistence is quite expensive, at least for managed Redis instances. Using PG seems like it could be much cheaper, especially if you already have an instance with room to spare.<p>I thought it was an interesting article, and I&#x27;d love to hear more from people using PG for queues in production (my intuition would say you&#x27;d get a lot of table bloat and&#x2F;or vacuum latency, but I haven&#x27;t tested it myself), but when it comes to the conclusion - &quot;choosing boring technology should be one’s default choice&quot;  - I can&#x27;t think of anything more boring (in a good sense, mostly) than Sidekiq + Redis for a Rails app.</div><br/><div id="37638071" class="c"><input type="checkbox" id="c-37638071" checked=""/><div class="controls bullet"><span class="by">pqdbr</span><span>|</span><a href="#37637005">parent</a><span>|</span><a href="#37640479">next</a><span>|</span><label class="collapse" for="c-37638071">[-]</label><label class="expand" for="c-37638071">[1 more]</label></div><br/><div class="children"><div class="content">Same here. Sidekiq + Rails in a Rails app is a powerhouse, simple and reliable, but I do worry about losing the queue in Redis. It would be great to have that in Postgres as well.</div><br/></div></div></div></div><div id="37640479" class="c"><input type="checkbox" id="c-37640479" checked=""/><div class="controls bullet"><span class="by">fasteo</span><span>|</span><a href="#37637005">prev</a><span>|</span><a href="#37639831">next</a><span>|</span><label class="collapse" for="c-37640479">[-]</label><label class="expand" for="c-37640479">[2 more]</label></div><br/><div class="children"><div class="content">Over the years I have used beanstalkd for all things queue. Working flawlessly every single time.<p>This is an output for our oldest instance (legacy system running Ubuntu 12)<p><pre><code>  Trying 127.0.0.1...
  Connected to localhost.
  Escape character is &#x27;^]&#x27;.
  stats
  OK 952
  ---
  current-jobs-urgent: 0
  current-jobs-ready: 765
  current-jobs-reserved: 2
  current-jobs-delayed: 946
  current-jobs-buried: 0
  cmd-put: 1188640739
  cmd-peek: 2718986
  cmd-peek-ready: 5052
  cmd-peek-delayed: 797
  cmd-peek-buried: 797
  cmd-reserve: 0
  cmd-reserve-with-timeout: 3245006799
  cmd-delete: 1188639093
  cmd-release: 43276760
  cmd-use: 1137988211
  cmd-watch: 166122
  cmd-ignore: 166077
  cmd-bury: 0
  cmd-kick: 1
  cmd-touch: 0
  cmd-stats: 1260
  cmd-stats-job: 43134828
  cmd-stats-tube: 53942209
  cmd-list-tubes: 3251625
  cmd-list-tube-used: 0
  cmd-list-tubes-watched: 0
  cmd-pause-tube: 988
  job-timeouts: 14084
  total-jobs: 1188640739
  max-job-size: 1048576
  current-tubes: 44
  current-connections: 63
  current-producers: 20
  current-workers: 47
  current-waiting: 41
  total-connections: 14996583
  pid: 3959
  version: 1.4.6
  rusage-utime: 170303.331293
  rusage-stime: 399435.543161
  uptime: 321658179
  binlog-oldest-index: 90539
  binlog-current-index: 90983
  binlog-max-size: 10485760</code></pre></div><br/></div></div><div id="37639831" class="c"><input type="checkbox" id="c-37639831" checked=""/><div class="controls bullet"><span class="by">AlexITC</span><span>|</span><a href="#37640479">prev</a><span>|</span><a href="#37637736">next</a><span>|</span><label class="collapse" for="c-37639831">[-]</label><label class="expand" for="c-37639831">[1 more]</label></div><br/><div class="children"><div class="content">I have been involved in a few projects using postgres-bakend queues for a few years, scale hasn&#x27;t been a problem so far.<p>On the other hand, I have done a few experiments with postgres LISTEN&#x2F;NOTIFY, while the feature seems nice at first glance, I concluded that it wasn&#x27;t worth it for our use cases, maybe it is different in other languages but in the JVM, you have to allocate 1-thread for polling these results, which also keeps a connection busy.<p>What I ended up doing is leveraging akka-stream to stream the queue data directly from the db, which makes it simple to define throttling rules, this is super simple and effective.</div><br/></div></div><div id="37637736" class="c"><input type="checkbox" id="c-37637736" checked=""/><div class="controls bullet"><span class="by">jjice</span><span>|</span><a href="#37639831">prev</a><span>|</span><a href="#37640400">next</a><span>|</span><label class="collapse" for="c-37637736">[-]</label><label class="expand" for="c-37637736">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve implemented queues with tables in RDBMSs a few times and it&#x27;s always great and usually all you need. Worried about future scale? Make a class to wrapper the queue with a decent interface and swap it for RabbitMQ or whatever you want down the road. Implementation stays opaque and you have an easy upgrade path later on.</div><br/></div></div><div id="37640400" class="c"><input type="checkbox" id="c-37640400" checked=""/><div class="controls bullet"><span class="by">foreigner</span><span>|</span><a href="#37637736">prev</a><span>|</span><a href="#37637023">next</a><span>|</span><label class="collapse" for="c-37640400">[-]</label><label class="expand" for="c-37640400">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in the market for a Postgres-backed queue system with client libraries in NodeJS _and_ Python. Clients in both languages need to be able to read and write from the queue. Can anybody suggest one?</div><br/></div></div><div id="37637023" class="c"><input type="checkbox" id="c-37637023" checked=""/><div class="controls bullet"><span class="by">jarofgreen</span><span>|</span><a href="#37640400">prev</a><span>|</span><a href="#37639157">next</a><span>|</span><label class="collapse" for="c-37637023">[-]</label><label class="expand" for="c-37637023">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’d love to see more neoq-like libraries for languages other than Go.<p>Python has Celery, but maybe the author is looking for more choice between brokers. <a href="https:&#x2F;&#x2F;docs.celeryq.dev&#x2F;en&#x2F;stable&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.celeryq.dev&#x2F;en&#x2F;stable&#x2F;index.html</a></div><br/></div></div><div id="37639157" class="c"><input type="checkbox" id="c-37639157" checked=""/><div class="controls bullet"><span class="by">LennyWhiteJr</span><span>|</span><a href="#37637023">prev</a><span>|</span><a href="#37637924">next</a><span>|</span><label class="collapse" for="c-37639157">[-]</label><label class="expand" for="c-37639157">[1 more]</label></div><br/><div class="children"><div class="content">In my Amazon team, we use PostgreSQL as a queue using skip-locked to implement transactional outbox pattern for our database inserts. People commenting &#x27;just use a queue&#x27; are totally missing the need for transactional consistency. I agree with the author, it&#x27;s an amazing tool and scales quite well.</div><br/></div></div><div id="37637924" class="c"><input type="checkbox" id="c-37637924" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#37639157">prev</a><span>|</span><label class="collapse" for="c-37637924">[-]</label><label class="expand" for="c-37637924">[1 more]</label></div><br/><div class="children"><div class="content">One of my favourite pieces of writing about worker queues is this by Brandur Leach:<p>Transactionally Staged Job Drains in Postgres - <a href="https:&#x2F;&#x2F;brandur.org&#x2F;job-drain" rel="nofollow noreferrer">https:&#x2F;&#x2F;brandur.org&#x2F;job-drain</a><p>It&#x27;s about the challenge of matching up transactions with queues - where you want a queue to be populated reliably if a transaction completes, and also reliably NOT be populated if it doesn&#x27;t.<p>Brandur&#x27;s pattern is to have an outgoing queue in a database table that gets updated as part of that transaction, and can then be separately drained to whatever queue system you like.</div><br/></div></div></div></div></div></div></div></body></html>