<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691226056198" as="style"/><link rel="stylesheet" href="styles.css?v=1691226056198"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://substrate.tools/blog/terraform-best-practices-for-reliability-at-any-scale">Terraform best practices for reliability at any scale</a> <span class="domain">(<a href="https://substrate.tools">substrate.tools</a>)</span></div><div class="subtext"><span>holoway</span> | <span>120 comments</span></div><br/><div><div id="37005911" class="c"><input type="checkbox" id="c-37005911" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#37006070">next</a><span>|</span><label class="collapse" for="c-37005911">[-]</label><label class="expand" for="c-37005911">[32 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s my #1 tip, most important:<p>Try to keep your stateful resources &#x2F; services in different &quot;stacks&quot; than your stateful things.<p>Absolutely 100% completely obvious, maybe too obvious? Because none of these guides ever mention it.<p>If you have state in a stack it becomes 10x more expensive and difficult to &quot;replace your way out of trouble&quot; (aka destroy and recreate as last resort). You want as much as possible in stateless, disposable stacks. DONT put that customer exposed bucket or DB in the same state&#x2F;stack as app server resources.<p>I don&#x27;t care about your folder structure, I care about what % of the infra I can reliably burn to the ground and replace using pipelines and no manual actions.</div><br/><div id="37008185" class="c"><input type="checkbox" id="c-37008185" checked=""/><div class="controls bullet"><span class="by">coryrc</span><span>|</span><a href="#37005911">parent</a><span>|</span><a href="#37005949">next</a><span>|</span><label class="collapse" for="c-37008185">[-]</label><label class="expand" for="c-37008185">[2 more]</label></div><br/><div class="children"><div class="content">You mean keep <i>stateless</i> separate from <i>stateful</i>?<p>Everyone else seems to be reading over the typo or I&#x27;m more confused than I thought.</div><br/><div id="37008219" class="c"><input type="checkbox" id="c-37008219" checked=""/><div class="controls bullet"><span class="by">wahnfrieden</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37008185">parent</a><span>|</span><a href="#37005949">next</a><span>|</span><label class="collapse" for="c-37008219">[-]</label><label class="expand" for="c-37008219">[1 more]</label></div><br/><div class="children"><div class="content">Yes</div><br/></div></div></div></div><div id="37005949" class="c"><input type="checkbox" id="c-37005949" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#37005911">parent</a><span>|</span><a href="#37008185">prev</a><span>|</span><a href="#37007227">next</a><span>|</span><label class="collapse" for="c-37005949">[-]</label><label class="expand" for="c-37005949">[21 more]</label></div><br/><div class="children"><div class="content">Is a &quot;stack&quot; here a (root) folder on which you&#x27;d do a &quot;terraform apply&quot;? I&#x27;ve never know what to call those, surely they aren&#x27;t &quot;modules&quot;.<p>And, so, you&#x27;re saying: try to have a separate deployment (stack then?) that contains the state, so you can wipe away everything else if you want to, without having to manage the state?</div><br/><div id="37005991" class="c"><input type="checkbox" id="c-37005991" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37005949">parent</a><span>|</span><a href="#37009197">next</a><span>|</span><label class="collapse" for="c-37005991">[-]</label><label class="expand" for="c-37005991">[19 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not exactly about the folder, the IaC from a single folder &#x2F; project can be instantiated in multiple places. Each time you do that, it has a unique state file, so I usually hear it referred to as a &quot;state&quot;. In cfn you can similarly deploy the same thing lots of times and each instantiation is called a &quot;stack&quot;, so stack&#x2F;state tend to get used inter-changeably.<p>And yes, that&#x27;s a succinct rephrasing.<p>When you first use iac it maybe seems logical to put your db and app server in the same &quot;thing&quot; (stack or state file) but now that thing is &quot;pet like&quot; and you have to take care of it forever. You can&#x27;t safely have a &quot;destroy&quot; action in your pipeline as a last resort.<p>If you put the stateful stuff in a separate stack you can freely modify the things in the stateless one with much less worry.</div><br/><div id="37006163" class="c"><input type="checkbox" id="c-37006163" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37005991">parent</a><span>|</span><a href="#37006818">next</a><span>|</span><label class="collapse" for="c-37006163">[-]</label><label class="expand" for="c-37006163">[16 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on this? I&#x27;ve never heard of this IAC structure and I&#x27;m trying to figure out what the benefit&#x2F;cons are. Maybe it&#x27;s just Friday and I&#x27;m checked out already.<p>If you run a terraform apply and only update microservices but you also have your dbs&#x2F;stateful things in the same stack&#x2F;app, you&#x27;re only updating the microservices so how would this affect the db&#x2F;stateful at all?<p>On the opposite end - I feel like there would be scenarios where I needed to update the stateful AND stateless services with the same terraform apply. Maybe I&#x27;m adding a new cluster and adding a db region&#x2F;replica&#x2F;securitygroup and that new cluster needs to point at the new db region.<p>In your scenario I would have updated microservices trying to reach out to a db in a region that doesn&#x27;t exist yet because I have to terraform apply two different stacks. How would you deal with a depends_on?<p>Maybe I&#x27;m misunderstanding this.</div><br/><div id="37006311" class="c"><input type="checkbox" id="c-37006311" checked=""/><div class="controls bullet"><span class="by">rcrowley</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006163">parent</a><span>|</span><a href="#37006983">next</a><span>|</span><label class="collapse" for="c-37006311">[-]</label><label class="expand" for="c-37006311">[13 more]</label></div><br/><div class="children"><div class="content">(Hi, I’m one of the authors of the article at the root of this thread.)<p>Considering your hypothetical stateless microservice change in the same root module as stateful services, problems arise when _someone else_ has merged changes that concern the stateful services, leaving you little room to apply your changes individually.<p>It’s also worth remembering that, even if a stateless service and a stateful service are managed in the same root module, applying changes is absolutely not atomic. Applying tightly coupled changes to two services “at the same time” is likely to result in brief service interruptions, even if everything returns to normal as soon as the whole changeset is applied.</div><br/><div id="37006403" class="c"><input type="checkbox" id="c-37006403" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006311">parent</a><span>|</span><a href="#37006983">next</a><span>|</span><label class="collapse" for="c-37006403">[-]</label><label class="expand" for="c-37006403">[12 more]</label></div><br/><div class="children"><div class="content">Ok I think we&#x27;re talking about two separate things here - you&#x27;re referencing a root module and not a &quot;stack&quot;, as in a stack is a full service&#x2F;application that uses multiple modules to deploy. Your db module, eks module, etc. All independent modules, not combined into one singular module. Say it&#x27;s sitting in the &#x2F;terraform&#x2F;app1&#x2F;services&#x2F;db(&amp;)app folders type of scenario.<p>I <i>think</i> you&#x27;re talking about putting stateful and stateless objects inside of a single module. So you&#x27;ve got &#x2F;terraform&#x2F;modules&#x2F;mybigapp&#x2F;main.tf that has your microservice + database inside of it.<p>If I&#x27;m right and that&#x27;s what you mean that&#x27;s really interesting I don&#x27;t think I&#x27;ve ever seen or done that but now I&#x27;m curious. I&#x27;m pretty sure I&#x27;ve never created an &quot;app1&quot; module with all of its resources.<p>Am I totally off here?</div><br/><div id="37006701" class="c"><input type="checkbox" id="c-37006701" checked=""/><div class="controls bullet"><span class="by">rcrowley</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006403">parent</a><span>|</span><a href="#37006761">prev</a><span>|</span><a href="#37006983">next</a><span>|</span><label class="collapse" for="c-37006701">[-]</label><label class="expand" for="c-37006701">[9 more]</label></div><br/><div class="children"><div class="content">I stuck with my typical term, root module, synonymous with how folks are using “stack” and “state” in various parts of this thread.<p>A module is any directory with Terraform code in it. A root module is one that has a configuration for how to store and lock Terraform state, providers, and possibly tfvars files. Both modules and root modules may reference other modules. You run `terraform init|plan|apply` in root modules.<p>I think my comment makes sense in that if you mix two services into the same root module (directly or via any amount of modules-instantiating-other-modules) you can end up with changes from two people affecting both services that you can’t easily sever.<p>Happy to clarify further if I’m still not addressing your original comment.</div><br/><div id="37006924" class="c"><input type="checkbox" id="c-37006924" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006701">parent</a><span>|</span><a href="#37006983">next</a><span>|</span><label class="collapse" for="c-37006924">[-]</label><label class="expand" for="c-37006924">[8 more]</label></div><br/><div class="children"><div class="content">@rcowley -- 
I&#x27;m going to preface this with I&#x27;m a Staff SRE at an adtech corp that does billions and have been a k8s and terraform contributor since 2015 (k8s 1.1 I forget the tf versions). I don&#x27;t mean this to brag I just want to set my experience expectation since I&#x27;m a random name on hn who you&#x27;d never know.<p>I think calling a service&#x2F;stack (or whatever, app, etc) a &quot;root module&quot; is a very, very confusing thing to do. Terraform has actual micro objects called modules. We work with them every day. I get how you could consider encompassing an entire chunk of terrafrom code that calls various modules a &quot;root module&quot;.. but I think this is just going to lead to absolute confusion to anyone not familiar with your terminology. I don&#x27;t know every TF conversation but I can&#x27;t think of a single time where I&#x27;ve heard root module in that context. Very good chance I&#x27;ve just missed those conversation and am ignorant to them.<p>I&#x27;m currently hiring SRE 2s and 3s so I&#x27;ve been interviewing lots of terraform writers and one of my tech questions is to ask someone what makes them to decide to write a terraform module and what type of modules they&#x27;ve written - it&#x27;s always ALBs, EKS, dbs, etc. components indepedently that go into creating a service&#x2F;stack. I&#x27;ve definitely not heard anyone mention that they write &quot;root modules&quot; in the sense of an entire service&#x2F;stack.<p>I don&#x27;t mean you&#x27;re right or wrong, maybe more people are aware of that verbage than I am. I just wanted to mention that in my personal case I think it&#x27;s confusing so I would assume that there are a lot of people in my shoes who would also be confused by it.</div><br/><div id="37009437" class="c"><input type="checkbox" id="c-37009437" checked=""/><div class="controls bullet"><span class="by">datatrashfire</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006924">parent</a><span>|</span><a href="#37007661">next</a><span>|</span><label class="collapse" for="c-37009437">[-]</label><label class="expand" for="c-37009437">[1 more]</label></div><br/><div class="children"><div class="content">Root module is the official terminology used in Hashicorps own documentation. That&#x27;s actually the term I&#x27;m most familiar with in my own experience.<p><a href="https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;language&#x2F;modules&#x2F;syntax" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;language&#x2F;modules&#x2F;s...</a><p>&gt; Every Terraform configuration has at least one module, known as its root module, which consists of the resources defined in the .tf files in the main working directory.</div><br/></div></div><div id="37007661" class="c"><input type="checkbox" id="c-37007661" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006924">parent</a><span>|</span><a href="#37009437">prev</a><span>|</span><a href="#37008555">next</a><span>|</span><label class="collapse" for="c-37007661">[-]</label><label class="expand" for="c-37007661">[2 more]</label></div><br/><div class="children"><div class="content">My 2ç as also a (very minor) terraform core, and numerous providers &amp; modules contributor, and user (also 2015 I think): I&#x27;ve never heard of &#x27;terraform stacks&#x27; before this thread, but &#x27;root module&#x27; makes perfect sense to me:<p>1) without the context of where the state is&#x2F;its contents, or estimating based on the resources&#x2F;style&#x2F;what&#x27;s variable vs. hardcoded, a &#x27;stack&#x27; (if you like) is indistinguishable from a module that&#x27;s to be used in someone else&#x27;s &#x27;stack&#x27;;<p>2) `path.root`</div><br/><div id="37007749" class="c"><input type="checkbox" id="c-37007749" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37007661">parent</a><span>|</span><a href="#37008555">next</a><span>|</span><label class="collapse" for="c-37007749">[-]</label><label class="expand" for="c-37007749">[1 more]</label></div><br/><div class="children"><div class="content">lol That&#x27;s interesting. I feel like all of the TACOS (spacelift, env0, atlantis) refer to stacks.<p>Thanks for your response It&#x27;s great to hear corroboration</div><br/></div></div></div></div><div id="37008555" class="c"><input type="checkbox" id="c-37008555" checked=""/><div class="controls bullet"><span class="by">firesteelrain</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006924">parent</a><span>|</span><a href="#37007661">prev</a><span>|</span><a href="#37007017">next</a><span>|</span><label class="collapse" for="c-37008555">[-]</label><label class="expand" for="c-37008555">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s always ALBs, EKS, dbs, etc. components indepedently that go into creating a service&#x2F;stack<p>More importantly, modules represent the DRY principles. We host them in our private Terraform registry and share between teams</div><br/></div></div><div id="37007017" class="c"><input type="checkbox" id="c-37007017" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006924">parent</a><span>|</span><a href="#37008555">prev</a><span>|</span><a href="#37006983">next</a><span>|</span><label class="collapse" for="c-37007017">[-]</label><label class="expand" for="c-37007017">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;language&#x2F;modules#the-root-module" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;language&#x2F;modules#t...</a> is what Terraform calls the module in the current directory, to distinguish it from child modules you might introduce.</div><br/><div id="37007165" class="c"><input type="checkbox" id="c-37007165" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37007017">parent</a><span>|</span><a href="#37006983">next</a><span>|</span><label class="collapse" for="c-37007165">[-]</label><label class="expand" for="c-37007165">[2 more]</label></div><br/><div class="children"><div class="content">Ok I may absolutely have the dumb today I appreciate the response. The way this is worded, because of this line - &quot;Modules are the main way to package and reuse resource configurations with Terraform.&quot; reads like - &quot;I have 10 golang apps, they all at a <i>minimum</i> use these same services, this is our &quot;golang root module&quot;. But some services might have more or less modules, ie service A uses redis, service B uses kafka without redis.<p>So in this verbiage, is every single &quot;stack&#x2F;app&quot; a &quot;root module&quot; and if one of them has a different database&#x2F;whatever module it&#x27;s just using different child modules and the child modules are the big differentiator?<p>Just to kind of prove the root-module argument I&#x27;m making here, this post in here is confused on calling a &quot;stack&quot; a module as well <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37005949">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37005949</a></div><br/><div id="37007856" class="c"><input type="checkbox" id="c-37007856" checked=""/><div class="controls bullet"><span class="by">rcrowley</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37007165">parent</a><span>|</span><a href="#37006983">next</a><span>|</span><label class="collapse" for="c-37007856">[-]</label><label class="expand" for="c-37007856">[1 more]</label></div><br/><div class="children"><div class="content">Glad we cleared up our terminology! I agree that “root module” risks ambiguity, just like you point out.<p>I just realized I never responded to the very last point in your original comment. I don’t have, and I don’t think Terraform has, a complete solution to dependencies between root modules. Fortunately, data sources will at least fail if they don’t find what they’re looking for. For me, these failures never come up in production since I’m never using `terraform destroy` there. It does come up in pre-production testing and that’s an area that seems rich with patterns and products on top of Terraform that are controlling order and dependence between root modules.<p>PS thanks for your work on Terraform and Kubernetes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37006983" class="c"><input type="checkbox" id="c-37006983" checked=""/><div class="controls bullet"><span class="by">linuxdude314</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006163">parent</a><span>|</span><a href="#37006311">prev</a><span>|</span><a href="#37006818">next</a><span>|</span><label class="collapse" for="c-37006983">[-]</label><label class="expand" for="c-37006983">[2 more]</label></div><br/><div class="children"><div class="content">You’re not wrong. You can achieve the same results using modules well.<p>It’s common for an entire environment for a whole biz unit or even company to be a single “stack”.<p>This pretty much only works if the “terraform apply” is centrally orchestrated I.e gitops is the only way to trigger the terraform run.</div><br/><div id="37007122" class="c"><input type="checkbox" id="c-37007122" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006983">parent</a><span>|</span><a href="#37006818">next</a><span>|</span><label class="collapse" for="c-37007122">[-]</label><label class="expand" for="c-37007122">[1 more]</label></div><br/><div class="children"><div class="content">Agree, it&#x27;s a complicated conversation because the tools support many different ways of working - and most of them can be made to work with different tradeoffs.<p>A team that e.g owns its own microservice IaC can absolutely maintain a setup long term with app &amp; db in the same state, it just requires care and love (it&#x27;s easier in some ways, it just doesn&#x27;t scale along certain dimensions).<p>Maybe you have other controls &#x2F; factors that can make it work for you.<p>But my experience is that as you split things across more teams or have more complicated IaC &quot;supply chains&quot; (eg teams supplying modules to each other or have lots of ppl working on different bits of the same thing) you need to look at ways to make things more foolproof, easier to support and give yourself as much &quot;wiggle room&quot; as possible for upgrades. At this point having state split out is very helpful (almost essential).<p>Because the terminology seems to be tripping up the conversation I&#x27;d be inclined to phrase it like this: a single &quot;terraform apply&quot; should be touching a precious, stateful stack or a disposable stateless stack and these should be clearly delineated. Ideally the stateful stacks should be as small as possible, as much stuff as possible should be in the stateless stacks.</div><br/></div></div></div></div></div></div><div id="37006818" class="c"><input type="checkbox" id="c-37006818" checked=""/><div class="controls bullet"><span class="by">waffletower</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37005991">parent</a><span>|</span><a href="#37006163">prev</a><span>|</span><a href="#37009891">next</a><span>|</span><label class="collapse" for="c-37006818">[-]</label><label class="expand" for="c-37006818">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s right, stacks can be instantiated across repos even depending upon the organization (both meanings of &#x27;organization&#x27; are valid here).</div><br/></div></div><div id="37009891" class="c"><input type="checkbox" id="c-37009891" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37005991">parent</a><span>|</span><a href="#37006818">prev</a><span>|</span><a href="#37009197">next</a><span>|</span><label class="collapse" for="c-37009891">[-]</label><label class="expand" for="c-37009891">[1 more]</label></div><br/><div class="children"><div class="content">what about prevent_destroy lifecycle?</div><br/></div></div></div></div><div id="37009197" class="c"><input type="checkbox" id="c-37009197" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37005949">parent</a><span>|</span><a href="#37005991">prev</a><span>|</span><a href="#37007227">next</a><span>|</span><label class="collapse" for="c-37009197">[-]</label><label class="expand" for="c-37009197">[1 more]</label></div><br/><div class="children"><div class="content">I have adopted the term &quot;Root Module&quot; vs &quot;Submodule&quot; because those line up with terraform&#x27;s own definitions, but I agree that they&#x27;re terribly, terribly named.</div><br/></div></div></div></div><div id="37007227" class="c"><input type="checkbox" id="c-37007227" checked=""/><div class="controls bullet"><span class="by">hansoolo</span><span>|</span><a href="#37005911">parent</a><span>|</span><a href="#37005949">prev</a><span>|</span><a href="#37006539">next</a><span>|</span><label class="collapse" for="c-37007227">[-]</label><label class="expand" for="c-37007227">[1 more]</label></div><br/><div class="children"><div class="content">Just stopped here because I had said XYZZY way too often in the last three hours xD</div><br/></div></div><div id="37006539" class="c"><input type="checkbox" id="c-37006539" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37005911">parent</a><span>|</span><a href="#37007227">prev</a><span>|</span><a href="#37008978">next</a><span>|</span><label class="collapse" for="c-37006539">[-]</label><label class="expand" for="c-37006539">[6 more]</label></div><br/><div class="children"><div class="content">Makes sense, but how do you connect the two so e.g. credentials from one are surfaced in the other?</div><br/><div id="37006635" class="c"><input type="checkbox" id="c-37006635" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006539">parent</a><span>|</span><a href="#37006654">next</a><span>|</span><label class="collapse" for="c-37006635">[-]</label><label class="expand" for="c-37006635">[2 more]</label></div><br/><div class="children"><div class="content">Use Data Sources to reference resources in a different state: <a href="https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;language&#x2F;data-sources" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;language&#x2F;data-sour...</a></div><br/><div id="37009928" class="c"><input type="checkbox" id="c-37009928" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006635">parent</a><span>|</span><a href="#37006654">next</a><span>|</span><label class="collapse" for="c-37009928">[-]</label><label class="expand" for="c-37009928">[1 more]</label></div><br/><div class="children"><div class="content">Ah - I didn&#x27;t think about that. Wrapping a remote call with a data source. Thanks.</div><br/></div></div></div></div><div id="37006654" class="c"><input type="checkbox" id="c-37006654" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006539">parent</a><span>|</span><a href="#37006635">prev</a><span>|</span><a href="#37006644">next</a><span>|</span><label class="collapse" for="c-37006654">[-]</label><label class="expand" for="c-37006654">[2 more]</label></div><br/><div class="children"><div class="content">terraform_remote_state<p>The root module can have outputs just like any other module. These outputs can be accessed from other stacks from the backend.<p>And if you use CDKTF the references are handled transparently.</div><br/><div id="37009934" class="c"><input type="checkbox" id="c-37009934" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37005911">root</a><span>|</span><a href="#37006654">parent</a><span>|</span><a href="#37006644">next</a><span>|</span><label class="collapse" for="c-37009934">[-]</label><label class="expand" for="c-37009934">[1 more]</label></div><br/><div class="children"><div class="content">Thanks - another good option! I seem to get slight shivers down my spine when I read terraform_remote_state, but I never actually used it, so I might be half-remembering an old opinionated blog post.</div><br/></div></div></div></div></div></div><div id="37008978" class="c"><input type="checkbox" id="c-37008978" checked=""/><div class="controls bullet"><span class="by">thwway23432</span><span>|</span><a href="#37005911">parent</a><span>|</span><a href="#37006539">prev</a><span>|</span><a href="#37006070">next</a><span>|</span><label class="collapse" for="c-37008978">[-]</label><label class="expand" for="c-37008978">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;stack&quot; nomenclature used here is jarring since it is unrepresented in Terraform HCL literature.<p>A CDK stack, (assuming that&#x27;s what is used here), would be loosely equivalent to a Terraform HCL module.</div><br/></div></div></div></div><div id="37006070" class="c"><input type="checkbox" id="c-37006070" checked=""/><div class="controls bullet"><span class="by">time0ut</span><span>|</span><a href="#37005911">prev</a><span>|</span><a href="#37006782">next</a><span>|</span><label class="collapse" for="c-37006070">[-]</label><label class="expand" for="c-37006070">[3 more]</label></div><br/><div class="children"><div class="content">I’ve been using Terragrunt [0] for the past three years to manage loosely coupled stacks of Terraform configurations. It allows you to compose separate configurations almost as easily as you compose modules within a configuration. Its got its own learning curve, but its a solid tool to have in the tool box.<p>Gruntwork is a really cool company that makes other tools in this space like Terratest [1]. Every module I write comes with Terratest powered integration tests. Nothing more satisfying than pushing a change, watching the pipeline run the test, and then automatically release a new version that I know works (or at least what I tested works).<p>[0] <a href="https:&#x2F;&#x2F;terragrunt.gruntwork.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;terragrunt.gruntwork.io&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;terratest.gruntwork.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;terratest.gruntwork.io&#x2F;</a></div><br/><div id="37009288" class="c"><input type="checkbox" id="c-37009288" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#37006070">parent</a><span>|</span><a href="#37006782">next</a><span>|</span><label class="collapse" for="c-37009288">[-]</label><label class="expand" for="c-37009288">[2 more]</label></div><br/><div class="children"><div class="content">They seem very insistent on keeping things DRY but not explaining why. Does Terraform tend to cause water leaks?</div><br/><div id="37009354" class="c"><input type="checkbox" id="c-37009354" checked=""/><div class="controls bullet"><span class="by">SgtBastard</span><span>|</span><a href="#37006070">root</a><span>|</span><a href="#37009288">parent</a><span>|</span><a href="#37006782">next</a><span>|</span><label class="collapse" for="c-37009354">[-]</label><label class="expand" for="c-37009354">[1 more]</label></div><br/><div class="children"><div class="content">DRY = Don’t Repeat Yourself.</div><br/></div></div></div></div></div></div><div id="37006782" class="c"><input type="checkbox" id="c-37006782" checked=""/><div class="controls bullet"><span class="by">waffletower</span><span>|</span><a href="#37006070">prev</a><span>|</span><a href="#37006133">next</a><span>|</span><label class="collapse" for="c-37006782">[-]</label><label class="expand" for="c-37006782">[1 more]</label></div><br/><div class="children"><div class="content">While combining the word &quot;best with &quot;Terraform&quot; in a sentence is more than likely to result in an oxymoron, it is  counter-productive not to attempt to organize and utilize terraform as elegantly and DRY as possible.  We interact with stacks (which we call projects typically) via Terragrunt and have a very large surface of modules as we do have a fair amount of infrastructure pieces. But we also try to expose Terraform infrastructure changes by use of Atlantis; though bulky, github does provide a reasonable means to dialogue and manage changes made by multiple teams.  The use of modules also helps us encapsulate infrastructure, and state problems are rare with these approaches, but the data sprawl inherent to Terraform is very unwieldy regardless of so called &quot;best&quot; practices.  The language features are weak, awkward and directly encourage repetition and specification bloat.  We have had some success via Data Sources to export logic outside of Terraform and provide much needed sanity when interacting with very verbose infrastructure such as Lake Formation.</div><br/></div></div><div id="37006133" class="c"><input type="checkbox" id="c-37006133" checked=""/><div class="controls bullet"><span class="by">thunfisch</span><span>|</span><a href="#37006782">prev</a><span>|</span><a href="#37007769">next</a><span>|</span><label class="collapse" for="c-37006133">[-]</label><label class="expand" for="c-37006133">[6 more]</label></div><br/><div class="children"><div class="content">We&#x27;re using Terragrunt with hundreds of AWS accounts and thousands of Terraform deployments&#x2F;states.<p>I&#x27;ll never want to do this without Terragrunt again. The suggested method of referencing remote states, and writing out the backends will fall apart instantly at that scale. It&#x27;s just way too brittle and unwieldy.<p>Terragrunt with some good defaults that will be included, and separated states for modules (which makes partial applies a breeze) as well as autogenerated backend configs (let Terragrunt inject it for you, with templated values) is the way to go.</div><br/><div id="37009887" class="c"><input type="checkbox" id="c-37009887" checked=""/><div class="controls bullet"><span class="by">rvdginste</span><span>|</span><a href="#37006133">parent</a><span>|</span><a href="#37006188">next</a><span>|</span><label class="collapse" for="c-37009887">[-]</label><label class="expand" for="c-37009887">[1 more]</label></div><br/><div class="children"><div class="content">We use a setup where we have multiple repos with Terraform configuration and thus multiple Terraform states. We then use Terraform remote state to link everything together. I am talking about 10-20 repos and states. Orthogonal to that, we use multiple workspaces to describe the infra in different environments.<p>The problems I have personally experienced with this approach are:<p>- if you update one of the root Terraform states, you need to execute a Terraform apply for every repo that depends on that Terraform state; developers do not do that because either they forget or they do know but are too lazy and subsequently are surprised that things are broken<p>- if you use workspaces for maintaining the infra in different environments, and certain components are only needed in specific environments, then the Terraform code becomes pretty ugly (using count which makes a single thing suddenly a list of things, which you then have to account for in the outputs which becomes very verbose)<p>Is Terragrunt something that would help us? I do not know Terragrunt, and a quick look at the website did not make that clear for me.</div><br/></div></div><div id="37006188" class="c"><input type="checkbox" id="c-37006188" checked=""/><div class="controls bullet"><span class="by">DelightOne</span><span>|</span><a href="#37006133">parent</a><span>|</span><a href="#37009887">prev</a><span>|</span><a href="#37006910">next</a><span>|</span><label class="collapse" for="c-37006188">[-]</label><label class="expand" for="c-37006188">[2 more]</label></div><br/><div class="children"><div class="content">Do you need to chain multiple Terragrunt executions to first bring the Kubernetes cluster up and then the containers, or does Terragrunt fix that?</div><br/><div id="37006572" class="c"><input type="checkbox" id="c-37006572" checked=""/><div class="controls bullet"><span class="by">miduil</span><span>|</span><a href="#37006133">root</a><span>|</span><a href="#37006188">parent</a><span>|</span><a href="#37006910">next</a><span>|</span><label class="collapse" for="c-37006572">[-]</label><label class="expand" for="c-37006572">[1 more]</label></div><br/><div class="children"><div class="content">Yes, with terragrunt you can do a `terragrunt run-all apply` and based on `output` to `variable` in each module data can be passed from one state&#x2F;module to the next one, terragrunt knows how to run them in the right order so you can bootstrap your EKS cluster by having one module which bootstraps the account, then another one which bootstraps EKS, then one that configures the cluster, installs your &quot;base pods&quot; and then later everything else.</div><br/></div></div></div></div><div id="37006910" class="c"><input type="checkbox" id="c-37006910" checked=""/><div class="controls bullet"><span class="by">ckdarby</span><span>|</span><a href="#37006133">parent</a><span>|</span><a href="#37006188">prev</a><span>|</span><a href="#37007769">next</a><span>|</span><label class="collapse" for="c-37006910">[-]</label><label class="expand" for="c-37006910">[2 more]</label></div><br/><div class="children"><div class="content">Have you spent any time with Pulumi?<p>I&#x27;ve kind of found terraform is dying and encourages a lot of bad practices but everyone agrees with them because HCL and it is transferable as most companies are just using TF.</div><br/><div id="37008466" class="c"><input type="checkbox" id="c-37008466" checked=""/><div class="controls bullet"><span class="by">RulerOf</span><span>|</span><a href="#37006133">root</a><span>|</span><a href="#37006910">parent</a><span>|</span><a href="#37007769">next</a><span>|</span><label class="collapse" for="c-37008466">[-]</label><label class="expand" for="c-37008466">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve kind of found terraform is dying<p>I don&#x27;t think it&#x27;s dying. The hype has worn off. Everybody uses it. It&#x27;s very mature. There&#x27;s a module for everything.<p>It&#x27;s just not new and sexy anymore IMO.</div><br/></div></div></div></div></div></div><div id="37007769" class="c"><input type="checkbox" id="c-37007769" checked=""/><div class="controls bullet"><span class="by">rcarr</span><span>|</span><a href="#37006133">prev</a><span>|</span><a href="#37005885">next</a><span>|</span><label class="collapse" for="c-37007769">[-]</label><label class="expand" for="c-37007769">[20 more]</label></div><br/><div class="children"><div class="content">Genuine question for DevOps people:<p>Other than the fact it seems to be an industry standard so it&#x27;s good for your job prospects, what are the benefits to Terraform over CloudFormation&#x2F;CDK or whatever the equivalent is for your particular cloud provider?<p>Most companies&#x2F;people pick a provider and then stick with it and it doesn&#x27;t seem like there&#x27;s much portability between configurations if you do decide to switch providers later down the line so I&#x27;m not sure what the benefits are. I haven&#x27;t delved into Terraform yet but I tried doing a project in Pulumi once and felt by the end of it that I might as well have just wrote it in AWS CDK directly.</div><br/><div id="37008644" class="c"><input type="checkbox" id="c-37008644" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37009376">next</a><span>|</span><label class="collapse" for="c-37008644">[-]</label><label class="expand" for="c-37008644">[2 more]</label></div><br/><div class="children"><div class="content">After you have waited 20 minutes for CloudFormation to fail and tell you that it can&#x27;t delete a resource (but won&#x27;t tell you why), and this is the third time it has happened in a week, you start looking at alternatives.</div><br/><div id="37009379" class="c"><input type="checkbox" id="c-37009379" checked=""/><div class="controls bullet"><span class="by">androidbishop</span><span>|</span><a href="#37007769">root</a><span>|</span><a href="#37008644">parent</a><span>|</span><a href="#37009376">next</a><span>|</span><label class="collapse" for="c-37009379">[-]</label><label class="expand" for="c-37009379">[1 more]</label></div><br/><div class="children"><div class="content">This 1000%.  Also recently discovered Google Deployment Manager is shit for the exact same reasons.  I honestly don&#x27;t get it.</div><br/></div></div></div></div><div id="37009376" class="c"><input type="checkbox" id="c-37009376" checked=""/><div class="controls bullet"><span class="by">androidbishop</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37008644">prev</a><span>|</span><a href="#37007851">next</a><span>|</span><label class="collapse" for="c-37009376">[-]</label><label class="expand" for="c-37009376">[3 more]</label></div><br/><div class="children"><div class="content">Terraform, and by extension HCL, is more powerful and flexible.  It can be used across clouds.  It has providers for all kinds of things, like kubernetes.  It can be abstracted and modularized.  It supports cool features like workspaces and junk, depending on how you want to use it.<p>Also recently I was forced to use Google Cloud Deployment Manager scripts for some legacy project we were migrating to Terraform, and I was shocked at how buggy and useless it was.  Failed to create resources for no discernible reason, couldn&#x27;t update existing resources with dependencies, couldn&#x27;t delete resources, was just unfathomably shit all around. Finished the Terraform migration earlier this morning and everything went off without a hitch, plus we got more coverage for stuff Deployment Manager doesn&#x27;t support.  It&#x27;s also organized much nicer now, with versioned modules and what-have-you.<p>Cloudformation is ugly and again, surprisingly isn&#x27;t well supported by AWS.  I don&#x27;t understand how it&#x27;s possible, but terraform providers seem to be more up to date with products and APIs.  Maybe that&#x27;s just me but I&#x27;ve seen others complain about the same thing.</div><br/><div id="37009457" class="c"><input type="checkbox" id="c-37009457" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#37007769">root</a><span>|</span><a href="#37009376">parent</a><span>|</span><a href="#37007851">next</a><span>|</span><label class="collapse" for="c-37009457">[-]</label><label class="expand" for="c-37009457">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t google cloud deployment just bash calls to the google cloud cli disguised as declarations by way of yaml?</div><br/><div id="37009921" class="c"><input type="checkbox" id="c-37009921" checked=""/><div class="controls bullet"><span class="by">androidbishop</span><span>|</span><a href="#37007769">root</a><span>|</span><a href="#37009457">parent</a><span>|</span><a href="#37007851">next</a><span>|</span><label class="collapse" for="c-37009921">[-]</label><label class="expand" for="c-37009921">[1 more]</label></div><br/><div class="children"><div class="content">Considering the fact that you can inject python code blocks, I kind of doubt it.  It also makes API calls that populates a dashboard with an inventory of resources created, so it seems to be more of an api wrapper like other IaC solutions.</div><br/></div></div></div></div></div></div><div id="37007851" class="c"><input type="checkbox" id="c-37007851" checked=""/><div class="controls bullet"><span class="by">Centigonal</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37009376">prev</a><span>|</span><a href="#37009250">next</a><span>|</span><label class="collapse" for="c-37007851">[-]</label><label class="expand" for="c-37007851">[1 more]</label></div><br/><div class="children"><div class="content">I worked closely with the folks that wrote our platform&#x27;s IaC, first in CDK, then in Terraform. I wrote a bit of CDK and zero TF myself, but here are some of the reasons we switched:<p>A big plus is that Terraform works outside of AWS land.<p>CDK is a nightmare to work with. You&#x27;re writing with programming-language syntax, which tempts you to write dynamic stuff - but everything  still compiles down to declarative CFN, which just makes the ergonomics feel limited. The L2 and L3 constructs have a lot of implicit defaults that came back to bite us later.<p>With CDK you get synth and deploy, which felt like a black box. Minor changes would do the same 8 minute long deploy process as large infrastructure refactors. Switching to TF significantly sped up our builds for minor commits. There might be a better way to do this with CDK (maybe deploying separate apps for each part of our infrastructure) and we may have just missed it.</div><br/></div></div><div id="37009250" class="c"><input type="checkbox" id="c-37009250" checked=""/><div class="controls bullet"><span class="by">nuker</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37007851">prev</a><span>|</span><a href="#37008152">next</a><span>|</span><label class="collapse" for="c-37009250">[-]</label><label class="expand" for="c-37009250">[1 more]</label></div><br/><div class="children"><div class="content">Im 10 years working with AWS. I strongly prefer Cloudformation, just separate things smartly between stacks. It has export&#x2F;import for stack outputs too. Just look at the “root module” mess in this discussion and you’ll get why.</div><br/></div></div><div id="37008152" class="c"><input type="checkbox" id="c-37008152" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37009250">prev</a><span>|</span><a href="#37009020">next</a><span>|</span><label class="collapse" for="c-37008152">[-]</label><label class="expand" for="c-37008152">[2 more]</label></div><br/><div class="children"><div class="content">- In the event that you <i>are</i> working with different cloud providers, Terraform is one thing to learn that then applies to all of them, as opposed to learning each provider&#x27;s bespoke infra-as-code offering.  Most companies stick to one PaaS&#x2F;IaaS, but individual personnel ain&#x27;t necessarily as limited over the courses of their careers.<p>- Not all cloud providers <i>have</i> an infra-as-code offering of their own in the first place (especially true with traditional server hosts), whereas pretty much every provider with some sort of API most likely has a Terraform provider implemented for it.<p>- Terraform providers include more than just PaaS&#x2F;IaaS providers &#x2F; server hosts; for example, my current job includes provisioning Datadog metrics and PagerDuty alerts alongside applications&#x27; AWS infra in the same per-app Terraform codebase, and a previous job entailed configuring Keycloak instances&#x2F;realms&#x2F;roles&#x2F;etc. via Terraform.</div><br/><div id="37009388" class="c"><input type="checkbox" id="c-37009388" checked=""/><div class="controls bullet"><span class="by">androidbishop</span><span>|</span><a href="#37007769">root</a><span>|</span><a href="#37008152">parent</a><span>|</span><a href="#37009020">next</a><span>|</span><label class="collapse" for="c-37009388">[-]</label><label class="expand" for="c-37009388">[1 more]</label></div><br/><div class="children"><div class="content">Also pretty neat that there&#x27;s a Terraform provider for Kubernetes native resources.</div><br/></div></div></div></div><div id="37009020" class="c"><input type="checkbox" id="c-37009020" checked=""/><div class="controls bullet"><span class="by">Illotus</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37008152">prev</a><span>|</span><a href="#37008259">next</a><span>|</span><label class="collapse" for="c-37009020">[-]</label><label class="expand" for="c-37009020">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Other than the fact it seems to be an industry standard so it&#x27;s good for your job prospects, what are the benefits to Terraform over CloudFormation&#x2F;CDK or whatever the equivalent is for your particular cloud provider?<p>For me the killer feature is that both plan and apply show the actual diff of changes vs running infrastructure. It makes understanding effects of changes much easier.</div><br/></div></div><div id="37008259" class="c"><input type="checkbox" id="c-37008259" checked=""/><div class="controls bullet"><span class="by">dgrin91</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37009020">prev</a><span>|</span><a href="#37008515">next</a><span>|</span><label class="collapse" for="c-37008259">[-]</label><label class="expand" for="c-37008259">[1 more]</label></div><br/><div class="children"><div class="content">Companies choose providers and tend to stick with them, but people don&#x27;t always stick with companies. If I know TF there is a decent chance my skills will be applicable when I change companies.<p>Also some big corps run their own internal datacenters and have cloud-like interfaces with them. You can write TF providers for that (its not going to be as nice as the public cloud ones, but still nice). Then you can utilize Terraforms multi-provider functionality to have 1 project manage deployments on multiple clouds that include on-prem.<p>Also terraforms multi-provider functionality is also useful for non aws&#x2F;azure&#x2F;gcp such as Cloudflare. As far as I know CDK does not support that.</div><br/></div></div><div id="37008515" class="c"><input type="checkbox" id="c-37008515" checked=""/><div class="controls bullet"><span class="by">RulerOf</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37008259">prev</a><span>|</span><a href="#37007852">next</a><span>|</span><label class="collapse" for="c-37008515">[-]</label><label class="expand" for="c-37008515">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got a lot of opinions here, but the only one I&#x27;ll share is that HCL knocks the socks off of json and yaml. Json is too rigid. YAML is too nested. HCL gets this just right.<p>Venturing away from opinions, the provider ecosystem with terraform enables some wonderful design options. For example, I have a module template that takes some basic container configs (e.g. ports, healthchecks) and a GitHub URL, then stands the service up on ECS <i>and</i> configures CI in the linked repo. CF can&#x27;t do that.</div><br/></div></div><div id="37007852" class="c"><input type="checkbox" id="c-37007852" checked=""/><div class="controls bullet"><span class="by">thedougd</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37008515">prev</a><span>|</span><a href="#37007806">next</a><span>|</span><label class="collapse" for="c-37007852">[-]</label><label class="expand" for="c-37007852">[2 more]</label></div><br/><div class="children"><div class="content">Providers I regularly use, even mixed in a single project. There are others I could use if they were available.<p>AWS
GitHub
Opsgenie
Okta
Scalr
TLS
DNS</div><br/><div id="37007871" class="c"><input type="checkbox" id="c-37007871" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#37007769">root</a><span>|</span><a href="#37007852">parent</a><span>|</span><a href="#37007806">next</a><span>|</span><label class="collapse" for="c-37007871">[-]</label><label class="expand" for="c-37007871">[1 more]</label></div><br/><div class="children"><div class="content">You forgot the greatest escape hatch of all: null</div><br/></div></div></div></div><div id="37007806" class="c"><input type="checkbox" id="c-37007806" checked=""/><div class="controls bullet"><span class="by">jahsome</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37007852">prev</a><span>|</span><a href="#37010028">next</a><span>|</span><label class="collapse" for="c-37007806">[-]</label><label class="expand" for="c-37007806">[1 more]</label></div><br/><div class="children"><div class="content">Third-party integrations and the universality&#x2F;reusability across multiple products and familiarity of HCL are big for me.</div><br/></div></div><div id="37010028" class="c"><input type="checkbox" id="c-37010028" checked=""/><div class="controls bullet"><span class="by">cwp</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37007806">prev</a><span>|</span><a href="#37008739">next</a><span>|</span><label class="collapse" for="c-37010028">[-]</label><label class="expand" for="c-37010028">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s subtle and so difficult to see the differences at smaller scales. If you&#x27;re going to provision a handful of EC2 instances, all the tools work fine.<p>I think HCL is an under appreciated aspect of Terraform. It was kinda awful for a while, but it&#x27;s gotten a lot better and much easier to work with. It hits a sweet spot between data languages like JSON and YAML and fully-general programming languages like Python.<p>Take CloudFormation. The &quot;native&quot; language is JSON, and they&#x27;ve added YAML support for better ergonomics. But JSON is just not expressive enough. You end up with &quot;pseudoparameters&quot; and &quot;function calls&quot; layered on top. Attribute names doubling as type declarations, deeply nested layers of structure and incredible amounts of repetitious complexity just to be able to express all the details need to handle even moderate amounts of infrastructure.<p>So, ok, AWS recognizes this and they provide CDK so you can wring out all the repetion using a real programming language - pick your favourite one, a bunch are supported. That helps some, but now you&#x27;ve got the worst of both worlds. It&#x27;s not &quot;just JSON&quot; anymore. You need a full programming environment. The CDK, let&#x27;s say the Python version, has to run on the right interpreter. It has a lot of package dependencies, and you&#x27;ll probably want to run it in a virtualenv, or maybe a container. And it&#x27;s got the full power of Python, so you might have sources of non-determinism that give you subtle errors and bugs. Maybe it&#x27;s daylight saving gotchas or hidden dependencies on data that it pulls in from the net. This can sound paranoid, but these things do start to bite if you have enough scale and enough time.<p>And then, all that Python code is just a front end to the JSON, so you get some insulation from it, but sometimes you&#x27;re going to have to reason about the JSON it&#x27;s producing.<p>HCL, despite its warts, avoids the problems with these extremes. It&#x27;s enough of a programming language that you can just use named, typed variables to deal with configuration, instead of all the { &quot;Fn::GetAtt&quot; : [&quot;ObjectName&quot;, &quot;AttName&quot;] } nonsense that CloudFormation will put you through. And the ability to create modules that can call each other is sooo important for wringing out all the repetition that these configurations seem to generate.<p>On the other hand, it&#x27;s not fully general, so you don&#x27;t have to deal with things like loops, recursion, and so on. This lack of power in the language enables more power in the tools. Things like the plan&#x2F;apply distinction, automatically tracking dependencies between resources, targeting specific resources, move blocks etc. would be difficult or impossible with a language as powerful as Python.<p>HCL isn&#x27;t the only language in this space - see CUE and Dhall, for example - but it&#x27;s undoubtedly the most widely used. And it makes a real difference in practice.</div><br/></div></div><div id="37008739" class="c"><input type="checkbox" id="c-37008739" checked=""/><div class="controls bullet"><span class="by">333throwaway342</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37010028">prev</a><span>|</span><a href="#37007816">next</a><span>|</span><label class="collapse" for="c-37008739">[-]</label><label class="expand" for="c-37008739">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Most companies&#x2F;people pick a provider and then stick with it and it doesn&#x27;t seem like there&#x27;s much portability between configurations if you do decide to switch providers later down the line so I&#x27;m not sure what the benefits are.<p>This smells like kubernetes<p>&gt; Terraform over CloudFormation&#x2F;CDK<p>They both work. It&#x27;s more about which providers you need.</div><br/></div></div><div id="37007816" class="c"><input type="checkbox" id="c-37007816" checked=""/><div class="controls bullet"><span class="by">x3n0ph3n3</span><span>|</span><a href="#37007769">parent</a><span>|</span><a href="#37008739">prev</a><span>|</span><a href="#37005885">next</a><span>|</span><label class="collapse" for="c-37007816">[-]</label><label class="expand" for="c-37007816">[2 more]</label></div><br/><div class="children"><div class="content">I have used both terraform and cloudformation substantially and they each have pros and cons. One thing terraform has over cloudformation is its rapid support for new services and features. AWS has done an awful job ensuring that cloudformation support is part of each team&#x27;s definition of &quot;done&quot; for each release. It just doesn&#x27;t get the support it really needs from AWS.</div><br/><div id="37007860" class="c"><input type="checkbox" id="c-37007860" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#37007769">root</a><span>|</span><a href="#37007816">parent</a><span>|</span><a href="#37005885">next</a><span>|</span><label class="collapse" for="c-37007860">[-]</label><label class="expand" for="c-37007860">[1 more]</label></div><br/><div class="children"><div class="content">CloudFormation is the ugly step child of AWS. It has bugs that have languished for <i>years</i></div><br/></div></div></div></div></div></div><div id="37005885" class="c"><input type="checkbox" id="c-37005885" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37007769">prev</a><span>|</span><a href="#37005760">next</a><span>|</span><label class="collapse" for="c-37005885">[-]</label><label class="expand" for="c-37005885">[1 more]</label></div><br/><div class="children"><div class="content">This was a good read but really if you already follow the common best practices of IAC&#x2F;terraform&#x2F;aws multi-account I don&#x27;t think you&#x27;re going to learn much.<p>The comments in here kind of made me think I was going to hop in and take away some huge wins I hadn&#x27;t considered. But I have been working with Terraform and AWS for a very long time.<p>If you&#x27;re unfamiliar with AWS multi-account best practices this is a good read.<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;organizations&#x2F;getting-started&#x2F;best-practices&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;organizations&#x2F;getting-started&#x2F;best-pr...</a></div><br/></div></div><div id="37005760" class="c"><input type="checkbox" id="c-37005760" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#37005885">prev</a><span>|</span><a href="#37006180">next</a><span>|</span><label class="collapse" for="c-37005760">[-]</label><label class="expand" for="c-37005760">[23 more]</label></div><br/><div class="children"><div class="content">Sorry if this comes across weird or snotty it’s not supposed to.<p>But I’m coming at this from a GCP lens and got half way through the article about how the recommended unit of isolation in the AWS environment is entirely different AWS accounts and I’m kind of hung up on that. Is that really a thing people tend to do often? Doesn’t it get super unwieldy? How does billing work? What about identity? I have so many questions.<p>EDIT: Despite the fact that the root resource in both GCP and AWS is an organization, when I heard “account” I mistook that to be AWS terminology for an organization.</div><br/><div id="37005850" class="c"><input type="checkbox" id="c-37005850" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005760">parent</a><span>|</span><a href="#37005788">next</a><span>|</span><label class="collapse" for="c-37005850">[-]</label><label class="expand" for="c-37005850">[12 more]</label></div><br/><div class="children"><div class="content">The way this works with AWS is similar to you making a GCP project.<p>At the top level you have an organization account, which is where billing occurs.<p>From this org account you create accounts for the following (typically):<p>1. Security - AKA the account your USERS are in
2. Ops - The account your monitoring, etc are in<p>From here where a lot of people seem to deviate (I&#x27;ve been interviewing level 2-3 SREs for the last 3 weeks and have heard all about different AWS structures that I don&#x27;t like) is how to break up your applications into their own accounts for a low blast radius.<p>What I DO, and is well known as being the best practice, is to create an AWS account for each environment of each application.<p>App1-sandbox
App1-staging
App1-production<p>Then your terraform is also structure by application&#x2F;environment&#x2F;service. Each environment and application has it&#x27;s own state in s3 and dynamodb.<p>And so on.<p>Is this unwieldly? I have 40-50 AWS accounts and no it&#x27;s not unwieldly at all IMO. Cross account IAM and trust relationships are set up very early on and they don&#x27;t need to be modified much if any at all until you create another AWS account. Creating a new AWS account is kind of annoying, though. I need to automate that process better.<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;organizations&#x2F;getting-started&#x2F;best-practices&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;organizations&#x2F;getting-started&#x2F;best-pr...</a></div><br/><div id="37009525" class="c"><input type="checkbox" id="c-37009525" checked=""/><div class="controls bullet"><span class="by">denvrede</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005850">parent</a><span>|</span><a href="#37005872">next</a><span>|</span><label class="collapse" for="c-37009525">[-]</label><label class="expand" for="c-37009525">[1 more]</label></div><br/><div class="children"><div class="content">How do you deploy your Apps? We exclusively use EKS and having one account per env and app seems like quite an overhead when I think about managing &#x2F; updating EKS clusters for each one. It also comes with an overhead of base applications that need to run in each cluster by default (like cert-manager, externaldns etc).<p>Right now we’re using one account per env but also see downsides and thought of going the next step to do one account per env and tribe&#x2F;team.</div><br/></div></div><div id="37005872" class="c"><input type="checkbox" id="c-37005872" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005850">parent</a><span>|</span><a href="#37009525">prev</a><span>|</span><a href="#37008133">next</a><span>|</span><label class="collapse" for="c-37005872">[-]</label><label class="expand" for="c-37005872">[8 more]</label></div><br/><div class="children"><div class="content">Cool, that was a genuinely fascinating window into AWS for me. Thank you for sharing</div><br/><div id="37005905" class="c"><input type="checkbox" id="c-37005905" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005872">parent</a><span>|</span><a href="#37008133">next</a><span>|</span><label class="collapse" for="c-37005905">[-]</label><label class="expand" for="c-37005905">[7 more]</label></div><br/><div class="children"><div class="content">FWIW I loathe AWS IAM and miss GCPs organization.</div><br/><div id="37006340" class="c"><input type="checkbox" id="c-37006340" checked=""/><div class="controls bullet"><span class="by">wpietri</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005905">parent</a><span>|</span><a href="#37007228">next</a><span>|</span><label class="collapse" for="c-37006340">[-]</label><label class="expand" for="c-37006340">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I started with AWS and then spent a year on GCP and next time I&#x27;d much rather do GCP. It felt much more manageable and supportive to me.</div><br/><div id="37009430" class="c"><input type="checkbox" id="c-37009430" checked=""/><div class="controls bullet"><span class="by">androidbishop</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37006340">parent</a><span>|</span><a href="#37007228">next</a><span>|</span><label class="collapse" for="c-37009430">[-]</label><label class="expand" for="c-37009430">[1 more]</label></div><br/><div class="children"><div class="content">A rare opinion but one I share wholeheartedly.  I started my career at Google Cloud but spent the rest of it working with AWS.  AWS always feels like an uphill struggle, lots of micro management and resources that need to be duct-taped together.  I&#x27;m lucky to have recently landed a Google Cloud gig and my God, things are so much easier and smoother now.  It just seems better designed and integrated to me, albeit much fewer services to choose from if you don&#x27;t buy into their ecosystem.</div><br/></div></div></div></div><div id="37007228" class="c"><input type="checkbox" id="c-37007228" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005905">parent</a><span>|</span><a href="#37006340">prev</a><span>|</span><a href="#37005942">next</a><span>|</span><label class="collapse" for="c-37007228">[-]</label><label class="expand" for="c-37007228">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I loathe GCP IAM and miss AWS IAM, CloudFormation, and not having to talk to any one single person or piece of software about &quot;please enable this foundational API in your Project&quot;</div><br/></div></div><div id="37005942" class="c"><input type="checkbox" id="c-37005942" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005905">parent</a><span>|</span><a href="#37007228">prev</a><span>|</span><a href="#37008133">next</a><span>|</span><label class="collapse" for="c-37005942">[-]</label><label class="expand" for="c-37005942">[3 more]</label></div><br/><div class="children"><div class="content">I’m quite into learning a lot of cloud native security stuff  and I have to say my first impression was that it seemed so much harder to think about creating a secure environment using AWS IAM. I couldn’t tell if it was just a case of familiarity or not.</div><br/><div id="37006105" class="c"><input type="checkbox" id="c-37006105" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005942">parent</a><span>|</span><a href="#37008133">next</a><span>|</span><label class="collapse" for="c-37006105">[-]</label><label class="expand" for="c-37006105">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure it&#x27;s because of it&#x27;s age and them kind of creating their version of IAM from scratch (someone correct me if they copied this structure from elsewhere) but you have to do a lot of goofy obtuse work with IAM automation. There are times I have to go into the console&#x2F;cli and grab some sort of specific UID for an object instead of using its name, things like that that just make it annoying. Sometimes you can&#x27;t use an account name and have to use the org ID... I could go on. You just kind of deal with it.<p>I haven&#x27;t worked on GCP since maybe 2016-17 so I&#x27;m not sure how it&#x27;s going over there anymore.</div><br/><div id="37006232" class="c"><input type="checkbox" id="c-37006232" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37006105">parent</a><span>|</span><a href="#37008133">next</a><span>|</span><label class="collapse" for="c-37006232">[-]</label><label class="expand" for="c-37006232">[1 more]</label></div><br/><div class="children"><div class="content">It really does sound like an entirely different level of complexity.<p>GCP native API is basically the same thing as knative in most ways. Just a bunch of various services and resources that you all call and authenticate and even often provision the same way.<p>As an example of that since we are talking about infrastructure management I would say at its “smoothest” level of integration there is a service you can use (or host it yourself on Kubernetes if that’s your thing for some reason) where like any other Kubernetes resource I would just “declare” what I wanted.<p>So now I’m not messing around with complicated Terraform logic at all (Google got really good with automation, I don’t think there is anything close to an equivalent for this is there?). I just declare say a BigQuery resource or a Project (AWS Account equivalent) resource and the service will do all the hard work of making sure that’s the state my account is in at any given point.<p>I can also stick policy controls around it like I would with K8s so only certain people can create certain resources under certain conditions.<p>It’s really easy to just stick that into a git repo and still do all of the IAC stuff mentioned in this article but it’s also easy to do the cross environment stuff and manage the roll out between each of them.<p>Overall, it’s very predictable, the IAM is really intuitive but also incredibly granular so it’s very easy to model things on top of and to feel fairly confident that I’m not accidentally doing something stupid so I really like it from that point of view.<p>My number one bit of advice for GCP is see how easily you can architect your way into using Cloud Run as much as possible unless you have some really wild use case. You can get to a really sophisticated set up with only a tiny team. Followed by read Google’s API guidelines (aip.dev) to understand how to build things in a way where you’re going to continuing having a good time.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37008133" class="c"><input type="checkbox" id="c-37008133" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005850">parent</a><span>|</span><a href="#37005872">prev</a><span>|</span><a href="#37005788">next</a><span>|</span><label class="collapse" for="c-37008133">[-]</label><label class="expand" for="c-37008133">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Creating a new AWS account is kind of annoying, though. I need to automate that process better.<p>You can do that with terraform...</div><br/><div id="37008261" class="c"><input type="checkbox" id="c-37008261" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37008133">parent</a><span>|</span><a href="#37005788">next</a><span>|</span><label class="collapse" for="c-37008261">[-]</label><label class="expand" for="c-37008261">[1 more]</label></div><br/><div class="children"><div class="content">You can, but using Terraform to provision resources inside those accounts entails pulling generated&#x2F;defined credentials from the org-level TF state and feeding that into the provider config for each app-env-level TF state.  Vanilla Terraform doesn&#x27;t support that very well (or at all, last I checked), but either some CI&#x2F;CD pipeline creativity or Terragrunt (or both!) can work around it.</div><br/></div></div></div></div></div></div><div id="37005788" class="c"><input type="checkbox" id="c-37005788" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37005760">parent</a><span>|</span><a href="#37005850">prev</a><span>|</span><a href="#37005791">next</a><span>|</span><label class="collapse" for="c-37005788">[-]</label><label class="expand" for="c-37005788">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But I’m coming at this from a GCP lens and got half way through the article about how the recommended unit of isolation in the AWS environment is entirely different AWS accounts and I’m kind of hung up on that. Is that really a thing people tend to do often? Doesn’t it get super unwieldy?<p>There are AWS systems above the account level for managing it (Organizations), so its not quite as bad as it might naively seem, but, yes, its more unwieldy than GCP’s projects.</div><br/><div id="37005826" class="c"><input type="checkbox" id="c-37005826" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005788">parent</a><span>|</span><a href="#37005791">next</a><span>|</span><label class="collapse" for="c-37005826">[-]</label><label class="expand" for="c-37005826">[1 more]</label></div><br/><div class="children"><div class="content">Oh thank god, that’s much better than I naively thought. Thanks for the heads up.</div><br/></div></div></div></div><div id="37005791" class="c"><input type="checkbox" id="c-37005791" checked=""/><div class="controls bullet"><span class="by">stock_toaster</span><span>|</span><a href="#37005760">parent</a><span>|</span><a href="#37005788">prev</a><span>|</span><a href="#37007123">next</a><span>|</span><label class="collapse" for="c-37005791">[-]</label><label class="expand" for="c-37005791">[3 more]</label></div><br/><div class="children"><div class="content">You can have sub-accounts that roll up billing to a main account. Still messy, but probably cleaner (security policy wise) and possibly safer (fewer production impacting accidental config changes?) than having a single giant account with _lots_ of things mixed together.</div><br/><div id="37007261" class="c"><input type="checkbox" id="c-37007261" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37005791">parent</a><span>|</span><a href="#37007123">next</a><span>|</span><label class="collapse" for="c-37007261">[-]</label><label class="expand" for="c-37007261">[2 more]</label></div><br/><div class="children"><div class="content">As the resident pedant, one cannot have &quot;sub-accounts&quot; in AWS. One can 100% have Accounts that are a member of an AWS Organization, which itself has a Management Account that does as you describe as the &quot;main account&quot;, but there is no parent-child relationship between Accounts, only OUs and Accounts or OUs and other OUs (which the Organization, itself, counts as an OU)</div><br/><div id="37007660" class="c"><input type="checkbox" id="c-37007660" checked=""/><div class="controls bullet"><span class="by">stock_toaster</span><span>|</span><a href="#37005760">root</a><span>|</span><a href="#37007261">parent</a><span>|</span><a href="#37007123">next</a><span>|</span><label class="collapse" for="c-37007660">[-]</label><label class="expand" for="c-37007660">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the corrections. :)</div><br/></div></div></div></div></div></div><div id="37007123" class="c"><input type="checkbox" id="c-37007123" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37005760">parent</a><span>|</span><a href="#37005791">prev</a><span>|</span><a href="#37007306">next</a><span>|</span><label class="collapse" for="c-37007123">[-]</label><label class="expand" for="c-37007123">[1 more]</label></div><br/><div class="children"><div class="content">Some AWS services have per-account (not per-resource) size and rate limits. Keeping resources in separate AWS accounts gets them out of each others’ blast radii.<p>AWS IAM doesn’t do capability inheritance; if I can write a policy at all I could grant <i>any</i> privilege to <i>any</i> resource in that policy, even privileges I don’t personally have. It’s easier for each groups of admins to have a separate AWS account than to put everyone in security boundaries that try to wall them off.</div><br/></div></div><div id="37007306" class="c"><input type="checkbox" id="c-37007306" checked=""/><div class="controls bullet"><span class="by">linuxdude314</span><span>|</span><a href="#37005760">parent</a><span>|</span><a href="#37007123">prev</a><span>|</span><a href="#37005822">next</a><span>|</span><label class="collapse" for="c-37007306">[-]</label><label class="expand" for="c-37007306">[1 more]</label></div><br/><div class="children"><div class="content">This doesn’t have anything to do with AWS, this has to do with terraform not allowing you to dynamically instantiate providers.<p>The same thing happens with the Kubernetes provider when you try to use it with multiple GKE clusters.</div><br/></div></div><div id="37005822" class="c"><input type="checkbox" id="c-37005822" checked=""/><div class="controls bullet"><span class="by">lgreiv</span><span>|</span><a href="#37005760">parent</a><span>|</span><a href="#37007306">prev</a><span>|</span><a href="#37005817">next</a><span>|</span><label class="collapse" for="c-37005822">[-]</label><label class="expand" for="c-37005822">[1 more]</label></div><br/><div class="children"><div class="content">You should be able to organize accounts hierarchically using AWS Organizations, which allows to have cost centers and centralized billing (and some imposed policies over all accounts).</div><br/></div></div><div id="37005817" class="c"><input type="checkbox" id="c-37005817" checked=""/><div class="controls bullet"><span class="by">cube2222</span><span>|</span><a href="#37005760">parent</a><span>|</span><a href="#37005822">prev</a><span>|</span><a href="#37007134">next</a><span>|</span><label class="collapse" for="c-37005817">[-]</label><label class="expand" for="c-37005817">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s extremely common and recommended.<p>Billing works by having a billing aws account that all other accounts are in a sense &quot;children&quot; of.</div><br/></div></div></div></div><div id="37006180" class="c"><input type="checkbox" id="c-37006180" checked=""/><div class="controls bullet"><span class="by">spicyusername</span><span>|</span><a href="#37005760">prev</a><span>|</span><a href="#37009039">next</a><span>|</span><label class="collapse" for="c-37006180">[-]</label><label class="expand" for="c-37006180">[7 more]</label></div><br/><div class="children"><div class="content">Everybody in here is recommending tarragrunt, but I&#x27;m not sure what value it provides over regular terraform.<p>After using it for a few months all of the features found in tarragrunt are in terraform.</div><br/><div id="37007084" class="c"><input type="checkbox" id="c-37007084" checked=""/><div class="controls bullet"><span class="by">jbjohns</span><span>|</span><a href="#37006180">parent</a><span>|</span><a href="#37008238">next</a><span>|</span><label class="collapse" for="c-37007084">[-]</label><label class="expand" for="c-37007084">[5 more]</label></div><br/><div class="children"><div class="content">This is my impression as well.  As far as I&#x27;ve understood, terragrunt was made back when terraform was missing a lot of key features (I think it maybe didn&#x27;t even have modules yet) but when I was asked to evaluate it recently for a client I couldn&#x27;t find a single reason to justify adding another tool.</div><br/><div id="37007207" class="c"><input type="checkbox" id="c-37007207" checked=""/><div class="controls bullet"><span class="by">linuxdude314</span><span>|</span><a href="#37006180">root</a><span>|</span><a href="#37007084">parent</a><span>|</span><a href="#37008238">next</a><span>|</span><label class="collapse" for="c-37007207">[-]</label><label class="expand" for="c-37007207">[4 more]</label></div><br/><div class="children"><div class="content">The primary thing terragrunt was designed to do was let you dynamically render providers.<p>Terraform still does not let you this.<p>It becomes very problematic when using providers that are region specific, amongst other scenarios.<p>That being said I don’t like the extra complexity terragrunt adds and instead choose to adopt a hierarchical structure that solves most of the problems being able to dynamically render providers would solve.<p>Each module is stored in its own git repo.<p>Top layer or root module contains one tf file that is ONLY imports with no parameters.<p>The modules being imported are called “tenant modules”. A tenant module contains instantiations of providers and modules with parameters.<p>The nodules imported by the tenant modules at the ones that actually stand up the infrastructure.<p>Variables are used, but no external parameters files are used at any level (except for testing).<p>All of the modules are versioned with git tagged releases so the correct version can easily be imported.<p>Couple this with a single remote state provider in the root module and throw it in a CI&#x2F;CD pipeline and you have a gitops driven infrastructure as code pipeline.</div><br/><div id="37007734" class="c"><input type="checkbox" id="c-37007734" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#37006180">root</a><span>|</span><a href="#37007207">parent</a><span>|</span><a href="#37008238">next</a><span>|</span><label class="collapse" for="c-37007734">[-]</label><label class="expand" for="c-37007734">[3 more]</label></div><br/><div class="children"><div class="content">What do you mean by &#x27;dynamically render providers&#x27;?<p>I assume you&#x27;re aware you can instantiate multiple versions (different params) of a provider and pass them to child modules, e.g. you can instantiate a module once for each of a several AWS regions&#x2F;accounts?<p>Do you mean that something like the region&#x2F;account param would be set on the basis of a computed value from some other resource (because we created the account, say, or listed all regions satisfying some filter with a data source)?</div><br/><div id="37008516" class="c"><input type="checkbox" id="c-37008516" checked=""/><div class="controls bullet"><span class="by">333throwaway342</span><span>|</span><a href="#37006180">root</a><span>|</span><a href="#37007734">parent</a><span>|</span><a href="#37008770">prev</a><span>|</span><a href="#37008238">next</a><span>|</span><label class="collapse" for="c-37008516">[-]</label><label class="expand" for="c-37008516">[1 more]</label></div><br/><div class="children"><div class="content">providers do not support `for_each` or `count`</div><br/></div></div></div></div></div></div></div></div><div id="37008238" class="c"><input type="checkbox" id="c-37008238" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#37006180">parent</a><span>|</span><a href="#37007084">prev</a><span>|</span><a href="#37009039">next</a><span>|</span><label class="collapse" for="c-37008238">[-]</label><label class="expand" for="c-37008238">[1 more]</label></div><br/><div class="children"><div class="content">Terragrunt shines in cases where you have independent sets of Terraform state, especially if they are dependencies&#x2F;dependents of one another.<p>For example, say you&#x27;re using Terraform to manage AWS resources, and you&#x27;ve provisioned an Active Directory forest that you in turn want to manage with Terraform via the AD provider.  Terraform providers can&#x27;t dynamically pull things like needed credentials from existing state, so you end up needing two separate Terraform states: one for AWS (which outputs the management credentials for the AD servers you&#x27;ve provisioned) and one for AD (which accepts those credentials as config during &#x27;terraform init&#x27;).<p>Terragrunt can do this in an automated way within a single codebase, redefining providers and handling dependency&#x2F;dependent relationships.  I don&#x27;t know of a way to do it in pure Terraform that doesn&#x27;t entail manual intervention.</div><br/></div></div></div></div><div id="37009039" class="c"><input type="checkbox" id="c-37009039" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#37006180">prev</a><span>|</span><a href="#37008647">next</a><span>|</span><label class="collapse" for="c-37009039">[-]</label><label class="expand" for="c-37009039">[1 more]</label></div><br/><div class="children"><div class="content">I settled on 1 subfolder, 1 “stack” (stage&#x2F;app, for example dev&#x2F;login&#x2F;frontend). This gives us fast deploy time and easy and painless way to destroy&#x2F;re-create. Databases could go a separate folder if state if we had any.<p>The point of Terraform is to have configuration in version control not to have a giant unmanageable state file.</div><br/></div></div><div id="37008647" class="c"><input type="checkbox" id="c-37008647" checked=""/><div class="controls bullet"><span class="by">RulerOf</span><span>|</span><a href="#37009039">prev</a><span>|</span><a href="#37007223">next</a><span>|</span><label class="collapse" for="c-37008647">[-]</label><label class="expand" for="c-37008647">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Using the -target option to terraform plan is discouraged (the Terraform documentation says, “this is for exceptional use only”). Anyway, it’s likely to lead to confusing infrastructure states if changes are applied incrementally with ad hoc, situational boundaries.<p>We&#x27;ve been using -target for years, and while I understand very well the reasons it&#x27;s discouraged, it is pretty much the only way you can have your cake and eat it too with respect to having &quot;one large terraform project&quot; and not running into terraform refreshes that make your eyes bleed.<p>You end up having to really understand your module structure to use it, but it let us develop some very elegant workflows around tasks like patching.<p>We developed a ruby code base that utilizes rake and the hcl2json tool to automate terraform-based infrastructure workflows, using various libraries to handle and validate that applications are happy with what terraform is doing to their servers while it works.<p>This gives us flexibility to run automations safely against a terraform code base that has been evolving since version 0.3 or so, before most of the mistakes were made often enough to come up with the best practices we have today.</div><br/></div></div><div id="37007223" class="c"><input type="checkbox" id="c-37007223" checked=""/><div class="controls bullet"><span class="by">ary</span><span>|</span><a href="#37008647">prev</a><span>|</span><a href="#37006006">next</a><span>|</span><label class="collapse" for="c-37007223">[-]</label><label class="expand" for="c-37007223">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At scale, many Terraform state files are better than one. But how do you draw the boundaries and decide which resources belong in which state files? What are the best practices for organizing Terraform state files to maximize reliability, minimize the blast-radius of changes, and align with the design of cloud providers?<p>1000% agree. I put together my version of standing up remote state in AWS into a Github repo. <a href="https:&#x2F;&#x2F;github.com&#x2F;aryounce&#x2F;terraform-aws-bootstrap">https:&#x2F;&#x2F;github.com&#x2F;aryounce&#x2F;terraform-aws-bootstrap</a><p>Our use of Terraform splits state exactly as described primarily to keep the state refresh times reasonable.</div><br/></div></div><div id="37006006" class="c"><input type="checkbox" id="c-37006006" checked=""/><div class="controls bullet"><span class="by">gerl1ng</span><span>|</span><a href="#37007223">prev</a><span>|</span><a href="#37005358">next</a><span>|</span><label class="collapse" for="c-37006006">[-]</label><label class="expand" for="c-37006006">[1 more]</label></div><br/><div class="children"><div class="content">The solution at the end almost looks like the manual setup of terragrunt which we are using to manage lots of base infra in many different accounts.<p>What would be interesting here would be to see how they actually reference the outputs from one layer onto the next layer. That is something that is not even solved nicely in terragrunt and one of the major annoyances for me there.
Using dependencies and the mock_output option is creating lots of noise in the plan outputs as the dependencies are only completely resolved when terragrund applies all the modules.<p>But it seems I also missed a few additions to terraform - so probably there are better ways to take outputs from one terraform run into another one.</div><br/></div></div><div id="37005358" class="c"><input type="checkbox" id="c-37005358" checked=""/><div class="controls bullet"><span class="by">Terretta</span><span>|</span><a href="#37006006">prev</a><span>|</span><a href="#37005812">next</a><span>|</span><label class="collapse" for="c-37005358">[-]</label><label class="expand" for="c-37005358">[1 more]</label></div><br/><div class="children"><div class="content">This should be mandatory reading for anyone doing IaC, using TF and AWS or not, less for how you do it, more for what and why.<p><i>&#x2F;&#x2F; shout out to AWS CAB alums</i></div><br/></div></div><div id="37005812" class="c"><input type="checkbox" id="c-37005812" checked=""/><div class="controls bullet"><span class="by">badblock</span><span>|</span><a href="#37005358">prev</a><span>|</span><a href="#37008032">next</a><span>|</span><label class="collapse" for="c-37005812">[-]</label><label class="expand" for="c-37005812">[5 more]</label></div><br/><div class="children"><div class="content">Some of this seems like old advice, instead of having directories per environment you should be using workspaces to keep your environments consistent so you don&#x27;t forget to add your new service to prod.</div><br/><div id="37006217" class="c"><input type="checkbox" id="c-37006217" checked=""/><div class="controls bullet"><span class="by">rcrowley</span><span>|</span><a href="#37005812">parent</a><span>|</span><a href="#37008032">next</a><span>|</span><label class="collapse" for="c-37006217">[-]</label><label class="expand" for="c-37006217">[4 more]</label></div><br/><div class="children"><div class="content">(Hi, I’m one of the authors of the article at the root of this thread.)<p>I’ve gone back and forth on workspaces versus more root modules. On balance, I like having more root modules because I can orient myself just by my working directory instead of both my working directory and workspace. Plus, I feel better about stuffing more dimensions of separation into a directory tree than into workspace names. YMMV.</div><br/><div id="37006971" class="c"><input type="checkbox" id="c-37006971" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#37005812">root</a><span>|</span><a href="#37006217">parent</a><span>|</span><a href="#37008032">next</a><span>|</span><label class="collapse" for="c-37006971">[-]</label><label class="expand" for="c-37006971">[3 more]</label></div><br/><div class="children"><div class="content">What do you think about multiple backends? It seems to be working well for me to have a single root module but with a separate backend configuration per environment.</div><br/><div id="37008566" class="c"><input type="checkbox" id="c-37008566" checked=""/><div class="controls bullet"><span class="by">RulerOf</span><span>|</span><a href="#37005812">root</a><span>|</span><a href="#37006971">parent</a><span>|</span><a href="#37008002">next</a><span>|</span><label class="collapse" for="c-37008566">[-]</label><label class="expand" for="c-37008566">[1 more]</label></div><br/><div class="children"><div class="content">Multiple backends are unwieldy if you&#x27;re using terraform at the command line, but they beat workspaces handily for discoverability.
 They&#x27;re a fine option if you&#x27;re applying through CI though, as the drudgery of utilizing them is handled effortlessly by the robots.</div><br/></div></div><div id="37008002" class="c"><input type="checkbox" id="c-37008002" checked=""/><div class="controls bullet"><span class="by">rcrowley</span><span>|</span><a href="#37005812">root</a><span>|</span><a href="#37006971">parent</a><span>|</span><a href="#37008566">prev</a><span>|</span><a href="#37008032">next</a><span>|</span><label class="collapse" for="c-37008002">[-]</label><label class="expand" for="c-37008002">[1 more]</label></div><br/><div class="children"><div class="content">That does work well for environments because typically you’d run exactly the same code, maybe with different cluster sizes or instance types, in each environment. But it doesn’t work well for isolating two services where the code is significantly or even entirely different.</div><br/></div></div></div></div></div></div></div></div><div id="37008032" class="c"><input type="checkbox" id="c-37008032" checked=""/><div class="controls bullet"><span class="by">aloknnikhil</span><span>|</span><a href="#37005812">prev</a><span>|</span><a href="#37005952">next</a><span>|</span><label class="collapse" for="c-37008032">[-]</label><label class="expand" for="c-37008032">[1 more]</label></div><br/><div class="children"><div class="content">It seems to me, this is trying really hard to shoehorn Terraform into managing at scale. For multi-account, multi-org, multi-region, multi-cloud deployments is Terraform really supposed to be the state of the art? How do you even get visibility into the various deployment workflows?</div><br/></div></div><div id="37005952" class="c"><input type="checkbox" id="c-37005952" checked=""/><div class="controls bullet"><span class="by">cube2222</span><span>|</span><a href="#37008032">prev</a><span>|</span><a href="#37007418">next</a><span>|</span><label class="collapse" for="c-37005952">[-]</label><label class="expand" for="c-37005952">[5 more]</label></div><br/><div class="children"><div class="content">The article recommends to split up your state files for various advantages, but also expands into how to manage it later in a custom way.<p>I agree with the splitting, but based on many home-grown automation systems I&#x27;ve seen  around this I&#x27;d really recommend you to use one of the specialized CI&#x2F;CD systems that are built around automating these kinds of workflows. Once you reach the &quot;many state files&quot; phase, you&#x27;ll save a lot of engineering time this way.<p>They&#x27;ll take care of, among others, running the right state files, in the right order, with the right parameters. But they&#x27;ll also take care of many other things you need to run Terraform at scale and with big  amounts of engineers (happy to expand but don&#x27;t want to kitchen-sink this comment).<p>Disclaimer: Take this with a sensible grain of salt, as I work at Spacelift[0] - one of the TACOS (and of course the one I&#x27;ll shamelessly link and recommend!).<p>But really, don&#x27;t use tools like Jenkins for this as you scale, it&#x27;ll likely hurt you in the long run.<p>[0]: <a href="https:&#x2F;&#x2F;spacelift.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;spacelift.io</a></div><br/><div id="37006065" class="c"><input type="checkbox" id="c-37006065" checked=""/><div class="controls bullet"><span class="by">swozey</span><span>|</span><a href="#37005952">parent</a><span>|</span><a href="#37007418">next</a><span>|</span><label class="collapse" for="c-37006065">[-]</label><label class="expand" for="c-37006065">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure that you have no control over this but I really wish Spacelift would increase the cost of its cloud tier and lower the cost of Ent. I&#x27;m in the anti-goldilocks zone. Ent seems priced for large teams when I practically fit into the cloud offering sans missing a few required features.<p>Great product though from what I&#x27;ve experienced.</div><br/><div id="37006122" class="c"><input type="checkbox" id="c-37006122" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#37005952">root</a><span>|</span><a href="#37006065">parent</a><span>|</span><a href="#37006680">next</a><span>|</span><label class="collapse" for="c-37006122">[-]</label><label class="expand" for="c-37006122">[1 more]</label></div><br/><div class="children"><div class="content">Disclaimer: Co-founder of Terrateam.<p>For Terrateam[0], we have probably 70% of the enterprise offering but at around 1&#x2F;10th the price.  If there are any features that are deal breaker, feel free to reach out to me and we&#x27;ll see what we can do.  That being said, Spacelift is a much more luxurious piece of software than us.  We are very utilitarian, but we have to rationalize that low price-point somehow.<p>[0] <a href="https:&#x2F;&#x2F;terrateam.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;terrateam.io</a></div><br/></div></div><div id="37006680" class="c"><input type="checkbox" id="c-37006680" checked=""/><div class="controls bullet"><span class="by">carty7</span><span>|</span><a href="#37005952">root</a><span>|</span><a href="#37006065">parent</a><span>|</span><a href="#37006122">prev</a><span>|</span><a href="#37006134">next</a><span>|</span><label class="collapse" for="c-37006680">[-]</label><label class="expand" for="c-37006680">[1 more]</label></div><br/><div class="children"><div class="content">Hi swozey. Spacelift sales leader here. Let&#x27;s have a conversation and I&#x27;ll work with you to find the goldilocks zone that you are looking for. Grab a demo with us and mention this post and my name &quot;Ryan&quot;. We can dive into the features you require.</div><br/></div></div><div id="37006134" class="c"><input type="checkbox" id="c-37006134" checked=""/><div class="controls bullet"><span class="by">cube2222</span><span>|</span><a href="#37005952">root</a><span>|</span><a href="#37006065">parent</a><span>|</span><a href="#37006680">prev</a><span>|</span><a href="#37007418">next</a><span>|</span><label class="collapse" for="c-37006134">[-]</label><label class="expand" for="c-37006134">[1 more]</label></div><br/><div class="children"><div class="content">Sorry to hear that! Pricing is hard.<p>If you haven&#x27;t yet, please try talking to our sales team. There&#x27;s usually a way to make  all sides happy with some custom agreements - after all, we&#x27;d love for you to be able to use our product as much as you need.</div><br/></div></div></div></div></div></div><div id="37007418" class="c"><input type="checkbox" id="c-37007418" checked=""/><div class="controls bullet"><span class="by">bickfordb</span><span>|</span><a href="#37005952">prev</a><span>|</span><a href="#37008400">next</a><span>|</span><label class="collapse" for="c-37007418">[-]</label><label class="expand" for="c-37007418">[2 more]</label></div><br/><div class="children"><div class="content">Aside from reducing the blast radius of any Terraform state (split by envs, then by teams as you grow), I highly recommend using cdktf with Python for Terraform projects.  Huge timesaver</div><br/><div id="37008793" class="c"><input type="checkbox" id="c-37008793" checked=""/><div class="controls bullet"><span class="by">333throwaway342</span><span>|</span><a href="#37007418">parent</a><span>|</span><a href="#37008400">next</a><span>|</span><label class="collapse" for="c-37008793">[-]</label><label class="expand" for="c-37008793">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know.<p>I kind of think using a language with native JSON support and structural type system would be best.<p>HCL also just works.</div><br/></div></div></div></div><div id="37008400" class="c"><input type="checkbox" id="c-37008400" checked=""/><div class="controls bullet"><span class="by">ochoseis</span><span>|</span><a href="#37007418">prev</a><span>|</span><a href="#37005663">next</a><span>|</span><label class="collapse" for="c-37008400">[-]</label><label class="expand" for="c-37008400">[1 more]</label></div><br/><div class="children"><div class="content">We’ve had a pretty good experience with Terraspace at work, which is an opinionated framework&#x2F;layout for Terraform. It supports hooks and splitting state between regions and accounts.</div><br/></div></div><div id="37005663" class="c"><input type="checkbox" id="c-37005663" checked=""/><div class="controls bullet"><span class="by">pezh0re</span><span>|</span><a href="#37008400">prev</a><span>|</span><a href="#37008783">next</a><span>|</span><label class="collapse" for="c-37005663">[-]</label><label class="expand" for="c-37005663">[4 more]</label></div><br/><div class="children"><div class="content">This is a great read, but I always seem to run into cases where I need to define something like a security group and then reference it when deploying ec2 instances. I&#x27;d love to decouple to reduce my plan time, but I haven&#x27;t figured a way out as of yet.<p>To be fair, I haven&#x27;t used terraform -chdir yet.</div><br/><div id="37006030" class="c"><input type="checkbox" id="c-37006030" checked=""/><div class="controls bullet"><span class="by">c0Re69</span><span>|</span><a href="#37005663">parent</a><span>|</span><a href="#37007784">next</a><span>|</span><label class="collapse" for="c-37006030">[-]</label><label class="expand" for="c-37006030">[1 more]</label></div><br/><div class="children"><div class="content">Try Terragrunt <a href="https:&#x2F;&#x2F;terragrunt.gruntwork.io&#x2F;docs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;terragrunt.gruntwork.io&#x2F;docs&#x2F;</a></div><br/></div></div><div id="37007784" class="c"><input type="checkbox" id="c-37007784" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#37005663">parent</a><span>|</span><a href="#37006030">prev</a><span>|</span><a href="#37006320">next</a><span>|</span><label class="collapse" for="c-37007784">[-]</label><label class="expand" for="c-37007784">[1 more]</label></div><br/><div class="children"><div class="content">-chdir is useful, but nothing to do with this (it&#x27;s literally just cd before running command).<p>As sibling said, use data source to read remote state outputs.</div><br/></div></div><div id="37006320" class="c"><input type="checkbox" id="c-37006320" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#37005663">parent</a><span>|</span><a href="#37007784">prev</a><span>|</span><a href="#37008783">next</a><span>|</span><label class="collapse" for="c-37006320">[-]</label><label class="expand" for="c-37006320">[1 more]</label></div><br/><div class="children"><div class="content">you can pull it in via a data source, but then of course this creates a coupling between multiple modules&#x2F;state files.</div><br/></div></div></div></div><div id="37008783" class="c"><input type="checkbox" id="c-37008783" checked=""/><div class="controls bullet"><span class="by">abledon</span><span>|</span><a href="#37005663">prev</a><span>|</span><a href="#37007999">next</a><span>|</span><label class="collapse" for="c-37008783">[-]</label><label class="expand" for="c-37008783">[2 more]</label></div><br/><div class="children"><div class="content">Why doesn&#x27;t Hashicorp provide official best practices like this?</div><br/><div id="37008863" class="c"><input type="checkbox" id="c-37008863" checked=""/><div class="controls bullet"><span class="by">333throwaway342</span><span>|</span><a href="#37008783">parent</a><span>|</span><a href="#37007999">next</a><span>|</span><label class="collapse" for="c-37008863">[-]</label><label class="expand" for="c-37008863">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t a rated E for everyone practice.<p>Hashicorp is focused on CI&#x2F;CD&#x2F;cloud&#x2F;workspace driven workflows over monorepo `chdir` driven.</div><br/></div></div></div></div><div id="37007999" class="c"><input type="checkbox" id="c-37007999" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37008783">prev</a><span>|</span><label class="collapse" for="c-37007999">[-]</label><label class="expand" for="c-37007999">[1 more]</label></div><br/><div class="children"><div class="content">What does the phrase &quot;stamp out&quot; mean in this context?</div><br/></div></div></div></div></div></div></div></body></html>