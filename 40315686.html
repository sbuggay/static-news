<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715504454133" as="style"/><link rel="stylesheet" href="styles.css?v=1715504454133"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://stevenharman.net/so-we-have-a-memory-leak">So We&#x27;ve Got a Memory Leak</a>Â <span class="domain">(<a href="https://stevenharman.net">stevenharman.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>123 comments</span></div><br/><div><div id="40327791" class="c"><input type="checkbox" id="c-40327791" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#40329480">next</a><span>|</span><label class="collapse" for="c-40327791">[-]</label><label class="expand" for="c-40327791">[73 more]</label></div><br/><div class="children"><div class="content">I just dont understand the fear with manual memory management. With RAII and and simple diligance (clear ownership rules), managing memory is an easy engineering task. I actually find it *more* challenging to deal with frameworks that insist or reference counting and shared pointers since ownership is now obscure.<p>I create it, I free it. I transfer, I no longer care. Its part of engineering discipline. Memory bugs are no worse than logic bugs, we fix the logic bugs, makes sense to fix the memory bugs. Disclaimer: I do embedded complex systems that run 24&#x2F;7.<p>We do the same for OS resources (handles, sockets, etc) and dont use automatic resource managers, we do it manually. So why complicate the design with automatic memory management?</div><br/><div id="40329254" class="c"><input type="checkbox" id="c-40329254" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40328430">next</a><span>|</span><label class="collapse" for="c-40329254">[-]</label><label class="expand" for="c-40329254">[8 more]</label></div><br/><div class="children"><div class="content">The use of manual memory management increases the cognitive load when reasoning about software. Working memory capacity varies considerably between people and is a performance limiting factor when designing complex systems. You see analogues of this in other engineering disciplines too.<p>Over my many years of working in software development I have come around to the idea that most software developers do not have sufficient working memory capacity to reason about memory management in addition to everything else they must reason about at the same time. They may know mechanically how to properly do manual memory management but when writing code they drop things if they are juggling too many things at once mentally. It isn&#x27;t a matter of effort, there simply is a complexity threshold past which something has to give. Automatic memory management has its tradeoffs but it also enables some people to be effective who otherwise would not be.<p>On the other side of that you have the minority that get manual memory management right every time almost effortlessly, who don&#x27;t grok why it is so difficult for everyone else because it is literally easy for them. I think some people can&#x27;t imagine that such a group of engineers exist because they are not in that group and their brain doesn&#x27;t work that way. If you are in this group, automatic memory management will seem to make things worse for unclear benefit.<p>I&#x27;ve observed this bifurcation in systems software my entire career. In discussions about memory safety and memory management, it is often erroneously assumed that the latter population simply doesn&#x27;t exist.</div><br/><div id="40329606" class="c"><input type="checkbox" id="c-40329606" checked=""/><div class="controls bullet"><span class="by">mattpallissard</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329254">parent</a><span>|</span><a href="#40331449">next</a><span>|</span><label class="collapse" for="c-40329606">[-]</label><label class="expand" for="c-40329606">[6 more]</label></div><br/><div class="children"><div class="content">I think the rift comes from people thinking manual memory management is a bunch of random allocs and frees all over the place.  That is gross and those of us who don&#x27;t mind managing memory don&#x27;t like it either.<p>Personally my gripe is when people don&#x27;t think about memory or space complexity at all.  I don&#x27;t care if it&#x27;s a custom memory management strategy or GC&#x27;d language, you need to think about it.  I have the same gripe about persistence, socket programming, and database queries.<p>Abstractions are great, use them, love them.  But understanding what the hell they are doing under the hood not only improves efficiency, it prevents bugs, and gives you a really solid base when reasoning about unexpected behavior.</div><br/><div id="40330244" class="c"><input type="checkbox" id="c-40330244" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329606">parent</a><span>|</span><a href="#40330253">next</a><span>|</span><label class="collapse" for="c-40330244">[-]</label><label class="expand" for="c-40330244">[1 more]</label></div><br/><div class="children"><div class="content">If the automatic allocation tools are good, then they&#x27;re doing the same thing as quality manual management but with much more compiler enforcement.</div><br/></div></div><div id="40330253" class="c"><input type="checkbox" id="c-40330253" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329606">parent</a><span>|</span><a href="#40330244">prev</a><span>|</span><a href="#40329697">next</a><span>|</span><label class="collapse" for="c-40330253">[-]</label><label class="expand" for="c-40330253">[1 more]</label></div><br/><div class="children"><div class="content">Which is actually the case in enterprise source code, touched by hundreds of offshoring companies.</div><br/></div></div><div id="40329697" class="c"><input type="checkbox" id="c-40329697" checked=""/><div class="controls bullet"><span class="by">mirsadm</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329606">parent</a><span>|</span><a href="#40330253">prev</a><span>|</span><a href="#40331449">next</a><span>|</span><label class="collapse" for="c-40329697">[-]</label><label class="expand" for="c-40329697">[3 more]</label></div><br/><div class="children"><div class="content">Any professional developer should understand these things. It was taught at first year of my computer science degree. As you say it isn&#x27;t particularly difficult if you have a strategy. If you can&#x27;t manage memory then what about any other resource that needs to be manually closed (sockets, file handles etc ).</div><br/><div id="40329919" class="c"><input type="checkbox" id="c-40329919" checked=""/><div class="controls bullet"><span class="by">da_chicken</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329697">parent</a><span>|</span><a href="#40331449">next</a><span>|</span><label class="collapse" for="c-40329919">[-]</label><label class="expand" for="c-40329919">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand the causal link between something having a proven track record of being error-prone and not <i>understanding</i> it.</div><br/><div id="40330604" class="c"><input type="checkbox" id="c-40330604" checked=""/><div class="controls bullet"><span class="by">prerok</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329919">parent</a><span>|</span><a href="#40331449">next</a><span>|</span><label class="collapse" for="c-40330604">[-]</label><label class="expand" for="c-40330604">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that automatic memory management means to some newcomers that you don&#x27;t have to worry about it. Which is not true at all.<p>These newcomers may have heard about it, may even understand it at some level, but it&#x27;s not in their rote knowledge. GC is great if you know that every allocation you do is expensive and that you know that it will be taken care of properly, because it will be short-lived.<p>But I have seen many cases where people just don&#x27;t have it in their conciousness why allocating huge arrays is a problem or why allocating a new Character object for every single character in a string might be bad. As soon as I point it out, they get it, but it&#x27;s not like they thought of it while writing their algorithm.</div><br/></div></div></div></div></div></div></div></div><div id="40331449" class="c"><input type="checkbox" id="c-40331449" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329254">parent</a><span>|</span><a href="#40329606">prev</a><span>|</span><a href="#40328430">next</a><span>|</span><label class="collapse" for="c-40331449">[-]</label><label class="expand" for="c-40331449">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.<p>-Brian Kernighan.</div><br/></div></div></div></div><div id="40328430" class="c"><input type="checkbox" id="c-40328430" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40329254">prev</a><span>|</span><a href="#40328978">next</a><span>|</span><label class="collapse" for="c-40328430">[-]</label><label class="expand" for="c-40328430">[36 more]</label></div><br/><div class="children"><div class="content">Memory bugs is an entire class of bugs that we have simply solved. If you use a language with a modern garbage collector (e.g. one that can handle cycles), you will very likely go an entire project without running into a single memory bug. To a first approximation, these bugs were not replaced with other bugs; they are simply gone. Further, we do not ask anything more of the programmer do accomplish this. Instead, we need the programmer to do less work than they would need to do with manual memory management.<p>That is not to say that garbage collection is an unambigous win. There are real downsides to using it. But for most programs, those modern garbage collectors are good enough that those downsides just don&#x27;t matter.</div><br/><div id="40328976" class="c"><input type="checkbox" id="c-40328976" checked=""/><div class="controls bullet"><span class="by">mattpallissard</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328430">parent</a><span>|</span><a href="#40329418">next</a><span>|</span><label class="collapse" for="c-40328976">[-]</label><label class="expand" for="c-40328976">[13 more]</label></div><br/><div class="children"><div class="content">&gt; you will very likely go an entire project without running into a single memory bug<p>Sure, you haven&#x27;t lost the handle to the memory, but you can still &quot;leak&quot; memory with a GC.  Happens all the time.  Add to data structure at state 1, do something in state 2, remove data in state 3.  What happens you never hit state 3?<p>&gt; But for most programs, those modern garbage collectors are good enough that those downsides just don&#x27;t matter.<p>I mostly agree with this.  Although, most programs hit a point where you have to be aware what the GC is doing and try to avoid additional allocations.  Which isn&#x27;t very ergonomic at times.   And is often more fucking around than manual memory management, just concentrated to a smaller portion of the code base.</div><br/><div id="40329311" class="c"><input type="checkbox" id="c-40329311" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328976">parent</a><span>|</span><a href="#40329332">next</a><span>|</span><label class="collapse" for="c-40329311">[-]</label><label class="expand" for="c-40329311">[1 more]</label></div><br/><div class="children"><div class="content">And this kind of leak is the same kind that is actually difficult to prevent and debug with manual allocation -- it&#x27;s present &#x2F; reachable in some structure, but not intentionally.  Say you have a cache of items -- how big should it grow?  Can it free space under memory pressure?  If you reuse items, do they own collections (e.g., std::vec) that hold on to reserved but unused space (e.g. clear() doesn&#x27;t free memory)?  These are the hard problems and they are approximately the same with or without GC.</div><br/></div></div><div id="40329332" class="c"><input type="checkbox" id="c-40329332" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328976">parent</a><span>|</span><a href="#40329311">prev</a><span>|</span><a href="#40332564">next</a><span>|</span><label class="collapse" for="c-40329332">[-]</label><label class="expand" for="c-40329332">[3 more]</label></div><br/><div class="children"><div class="content">Joshua Bloch, of Effective Java fame, used the term unintentional object retention as a more precise term for memory âleaksâ in garbage collected languages.</div><br/><div id="40329548" class="c"><input type="checkbox" id="c-40329548" checked=""/><div class="controls bullet"><span class="by">mattpallissard</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329332">parent</a><span>|</span><a href="#40330049">next</a><span>|</span><label class="collapse" for="c-40329548">[-]</label><label class="expand" for="c-40329548">[1 more]</label></div><br/><div class="children"><div class="content">Seemes a bit pedantic, but so am I.  I like that term.</div><br/></div></div><div id="40330049" class="c"><input type="checkbox" id="c-40330049" checked=""/><div class="controls bullet"><span class="by">DowsingSpoon</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329332">parent</a><span>|</span><a href="#40329548">prev</a><span>|</span><a href="#40332564">next</a><span>|</span><label class="collapse" for="c-40330049">[-]</label><label class="expand" for="c-40330049">[1 more]</label></div><br/><div class="children"><div class="content">Iâve also heard this referred to as Abandoned Memory, or sometimes a Space Leak. Itâs a common class of bug in a reference counted language, like Objective-C, where cycles need special consideration.</div><br/></div></div></div></div><div id="40332564" class="c"><input type="checkbox" id="c-40332564" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328976">parent</a><span>|</span><a href="#40329332">prev</a><span>|</span><a href="#40329122">next</a><span>|</span><label class="collapse" for="c-40332564">[-]</label><label class="expand" for="c-40332564">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sure, you haven&#x27;t lost the handle to the memory, but you can still &quot;leak&quot; memory with a GC. Happens all the time. Add to data structure at state 1, do something in state 2, remove data in state 3. What happens you never hit state 3?<p>What happens if you never escape a while loop? Should we ban while loop then? Bugs happen, we fix them. But I haven&#x27;t had a memory bug in years outside of C and C++.</div><br/></div></div><div id="40329122" class="c"><input type="checkbox" id="c-40329122" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328976">parent</a><span>|</span><a href="#40332564">prev</a><span>|</span><a href="#40329418">next</a><span>|</span><label class="collapse" for="c-40329122">[-]</label><label class="expand" for="c-40329122">[7 more]</label></div><br/><div class="children"><div class="content">Are you calling just allocating memory youâll never use leaking? It is not. It is recoverable because for it not to be GCâd it has to be someone accessible. A memory leak means you lost the pointer to the memory, so now you canât free it.</div><br/><div id="40330499" class="c"><input type="checkbox" id="c-40330499" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329122">parent</a><span>|</span><a href="#40329281">next</a><span>|</span><label class="collapse" for="c-40330499">[-]</label><label class="expand" for="c-40330499">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m OK with people using the expression &quot;memory leak&quot; to mean &quot;unbounded growth in heap size over time&quot;.  The case that I see most frequently is a routine that&#x27;s set up like &quot;use some memory, wait until an event that never happens happens, free memory&quot;.  Technically if you let time run indefinitely, the memory would be freed.  But since memory is finite, eventually you run out and your program crashes, which is annoying in this case.</div><br/></div></div><div id="40329281" class="c"><input type="checkbox" id="c-40329281" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329122">parent</a><span>|</span><a href="#40330499">prev</a><span>|</span><a href="#40329222">next</a><span>|</span><label class="collapse" for="c-40329281">[-]</label><label class="expand" for="c-40329281">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Are you calling just allocating memory youâll never use leaking? It is not.<p>Yes it is, by definition a memory leak is any memory that has been reserved but won&#x27;t be read from or written to. If you allocate memory into a data structure and after some point in time you will never read from or write to that memory, then that memory constitutes a leak.</div><br/><div id="40329498" class="c"><input type="checkbox" id="c-40329498" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329281">parent</a><span>|</span><a href="#40332487">next</a><span>|</span><label class="collapse" for="c-40329498">[-]</label><label class="expand" for="c-40329498">[2 more]</label></div><br/><div class="children"><div class="content">There are (at least) 2 definitions of memory leak.<p>The upsides of the definition you gave are that it&#x27;s simple, well defined, and maximally precise (nothing that is safe to collect is considered live)<p>The significant downside to this definition is that it&#x27;s uncomputable. To know if memory is used requires knowing if a loop halts.<p>The second definition of memory leak is &quot;unreachability&quot; which is a bit harder to nail down. It&#x27;s a conservative approximation of the first definition, but is more popular because it&#x27;s computable, and it&#x27;s practical to write programs with or without GC that don&#x27;t leak</div><br/><div id="40330853" class="c"><input type="checkbox" id="c-40330853" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329498">parent</a><span>|</span><a href="#40332487">next</a><span>|</span><label class="collapse" for="c-40330853">[-]</label><label class="expand" for="c-40330853">[1 more]</label></div><br/><div class="children"><div class="content">The latter definition is not particularly useful for writing programs that run on hardware with finite memory.  End users don&#x27;t care whether or not the allocations are reachable when your program uses all the memory in the system and crowds out other programs, slows, and&#x2F;or crashes.</div><br/></div></div></div></div><div id="40332487" class="c"><input type="checkbox" id="c-40332487" checked=""/><div class="controls bullet"><span class="by">coding123</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329281">parent</a><span>|</span><a href="#40329498">prev</a><span>|</span><a href="#40329222">next</a><span>|</span><label class="collapse" for="c-40332487">[-]</label><label class="expand" for="c-40332487">[1 more]</label></div><br/><div class="children"><div class="content">That could also potentially be a cache in a highly unused program.</div><br/></div></div></div></div><div id="40329222" class="c"><input type="checkbox" id="c-40329222" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329122">parent</a><span>|</span><a href="#40329281">prev</a><span>|</span><a href="#40329418">next</a><span>|</span><label class="collapse" for="c-40329222">[-]</label><label class="expand" for="c-40329222">[1 more]</label></div><br/><div class="children"><div class="content">lost can include you don&#x27;t know where to find it even though you know it exists...</div><br/></div></div></div></div></div></div><div id="40329418" class="c"><input type="checkbox" id="c-40329418" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328430">parent</a><span>|</span><a href="#40328976">prev</a><span>|</span><a href="#40328478">next</a><span>|</span><label class="collapse" for="c-40329418">[-]</label><label class="expand" for="c-40329418">[8 more]</label></div><br/><div class="children"><div class="content">Uncollectable reference cycles are shockingly easy to make in JS, especially with React. A classic example:<p><pre><code>    function closure() {
        var smallObject = 3;
        var largeObject = Array(1000000);

        function longLived() { return smallObject; }
        function shortLived() { return largeObject; }
        shortLived(); return longLived;
    }
</code></pre>
Will keep largeObject alive.</div><br/><div id="40330144" class="c"><input type="checkbox" id="c-40330144" checked=""/><div class="controls bullet"><span class="by">AgentME</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329418">parent</a><span>|</span><a href="#40332096">next</a><span>|</span><label class="collapse" for="c-40330144">[-]</label><label class="expand" for="c-40330144">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t an uncollectable reference cycle. It&#x27;s true that with this code in most&#x2F;all JS engines, if there&#x27;s a reference to the function `longLived` then `largeObject` will be kept in memory, but reference cycles are collectable in standard garbage collection systems. Both of the values will be garbage-collectable once no outside references to `longLived` still exist. Pure reference counting systems (Rust Rc, C++ shared_ptr, etc) are the kind of system that fail to automatically handle cycles.<p>You could test this with your code by setting a FinalizationRegistry to log when they&#x27;re both finalized, unset any outside reference to `longLived`, and then do something to force a GC (like run Node with --expose-gc and call `global.gc()`, or just allocate a big Uint8Array).</div><br/></div></div><div id="40332096" class="c"><input type="checkbox" id="c-40332096" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329418">parent</a><span>|</span><a href="#40330144">prev</a><span>|</span><a href="#40329522">next</a><span>|</span><label class="collapse" for="c-40332096">[-]</label><label class="expand" for="c-40332096">[1 more]</label></div><br/><div class="children"><div class="content">Geez!  Didn&#x27;t henry baker warn against implementing closures this way <i>decades</i> ago?  This is an implementation bugâthe code is fine.</div><br/></div></div><div id="40329522" class="c"><input type="checkbox" id="c-40329522" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329418">parent</a><span>|</span><a href="#40332096">prev</a><span>|</span><a href="#40331323">next</a><span>|</span><label class="collapse" for="c-40329522">[-]</label><label class="expand" for="c-40329522">[3 more]</label></div><br/><div class="children"><div class="content">Is this a property of JavaScript or the engine running it? This feels like something a sufficiently-smartâ¢ closure implementation should be able to prevent.</div><br/><div id="40329659" class="c"><input type="checkbox" id="c-40329659" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329522">parent</a><span>|</span><a href="#40332287">next</a><span>|</span><label class="collapse" for="c-40329659">[-]</label><label class="expand" for="c-40329659">[1 more]</label></div><br/><div class="children"><div class="content">This is an artifact of V8&#x27;s GC. Effectively, largeObject and smallObject are tracked together, as a unit. Splitting it out into two separate records increases average memory usage. They keep saying they want to fix it eventually, but it&#x27;s been this way for 10+ years at this point.<p>You really do have to know the quirks of what you&#x27;re targeting.</div><br/></div></div><div id="40332287" class="c"><input type="checkbox" id="c-40332287" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329522">parent</a><span>|</span><a href="#40329659">prev</a><span>|</span><a href="#40331323">next</a><span>|</span><label class="collapse" for="c-40332287">[-]</label><label class="expand" for="c-40332287">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sufficiently-smartâ¢<p>Well, the reference lua implementation handles this case fine, and it&#x27;s a solid but not at all smartâ¢ codebase.</div><br/></div></div></div></div><div id="40329600" class="c"><input type="checkbox" id="c-40329600" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329418">parent</a><span>|</span><a href="#40331323">prev</a><span>|</span><a href="#40328478">next</a><span>|</span><label class="collapse" for="c-40329600">[-]</label><label class="expand" for="c-40329600">[1 more]</label></div><br/><div class="children"><div class="content">JS runtimes are allowed to optimize this out, IIRC, and will often do so.</div><br/></div></div></div></div><div id="40328478" class="c"><input type="checkbox" id="c-40328478" checked=""/><div class="controls bullet"><span class="by">barbariangrunge</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328430">parent</a><span>|</span><a href="#40329418">prev</a><span>|</span><a href="#40332121">next</a><span>|</span><label class="collapse" for="c-40328478">[-]</label><label class="expand" for="c-40328478">[1 more]</label></div><br/><div class="children"><div class="content">Even game engines (including unreal) use gc these days, which is nuts. Still though, itâs best to be careful with your allocations, use pooling, etc</div><br/></div></div><div id="40332121" class="c"><input type="checkbox" id="c-40332121" checked=""/><div class="controls bullet"><span class="by">jules</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328430">parent</a><span>|</span><a href="#40328478">prev</a><span>|</span><a href="#40328778">next</a><span>|</span><label class="collapse" for="c-40332121">[-]</label><label class="expand" for="c-40332121">[1 more]</label></div><br/><div class="children"><div class="content">The article in question is about Ruby, which is garbage collected.<p>It&#x27;s easy to get in trouble with an interconnected object graph: you mess up and hold onto a pointer that you shouldn&#x27;t be holding onto, which results in a leak.</div><br/></div></div><div id="40328778" class="c"><input type="checkbox" id="c-40328778" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328430">parent</a><span>|</span><a href="#40332121">prev</a><span>|</span><a href="#40330545">next</a><span>|</span><label class="collapse" for="c-40328778">[-]</label><label class="expand" for="c-40328778">[9 more]</label></div><br/><div class="children"><div class="content">There is one downside, though it&#x27;s not inherent to garbage collection, it just happens to correlate in current languages. Gc&#x27;d languages don&#x27;t have raii, and for that reason they actually make you do <i>more</i> work when managing non-memory resources. The have been some attempts to work around this with e.g. pythons <i>with</i>, but In my opinion it&#x27;s less ergonomic due to forcing indentation.</div><br/><div id="40328931" class="c"><input type="checkbox" id="c-40328931" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328778">parent</a><span>|</span><a href="#40329402">next</a><span>|</span><label class="collapse" for="c-40328931">[-]</label><label class="expand" for="c-40328931">[7 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s defer works like RAII and does not introduce indentations.<p><pre><code>    f := createFile(&quot;&#x2F;tmp&#x2F;defer.txt&quot;)
    defer closeFile(f)
    writeFile(f)</code></pre></div><br/><div id="40328979" class="c"><input type="checkbox" id="c-40328979" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328931">parent</a><span>|</span><a href="#40330310">next</a><span>|</span><label class="collapse" for="c-40328979">[-]</label><label class="expand" for="c-40328979">[5 more]</label></div><br/><div class="children"><div class="content">Even when the syntax does require indentation (&quot;with&quot; in python, &quot;using&quot; in C#) it&#x27;s still pretty clean IMO.</div><br/><div id="40329464" class="c"><input type="checkbox" id="c-40329464" checked=""/><div class="controls bullet"><span class="by">david_allison</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328979">parent</a><span>|</span><a href="#40329487">next</a><span>|</span><label class="collapse" for="c-40329464">[-]</label><label class="expand" for="c-40329464">[3 more]</label></div><br/><div class="children"><div class="content">Additionally, `using` no longer requires indentation in C#<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-reference&#x2F;proposals&#x2F;csharp-8.0&#x2F;using" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-ref...</a></div><br/><div id="40330229" class="c"><input type="checkbox" id="c-40330229" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329464">parent</a><span>|</span><a href="#40329487">next</a><span>|</span><label class="collapse" for="c-40330229">[-]</label><label class="expand" for="c-40330229">[2 more]</label></div><br/><div class="children"><div class="content">TIL!<p>I just recently updated a few small services to C# 12 and there&#x27;s a bunch of little niceties like this I&#x27;m finding (spread operator for instance).</div><br/><div id="40330281" class="c"><input type="checkbox" id="c-40330281" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40330229">parent</a><span>|</span><a href="#40329487">next</a><span>|</span><label class="collapse" for="c-40330281">[-]</label><label class="expand" for="c-40330281">[1 more]</label></div><br/><div class="children"><div class="content">Using also no longer requires inheritance from IDispose, it suffices that the type does support Dispose pattern, which is great when coupled with extension methods.</div><br/></div></div></div></div></div></div><div id="40329487" class="c"><input type="checkbox" id="c-40329487" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328979">parent</a><span>|</span><a href="#40329464">prev</a><span>|</span><a href="#40330310">next</a><span>|</span><label class="collapse" for="c-40329487">[-]</label><label class="expand" for="c-40329487">[1 more]</label></div><br/><div class="children"><div class="content">Using no longer requires a new scope block in more recent versions of C#</div><br/></div></div></div></div><div id="40330310" class="c"><input type="checkbox" id="c-40330310" checked=""/><div class="controls bullet"><span class="by">valicord</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328931">parent</a><span>|</span><a href="#40328979">prev</a><span>|</span><a href="#40329402">next</a><span>|</span><label class="collapse" for="c-40330310">[-]</label><label class="expand" for="c-40330310">[1 more]</label></div><br/><div class="children"><div class="content">This misses the main benefit of RAII which is that you can&#x27;t forget to close the file.</div><br/></div></div></div></div><div id="40329402" class="c"><input type="checkbox" id="c-40329402" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328778">parent</a><span>|</span><a href="#40328931">prev</a><span>|</span><a href="#40330545">next</a><span>|</span><label class="collapse" for="c-40329402">[-]</label><label class="expand" for="c-40329402">[1 more]</label></div><br/><div class="children"><div class="content">Do they?<p><pre><code>    &#x2F;&#x2F; Disposed when goes out of scope
    using var http = new HttpClient();
    var text = await http.GetStringAsync(&quot;https:&#x2F;&#x2F;example.org&#x2F;&quot;);</code></pre></div><br/></div></div></div></div><div id="40330545" class="c"><input type="checkbox" id="c-40330545" checked=""/><div class="controls bullet"><span class="by">patrick451</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328430">parent</a><span>|</span><a href="#40328778">prev</a><span>|</span><a href="#40328978">next</a><span>|</span><label class="collapse" for="c-40330545">[-]</label><label class="expand" for="c-40330545">[3 more]</label></div><br/><div class="children"><div class="content">Performance regression is a bug and GC has a horrific overhead in the average program. My computer is orders of magnitude faster than it was 15 years ago but it spends all of it&#x27;s time wondering around in the wilderness hunting for memory to free. We could have just told it.<p>&gt; those modern garbage collectors are good enough that those downsides just don&#x27;t matter.<p>This is not what I see. Every I look at a profile of a program written in a GCed language, most of the time is spent in the garbage collector. I can&#x27;t recall the last time I looked at a c++ profile where more than 10% of the time spent in new&#x2F;delete. I have seen 100x speedups by disabling GC. You can&#x27;t ship that, but it proves there is massive overhead to garbage collection.</div><br/><div id="40330860" class="c"><input type="checkbox" id="c-40330860" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40330545">parent</a><span>|</span><a href="#40328978">next</a><span>|</span><label class="collapse" for="c-40330860">[-]</label><label class="expand" for="c-40330860">[2 more]</label></div><br/><div class="children"><div class="content">&gt; GC has a horrific overhead in the average program<p>It doesn&#x27;t have to be that way. The BEAM is designed for tiny processes, and GC is cheap.</div><br/><div id="40330941" class="c"><input type="checkbox" id="c-40330941" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40330860">parent</a><span>|</span><a href="#40328978">next</a><span>|</span><label class="collapse" for="c-40330941">[-]</label><label class="expand" for="c-40330941">[1 more]</label></div><br/><div class="children"><div class="content">I love Erlang and BEAM, but the reason the GC is (mostly) cheap is because self-referential data structures are impossible, so you can have a very simple and yet still very effective GC. One heap per process also helps immensely.<p>Also, when your process has a giant heap, the GC gets expensive. There&#x27;s been lots of improvement over the years, but I used to have processes that could usually go through N messages&#x2F;sec, but if they ever got a backlog, the throughput would drop, and that would tend towards more backlog and even less throughput, and pretty soon it will never catch up.<p>That sometimes happens with other GC systems, but it never feels quite so dire.</div><br/></div></div></div></div></div></div></div></div><div id="40328978" class="c"><input type="checkbox" id="c-40328978" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40328430">prev</a><span>|</span><a href="#40327974">next</a><span>|</span><label class="collapse" for="c-40328978">[-]</label><label class="expand" for="c-40328978">[1 more]</label></div><br/><div class="children"><div class="content">IMO itâs not that memory management is hard, itâs that developers are imperfect, so writing a 100% UB-free, leak-free program is hard. And it only takes a single oversight to cause havoc, be it a CVE, leak that causes a long-running program to slowly grow memory, or hair-pulling bug that occurs 1 in 1000 times.<p>Yes, logic bugs have the same issues, and even in languages like Java we can sometimes (albeit rarely IIRC) get memory leaks. But memory-safe languages are an <i>improvement</i>. Just like TypeScript is an improvement over JavaScript, even though they have the same semantics. We have automated systems that can decrease the amount of memory errors from 1% to 0.01%, why keep leak and UB prevention a manual concern? Moreover, the drawbacks of memory-safe languages are often not an issue: you can use a GC-based language like Java which is easy but has overhead, or an enforced-ownership language like Rust which has a learning curve but no overhead. Meanwhile, while logic bugs can be a PITA, memory bugs are particularly notorious, since they donât give you a clear error message or in some cases even cause your program to halt when they occur.<p>Tangential: another solution that practically eliminated a class of bugs is formal verification. And currently we donât see it in any system but those where correctness is most important, but thatâs because unlike memory management the downsides are very large (extremely verbose, tricky code that must be structured a certain way or itâs even more verbose and tricky). But if formal verification gets better I believe that will also start to become more mainstream.</div><br/></div></div><div id="40327974" class="c"><input type="checkbox" id="c-40327974" checked=""/><div class="controls bullet"><span class="by">elondaits</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40328978">prev</a><span>|</span><a href="#40327831">next</a><span>|</span><label class="collapse" for="c-40327974">[-]</label><label class="expand" for="c-40327974">[4 more]</label></div><br/><div class="children"><div class="content">I worked with manual memory management for a decade (24&#x2F;7 systems) and donât miss it. Itâs not per-se hard, itâs not scary, but if youâre dealing with structures that may contain reference loops, or using an architecture based on event handlers that may be moving references around, you need to do some very careful design around memory management instead of just thinking of the problem domain.</div><br/><div id="40328333" class="c"><input type="checkbox" id="c-40328333" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40327974">parent</a><span>|</span><a href="#40331169">next</a><span>|</span><label class="collapse" for="c-40328333">[-]</label><label class="expand" for="c-40328333">[2 more]</label></div><br/><div class="children"><div class="content">By far, the worst memory leak Iâve ever had to debug involved a cycle like you are describing, but it was in a Java program (swing encourages&#x2F;encouraged such leaks, and âmemory leaks in java are impossibleâ, so there werenât decent heap profilers at the time).<p>For the last few decades, Iâve been writing c&#x2F;c++&#x2F;rust code, and the tooling there makes it trivial to find such things.<p>One good approach is to use a C++ custom allocator (that wraps a standard allocator) that gets a reference to a call site specific counter (or type specific counter) at compile time.  When an object is allocated it increments the counter.   When deleted, it decrements.<p>Every few minutes, it logs the top 100 allocation sites, sorted by object count or memory usage.  At process exit, return an error code if any counters are non-zero.<p>With that, people canât check in memory leaks that are encountered by tests.<p>In practice, the overhead of such a thing is too low to be measured, so it can be on all the time.  That lets it find leaks that only occur in customer environments.</div><br/><div id="40328916" class="c"><input type="checkbox" id="c-40328916" checked=""/><div class="controls bullet"><span class="by">billjings</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328333">parent</a><span>|</span><a href="#40331169">next</a><span>|</span><label class="collapse" for="c-40328916">[-]</label><label class="expand" for="c-40328916">[1 more]</label></div><br/><div class="children"><div class="content">But circular references don&#x27;t leak in Java. You have to have a GC root (e.g. a static, or something in your runtime) somewhere pointing at the thing to actually leak it.<p>There is one case where a &quot;circular&quot; reference can appear to cause a leak that I know of: WeakHashMap. But that&#x27;s because the keys, which are indeed cleaned up at some point once the associated value is GC&#x27;d, are themselves strongly retained references.</div><br/></div></div></div></div><div id="40331169" class="c"><input type="checkbox" id="c-40331169" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40327974">parent</a><span>|</span><a href="#40328333">prev</a><span>|</span><a href="#40327831">next</a><span>|</span><label class="collapse" for="c-40331169">[-]</label><label class="expand" for="c-40331169">[1 more]</label></div><br/><div class="children"><div class="content">Excluding from the problem domain the tool - and the constrains that come with it - namely the computer, isn&#x27;t it a bit arbitrary?<p>I think nowadays the only major languages that don&#x27;t provide GC are C&#x2F;C++, and one use them typically for their unrivaled performances, meaning performance is a more or less explicit requirement, so it is part of the problem domain.</div><br/></div></div></div></div><div id="40327831" class="c"><input type="checkbox" id="c-40327831" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40327974">prev</a><span>|</span><a href="#40327862">next</a><span>|</span><label class="collapse" for="c-40327831">[-]</label><label class="expand" for="c-40327831">[4 more]</label></div><br/><div class="children"><div class="content">35% of vulnerabilities in the biggest tech companies being due to use after free bugs are a part of the answer. (More than 90% of severe vulnerabilities are due to memory bugs impossible in memory-safe languages.)</div><br/><div id="40329328" class="c"><input type="checkbox" id="c-40329328" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40327831">parent</a><span>|</span><a href="#40329188">next</a><span>|</span><label class="collapse" for="c-40329328">[-]</label><label class="expand" for="c-40329328">[2 more]</label></div><br/><div class="children"><div class="content">Manual memory management vs GC is orthogonal to memory safe vs unsafe.</div><br/><div id="40330287" class="c"><input type="checkbox" id="c-40330287" checked=""/><div class="controls bullet"><span class="by">AgentME</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40329328">parent</a><span>|</span><a href="#40329188">next</a><span>|</span><label class="collapse" for="c-40330287">[-]</label><label class="expand" for="c-40330287">[1 more]</label></div><br/><div class="children"><div class="content">In practice the lines of each issue are placed very close together. Other than Rust, there are no popular memory safe languages that use manual memory management.</div><br/></div></div></div></div><div id="40329188" class="c"><input type="checkbox" id="c-40329188" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40327831">parent</a><span>|</span><a href="#40329328">prev</a><span>|</span><a href="#40327862">next</a><span>|</span><label class="collapse" for="c-40329188">[-]</label><label class="expand" for="c-40329188">[1 more]</label></div><br/><div class="children"><div class="content">Every memory-safe language has a runtime written in a memory-managed language. Yes, even Rust: Rust is implemented using many (well-vetted) unsafe blocks.<p>So projects to improve the quality, and lower the defect rate, in memory-managed programming, are far from wasted.  Even if they only get used to write fast garbage collectors so that line coders can get on with the work of delivering value  to customers.</div><br/></div></div></div></div><div id="40327862" class="c"><input type="checkbox" id="c-40327862" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40327831">prev</a><span>|</span><a href="#40330055">next</a><span>|</span><label class="collapse" for="c-40327862">[-]</label><label class="expand" for="c-40327862">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We do the same for OS resources (handles, sockets, etc) and dont use automatic resource managers<p>1) Modern languages have made inroads here.<p>2) The OS is my automatic resource manager.  When I hit ctrl-c on my running C program, my free() is never hit, yet it is cleaned up for me.<p>&gt; So why complicate the design with automatic memory management?<p>I don&#x27;t know beforehand who is going to be reading my memory, how many times, in what order, or whether they&#x27;re going to copy out of it, or hold onto pointers into it.<p>&gt; I just dont understand the fear with manual memory management. With RAII and and simple diligance (clear ownership rules), managing memory is an easy engineering task.<p>I claim that if managing memory is that straightforward, then it makes more sense to leave it to the compiler (Rust-style, not Java-style.) rather than let a human risk messing it up.</div><br/></div></div><div id="40330055" class="c"><input type="checkbox" id="c-40330055" checked=""/><div class="controls bullet"><span class="by">derriz</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40327862">prev</a><span>|</span><a href="#40328204">next</a><span>|</span><label class="collapse" for="c-40330055">[-]</label><label class="expand" for="c-40330055">[3 more]</label></div><br/><div class="children"><div class="content">Sure, for simple flows-of-control, GC buys you little and an RAII type approach is fine.  But RAII really only works if lifecycle and ownership spans are reflected in the lexical structure of the code base.  RAII relies on creation and cleanup happening within a block&#x2F;lexical scope.<p>Unfortunately in the real C++ codebases I&#x27;ve had to work with, the flow of control is never so simple.  Any correspondence between lexical scope and  lifecycle is broken if the code uses exceptions, callbacks, any type of async, threads, etc.</div><br/><div id="40332459" class="c"><input type="checkbox" id="c-40332459" checked=""/><div class="controls bullet"><span class="by">pixelfarmer</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40330055">parent</a><span>|</span><a href="#40330125">next</a><span>|</span><label class="collapse" for="c-40332459">[-]</label><label class="expand" for="c-40332459">[1 more]</label></div><br/><div class="children"><div class="content">No, it still applies. You have to think on a higher abstraction level, like components with interfaces between them of sorts. If one of them creates a resource (because this goes far beyond memory allocations which are also only resources), it MUST take care to delete that resource again. Whether that happens in a different thread or whatever: Who cares. (And yes, more care needs to be taken around creation&#x2F;deletion&#x2F;use of resources then.) The Linux kernel is loaded with examples of it.<p>Any deviation from that MUST be documented which includes seeing that as comments in code so people who read&#x2F;maintain that code know what this is all about.<p>Thing is, many memory leaks are actually logic bugs and no (resource-)GC will save your bacon against these, in fact, you made your life more complicated through it because now you have to debug through another (abstraction) layer before getting to the true problem.<p>This is what this ownership in Rust is all about: It makes ownership visible to the programmer so they have to take care about it in a very explicit manner.</div><br/></div></div><div id="40330125" class="c"><input type="checkbox" id="c-40330125" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40330055">parent</a><span>|</span><a href="#40332459">prev</a><span>|</span><a href="#40328204">next</a><span>|</span><label class="collapse" for="c-40330125">[-]</label><label class="expand" for="c-40330125">[1 more]</label></div><br/><div class="children"><div class="content">... or a persistent data-structure [1].<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Persistent_data_structure" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Persistent_data_structure</a></div><br/></div></div></div></div><div id="40328204" class="c"><input type="checkbox" id="c-40328204" checked=""/><div class="controls bullet"><span class="by">inetknght</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40330055">prev</a><span>|</span><a href="#40332553">next</a><span>|</span><label class="collapse" for="c-40328204">[-]</label><label class="expand" for="c-40328204">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>just dont understand the fear with manual memory management. With RAII and and simple diligance (clear ownership rules), managing memory is an easy engineering task. I actually find it </i>more* challenging to deal with frameworks that insist or reference counting and shared pointers since ownership is now obscure.*<p>I mostly agree.<p>With RAII, memory management is simplified. &quot;Just&quot; evaluate the lifetime of the object. Super easy if you&#x27;re good at software design.<p>Reference counting and shared pointers still have their niche use case. But I&#x27;ve most often seen referencing counting used as a crutch where reference-counting is _easy_ but designing around object lifetimes is more appropriate.<p>&gt; <i>Memory bugs are no worse than logic bugs</i><p>It&#x27;s true. A memory bug is &quot;just&quot; another logic bug. Memory bugs lead to null pointers and wild pointers. They&#x27;re just as dangerous as logic bugs. Memory bugs are also <i>far</i> more preventable with RAII.<p>&gt; <i>We do the same for OS resources (handles, sockets, etc) and dont use automatic resource managers, we do it manually. So why complicate the design with automatic memory management? </i><p>I&#x27;m just going to point out that I <i>don&#x27;t</i> do manual allocations for OS resources. I wrap OS resources into RAII objects. I&#x27;ve made lots (!) of custom RAII wrappers for OS objects and library objects. It&#x27;s trivial to do and saves a <i>feckton</i> of headaches.<p>C++ has std::fstream. I&#x27;m not saying it&#x27;s great. But it&#x27;s definitely RAII for files and has been around for... well I don&#x27;t know exactly but certainly 25+ years.</div><br/><div id="40328301" class="c"><input type="checkbox" id="c-40328301" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328204">parent</a><span>|</span><a href="#40332553">next</a><span>|</span><label class="collapse" for="c-40328301">[-]</label><label class="expand" for="c-40328301">[1 more]</label></div><br/><div class="children"><div class="content">RAII was a huge improvement over C and I was shocked to see Zig forego such an improvement.  Rust adopted RAII, and took it all to the next level with no data races and a lot more bugs caught at compile time.</div><br/></div></div></div></div><div id="40332553" class="c"><input type="checkbox" id="c-40332553" checked=""/><div class="controls bullet"><span class="by">anon-3988</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40328204">prev</a><span>|</span><a href="#40327919">next</a><span>|</span><label class="collapse" for="c-40332553">[-]</label><label class="expand" for="c-40332553">[1 more]</label></div><br/><div class="children"><div class="content">You can literally replace memory management in your post with stack management.<p>You wouldn&#x27;t say the same thing about stack push and pop would you? Memory management is kind of a solved problem for 99% of program. It only happens very rarely and under very constrained environment.<p>Yes, I did encountered a stack overflow error because I didn&#x27;t realize the size of the struct is gigantic. So I solved it by creating the object on the heap instead. Similarly, memory &quot;bugs&quot; in managed systems is very rare and they can mostly be solved.<p>Every time a managed systems have issues, we get blog posts like this exactly because they are rare. If I write a blog post every time I have encountered a memory leak in a C program, well no one really cares. It&#x27;s kind of expected.</div><br/></div></div><div id="40327919" class="c"><input type="checkbox" id="c-40327919" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40332553">prev</a><span>|</span><a href="#40330247">next</a><span>|</span><label class="collapse" for="c-40327919">[-]</label><label class="expand" for="c-40327919">[1 more]</label></div><br/><div class="children"><div class="content">Memory leaks can be hard to track down, but overflows and use after free bugs can take a project weeks off schedule. Depending on what is overwritten and where, the effects show up very far from the source of the problem. For an engineering or product manager this is a terrifying prospect. Managed memory more or less solves those problems - it introduces a couple of others and there are still a possibility of resource leaks but these problems are both more rare and generally easier to pin down.</div><br/></div></div><div id="40330247" class="c"><input type="checkbox" id="c-40330247" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40327919">prev</a><span>|</span><a href="#40328107">next</a><span>|</span><label class="collapse" for="c-40330247">[-]</label><label class="expand" for="c-40330247">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t scale in large teams of various skill levels.</div><br/></div></div><div id="40328107" class="c"><input type="checkbox" id="c-40328107" checked=""/><div class="controls bullet"><span class="by">watermelon0</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40330247">prev</a><span>|</span><a href="#40328464">next</a><span>|</span><label class="collapse" for="c-40328107">[-]</label><label class="expand" for="c-40328107">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We do the same for OS resources (handles, sockets, etc) and dont use automatic resource managers, we do it manually.<p>Generally, in most languages, file handles and sockets are automatically closed, when the variable holding them gets out of scope.</div><br/></div></div><div id="40328040" class="c"><input type="checkbox" id="c-40328040" checked=""/><div class="controls bullet"><span class="by">pylua</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40328464">prev</a><span>|</span><a href="#40328005">next</a><span>|</span><label class="collapse" for="c-40328040">[-]</label><label class="expand" for="c-40328040">[1 more]</label></div><br/><div class="children"><div class="content">Businesses need software to be less complex and easier to develop so it is cheaper.<p>I canât imagine manual memory management on these large scale projects with a high variance of developer scale and opinions.</div><br/></div></div><div id="40328005" class="c"><input type="checkbox" id="c-40328005" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40328040">prev</a><span>|</span><a href="#40329616">next</a><span>|</span><label class="collapse" for="c-40328005">[-]</label><label class="expand" for="c-40328005">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Memory bugs are no worse than logic bugs<p>I guess it comes down to what you mean by &quot;worse&quot;. It seems that memory bugs carry a higher risk of being completely invisible except in deliberately contrived situations. This makes them more dangerous because there&#x27;s less of an incentive to fix something that clients will never notice.</div><br/><div id="40328742" class="c"><input type="checkbox" id="c-40328742" checked=""/><div class="controls bullet"><span class="by">_gabe_</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40328005">parent</a><span>|</span><a href="#40329616">next</a><span>|</span><label class="collapse" for="c-40328742">[-]</label><label class="expand" for="c-40328742">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems that memory bugs carry a higher risk of being completely invisible except in deliberately contrived situations.<p>Do they <i>really</i> carry a higher risk of being invisible though? You donât need to âcontriveâ situations either. My company just spent 6+ months trying to solve a JavaScript undefined symbol bug stemming from a library. When we finally tracked it down, it was because we were using import instead of require, which the documentation didnât clarify was important. The fix we implemented was nowhere near where we expected the bug, and the only reason we finally solved it was because we had exhausted all other options. Sounds the same, if not worse, as a difficult to track memory bug to me.</div><br/></div></div></div></div><div id="40329616" class="c"><input type="checkbox" id="c-40329616" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40328005">prev</a><span>|</span><a href="#40330535">next</a><span>|</span><label class="collapse" for="c-40329616">[-]</label><label class="expand" for="c-40329616">[1 more]</label></div><br/><div class="children"><div class="content">If manually managing memory were in fact an easy engineering task, software developers wouldn&#x27;t be so demonstrably bad at it.</div><br/></div></div><div id="40329369" class="c"><input type="checkbox" id="c-40329369" checked=""/><div class="controls bullet"><span class="by">artemonster</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40330535">prev</a><span>|</span><a href="#40331176">next</a><span>|</span><label class="collapse" for="c-40329369">[-]</label><label class="expand" for="c-40329369">[1 more]</label></div><br/><div class="children"><div class="content">Oh yes! And also dont forget about the hand holding static type system that wont let you fart unless you explicitly convince it that you will not shit your pants!</div><br/></div></div><div id="40331176" class="c"><input type="checkbox" id="c-40331176" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40327791">parent</a><span>|</span><a href="#40329369">prev</a><span>|</span><a href="#40329480">next</a><span>|</span><label class="collapse" for="c-40331176">[-]</label><label class="expand" for="c-40331176">[2 more]</label></div><br/><div class="children"><div class="content">So you never, ever, ever make a mistake? No, don&#x27;t bother answering that. Of course you do. No amount of &quot;engineering discipline&quot; in the world can stamp out the human propensity to occasionally make a mistake.</div><br/><div id="40331280" class="c"><input type="checkbox" id="c-40331280" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#40327791">root</a><span>|</span><a href="#40331176">parent</a><span>|</span><a href="#40329480">next</a><span>|</span><label class="collapse" for="c-40331280">[-]</label><label class="expand" for="c-40331280">[1 more]</label></div><br/><div class="children"><div class="content">Where did they say that?<p>Why do you jump to that?<p>Why didn&#x27;t you assume that they make errors like everyone, and simply deal with them?<p>Your ego is so fragile that it can&#x27;t survive un the the same universe with the idea that someone somewhere might be living just fine without a crutch you apparently consider indispensable?<p>The fact is there are more than one way to detect and avoid errors reaching all the way to production. Every other human activity since humans existed employs them for thousands of years before golang existed. Rigor and discipline and methodology are not actually impossible. Shock!</div><br/></div></div></div></div></div></div><div id="40329480" class="c"><input type="checkbox" id="c-40329480" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40327791">prev</a><span>|</span><a href="#40328183">next</a><span>|</span><label class="collapse" for="c-40329480">[-]</label><label class="expand" for="c-40329480">[3 more]</label></div><br/><div class="children"><div class="content">So one place I worked might win some sort of prize for the dumbest way to burn $5m with a memory leak.<p>So back in the 90s the printer driver in Solaris had a memory leak[1]. At the time I was a contractor for a big bank that is sadly&#x2F;not sadly no longer with us any more. This was when the status of faxes in confirming contracts hadn&#x27;t been sufficiently tested in court so banks used to book trades by fax and the system that sent the fax would also send a document to a particular printer which would print the trade confirm out and there was some poor sap whos job consisted of picking up the confirms from this printer, calling the counterparty and reading them out so that they were all on tape[2] and legally confirmed.<p>Anyhow one day the memory leak caused the printer driver to fall over and fail to print out one of the confirms so the person didn&#x27;t read it out on the telephone. The market moved substantially and the counterparty DKd the trade[3]. A lot of huffing and puffing by senior executives at the bank had no effect and they booked a $5m loss and made a policy to never trade with that particular bank again[4].  The fax printer job was moved to windows NT.<p>[1] According to the excellent &quot;Expert C programming&quot; this was eventually fixed because Scott McNealy, then CEO of Sun Microsystems had been given a very underpowered workstation (as CEO) so was affected a lot by this problem and eventually made enough of a fuss the devs got around to fixing it <a href="https:&#x2F;&#x2F;progforperf.github.io&#x2F;Expert_C_Programming.pdf" rel="nofollow">https:&#x2F;&#x2F;progforperf.github.io&#x2F;Expert_C_Programming.pdf</a><p>[2] Calls in the securities division of banks are pretty much always recorded for legal and compliance reasons<p>[3] DK stands for &quot;Don&#x27;t know&quot;.  If the other side says they &quot;don&#x27;t know&quot; a trade they are disputing the fact that a contract was made.<p>[4] Which I&#x27;m sure hurt us more than it hurt them as they could just trade somewhere else and pay some other bank their commission</div><br/><div id="40329654" class="c"><input type="checkbox" id="c-40329654" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#40329480">parent</a><span>|</span><a href="#40328183">next</a><span>|</span><label class="collapse" for="c-40329654">[-]</label><label class="expand" for="c-40329654">[2 more]</label></div><br/><div class="children"><div class="content">&gt;...they booked a $5m loss and made a policy to never trade with that particular bank again<p>Maybe I am too cynical, but would many businesses retroactively agree to a deal which would cost them a ton of money? If the Process requires Is dotted, Ts crossed, and a phone call confirmation which was never placed -why eat the loss when the other party should own the error?<p>Citi just had a lawsuit because of paying back a loan too quickly. I expect everyone in finance to play hard ball on written agreements when it works in their favor.</div><br/><div id="40329738" class="c"><input type="checkbox" id="c-40329738" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40329480">root</a><span>|</span><a href="#40329654">parent</a><span>|</span><a href="#40328183">next</a><span>|</span><label class="collapse" for="c-40329738">[-]</label><label class="expand" for="c-40329738">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes it happens. Particularly in big US old school broker-dealers, &quot;Dictum Meum Pactum&quot;[1] is something some people take very seriously especially since you will have a fruitful (if adversarial) working relationship over many years and may need someone to do you a personal favour in the future (eg giving you a job etc).<p>For example I know of one US investment bank where a very large options position was &quot;booked&quot; by a trader using a spreadsheet rather than in the official booking system which meant that the normal &quot;exercise and expiry&quot; alerts didn&#x27;t go off to warn people when the trade was about to expire. The trader in question went on holiday and as a result the trade expired more than a billion dollars[2] in the money. The CEO of the bank called up the counterparty and successfully persuaded them to honour the trade and pay up even though it had actually expired and everyone knew there was no legal obligation. As it was explained to me at the time, the counterparty had probably hedged the trade so was not scratching around the sofa trying to find the money.<p>[1] &quot;My word is my bond&quot;<p>[2] Yes.  With a b.</div><br/></div></div></div></div></div></div><div id="40328183" class="c"><input type="checkbox" id="c-40328183" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#40329480">prev</a><span>|</span><a href="#40329348">next</a><span>|</span><label class="collapse" for="c-40328183">[-]</label><label class="expand" for="c-40328183">[4 more]</label></div><br/><div class="children"><div class="content">Valgrind makes finding leaks so easy in C.<p>Fixing them is harder, but it&#x27;s usually easy if your design is right. I usually allocate and free in the same function unless the function is meant to allocate for the caller. (And then that call is considered allocation in the caller.)</div><br/><div id="40332886" class="c"><input type="checkbox" id="c-40332886" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40328183">parent</a><span>|</span><a href="#40329959">next</a><span>|</span><label class="collapse" for="c-40332886">[-]</label><label class="expand" for="c-40332886">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I usually allocate and free in the same function unless the function is meant to allocate for the caller. (And then that call is considered allocation in the caller.)<p>Yeah. I do a similar thing in C, but think of it as &#x27;differing level of scopes in the abstraction&#x27;[1].<p>It&#x27;s pretty easy to <i>visually spot</i> when a scope acquires a resource in $SCOPE::foo() and never releases that resource in the $SCOPE::cleanup().<p>[1] Like the way code has block scope, function scope, file scope and global scope, a problem domain or an abstraction over the solution (the model) also has varying levels of scope. I&#x27;ve never found this to be a taught thing, however. Modeling the problem domain and any proposed solution is a useful skill before jumping into coding a solution.</div><br/></div></div><div id="40329959" class="c"><input type="checkbox" id="c-40329959" checked=""/><div class="controls bullet"><span class="by">canucker2016</span><span>|</span><a href="#40328183">parent</a><span>|</span><a href="#40332886">prev</a><span>|</span><a href="#40329348">next</a><span>|</span><label class="collapse" for="c-40329959">[-]</label><label class="expand" for="c-40329959">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the &quot;repro the bug&quot; that&#x27;s hard...<p>When I worked on static analysis of codebases, the error handling codepath was the most likely source of problems.</div><br/><div id="40330091" class="c"><input type="checkbox" id="c-40330091" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#40328183">root</a><span>|</span><a href="#40329959">parent</a><span>|</span><a href="#40329348">next</a><span>|</span><label class="collapse" for="c-40330091">[-]</label><label class="expand" for="c-40330091">[1 more]</label></div><br/><div class="children"><div class="content">Yes.<p>To do that, I fuzz like crazy, and every path becomes a test, even if it means a lot of manual work checking each one. That alone exercises tons of error paths.<p>To cover 99% of the rest, I use SQLite&#x27;s error injection [1] on all tests. Just doing error injection on allocation gets you 90% of the way there.<p>[1]: <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;testing.html#anomaly_testing" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;testing.html#anomaly_testing</a></div><br/></div></div></div></div></div></div><div id="40329348" class="c"><input type="checkbox" id="c-40329348" checked=""/><div class="controls bullet"><span class="by">1024core</span><span>|</span><a href="#40328183">prev</a><span>|</span><a href="#40327225">next</a><span>|</span><label class="collapse" for="c-40329348">[-]</label><label class="expand" for="c-40329348">[5 more]</label></div><br/><div class="children"><div class="content">Reminds me of this story I heard about Yahoo. Their ads server had a memory leak and it would OOM after something like 10000 requests.<p>Their solution: restart the server after 8000 requests.<p>This worked for a year or two. And then it started OOM-ing after 8000 requests.<p>Next solution: restart the server after 6000 requests.</div><br/><div id="40330619" class="c"><input type="checkbox" id="c-40330619" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#40329348">parent</a><span>|</span><a href="#40330063">next</a><span>|</span><label class="collapse" for="c-40330619">[-]</label><label class="expand" for="c-40330619">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Their solution: restart the server after 8000 requests.<p>8000 requests is something like 500 milliseconds for the average ad server.<p>You need exceptionally fast restarts for that to work.</div><br/><div id="40331024" class="c"><input type="checkbox" id="c-40331024" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40329348">root</a><span>|</span><a href="#40330619">parent</a><span>|</span><a href="#40330725">next</a><span>|</span><label class="collapse" for="c-40331024">[-]</label><label class="expand" for="c-40331024">[1 more]</label></div><br/><div class="children"><div class="content">This is in the context of (y)Apache. You set MaxRequestsPerChild, so when the request limit is hit, the child is killed, a new one started, and requests can be served by other children until the replacement is ready. In a pure config, idle children block on accept, so the kernel does all the coordination work required to get requests to children, the child exits after hitting the cap, and the parent catches the exit and spawns another. As long as all the children don&#x27;t hit their cap at once, there&#x27;s no gap in service. If they do all hit the cap at once, it&#x27;s still not so bad.<p>I don&#x27;t know about ads, but on Yahoo Travel, I had no qualms about solving memory leaks that took months to show up with MaxRequestsPerChild 100000. I gave valgrind or something a whirl, but didn&#x27;t find it right away and was tired of getting paged once a quarter for it, so...<p>I did do some scaleout work for Shopping once, and found theirs set at 3. I don&#x27;t remember where I left it, but much higher. Nobody knew why it was 3, so I took the chance that it would become aparrent if I set it to 100, and nothing obvious was wrong and the servers were much happier. fork() is fast, but it&#x27;s not fast enough to do it every 3 requests.</div><br/></div></div><div id="40330725" class="c"><input type="checkbox" id="c-40330725" checked=""/><div class="controls bullet"><span class="by">wging</span><span>|</span><a href="#40329348">root</a><span>|</span><a href="#40330619">parent</a><span>|</span><a href="#40331024">prev</a><span>|</span><a href="#40330063">next</a><span>|</span><label class="collapse" for="c-40330725">[-]</label><label class="expand" for="c-40330725">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps now, but the story is about Yahoo, which means it could be from the early 2000s or late 90s. Traffic volumes were probably lower, computers were definitely slower, internet advertising was not as big as it is now, etc.</div><br/></div></div></div></div><div id="40330063" class="c"><input type="checkbox" id="c-40330063" checked=""/><div class="controls bullet"><span class="by">xandrius</span><span>|</span><a href="#40329348">parent</a><span>|</span><a href="#40330619">prev</a><span>|</span><a href="#40327225">next</a><span>|</span><label class="collapse" for="c-40330063">[-]</label><label class="expand" for="c-40330063">[1 more]</label></div><br/><div class="children"><div class="content">If that gives you extra time to move the problem to the future, I&#x27;d say that&#x27;s a win :D</div><br/></div></div></div></div><div id="40327225" class="c"><input type="checkbox" id="c-40327225" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40329348">prev</a><span>|</span><a href="#40327297">next</a><span>|</span><label class="collapse" for="c-40327225">[-]</label><label class="expand" for="c-40327225">[28 more]</label></div><br/><div class="children"><div class="content">&quot;I&#x27;m not a real programmer. I throw together things until it works then I move on. The real programmers will say &#x27;Yeah it works but you&#x27;re leaking memory everywhere. Perhaps we should fix that.&#x27; Iâll just restart Apache every 10 requests.&quot; -Rasmus Lerdorf, PHP Non-Designer<p><a href="https:&#x2F;&#x2F;en.wikiquote.org&#x2F;wiki&#x2F;Rasmus_Lerdorf" rel="nofollow">https:&#x2F;&#x2F;en.wikiquote.org&#x2F;wiki&#x2F;Rasmus_Lerdorf</a></div><br/><div id="40327306" class="c"><input type="checkbox" id="c-40327306" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#40327225">parent</a><span>|</span><a href="#40327231">next</a><span>|</span><label class="collapse" for="c-40327306">[-]</label><label class="expand" for="c-40327306">[22 more]</label></div><br/><div class="children"><div class="content">Never calling free() is a valid memory management strategy if you know your process lifetime exactly.</div><br/><div id="40327353" class="c"><input type="checkbox" id="c-40327353" checked=""/><div class="controls bullet"><span class="by">iveqy</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327306">parent</a><span>|</span><a href="#40327338">next</a><span>|</span><label class="collapse" for="c-40327353">[-]</label><label class="expand" for="c-40327353">[1 more]</label></div><br/><div class="children"><div class="content">Git is actually using that approach which means that libgit is pretty useless to embed, which noone does anyway since it&#x27;s GPL and everyone instead uses libgit2.</div><br/></div></div><div id="40327338" class="c"><input type="checkbox" id="c-40327338" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327306">parent</a><span>|</span><a href="#40327353">prev</a><span>|</span><a href="#40327438">next</a><span>|</span><label class="collapse" for="c-40327338">[-]</label><label class="expand" for="c-40327338">[8 more]</label></div><br/><div class="children"><div class="content">I tried to do this in a real program once.  The program only ever runs for a fraction of a second and then exits, so it seemed like a good candidate.  Unfortunately what happened after is that our company started running tools like Coverity which complained about leaked memory.  The path of least resistance was to fix that by adding free()&#x27;s everywhere.</div><br/><div id="40327397" class="c"><input type="checkbox" id="c-40327397" checked=""/><div class="controls bullet"><span class="by">matja</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327338">parent</a><span>|</span><a href="#40329224">next</a><span>|</span><label class="collapse" for="c-40327397">[-]</label><label class="expand" for="c-40327397">[5 more]</label></div><br/><div class="children"><div class="content">And then you accidently add a use-after-free bug by trying to satisfy a &quot;correctness&quot; tool...</div><br/><div id="40327516" class="c"><input type="checkbox" id="c-40327516" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327397">parent</a><span>|</span><a href="#40327922">next</a><span>|</span><label class="collapse" for="c-40327516">[-]</label><label class="expand" for="c-40327516">[1 more]</label></div><br/><div class="children"><div class="content">Itâs hard to fault the static analysis tooling here. Not freeing memory is, almost always, unintended behavior. Besides, if a business is going to blindly apply static analysis to their projects and then demand that every warning be âfixedâ, then the tool really isnât the problem.<p>Still, any serious developer should, at the very least, have the patience to interrogate their code.</div><br/></div></div><div id="40327922" class="c"><input type="checkbox" id="c-40327922" checked=""/><div class="controls bullet"><span class="by">jmb99</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327397">parent</a><span>|</span><a href="#40327516">prev</a><span>|</span><a href="#40327760">next</a><span>|</span><label class="collapse" for="c-40327922">[-]</label><label class="expand" for="c-40327922">[2 more]</label></div><br/><div class="children"><div class="content">Coverity will definitely warn you about use-after-free. Itâs not a âcorrectnessâ tool, itâs a static analyzer and probably the best one out there (imo). Yes in this use case itâs probably not too important to care about, but really any code base of importance should be run through it on a fairly regular basis.</div><br/><div id="40332253" class="c"><input type="checkbox" id="c-40332253" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327922">parent</a><span>|</span><a href="#40327760">next</a><span>|</span><label class="collapse" for="c-40332253">[-]</label><label class="expand" for="c-40332253">[1 more]</label></div><br/><div class="children"><div class="content">Coverity canât find all  use after free bugs.</div><br/></div></div></div></div><div id="40327760" class="c"><input type="checkbox" id="c-40327760" checked=""/><div class="controls bullet"><span class="by">nkrisc</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327397">parent</a><span>|</span><a href="#40327922">prev</a><span>|</span><a href="#40329224">next</a><span>|</span><label class="collapse" for="c-40327760">[-]</label><label class="expand" for="c-40327760">[1 more]</label></div><br/><div class="children"><div class="content">The tool doesnât demand it be satisfied, a manager does.</div><br/></div></div></div></div><div id="40329224" class="c"><input type="checkbox" id="c-40329224" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327338">parent</a><span>|</span><a href="#40327397">prev</a><span>|</span><a href="#40327403">next</a><span>|</span><label class="collapse" for="c-40329224">[-]</label><label class="expand" for="c-40329224">[1 more]</label></div><br/><div class="children"><div class="content">Worth pointing out that in Zig, you wouldn&#x27;t have had this problem in the first place. The natural way to write a program of that nature is to create an arena allocator, immediately defer arena.deinit() on the next line, and then allocate to your heart&#x27;s content.  When the function returns, on an error or otherwise, the arena is freed.<p>No need to go back later and add a bunch of free(), because you correctly implemented the memory policy as a matter of course, in two lines.</div><br/></div></div><div id="40327403" class="c"><input type="checkbox" id="c-40327403" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327338">parent</a><span>|</span><a href="#40329224">prev</a><span>|</span><a href="#40327438">next</a><span>|</span><label class="collapse" for="c-40327403">[-]</label><label class="expand" for="c-40327403">[1 more]</label></div><br/><div class="children"><div class="content">How much use after free and double free did you have to fix?</div><br/></div></div></div></div><div id="40327438" class="c"><input type="checkbox" id="c-40327438" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327306">parent</a><span>|</span><a href="#40327338">prev</a><span>|</span><a href="#40330126">next</a><span>|</span><label class="collapse" for="c-40327438">[-]</label><label class="expand" for="c-40327438">[7 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t do it though.<p>Unless you know you will only allocate 100x times less memory than the average user has it will bite you.<p>1. Your code is now fragile (in the taleb sense).<p>2. Your code is now unusable when someone wants to use it as a library in the future<p>3. You are now prone to memory fragmentation (many use a bump the pointer allocator when not freeing).<p>4. You encourage people to not care about free-ing anything â when you do turn free on, or turn a GC on, you might struggle to actually free anything because of references all over the place.</div><br/><div id="40327980" class="c"><input type="checkbox" id="c-40327980" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327438">parent</a><span>|</span><a href="#40329929">next</a><span>|</span><label class="collapse" for="c-40327980">[-]</label><label class="expand" for="c-40327980">[5 more]</label></div><br/><div class="children"><div class="content">In certain circumstances it can be a good move. It might significantly improve real world performance, for instance.<p>Walter did this in the DMD compiler years ago and it gave a drastic performance boost. [0]<p>&gt; You are now prone to memory fragmentation (many use a bump the pointer allocator when not freeing)<p>Pointer-bump allocation is immune to fragmentation by definition, no?<p>Keeping dead objects around might lead to caches filled with mostly &#x27;dead&#x27; data though.<p>[0] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20190126213344&#x2F;https:&#x2F;&#x2F;www.drdobbs.com&#x2F;cpp&#x2F;increasing-compiler-speed-by-over-75&#x2F;240158941" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20190126213344&#x2F;https:&#x2F;&#x2F;www.drdob...</a></div><br/><div id="40328459" class="c"><input type="checkbox" id="c-40328459" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327980">parent</a><span>|</span><a href="#40329929">next</a><span>|</span><label class="collapse" for="c-40328459">[-]</label><label class="expand" for="c-40328459">[4 more]</label></div><br/><div class="children"><div class="content">Walter doing that is why compiling my work project uses 70 gigs of ram and is slow - because nothing stays in the cache because everything gets copied so much (because copies are cheap right?)<p>Anecdotally people have told me that&#x27;s it&#x27;s faster with a modern malloc impl anyway, haven&#x27;t tried it properly.<p>&gt; Pointer-bump allocation is immune to fragmentation by definition, no?<p>In some sense yes but what I mean is that like should end up near like whereas if you have everything going through a single bumping allocator then you can have a pattern of<p>ABABAB where a proper allocator would do AAABBB which the cache can actually use.</div><br/><div id="40330140" class="c"><input type="checkbox" id="c-40330140" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40328459">parent</a><span>|</span><a href="#40329929">next</a><span>|</span><label class="collapse" for="c-40330140">[-]</label><label class="expand" for="c-40330140">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Walter doing that is why compiling my work project uses 70 gigs of ram and is slow - because nothing stays in the cache<p>This sounds like guesswork. Do you know the details of DMD&#x27;s internals? Have you done profiling to confirm poor cache behaviour?<p>Again, per the article I linked, when Walter made the change there was a drastic <i>improvement</i> in performance.<p>&gt; everything gets copied so much (because copies are cheap right?)<p>I&#x27;m not sure what copying you&#x27;re referring to here. Declining to call <i>free</i> has nothing to do with needless copy operations.<p>&gt; like should end up near like whereas if you have everything going through a single bumping allocator then you can have a pattern of ABABAB where a proper allocator would do AAABBB which the cache can actually use.<p>A general purpose allocator like <i>malloc</i> can&#x27;t segment the allocations for different types&#x2F;purposes, it only has the allocation size to go on. That&#x27;s true whether or not you ever call <i>free</i>. If you want to manage memory using purpose-specific pools, you&#x27;d need to do that yourself.<p>As for whether this really would improve cache performance, I imagine it&#x27;s possible, which is why we have discussions about structure-of-arrays vs array-of-structures, and the <i>entity component system</i> pattern used in gamedev. I&#x27;d be surprised if compiler code could be significantly accelerated with that kind of reworking, though.</div><br/><div id="40330763" class="c"><input type="checkbox" id="c-40330763" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40330140">parent</a><span>|</span><a href="#40330716">next</a><span>|</span><label class="collapse" for="c-40330763">[-]</label><label class="expand" for="c-40330763">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure what copying you&#x27;re referring to here. Declining to call free has nothing to do with needless copy operations<p>Think.<p>You make malloc feel inexpensive both by using a crappy but fast allocator and disabling free. People (reflexively) know this, and then they don&#x27;t get punished when they get extremely careless with their allocations because test suites never allocate enough memory to OOM the machine.<p>This isn&#x27;t some hypothetical, I have measured the amount of memory dmd ever actually writes to (i.e. after allocation) to be absurdly low. Like single digits.<p>Pretty much every bit of semantic analysis that hasn&#x27;t been optimized post-facto involves copying hundreds to thousands of bytes.<p>&gt; A general purpose allocator like malloc can&#x27;t segment the allocations for different types&#x2F;purposes, it only has the allocation size to go on. That&#x27;s true whether or not you ever call free.<p>The size is what I&#x27;m getting at, but a D allocator can do this because it gets given type information. (dmd allocates mainly with `new` which is then forwarded to the bump the pointer allocator if the GC is not un-disabled)<p>Also evidence that the exact scheme dmd uses is suboptimal wrt allocator impl:<p><a href="https:&#x2F;&#x2F;forum.dlang.org&#x2F;thread&#x2F;zmknwhsidfigzsiqcibs@forum.dlang.org" rel="nofollow">https:&#x2F;&#x2F;forum.dlang.org&#x2F;thread&#x2F;zmknwhsidfigzsiqcibs@forum.dl...</a></div><br/></div></div><div id="40330716" class="c"><input type="checkbox" id="c-40330716" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40330140">parent</a><span>|</span><a href="#40330763">prev</a><span>|</span><a href="#40329929">next</a><span>|</span><label class="collapse" for="c-40330716">[-]</label><label class="expand" for="c-40330716">[1 more]</label></div><br/><div class="children"><div class="content">I know the internals of DMD extremely well.</div><br/></div></div></div></div></div></div></div></div><div id="40329929" class="c"><input type="checkbox" id="c-40329929" checked=""/><div class="controls bullet"><span class="by">dur-randir</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327438">parent</a><span>|</span><a href="#40327980">prev</a><span>|</span><a href="#40330126">next</a><span>|</span><label class="collapse" for="c-40329929">[-]</label><label class="expand" for="c-40329929">[1 more]</label></div><br/><div class="children"><div class="content">Instagram ran ~year with GC disabled just fine, citing 10% better memory utilisation. While you might be right for a library code, on application level it sometimes makes sense.</div><br/></div></div></div></div><div id="40330126" class="c"><input type="checkbox" id="c-40330126" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327306">parent</a><span>|</span><a href="#40327438">prev</a><span>|</span><a href="#40327316">next</a><span>|</span><label class="collapse" for="c-40330126">[-]</label><label class="expand" for="c-40330126">[1 more]</label></div><br/><div class="children"><div class="content">CGI. But once you loose control of your memory in a large code base it is practically impossible to regain it. So you canât move to long lived server processes when you decide to enter the more modern era.</div><br/></div></div><div id="40327316" class="c"><input type="checkbox" id="c-40327316" checked=""/><div class="controls bullet"><span class="by">alternatex</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327306">parent</a><span>|</span><a href="#40330126">prev</a><span>|</span><a href="#40327314">next</a><span>|</span><label class="collapse" for="c-40327316">[-]</label><label class="expand" for="c-40327316">[1 more]</label></div><br/><div class="children"><div class="content">I think the complaint is that there was no strategy. The dude just wanted to build some websites.</div><br/></div></div><div id="40327314" class="c"><input type="checkbox" id="c-40327314" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327306">parent</a><span>|</span><a href="#40327316">prev</a><span>|</span><a href="#40327469">next</a><span>|</span><label class="collapse" for="c-40327314">[-]</label><label class="expand" for="c-40327314">[1 more]</label></div><br/><div class="children"><div class="content">Oldie but a goodie: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20180228-00&#x2F;?p=98125" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20180228-00&#x2F;?p=98...</a></div><br/></div></div><div id="40327469" class="c"><input type="checkbox" id="c-40327469" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327306">parent</a><span>|</span><a href="#40327314">prev</a><span>|</span><a href="#40327933">next</a><span>|</span><label class="collapse" for="c-40327469">[-]</label><label class="expand" for="c-40327469">[1 more]</label></div><br/><div class="children"><div class="content">free() doing nothing can be a valid application-level strategy. Not calling free() can bite you down the line.</div><br/></div></div></div></div><div id="40327231" class="c"><input type="checkbox" id="c-40327231" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40327225">parent</a><span>|</span><a href="#40327306">prev</a><span>|</span><a href="#40327297">next</a><span>|</span><label class="collapse" for="c-40327231">[-]</label><label class="expand" for="c-40327231">[5 more]</label></div><br/><div class="children"><div class="content">That explains PHP</div><br/><div id="40328853" class="c"><input type="checkbox" id="c-40328853" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327231">parent</a><span>|</span><a href="#40327240">next</a><span>|</span><label class="collapse" for="c-40328853">[-]</label><label class="expand" for="c-40328853">[3 more]</label></div><br/><div class="children"><div class="content">There is a scene in the pirates of the carribean I think of a lot. &quot;You are without a doubt the worst pirate I have ever heard of&quot; &quot;Ah, but you have heard of me.&quot;<p>He kept the scope down. He shipped. It was hugely successful. In the end it was overtaken and rightly so, but that doesn&#x27;t invalidate the success it had.</div><br/><div id="40328952" class="c"><input type="checkbox" id="c-40328952" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40328853">parent</a><span>|</span><a href="#40327240">next</a><span>|</span><label class="collapse" for="c-40328952">[-]</label><label class="expand" for="c-40328952">[2 more]</label></div><br/><div class="children"><div class="content">But it doesn&#x27;t justify the arrogance.<p>&quot;For all the folks getting excited about my quotes. Here is another - Yes, I am a terrible coder, but I am probably still better than you :)&quot; -Rasmus Lerdorf<p>OR the continued negligence.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40256878">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40256878</a><p>And who remembers how careless, reckless, and blithe he was with the PHP 5.3.7 release he didn&#x27;t bother to test because running tests was too much of a hassle because there were already so many test failures that wading through them all to see if there were any new ones was just too much to ask of him, the leader of the widely used project, in charge of cutting releases?<p>&gt;5.3.7 upgrade warning: [22-Aug-2011] Due to unfortunate issues with 5.3.7 (see bug#55439) users should postpone upgrading until 5.3.8 is released (expected in a few days).<p>No seriously, he&#x27;s literally as careless as he claims to be (when he says that repeatedly, you should believe him!), and his lack of giving a shit about things like tests and encryption and security that are extremely important has caused actual serious security problems, like breaking crypt() by checking in sloppy buggy code that would have caused a unit test to fail, but without bothering to run the unit tests (because so many of them failed anyway, so who cares??), and then MAKING A RELEASE of PHP 5.3.7 with, OF ALL THINGS, a broken untested crypt()!<p><a href="http:&#x2F;&#x2F;i.imgur.com&#x2F;cAvSr.jpg" rel="nofollow">http:&#x2F;&#x2F;i.imgur.com&#x2F;cAvSr.jpg</a><p>Do you think that&#x27;s just his sense of humor, a self deprecating joke, breaking then releasing crypt() without testing, that&#x27;s funny in some context? What context would that be? Do you just laugh and shrug it off with &quot;Let Rasmus be Rasmus!&quot;<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;jsudd&#x2F;you_see_rasmus_lerdorf_creator_of_php_wrecking&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;jsudd&#x2F;you_see_...</a><p>&gt;r314434 (rasmus): Make static analyzers happy<p>&gt;r315218 (stas): Unbreak crypt() (fix bug #55439) # If you want to remove static analyser messages, be my guest, but please run unit tests after<p><a href="http:&#x2F;&#x2F;svn.php.net&#x2F;viewvc&#x2F;php&#x2F;php-src&#x2F;trunk&#x2F;ext&#x2F;standard&#x2F;php_crypt_r.c?r1=314438&amp;r2=314437&amp;pathrev=314438" rel="nofollow">http:&#x2F;&#x2F;svn.php.net&#x2F;viewvc&#x2F;php&#x2F;php-src&#x2F;trunk&#x2F;ext&#x2F;standard&#x2F;php...</a><p><a href="https:&#x2F;&#x2F;plus.google.com&#x2F;113641248237520845183&#x2F;posts&#x2F;g68d9RvRA1i" rel="nofollow">https:&#x2F;&#x2F;plus.google.com&#x2F;113641248237520845183&#x2F;posts&#x2F;g68d9RvR...</a> [broken link]<p>&gt;Rasmus Lerdorf<p>&gt;+Lorenz H.-S. We do. See <a href="http:&#x2F;&#x2F;gcov.php.net" rel="nofollow">http:&#x2F;&#x2F;gcov.php.net</a><p>&gt;You can see the code coverage, test case failures, Valgrind reports and more for each branch.<p>&gt;The crypt change did trigger a test to fail, we just went a bit too fast with the release and didn&#x27;t notice the failure. This is mostly because we have too many test failures which is primarily caused by us adding tests for bug reports before actually fixing the bug. I still like the practice of adding test cases for bugs and then working towards making the tests pass, however for some of these non-critical bugs that are taking a while to change we should probably switch them to XFAIL (expected fail) so they don&#x27;t clutter up the test failure output and thus making it harder to spot new failures like this crypt one.<p>And don&#x27;t even get me started about mysql_real_escape_string! It has the word &quot;real&quot; in it. I mean, come on, who would ever name a function &quot;real&quot;, and why?<p>That implies the existence of a not-so-real mysql escape string function. Why didn&#x27;t they simply FIX the gaping security hole in the not-so-real mysql escape string function, instead of maintaining one that was real that you should use, and one that was not so real that you should definitely not use, in the name of backwards compatibility?<p>Or were there actually people out there using the non-real mysql escape string function, and they didn&#x27;t want to ruffle their feathers by forcing those people with code that had a security hole so big you could fly a space shuttle through to fix their gaping security holes?<p>The name of the function &quot;mysql_real_escape_string&quot; says all you need to know about the culture and carelessness and lack of security consciousness of the PHP community.<p>Melania Trump&#x27;s &quot;I REALLY DON&#x27;T CARE DO U?&quot; nihilistic fashion statement sums up Rasmus Lerdorf&#x27;s and the PHP community&#x27;s attitude towards security, software quality, programming, standards, computer science, and unit tests.<p>Â¯\_(ã)_&#x2F;Â¯<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=l5imY2oQauE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=l5imY2oQauE</a></div><br/><div id="40333053" class="c"><input type="checkbox" id="c-40333053" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40328952">parent</a><span>|</span><a href="#40327240">next</a><span>|</span><label class="collapse" for="c-40333053">[-]</label><label class="expand" for="c-40333053">[1 more]</label></div><br/><div class="children"><div class="content">Your examples of arrogance has nuance:<p>&gt; &quot;For all the folks getting excited about my quotes. Here is another - Yes, I am a terrible coder, but I am probably still better than you :)&quot; -Rasmus Lerdorf<p>Well, he shipped, met his user&#x27;s needs, met the markets needs and generally hit all the necessary bullet points to make a successful and lasting impact on the world. If he didn&#x27;t meet some requirement that you have, like memory safety, its because it wasn&#x27;t necessary.<p>Checking off the required stuff and leaving the optional stuff for later <i>is</i> the sign of a good coder.<p>&gt; his lack of giving a shit about things like tests and encryption and security that are extremely important<p>Woah there, cowboy! It turned out his take <i>was</i> correct, because it continued dominating over all those other technologies which cared about the thing <i>you</i> cared about.<p>Being correct is better than being elegant, clean, or bug-free.<p>&gt;  This is mostly because we have too many test failures which is primarily caused by us adding tests for bug reports before actually fixing the bug. I still like the practice of adding test cases for bugs and then working towards making the tests pass, however for some of these non-critical bugs that are taking a while to change<p>That&#x27;s just a different way of saying &quot;We didn&#x27;t have enough resources to make the fixes go quicker&quot;. What&#x27;s the alternative here? Don&#x27;t log the bug? Don&#x27;t make a test to repro the bug?<p>&gt; Why didn&#x27;t they simply FIX the gaping security hole in the not-so-real mysql escape string function,<p>You sound like you&#x27;ve never been in a professional development shop at all. The reason that things hang around seemingly forever is because <i>someone is using it!</i>.<p>It&#x27;s the amateur mickey-mouse outfits that remove stuff which users are still using. It really is the equivalent of &quot;Don&#x27;t break userland&quot;.<p>No professional worth their salt breaks their existing users without a very good reason. This is why Microsoft is still shipping broken win32 functions that were written in 1998. It&#x27;s why Linus insists &quot;Don&#x27;t break userland&quot;.<p>If you want to level up to professional level when shipping software, you&#x27;re going to be shipping a lot of mistakes that you already know about.<p>On the whole, your comment makes Rasmus look like more of a professional than you.</div><br/></div></div></div></div></div></div><div id="40327240" class="c"><input type="checkbox" id="c-40327240" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40327225">root</a><span>|</span><a href="#40327231">parent</a><span>|</span><a href="#40328853">prev</a><span>|</span><a href="#40327297">next</a><span>|</span><label class="collapse" for="c-40327240">[-]</label><label class="expand" for="c-40327240">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40256878">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40256878</a><p>&gt;It&#x27;s not &quot;supposed&quot; to be that way.<p>&gt;It just happened to end up that way because Rasmus Lerdorf just doesn&#x27;t give a shit. Â¯\_(ã)_&#x2F;Â¯<p>[...]</div><br/></div></div></div></div></div></div><div id="40327297" class="c"><input type="checkbox" id="c-40327297" checked=""/><div class="controls bullet"><span class="by">chubs</span><span>|</span><a href="#40327225">prev</a><span>|</span><a href="#40331975">next</a><span>|</span><label class="collapse" for="c-40327297">[-]</label><label class="expand" for="c-40327297">[3 more]</label></div><br/><div class="children"><div class="content">When I was a rails developer, the âdone thingâ was to simply throw hardware at issues like these as an acceptable tradeoff for productivity. If you cared about this sort of thing, youâd use something more formal. I find it personally difficult to calm my pearl-clutching perfectionist tendencies to embrace that approach but I canât deny it does work :)</div><br/><div id="40327394" class="c"><input type="checkbox" id="c-40327394" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40327297">parent</a><span>|</span><a href="#40331975">next</a><span>|</span><label class="collapse" for="c-40327394">[-]</label><label class="expand" for="c-40327394">[2 more]</label></div><br/><div class="children"><div class="content">Lifehack: instead of admitting you are rebooting the server every 10 minutes to clear the memory leaks, call it a &quot;phased arena allocation strategy&quot; and then it&#x27;s fine.</div><br/><div id="40327604" class="c"><input type="checkbox" id="c-40327604" checked=""/><div class="controls bullet"><span class="by">projektfu</span><span>|</span><a href="#40327297">root</a><span>|</span><a href="#40327394">parent</a><span>|</span><a href="#40331975">next</a><span>|</span><label class="collapse" for="c-40327604">[-]</label><label class="expand" for="c-40327604">[1 more]</label></div><br/><div class="children"><div class="content">Oddly, Apache uses a pool allocator[1], so it is using essentially the same strategy as Rasmus already.<p>1. or it did 20 years ago, i might be out of date :)</div><br/></div></div></div></div></div></div><div id="40331975" class="c"><input type="checkbox" id="c-40331975" checked=""/><div class="controls bullet"><span class="by">narag</span><span>|</span><a href="#40327297">prev</a><span>|</span><a href="#40327621">next</a><span>|</span><label class="collapse" for="c-40331975">[-]</label><label class="expand" for="c-40331975">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used languages with and without garbage collection. Usually, manual is more difficult to write, automatic is more difficult to troubleshoot.<p>I would love to use a language that allows me to do both. Writing exploratory code is more convenient using automatic memory management. There are certain kinds of code that benefit from manual memory management.<p>I find appalling that people can&#x27;t find a middle ground between forbidden and mandatory.</div><br/><div id="40331991" class="c"><input type="checkbox" id="c-40331991" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#40331975">parent</a><span>|</span><a href="#40331980">next</a><span>|</span><label class="collapse" for="c-40331991">[-]</label><label class="expand" for="c-40331991">[1 more]</label></div><br/><div class="children"><div class="content">That langauge is C++. I almost never do manual memory management in that language, but you can do it if you want.</div><br/></div></div><div id="40331980" class="c"><input type="checkbox" id="c-40331980" checked=""/><div class="controls bullet"><span class="by">amedvednikov</span><span>|</span><a href="#40331975">parent</a><span>|</span><a href="#40331991">prev</a><span>|</span><a href="#40327621">next</a><span>|</span><label class="collapse" for="c-40331980">[-]</label><label class="expand" for="c-40331980">[1 more]</label></div><br/><div class="children"><div class="content">V uses a GC by default, but it&#x27;s easily disabled per function&#x2F;module via the @[manualfree] attribute or for the entire project via `v -gc none`<p><a href="https:&#x2F;&#x2F;vlang.io" rel="nofollow">https:&#x2F;&#x2F;vlang.io</a></div><br/></div></div></div></div><div id="40327621" class="c"><input type="checkbox" id="c-40327621" checked=""/><div class="controls bullet"><span class="by">invisitor</span><span>|</span><a href="#40331975">prev</a><span>|</span><a href="#40327610">next</a><span>|</span><label class="collapse" for="c-40327621">[-]</label><label class="expand" for="c-40327621">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t read it all but I noticed I enjoyed the way you write. I don&#x27;t know if it&#x27;s the emojis or the overall formatting you use.</div><br/></div></div><div id="40327871" class="c"><input type="checkbox" id="c-40327871" checked=""/><div class="controls bullet"><span class="by">SomeoneFromCA</span><span>|</span><a href="#40327610">prev</a><span>|</span><label class="collapse" for="c-40327871">[-]</label><label class="expand" for="c-40327871">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Much has been written about various tools for profiling a leak, understanding heap dumps, common causes of leaks&quot;.<p>Eww.. leaks and heap dumps. Someone needs a healthier diet.</div><br/></div></div></div></div></div></div></div></body></html>