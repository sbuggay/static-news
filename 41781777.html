<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728464455038" as="style"/><link rel="stylesheet" href="styles.css?v=1728464455038"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://entropicthoughts.com/practices-of-reliable-software-design">Practices of Reliable Software Design</a>Â <span class="domain">(<a href="https://entropicthoughts.com">entropicthoughts.com</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>20 comments</span></div><br/><div><div id="41783154" class="c"><input type="checkbox" id="c-41783154" checked=""/><div class="controls bullet"><span class="by">nostrademons</span><span>|</span><a href="#41784984">next</a><span>|</span><label class="collapse" for="c-41783154">[-]</label><label class="expand" for="c-41783154">[8 more]</label></div><br/><div class="children"><div class="content">There is a bunch of good advice here, but it&#x27;s missed the most useful principal in my experience, probably because the motivating example is too small in scope:<p><i>The way to build reliable software systems is to have multiple independent paths to success.</i><p>This is the Erlang &quot;let it crash&quot; strategy restated, but I&#x27;ve also found it embodied in things like the architecture of Google Search, Tandem Computer, Ethereum, RAID 5, the Space Shuttle, etc.  Basically, you achieve reliability through redundancy.  For any given task, compute the answer multiple times in parallel, ideally in multiple independent ways.  If the answer agrees, great, you&#x27;re done.  If not, have some consensus mechanism to detect the true answer.  If you can&#x27;t compute the answer in parallel, or you still don&#x27;t get one back, retry.<p>The reason for this is simply math.  If you have n different events that must all go right to achieve success, the chance of this happening is x1 * x2 * ... * xn.  This product goes to zero very quickly - if you have 20 components connected in series that are all 98% reliable, the chance of success is only 2&#x2F;3.  If instead you have n different events where <i>any</i> one can go right to achieve success, the chance of success is 1 - (1 - y1) * (1 - y2) * ... * (1 - yn).  <i>This</i> inverse actually increases as the number of alternate pathways to success goes up and fast.  If you have 3 alternatives each of which has just an 80% chance of success, but any of the 3 will work, then doing them all in parallel has a 97% chance of success.<p>This is why complex software systems that must stay up are built with redundancy, replicas, failover, retries, and other similar mechanisms in place.  And the presence of those mechanisms usually trumps anything you can do to increase the reliability of individual components, simply because you get diminishing returns to carefulness.  You might spend 100x more resources to go from 90% reliability to 99% reliability, but if you can identify a system boundary and correctness check, you can get that 99% reliability simply by having 2 teams each build a subsystem that is 90% reliable and checking that their answers agree.</div><br/><div id="41784502" class="c"><input type="checkbox" id="c-41784502" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#41783154">parent</a><span>|</span><a href="#41783373">next</a><span>|</span><label class="collapse" for="c-41784502">[-]</label><label class="expand" for="c-41784502">[1 more]</label></div><br/><div class="children"><div class="content">I disagree somewhat, influenced by the teachings of Nancy Leveson.<p>In the 1930&#x27;s, yes, component redundancy was the way to reliability. This worked at the time because components were flaky and technical systems were simple aggregations of components. Today, components themselves are more reliable, but even when they are not, redundancy adds only a little reliability because there&#x27;s a new, large, source of failure: interactive complexity.<p>Today&#x27;s systems are so complicated that many failures stem from insufficient, misunderstood, or ambiguous specifications. These errors happen not because a component failed -- all components work exactly as they were intended to -- it is only that in their intended interactions they produce an unintended result. Failure is an emergent property.<p>The solution is to approach reliability from a system theoretic perspective. This very early draft contains the core of the idea, but not yet fleshed out or edited: <a href="https:&#x2F;&#x2F;entropicthoughts.com&#x2F;root-cause-analysis-youre-doing-it-wrong" rel="nofollow">https:&#x2F;&#x2F;entropicthoughts.com&#x2F;root-cause-analysis-youre-doing...</a></div><br/></div></div><div id="41783373" class="c"><input type="checkbox" id="c-41783373" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41783154">parent</a><span>|</span><a href="#41784502">prev</a><span>|</span><a href="#41785552">next</a><span>|</span><label class="collapse" for="c-41783373">[-]</label><label class="expand" for="c-41783373">[2 more]</label></div><br/><div class="children"><div class="content">In the limit, there is a hard tradeoff between efficiency and reliability.<p>Failovers, redundancies, and backups are all important for building systems that are resilient in the face of problems, for reasons you&#x27;ve pointed out.<p>However, failovers, redundancies and backups are inefficient. Solving a problem with 1 thing is always going to be more efficient that solving the same problem with 10 things.<p>It&#x27;s interesting to see this tradeoff play out in real-life. We see people coalescing around one or two services because that&#x27;s the most efficient path, and then we see them diversifying across multiple services once bad things happen to the centralised services.</div><br/><div id="41783670" class="c"><input type="checkbox" id="c-41783670" checked=""/><div class="controls bullet"><span class="by">hippich</span><span>|</span><a href="#41783154">root</a><span>|</span><a href="#41783373">parent</a><span>|</span><a href="#41785552">next</a><span>|</span><label class="collapse" for="c-41783670">[-]</label><label class="expand" for="c-41783670">[1 more]</label></div><br/><div class="children"><div class="content">Imho, the problem is that it is hard to estimate trade-offs. Optimizations (not just in computer systems, but in general) often seen as risk-free, when in reality they are not. More often than not one will be celebrated for optimization, and rarely for resilience (dubbed as duplicate, useless work)</div><br/></div></div></div></div><div id="41785552" class="c"><input type="checkbox" id="c-41785552" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41783154">parent</a><span>|</span><a href="#41783373">prev</a><span>|</span><a href="#41783883">next</a><span>|</span><label class="collapse" for="c-41785552">[-]</label><label class="expand" for="c-41785552">[1 more]</label></div><br/><div class="children"><div class="content">Who will replicate the consensus checker?</div><br/></div></div><div id="41783883" class="c"><input type="checkbox" id="c-41783883" checked=""/><div class="controls bullet"><span class="by">manvillej</span><span>|</span><a href="#41783154">parent</a><span>|</span><a href="#41785552">prev</a><span>|</span><a href="#41784984">next</a><span>|</span><label class="collapse" for="c-41783883">[-]</label><label class="expand" for="c-41783883">[3 more]</label></div><br/><div class="children"><div class="content">the simple basic reality of statistics, a binomial distribution.<p>5 independent systems with 90% chance of success is mathematically as reliable as one that is 99.999%.<p>100x 90% systems would get you to 100 &quot;9s&quot; of reliability aka 99.99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999%</div><br/><div id="41785806" class="c"><input type="checkbox" id="c-41785806" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#41783154">root</a><span>|</span><a href="#41783883">parent</a><span>|</span><a href="#41784408">next</a><span>|</span><label class="collapse" for="c-41785806">[-]</label><label class="expand" for="c-41785806">[1 more]</label></div><br/><div class="children"><div class="content">Actually making 5 completely independent systems would be exceptionally hard. No shared code or team members, no shared hardware... For example, what 5 computing platforms would you use? x86, ARM, RISC-V and...?<p>Math rarely applies so easily to real life. Talking about &quot;independent&quot; systems is cheap.<p>If at all possible. How would you transport yourself to work using two <i>independent</i> systems?</div><br/></div></div><div id="41784408" class="c"><input type="checkbox" id="c-41784408" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#41783154">root</a><span>|</span><a href="#41783883">parent</a><span>|</span><a href="#41785806">prev</a><span>|</span><a href="#41784984">next</a><span>|</span><label class="collapse" for="c-41784408">[-]</label><label class="expand" for="c-41784408">[1 more]</label></div><br/><div class="children"><div class="content">Except the binomial assumption obviously does not hold because<p>(a) failures are correlated, not independent, and<p>(b) many failures happen not at the component level but at the plane where components interact, and regardless of how much redundancy there is at the component level, there is ultimately just one plane at which they finally interact to produce a result.</div><br/></div></div></div></div></div></div><div id="41784984" class="c"><input type="checkbox" id="c-41784984" checked=""/><div class="controls bullet"><span class="by">SomewhatLikely</span><span>|</span><a href="#41783154">prev</a><span>|</span><a href="#41784606">next</a><span>|</span><label class="collapse" for="c-41784984">[-]</label><label class="expand" for="c-41784984">[1 more]</label></div><br/><div class="children"><div class="content">My first thought upon seeing the prompt:<p><pre><code>    If you would build an in-memory cache, how would you do it?

    It should have good performance and be able to hold many entries. 
    Reads are more common than writes. I know how I would do it already, 
    but Iâm curious about your approach.
</code></pre>
Was to add this requirement since it comes up so often:<p><pre><code>    Let&#x27;s assume that keys accessed follow a power law, so some keys get 
    accessed very frequently and we would like them to have the fastest 
    retrieval of all.
</code></pre>
I&#x27;m not sure if there are any efficient tweaks to hash tables or b-trees that might help with this additional requirement.  Obviously we could make a hash table take way more space than needed to reduce collisions, but with a decent load factor is the answer to just swap frequently accessed keys to the beginning of their probe chain?  How do we know it&#x27;s frequently accessed? Count-Min sketch?<p>Even with that tweak, the hottest keys will still be scattered around memory.  Wouldn&#x27;t it be best if their entries could fit into fewer pages?  So, maybe a much smaller &quot;hot&quot; table containing say the 1,000 most accessed keys.  We still want a high load factor to maximize the use of cache pages so perhaps perfect hashing?</div><br/></div></div><div id="41784606" class="c"><input type="checkbox" id="c-41784606" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#41784984">prev</a><span>|</span><a href="#41785402">next</a><span>|</span><label class="collapse" for="c-41784606">[-]</label><label class="expand" for="c-41784606">[3 more]</label></div><br/><div class="children"><div class="content">The first point is one that resonates strongly with me. Counter-intuitivly, the first instinct of a programmer should be &quot;buy that, don&#x27;t write it&quot;<p>Of course, as a programmer, this is by far not my first instinct. I am a programmer, my function is programming, not purchasing.<p>Of course buying something is always cheaper (compared to the cost of my time) and will be orders of magnitude cheaper once the costs to maintain written-by-me code is added in.<p>Things that are bought -tend- to last longer too. If I leave my job I leave behind a bunch of custom code nobody wants to work on. If I leave Redis behind, well, the next guy just carries on running Redis.<p>I know all this. I advocate for all this. But I&#x27;m a programmer, send coders gotta code:) do it&#x27;s not like we buy everything, I&#x27;m still there, still writing.<p>Hopefully though my emphasis is on adding value. Build things that others will take over one-day. Keep designs clean, and code cleaner.<p>And if I add one &#x27;practice&#x27; to the list; Don&#x27;t Be Clever. Clever code is hard to read, hard to understand, hard to maintain. Keep all code as simple as it can be. Reliable software is software that mostly isn&#x27;t trying to be too clever.</div><br/><div id="41784750" class="c"><input type="checkbox" id="c-41784750" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#41784606">parent</a><span>|</span><a href="#41785402">next</a><span>|</span><label class="collapse" for="c-41784750">[-]</label><label class="expand" for="c-41784750">[2 more]</label></div><br/><div class="children"><div class="content">This topic deserves an article on its own. I feel my team crossed &quot;the line&quot; on a SaaS that hosts docs from our Openapi and page doesnt even refresh safely. But how do we define the line?</div><br/><div id="41784836" class="c"><input type="checkbox" id="c-41784836" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#41784606">root</a><span>|</span><a href="#41784750">parent</a><span>|</span><a href="#41785402">next</a><span>|</span><label class="collapse" for="c-41784836">[-]</label><label class="expand" for="c-41784836">[1 more]</label></div><br/><div class="children"><div class="content">The line is where the cost of building is less than that of buying. It sounds like in your case building would have been cheaper, given the simplicity of the problem and the quality issues with the purchased solution.<p>It does get difficult in more complicated cases thanks to a lack of information on what a good solution looks like. This article attempts to straighten it out a little: <a href="https:&#x2F;&#x2F;entropicthoughts.com&#x2F;build-vs-buy" rel="nofollow">https:&#x2F;&#x2F;entropicthoughts.com&#x2F;build-vs-buy</a></div><br/></div></div></div></div></div></div><div id="41785402" class="c"><input type="checkbox" id="c-41785402" checked=""/><div class="controls bullet"><span class="by">l5870uoo9y</span><span>|</span><a href="#41784606">prev</a><span>|</span><a href="#41785480">next</a><span>|</span><label class="collapse" for="c-41785402">[-]</label><label class="expand" for="c-41785402">[1 more]</label></div><br/><div class="children"><div class="content">I would add a ninth practice; throw errors. You find and fix them as opposed to errors that go silently unnoticed in the code base.</div><br/></div></div><div id="41784578" class="c"><input type="checkbox" id="c-41784578" checked=""/><div class="controls bullet"><span class="by">u8_friedrich</span><span>|</span><a href="#41785480">prev</a><span>|</span><a href="#41783581">next</a><span>|</span><label class="collapse" for="c-41784578">[-]</label><label class="expand" for="c-41784578">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is much easier to add features to reliable software, than it is to add reliability to featureful software.<p>Not sure about this tbh. In a lot of cases yeah maybe. But when you are dealing with complicated business logic where there is a lot of bells and whistles required, building a simple reliable version can lead you into a naive implementation that might be reliable but very hard to extend, while making an unstable complicated thing can help you understand the pit falls and you can work back from there into something more reliable. So I think this depends very much on the context.</div><br/></div></div><div id="41783581" class="c"><input type="checkbox" id="c-41783581" checked=""/><div class="controls bullet"><span class="by">BillLucky</span><span>|</span><a href="#41784578">prev</a><span>|</span><a href="#41783222">next</a><span>|</span><label class="collapse" for="c-41783581">[-]</label><label class="expand" for="c-41783581">[1 more]</label></div><br/><div class="children"><div class="content">Simple but elegant design principles, recommended</div><br/></div></div></div></div></div></div></div></body></html>