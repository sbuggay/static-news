<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732352514043" as="style"/><link rel="stylesheet" href="styles.css?v=1732352514043"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.researchgate.net/publication/348993267_An_Analysis_of_the_Performance_of_Websockets_in_Various_Programming_Languages_and_Libraries">An Analysis of the Performance of WebSockets in Various Programming Languages (2021)</a> <span class="domain">(<a href="https://www.researchgate.net">www.researchgate.net</a>)</span></div><div class="subtext"><span>max0563</span> | <span>20 comments</span></div><br/><div><div id="42219400" class="c"><input type="checkbox" id="c-42219400" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#42219301">next</a><span>|</span><label class="collapse" for="c-42219400">[-]</label><label class="expand" for="c-42219400">[1 more]</label></div><br/><div class="children"><div class="content">If the author is reading this, I think a single repository would be more appropriate than multiple repos [1]. It would be nice to set things up so we can simply git pull, docker run, and execute the benchmarks for each language sequentially.<p>Something that stood out to me is the author’s conclusion that &quot;Node.js wins.&quot; However, both the Node.js and C++ versions use the same library, uWebSockets! I suspect the actual takeaway is this:<p>&quot;uWebSockets wins, and the uWebSockets authors know their library well enough that even their JavaScript wrapper outperforms my own implementation in plain C++ using the same library!&quot; :-p<p>Makes me wonder if there’s something different that could be done in Go to achieve better performance. Alternatively, this may highlight which language&#x2F;library makes it easier to do the right thing out of the box (for example, it seems easier to use uWebsockets in nodejs than in C++). TechEmpower controversies also come to mind, where &quot;winning&quot; implementations often don’t reflect how developers typically write code in a given language, framework, or library.<p>--<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;matttomasetti?tab=repositories&amp;q=websocket-benchmark">https:&#x2F;&#x2F;github.com&#x2F;matttomasetti?tab=repositories&amp;q=websocke...</a></div><br/></div></div><div id="42219301" class="c"><input type="checkbox" id="c-42219301" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#42219400">prev</a><span>|</span><a href="#42219283">next</a><span>|</span><label class="collapse" for="c-42219301">[-]</label><label class="expand" for="c-42219301">[6 more]</label></div><br/><div class="children"><div class="content">Their explanation for why Go performs badly didn&#x27;t make any sense to me. I&#x27;m not sure if they don&#x27;t understand how goroutines work, if I don&#x27;t understand how goroutines work or if I just don&#x27;t understand their explanation.<p>Also, in the end, they didn&#x27;t use the JSON payload. It would have been interesting if they had just written a static string. I&#x27;m curious how much of this is really measuring JSON [de]serialization performance.<p>Finally, it&#x27;s worth pointing out that WebSocket is a standard. It&#x27;s possible that some of these implementations follow the standard better than others. For example, WebSocket requires that a text message be valid UTF8. Personally, I think that&#x27;s a dumb requirement (and in my own websocket server implementation for Zig, I don&#x27;t enforce this - if the application wants to, it can). But it&#x27;s completely possible that some implementations enforce this and others don&#x27;t, and that (along with every other check) could make a difference.</div><br/><div id="42219830" class="c"><input type="checkbox" id="c-42219830" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#42219301">parent</a><span>|</span><a href="#42219340">next</a><span>|</span><label class="collapse" for="c-42219830">[-]</label><label class="expand" for="c-42219830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m curious how much of this is really measuring JSON [de]serialization performance.<p>Well, they did use the standard library for that, so quite a bit, I suppose. That thing is slow. I&#x27;ve got no idea how fast those functions are in other languages, but you&#x27;re right that it would ruin the idea behind the benchmark.</div><br/></div></div><div id="42219340" class="c"><input type="checkbox" id="c-42219340" checked=""/><div class="controls bullet"><span class="by">vandot</span><span>|</span><a href="#42219301">parent</a><span>|</span><a href="#42219830">prev</a><span>|</span><a href="#42219595">next</a><span>|</span><label class="collapse" for="c-42219340">[-]</label><label class="expand" for="c-42219340">[3 more]</label></div><br/><div class="children"><div class="content">They didn’t use goroutines, which is explains the poor perf. 
<a href="https:&#x2F;&#x2F;github.com&#x2F;matttomasetti&#x2F;Go-Gorilla_Websocket-Benchmark-Server&#x2F;blob&#x2F;master&#x2F;go-gorilla_websocket-benchmark-server.go#L58">https:&#x2F;&#x2F;github.com&#x2F;matttomasetti&#x2F;Go-Gorilla_Websocket-Benchm...</a><p>Also, this paper is from Feb 2021.</div><br/><div id="42219383" class="c"><input type="checkbox" id="c-42219383" checked=""/><div class="controls bullet"><span class="by">windlep</span><span>|</span><a href="#42219301">root</a><span>|</span><a href="#42219340">parent</a><span>|</span><a href="#42219595">next</a><span>|</span><label class="collapse" for="c-42219383">[-]</label><label class="expand" for="c-42219383">[2 more]</label></div><br/><div class="children"><div class="content">I was under the impression that the underlying net&#x2F;http library uses a new goroutine for every connection, so each websocket gets its own goroutine. Or is there somewhere else you were expecting goroutines in addition to the one per connection?</div><br/><div id="42219633" class="c"><input type="checkbox" id="c-42219633" checked=""/><div class="controls bullet"><span class="by">donjoe</span><span>|</span><a href="#42219301">root</a><span>|</span><a href="#42219383">parent</a><span>|</span><a href="#42219595">next</a><span>|</span><label class="collapse" for="c-42219633">[-]</label><label class="expand" for="c-42219633">[1 more]</label></div><br/><div class="children"><div class="content">Which is perfectly fine. However, you will be able to process only a single message per connection at once.<p>What you would do in go is:<p>- either a new goroutine per message<p>- or installing a worker pool with a predefined goroutine size accepting messages for processing</div><br/></div></div></div></div></div></div><div id="42219595" class="c"><input type="checkbox" id="c-42219595" checked=""/><div class="controls bullet"><span class="by">ikornaselur</span><span>|</span><a href="#42219301">parent</a><span>|</span><a href="#42219340">prev</a><span>|</span><a href="#42219283">next</a><span>|</span><label class="collapse" for="c-42219595">[-]</label><label class="expand" for="c-42219595">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I thought this looked familiar.. I went through this article about a year and a half ago when exploring WebSockets in Python for work. With some tuning and using a different libraries + libuv we were easily able to get similar performance to NodeJS.<p>I had a blog post somewhere to show the testing and results, but can&#x27;t seem to find it at the moment though.</div><br/></div></div></div></div><div id="42219283" class="c"><input type="checkbox" id="c-42219283" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#42219301">prev</a><span>|</span><a href="#42219440">next</a><span>|</span><label class="collapse" for="c-42219283">[-]</label><label class="expand" for="c-42219283">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the free access links. I did read through a bit.<p>The title is misleading because exactly one implementation was chosen for each of the tested languages. They conclude “do not us e Python” because the Python websockets library performs pretty poorly.<p>Each language is scored based on the library chosen. I have to believe there are more options for some of these languages.<p>As someone who is implementing an Elixir LiveView app right now, I was particularly curious to see how Elixir performed given LiveViews reliance on websockets, but as Elixir didn’t make the cut.</div><br/><div id="42219645" class="c"><input type="checkbox" id="c-42219645" checked=""/><div class="controls bullet"><span class="by">nelsonic</span><span>|</span><a href="#42219283">parent</a><span>|</span><a href="#42219440">next</a><span>|</span><label class="collapse" for="c-42219645">[-]</label><label class="expand" for="c-42219645">[1 more]</label></div><br/><div class="children"><div class="content">Was also surprised they omitted Elixir&#x2F;Erlang from the list of languages. Crazy considering how many messaging apps use OTP on the backend.</div><br/></div></div></div></div><div id="42219440" class="c"><input type="checkbox" id="c-42219440" checked=""/><div class="controls bullet"><span class="by">simpaticoder</span><span>|</span><a href="#42219283">prev</a><span>|</span><a href="#42219872">next</a><span>|</span><label class="collapse" for="c-42219440">[-]</label><label class="expand" for="c-42219440">[1 more]</label></div><br/><div class="children"><div class="content">Interesting that <a href="https:&#x2F;&#x2F;github.com&#x2F;uNetworking&#x2F;uWebSockets.js">https:&#x2F;&#x2F;github.com&#x2F;uNetworking&#x2F;uWebSockets.js</a> (which is C++ with node bindings) outperforms the raw C++ uWebSockets implementation.<p>It&#x27;s also interesting that <a href="https:&#x2F;&#x2F;github.com&#x2F;websockets&#x2F;ws">https:&#x2F;&#x2F;github.com&#x2F;websockets&#x2F;ws</a> does not appear in this study, given that in the node ecosystem it is ~3x more likely to be used (not a perfect measurement but ws has 28k github stars vs uWebSockets 8k stars)</div><br/></div></div><div id="42219872" class="c"><input type="checkbox" id="c-42219872" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#42219440">prev</a><span>|</span><a href="#42219416">next</a><span>|</span><label class="collapse" for="c-42219872">[-]</label><label class="expand" for="c-42219872">[1 more]</label></div><br/><div class="children"><div class="content">The DX for websockets in Go(gorilla) is horrible. But i do not believe these numbers one bit.</div><br/></div></div><div id="42219416" class="c"><input type="checkbox" id="c-42219416" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#42219872">prev</a><span>|</span><a href="#42219445">next</a><span>|</span><label class="collapse" for="c-42219416">[-]</label><label class="expand" for="c-42219416">[1 more]</label></div><br/><div class="children"><div class="content">(2021)
Was surprised it used a depreciated Rust crate until I noticed how out of date it is</div><br/></div></div><div id="42219280" class="c"><input type="checkbox" id="c-42219280" checked=""/><div class="controls bullet"><span class="by">5Qn8mNbc2FNCiVV</span><span>|</span><a href="#42219445">prev</a><span>|</span><a href="#42219746">next</a><span>|</span><label class="collapse" for="c-42219280">[-]</label><label class="expand" for="c-42219280">[2 more]</label></div><br/><div class="children"><div class="content">Too bad that uWebsockets was used for Node because a lot of higher level libraries are built on top of <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;ws" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;ws</a></div><br/><div id="42219395" class="c"><input type="checkbox" id="c-42219395" checked=""/><div class="controls bullet"><span class="by">windlep</span><span>|</span><a href="#42219280">parent</a><span>|</span><a href="#42219746">next</a><span>|</span><label class="collapse" for="c-42219395">[-]</label><label class="expand" for="c-42219395">[1 more]</label></div><br/><div class="children"><div class="content">I was able to make a uWebsockets adapter for NestJS pretty easily. It&#x27;s a bit sensitive of a library to integrate though, a single write when the connection is gone and you get a segfault, which means a lot of checking before writing if you&#x27;ve yielded since you last checked. This was a few years ago, perhaps they fixed that.</div><br/></div></div></div></div><div id="42219746" class="c"><input type="checkbox" id="c-42219746" checked=""/><div class="controls bullet"><span class="by">zo1</span><span>|</span><a href="#42219280">prev</a><span>|</span><a href="#42219181">next</a><span>|</span><label class="collapse" for="c-42219746">[-]</label><label class="expand" for="c-42219746">[1 more]</label></div><br/><div class="children"><div class="content">Was this published as-is to some sort of prominent CS journal? I honestly can&#x27;t tell from the link. If that&#x27;s the case, I&#x27;m very disappointed and would have a few choice words about the state of &quot;academia&quot;.</div><br/></div></div><div id="42219181" class="c"><input type="checkbox" id="c-42219181" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#42219746">prev</a><span>|</span><a href="#42219593">next</a><span>|</span><label class="collapse" for="c-42219181">[-]</label><label class="expand" for="c-42219181">[2 more]</label></div><br/><div class="children"><div class="content">The SSRN link doesn’t have a login-wall: <a href="https:&#x2F;&#x2F;papers.ssrn.com&#x2F;sol3&#x2F;papers.cfm?abstract_id=3778525" rel="nofollow">https:&#x2F;&#x2F;papers.ssrn.com&#x2F;sol3&#x2F;papers.cfm?abstract_id=3778525</a></div><br/><div id="42219217" class="c"><input type="checkbox" id="c-42219217" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#42219181">parent</a><span>|</span><a href="#42219593">next</a><span>|</span><label class="collapse" for="c-42219217">[-]</label><label class="expand" for="c-42219217">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! 
Here&#x27;s the direct link to the ungated PDF: <a href="https:&#x2F;&#x2F;download.ssrn.com&#x2F;21&#x2F;02&#x2F;03&#x2F;ssrn_id3778525_code4568915.pdf?response-content-disposition=inline&amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIBz9ASyrOZb7lgu4c7TPazOVmNtXFIfbhGR%2BPNEQRaLXAiEA8J7SZDs1dYpi7gpDiCI78zaJZIWZHkXIhbu99ui%2B3%2FEqxgUIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAEGgwzMDg0NzUzMDEyNTciDIv7tdkuoYsFpo6F7yqaBcYKhbXn5qs7JiWcTskh8279TVWylAjLpM2l9SEz2cHG8mE6XYRUCxg3r9mnm2c3ouVX8RheZ3i%2BapmEy12Nf6E1%2FYKsH9OpU9%2BAVjOn0n8gaHUAEitd1avpiSk662x0b86p09X8Dy7NV1uXI27%2FYfxEGUWvrvfYC%2BvYrLBSDFEaWOAxqPWFAoxVtz0wyDk07pVY%2FbDydStaAaEUGws9e6%2FcSOKv4tA3gr1DtS3Wc8UMsPMOlV6oUHK0jFVZyo1pL%2F6jT8KCZSRAiubk0XTk1TRfcJtI5htH9lZEJMusuky%2BNRaRcuOsLeXt0bRZGRMyQ7fm74yTc9QEckQB%2B%2FZ0cb7%2Fw3hd7C7Sq%2B2Wy9zyWGxoejoxHDMtvga%2BiBH6%2FyQGSltBG358vO3grSynJ3rpAxCwcCNlwY2Pb1yWjCzodVFYAsn6AUALL8gjg4oRQdjHSrZs%2F0I7RPdVYsrPevaU0pM9xIMDRANcdQtGoTsYoPgzRP%2FfPcQRnVXE4nJ8GB%2FlNtazu%2BLgoHTo6JHe4ds1y6GGGy7CHeDnBRyXdqveDq%2Brgjozivf0l96Lc8kqjY8PpAtJvUTYhmz%2FQsy%2B41Wu7bv1QRsaogIgapIAdHkY8Xv6FyXvZyfCKLqVAv4C%2FRRrGKJwycFQJ%2BXzUpJc8vl79Cbwn%2Fmf1gdKPFjhMB0s2skkSOQUcojbQnxfILJKVG1Pv904wH%2BapVRkPCohkRL4%2BafWioVD5d74%2BqbstnZIRoJw0dO0AocLPH0FP%2BdWXQRLB2qNVqUQOhdCYXxXX7iPpGXGhhj3hk7cvFmrgwDADm6DWHgXLX8d1vrKUMEjGJPxcB4sb6CzKs3bPh4Mb4%2BPMLczUMfei%2B6a8f5iY5NWJhnu2kIHVJI%2BoNXilTCUl4W6BjqxAfAUk4qD%2FPqQmUX4ZGPsZe3rEzgKdJr9RWN2ui5sbn6cp5Z6%2BAiT2VNCxd7VYCq0ZdhuDf7YDMkGcTEIBaCVKFWqk6TFNa7VTK4NnIh519yHZIcpStx5hUgQXrKfadCQ8PCb8a7BNAIq1rIXPdjeyc1XOzw1QDbcM3nARYhJY6UlHOYjEznllSKDjK%2BFuWOzdvg%2B9IlHDSisGa6sYJtqXRPYQtgcpXVC9EspXg0FqJZSlQ%3D%3D&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Date=20241123T042500Z&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Expires=300&amp;X-Amz-Credential=ASIAUPUUPRWE7KW6RUGY%2F20241123%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Signature=8a05d683177c04b274cb176dc107cda22c22e6f4180f2827578f5e6772c45f51&amp;abstractId=3778525" rel="nofollow">https:&#x2F;&#x2F;download.ssrn.com&#x2F;21&#x2F;02&#x2F;03&#x2F;ssrn_id3778525_code456891...</a><p>TLDR; NodeJS is the clear winner, and Python far and away the worst of the bunch.</div><br/></div></div></div></div></div></div></div></div></div></body></html>