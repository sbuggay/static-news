<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704531656404" as="style"/><link rel="stylesheet" href="styles.css?v=1704531656404"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.regehr.org/archives/1393">Teaching C (2016)</a> <span class="domain">(<a href="https://blog.regehr.org">blog.regehr.org</a>)</span></div><div class="subtext"><span>hasheddan</span> | <span>59 comments</span></div><br/><div><div id="38887385" class="c"><input type="checkbox" id="c-38887385" checked=""/><div class="controls bullet"><span class="by">chrsw</span><span>|</span><a href="#38888924">next</a><span>|</span><label class="collapse" for="c-38887385">[-]</label><label class="expand" for="c-38887385">[1 more]</label></div><br/><div class="children"><div class="content">A few good C books have come out in the time since this article was first published, 2016.<p><a href="https:&#x2F;&#x2F;nostarch.com&#x2F;Effective_C" rel="nofollow">https:&#x2F;&#x2F;nostarch.com&#x2F;Effective_C</a><p><a href="https:&#x2F;&#x2F;www.packtpub.com&#x2F;free-ebook&#x2F;extreme-c&#x2F;9781789343625" rel="nofollow">https:&#x2F;&#x2F;www.packtpub.com&#x2F;free-ebook&#x2F;extreme-c&#x2F;9781789343625</a><p><a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;fluent-c&#x2F;9781492097273" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;fluent-c&#x2F;9781492097273</a></div><br/></div></div><div id="38888924" class="c"><input type="checkbox" id="c-38888924" checked=""/><div class="controls bullet"><span class="by">heads</span><span>|</span><a href="#38887385">prev</a><span>|</span><a href="#38887384">next</a><span>|</span><label class="collapse" for="c-38888924">[-]</label><label class="expand" for="c-38888924">[1 more]</label></div><br/><div class="children"><div class="content">The thing that really got me into this subject was building my own virtual machine and then a compiler to turn a high level language into machine code.<p>It sounds complicated but the VM, in Python, is basically:<p><pre><code>  r = {}
  mem = []
  boot(mem)
  pc = 0
  while True:
    op, args = decode(mem[pc++])
    if op == “+”:
      d, a, b = args
      r[d] = r[a] + b
    elif ...:
      ...
</code></pre>
The “source” which gets “compiled” can also just be Python function calls that emit op codes — no need to get bogged down with lexing and parsing!<p>The thing you focus on is the semantics of representing a function call (and return) in machine code and how to manage the stack.  It made C make a lot more sense e.g. defining locals up front so the compiler knows how much stack space to use.  I wish I could remember more — this was all from teaching A-Level Computer Science a few years ago.</div><br/></div></div><div id="38887384" class="c"><input type="checkbox" id="c-38887384" checked=""/><div class="controls bullet"><span class="by">alilleybrinker</span><span>|</span><a href="#38888924">prev</a><span>|</span><a href="#38889519">next</a><span>|</span><label class="collapse" for="c-38887384">[-]</label><label class="expand" for="c-38887384">[2 more]</label></div><br/><div class="children"><div class="content">It’s not mentioned in the article, but I also think that learning how to debug and observe the behavior of C programs is useful given the limited ability to catch issues at compile time and high likelihood of code weaknesses and errors in C. Learning not just a traditional debugger like gdb or lldb, but also at least being introduced to tools like perf, strace, and ideally more powerful things like dtrace or bpftrace would be very helpful.<p>In my own Masters program we had a class on software systems which heavily featured both practical coverage of C and lots about debugging and observability. One of the most aggressively _useful_ classes I’ve taken.</div><br/><div id="38888570" class="c"><input type="checkbox" id="c-38888570" checked=""/><div class="controls bullet"><span class="by">clipsy</span><span>|</span><a href="#38887384">parent</a><span>|</span><a href="#38889519">next</a><span>|</span><label class="collapse" for="c-38888570">[-]</label><label class="expand" for="c-38888570">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like a class that was sorely missing in my CS education; looking back at what I was taught versus what skills have been useful in the industry, my university courses always seemed to treat debugging, profiling, etc as irrelevant details. Taking time to improve my understanding of them has paid off quite well in my career, I think.</div><br/></div></div></div></div><div id="38889519" class="c"><input type="checkbox" id="c-38889519" checked=""/><div class="controls bullet"><span class="by">sgbeal</span><span>|</span><a href="#38887384">prev</a><span>|</span><a href="#38888799">next</a><span>|</span><label class="collapse" for="c-38889519">[-]</label><label class="expand" for="c-38889519">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A stronger tool such as the Clang static analyzer should also be used.<p>While also teaching students that static code analyzers are very far from infallible and can waste a great deal of developer time with false positives.<p>It happens about once every month or two that someone posts on the sqlite forum, &quot;I&#x27;ve found this serious bug...&quot; and, after some back and forth, it&#x27;s revealed that they used a static analyzer or, even worse, just pasted a single internal function from the sqlite core into ChatGPT and asked it to analyze the code for them (completely free of any calling context). Roughly 9 times out of 10, static code analyzers are flat out wrong in their analysis of that particular source tree. It&#x27;s very rare that a report in sqlite which stems from a static code analyzer is actually correct.<p>The advice given to such posters is invariably: if you can demonstrate code which tickles the bug your tool is claiming to have found, it will be treated with priority. Until then... not so much.</div><br/></div></div><div id="38888799" class="c"><input type="checkbox" id="c-38888799" checked=""/><div class="controls bullet"><span class="by">countWSS</span><span>|</span><a href="#38889519">prev</a><span>|</span><a href="#38887995">next</a><span>|</span><label class="collapse" for="c-38888799">[-]</label><label class="expand" for="c-38888799">[2 more]</label></div><br/><div class="children"><div class="content">Many people complain about teaching C leading to bad habits or something of that sort.
C is crucial to understanding OS apis, driver code and low-level algorithms,
its not locked to single platform like assembly and allows composing fairly high-level
 abstractions without any hidden overhead. Writing your own libc functions and understanding
how they work is essential to systems programming.</div><br/><div id="38889375" class="c"><input type="checkbox" id="c-38889375" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38888799">parent</a><span>|</span><a href="#38887995">next</a><span>|</span><label class="collapse" for="c-38889375">[-]</label><label class="expand" for="c-38889375">[1 more]</label></div><br/><div class="children"><div class="content">The complaint is probably more about teaching C <i>too early</i> and getting fixated on that. The importance and eventual need for learning C is hardly questioned.</div><br/></div></div></div></div><div id="38887995" class="c"><input type="checkbox" id="c-38887995" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38888799">prev</a><span>|</span><a href="#38887693">next</a><span>|</span><label class="collapse" for="c-38887995">[-]</label><label class="expand" for="c-38887995">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Teaching C (2016)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32798826">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32798826</a> - Sept 2022 (94 comments)<p><i>Teaching C (2016)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18334476">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18334476</a> - Oct 2018 (211 comments)<p><i>Teaching C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11668396">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11668396</a> - May 2016 (152 comments)</div><br/></div></div><div id="38887693" class="c"><input type="checkbox" id="c-38887693" checked=""/><div class="controls bullet"><span class="by">TrackerFF</span><span>|</span><a href="#38887995">prev</a><span>|</span><a href="#38887720">next</a><span>|</span><label class="collapse" for="c-38887693">[-]</label><label class="expand" for="c-38887693">[1 more]</label></div><br/><div class="children"><div class="content">When I studied, C was the first language we learned. I think it was a great way, as we&#x27;d learn about memory management, how to do things from &quot;scratch&quot;, and since there weren&#x27;t many batteries included, we kind of just implemented data structures and algorithms as we went on.<p>It also primed us for more involved classes, like operating systems, compilers, databases, and so on.<p>But I have to say, it is a language that students really need to fundamentally know if it is going to be used down the road. Sounds obvious, but when I TA&#x27;d in more advanced classes (i.e. anything after &quot;introduction to programming&quot;), many of the students that were struggling, were really just struggling with the language - not necessarily the CS concepts. A lot of them were even students that had programming experience prior to enrolling, but had mostly used higher level languages.</div><br/></div></div><div id="38887720" class="c"><input type="checkbox" id="c-38887720" checked=""/><div class="controls bullet"><span class="by">puzzledobserver</span><span>|</span><a href="#38887693">prev</a><span>|</span><a href="#38889639">next</a><span>|</span><label class="collapse" for="c-38887720">[-]</label><label class="expand" for="c-38887720">[6 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t a better first question be _why_ we&#x27;re teaching students C?<p>One answer might be that although students might spend most of their later professional lives in higher-level languages, they should have some experience in a low-level language.<p>The ideal such language would not have memory management (i.e., not Java &#x2F; Python), no memory management help from the type system (so no Rust), and no fancy facilities to build abstractions (so no Rust or C++). This language should, ideally, still be a little more pleasant to work with than assembly (so, no assembly). For historical reasons, we would still like unchecked array accesses and null-terminated strings.<p>Now C is an answer to this question, but it need not be the only answer. We could instead teach students a fictionalized version of real C. So nice 2-s complement behavior on overflows, buffer overflows segfaults and other bad behavior, but mostly of the predictable kind. We could define undefined behaviors as the instructor sees fit.<p>As much as we can, we can try to make this fictionalized language agree with the semantics of gcc -O0. We can then study gcc -O0 -S itself as an empirical artifact, and use it to understand x86&#x2F;x86-64&#x2F;ARM&#x2F;MIPS assembly.<p>Finally, while we&#x27;re at it, we can use the Bourbaki dangerous bend symbol (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bourbaki_dangerous_bend_symbol" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bourbaki_dangerous_bend_symbol</a>) to repeatedly remind students that what they&#x27;re studying isn&#x27;t a real language, that real C has sharp edges (including undefined behaviors), and that things like ASAN &#x2F; Valgrind &#x2F; ... exist.<p>I worry that this article is confusing that we&#x27;d like students to eventually understand (some understanding of C and an appreciation of the fact that it is an important language which still needs to be handled with care) with the didactic process of reaching that understanding. Wittgenstein&#x27;s ladder is a thing.</div><br/><div id="38888677" class="c"><input type="checkbox" id="c-38888677" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38887720">parent</a><span>|</span><a href="#38889337">next</a><span>|</span><label class="collapse" for="c-38888677">[-]</label><label class="expand" for="c-38888677">[2 more]</label></div><br/><div class="children"><div class="content">Because teaching students a fictional version of C does not prepare them well for dealing with actual C.</div><br/><div id="38889416" class="c"><input type="checkbox" id="c-38889416" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38887720">root</a><span>|</span><a href="#38888677">parent</a><span>|</span><a href="#38889337">next</a><span>|</span><label class="collapse" for="c-38889416">[-]</label><label class="expand" for="c-38889416">[1 more]</label></div><br/><div class="children"><div class="content">It is not like that instructors are necessarily good at actual C, not alone teaching C though.</div><br/></div></div></div></div><div id="38889337" class="c"><input type="checkbox" id="c-38889337" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38887720">parent</a><span>|</span><a href="#38888677">prev</a><span>|</span><a href="#38888336">next</a><span>|</span><label class="collapse" for="c-38889337">[-]</label><label class="expand" for="c-38889337">[1 more]</label></div><br/><div class="children"><div class="content">I feel like you&#x27;re trying to merge computation as a science with an idealized language choice and I don&#x27;t think it would serve students well.<p>The &quot;sharp edges&quot; of C in either user mode or kernel mode when running on an x86 or arm platform are true implementation semantics that you must deal with while trying to realize genuine &quot;computation.&quot;<p>Programming languages are just collections of human shorthand for managing these semantics.  Which makes me feel that inventing this language would be putting the cart before the horse.</div><br/></div></div><div id="38888336" class="c"><input type="checkbox" id="c-38888336" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38887720">parent</a><span>|</span><a href="#38889337">prev</a><span>|</span><a href="#38888490">next</a><span>|</span><label class="collapse" for="c-38888336">[-]</label><label class="expand" for="c-38888336">[1 more]</label></div><br/><div class="children"><div class="content">If we went to the trouble of making a safe version of C - and we would have to actually implement it; you can&#x27;t very well teach students to program without letting them actually compile the code and run it - I&#x27;d rather just... use that. Call it C24, get it into GCC and Clang, and standardize on something with less Undefined Behavior and painful sharp edges.</div><br/></div></div></div></div><div id="38889639" class="c"><input type="checkbox" id="c-38889639" checked=""/><div class="controls bullet"><span class="by">DrNosferatu</span><span>|</span><a href="#38887720">prev</a><span>|</span><a href="#38889721">next</a><span>|</span><label class="collapse" for="c-38889639">[-]</label><label class="expand" for="c-38889639">[1 more]</label></div><br/><div class="children"><div class="content">No mention of the Deitel &amp; Deitel books?</div><br/></div></div><div id="38889721" class="c"><input type="checkbox" id="c-38889721" checked=""/><div class="controls bullet"><span class="by">toasted-subs</span><span>|</span><a href="#38889639">prev</a><span>|</span><a href="#38887960">next</a><span>|</span><label class="collapse" for="c-38889721">[-]</label><label class="expand" for="c-38889721">[1 more]</label></div><br/><div class="children"><div class="content">I feel like very rarely do u feel as satisfied as when I program in C.</div><br/></div></div><div id="38887960" class="c"><input type="checkbox" id="c-38887960" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38889721">prev</a><span>|</span><a href="#38887168">next</a><span>|</span><label class="collapse" for="c-38887960">[-]</label><label class="expand" for="c-38887960">[2 more]</label></div><br/><div class="children"><div class="content">I was an experienced asm programmer before a friend loaned me a copy of K+R C. I understood C immediately. I imagine trying to learn C without knowing assembler would be a much tougher road.<p>Knowing C also helps in understanding a lot of other languages.</div><br/></div></div><div id="38887168" class="c"><input type="checkbox" id="c-38887168" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#38887960">prev</a><span>|</span><a href="#38888803">next</a><span>|</span><label class="collapse" for="c-38887168">[-]</label><label class="expand" for="c-38887168">[2 more]</label></div><br/><div class="children"><div class="content">In my opinion the implementation of glibc (there is a bunch of good reasons for the “weirdness” and a whole lot of gcc-isms) and even the linked example from musl (with somewhat confusing #ifdef block) is a thing that should be in some kind of “System Programming” course, not in introductory course to C.</div><br/><div id="38887432" class="c"><input type="checkbox" id="c-38887432" checked=""/><div class="controls bullet"><span class="by">nicklecompte</span><span>|</span><a href="#38887168">parent</a><span>|</span><a href="#38888803">next</a><span>|</span><label class="collapse" for="c-38887432">[-]</label><label class="expand" for="c-38887432">[1 more]</label></div><br/><div class="children"><div class="content">The point is that the course is not introductory:<p>&gt; I’ve always taught C as a side effect of teaching operating systems, embedded systems, or something along those lines....One might argue that we shouldn’t be teaching C any longer, and I would certainly agree that C is probably a poor first or second language.<p>So this would be an upper-level class: an introduction to C programming for people with Python&#x2F;Haskell&#x2F;etc experience and a decent general understanding of computer science.</div><br/></div></div></div></div><div id="38888803" class="c"><input type="checkbox" id="c-38888803" checked=""/><div class="controls bullet"><span class="by">prudentpomelo</span><span>|</span><a href="#38887168">prev</a><span>|</span><a href="#38888205">next</a><span>|</span><label class="collapse" for="c-38888803">[-]</label><label class="expand" for="c-38888803">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; There’s a lot of reading material out there. For the basics, I still recommend that students purchase K&amp;R.<p>Has anyone read K&amp;R and regretted it? I am working through all the exercises and have really enjoyed the process.</div><br/></div></div><div id="38888205" class="c"><input type="checkbox" id="c-38888205" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#38888803">prev</a><span>|</span><a href="#38887429">next</a><span>|</span><label class="collapse" for="c-38888205">[-]</label><label class="expand" for="c-38888205">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; adding some high-quality C code, perhaps starting with Redis, Musl, or Xv6.<p>Agree. Xv6 is the reason why I used C. I learnt more about various OS concepts (process scheduling, file system etc) by hacking Xv6 code. Linux is too complicated for my taste.<p>As a mobile app dev, I don&#x27;t use C. Well.... I do. Very ocasionally though. Only for interacting with specific Android hardwares.</div><br/></div></div><div id="38887429" class="c"><input type="checkbox" id="c-38887429" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#38888205">prev</a><span>|</span><a href="#38887805">next</a><span>|</span><label class="collapse" for="c-38887429">[-]</label><label class="expand" for="c-38887429">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a lot of criticism of C here. I do want to say the K&amp;R book was a great read when I finally did some hands-on work with C. Credit to Victor Yodaiken for recommending it.<p>The explanations were well-done. They gradually build up the examples. They actually did warn about common gotchas even then. Their examples mostly worked today with only minor tweaks. I used it with Clang’s and MS Visual Studio’s static analyzers.</div><br/></div></div><div id="38887805" class="c"><input type="checkbox" id="c-38887805" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#38887429">prev</a><span>|</span><a href="#38887277">next</a><span>|</span><label class="collapse" for="c-38887805">[-]</label><label class="expand" for="c-38887805">[10 more]</label></div><br/><div class="children"><div class="content">I love C. It&#x27;s the language that makes me the most happy. I&#x27;m not entirely sure why, I think I like being in control. People always comment about C is unsafe, full of razors and knives flying around.<p>The thing to keep in mind is that *you* are the one throwing the razors and knives from the moment you go beyond printf(&quot;hello, world!\n&quot;);<p>I&#x27;d never recommend a company to start building anything in C. In term of the various team sizes and staff churn over the lifetime of a company, it&#x27;s too risky.<p>But afaik most companies, particularly the growth hacking ones, are either Go or Kotlin or at that level of abstraction. Rust is slowly eating at C++ and I&#x27;m pretty sure no company in their right mind today start a new product in C++. It will slowly become COBOL.<p>C on the other hand still has new C written every day. I&#x27;m a polyglot and I love C, but I never had a job in C. I hope some day that happens. The modern tools aforementioned, e.g. static analysis, clangd, are really good.<p>The thing I love most about C is that there is a direct relationship between me doing something stupid and feeling pain for it. In python, I can write crap all day without feeling it. Some day I&#x27;ll feel it, but not today!<p>I like small binaries and fast code. I like that when a developer tells me I did something wrong, they can prove it, and it&#x27;s not some stupid high level language &quot;the more you knoooow&quot;. I like control over things.<p>I love modern C and I wish it well!</div><br/><div id="38888042" class="c"><input type="checkbox" id="c-38888042" checked=""/><div class="controls bullet"><span class="by">3a2d29</span><span>|</span><a href="#38887805">parent</a><span>|</span><a href="#38889360">next</a><span>|</span><label class="collapse" for="c-38888042">[-]</label><label class="expand" for="c-38888042">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m pretty sure no company in their right mind today start a new product in C++<p>I say this as someone who loves rust and zig, but these types of statements make me feel like HN is way out of touch with the industry.  New products are constantly made in C++.  That doesn&#x27;t make it good (and i don&#x27;t think companies building in C++ are making the best choices), but to say that no big tech company is writing any new code in C++ is just not correct.  I see this happen every day at my job.<p>I also would definitely say more C++ code is written every day over C, although I&#x27;ll say, I am not as familiar with the embedded world, but I know one HFT&#x2F;Gaming&#x2F;Robotics firm will have millions of new C++ lines every day.</div><br/><div id="38888048" class="c"><input type="checkbox" id="c-38888048" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#38887805">root</a><span>|</span><a href="#38888042">parent</a><span>|</span><a href="#38889360">next</a><span>|</span><label class="collapse" for="c-38888048">[-]</label><label class="expand" for="c-38888048">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in their right mind</div><br/></div></div></div></div><div id="38889360" class="c"><input type="checkbox" id="c-38889360" checked=""/><div class="controls bullet"><span class="by">dvko</span><span>|</span><a href="#38887805">parent</a><span>|</span><a href="#38888042">prev</a><span>|</span><a href="#38888137">next</a><span>|</span><label class="collapse" for="c-38889360">[-]</label><label class="expand" for="c-38889360">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I love C.<p>You and me both. I&#x27;m also a polygot but I originally started on interpreted languages like PHP and Python. I then learned some C, which was quite frustrating before I learned how to reason about memory ownership and hold myself to some idioms. Oh and Valgrind.<p>I then rewrote a bunch of projects in Rust and while it lead to correct and working software, it didn&#x27;t spark the joy that C did for me. I don&#x27;t exactly know why and at times I almost feel ashamed to mention this. I do hope there&#x27;s a future where there&#x27;s a version of C with some more substantial changes&#x2F;improvements though, perhaps taking a lesson or two from Rust or Zig (eg string type w&#x2F; length).</div><br/></div></div><div id="38888137" class="c"><input type="checkbox" id="c-38888137" checked=""/><div class="controls bullet"><span class="by">jakogut</span><span>|</span><a href="#38887805">parent</a><span>|</span><a href="#38889360">prev</a><span>|</span><a href="#38889557">next</a><span>|</span><label class="collapse" for="c-38888137">[-]</label><label class="expand" for="c-38888137">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I also like writing and especially reading (good) C. The Linux kernel, Wine, and FFmpeg are a joy to read, and much more approachable than one would think.<p>I get exhausted by people denouncing C in favor of the language du jour, and suggesting it&#x27;s been obsoleted by newer and especially more abstract languages. A hammer and nails are still useful for specific jobs, even if you have screws.<p>All tools have their trade offs. Even when you have a battery powered impact driver, sometimes you still need to pick up a basic hammer.</div><br/></div></div><div id="38889557" class="c"><input type="checkbox" id="c-38889557" checked=""/><div class="controls bullet"><span class="by">sgbeal</span><span>|</span><a href="#38887805">parent</a><span>|</span><a href="#38888137">prev</a><span>|</span><a href="#38887997">next</a><span>|</span><label class="collapse" for="c-38889557">[-]</label><label class="expand" for="c-38889557">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The thing I love most about C is that there is a direct relationship between me doing something stupid and feeling pain for it.<p>Excellent! Such wisdom is rarely found in random forum threads on the internet.</div><br/></div></div><div id="38887997" class="c"><input type="checkbox" id="c-38887997" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38887805">parent</a><span>|</span><a href="#38889557">prev</a><span>|</span><a href="#38889198">next</a><span>|</span><label class="collapse" for="c-38887997">[-]</label><label class="expand" for="c-38887997">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m pretty sure no company in their right mind today start a new product in C++.<p>The library support for rust in key areas is terribly lacking and not everyone is a Microsoft that can afford to build the world from scratch.<p>As just one example a few valiant folks develop plugins and realtime audio with rust, but serious work that needs to get done today happens in C++.</div><br/></div></div><div id="38889198" class="c"><input type="checkbox" id="c-38889198" checked=""/><div class="controls bullet"><span class="by">bsdpufferfish</span><span>|</span><a href="#38887805">parent</a><span>|</span><a href="#38887997">prev</a><span>|</span><a href="#38888687">next</a><span>|</span><label class="collapse" for="c-38889198">[-]</label><label class="expand" for="c-38889198">[1 more]</label></div><br/><div class="children"><div class="content">&gt; staff churn over the lifetime of a company, it&#x27;s too risky.<p>Experience says otherwise. C code bases have serious longevity due to how many people know it and can jump in and contribute. There just aren&#x27;t that many patterns and abstractions.</div><br/></div></div><div id="38888687" class="c"><input type="checkbox" id="c-38888687" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38887805">parent</a><span>|</span><a href="#38889198">prev</a><span>|</span><a href="#38888488">next</a><span>|</span><label class="collapse" for="c-38888687">[-]</label><label class="expand" for="c-38888687">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m a polyglot and I love C, but I never had a job in C. I hope some day that happens. The modern tools aforementioned, e.g. static analysis, clangd, are really good.<p>If you had a job in this you’d know that they are not ;)</div><br/></div></div></div></div><div id="38887277" class="c"><input type="checkbox" id="c-38887277" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38887805">prev</a><span>|</span><a href="#38888375">next</a><span>|</span><label class="collapse" for="c-38887277">[-]</label><label class="expand" for="c-38887277">[15 more]</label></div><br/><div class="children"><div class="content">This has a bunch of &quot;But what could possibly replace C?&quot; type comments and the author (writing in 2016) replies Rust. So that&#x27;s somebody with their eyes on the ball.<p>They also point out that C is a bad first language. This shouldn&#x27;t be relevant to many Computer Science courses, but I have seen too many Electronics students who are taught C first, or indeed as their only language.</div><br/><div id="38887742" class="c"><input type="checkbox" id="c-38887742" checked=""/><div class="controls bullet"><span class="by">genmud</span><span>|</span><a href="#38887277">parent</a><span>|</span><a href="#38887354">next</a><span>|</span><label class="collapse" for="c-38887742">[-]</label><label class="expand" for="c-38887742">[6 more]</label></div><br/><div class="children"><div class="content">I’m actually of the opinion that C should be taught hand in hand or just after someone learns assembly. It’s admittedly a bit gatekeeper-y, but IMHO C should be thought of with same mindset as you would develop an ASM program, but with a bunch of shortcuts and syntactic sugar.<p>Without understanding what code gets generated, there are so many footguns it can be dangerous at best. Knowing things like calling conventions and how the compiler interacts with memory are really important.</div><br/><div id="38889121" class="c"><input type="checkbox" id="c-38889121" checked=""/><div class="controls bullet"><span class="by">ranger207</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887742">parent</a><span>|</span><a href="#38888010">next</a><span>|</span><label class="collapse" for="c-38889121">[-]</label><label class="expand" for="c-38889121">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I learned this way, and, for example, wrapping my head around pointers was much easier after I already understood why LEA existed. Yes, C isn&#x27;t portable assembler, and no, you can&#x27;t necessarily predict what ASM will be produced from a particular snippet of code. However, C operates closer to &quot;portable assembler&quot; than any other programming language, and it&#x27;s a lot harder to go from anything else to C than it is to go from assembly to C</div><br/></div></div><div id="38888010" class="c"><input type="checkbox" id="c-38888010" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887742">parent</a><span>|</span><a href="#38889121">prev</a><span>|</span><a href="#38887354">next</a><span>|</span><label class="collapse" for="c-38888010">[-]</label><label class="expand" for="c-38888010">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m of the opposite opinion. The portable-assembler camp is responsible for a lot of the issues and footguns, because they think they know what code will be generated. But they don&#x27;t. Compilers can generate any code they want, as long as the program ends up doing the correct io and side effects.<p>The assembler perspective is important, but not for correctness, rather for optimization. When you optimize it starts mattering how much register pressure and cache pressure etc you have.</div><br/><div id="38889431" class="c"><input type="checkbox" id="c-38889431" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38888010">parent</a><span>|</span><a href="#38888749">next</a><span>|</span><label class="collapse" for="c-38889431">[-]</label><label class="expand" for="c-38889431">[1 more]</label></div><br/><div class="children"><div class="content">I do resonate with your comment a lot, but the portable assembly aspect also drove much of the current C use. As a compromise we may teach <i>two</i> quite different architectures and ask students to write a single code that runs in both. This way they can avoid false beliefs like `sizeof(int) == 4` and hopefully still learn common aspects of most architectures that shaped C&#x27;s design.</div><br/></div></div><div id="38888749" class="c"><input type="checkbox" id="c-38888749" checked=""/><div class="controls bullet"><span class="by">genmud</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38888010">parent</a><span>|</span><a href="#38889431">prev</a><span>|</span><a href="#38887354">next</a><span>|</span><label class="collapse" for="c-38888749">[-]</label><label class="expand" for="c-38888749">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying because they need to understand exactly what code gets generated, compiler optimizations can produce interesting results. What I am saying is the idea that an if statement from an assembly is a compare and a jump... knowing what happens under the hood is kind of important for people writing C in 2024.<p>Like I guess the point I have to make is that if you are writing C in 2024, there is likely a good reason, and if you don&#x27;t know what&#x27;s going on in the assembler, I feel like people are playing with fire.</div><br/><div id="38888846" class="c"><input type="checkbox" id="c-38888846" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38888749">parent</a><span>|</span><a href="#38887354">next</a><span>|</span><label class="collapse" for="c-38888846">[-]</label><label class="expand" for="c-38888846">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s the misleading perspective the grandparent comment is referring to. An if statement in C <i>isn&#x27;t</i> necessarily a branch. The generated assembly assembly might have no branches if it&#x27;s eliminated, it might have multiple branches, and the compiler might even include a function call (e.g. fharden-conditional-branches). You can&#x27;t know just by looking at the source code alone.<p>I&#x27;ve found that I&#x27;m much less accurate when writing code for non-GCC&#x2F;Clang compilers because my mental model of what&#x27;s going to be generated isn&#x27;t accurate enough without the years of experience I&#x27;ve had looking at the outputs of those specific compiler families.</div><br/></div></div></div></div></div></div></div></div><div id="38887354" class="c"><input type="checkbox" id="c-38887354" checked=""/><div class="controls bullet"><span class="by">practicemaths</span><span>|</span><a href="#38887277">parent</a><span>|</span><a href="#38887742">prev</a><span>|</span><a href="#38887350">next</a><span>|</span><label class="collapse" for="c-38887354">[-]</label><label class="expand" for="c-38887354">[7 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with C? I&#x27;m teaching myself with Ritchie at the moment. Seems fine so far but I&#x27;m also more interested in embedded systems.</div><br/><div id="38887737" class="c"><input type="checkbox" id="c-38887737" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887354">parent</a><span>|</span><a href="#38887629">next</a><span>|</span><label class="collapse" for="c-38887737">[-]</label><label class="expand" for="c-38887737">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; What&#x27;s wrong with C?<p>The biggest problem with C is that it lets you do anything to include things you don&#x27;t want to do and should not do.<p>&quot;The programmer knows best&quot; means you can easily write to arbitrary memory addresses, smash the call stack, allocate memory and never free it, etc. and as long as the syntax is correct, your program will compile.<p>Sometimes, in interesting low-level code, embedded code, or similar, this unrestricted behavior is needed:  you write seemingly arbitrary values to a memory address because it is memory-mapped hardware and that is where the control register receives instructions.  But in most application-level code, it is bad behavior and just causes segment violations.<p>&quot;The programmer knows best&quot; is the primary cause of security flaws in C (and C++ because of its heavy compatibility with C) since even experienced C programmers make mistakes or find their code being used in unanticipated ways.</div><br/></div></div><div id="38887629" class="c"><input type="checkbox" id="c-38887629" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887354">parent</a><span>|</span><a href="#38887737">prev</a><span>|</span><a href="#38887580">next</a><span>|</span><label class="collapse" for="c-38887629">[-]</label><label class="expand" for="c-38887629">[1 more]</label></div><br/><div class="children"><div class="content">C gives you too many guns to shoot yourself in the foot. Beginners deserve a language with a helpful compiler, slightly more hand-holding, as well as more structure and convention to encourage a maintainable coding style.<p>You can read about how experts write their C code (like <a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;10&#x2F;08&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;10&#x2F;08&#x2F;</a>) but you aren&#x27;t going to appreciate why they decide to do this. Indeed, beginners need to be able to blindly follow rules before they can critique them or invent their own coding styles.</div><br/></div></div><div id="38887580" class="c"><input type="checkbox" id="c-38887580" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887354">parent</a><span>|</span><a href="#38887629">prev</a><span>|</span><a href="#38887902">next</a><span>|</span><label class="collapse" for="c-38887580">[-]</label><label class="expand" for="c-38887580">[1 more]</label></div><br/><div class="children"><div class="content">As a first language, a lot of students face major stumbling blocks when they deal with pointers and manual memory management.  It&#x27;s hard enough learning how to program for the first time; I remember learning QBASIC as a ten year old from a textbook and online tutorials.  Over twenty years later I had experience teaching introductory Python to absolute beginners, and they have to learn how to convert problem statements into code.  They have to learn how simple constructs such as loops and functions work.  The course would have been much more difficult for my students if I needed to teach them about pointers and manual memory management.  I still remember when I first encountered C in high school, and I struggled with segmentation faults due to my inadequate understanding of how pointers worked.  It wasn&#x27;t until my sophomore year of college when I finally understood pointers.  It was when I took a computer organization course that used assembly.  It was then when I had a better understanding of how memory worked and how C&#x27;s pointer syntax directly translated to assembly.<p>I admit that I still have a soft spot for C; once I finally understood pointers I did most of my projects in C; it helped that I had (and still have) a love for systems programming.  To this day I can write C in my sleep even though it&#x27;s been two years since I&#x27;ve last written a significant amount of C.  But in grad school I got bit hard by the Lisp and Smalltalk bugs....I went from a big Bell Labs fan to a Xerox PARC fan, and in my professional career I&#x27;ve been largely coding in Python for the past five years since it&#x27;s now the lingua franca of machine learning.<p>But I wouldn&#x27;t recommend C as a first language; I feel it&#x27;s too much for absolute beginners.  I&#x27;m torn between Python and Scheme; my feelings right now is that Python is a good introductory language for helping people gain programming experience and allowing students to build interesting things using Python&#x27;s extensive libraries, while Scheme is an excellent vehicle for teaching how programming languages work at a high level; I have a soft spot for The Structure and Interpretation of Computer Programs (this was the introductory CS textbook at MIT from the 1980s to the late 2000s when MIT switched to Python) and I used it as part of an upper-division course on programming language principles and paradigms at a university where Java is the introductory language.</div><br/></div></div><div id="38887902" class="c"><input type="checkbox" id="c-38887902" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887354">parent</a><span>|</span><a href="#38887580">prev</a><span>|</span><a href="#38887566">next</a><span>|</span><label class="collapse" for="c-38887902">[-]</label><label class="expand" for="c-38887902">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s wrong with C?<p>It&#x27;s great if you&#x27;re coming from assembly language and the de-factor standard for embedded systems.</div><br/></div></div><div id="38887566" class="c"><input type="checkbox" id="c-38887566" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887354">parent</a><span>|</span><a href="#38887902">prev</a><span>|</span><a href="#38887491">next</a><span>|</span><label class="collapse" for="c-38887566">[-]</label><label class="expand" for="c-38887566">[1 more]</label></div><br/><div class="children"><div class="content">C is a very pragmatic language for writing software on a PDP-11 fifty years ago. You aren&#x27;t doing that, so every single place where C made compromises to facilitate that you&#x27;re paying a price for something you don&#x27;t need or even want.<p>For example you want fat pointers, particularly for slice types. On a PDP-11 spending <i>two</i> registers for these types is extravagant, today this seems ridiculous, but C still doesn&#x27;t provide any fat pointer types. So either you have to roll your own (and with them libraries of code to use them) or put up with whatever was a good idea in the 1970s. The most famous slice type is Rust&#x27;s &amp;str or C++ std::string_view, a fat pointer for referring to text - strings in other words, but not the mutable, owned, auto-growing strings you might associate with higher level languages, this is just the simple concept of some text. C can&#x27;t do that, what C gives you is a pointer to a byte, pointer arithmetic and a stern admonition to stop when you reach a byte with a zero value... or you can roll your own slice types.</div><br/></div></div><div id="38887491" class="c"><input type="checkbox" id="c-38887491" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#38887277">root</a><span>|</span><a href="#38887354">parent</a><span>|</span><a href="#38887566">prev</a><span>|</span><a href="#38887350">next</a><span>|</span><label class="collapse" for="c-38887491">[-]</label><label class="expand" for="c-38887491">[1 more]</label></div><br/><div class="children"><div class="content">C++ is usually better because you can start with the abstractions (e.g. new, classes, I&#x2F;O streams, and strings) and then work each one backwards once they’re comfortable at the high level.<p>(Although C++ wouldn’t be my first choice to begin with for a first language)</div><br/></div></div></div></div></div></div><div id="38888375" class="c"><input type="checkbox" id="c-38888375" checked=""/><div class="controls bullet"><span class="by">beyonddream</span><span>|</span><a href="#38887277">prev</a><span>|</span><a href="#38887768">next</a><span>|</span><label class="collapse" for="c-38888375">[-]</label><label class="expand" for="c-38888375">[2 more]</label></div><br/><div class="children"><div class="content">I have been programming in C professionally for the past ~4 years on a multi-threaded application in the ads industry and that is central to the business. C has lot of documented &quot;foot-guns&quot; but most of it (if not all of it) can be safeguarded against mis-use using  &quot;support structures&quot; around the codebase like having standard code style (enforced via tools as much as possible), static code analysis (via compiler and external code scanning tools), dynamic code analysis (via Asan, Ubsan etc), having small, medium and large tests with right amount of code coverage etc. In addition to that, having a standard set of libraries (c modules for high performance data-structures&#x2F;algorithms, macro based templates to work with types) and threading model goes a long way in reducing the pain to a very bare minimum. On the plus side, you enjoy a &quot;simpler&quot; language syntax that is easy to learn and with the above “support structures” one can become productive in no time. Plus there are newer books in the market that can teach you C properly, one I have read and recommend is &quot;Effective C by Robert C. Seacord&quot; - the author is one of the C standards committee members so you can&#x27;t go wrong with the choice.</div><br/></div></div><div id="38887768" class="c"><input type="checkbox" id="c-38887768" checked=""/><div class="controls bullet"><span class="by">6R1M0R4CL3</span><span>|</span><a href="#38888375">prev</a><span>|</span><a href="#38887333">next</a><span>|</span><label class="collapse" for="c-38887768">[-]</label><label class="expand" for="c-38887768">[3 more]</label></div><br/><div class="children"><div class="content">we should all learn C and in time, go help that kernel project some of you might have heard of...</div><br/><div id="38889149" class="c"><input type="checkbox" id="c-38889149" checked=""/><div class="controls bullet"><span class="by">ptek</span><span>|</span><a href="#38887768">parent</a><span>|</span><a href="#38888495">next</a><span>|</span><label class="collapse" for="c-38889149">[-]</label><label class="expand" for="c-38889149">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I&#x27;d like to be skilled enough to contribute and add some more drivers to NetBSD or NextStep 3.3&#x2F;OpenStep 4.2&#x2F;Rhapsody DR2 (Objective C)</div><br/></div></div></div></div></div></div></div></div></div></body></html>