<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713517254413" as="style"/><link rel="stylesheet" href="styles.css?v=1713517254413"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dl.acm.org/doi/10.1145/3617232.3624859?ai=&amp;ui=&amp;af=">Formal Mechanised Semantics of CHERI C: Capabilities, Undefined Behaviour</a>Â <span class="domain">(<a href="https://dl.acm.org">dl.acm.org</a>)</span></div><div class="subtext"><span>rbanffy</span> | <span>15 comments</span></div><br/><div><div id="40081554" class="c"><input type="checkbox" id="c-40081554" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40082626">next</a><span>|</span><label class="collapse" for="c-40081554">[-]</label><label class="expand" for="c-40081554">[3 more]</label></div><br/><div class="children"><div class="content">&gt;CHERI was first prototyped as extensions of MIPS and RISC-V; it is currently being evaluated by Arm...<p>Note there&#x27;s also a RISC-V effort[0][1] to write an extension specification proper.<p>0. <a href="https:&#x2F;&#x2F;jira.riscv.org&#x2F;browse&#x2F;RVS-2141?src=confmacro" rel="nofollow">https:&#x2F;&#x2F;jira.riscv.org&#x2F;browse&#x2F;RVS-2141?src=confmacro</a><p>1. <a href="https:&#x2F;&#x2F;wiki.riscv.org&#x2F;display&#x2F;HOME&#x2F;RISC-V+Specification+Status" rel="nofollow">https:&#x2F;&#x2F;wiki.riscv.org&#x2F;display&#x2F;HOME&#x2F;RISC-V+Specification+Sta...</a></div><br/><div id="40084617" class="c"><input type="checkbox" id="c-40084617" checked=""/><div class="controls bullet"><span class="by">taffronaut</span><span>|</span><a href="#40081554">parent</a><span>|</span><a href="#40081792">next</a><span>|</span><label class="collapse" for="c-40084617">[-]</label><label class="expand" for="c-40084617">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a link to the Arm program:
<a href="https:&#x2F;&#x2F;www.morello-project.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.morello-project.org&#x2F;</a></div><br/></div></div><div id="40081792" class="c"><input type="checkbox" id="c-40081792" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#40081554">parent</a><span>|</span><a href="#40084617">prev</a><span>|</span><a href="#40082626">next</a><span>|</span><label class="collapse" for="c-40081792">[-]</label><label class="expand" for="c-40081792">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it was built on BERI:<p><a href="https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;research&#x2F;security&#x2F;ctsrd&#x2F;beri&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;research&#x2F;security&#x2F;ctsrd&#x2F;beri&#x2F;</a></div><br/></div></div></div></div><div id="40082626" class="c"><input type="checkbox" id="c-40082626" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#40081554">prev</a><span>|</span><label class="collapse" for="c-40082626">[-]</label><label class="expand" for="c-40082626">[11 more]</label></div><br/><div class="children"><div class="content">Does this CHERI platform enable memory safety for programming languages and all the facilities provided by borrow checking language like Rust is not necessary?</div><br/><div id="40083967" class="c"><input type="checkbox" id="c-40083967" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40082626">parent</a><span>|</span><a href="#40083746">next</a><span>|</span><label class="collapse" for="c-40083967">[-]</label><label class="expand" for="c-40083967">[1 more]</label></div><br/><div class="children"><div class="content">No, there are actually quite a few things CHERI does that aren&#x27;t the borrow checker&#x27;s job, and some things the borrow checker does that CHERI doesn&#x27;t help with.<p>In C and C++, if you write x[4] for an array with only 2 members, you get undefined behaviour. In Rust this causes a &#x27;panic&#x27;, but that isn&#x27;t a &#x27;borrow checker&#x27; thing, that&#x27;s because in Rust all array accesses are bounds checked by default.<p>You can do un-bounds checked array accesses in Rust, you can do bounds-checked accesses in C++ (for std::vector at least), it&#x27;s just that the languages chose different defaults.<p>One thing the borrow checker does is help write parallel code by stopping multiple threads writing to the same memory at the same time. CHERI doesn&#x27;t stop that at all.</div><br/></div></div><div id="40083746" class="c"><input type="checkbox" id="c-40083746" checked=""/><div class="controls bullet"><span class="by">Peter_Sewell</span><span>|</span><a href="#40082626">parent</a><span>|</span><a href="#40083967">prev</a><span>|</span><a href="#40082850">next</a><span>|</span><label class="collapse" for="c-40083746">[-]</label><label class="expand" for="c-40083746">[1 more]</label></div><br/><div class="children"><div class="content">CHERI enables a rather high level of memory safety. It uses dynamic hardware checks rather than the safe-Rust static checks, which means that existing C&#x2F;C++ code can often be ported to CHERI C&#x2F;C++ with minor changes.  Of course, as others note, &quot;memory safety&quot; is not a simple single thing, and there are certainly some cases that CHERI C&#x2F;C++ don&#x27;t depend on (as noted in this paper by Vadim Zaliva and others in our group).  But in examples like this one from another comment:<p><pre><code>    struct buffer {
          char *data;
          size_t capacity;
          size_t length;
        }
</code></pre>
the pointer &#x27;data&#x27; will in CHERI have to be a valid capability, not just a virtual address, to permit access. It should normally have been instantiated with the correct bounds from the appropriate allocation, separately from the &#x27;length&#x27; field, so the hardware will do the right check.</div><br/></div></div><div id="40082850" class="c"><input type="checkbox" id="c-40082850" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40082626">parent</a><span>|</span><a href="#40083746">prev</a><span>|</span><a href="#40083618">next</a><span>|</span><label class="collapse" for="c-40082850">[-]</label><label class="expand" for="c-40082850">[1 more]</label></div><br/><div class="children"><div class="content">No. CHERI doesn&#x27;t help with data races, for example. Also it doesn&#x27;t help with compiler optimizations that exploit UB to make code faster.<p>Unfortunately low level languages are kind of addicted to optimizations that only work for languages with UB. There&#x27;s too much performance being left at the table if you create a programming language entirely without UB.<p>There&#x27;s no law of nature, however, that says this must be the case forever. You could have a theorem prover prove useful properties about programs (and them feed them to the optimizer) and refrain from &quot;optimizing&quot; if you can&#x27;t 100% prove that this will not break.</div><br/></div></div><div id="40083618" class="c"><input type="checkbox" id="c-40083618" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40082626">parent</a><span>|</span><a href="#40082850">prev</a><span>|</span><a href="#40084217">next</a><span>|</span><label class="collapse" for="c-40083618">[-]</label><label class="expand" for="c-40083618">[5 more]</label></div><br/><div class="children"><div class="content">EDIT: Apparently CHERI can handle this scenario, please ignore the rest of the comment<p>Memory safety is not a binary choice. Consider this typical structure:<p><pre><code>    struct buffer {
      char *data;
      size_t capacity;
      size_t length;
    }
</code></pre>
In fact it doesn&#x27;t even have to be C, you could write it in Java, Python, etc. Lets say you decide to reuse such a buffer multiple times. From the C semantics point of view, there is nothing wrong with accessing elements past length. But it can easily lead to a heartbleed style vulnerability. There is probably some escape hatch for CHERI to mark memory as uninitialized, but I&#x27;m not very familiar with it. In Rust you can probably give out slices which will ensure bounds checking (or eliminate it if possible). The only correct way towards safety is languages which enable the programmer to add additional restrictions, like Rust or Frama-C.<p>Anyway, this is mostly just theoretical musing, in practice CHERI will catch lots of issues. But I don&#x27;t think it is correct to call it &quot;memory safety&quot;.</div><br/><div id="40083834" class="c"><input type="checkbox" id="c-40083834" checked=""/><div class="controls bullet"><span class="by">vzaliva</span><span>|</span><a href="#40082626">root</a><span>|</span><a href="#40083618">parent</a><span>|</span><a href="#40084217">next</a><span>|</span><label class="collapse" for="c-40083834">[-]</label><label class="expand" for="c-40083834">[4 more]</label></div><br/><div class="children"><div class="content">In CHERI, the `data` pointer in your example is not merely a 64-bit pointer (assuming ARM Morello architecture) but a special 128-bit data structure called a `capability`, which encodes within it the bounds of the memory block allocated to it. The hardware will prevent any out-of-bounds access, even if you manage to bypass any C language type checks, for example, by using inline assembly. So, this offers a pretty strong level of memory protection.</div><br/><div id="40083879" class="c"><input type="checkbox" id="c-40083879" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40082626">root</a><span>|</span><a href="#40083834">parent</a><span>|</span><a href="#40084217">next</a><span>|</span><label class="collapse" for="c-40083879">[-]</label><label class="expand" for="c-40083879">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but the capability will be enforcing the bound w.r.t &quot;capacity&quot;, not &quot;length&quot; as that is the allocated size. From CHERI&#x27;s point of view &quot;length&quot; is just some random user defined variable with no effect on bounds checks.</div><br/><div id="40083942" class="c"><input type="checkbox" id="c-40083942" checked=""/><div class="controls bullet"><span class="by">Peter_Sewell</span><span>|</span><a href="#40082626">root</a><span>|</span><a href="#40083879">parent</a><span>|</span><a href="#40084217">next</a><span>|</span><label class="collapse" for="c-40083942">[-]</label><label class="expand" for="c-40083942">[2 more]</label></div><br/><div class="children"><div class="content">If you want to narrow the bounds of `data` on reuse, you can do easily do that in CHERI C (you&#x27;d need to also keep the larger capability somewhere to rederive the `data` capability from, either in this struct or elsewhere, depending where the allocation come from).</div><br/><div id="40084087" class="c"><input type="checkbox" id="c-40084087" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40082626">root</a><span>|</span><a href="#40083942">parent</a><span>|</span><a href="#40084217">next</a><span>|</span><label class="collapse" for="c-40084087">[-]</label><label class="expand" for="c-40084087">[1 more]</label></div><br/><div class="children"><div class="content">Oh that is great news, I was not aware that CHERI was this powerful. Interesting if this could be abused by JIT compilers to provide free runtime bounds checks, kind of like the free null pointer checks done by catching SEGV.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40084217" class="c"><input type="checkbox" id="c-40084217" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40082626">parent</a><span>|</span><a href="#40083618">prev</a><span>|</span><a href="#40082785">next</a><span>|</span><label class="collapse" for="c-40084217">[-]</label><label class="expand" for="c-40084217">[1 more]</label></div><br/><div class="children"><div class="content">No. CHERI does not have a straightforward way of protecting against UAF.</div><br/></div></div><div id="40082785" class="c"><input type="checkbox" id="c-40082785" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#40082626">parent</a><span>|</span><a href="#40084217">prev</a><span>|</span><label class="collapse" for="c-40082785">[-]</label><label class="expand" for="c-40082785">[1 more]</label></div><br/><div class="children"><div class="content">Not in the near future, because compilers will still emit weird code in the presence of UB. The hardware enforces more stuff, and it makes it more likely you&#x27;ll get a crash instead of the program continuing in a bad state, but it absolutely does not eliminate the general UB or &quot;implementation defined&quot; problems.</div><br/></div></div></div></div></div></div></div></div></div></body></html>