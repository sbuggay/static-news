<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708851659757" as="style"/><link rel="stylesheet" href="styles.css?v=1708851659757"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2021/02/06/ARCHITECTURE.md.html">Architecture.md (2021)</a> <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>27 comments</span></div><br/><div><div id="39498979" class="c"><input type="checkbox" id="c-39498979" checked=""/><div class="controls bullet"><span class="by">marttilaine</span><span>|</span><a href="#39496175">next</a><span>|</span><label class="collapse" for="c-39498979">[-]</label><label class="expand" for="c-39498979">[1 more]</label></div><br/><div class="children"><div class="content">I experimented with something similar in one of my larger side projects a couple of years ago:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;shipmight&#x2F;shipmight&#x2F;blob&#x2F;master&#x2F;src&#x2F;ARCHITECTURE.md">https:&#x2F;&#x2F;github.com&#x2F;shipmight&#x2F;shipmight&#x2F;blob&#x2F;master&#x2F;src&#x2F;ARCHI...</a><p>At the top of each file there was a tree of links to other ARCHITECTURE.md-files in the repo, like this:<p><pre><code>    * ARCHITECTURE.md &lt;- you are here
    * backend&#x2F;ARCHITECTURE.md
        * backend&#x2F;api&#x2F;ARCHITECTURE.md
        * backend&#x2F;cli&#x2F;ARCHITECTURE.md
        * backend&#x2F;ui&#x2F;ARCHITECTURE.md
        * backend&#x2F;utils&#x2F;ARCHITECTURE.md
    * frontend&#x2F;ARCHITECTURE.md
    * internal-charts&#x2F;ARCHITECTURE.md</code></pre></div><br/></div></div><div id="39496175" class="c"><input type="checkbox" id="c-39496175" checked=""/><div class="controls bullet"><span class="by">hbcondo714</span><span>|</span><a href="#39498979">prev</a><span>|</span><a href="#39497448">next</a><span>|</span><label class="collapse" for="c-39496175">[-]</label><label class="expand" for="c-39496175">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you maintain an open-source project in the range of 10k-200k lines of code, I strongly encourage you to add an ARCHITECTURE document<p>I like this idea but IMHO, regardless of repo size, architecture can still has some place in a Readme. For example, I purposely placed a Mermaid sequence diagram[1] in the main Readme because I think it&#x27;s important that all readers see and understand its workflow[2]<p>[1] <a href="https:&#x2F;&#x2F;mermaid.js.org&#x2F;syntax&#x2F;sequenceDiagram.html" rel="nofollow">https:&#x2F;&#x2F;mermaid.js.org&#x2F;syntax&#x2F;sequenceDiagram.html</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;hbcondo&#x2F;revenut-app?tab=readme-ov-file#-workflow">https:&#x2F;&#x2F;github.com&#x2F;hbcondo&#x2F;revenut-app?tab=readme-ov-file#-w...</a></div><br/></div></div><div id="39497448" class="c"><input type="checkbox" id="c-39497448" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#39496175">prev</a><span>|</span><a href="#39496931">next</a><span>|</span><label class="collapse" for="c-39497448">[-]</label><label class="expand" for="c-39497448">[2 more]</label></div><br/><div class="children"><div class="content">This approach sounds great as a low-maintenance model for open-source projects with many ad hoc contributors. For projects with dedicated engineers, consider ADRs instead. These require more maintenance, but capture the &quot;why&quot; and &quot;alternatives considered&quot;, which can be immensely helpful when rearchitecting.<p>See <a href="https:&#x2F;&#x2F;adr.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;adr.github.io&#x2F;</a></div><br/><div id="39498340" class="c"><input type="checkbox" id="c-39498340" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#39497448">parent</a><span>|</span><a href="#39496931">next</a><span>|</span><label class="collapse" for="c-39498340">[-]</label><label class="expand" for="c-39498340">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think “instead” is the correct word here. “As well” I think fits better.<p>ARCHITECTURE.md will have the current state of the architecture. ADRs is the log of decisions that got you there. Both are very useful.</div><br/></div></div></div></div><div id="39496931" class="c"><input type="checkbox" id="c-39496931" checked=""/><div class="controls bullet"><span class="by">patrickthebold</span><span>|</span><a href="#39497448">prev</a><span>|</span><a href="#39496109">next</a><span>|</span><label class="collapse" for="c-39496931">[-]</label><label class="expand" for="c-39496931">[7 more]</label></div><br/><div class="children"><div class="content">Random thought: Every IDE I&#x27;ve used gives me the folder structure of the project on the left as a standard directory tree. Does any support navigating a project as a graph of dependencies?</div><br/><div id="39497936" class="c"><input type="checkbox" id="c-39497936" checked=""/><div class="controls bullet"><span class="by">ccorcos</span><span>|</span><a href="#39496931">parent</a><span>|</span><a href="#39498219">next</a><span>|</span><label class="collapse" for="c-39497936">[-]</label><label class="expand" for="c-39497936">[1 more]</label></div><br/><div class="children"><div class="content">I have the exact same thought.<p>What would it look like? I have two ideas.<p>1. Multiple directory trees that use symlinks to organize files orthogonally. Your typical directory structure may have things split by client &#x2F; server. But what if I want to split things based on feature? An IDE could make this a lot easier.<p>2. Along the lines of this post, I’d love if an IDE would make it easier to create bookmarks and navigate between them to walk people through the code. I’d love to leave a comment sometimes that I can click to jump me to another location in the codebase. Stringing these together leads allows you to weave a narrative throughout the codebase to explain how things work!<p>Is anyone working in these kinds of things??</div><br/></div></div><div id="39498219" class="c"><input type="checkbox" id="c-39498219" checked=""/><div class="controls bullet"><span class="by">euroderf</span><span>|</span><a href="#39496931">parent</a><span>|</span><a href="#39497936">prev</a><span>|</span><a href="#39497302">next</a><span>|</span><label class="collapse" for="c-39498219">[-]</label><label class="expand" for="c-39498219">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you want a multitree.</div><br/></div></div><div id="39497302" class="c"><input type="checkbox" id="c-39497302" checked=""/><div class="controls bullet"><span class="by">abid786</span><span>|</span><a href="#39496931">parent</a><span>|</span><a href="#39498219">prev</a><span>|</span><a href="#39496109">next</a><span>|</span><label class="collapse" for="c-39497302">[-]</label><label class="expand" for="c-39497302">[4 more]</label></div><br/><div class="children"><div class="content">What would that practically look like? How would circular dependencies be resolved, for example?</div><br/><div id="39497466" class="c"><input type="checkbox" id="c-39497466" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39496931">root</a><span>|</span><a href="#39497302">parent</a><span>|</span><a href="#39497344">next</a><span>|</span><label class="collapse" for="c-39497466">[-]</label><label class="expand" for="c-39497466">[1 more]</label></div><br/><div class="children"><div class="content">As far as I&#x27;m concerned, if you have circular dependencies between directories, you&#x27;re doing something wrong (see also my top-level comment).<p>If you&#x27;re sane and have a DAG of directories, you can just toposort.</div><br/></div></div><div id="39497344" class="c"><input type="checkbox" id="c-39497344" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#39496931">root</a><span>|</span><a href="#39497302">parent</a><span>|</span><a href="#39497466">prev</a><span>|</span><a href="#39497327">next</a><span>|</span><label class="collapse" for="c-39497344">[-]</label><label class="expand" for="c-39497344">[1 more]</label></div><br/><div class="children"><div class="content">The two usual ways I&#x27;ve seen it is either by following the code&#x2F;control-flow (calls or inverted as called by) or by following the data flow. You can select any code function and see the call (or called) graph <i>(shown as a tree)</i>, similarly for any data element and see the data elements that use (or is used by) graph and pruning cycles.</div><br/></div></div><div id="39497327" class="c"><input type="checkbox" id="c-39497327" checked=""/><div class="controls bullet"><span class="by">nateabele</span><span>|</span><a href="#39496931">root</a><span>|</span><a href="#39497302">parent</a><span>|</span><a href="#39497344">prev</a><span>|</span><a href="#39496109">next</a><span>|</span><label class="collapse" for="c-39497327">[-]</label><label class="expand" for="c-39497327">[1 more]</label></div><br/><div class="children"><div class="content">Two nodes, and either two edges with one arrow each, or one edge with two arrows.<p>¯\_(ツ)_&#x2F;¯</div><br/></div></div></div></div></div></div><div id="39496109" class="c"><input type="checkbox" id="c-39496109" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#39496931">prev</a><span>|</span><a href="#39497887">next</a><span>|</span><label class="collapse" for="c-39496109">[-]</label><label class="expand" for="c-39496109">[1 more]</label></div><br/><div class="children"><div class="content">I would be wary of extrapolating what the author is writing of here to general software projects. I think it makes a lot of sense on large open source projects, where there are many contributors with little context- it is worth the effort to maintain such a document in this case. But all the developer committed documentation I&#x27;ve seen on smaller work projects have inevitably become unmaintained.</div><br/></div></div><div id="39497887" class="c"><input type="checkbox" id="c-39497887" checked=""/><div class="controls bullet"><span class="by">xavdid</span><span>|</span><a href="#39496109">prev</a><span>|</span><a href="#39497112">next</a><span>|</span><label class="collapse" for="c-39497887">[-]</label><label class="expand" for="c-39497887">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always found this to be a very useful practice. Many projects have a few core files (or packages &#x2F; modules &#x2F; whatever) where most of the changes happen. Being able to familiarize new contributors (or old returning ones) with those quickly really helps the startup time on a project.<p>I&#x27;ve added architecture files to projects at multiple jobs now [0], [1] and they&#x27;ve been well received. They&#x27;re not perfect, but they&#x27;re better than nothing.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;zapier&#x2F;zapier-platform&#x2F;pull&#x2F;324">https:&#x2F;&#x2F;github.com&#x2F;zapier&#x2F;zapier-platform&#x2F;pull&#x2F;324</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;stripe&#x2F;stripe-cli&#x2F;blob&#x2F;master&#x2F;ARCHITECTURE.md">https:&#x2F;&#x2F;github.com&#x2F;stripe&#x2F;stripe-cli&#x2F;blob&#x2F;master&#x2F;ARCHITECTUR...</a></div><br/></div></div><div id="39497112" class="c"><input type="checkbox" id="c-39497112" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#39497887">prev</a><span>|</span><a href="#39498481">next</a><span>|</span><label class="collapse" for="c-39497112">[-]</label><label class="expand" for="c-39497112">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  the shorter it is, the less likely it will be invalidated by some future change. This is the main rule of thumb for ARCHITECTURE — only specify things that are unlikely to frequently change. Don’t try to keep it synchronized with code.
</code></pre>
Interfaces are less likely [and harder!] to change. (<i>On the criteria to be used in decomposing systems into modules</i>, Parnas).<p>I agree it is <i>the</i> difficulty in grokking a codebase. &quot;Pattern&quot; naming sort of helps, but I end up having to read a far bit.<p>On github, I always keep thinking the commit messages for each file are descriptions. Would that be more useful?</div><br/></div></div><div id="39498481" class="c"><input type="checkbox" id="c-39498481" checked=""/><div class="controls bullet"><span class="by">tarcon</span><span>|</span><a href="#39497112">prev</a><span>|</span><a href="#39496536">next</a><span>|</span><label class="collapse" for="c-39498481">[-]</label><label class="expand" for="c-39498481">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s just more documentation to read which becomes outdated (read: lies) at the point in time someone moves code around with refactoring tooling in their IDE.<p>What about aspiring to &quot;screaming architecture&quot; instead? Don&#x27;t hide your application domain in a &quot;crates&quot; directory. Do it the other way around.</div><br/></div></div><div id="39496536" class="c"><input type="checkbox" id="c-39496536" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#39498481">prev</a><span>|</span><a href="#39498353">next</a><span>|</span><label class="collapse" for="c-39496536">[-]</label><label class="expand" for="c-39496536">[3 more]</label></div><br/><div class="children"><div class="content">My experience was that on every project I was onboarded I was shown such an architecture diagram with a brief explanation of its components.<p>Now I&#x27;m surprised how uncommon this is in open source.</div><br/><div id="39496807" class="c"><input type="checkbox" id="c-39496807" checked=""/><div class="controls bullet"><span class="by">lucb1e</span><span>|</span><a href="#39496536">parent</a><span>|</span><a href="#39498353">next</a><span>|</span><label class="collapse" for="c-39496807">[-]</label><label class="expand" for="c-39496807">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;explanation of its components&quot; is the problem: someone needs to do it. Open source projects don&#x27;t have an employee&#x27;s first day, so they don&#x27;t have this introduction.<p>They&#x27;re not good if you don&#x27;t have a sea of time, though. (An employee is <i>expected</i> to take a few weeks before getting anything done on their own.) I&#x27;m a security consultant, so we get to see a brand new one of these every two weeks and the problem with these explanations is that they are ad-hoc, unstructured, and mention lots of irrelevant details because the speaker has the curse of knowledge.<p>Perhaps someone new to the repository should write this thing once, after which it can just be maintained. Second best is to just have <i>anybody</i> write it down, taking a minute to think about what goes in there and what doesn&#x27;t rather than doing it always on the fly, because as the author says:<p>&gt; this file should describe the high-level architecture of the project. Keep it short: every recurring contributor will have to read it. Additionally, the shorter it is, the less likely it will be invalidated by some future change.</div><br/><div id="39497748" class="c"><input type="checkbox" id="c-39497748" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#39496536">root</a><span>|</span><a href="#39496807">parent</a><span>|</span><a href="#39498353">next</a><span>|</span><label class="collapse" for="c-39497748">[-]</label><label class="expand" for="c-39497748">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;explanation of its components&quot; is the problem: someone needs to do it. Open source projects don&#x27;t have an employee&#x27;s first day, so they don&#x27;t have this introduction.<p>Also a problem in my day $JOB the previous rockstar devs didn’t provide anything like this so it’s not a n open source thing it’s a the-code-are-the-docs mentality.</div><br/></div></div></div></div></div></div><div id="39498353" class="c"><input type="checkbox" id="c-39498353" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39496536">prev</a><span>|</span><a href="#39498060">next</a><span>|</span><label class="collapse" for="c-39498353">[-]</label><label class="expand" for="c-39498353">[1 more]</label></div><br/><div class="children"><div class="content">A DEVELOPMENT or HACKING document should be enough for contributors, to cite the coding guidelines. When someone wants to contribute without understanding the code workflow, he should not contribute.</div><br/></div></div><div id="39498060" class="c"><input type="checkbox" id="c-39498060" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#39498353">prev</a><span>|</span><a href="#39497565">next</a><span>|</span><label class="collapse" for="c-39498060">[-]</label><label class="expand" for="c-39498060">[1 more]</label></div><br/><div class="children"><div class="content">I’m 100% on board with this. Even if it’s just a <i>see docs</i> within the repo. I should be able to understand the intent of things without having to go read your website (should you’d remember to write one).<p>ASCII diagrams of components or your draw.io diagrams would go here. Knowing what you have is half the battle.</div><br/></div></div><div id="39497565" class="c"><input type="checkbox" id="c-39497565" checked=""/><div class="controls bullet"><span class="by">paiute</span><span>|</span><a href="#39498060">prev</a><span>|</span><a href="#39497449">next</a><span>|</span><label class="collapse" for="c-39497565">[-]</label><label class="expand" for="c-39497565">[1 more]</label></div><br/><div class="children"><div class="content">I love the idea here, but i loath the example. TMI. Give the core idea, any communication points (sockets, apis etc), maybe an abstract diagram.</div><br/></div></div><div id="39497449" class="c"><input type="checkbox" id="c-39497449" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39497565">prev</a><span>|</span><a href="#39495094">next</a><span>|</span><label class="collapse" for="c-39497449">[-]</label><label class="expand" for="c-39497449">[2 more]</label></div><br/><div class="children"><div class="content">One particular aspect of project architecture I often see people do wrong: a failure to have clear dependency structure between directories (and, often, too much stuff within a directory). This is particularly common if there is a directory named something like &quot;common&quot;, &quot;util&quot;, or &quot;misc&quot; (I am not actually arguing against having such directories, only noting they are prone to confusion).<p>I developed the following rules, which can be automatically enforced if you explicitly write the ranks (don&#x27;t try implicit ranking; that means you won&#x27;t get sane errors when you violate the rules):<p>0. Every directory has an implicit dependency on all its contained children.<p>1. A directory that does not depend on any other directories has rank 0. It suffices to only use rank between sibling directories, and it&#x27;s probably simplest to maintain, though global ranking <i>does</i> work.<p>2. A directory that depends on others has a rank of 1 + the highest rank among its dependencies. To ease refactoring you could loosen this to &quot;has a rank that is strictly greater than the highest rank among its dependencies&quot;.<p>3. Thus, circular dependencies between directories are forbidden; refactor (preferably, by <i>splitting</i> directories; most projects are too merged already) until you have a DAG. (circular dependencies between files in a single directory are allowed, subject to language-specific caution)<p>4. Thus, it is forbidden for a subdirectory to depend on a parent (or ancestor). If you encounter this, move the relevant files to a new subdirectory (since depending on a sibling or uncle is okay; if rank only applies between siblings this means the parent has to add a dependency on the uncle so that it gets the correct rank).<p>5. Depending on a cousin (or nephew) directory should be treated as a dependency on that cousin&#x27;s parent, though (depending on what amount of directory structure your language forces you to use) it may be a hint you&#x27;re doing something wrong.<p>6. Each directory can produce at most one library (shared and static count as the same library) or executable (at least, user-facing ones; code generators and tests might not count). Note that for other reasons it&#x27;s generally inadvisable to <i>ship</i> multiple shared libraries or multiple static libraries, though you might use them during development.<p>7. (YMMV) If a directory contains any generated files (or their inputs), it should not contain any other files. Note that there are at least 3 major workflows for generated files, so the details will vary, but isolating them is useful regardless.<p>Note again: this is both coarser and finer than build dependencies - we treat directories as units, but add conceptual dependencies. As a general rule, I find it useful to define that the client (which calls `connect`) depends on the server (which calls `listen` and `accept`), and&#x2F;or the data consumer depends on the data producer. Admittedly I have not deeply considered the case of servers that are worker-like, but note that it is often still possible to satisfy both by splitting directories further.<p>Note that additionally defining a &quot;weight&quot; (1 + weight of dependencies), although possible,
is not particularly useful at the directory level. Long chains are easier to understand than tangled messes, but have a higher weight, and we don&#x27;t want to discourage splitting a directory into a chain.<p>=====<p>In my experience, a project of about 100 kLoC organized itself about 20 immediate subdirectories of src&#x2F; with a max rank of about 10. This was roughly follows:<p>0-1: core support for the language, compiler, and replacements for the standard library; these almost never change. If somehow you have other kinds of code that doesn&#x27;t depend on these, consider artificially inflating their rank to at least 2. About 1 each.<p>2-3: most fairly-project-agnostic (but not polyfill-like) &quot;common&quot;-like directories. About 2-3 each, probably.<p>4-6: semi-project-specific common stuff, most executables&#x2F;libraries. IME generated files tend to belong here, and may be responsible for splitting a directory into a chain of length 3. There are a lot of these, usually with 1-2 dependencies of the previous rank and several more of the rank before that; likely there is <i>nothing</i> that depends on the <i>entirety</i> of any previous rank.<p>7-9: dependencies of the most complicated executable. About 1 each, a single chain at this point, though they might still have low-rank dependencies. At this point there&#x27;s a decent chance that a directory might depend on the entirety of rank 2.<p>10: the most complicated executable (at least for me, this was the executable that had a conceptual dependency on other executables, even if it didn&#x27;t have a source dependency. If you have a simple executable that conceptually depends on a complicated one, the simple one would be the highest rank instead). Note that only one of its dependencies is a 9; the rest are in the 3-6 range.<p>An alternate structure with deeper nesting, which I considered but never bothered to implement:<p><pre><code>  src&#x2F;base&#x2F; - the directories ranked 0-1 above
  src&#x2F;lib&#x2F; - everything that either is part of a shared library, or is used by multiple executables (all directories ranked 2-3, and some ranked 4-6)
  src&#x2F;each-executable&#x2F;various&#x2F; - dependencies of a particular executable (including all directories ranked 7-9 above)
  src&#x2F;each-executable&#x2F;main&#x2F; or just src&#x2F;each-executable&#x2F; - the file containing `main` and as little else as possible (otherwise we&#x27;re likely to confuse &quot;code closely related to `main`&quot; and &quot;code that is executable-specific but not involved in many dependencies&quot;)

</code></pre>
At top level, I never bothered to formalize it, but it was basically a single chain (though exactly what a &quot;dependency&quot; is not quite as clear here):<p>0: scripts&#x2F; - executable scripts used during the build that don&#x27;t have to be built, or that might be installed with no more than a shebang update.<p>1: src&#x2F; - all source code, including that for tests and tool&#x2F;<p>2: tool&#x2F; - built executables needed for later parts of the build. Refactoring to split this out from shebang scripts is nice for your sanity, but may be noisy, especially if your build system&#x27;s dependencies are sloppy. In contrast to build&#x2F; these are never cross-compiled.<p>3: build&#x2F; (all other output (data and potentially-cross-compiled code); contains bin&#x2F;, lib&#x2F;, and share&#x2F; at least)<p>Hopefully, projects that get much bigger than this can be split into further subdirectories so that the dependency ranking only need be done separately within them. I&#x27;m not sure if any big project is <i>actually</i> that nice in whole, but you should at least be able to create sanity in part without too much distress.<p>That said, keep in mind that this is just one approach to this particular problem, and it is just one architecture-related problem. Particularly, if your tooling makes it difficult to split directories (or files for that matter), fix your tooling first (related: &quot;recursive make considered harmful&quot;)</div><br/><div id="39498312" class="c"><input type="checkbox" id="c-39498312" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#39497449">parent</a><span>|</span><a href="#39495094">next</a><span>|</span><label class="collapse" for="c-39498312">[-]</label><label class="expand" for="c-39498312">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting approach, thanks for taking the time to write it! I&#x27;ll be evaluating my own projects with these guidelines- I think I&#x27;ve structured some of them like this without thinking about WHY</div><br/></div></div></div></div><div id="39495094" class="c"><input type="checkbox" id="c-39495094" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#39497449">prev</a><span>|</span><label class="collapse" for="c-39495094">[-]</label><label class="expand" for="c-39495094">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>One of the lessons I’ve learned is that the biggest difference between an occasional contributor and a core developer lies in the knowledge about the physical architecture of the project. Roughly, it takes 2x more time to write a patch if you are unfamiliar with the project, but it takes 10x more time to figure out where you should change the code.</i><p>Here here! This sounds like such awesome advice.<p>I wish we had better tools to visualize architecture of running systems. It&#x27;s crazy to me that reading the code or a markdown file are still so state of the art. Maybe if someone&#x27;s fancy they&#x27;ll have some nice Mermaid diagrams. I want the architecture to be able to show itself live. Broadscale macroscale observability, baked in.<p>I think this would help <i>everyone</i> be able to appreciate &amp; grok computing much more, would help humanity augment itself.</div><br/><div id="39495519" class="c"><input type="checkbox" id="c-39495519" checked=""/><div class="controls bullet"><span class="by">porkbrain</span><span>|</span><a href="#39495094">parent</a><span>|</span><label class="collapse" for="c-39495519">[-]</label><label class="expand" for="c-39495519">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to see something like [dep-tree](<a href="https:&#x2F;&#x2F;github.com&#x2F;gabotechs&#x2F;dep-tree">https:&#x2F;&#x2F;github.com&#x2F;gabotechs&#x2F;dep-tree</a>) &#x27;s visualization augmented with a keyword or LLM vector search. Your query would highlight relevant files and clusters.</div><br/><div id="39498951" class="c"><input type="checkbox" id="c-39498951" checked=""/><div class="controls bullet"><span class="by">20after4</span><span>|</span><a href="#39495094">root</a><span>|</span><a href="#39495519">parent</a><span>|</span><label class="collapse" for="c-39498951">[-]</label><label class="expand" for="c-39498951">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much what <a href="https:&#x2F;&#x2F;sourcegraph.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sourcegraph.com&#x2F;</a> are selling, is it not?  (granted, they don&#x27;t visualize their graph quite so graphically)</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>