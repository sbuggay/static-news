<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707123658250" as="style"/><link rel="stylesheet" href="styles.css?v=1707123658250"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://proofwiki.org/wiki/Main_Page">ProofWiki: Online compendium of mathematical proofs</a> <span class="domain">(<a href="https://proofwiki.org">proofwiki.org</a>)</span></div><div class="subtext"><span>Tomte</span> | <span>29 comments</span></div><br/><div><div id="39253516" class="c"><input type="checkbox" id="c-39253516" checked=""/><div class="controls bullet"><span class="by">alexmolas</span><span>|</span><a href="#39258173">next</a><span>|</span><label class="collapse" for="c-39253516">[-]</label><label class="expand" for="c-39253516">[4 more]</label></div><br/><div class="children"><div class="content">The featured proof about the sum of Fibonacci numbers divided by 2^n is beautiful.<p>When I started reading the proof I thought it was a mistake, a mismatch between the theorem to proof and the linked proof. I didn&#x27;t expect using Kolmogorov axioms to prove this kind of sums. I really enjoyed reading it. I just learned something new today, thanks!</div><br/><div id="39256128" class="c"><input type="checkbox" id="c-39256128" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#39253516">parent</a><span>|</span><a href="#39257593">next</a><span>|</span><label class="collapse" for="c-39256128">[-]</label><label class="expand" for="c-39256128">[1 more]</label></div><br/><div class="children"><div class="content">I found a more detailed explanation of that proof at <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4ApWBYBsc9k" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4ApWBYBsc9k</a><p>It also wasn&#x27;t immediately clear to me that this _is_ a valid sample space, the explanation in <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;math&#x2F;comments&#x2F;18szn6y&#x2F;anyone_use_proof_wiki&#x2F;kfciwa8&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;math&#x2F;comments&#x2F;18szn6y&#x2F;anyone_use_pr...</a> provides a more formal but still readable construction<p>I especially like the &quot;finite&quot; variant&#x2F;version of the proof which reframes this as a counting&#x2F;combinatorial proof instead of a probability-based one.</div><br/></div></div><div id="39257593" class="c"><input type="checkbox" id="c-39257593" checked=""/><div class="controls bullet"><span class="by">md224</span><span>|</span><a href="#39253516">parent</a><span>|</span><a href="#39256128">prev</a><span>|</span><a href="#39258173">next</a><span>|</span><label class="collapse" for="c-39257593">[-]</label><label class="expand" for="c-39257593">[2 more]</label></div><br/><div class="children"><div class="content">&gt; However, we also see that for only those combinations starting with a T (that is f(n - 1))...<p>Why is that f(n - 1)?</div><br/><div id="39257833" class="c"><input type="checkbox" id="c-39257833" checked=""/><div class="controls bullet"><span class="by">ihm</span><span>|</span><a href="#39253516">root</a><span>|</span><a href="#39257593">parent</a><span>|</span><a href="#39258173">next</a><span>|</span><label class="collapse" for="c-39257833">[-]</label><label class="expand" for="c-39257833">[1 more]</label></div><br/><div class="children"><div class="content">The set of sequences of length n ending in HH (and with no earlier HH) and beginning with a T are in bijection with the set of sequences of length n-1 ending in HH (and with no earlier HH) by the bijection<p><pre><code>   def f(s):
     assert(s[0] == &#x27;T&#x27;)
     return s[1:]
</code></pre>
whose inverse is<p><pre><code>  def f_inverse(s):
    return &#x27;T&#x27; + s</code></pre></div><br/></div></div></div></div></div></div><div id="39258173" class="c"><input type="checkbox" id="c-39258173" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#39253516">prev</a><span>|</span><a href="#39253284">next</a><span>|</span><label class="collapse" for="c-39258173">[-]</label><label class="expand" for="c-39258173">[1 more]</label></div><br/><div class="children"><div class="content">I remember findind this site when solving exercise of creating sign function for Z with arithmetic operators only. I used this[1] page to cheat and reimplement mod in C (by default % is rem) with defined zero. Unfortunately it doesn&#x27;t helped me yet, but I still like this site.<p>[1]: <a href="https:&#x2F;&#x2F;proofwiki.org&#x2F;wiki&#x2F;Definition:Modulo_Operation&#x2F;Modulo_Zero" rel="nofollow">https:&#x2F;&#x2F;proofwiki.org&#x2F;wiki&#x2F;Definition:Modulo_Operation&#x2F;Modul...</a></div><br/></div></div><div id="39253284" class="c"><input type="checkbox" id="c-39253284" checked=""/><div class="controls bullet"><span class="by">gdsimoes</span><span>|</span><a href="#39258173">prev</a><span>|</span><a href="#39254612">next</a><span>|</span><label class="collapse" for="c-39253284">[-]</label><label class="expand" for="c-39253284">[1 more]</label></div><br/><div class="children"><div class="content">What I like most about ProofWiki is its sometimes nonstandard notations. For example, the interval notation: <a href="https:&#x2F;&#x2F;proofwiki.org&#x2F;wiki&#x2F;Definition:Real_Interval&#x2F;Notation" rel="nofollow">https:&#x2F;&#x2F;proofwiki.org&#x2F;wiki&#x2F;Definition:Real_Interval&#x2F;Notation</a></div><br/></div></div><div id="39254612" class="c"><input type="checkbox" id="c-39254612" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#39253284">prev</a><span>|</span><a href="#39254180">next</a><span>|</span><label class="collapse" for="c-39254612">[-]</label><label class="expand" for="c-39254612">[2 more]</label></div><br/><div class="children"><div class="content">The ads significantly impact credibility for a site like this IMHO.</div><br/><div id="39255510" class="c"><input type="checkbox" id="c-39255510" checked=""/><div class="controls bullet"><span class="by">LeonB</span><span>|</span><a href="#39254612">parent</a><span>|</span><a href="#39254180">next</a><span>|</span><label class="collapse" for="c-39255510">[-]</label><label class="expand" for="c-39255510">[1 more]</label></div><br/><div class="children"><div class="content">Agree - and not simply the presence of ads, but the scammy, fraudulent type. I just saw the tiniest “X” to close an ad I’ve ever seen. And clicking it just opened the advertisers site anyway.<p>That’s not a sustainable strategy, that’s just fraud.</div><br/></div></div></div></div><div id="39254180" class="c"><input type="checkbox" id="c-39254180" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#39254612">prev</a><span>|</span><a href="#39253461">next</a><span>|</span><label class="collapse" for="c-39254180">[-]</label><label class="expand" for="c-39254180">[10 more]</label></div><br/><div class="children"><div class="content">From &quot;Ask HN: Did studying proof based math topics make you a better programmer?&quot; 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36463580">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36463580</a> :<p>&gt; <i>Lean mathlib was originally a type checker proof assistant, but now leanprover-community is implementing like all math as proofs in Lean in the mathlib project</i><p>Lean Mathlib is composed of <i>executable</i> proofs written in Lean: 
<a href="https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;mathlib-overview.html" rel="nofollow">https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;mathlib-overview.html</a></div><br/><div id="39255004" class="c"><input type="checkbox" id="c-39255004" checked=""/><div class="controls bullet"><span class="by">eduhetxub</span><span>|</span><a href="#39254180">parent</a><span>|</span><a href="#39255275">next</a><span>|</span><label class="collapse" for="c-39255004">[-]</label><label class="expand" for="c-39255004">[5 more]</label></div><br/><div class="children"><div class="content">Be careful. While a proof in Lean is executable (it is a script, so to speak) it is conceptually a sequence of references to tactics. Writing a Lean proof does involve a highly specialised form of functional programming, but I wouldn&#x27;t be at all sure that becoming an expert in Lean would improve your programming skills across the board.<p>Your comment also reminds me of  the people who claim that the Curry-Howard isomorphism means &quot;programming is math&quot;. It&#x27;s not a claim that anyone should really be making in good faith. There&#x27;s a lot more to programming than the lambda calculus.</div><br/><div id="39255303" class="c"><input type="checkbox" id="c-39255303" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#39254180">root</a><span>|</span><a href="#39255004">parent</a><span>|</span><a href="#39255275">next</a><span>|</span><label class="collapse" for="c-39255303">[-]</label><label class="expand" for="c-39255303">[4 more]</label></div><br/><div class="children"><div class="content">Verbal skills are apparently more predictive of programming career success than math scores.<p>Is Quantum Logic the correct propositional logic?
Is Quantum Logic a sufficient logic for all things?<p>I&#x27;d much rather work with machine-checkable proofs; though Lean is not what I&#x27;ve been taught math in either.<p>Coq-HoTT is written in Coq, not Lean.<p>A tool that finds the correspondence between proofs as presented and checkable proofs in a reasonable syntax would be helpful, I think.<p>If I start with 
&quot;Why is 2+2=4?&quot; [in this finite ring], I&#x27;m not sure how to find the relevant Lean code in Mathlib to prove my bias inductively, deductively, or abductively</div><br/><div id="39258735" class="c"><input type="checkbox" id="c-39258735" checked=""/><div class="controls bullet"><span class="by">isaacfrond</span><span>|</span><a href="#39254180">root</a><span>|</span><a href="#39255303">parent</a><span>|</span><a href="#39256523">next</a><span>|</span><label class="collapse" for="c-39258735">[-]</label><label class="expand" for="c-39258735">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Verbal skills are apparently more predictive of programming career success than math scores.<p>This is an urban legend inspired by this article [1]. One problem with this research though is that it studies language <i>learning</i>. Not how good a programmer one becomes, and certainly not career success.<p>[1]: Relating Natural Language Aptitude to Individual Differences in Learning Programming Languages. <a href="https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;s41598-020-60661-8" rel="nofollow">https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;s41598-020-60661-8</a></div><br/></div></div><div id="39256523" class="c"><input type="checkbox" id="c-39256523" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#39254180">root</a><span>|</span><a href="#39255303">parent</a><span>|</span><a href="#39258735">prev</a><span>|</span><a href="#39255275">next</a><span>|</span><label class="collapse" for="c-39256523">[-]</label><label class="expand" for="c-39256523">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Verbal skills are apparently more predictive of programming career success than math scores.<p>Curious about the  references!</div><br/><div id="39257796" class="c"><input type="checkbox" id="c-39257796" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#39254180">root</a><span>|</span><a href="#39256523">parent</a><span>|</span><a href="#39255275">next</a><span>|</span><label class="collapse" for="c-39257796">[-]</label><label class="expand" for="c-39257796">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard this and always thought it was probably true even setting aside the soft skills part of the job, but that was before data engineering and data scientists were common titles.  If it ever was true, the situation is probably more nuanced now than it used to be</div><br/></div></div></div></div></div></div></div></div><div id="39255275" class="c"><input type="checkbox" id="c-39255275" checked=""/><div class="controls bullet"><span class="by">ratmice</span><span>|</span><a href="#39254180">parent</a><span>|</span><a href="#39255004">prev</a><span>|</span><a href="#39253461">next</a><span>|</span><label class="collapse" for="c-39255275">[-]</label><label class="expand" for="c-39255275">[4 more]</label></div><br/><div class="children"><div class="content">Not all lean proofs are actually computable, see the computable function link in the url you gave.</div><br/><div id="39255600" class="c"><input type="checkbox" id="c-39255600" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#39254180">root</a><span>|</span><a href="#39255275">parent</a><span>|</span><a href="#39253461">next</a><span>|</span><label class="collapse" for="c-39255600">[-]</label><label class="expand" for="c-39255600">[3 more]</label></div><br/><div class="children"><div class="content">Not all code functions are mathematical functions. An expression can describe a relation that is not a function per the definition like &quot;a function always returns one output for one input&quot;.<p>Function (mathematics) <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Function_(mathematics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Function_(mathematics)</a><p>The Navier-Stokes equations are PDEs, not functions; but are they computable in Lean, or can algorithms for finding solutions be expressed in Lean?<p>Lean docs &gt; Missing undergraduate mathematics in mathlib: 
<a href="https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;undergrad_todo.html#:~:text=Multivariable%20calculus" rel="nofollow">https:&#x2F;&#x2F;leanprover-community.github.io&#x2F;undergrad_todo.html#:...</a><p>Is ℯ^(2ί π x) a function? It&#x27;s a complex function, but Geogebra draws it as a ~ (unit circle) + (y=0 if x &gt; 0).</div><br/><div id="39255710" class="c"><input type="checkbox" id="c-39255710" checked=""/><div class="controls bullet"><span class="by">ratmice</span><span>|</span><a href="#39254180">root</a><span>|</span><a href="#39255600">parent</a><span>|</span><a href="#39253461">next</a><span>|</span><label class="collapse" for="c-39255710">[-]</label><label class="expand" for="c-39255710">[2 more]</label></div><br/><div class="children"><div class="content">What I mean is lean can prove things like one of cantors theorems, the proof of which requires you to derive from properties on a function f showing that there exists a function g inverse to f, and show something about the results of calling g.<p>such a function in lean is considered non-computable by lean because it cannot be evaluated by lean since g has merely been shown to exist.<p>Many proofs in lean however are computable, just not all.</div><br/><div id="39255848" class="c"><input type="checkbox" id="c-39255848" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#39254180">root</a><span>|</span><a href="#39255710">parent</a><span>|</span><a href="#39253461">next</a><span>|</span><label class="collapse" for="c-39255848">[-]</label><label class="expand" for="c-39255848">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think SymPy has abstract Function attributes to reason about, but it does have limited reasoning about number classes given e.g. `x = Symbol(&#x27;x&#x27;, real=True)`<p>SymPy docs &gt; Writing Custom Functions &gt; Easy Cases: Fully Symbolic or Fully Evaluated:  <a href="https:&#x2F;&#x2F;docs.sympy.org&#x2F;latest&#x2F;guides&#x2F;custom-functions.html#writing-custom-functions" rel="nofollow">https:&#x2F;&#x2F;docs.sympy.org&#x2F;latest&#x2F;guides&#x2F;custom-functions.html#w...</a><p>If there is some sort of e.g. geometric correspondence, it could be possible for a Church-Turing classical computer to compute quantum functions (that return wave functions) that a Church-Turing-Deutsch quantum computer can compute; but otherwise Lean can&#x27;t compute most quantum circuits either.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39253461" class="c"><input type="checkbox" id="c-39253461" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39254180">prev</a><span>|</span><a href="#39255784">next</a><span>|</span><label class="collapse" for="c-39253461">[-]</label><label class="expand" for="c-39253461">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>ProofWiki is an online compendium of mathematical proofs</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31293073">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31293073</a> - May 2022 (16 comments)</div><br/></div></div><div id="39255784" class="c"><input type="checkbox" id="c-39255784" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#39253461">prev</a><span>|</span><a href="#39255421">next</a><span>|</span><label class="collapse" for="c-39255784">[-]</label><label class="expand" for="c-39255784">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Stem Formulas&quot; (2023) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36817851#36839925">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36817851#36839925</a></div><br/></div></div><div id="39255421" class="c"><input type="checkbox" id="c-39255421" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#39255784">prev</a><span>|</span><a href="#39253749">next</a><span>|</span><label class="collapse" for="c-39255421">[-]</label><label class="expand" for="c-39255421">[1 more]</label></div><br/><div class="children"><div class="content">The compendia of Metamath proofs us here
<a href="https:&#x2F;&#x2F;us.metamath.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;us.metamath.org&#x2F;</a><p>All of theree are formally from axioms or other formal proofs that lead back to their axioms, without any gaps.</div><br/></div></div><div id="39253749" class="c"><input type="checkbox" id="c-39253749" checked=""/><div class="controls bullet"><span class="by">ivancho</span><span>|</span><a href="#39255421">prev</a><span>|</span><a href="#39256105">next</a><span>|</span><label class="collapse" for="c-39253749">[-]</label><label class="expand" for="c-39253749">[6 more]</label></div><br/><div class="children"><div class="content">Their &quot;proof&quot; that there are only 12 solutions to 8 Mutually Non-Attacking Queens on Chessboard is just &quot;That there are only these 12 can be proved by brute force.&quot; :&#x2F;</div><br/><div id="39254203" class="c"><input type="checkbox" id="c-39254203" checked=""/><div class="controls bullet"><span class="by">geor9e</span><span>|</span><a href="#39253749">parent</a><span>|</span><a href="#39253779">next</a><span>|</span><label class="collapse" for="c-39254203">[-]</label><label class="expand" for="c-39254203">[2 more]</label></div><br/><div class="children"><div class="content">You have proof in sarcasm quotes, but it counts <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof_by_exhaustion" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof_by_exhaustion</a><p>In my university math departments putnam problem competition (they&#x27;d just be on the wall, prize was a $40 giant pizza each week) they would accept the most elegant solution, so if nobody else submitted something better I&#x27;d get a pizza for just running a few lines of python.</div><br/><div id="39255032" class="c"><input type="checkbox" id="c-39255032" checked=""/><div class="controls bullet"><span class="by">ivancho</span><span>|</span><a href="#39253749">root</a><span>|</span><a href="#39254203">parent</a><span>|</span><a href="#39253779">next</a><span>|</span><label class="collapse" for="c-39255032">[-]</label><label class="expand" for="c-39255032">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not gatekeeping proofs here, and I&#x27;m glad you got math pizza :) If proofwiki had exhaustively printed all possible arrangements, or the decision tree of constructing them, or if they had even included the code that would do the checking (like, say, <a href="https:&#x2F;&#x2F;www.richard-towers.com&#x2F;2023&#x2F;03&#x2F;11&#x2F;typescripting-the-technical-interview.html" rel="nofollow">https:&#x2F;&#x2F;www.richard-towers.com&#x2F;2023&#x2F;03&#x2F;11&#x2F;typescripting-the-...</a>), then I would agree it counts. But without even a rough ballpark estimate of possible arrangements to check, asserting &quot;brute force&quot; does not make a proof. If I incorporate understanding of the problem, I can see that at most we need to check 8!, which is reasonable. But if the constraints were not so simple, then we might be dealing with 64-choose-8 cases instead, which is heading into not-reasonable.<p>They can add the same sentence under every finite fact in their wiki, but then it won&#x27;t be a proof wiki, it would be a list of numeric facts they checked by brute force and we can either trust them, or check ourselves.</div><br/></div></div></div></div><div id="39253779" class="c"><input type="checkbox" id="c-39253779" checked=""/><div class="controls bullet"><span class="by">jusuhi</span><span>|</span><a href="#39253749">parent</a><span>|</span><a href="#39254203">prev</a><span>|</span><a href="#39256105">next</a><span>|</span><label class="collapse" for="c-39253779">[-]</label><label class="expand" for="c-39253779">[3 more]</label></div><br/><div class="children"><div class="content">The task proving some statement and the task of finding the shortest, or a &quot;reasonably short&quot; proof, are very different endeavours.<p>The first is about certainty that a statement is valid (&quot;true&quot;). The other is about simplifying the understanding of _why_ it is valid. Most of the time, you don&#x27;t care much about the latter.</div><br/><div id="39255201" class="c"><input type="checkbox" id="c-39255201" checked=""/><div class="controls bullet"><span class="by">ivancho</span><span>|</span><a href="#39253749">root</a><span>|</span><a href="#39253779">parent</a><span>|</span><a href="#39253891">next</a><span>|</span><label class="collapse" for="c-39255201">[-]</label><label class="expand" for="c-39255201">[1 more]</label></div><br/><div class="children"><div class="content">What is your certainty that that statement is true? What if it was a calculation which takes decades on a supercomputer?</div><br/></div></div><div id="39253891" class="c"><input type="checkbox" id="c-39253891" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#39253749">root</a><span>|</span><a href="#39253779">parent</a><span>|</span><a href="#39255201">prev</a><span>|</span><a href="#39256105">next</a><span>|</span><label class="collapse" for="c-39253891">[-]</label><label class="expand" for="c-39253891">[1 more]</label></div><br/><div class="children"><div class="content">It would be nice to have an reproducible example of how the result was achieved though. Otherwise it&#x27;s a compendium of results, not proofs.</div><br/></div></div></div></div></div></div><div id="39256105" class="c"><input type="checkbox" id="c-39256105" checked=""/><div class="controls bullet"><span class="by">ClassyJacket</span><span>|</span><a href="#39253749">prev</a><span>|</span><label class="collapse" for="c-39256105">[-]</label><label class="expand" for="c-39256105">[1 more]</label></div><br/><div class="children"><div class="content">In 
<a href="https:&#x2F;&#x2F;proofwiki.org&#x2F;wiki&#x2F;Definition:Graham%27s_Number" rel="nofollow">https:&#x2F;&#x2F;proofwiki.org&#x2F;wiki&#x2F;Definition:Graham%27s_Number</a><p>it states 
&quot;Amusingly, given that Graham&#x27;s number is an upper bound, the actual solution to the problem in question, according to certain experts, may well be 6. &quot;<p>I cannot edit the page but I believe they&#x27;re up to at least 13 now.</div><br/></div></div></div></div></div></div></div></body></html>