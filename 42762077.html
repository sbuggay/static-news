<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737363652207" as="style"/><link rel="stylesheet" href="styles.css?v=1737363652207"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://aartaka.me/lisp-indent.html">All Lisp indentation schemes are ugly</a> <span class="domain">(<a href="https://aartaka.me">aartaka.me</a>)</span></div><div class="subtext"><span>birdculture</span> | <span>66 comments</span></div><br/><div><div id="42763552" class="c"><input type="checkbox" id="c-42763552" checked=""/><div class="controls bullet"><span class="by">lihaoyi</span><span>|</span><a href="#42765524">next</a><span>|</span><label class="collapse" for="c-42763552">[-]</label><label class="expand" for="c-42763552">[39 more]</label></div><br/><div class="children"><div class="content">This post misses the IMO best indentation scheme for lisp, which I used for my college class where we had to use MIT scheme:<p><pre><code>    (define (match:element variable restrictions)
        (define (ok? datum)
            (every 
                (lambda (restriction)
                    (restriction datum)
                )
                restrictions
            )
        )
        (define (element-match data dictionary succeed)
            (and 
                (ok? data)
                (let ((vcell (match:lookup variable dictionary)))
                    (if vcell
                        (and 
                            (equal? (match:value vcell) data)
                            (succeed dictionary)
                        )
                        (succeed (match:bind variable data dictionary))
                    )
                )
            )
        )
        element-match
    )
</code></pre>
It may not be densest or most compact indentation scheme, but damn is it readable for someone without a lisp&#x2F;scheme background!</div><br/><div id="42766238" class="c"><input type="checkbox" id="c-42766238" checked=""/><div class="controls bullet"><span class="by">Avshalom</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42764619">next</a><span>|</span><label class="collapse" for="c-42766238">[-]</label><label class="expand" for="c-42766238">[1 more]</label></div><br/><div class="children"><div class="content">More of an allman Lisp guy myself<p><pre><code>  (
  define (match:element variable restrictions)
    (
    define (ok? datum)
      (
      every 
        (
        lambda (restriction)
          (restriction datum)
        )
        restrictions
      )
    )
  (
    define (element-match data dictionary succeed)
      (
      and 
        (ok? data)
        (
        let ((vcell (match:lookup variable dictionary)))
          (
          if vcell
            (
            and 
             (equal? (match:value vcell) data)
             (succeed dictionary)
            )
            (succeed (match:bind variable data dictionary))
          )
        )
      )
    )
    element-match
  )</code></pre></div><br/></div></div><div id="42764619" class="c"><input type="checkbox" id="c-42764619" checked=""/><div class="controls bullet"><span class="by">davvid</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42766238">prev</a><span>|</span><a href="#42764362">next</a><span>|</span><label class="collapse" for="c-42764619">[-]</label><label class="expand" for="c-42764619">[11 more]</label></div><br/><div class="children"><div class="content">&gt; This post misses the IMO best indentation scheme for lisp [...]<p>Likewise, a lispier(?) and more compact compromise?:<p><pre><code>    (define (match:element variable restrictions)
        (define (ok? datum)
            (every 
                (lambda (restriction)
                    (restriction datum))
                restrictions))
        (define (element-match data dictionary succeed)
            (and 
                (ok? data)
                (let ((vcell (match:lookup variable dictionary)))
                    (if vcell
                        (and 
                            (equal? (match:value vcell) data)
                            (succeed dictionary))
                        (succeed (match:bind variable data dictionary))))))
        element-match)</code></pre></div><br/><div id="42765641" class="c"><input type="checkbox" id="c-42765641" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42764619">parent</a><span>|</span><a href="#42764362">next</a><span>|</span><label class="collapse" for="c-42765641">[-]</label><label class="expand" for="c-42765641">[10 more]</label></div><br/><div class="children"><div class="content">It becomes much harder to notice if you have closed all the right matching parens, and hence where a token after the closing paren belongs. 
When the closing paren is exactly below the opening paren, on the same column, it becomes much easier to see the structure. It&#x27;s a very good thing for students who just learn Lisp.</div><br/><div id="42765826" class="c"><input type="checkbox" id="c-42765826" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765641">parent</a><span>|</span><a href="#42764362">next</a><span>|</span><label class="collapse" for="c-42765826">[-]</label><label class="expand" for="c-42765826">[9 more]</label></div><br/><div class="children"><div class="content">But all the cool kids are using paredit or parinfer which means you don&#x27;t actually ever write the closing parens yourself.<p>Counting parens is silly when the editor can do it for you.</div><br/><div id="42766245" class="c"><input type="checkbox" id="c-42766245" checked=""/><div class="controls bullet"><span class="by">wink</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765826">parent</a><span>|</span><a href="#42766160">next</a><span>|</span><label class="collapse" for="c-42766245">[-]</label><label class="expand" for="c-42766245">[2 more]</label></div><br/><div class="children"><div class="content">Not your fault, but I think it&#x27;s such a silly argument.<p>About 90% of my problems arise when I shift the parens, e.g. going from `(+ (1 2))` to `(+ (+ 1 2) 3)` or the other way round - and if there is now ) or )) at the very end (but more likely at 4+, not 1 or 2.<p>How would any plugin know what I mean here? (I know + is a bad example as its commutative...).</div><br/><div id="42766343" class="c"><input type="checkbox" id="c-42766343" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42766245">parent</a><span>|</span><a href="#42766160">next</a><span>|</span><label class="collapse" for="c-42766343">[-]</label><label class="expand" for="c-42766343">[1 more]</label></div><br/><div class="children"><div class="content">You need to clarify your example, because it appears that you are inserting `+` and `3` between existing parens rather than shifting them.<p>But regardless, I think the answer you are looking for is:<p>Some of the coolest kids of all use rainbow delimiters so that they can easily identify the matching closing paren with their eyes!</div><br/></div></div></div></div><div id="42766160" class="c"><input type="checkbox" id="c-42766160" checked=""/><div class="controls bullet"><span class="by">davvid</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765826">parent</a><span>|</span><a href="#42766245">prev</a><span>|</span><a href="#42766199">next</a><span>|</span><label class="collapse" for="c-42766160">[-]</label><label class="expand" for="c-42766160">[1 more]</label></div><br/><div class="children"><div class="content">Likewise, it&#x27;s better to optimize for experienced readers than it is to optimize for students.</div><br/></div></div><div id="42766199" class="c"><input type="checkbox" id="c-42766199" checked=""/><div class="controls bullet"><span class="by">harperlee</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765826">parent</a><span>|</span><a href="#42766160">prev</a><span>|</span><a href="#42765931">next</a><span>|</span><label class="collapse" for="c-42766199">[-]</label><label class="expand" for="c-42766199">[1 more]</label></div><br/><div class="children"><div class="content">Some time ago parinfer (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42766205">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42766205</a>) took some attention as a more pythonesque approach to matching presentation and meaning. I liked it, but it seems that it didn’t catch on, alas.</div><br/></div></div><div id="42765931" class="c"><input type="checkbox" id="c-42765931" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765826">parent</a><span>|</span><a href="#42766199">prev</a><span>|</span><a href="#42766028">next</a><span>|</span><label class="collapse" for="c-42765931">[-]</label><label class="expand" for="c-42765931">[3 more]</label></div><br/><div class="children"><div class="content">Writing code is usually easier than reading!</div><br/><div id="42766138" class="c"><input type="checkbox" id="c-42766138" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765931">parent</a><span>|</span><a href="#42766028">next</a><span>|</span><label class="collapse" for="c-42766138">[-]</label><label class="expand" for="c-42766138">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re not used to the language, the conceptual models of the codebase you are working on, or you&#x27;re working with obfuscated code. Otherwise it should be much faster to read and understand the code somebody else wrote than to write it from scratch?</div><br/><div id="42766430" class="c"><input type="checkbox" id="c-42766430" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42766138">parent</a><span>|</span><a href="#42766028">next</a><span>|</span><label class="collapse" for="c-42766430">[-]</label><label class="expand" for="c-42766430">[1 more]</label></div><br/><div class="children"><div class="content">No, I mean, in general, including languages which I work with for 20-25 years. Reading code is still harder than writing.</div><br/></div></div></div></div></div></div><div id="42766028" class="c"><input type="checkbox" id="c-42766028" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765826">parent</a><span>|</span><a href="#42765931">prev</a><span>|</span><a href="#42764362">next</a><span>|</span><label class="collapse" for="c-42766028">[-]</label><label class="expand" for="c-42766028">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.</div><br/></div></div></div></div></div></div></div></div><div id="42764362" class="c"><input type="checkbox" id="c-42764362" checked=""/><div class="controls bullet"><span class="by">n8henrie</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42764619">prev</a><span>|</span><a href="#42766269">next</a><span>|</span><label class="collapse" for="c-42764362">[-]</label><label class="expand" for="c-42764362">[3 more]</label></div><br/><div class="children"><div class="content">As a hobbyist that keeps trying to break into lisp, I think the absence of an obviously good formatter for lisps has made things <i>much</i> harder.<p>This looks like how I&#x27;ve naively tried to format things, and having started with python kind of makes sense.<p>But trying to read &#x2F; edit code with 5 parentheses bunched together, I have the hardest time telling if they are matched or where. Thank goodness for vim &#x2F; helix auto-matching.</div><br/><div id="42764717" class="c"><input type="checkbox" id="c-42764717" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42764362">parent</a><span>|</span><a href="#42764728">next</a><span>|</span><label class="collapse" for="c-42764717">[-]</label><label class="expand" for="c-42764717">[1 more]</label></div><br/><div class="children"><div class="content">The way to have a good time with lisp is using Emacs and Slime&#x2F;Sly. And if you like shortcuts, you can try Paredit for structural editing.<p>I just use the Tab key for indenting and it always work for me (there&#x27;s a logic on where to break line to get correct indenting, and it makes it easy to see if you misplaced a parenthesis. Also, both Emacs and Vim, highlight the matched parenthesis, so I never wonder about if I have the correct number of closing parenthesis.</div><br/></div></div><div id="42764728" class="c"><input type="checkbox" id="c-42764728" checked=""/><div class="controls bullet"><span class="by">JBiserkov</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42764362">parent</a><span>|</span><a href="#42764717">prev</a><span>|</span><a href="#42766269">next</a><span>|</span><label class="collapse" for="c-42764728">[-]</label><label class="expand" for="c-42764728">[1 more]</label></div><br/><div class="children"><div class="content">You can also try &quot;rainbow parens&quot; color scheme that makes nesting much easier to see.</div><br/></div></div></div></div><div id="42766269" class="c"><input type="checkbox" id="c-42766269" checked=""/><div class="controls bullet"><span class="by">dmos62</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42764362">prev</a><span>|</span><a href="#42765510">next</a><span>|</span><label class="collapse" for="c-42766269">[-]</label><label class="expand" for="c-42766269">[1 more]</label></div><br/><div class="children"><div class="content">The only thing that&#x27;s missing is moving most of nested logic into `let` assignments.</div><br/></div></div><div id="42765510" class="c"><input type="checkbox" id="c-42765510" checked=""/><div class="controls bullet"><span class="by">draven</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42766269">prev</a><span>|</span><a href="#42765491">next</a><span>|</span><label class="collapse" for="c-42765510">[-]</label><label class="expand" for="c-42765510">[1 more]</label></div><br/><div class="children"><div class="content">Admit you posted this only to trigger lispers.</div><br/></div></div><div id="42765491" class="c"><input type="checkbox" id="c-42765491" checked=""/><div class="controls bullet"><span class="by">donio</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42765510">prev</a><span>|</span><a href="#42763644">next</a><span>|</span><label class="collapse" for="c-42765491">[-]</label><label class="expand" for="c-42765491">[2 more]</label></div><br/><div class="children"><div class="content">For Lisp users this is 35% extra vertical space for zero readability benefit. Or negative readability rather. When I see this formatting style I have to fix it before I can read it. It&#x27;s like trying to read C code with an extra blank line after every single closing brace.</div><br/><div id="42765655" class="c"><input type="checkbox" id="c-42765655" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42765491">parent</a><span>|</span><a href="#42763644">next</a><span>|</span><label class="collapse" for="c-42765655">[-]</label><label class="expand" for="c-42765655">[1 more]</label></div><br/><div class="children"><div class="content">Lisp users are a diverse crowd. I won&#x27;t be so bold as to sign off for all of them.</div><br/></div></div></div></div><div id="42763644" class="c"><input type="checkbox" id="c-42763644" checked=""/><div class="controls bullet"><span class="by">rayiner</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42765491">prev</a><span>|</span><a href="#42765868">next</a><span>|</span><label class="collapse" for="c-42763644">[-]</label><label class="expand" for="c-42763644">[10 more]</label></div><br/><div class="children"><div class="content">That is blasphemy.</div><br/><div id="42764559" class="c"><input type="checkbox" id="c-42764559" checked=""/><div class="controls bullet"><span class="by">simplify</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42763644">parent</a><span>|</span><a href="#42764499">next</a><span>|</span><label class="collapse" for="c-42764559">[-]</label><label class="expand" for="c-42764559">[1 more]</label></div><br/><div class="children"><div class="content">You may not like it, but this is what peak lisp indentation looks like :)<p>Honestly though, this style for ending parenthesis of block-type nodes makes a lot of sense to me. And you still retain the benefit of macro-ing your own syntax when you need it.</div><br/></div></div><div id="42764499" class="c"><input type="checkbox" id="c-42764499" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42763644">parent</a><span>|</span><a href="#42764559">prev</a><span>|</span><a href="#42764824">next</a><span>|</span><label class="collapse" for="c-42764499">[-]</label><label class="expand" for="c-42764499">[3 more]</label></div><br/><div class="children"><div class="content">The uncuddled closing parens are a sure sign of a sick mind; probably corrupted by C or the like.</div><br/><div id="42765096" class="c"><input type="checkbox" id="c-42765096" checked=""/><div class="controls bullet"><span class="by">andriamanitra</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42764499">parent</a><span>|</span><a href="#42766349">next</a><span>|</span><label class="collapse" for="c-42765096">[-]</label><label class="expand" for="c-42765096">[1 more]</label></div><br/><div class="children"><div class="content">They make line-by-line diffs nicer. And it&#x27;s quite nice to be able to swap&#x2F;move lines without messing up the closing paren, especially when not using a structural editor.</div><br/></div></div><div id="42766349" class="c"><input type="checkbox" id="c-42766349" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42764499">parent</a><span>|</span><a href="#42765096">prev</a><span>|</span><a href="#42764824">next</a><span>|</span><label class="collapse" for="c-42766349">[-]</label><label class="expand" for="c-42766349">[1 more]</label></div><br/><div class="children"><div class="content">To be fair in C they don&#x27;t put semicolon on its own line either.</div><br/></div></div></div></div><div id="42764824" class="c"><input type="checkbox" id="c-42764824" checked=""/><div class="controls bullet"><span class="by">JBiserkov</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42763644">parent</a><span>|</span><a href="#42764499">prev</a><span>|</span><a href="#42765663">next</a><span>|</span><label class="collapse" for="c-42764824">[-]</label><label class="expand" for="c-42764824">[2 more]</label></div><br/><div class="children"><div class="content">One thing I dislike about the compact style is how adding&#x2F;removing a let block causes a diff line that is just adding&#x2F;removing a parent.</div><br/><div id="42765409" class="c"><input type="checkbox" id="c-42765409" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42764824">parent</a><span>|</span><a href="#42765663">next</a><span>|</span><label class="collapse" for="c-42765409">[-]</label><label class="expand" for="c-42765409">[1 more]</label></div><br/><div class="children"><div class="content">Do you really think it&#x27;s just a matter of style whether or not you must add or remove a parenthesis? Or whether that change shows up in a diff?</div><br/></div></div></div></div><div id="42765663" class="c"><input type="checkbox" id="c-42765663" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42763644">parent</a><span>|</span><a href="#42764824">prev</a><span>|</span><a href="#42763700">next</a><span>|</span><label class="collapse" for="c-42765663">[-]</label><label class="expand" for="c-42765663">[1 more]</label></div><br/><div class="children"><div class="content">A blasphemy is a very useful thing in cases when a discipline turns into a religion.
(Yes, I know about jokes.)</div><br/></div></div><div id="42763700" class="c"><input type="checkbox" id="c-42763700" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42763644">parent</a><span>|</span><a href="#42765663">prev</a><span>|</span><a href="#42764881">next</a><span>|</span><label class="collapse" for="c-42763700">[-]</label><label class="expand" for="c-42763700">[1 more]</label></div><br/><div class="children"><div class="content">Nicely indented easy to read blasphemy is the most dangerous kind!</div><br/></div></div><div id="42764881" class="c"><input type="checkbox" id="c-42764881" checked=""/><div class="controls bullet"><span class="by">acheron</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42763644">parent</a><span>|</span><a href="#42763700">prev</a><span>|</span><a href="#42765868">next</a><span>|</span><label class="collapse" for="c-42764881">[-]</label><label class="expand" for="c-42764881">[1 more]</label></div><br/><div class="children"><div class="content">Exactly what I was thinking.</div><br/></div></div></div></div><div id="42765868" class="c"><input type="checkbox" id="c-42765868" checked=""/><div class="controls bullet"><span class="by">mcv</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42763644">prev</a><span>|</span><a href="#42766340">next</a><span>|</span><label class="collapse" for="c-42765868">[-]</label><label class="expand" for="c-42765868">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;m surprised the article doesn&#x27;t address this obvious case. It&#x27;s pretty much my default indentation scheme for any language, and while I see a lot of lispers here complain about the wasted vertical space, it&#x27;s undeniably easy to see which parentheses match and what the block structure is.<p>I&#x27;ll happily tolerate some wasted space in that trade-off.</div><br/></div></div><div id="42766340" class="c"><input type="checkbox" id="c-42766340" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42765868">prev</a><span>|</span><a href="#42763762">next</a><span>|</span><label class="collapse" for="c-42766340">[-]</label><label class="expand" for="c-42766340">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the most disgusting things I read on HN.</div><br/></div></div><div id="42765360" class="c"><input type="checkbox" id="c-42765360" checked=""/><div class="controls bullet"><span class="by">stackghost</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42763762">prev</a><span>|</span><a href="#42764174">next</a><span>|</span><label class="collapse" for="c-42765360">[-]</label><label class="expand" for="c-42765360">[1 more]</label></div><br/><div class="children"><div class="content">Those poor lonely parens!</div><br/></div></div><div id="42764174" class="c"><input type="checkbox" id="c-42764174" checked=""/><div class="controls bullet"><span class="by">maiar</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42765360">prev</a><span>|</span><a href="#42765623">next</a><span>|</span><label class="collapse" for="c-42764174">[-]</label><label class="expand" for="c-42764174">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been in too many arguments about Lisp indentation but that actually comes close to decent with a couple of changes: move the singleton closing parens up, and reduce to, say, 2 spaces.</div><br/></div></div><div id="42765623" class="c"><input type="checkbox" id="c-42765623" checked=""/><div class="controls bullet"><span class="by">EFreethought</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42764174">prev</a><span>|</span><a href="#42765422">next</a><span>|</span><label class="collapse" for="c-42765623">[-]</label><label class="expand" for="c-42765623">[1 more]</label></div><br/><div class="children"><div class="content">I am sure there are some Emacs modes or plugins for other editors that could go back and forth between this and the more commonly-seen style.</div><br/></div></div><div id="42765422" class="c"><input type="checkbox" id="c-42765422" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42765623">prev</a><span>|</span><a href="#42764530">next</a><span>|</span><label class="collapse" for="c-42765422">[-]</label><label class="expand" for="c-42765422">[1 more]</label></div><br/><div class="children"><div class="content">Once you have even a small amount of that background it&#x27;s complete shit. Or else if it isn&#x27;t, nobody wants to work with you. But at that point that probably suits you fine. If you want to work completely alone, yet be maximally productive, you&#x27;ve landed in a good language family.</div><br/></div></div><div id="42764530" class="c"><input type="checkbox" id="c-42764530" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#42763552">parent</a><span>|</span><a href="#42765422">prev</a><span>|</span><a href="#42765524">next</a><span>|</span><label class="collapse" for="c-42764530">[-]</label><label class="expand" for="c-42764530">[2 more]</label></div><br/><div class="children"><div class="content">Honestly that&#x27;s the indentation format I use for every language. Doing it in Lisp just makes sense.<p>My &quot;OTBS all the things&quot; rules:<p>- Never horizontal align. Indentation is a simple tree, with each set of children indented 1 layer deeper, which can be 4 spaces or 1 tab.<p><pre><code>    ThisKindOfThing(
                    foo,
                    bar,
                    baz);
</code></pre>
is generally dumb.<p>- If a block is worth indenting for, the end of the block deserves its own line.  Just do OTBS but also for parentheses if you&#x27;ve a long function call.<p><pre><code>  ThisKindOfThing (
      foo,
      bar,
      baz
  );
</code></pre>
Is just more consistent and easier to manage while still being legible.<p>- if you&#x27;re ever splitting something across multiple lines there must be an indent.<p><pre><code>  myObj
      .Foo()
      .Bar()
      .Baz();
</code></pre>
- you&#x27;re allowed to double-dip on tree depth - that is indent only one level for like 3 levels of tree, as long as the opening of that 3-deep jump is a clear one-liner and the end of it is a line that says &quot;)))&quot;.<p><pre><code>  Foo(Bar(Baz(
      someVal
  )));
</code></pre>
- when splitting lines on infix operators, anything but commas go at the start of the line (also, bedmas counts as tree depth)<p><pre><code>  foo
      + bar
      + baz
      + (
          var1
          * var2
          * var3
      )
      + quux;</code></pre></div><br/><div id="42766374" class="c"><input type="checkbox" id="c-42766374" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#42763552">root</a><span>|</span><a href="#42764530">parent</a><span>|</span><a href="#42765524">next</a><span>|</span><label class="collapse" for="c-42766374">[-]</label><label class="expand" for="c-42766374">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty awful even for other languages.</div><br/></div></div></div></div></div></div><div id="42765524" class="c"><input type="checkbox" id="c-42765524" checked=""/><div class="controls bullet"><span class="by">RedNifre</span><span>|</span><a href="#42763552">prev</a><span>|</span><a href="#42763804">next</a><span>|</span><label class="collapse" for="c-42765524">[-]</label><label class="expand" for="c-42765524">[1 more]</label></div><br/><div class="children"><div class="content">Are there any formatters that detect related things and put them in the same column? Here&#x27;s a Pie example:<p><pre><code>  (claim  Tuple3 (-&gt;                U       U     U    U))
  (define Tuple3 (lambda          ( a       b     c   )
                   (Pair            a (Pair b     c)  )))
  (claim  tuple3Of (Pi (           (A U)   (B U) (C U))
                    (-&gt;             A       B     C
                      (Tuple3       A       B     C   ))))
  (define tuple3Of (lambda  (       A       B     C   )
                     (lambda      ( a       b     c   )
                       (the (Tuple3 A       B     C   )
                         (cons      a (cons b     c)) ))))

  (claim  Tuple5 (-&gt;                U       U       U       U     U    U))
  (define Tuple5 (lambda          ( a       b       c       d     e   )
                   (Pair            a (Pair b (Pair c (Pair d     e))))))
  (claim  tuple5Of (Pi            ((A U)   (B U)   (C U)   (D U) (E U))
                     (-&gt;            A       B       C       D     E
                       (Tuple5      A       B       C       D     E   ))))
  (define tuple5Of (lambda        ( A       B       C       D     E   )
                     (lambda      ( a       b       c       d     e   )
                       (the (Tuple5 A       B       C       D     E   )
                         (cons      a (cons b (cons c (cons d     e))))))))</code></pre></div><br/></div></div><div id="42763804" class="c"><input type="checkbox" id="c-42763804" checked=""/><div class="controls bullet"><span class="by">fn-mote</span><span>|</span><a href="#42765524">prev</a><span>|</span><a href="#42765384">next</a><span>|</span><label class="collapse" for="c-42763804">[-]</label><label class="expand" for="c-42763804">[1 more]</label></div><br/><div class="children"><div class="content">I love a Lisp-themed article, but this is such a yawn in 2025.<p>It seems pretty clear that a threading macro which allows the user to place the &quot;hole&quot; being filled wherever they want is the answer.<p>Example: cl-arrows<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nightfly19&#x2F;cl-arrows?tab=readme-ov-file">https:&#x2F;&#x2F;github.com&#x2F;nightfly19&#x2F;cl-arrows?tab=readme-ov-file</a></div><br/></div></div><div id="42765384" class="c"><input type="checkbox" id="c-42765384" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42763804">prev</a><span>|</span><a href="#42763112">next</a><span>|</span><label class="collapse" for="c-42765384">[-]</label><label class="expand" for="c-42765384">[2 more]</label></div><br/><div class="children"><div class="content">I just skipped to the bottom of this crap to find the real gem: it&#x27;s produced with the help of <i>ed</i>.<p>Yeah, someone working with <i>ed</i> its not going to like 19 repeated leading spaces across lines for vertical alignment. They will like that less than even somebody working with Notepad.</div><br/><div id="42766195" class="c"><input type="checkbox" id="c-42766195" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#42765384">parent</a><span>|</span><a href="#42763112">next</a><span>|</span><label class="collapse" for="c-42766195">[-]</label><label class="expand" for="c-42766195">[1 more]</label></div><br/><div class="children"><div class="content">...the author is using ed scripts as a static site generator, in a way completely unrelated to the post content. People are allowed to do oddball things.</div><br/></div></div></div></div><div id="42763112" class="c"><input type="checkbox" id="c-42763112" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#42765384">prev</a><span>|</span><a href="#42765651">next</a><span>|</span><label class="collapse" for="c-42763112">[-]</label><label class="expand" for="c-42763112">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Common Lisp in particular is extremely unfriendly to threading macros. Arrows imply a consistent thread-first or thread-last functions. But CL&#x27;s standard lib is too inconsistent for that to work. So we&#x27;re left with picking an indentation style we don&#x27;t necessarily like.</i><p>Diamond arrows exist, you know.<p><pre><code>    (-&lt;&gt; foo
      bar
      (baz)
      (quux 1 2 3)
      (fred 4 5 6 &lt;&gt;)
      (frob 7 &lt;&gt; 8 &lt;&gt; 9))
</code></pre>
All in all, this post reads like a rant, and I realized that upon reading &quot;now what I&#x27;m about to suggest is likely not to your taste&quot;. That style of indentation is something I use often when writing calls to long-named functions like COMPUTE-APPLICABLE-METHODS and I haven&#x27;t ever thought of it being not to my taste, or even of it being <i>ugly</i> as the author suggests.</div><br/></div></div><div id="42765651" class="c"><input type="checkbox" id="c-42765651" checked=""/><div class="controls bullet"><span class="by">wegfawefgawefg</span><span>|</span><a href="#42763112">prev</a><span>|</span><a href="#42763531">next</a><span>|</span><label class="collapse" for="c-42765651">[-]</label><label class="expand" for="c-42765651">[1 more]</label></div><br/><div class="children"><div class="content">idk i always just put a newline before every single open parens and that worked for me</div><br/></div></div><div id="42763531" class="c"><input type="checkbox" id="c-42763531" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42765651">prev</a><span>|</span><a href="#42763314">next</a><span>|</span><label class="collapse" for="c-42763531">[-]</label><label class="expand" for="c-42763531">[1 more]</label></div><br/><div class="children"><div class="content">never had any real issue using emacs indentation engine (not even sure lisp modes use smie..)</div><br/></div></div><div id="42763314" class="c"><input type="checkbox" id="c-42763314" checked=""/><div class="controls bullet"><span class="by">swayvil</span><span>|</span><a href="#42763531">prev</a><span>|</span><a href="#42763288">next</a><span>|</span><label class="collapse" for="c-42763314">[-]</label><label class="expand" for="c-42763314">[2 more]</label></div><br/><div class="children"><div class="content">Surely one could do it with different background colors instead. Any examples of that?</div><br/><div id="42764195" class="c"><input type="checkbox" id="c-42764195" checked=""/><div class="controls bullet"><span class="by">el_memorioso</span><span>|</span><a href="#42763314">parent</a><span>|</span><a href="#42763288">next</a><span>|</span><label class="collapse" for="c-42764195">[-]</label><label class="expand" for="c-42764195">[1 more]</label></div><br/><div class="children"><div class="content">For matching parentheses, Emacs users can use a package called rainbow-delimiters that colors matching delimiters. Different levels of enclosure use different colors. I&#x27;ve found this to be too much visual noise -- I am usually just interested on the delimiters for the current s-expressions. In this vein, having multiple different colored backgrounds would be garish and distracting for me.</div><br/></div></div></div></div><div id="42763288" class="c"><input type="checkbox" id="c-42763288" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#42763314">prev</a><span>|</span><a href="#42765300">next</a><span>|</span><label class="collapse" for="c-42763288">[-]</label><label class="expand" for="c-42763288">[11 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; (tree-transform-if predicate
    &gt;                   transformer
    &gt;                   (second tree)
    &gt;                   depth)
</code></pre>
&gt; A problematic function indentation
&gt; Nineteen! Nineteen spaces of indentation! It&#x27;s getting unruly. Such an indent, when used in deeply nested code, makes it too wide and unreadable. If you add the strict one-per-line alignment of arguments, it&#x27;s also painfully long line-wise.<p>I think this is more a problem with languages that encourage (or don&#x27;t discourage) deeply nested function calls. I face the same issue in Python, although Python kinda discourages me to do:<p><pre><code>    foo(
        bar(
            baz(
                far(
                    faz(...)))))

</code></pre>
Instead, Python and Pythonic idioms encourage a &quot;step by step&quot; approach:<p><pre><code>    a = faz(...)
    b = far(a)
    ...

</code></pre>
I don&#x27;t know which is &quot;better&quot;—the first approach requires thinking ahead about the chain of functions we&#x27;re about to call while the second one is more like a gradual development of the solution, albeit being more verbose than the former.</div><br/><div id="42764067" class="c"><input type="checkbox" id="c-42764067" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42763288">parent</a><span>|</span><a href="#42763545">next</a><span>|</span><label class="collapse" for="c-42764067">[-]</label><label class="expand" for="c-42764067">[1 more]</label></div><br/><div class="children"><div class="content">The second Python method that uses intermediary variable is what I use because it works much better with a debugger<p>I also like this trick to avoid nested for loops:<p><pre><code>  import itertools 
  names = [&#x27;Bob&#x27;, &#x27;Sam&#x27;]
  nums = [1,2]
  letters = [&#x27;A&#x27;,&#x27;B&#x27;]
  for name,num,letter in itertools.product(names,nums,letters):
      print(f&quot;{name} {num} {letter}&quot;)

  Bob 1 A
  Bob 1 B
  Bob 2 A
  Bob 2 B
  Sam 1 A
  Sam 1 B
  Sam 2 A
  Sam 2 B</code></pre></div><br/></div></div><div id="42763545" class="c"><input type="checkbox" id="c-42763545" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#42763288">parent</a><span>|</span><a href="#42764067">prev</a><span>|</span><a href="#42763555">next</a><span>|</span><label class="collapse" for="c-42763545">[-]</label><label class="expand" for="c-42763545">[4 more]</label></div><br/><div class="children"><div class="content">You can have the same step-by-step in Lisp via LET*. The problem outlined by the author happens when you have a function call where 1) the operator has a long name, 2) there are many arguments. The TREE-TRANSFORM-IF is such a case and you can&#x27;t solve it by just &quot;going step by step&quot;.</div><br/><div id="42764767" class="c"><input type="checkbox" id="c-42764767" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42763288">root</a><span>|</span><a href="#42763545">parent</a><span>|</span><a href="#42763598">next</a><span>|</span><label class="collapse" for="c-42764767">[-]</label><label class="expand" for="c-42764767">[2 more]</label></div><br/><div class="children"><div class="content">Why not just locally bind it to something shorter with let? Lisp is flexible enough that this is a non issue.</div><br/><div id="42765389" class="c"><input type="checkbox" id="c-42765389" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#42763288">root</a><span>|</span><a href="#42764767">parent</a><span>|</span><a href="#42763598">next</a><span>|</span><label class="collapse" for="c-42765389">[-]</label><label class="expand" for="c-42765389">[1 more]</label></div><br/><div class="children"><div class="content">You introduce four new variables. You get five lines instead of four, and four of these lines are pure cognitive overhead.</div><br/></div></div></div></div><div id="42763598" class="c"><input type="checkbox" id="c-42763598" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#42763288">root</a><span>|</span><a href="#42763545">parent</a><span>|</span><a href="#42764767">prev</a><span>|</span><a href="#42763555">next</a><span>|</span><label class="collapse" for="c-42763598">[-]</label><label class="expand" for="c-42763598">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I think for whatever reason, Lisp languages tend to use long names for funcs and vars whereas Haskell and other FP languages prefer symbols like &gt;&gt;=, &lt;$&gt;, etc. Personally, I prefer somewhere in the middle.<p>&gt; The TREE-TRANSFORM-IF is such a case and you can&#x27;t solve it by just &quot;going step by step&quot;.<p>Yes, this is a good point.</div><br/></div></div></div></div><div id="42763555" class="c"><input type="checkbox" id="c-42763555" checked=""/><div class="controls bullet"><span class="by">martin-t</span><span>|</span><a href="#42763288">parent</a><span>|</span><a href="#42763545">prev</a><span>|</span><a href="#42764609">next</a><span>|</span><label class="collapse" for="c-42763555">[-]</label><label class="expand" for="c-42763555">[3 more]</label></div><br/><div class="children"><div class="content">I prefer a third approach - chaining method calls via `.method()`. C#&#x27;s LINQ extension methods and Rust&#x27;s iterator methods do it and I find it to be the best of both worlds most of the time.</div><br/><div id="42763573" class="c"><input type="checkbox" id="c-42763573" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#42763288">root</a><span>|</span><a href="#42763555">parent</a><span>|</span><a href="#42764609">next</a><span>|</span><label class="collapse" for="c-42763573">[-]</label><label class="expand" for="c-42763573">[2 more]</label></div><br/><div class="children"><div class="content">So the &quot;fluent design&quot; approach? I like that too, and many OO languages allow for that, but I haven&#x27;t seen that approach in functional programming.</div><br/><div id="42764305" class="c"><input type="checkbox" id="c-42764305" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#42763288">root</a><span>|</span><a href="#42763573">parent</a><span>|</span><a href="#42764609">next</a><span>|</span><label class="collapse" for="c-42764305">[-]</label><label class="expand" for="c-42764305">[1 more]</label></div><br/><div class="children"><div class="content">Really?<p>Iterator methods are the only part of Rust&#x2F;C# that feel like normal decent function composition. Except Haskell is backwards.</div><br/></div></div></div></div></div></div><div id="42764609" class="c"><input type="checkbox" id="c-42764609" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#42763288">parent</a><span>|</span><a href="#42763555">prev</a><span>|</span><a href="#42765300">next</a><span>|</span><label class="collapse" for="c-42764609">[-]</label><label class="expand" for="c-42764609">[2 more]</label></div><br/><div class="children"><div class="content">That deep nest of function calls is why I love languages that have bash-style pipelining as a built in feature, either with explicit shell piping features, or where everything Function(myObj) is also implicitly myObj.Method()<p>Then it becomes (eg PowerShell, a language I hate but use constantly)<p><pre><code>  Faz | 
      Far |
      Baz |
      Bar |
      Foo
</code></pre>
Or (more C++&#x2F;Java&#x2F;C#-ish)<p><pre><code>  Faz()
      .Far()
      .Baz()
      .Bar()
      .Foo()
</code></pre>
In this way the data and execution flows forwards instead of backwards and you don&#x27;t have a pyramid of indentation.<p>I don&#x27;t know why we&#x27;re so stuck on prefix notation for function calls. Postfix is just easier to read in long chains.</div><br/><div id="42765864" class="c"><input type="checkbox" id="c-42765864" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42763288">root</a><span>|</span><a href="#42764609">parent</a><span>|</span><a href="#42765300">next</a><span>|</span><label class="collapse" for="c-42765864">[-]</label><label class="expand" for="c-42765864">[1 more]</label></div><br/><div class="children"><div class="content">In Python you have the wonderful <a href="https:&#x2F;&#x2F;github.com&#x2F;pytoolz&#x2F;toolz">https:&#x2F;&#x2F;github.com&#x2F;pytoolz&#x2F;toolz</a><p><pre><code>    from toolz import pipe
    pipe(&#x27;hello&#x27;,lambda w: ( &quot;foo&quot;, w ), lambda y: [ 0, y, 1 ])

    [0, (&#x27;foo&#x27;, &#x27;hello&#x27;), 1]
</code></pre>
You can used named functions, but they would need to be define above in upper scope<p><pre><code>    def h(x):
        return ( &quot;foo&quot;, x )

    def g(x):
        return [ 0, x, 1]

    pipe(&#x27;hello&#x27;, h, g)</code></pre></div><br/></div></div></div></div></div></div><div id="42763171" class="c"><input type="checkbox" id="c-42763171" checked=""/><div class="controls bullet"><span class="by">stevebmark</span><span>|</span><a href="#42765300">prev</a><span>|</span><label class="collapse" for="c-42763171">[-]</label><label class="expand" for="c-42763171">[5 more]</label></div><br/><div class="children"><div class="content">Lisp is an objectively goofy language,* I appreciate someone pointing out the pain points around trying to cobble together readability via indentation.<p>* Not a bad language - well, maybe bad by today&#x27;s standards, but undeniably a very important language - just goofy</div><br/><div id="42763227" class="c"><input type="checkbox" id="c-42763227" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#42763171">parent</a><span>|</span><a href="#42763221">next</a><span>|</span><label class="collapse" for="c-42763227">[-]</label><label class="expand" for="c-42763227">[3 more]</label></div><br/><div class="children"><div class="content">What languages do you use are readable without indentation?  I guess other than Python, where indentation actually contributes towards correctness rather than it just being optional.</div><br/><div id="42763260" class="c"><input type="checkbox" id="c-42763260" checked=""/><div class="controls bullet"><span class="by">cb321</span><span>|</span><a href="#42763171">root</a><span>|</span><a href="#42763227">parent</a><span>|</span><a href="#42764493">next</a><span>|</span><label class="collapse" for="c-42763260">[-]</label><label class="expand" for="c-42763260">[1 more]</label></div><br/><div class="children"><div class="content">Well, there is also <a href="https:&#x2F;&#x2F;nim-lang.org" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org</a> as well as a pretty big list at <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Off-side_rule" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Off-side_rule</a> .  Just expanding, not trying to invalidate your valid question!</div><br/></div></div><div id="42764493" class="c"><input type="checkbox" id="c-42764493" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#42763171">root</a><span>|</span><a href="#42763227">parent</a><span>|</span><a href="#42763260">prev</a><span>|</span><a href="#42763221">next</a><span>|</span><label class="collapse" for="c-42764493">[-]</label><label class="expand" for="c-42764493">[1 more]</label></div><br/><div class="children"><div class="content">APL?<p>(For certain values of readable)</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>