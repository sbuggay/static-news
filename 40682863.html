<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718528458055" as="style"/><link rel="stylesheet" href="styles.css?v=1718528458055"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.openmymind.net/Leveraging-Zigs-Allocators/">Leveraging Zig&#x27;s Allocators</a>Â <span class="domain">(<a href="https://www.openmymind.net">www.openmymind.net</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>90 comments</span></div><br/><div><div id="40690367" class="c"><input type="checkbox" id="c-40690367" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#40695442">next</a><span>|</span><label class="collapse" for="c-40690367">[-]</label><label class="expand" for="c-40690367">[16 more]</label></div><br/><div class="children"><div class="content">I think the last sample needs a `fba.reset()` call in between requests.<p>BTW, I used zig a lot recently and the opaque allocator system is great. You can create weird wrappers and stuff.<p>For example, the standard library json parser will parse json, deserialize a type that you requested (say, a struct). But it needs to allocate stuff. So it creates an arena for that specific operation and returns a wrapper that has a `deinit` method. Calling it deinits the arena so you essentially free everything in your graph of structs, arrays etc. And since it receives an upstream allocator for the arena, you could pass in any allocator. A fixed stack allocator if you wish to use stack space, another arena, maybe jemalloc wrapper. A test allocator that checks for memory leaks.. Whatever.</div><br/><div id="40690968" class="c"><input type="checkbox" id="c-40690968" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40690367">parent</a><span>|</span><a href="#40690715">next</a><span>|</span><label class="collapse" for="c-40690968">[-]</label><label class="expand" for="c-40690968">[5 more]</label></div><br/><div class="children"><div class="content">When I read json I always end up holding onto values from some of the keys. Sometimes the keys too if the node is abstract enough.<p>I assume the receiver then has to know it has to clone all of those values, yes?<p>That seems a little tricky for general code and moreso for unit tests.</div><br/><div id="40691005" class="c"><input type="checkbox" id="c-40691005" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40690968">parent</a><span>|</span><a href="#40691961">next</a><span>|</span><label class="collapse" for="c-40691005">[-]</label><label class="expand" for="c-40691005">[3 more]</label></div><br/><div class="children"><div class="content">You can pass the json deserializer an allocator that is appropriate for the lifetime of the object you want to get out of it, so often no copying is required.</div><br/><div id="40692357" class="c"><input type="checkbox" id="c-40692357" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40691005">parent</a><span>|</span><a href="#40691961">next</a><span>|</span><label class="collapse" for="c-40692357">[-]</label><label class="expand" for="c-40692357">[2 more]</label></div><br/><div class="children"><div class="content">Right, but that means you lose the simplicity and performance benefits of an arena allocator.</div><br/><div id="40692802" class="c"><input type="checkbox" id="c-40692802" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40692357">parent</a><span>|</span><a href="#40691961">next</a><span>|</span><label class="collapse" for="c-40692802">[-]</label><label class="expand" for="c-40692802">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve mainly written unusual code that allocates a bunch of FixedBufferAlocators up front and clears each of them according to their own lifecycles. I agree that more typical code would reach for a GPA or something here. If you&#x27;re using simdjzon, the tape and strings will be allocated contiguously within a pair of buffers (and then if you actually want to copy from the tape to your own struct containing slices or pointers then you&#x27;ll have to decide where that goes), but the std json stuff will just repeatedly call whatever allocator you give it.</div><br/></div></div></div></div></div></div><div id="40691961" class="c"><input type="checkbox" id="c-40691961" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40690968">parent</a><span>|</span><a href="#40691005">prev</a><span>|</span><a href="#40690715">next</a><span>|</span><label class="collapse" for="c-40691961">[-]</label><label class="expand" for="c-40691961">[1 more]</label></div><br/><div class="children"><div class="content">Unit tests are trivial because you can <i>probably</i> use a single arena that is only reset once at the end of the test. Unless the test is specifically to stress test memory in some form.<p>&gt; I assume the receiver then has to know it has to clone all of those values, yes?<p>The receiver needs to understand the lifetime any which way. If you parse a large JSON blob and wish to retain arbitrary key&#x2F;values you have to understand how long they&#x27;re valid for.<p>If you&#x27;re using a garbage collection language you can not worry about it (you just have to worry about other things!). You can think about it less if the key&#x2F;values are ref-counted. But for most C-like language implementations you probably have to retain either the entire parsed structure or clone the key&#x2F;values you care about.</div><br/></div></div></div></div><div id="40690715" class="c"><input type="checkbox" id="c-40690715" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#40690367">parent</a><span>|</span><a href="#40690968">prev</a><span>|</span><a href="#40691004">next</a><span>|</span><label class="collapse" for="c-40690715">[-]</label><label class="expand" for="c-40690715">[1 more]</label></div><br/><div class="children"><div class="content">fixed, thanks.</div><br/></div></div><div id="40691004" class="c"><input type="checkbox" id="c-40691004" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#40690367">parent</a><span>|</span><a href="#40690715">prev</a><span>|</span><a href="#40695442">next</a><span>|</span><label class="collapse" for="c-40691004">[-]</label><label class="expand" for="c-40691004">[9 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t this be better done with a class that takes care of its memory when it goes out of scope?</div><br/><div id="40695312" class="c"><input type="checkbox" id="c-40695312" checked=""/><div class="controls bullet"><span class="by">usrnm</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40691004">parent</a><span>|</span><a href="#40691010">next</a><span>|</span><label class="collapse" for="c-40695312">[-]</label><label class="expand" for="c-40695312">[1 more]</label></div><br/><div class="children"><div class="content">Because you can have an arbitrary number of object that can all be freed in O(1), instead of traversing a tree and calling individual destructors. An arena per object makes no sense</div><br/></div></div><div id="40691010" class="c"><input type="checkbox" id="c-40691010" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40691004">parent</a><span>|</span><a href="#40695312">prev</a><span>|</span><a href="#40691798">next</a><span>|</span><label class="collapse" for="c-40691010">[-]</label><label class="expand" for="c-40691010">[6 more]</label></div><br/><div class="children"><div class="content">There are no automatically-invoked destructors in Zig.</div><br/><div id="40692362" class="c"><input type="checkbox" id="c-40692362" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40691010">parent</a><span>|</span><a href="#40691798">next</a><span>|</span><label class="collapse" for="c-40692362">[-]</label><label class="expand" for="c-40692362">[5 more]</label></div><br/><div class="children"><div class="content">Perhaps if this was added it would prove to be a better solution in this case?</div><br/><div id="40692838" class="c"><input type="checkbox" id="c-40692838" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40692362">parent</a><span>|</span><a href="#40693655">next</a><span>|</span><label class="collapse" for="c-40692838">[-]</label><label class="expand" for="c-40692838">[2 more]</label></div><br/><div class="children"><div class="content">It would prevent you from writing the bug at the top of the thread.<p>I have stopped considering this sort of thing as a potential addition to the language because the BDFL doesn&#x27;t like it. So realistically we must remember to write reset, or defer deinit, etc. This sort of case hurts a little, but people who are used to RAII will experience more pain in cases where they want to return the value or store it somewhere and some other code gains responsibility for deinitializing it eventually.</div><br/><div id="40694315" class="c"><input type="checkbox" id="c-40694315" checked=""/><div class="controls bullet"><span class="by">i4k</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40692838">parent</a><span>|</span><a href="#40693655">next</a><span>|</span><label class="collapse" for="c-40694315">[-]</label><label class="expand" for="c-40694315">[1 more]</label></div><br/><div class="children"><div class="content">On the other hand, is more clear where things are released. When over relying on destructors, often it becomes trick to known when it happens and in which order. This kind of trade off is important to take into consideration depending on the project.</div><br/></div></div></div></div><div id="40693655" class="c"><input type="checkbox" id="c-40693655" checked=""/><div class="controls bullet"><span class="by">pharrington</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40692362">parent</a><span>|</span><a href="#40692838">prev</a><span>|</span><a href="#40691798">next</a><span>|</span><label class="collapse" for="c-40693655">[-]</label><label class="expand" for="c-40693655">[2 more]</label></div><br/><div class="children"><div class="content">One of Zig&#x27;s design goals is to have as little implicit behavior as possible.</div><br/><div id="40694646" class="c"><input type="checkbox" id="c-40694646" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40693655">parent</a><span>|</span><a href="#40691798">next</a><span>|</span><label class="collapse" for="c-40694646">[-]</label><label class="expand" for="c-40694646">[1 more]</label></div><br/><div class="children"><div class="content">I am well aware.</div><br/></div></div></div></div></div></div></div></div><div id="40691798" class="c"><input type="checkbox" id="c-40691798" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#40690367">root</a><span>|</span><a href="#40691004">parent</a><span>|</span><a href="#40691010">prev</a><span>|</span><a href="#40695442">next</a><span>|</span><label class="collapse" for="c-40691798">[-]</label><label class="expand" for="c-40691798">[1 more]</label></div><br/><div class="children"><div class="content">Need varies. Some memory needs to be still alive after the parse process.</div><br/></div></div></div></div></div></div><div id="40695442" class="c"><input type="checkbox" id="c-40695442" checked=""/><div class="controls bullet"><span class="by">cageface</span><span>|</span><a href="#40690367">prev</a><span>|</span><a href="#40690220">next</a><span>|</span><label class="collapse" for="c-40695442">[-]</label><label class="expand" for="c-40695442">[2 more]</label></div><br/><div class="children"><div class="content">I have to admit I donât really understand the problem Zig is trying to solve. If youâre not trying at the language level to address the core problems of C&#x2F;C++, like Rust is, then it seems like youâre just making a more ergonomic version of those languages and thatâs not enough to overcome how deeply entrenched they are.</div><br/><div id="40695542" class="c"><input type="checkbox" id="c-40695542" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#40695442">parent</a><span>|</span><a href="#40690220">next</a><span>|</span><label class="collapse" for="c-40695542">[-]</label><label class="expand" for="c-40695542">[1 more]</label></div><br/><div class="children"><div class="content">Zigs tight C integration makes it easy to just start using Zig in an existing C codebase, which is a great way to overcome the challenges you&#x27;ve mentioned. It doesn&#x27;t need to replace C all at once, just slowly.</div><br/></div></div></div></div><div id="40690220" class="c"><input type="checkbox" id="c-40690220" checked=""/><div class="controls bullet"><span class="by">gizmo</span><span>|</span><a href="#40695442">prev</a><span>|</span><a href="#40689870">next</a><span>|</span><label class="collapse" for="c-40690220">[-]</label><label class="expand" for="c-40690220">[36 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not 100% sure how Zig allocators work but it looks like the arena memory is getting re-used without zeroing the memory? With slight memory corruption freed memory from a previous request can end up leaking. That&#x27;s not great.<p>Even if you don&#x27;t have process isolation between workers (which is generally what you want) then you can still put memory arenas far apart in virtual memory, make use of inaccessible guard pages, and take other precautions to prevent catastrophic memory corruption.</div><br/><div id="40692997" class="c"><input type="checkbox" id="c-40692997" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40690287">next</a><span>|</span><label class="collapse" for="c-40692997">[-]</label><label class="expand" for="c-40692997">[1 more]</label></div><br/><div class="children"><div class="content">In my Zig servers I&#x27;m using a similar arena-based (with resetting) strategy. It&#x27;s not as bad as you&#x27;d imagine:<p>The current alloc implementation memsets under the hood. There are ongoing discussions about the right way to remove that performance overhead, but safety comes first.<p>Any sane implementation has an arena per request and per connection anyway, not shared between processes. You don&#x27;t have bonkers aliasing bugs because the OS would have panicked before handing out that memory.<p>Zig has a lot of small features designed to make memory corruption an unhappy code path. I&#x27;ve had one corruption bug out of a lot of Zig code the last few years. It was from a misunderstanding of async (a classic stack pointer leak disguised by a confusion over async syntax). It&#x27;s not an issue since async is gone from the language, and that sort of thing is normally turned into a compiler error anyway as soon as somebody reports it.</div><br/></div></div><div id="40690287" class="c"><input type="checkbox" id="c-40690287" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40692997">prev</a><span>|</span><a href="#40690379">next</a><span>|</span><label class="collapse" for="c-40690287">[-]</label><label class="expand" for="c-40690287">[1 more]</label></div><br/><div class="children"><div class="content">I guess you could place a zeroing allocator wrapper in between the arena and it&#x27;s underlying allocator. That would write zero to anything that&#x27;s getting freed. Arena deinit will free anything allocated from the underlying allocator so upon completion of each request, used memory would be zeroed before returned back to the main allocator.<p>And that handler signature would still be the same. Which is the he whole point of this article so, yay.</div><br/></div></div><div id="40690379" class="c"><input type="checkbox" id="c-40690379" checked=""/><div class="controls bullet"><span class="by">nurpax</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40690287">prev</a><span>|</span><a href="#40690471">next</a><span>|</span><label class="collapse" for="c-40690379">[-]</label><label class="expand" for="c-40690379">[1 more]</label></div><br/><div class="children"><div class="content">The same can happen with C malloc&#x2F;free too.</div><br/></div></div><div id="40690471" class="c"><input type="checkbox" id="c-40690471" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40690379">prev</a><span>|</span><a href="#40690532">next</a><span>|</span><label class="collapse" for="c-40690471">[-]</label><label class="expand" for="c-40690471">[21 more]</label></div><br/><div class="children"><div class="content">Thatâs not specific to Zig â local heap allocators generally donât zero deallocated memory â thatâs a significant, unnecessary performance hit.<p>If you need data to be isolated when memory is corrupt, you need it to be isolated always.</div><br/><div id="40691479" class="c"><input type="checkbox" id="c-40691479" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40690471">parent</a><span>|</span><a href="#40690532">next</a><span>|</span><label class="collapse" for="c-40691479">[-]</label><label class="expand" for="c-40691479">[20 more]</label></div><br/><div class="children"><div class="content">memset is <i>the</i> golden example of an easily pipelined, parallelized, predictable CPU operation - any semi-modern CPU couldn&#x27;t ask for easier work to do. Zeroing 8 KB of memory is <i>very</i> cheap.<p>If we use a modern Xeon chip as an example, an AVX2 store has a throughput of 2 instructions &#x2F; cycle. Doing that 256 times for 8 KB totals 128 cycles, plus a few extra cycles to account for the latency of issuing the first instruction and the last store to the L1 cache. With a 2 GHz clock frequency, it still takes less than 70 nanoseconds. For comparison, an integer divide has a worst-case latency of 90ish cycles, or 45ish nanoseconds.</div><br/><div id="40692825" class="c"><input type="checkbox" id="c-40692825" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691479">parent</a><span>|</span><a href="#40691918">next</a><span>|</span><label class="collapse" for="c-40692825">[-]</label><label class="expand" for="c-40692825">[3 more]</label></div><br/><div class="children"><div class="content">Zeroing memory is very cheap, but not zeroing it is even cheaper.<p>Zeroing memory on deallocation can be important for sensitive data. Otherwise, it makes more sense to zero on allocation <i>if</i> you know that it&#x27;s needed because the allocated structure will be used without initilazation <i>and</i> the memory isn&#x27;t zero by guarantee (most OSes guarantee newly allocated memory will be zero, and have a process to zero pages in the background when possible)</div><br/><div id="40693136" class="c"><input type="checkbox" id="c-40693136" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40692825">parent</a><span>|</span><a href="#40691918">next</a><span>|</span><label class="collapse" for="c-40693136">[-]</label><label class="expand" for="c-40693136">[2 more]</label></div><br/><div class="children"><div class="content">Sure, but in most practical applications where an HTTP server is involved, zeroing the request&#x2F;response buffer memory is very unlikely to ever be your bottleneck. Even at 10K RPS per core, your per-request CPU time budget is 100 microseconds. Zeroing memory will only account for a fraction of a percentage of that.<p>If you&#x27;re exposing an HTTP API to clients, it&#x27;s likely that any response&#x27;s contents will contain sensitive client-specific data. If memory corruption bugs are more likely than bottlenecking on zeroing out your request&#x2F;response buffer, then zeroing the request&#x2F;response buffer is a good idea, until proven otherwise by benchmarks or profiling.</div><br/><div id="40693704" class="c"><input type="checkbox" id="c-40693704" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40693136">parent</a><span>|</span><a href="#40691918">next</a><span>|</span><label class="collapse" for="c-40693704">[-]</label><label class="expand" for="c-40693704">[1 more]</label></div><br/><div class="children"><div class="content">Zeroing on allocation is much more sensible though because that way you preload the memory into your caches as opposed to on deallocation where you bring memory into cache that you know you no longer care about. Also if you do the zero on allocation, the compiler can delete it if it can prove that you write to the memory before reading to it.</div><br/></div></div></div></div></div></div><div id="40691918" class="c"><input type="checkbox" id="c-40691918" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691479">parent</a><span>|</span><a href="#40692825">prev</a><span>|</span><a href="#40691972">next</a><span>|</span><label class="collapse" for="c-40691918">[-]</label><label class="expand" for="c-40691918">[5 more]</label></div><br/><div class="children"><div class="content">This memory is now the least recently used in the L1 cache, despite being freed by the allocator, meaning it probably isn&#x27;t being used again.<p>If it was freed after already being removed from the L1 cache, then you also need to evict other L1 cache contents and wait for it to be read into L1 so you can write to it.<p>128 cycles is a generous estimate, and ignores the costs to the rest of the program.</div><br/><div id="40692583" class="c"><input type="checkbox" id="c-40692583" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691918">parent</a><span>|</span><a href="#40692385">next</a><span>|</span><label class="collapse" for="c-40692583">[-]</label><label class="expand" for="c-40692583">[3 more]</label></div><br/><div class="children"><div class="content">You can use non-temporal writes to avoid this, and some CPUs have an instruction that zeroes a cache line. It&#x27;s not expensive to do this.</div><br/><div id="40693543" class="c"><input type="checkbox" id="c-40693543" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40692583">parent</a><span>|</span><a href="#40692385">next</a><span>|</span><label class="collapse" for="c-40693543">[-]</label><label class="expand" for="c-40693543">[2 more]</label></div><br/><div class="children"><div class="content">Nontemporal writes are substantially slower, e.g. with avx512 you can do 1 64 byte nontemporal write every 5 or so clock cycles. That puts you at &gt;= 640 cycles for 8 KiB.
<a href="https:&#x2F;&#x2F;uops.info&#x2F;html-instr&#x2F;VMOVNTPS_M512_ZMM.html" rel="nofollow">https:&#x2F;&#x2F;uops.info&#x2F;html-instr&#x2F;VMOVNTPS_M512_ZMM.html</a></div><br/><div id="40694192" class="c"><input type="checkbox" id="c-40694192" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40693543">parent</a><span>|</span><a href="#40692385">next</a><span>|</span><label class="collapse" for="c-40694192">[-]</label><label class="expand" for="c-40694192">[1 more]</label></div><br/><div class="children"><div class="content">Well, the point of a non-temporal write kind of is that you don&#x27;t care how fast it is. (Since if it was being read again anytime soon, you&#x27;d want it in the cache.)<p>But yes, it can be an over-optimization.</div><br/></div></div></div></div></div></div><div id="40692385" class="c"><input type="checkbox" id="c-40692385" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691918">parent</a><span>|</span><a href="#40692583">prev</a><span>|</span><a href="#40691972">next</a><span>|</span><label class="collapse" for="c-40692385">[-]</label><label class="expand" for="c-40692385">[1 more]</label></div><br/><div class="children"><div class="content">The worker is already reading&#x2F;writing to the buffer memory to service each incoming HTTP request, whether the memory is zeroed or not. The side effects on the CPU cache are insubstantial.</div><br/></div></div></div></div><div id="40691972" class="c"><input type="checkbox" id="c-40691972" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691479">parent</a><span>|</span><a href="#40691918">prev</a><span>|</span><a href="#40692889">next</a><span>|</span><label class="collapse" for="c-40691972">[-]</label><label class="expand" for="c-40691972">[8 more]</label></div><br/><div class="children"><div class="content">This might be a stupid question, but why isn&#x27;t zeroing 8KB of memory a single instruction? It must be so common as to be worthy that all the layers of memory (and indirection) to understand that.</div><br/><div id="40693499" class="c"><input type="checkbox" id="c-40693499" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691972">parent</a><span>|</span><a href="#40692586">next</a><span>|</span><label class="collapse" for="c-40693499">[-]</label><label class="expand" for="c-40693499">[2 more]</label></div><br/><div class="children"><div class="content">128-bit or 256-bit memsets via SIMD instructions are sufficient to saturate RAM bandwidth, so there wouldn&#x27;t be much of a gain from having a dedicated instruction.<p>(By the way, x86 does have a dedicated instruction--rep stosb--but compilers differ as to how often they use it, for the reason cited above.)</div><br/><div id="40694757" class="c"><input type="checkbox" id="c-40694757" checked=""/><div class="controls bullet"><span class="by">tubs</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40693499">parent</a><span>|</span><a href="#40692586">next</a><span>|</span><label class="collapse" for="c-40694757">[-]</label><label class="expand" for="c-40694757">[1 more]</label></div><br/><div class="children"><div class="content">The gain is in power efficiency.<p>Arm64 provides `dc zva` for this.</div><br/></div></div></div></div><div id="40692586" class="c"><input type="checkbox" id="c-40692586" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691972">parent</a><span>|</span><a href="#40693499">prev</a><span>|</span><a href="#40692409">next</a><span>|</span><label class="collapse" for="c-40692586">[-]</label><label class="expand" for="c-40692586">[4 more]</label></div><br/><div class="children"><div class="content">If the memory is above the size of a page, you can tell the VM to drop the page and give you a new zero filled one instead.</div><br/><div id="40692925" class="c"><input type="checkbox" id="c-40692925" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40692586">parent</a><span>|</span><a href="#40692409">next</a><span>|</span><label class="collapse" for="c-40692925">[-]</label><label class="expand" for="c-40692925">[3 more]</label></div><br/><div class="children"><div class="content">For 8kb? Syscalling in to the kernel, updating the processesâs memory map and then later faulting is probably slower by an order of magnitude or more compared to just setting those bytes to zero.<p>Memcpy, bzero and friends are insanely fast. Practically free when those bytes are in the cpuâs cache already.</div><br/><div id="40693205" class="c"><input type="checkbox" id="c-40693205" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40692925">parent</a><span>|</span><a href="#40692409">next</a><span>|</span><label class="collapse" for="c-40693205">[-]</label><label class="expand" for="c-40693205">[2 more]</label></div><br/><div class="children"><div class="content">So don&#x27;t syscall. Darwin has a system similar to io_uring for this.<p>(But it also has a 16KB page size.)</div><br/><div id="40695172" class="c"><input type="checkbox" id="c-40695172" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40693205">parent</a><span>|</span><a href="#40692409">next</a><span>|</span><label class="collapse" for="c-40695172">[-]</label><label class="expand" for="c-40695172">[1 more]</label></div><br/><div class="children"><div class="content">Probably still cause a page fault when the memory is re-accessed though. I suspect even using io_uring will still be a lot slower than bzero if you&#x27;re just zeroing out 2 pages of memory. Zeroing memory is <i>really</i> fast.</div><br/></div></div></div></div></div></div></div></div><div id="40692409" class="c"><input type="checkbox" id="c-40692409" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691972">parent</a><span>|</span><a href="#40692586">prev</a><span>|</span><a href="#40692889">next</a><span>|</span><label class="collapse" for="c-40692409">[-]</label><label class="expand" for="c-40692409">[1 more]</label></div><br/><div class="children"><div class="content">Zeroing something that large is not typical. That said, some architectures have optimized zeroing instructions, such as dc zva on ARM.</div><br/></div></div></div></div><div id="40692889" class="c"><input type="checkbox" id="c-40692889" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691479">parent</a><span>|</span><a href="#40691972">prev</a><span>|</span><a href="#40690532">next</a><span>|</span><label class="collapse" for="c-40692889">[-]</label><label class="expand" for="c-40692889">[3 more]</label></div><br/><div class="children"><div class="content">compilers are probably going to remove that memset.</div><br/><div id="40692930" class="c"><input type="checkbox" id="c-40692930" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40692889">parent</a><span>|</span><a href="#40694260">next</a><span>|</span><label class="collapse" for="c-40692930">[-]</label><label class="expand" for="c-40692930">[1 more]</label></div><br/><div class="children"><div class="content">In C, you can use explicit_bzero to make sure the instructions arenât removed by the optimiser:<p><a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;bzero.3.html" rel="nofollow">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man3&#x2F;bzero.3.html</a></div><br/></div></div><div id="40694260" class="c"><input type="checkbox" id="c-40694260" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40692889">parent</a><span>|</span><a href="#40692930">prev</a><span>|</span><a href="#40690532">next</a><span>|</span><label class="collapse" for="c-40694260">[-]</label><label class="expand" for="c-40694260">[1 more]</label></div><br/><div class="children"><div class="content">Compilers can remove the memset if they can show it is overwritten prior to use (though C and C++ UB could technically make it possible to skip padding they donât), or it isnât used (in which case we go back to non-zeroâd memory again which in this scenario weâre trying to avoid).<p>There are various _s variants of memset, etc that require the compiler to perform the operations even if it âprovesâ the data cannot be read.<p>And finally modern hardware has mechanisms to say âthis is now zeroâ and not actually zero the memory and instead just tell the MMU that the region is now zero (which removes the cpu time and cache impact of accessing the memory directly).<p>On macOS and iOS I believe all memory is now zeroâd on free and I think malloc ostensibly therefore guarantees zeroâd memory (the problem I think is whether calloc tries to rely on that behavior, because then calloc can produce non-zero memory courtesy of a buffer overrun&#x2F;UaF after free has ostensibly zeroâd memory)</div><br/></div></div></div></div></div></div></div></div><div id="40690532" class="c"><input type="checkbox" id="c-40690532" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40690471">prev</a><span>|</span><a href="#40691824">next</a><span>|</span><label class="collapse" for="c-40690532">[-]</label><label class="expand" for="c-40690532">[6 more]</label></div><br/><div class="children"><div class="content">Deinit in O(1) seems to be a big attraction of arenas.</div><br/><div id="40690976" class="c"><input type="checkbox" id="c-40690976" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40690532">parent</a><span>|</span><a href="#40691824">next</a><span>|</span><label class="collapse" for="c-40690976">[-]</label><label class="expand" for="c-40690976">[5 more]</label></div><br/><div class="children"><div class="content">O(1) is nice, but I feel like avoiding walking a bunch of data structures is maybe most important.</div><br/><div id="40691118" class="c"><input type="checkbox" id="c-40691118" checked=""/><div class="controls bullet"><span class="by">elvircrn</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40690976">parent</a><span>|</span><a href="#40691824">next</a><span>|</span><label class="collapse" for="c-40691118">[-]</label><label class="expand" for="c-40691118">[4 more]</label></div><br/><div class="children"><div class="content">Any papers&#x2F;blogs&#x2F;SO answers covering this?</div><br/><div id="40692676" class="c"><input type="checkbox" id="c-40692676" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691118">parent</a><span>|</span><a href="#40692374">next</a><span>|</span><label class="collapse" for="c-40692676">[-]</label><label class="expand" for="c-40692676">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have anything for you, but if you have some normally allocated hierarchal data structures in order to free them you&#x27;ll have to go through their members, chase pointers, etc., to figure out the addresses to free, then call free on them in sequence. That&#x27;s all going to be a lot more expensive than just memsetting a bunch of data to zero, which you can do at whatever the speed of your cores memory bandwidth is.</div><br/><div id="40692986" class="c"><input type="checkbox" id="c-40692986" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40692676">parent</a><span>|</span><a href="#40692374">next</a><span>|</span><label class="collapse" for="c-40692986">[-]</label><label class="expand" for="c-40692986">[1 more]</label></div><br/><div class="children"><div class="content">Yep. And you often donât even need to zero the data.<p>Generally, no paper or SO answer will tell you where <i>your program</i> spends its time. Learn to use profiling tools, and experiment with stuff like this. Try out arenas. Benchmark before and after and see what kind of real performance difference it makes in your own program.</div><br/></div></div></div></div><div id="40692374" class="c"><input type="checkbox" id="c-40692374" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691118">parent</a><span>|</span><a href="#40692676">prev</a><span>|</span><a href="#40691824">next</a><span>|</span><label class="collapse" for="c-40692374">[-]</label><label class="expand" for="c-40692374">[1 more]</label></div><br/><div class="children"><div class="content">What are you looking for? Bump allocators are quite simple, compared to typical allocators at least.</div><br/></div></div></div></div></div></div></div></div><div id="40691824" class="c"><input type="checkbox" id="c-40691824" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40690532">prev</a><span>|</span><a href="#40690890">next</a><span>|</span><label class="collapse" for="c-40691824">[-]</label><label class="expand" for="c-40691824">[2 more]</label></div><br/><div class="children"><div class="content">If needed, you should zero memory on allocation succeeds, instead of zeroing it after it is freed.</div><br/><div id="40691960" class="c"><input type="checkbox" id="c-40691960" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#40690220">root</a><span>|</span><a href="#40691824">parent</a><span>|</span><a href="#40690890">next</a><span>|</span><label class="collapse" for="c-40691960">[-]</label><label class="expand" for="c-40691960">[1 more]</label></div><br/><div class="children"><div class="content">Generally, you 0 on free in secure environments to avoid leaking secrets from 1 section of knowledge to the next. ie a request may contain a password, which the next request should not have access to.</div><br/></div></div></div></div><div id="40690890" class="c"><input type="checkbox" id="c-40690890" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40691824">prev</a><span>|</span><a href="#40692367">next</a><span>|</span><label class="collapse" for="c-40690890">[-]</label><label class="expand" for="c-40690890">[1 more]</label></div><br/><div class="children"><div class="content">I once spent an utterly baffling afternoon trying to figure out why my benchmark for a reverse iteration across a rope data structure in Julia was finishing way too fast. I was perf tuning it, and while it would have been lovely if my implementation was actually 50 times faster than reverse iterating a native String type, I didn&#x27;t buy it.<p>Finally figured it out: I flipped a sign in the reverse iterator, so it was allocating a bunch of memory and immediately hitting the margin of the Vector, and returning it with most of the bytes undefined.  Why didn&#x27;t I catch it sooner? Well, I kept running the benchmark, which allocated a reverse buffer for the String version, which GC released, then I ran the buggy code... and the GC picked up the recently freed <i>correct data</i> and handed it back to me! Oops.<p>Of course, if you want to avoid that risk in <i>Zig</i>, you just write a ZeroOnFreeAllocator, which zeros out your memory when you free it. It&#x27;s a drop in replacement for anything which needs an allocator, job done.</div><br/></div></div><div id="40692367" class="c"><input type="checkbox" id="c-40692367" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40690890">prev</a><span>|</span><a href="#40690601">next</a><span>|</span><label class="collapse" for="c-40692367">[-]</label><label class="expand" for="c-40692367">[1 more]</label></div><br/><div class="children"><div class="content">Guard pages are not enough to prevent memory corruption across requests.</div><br/></div></div><div id="40690601" class="c"><input type="checkbox" id="c-40690601" checked=""/><div class="controls bullet"><span class="by">jedisct1</span><span>|</span><a href="#40690220">parent</a><span>|</span><a href="#40692367">prev</a><span>|</span><a href="#40689870">next</a><span>|</span><label class="collapse" for="c-40690601">[-]</label><label class="expand" for="c-40690601">[1 more]</label></div><br/><div class="children"><div class="content">Zig allocators can be composed, so adding zeroization would be trivial.</div><br/></div></div></div></div><div id="40689870" class="c"><input type="checkbox" id="c-40689870" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40690220">prev</a><span>|</span><a href="#40689934">next</a><span>|</span><label class="collapse" for="c-40689870">[-]</label><label class="expand" for="c-40689870">[2 more]</label></div><br/><div class="children"><div class="content">Is there a reason why someone wouldn&#x27;t use retain_with_limit or is doing without it just an exercise?</div><br/><div id="40690763" class="c"><input type="checkbox" id="c-40690763" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#40689870">parent</a><span>|</span><a href="#40689934">next</a><span>|</span><label class="collapse" for="c-40690763">[-]</label><label class="expand" for="c-40690763">[1 more]</label></div><br/><div class="children"><div class="content">The inspiration for the post came from my httpz library. The fallback using a FixedBufferAllocator + ArenaAllocator is used. The fixed buffer is a thread local. But the arena allocators belong to connections, of which there could be thousands.<p>You might have 1 fixed buffer, for N (500+) ArenaAllocators (but only being used per one at a time). This allows you to allocate a relatively large fixed buffer since you have relatively few threads.<p>If you just used retain_with_limit, then you&#x27;d either have to have a much smaller retained size, or you&#x27;d need a lot more memory.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;karlseguin&#x2F;http.zig&#x2F;blob&#x2F;c8b04e3fef5abf324c452f023e6b999c2ab85d6f&#x2F;src&#x2F;httpz.zig#L481">https:&#x2F;&#x2F;github.com&#x2F;karlseguin&#x2F;http.zig&#x2F;blob&#x2F;c8b04e3fef5abf32...</a></div><br/></div></div></div></div><div id="40689934" class="c"><input type="checkbox" id="c-40689934" checked=""/><div class="controls bullet"><span class="by">mikemitchelldev</span><span>|</span><a href="#40689870">prev</a><span>|</span><a href="#40692713">next</a><span>|</span><label class="collapse" for="c-40689934">[-]</label><label class="expand" for="c-40689934">[12 more]</label></div><br/><div class="children"><div class="content">Off topic but I wish Go had chosen to use fn rather than func</div><br/><div id="40692064" class="c"><input type="checkbox" id="c-40692064" checked=""/><div class="controls bullet"><span class="by">scns</span><span>|</span><a href="#40689934">parent</a><span>|</span><a href="#40691665">next</a><span>|</span><label class="collapse" for="c-40692064">[-]</label><label class="expand" for="c-40692064">[2 more]</label></div><br/><div class="children"><div class="content">I like the way Kotlin did it: fun. Gives a nice alignement of four with the space. And functional programming can be fun.</div><br/><div id="40693523" class="c"><input type="checkbox" id="c-40693523" checked=""/><div class="controls bullet"><span class="by">vram22</span><span>|</span><a href="#40689934">root</a><span>|</span><a href="#40692064">parent</a><span>|</span><a href="#40691665">next</a><span>|</span><label class="collapse" for="c-40693523">[-]</label><label class="expand" for="c-40693523">[1 more]</label></div><br/><div class="children"><div class="content">&gt;And functional programming can be fun.<p><i>can</i> is the operative word, not <i>is</i>. Thinking of that other word, the m-word, that sounds like nomad. ;)<p>&#x2F;jk</div><br/></div></div></div></div><div id="40691665" class="c"><input type="checkbox" id="c-40691665" checked=""/><div class="controls bullet"><span class="by">whobre</span><span>|</span><a href="#40689934">parent</a><span>|</span><a href="#40692064">prev</a><span>|</span><a href="#40690941">next</a><span>|</span><label class="collapse" for="c-40691665">[-]</label><label class="expand" for="c-40691665">[3 more]</label></div><br/><div class="children"><div class="content">Iâll never understand why people care about such things.</div><br/><div id="40691842" class="c"><input type="checkbox" id="c-40691842" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#40689934">root</a><span>|</span><a href="#40691665">parent</a><span>|</span><a href="#40692011">next</a><span>|</span><label class="collapse" for="c-40691842">[-]</label><label class="expand" for="c-40691842">[1 more]</label></div><br/><div class="children"><div class="content">Maybe someone think &quot;func&quot; listens like another word.</div><br/></div></div><div id="40692011" class="c"><input type="checkbox" id="c-40692011" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40689934">root</a><span>|</span><a href="#40691665">parent</a><span>|</span><a href="#40691842">prev</a><span>|</span><a href="#40690941">next</a><span>|</span><label class="collapse" for="c-40692011">[-]</label><label class="expand" for="c-40692011">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t understand personal preferences?  Or you don&#x27;t understand the desire to share them with your peers?  Or you can&#x27;t understand why people don&#x27;t just bully themselves into silence for the benefit of others?</div><br/></div></div></div></div><div id="40690941" class="c"><input type="checkbox" id="c-40690941" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40689934">parent</a><span>|</span><a href="#40691665">prev</a><span>|</span><a href="#40689999">next</a><span>|</span><label class="collapse" for="c-40690941">[-]</label><label class="expand" for="c-40690941">[1 more]</label></div><br/><div class="children"><div class="content">I happen to agree. When I see &#x27;fn&#x27; I &quot;hear&quot; function, when I see &#x27;func&#x27; I hear &quot;funk, but misspelled&quot;.<p>Also, with four space indentation (or for Go, a four space tabset), &#x27;func&#x27; aligns right where the code begins, pushing the function name off one space to the right.  For &#x27;fn&#x27; the function name starts one space before the code, I find this more aesthetic.  Then again, the standard tabset is eight spaces, so this matters less in Go.<p>It would be pretty silly to pick a language on the basis of that kind of superficial window dressing, of course.  But I know which one I prefer.</div><br/></div></div><div id="40689955" class="c"><input type="checkbox" id="c-40689955" checked=""/><div class="controls bullet"><span class="by">ziggy_star</span><span>|</span><a href="#40689934">parent</a><span>|</span><a href="#40689999">prev</a><span>|</span><a href="#40692713">next</a><span>|</span><label class="collapse" for="c-40689955">[-]</label><label class="expand" for="c-40689955">[4 more]</label></div><br/><div class="children"><div class="content">Oh hey, are you that Mitch?<p>I literally just signed up to ask if anybody can recommend any good Zig codebases to read other than Tigerbeatle. How&#x27;s your terminal going?<p>Edit: The rest of the posted site seems like a treasure trove not just this one article. Was wondering how to get into Zig and here we are. Such kismet.<p>Almost missed it so heads up for others.</div><br/><div id="40690153" class="c"><input type="checkbox" id="c-40690153" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#40689934">root</a><span>|</span><a href="#40689955">parent</a><span>|</span><a href="#40689967">next</a><span>|</span><label class="collapse" for="c-40690153">[-]</label><label class="expand" for="c-40690153">[2 more]</label></div><br/><div class="children"><div class="content">We&#x27;re working on a game engine in Zig[0]<p>If you&#x27;re looking for interesting Zig codebases to read, you might be interested in our low-level audio input&#x2F;output library[1] or our module system[2] codebase - the latter includes an entity component system and uses Zig&#x27;s comptime to a great degree to enable some interesting flexibility (dependency injection, global view of the world, etc.) while maintaining a great amount of type safety in an otherwise dynamic system.<p>[0] <a href="https:&#x2F;&#x2F;machengine.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;machengine.org&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;hexops&#x2F;mach&#x2F;tree&#x2F;main&#x2F;src&#x2F;sysaudio">https:&#x2F;&#x2F;github.com&#x2F;hexops&#x2F;mach&#x2F;tree&#x2F;main&#x2F;src&#x2F;sysaudio</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;hexops&#x2F;mach&#x2F;tree&#x2F;main&#x2F;src&#x2F;module">https:&#x2F;&#x2F;github.com&#x2F;hexops&#x2F;mach&#x2F;tree&#x2F;main&#x2F;src&#x2F;module</a></div><br/><div id="40690167" class="c"><input type="checkbox" id="c-40690167" checked=""/><div class="controls bullet"><span class="by">ziggy_star</span><span>|</span><a href="#40689934">root</a><span>|</span><a href="#40690153">parent</a><span>|</span><a href="#40689967">next</a><span>|</span><label class="collapse" for="c-40690167">[-]</label><label class="expand" for="c-40690167">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div><div id="40689967" class="c"><input type="checkbox" id="c-40689967" checked=""/><div class="controls bullet"><span class="by">mikemitchelldev</span><span>|</span><a href="#40689934">root</a><span>|</span><a href="#40689955">parent</a><span>|</span><a href="#40690153">prev</a><span>|</span><a href="#40692713">next</a><span>|</span><label class="collapse" for="c-40689967">[-]</label><label class="expand" for="c-40689967">[1 more]</label></div><br/><div class="children"><div class="content">No, sorry not me. Though I have signed up for an invite for that terminal by Mitchell Hashimoto (I think his name is).</div><br/></div></div></div></div></div></div><div id="40692713" class="c"><input type="checkbox" id="c-40692713" checked=""/><div class="controls bullet"><span class="by">sbussard</span><span>|</span><a href="#40689934">prev</a><span>|</span><a href="#40689794">next</a><span>|</span><label class="collapse" for="c-40692713">[-]</label><label class="expand" for="c-40692713">[2 more]</label></div><br/><div class="children"><div class="content">Has anyone here used zig with Bazel?</div><br/><div id="40693035" class="c"><input type="checkbox" id="c-40693035" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40692713">parent</a><span>|</span><a href="#40689794">next</a><span>|</span><label class="collapse" for="c-40693035">[-]</label><label class="expand" for="c-40693035">[1 more]</label></div><br/><div class="children"><div class="content">Not me, not yet, and it&#x27;s been a few years since I&#x27;ve used Blaze.<p>It ought to be fairly straightforward. Zig is an easy dependency to either vendor or install on a given system&#x2F;code-base (much more painful currently if you want Blaze to also build Zig itself), and at a bare minimum you could just add BUILD steps for each of the artifacts define in build.zig.<p>Things get more interesting if you want to take advantage of Zig&#x27;s caching, especially once incremental compilation is fully released. It&#x27;s a fast enough compilation step that perhaps you could totally ignore Zig&#x27;s caching for now and wait to see how that feature shapes up before making any hard decisions, but my spidey senses say that&#x27;ll be a nontrivial amount of work for _somebody_ to integrate those two ideas.</div><br/></div></div></div></div><div id="40689856" class="c"><input type="checkbox" id="c-40689856" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#40689794">prev</a><span>|</span><a href="#40691994">next</a><span>|</span><label class="collapse" for="c-40689856">[-]</label><label class="expand" for="c-40689856">[7 more]</label></div><br/><div class="children"><div class="content">I love the way Zig does allocators, when you compare it to Rust where allocation failures just panic (rolls eyes)</div><br/><div id="40691376" class="c"><input type="checkbox" id="c-40691376" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#40689856">parent</a><span>|</span><a href="#40691659">next</a><span>|</span><label class="collapse" for="c-40691376">[-]</label><label class="expand" for="c-40691376">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s getting there eventually! <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;boxed&#x2F;struct.Box.html#method.try_new" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;boxed&#x2F;struct.Box.html#method.t...</a></div><br/></div></div><div id="40691659" class="c"><input type="checkbox" id="c-40691659" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#40689856">parent</a><span>|</span><a href="#40691376">prev</a><span>|</span><a href="#40693506">next</a><span>|</span><label class="collapse" for="c-40691659">[-]</label><label class="expand" for="c-40691659">[2 more]</label></div><br/><div class="children"><div class="content">I agree, the lack of control is frustrating but on the contrary: how much software is actually going to do anything useful if allocation is failing? Designing your std library around the common case then gathering input on what memory fallible APIs should look like is smarter IMO.</div><br/><div id="40693095" class="c"><input type="checkbox" id="c-40693095" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40689856">root</a><span>|</span><a href="#40691659">parent</a><span>|</span><a href="#40693506">next</a><span>|</span><label class="collapse" for="c-40693095">[-]</label><label class="expand" for="c-40693095">[1 more]</label></div><br/><div class="children"><div class="content">Most problems have speed&#x2F;memory&#x2F;disk tradeoffs available. Simple coding strategies include &quot;if RAM then do the fast thing, else do the slightly slower thing&quot;, &quot;if RAM then allocate that way, else use mmap&quot;, &quot;if RAM then continue, else notify operator without throwing away all their work&quot;, ....<p>Rust was still probably right to not expose that at first since memory is supposed be fairly transparent, but Zig forces the user to care about memory, and given that constraint it&#x27;s nearly free to also inform them of problems. The stdlib is already designed (like in Rust) around allocations succeeding, since those errors are just passed to the caller, but Zig can immediately start collecting data about how people use those capabilities. At a language level, including visibility into allocation failures was IMO a good idea.</div><br/></div></div></div></div><div id="40693506" class="c"><input type="checkbox" id="c-40693506" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40689856">parent</a><span>|</span><a href="#40691659">prev</a><span>|</span><a href="#40692725">next</a><span>|</span><label class="collapse" for="c-40693506">[-]</label><label class="expand" for="c-40693506">[1 more]</label></div><br/><div class="children"><div class="content">Stack overflow, which is a type of allocation failure, still aborts in Zig, so it&#x27;s not that simple.</div><br/></div></div><div id="40692725" class="c"><input type="checkbox" id="c-40692725" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40689856">parent</a><span>|</span><a href="#40693506">prev</a><span>|</span><a href="#40689860">next</a><span>|</span><label class="collapse" for="c-40692725">[-]</label><label class="expand" for="c-40692725">[1 more]</label></div><br/><div class="children"><div class="content">The Rust standard library aborts on allocation failure using the basic APIs, but Rust itself doesn&#x27;t allocate. If someone wanted to write a Zig-style library in Rust, it would work just fine.</div><br/></div></div></div></div><div id="40690770" class="c"><input type="checkbox" id="c-40690770" checked=""/><div class="controls bullet"><span class="by">ctxcode</span><span>|</span><a href="#40691994">prev</a><span>|</span><label class="collapse" for="c-40690770">[-]</label><label class="expand" for="c-40690770">[10 more]</label></div><br/><div class="children"><div class="content">These kind of tactics work for simple examples. In real world http servers you&#x27;ll retain memory across requests (caches) and you&#x27;ll need a way to handle blocking io. That&#x27;s why most commonly we use GC&#x27;d&#x2F;ownership languages for this + things like goroutines&#x2F;tokio&#x2F;etc.. web devs dont want to deal with memory themselfs.</div><br/><div id="40690797" class="c"><input type="checkbox" id="c-40690797" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40690770">parent</a><span>|</span><a href="#40690814">next</a><span>|</span><label class="collapse" for="c-40690797">[-]</label><label class="expand" for="c-40690797">[5 more]</label></div><br/><div class="children"><div class="content">Off the top of my head, I was wondering... for software like web services, isn&#x27;t it easier and faster to use a bump allocator per request, and release the whole block at the end of it? Assuming the number of concurrent requests&#x2F;memory usage is known and you don&#x27;t expect any massive spike.<p>I am working on an actor language kernel, and was thinking of adopting the same strategy, i.e. using a very naive bump allocator per actor, with the idea that many actors die pretty quickly so you don&#x27;t have to pay for the cost of GC most of the time. You can run the GC after a certain threshold of memory usage.</div><br/><div id="40693145" class="c"><input type="checkbox" id="c-40693145" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40690770">root</a><span>|</span><a href="#40690797">parent</a><span>|</span><a href="#40691716">next</a><span>|</span><label class="collapse" for="c-40693145">[-]</label><label class="expand" for="c-40693145">[1 more]</label></div><br/><div class="children"><div class="content">The problem _somebody_ between the hardware and your webapp has to deal with is fragmentation, and it&#x27;s especially annoying with requests which don&#x27;t evenly consume RAM. Your OS can map pages around that problem, but it&#x27;s cheaper to have a contiguous right-sized allocation which you never re-initialize.<p>Assuming the number of concurrent requests is known and they have bounded memory usage (the latter is application-dependant, the former can be emulated by 503-erroring excess requests, or something trickier if clients handle that poorly), yeah, just splay a bunch of bump allocators evenly throughout RAM, and don&#x27;t worry about the details. It&#x27;s not much faster though. The steady state for reset-arenas is that they&#x27;re all right-sized contiguous bump allocators. Using that strategy, arenas are a negligible contribution to the costs of a 200k QPS&#x2F;core service.</div><br/></div></div><div id="40691716" class="c"><input type="checkbox" id="c-40691716" checked=""/><div class="controls bullet"><span class="by">ctxcode</span><span>|</span><a href="#40690770">root</a><span>|</span><a href="#40690797">parent</a><span>|</span><a href="#40693145">prev</a><span>|</span><a href="#40690861">next</a><span>|</span><label class="collapse" for="c-40691716">[-]</label><label class="expand" for="c-40691716">[2 more]</label></div><br/><div class="children"><div class="content">If you never cache any data. Sure, u can use a bump allocator. Otherwise it gets tricky. I havent worked with actors really, but from the looks of it, it seems like they would create alot of bottlenecks compared to coroutines. And it would probably throw all your bump allocator performance benefits out the window. As for the GC thing. You cant &#x27;just&#x27; call a GC.. Either you use a bump allocator or you use a GC. Your GC cant steal objects from your bump allocator. It can copy it... but then the reference changes and that&#x27;s a big problem.</div><br/><div id="40692871" class="c"><input type="checkbox" id="c-40692871" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40690770">root</a><span>|</span><a href="#40691716">parent</a><span>|</span><a href="#40690861">next</a><span>|</span><label class="collapse" for="c-40692871">[-]</label><label class="expand" for="c-40692871">[1 more]</label></div><br/><div class="children"><div class="content">I think this comment assumes that you&#x27;re using one allocator, but it&#x27;s probably normal in Zig to use one allocator for your caches, and another allocator for your per-request state, with one instance of the latter sort of allocator for each execution context that handles requests (probably coroutines). So you can just have both, and the stuff that can go in the bump allocator does, and concurrent requests don&#x27;t step on each others toes.</div><br/></div></div></div></div><div id="40690861" class="c"><input type="checkbox" id="c-40690861" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40690770">root</a><span>|</span><a href="#40690797">parent</a><span>|</span><a href="#40691716">prev</a><span>|</span><a href="#40690814">next</a><span>|</span><label class="collapse" for="c-40690861">[-]</label><label class="expand" for="c-40690861">[1 more]</label></div><br/><div class="children"><div class="content">Have you looked at how Erlang does memory management within its processes? You definitely can &quot;get away&quot; with a lot of things when you have actors you can reasonably expect will be small scale, if you are absolutely sure their data dies with them.</div><br/></div></div></div></div><div id="40690814" class="c"><input type="checkbox" id="c-40690814" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#40690770">parent</a><span>|</span><a href="#40690797">prev</a><span>|</span><a href="#40690885">next</a><span>|</span><label class="collapse" for="c-40690814">[-]</label><label class="expand" for="c-40690814">[1 more]</label></div><br/><div class="children"><div class="content">This example came from a real world http server. Admittedly, Zig&#x27;s &quot;web dev&quot; community is small, but we&#x27;re trying :) I&#x27;m sure a lot could be improved in httpz, but it&#x27;s filling a gap.</div><br/></div></div><div id="40690885" class="c"><input type="checkbox" id="c-40690885" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40690770">parent</a><span>|</span><a href="#40690814">prev</a><span>|</span><a href="#40690870">next</a><span>|</span><label class="collapse" for="c-40690885">[-]</label><label class="expand" for="c-40690885">[1 more]</label></div><br/><div class="children"><div class="content">You can use these patterns for per-request resources that persist across some I&#x2F;O calls using async if you are on an old version of Zig or using zigcoro while you wait for the feature to return to the language. zigcoro&#x27;s API is designed to make the eventual transition back to language-level async easy.</div><br/></div></div><div id="40690870" class="c"><input type="checkbox" id="c-40690870" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40690770">parent</a><span>|</span><a href="#40690885">prev</a><span>|</span><a href="#40690840">next</a><span>|</span><label class="collapse" for="c-40690870">[-]</label><label class="expand" for="c-40690870">[1 more]</label></div><br/><div class="children"><div class="content">Yes, we were creating Apache and IIS plugins 25 years ago for PHP, Perl, Tcl, Coldfusion, ASP (scripting COM in VB), or C++ frameworks like ATLServer.<p>Very few were dealing with raw memory management in C, without anything else.<p>And all of this evolved into the Web application servers, and distributed computing landscape of modern times.</div><br/></div></div><div id="40690840" class="c"><input type="checkbox" id="c-40690840" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40690770">parent</a><span>|</span><a href="#40690870">prev</a><span>|</span><label class="collapse" for="c-40690840">[-]</label><label class="expand" for="c-40690840">[1 more]</label></div><br/><div class="children"><div class="content">It scales to complex examples as well. Retained memory would be handled with its own allocator: for a large data structure like an LRU cache, one would initialize it with a pointer to the allocator, and use that internally to manage the memory.<p>Blocking (or rather, non-blocking, which is clearly what you meant) IO is a different story. Zig had an async system, but it had problems and got removed a couple point releases ago.  There&#x27;s libxev[0] for evented programs, from Mitchell Hashimoto. It&#x27;s not mature yet but it offers a good solution to single-threaded concurrency and non-blocking IO.<p>I don&#x27;t think Zig is the best choice for multithreaded programs, however, unless they&#x27;re carefully engineered to share little to no memory (using message passing, for instance).  You&#x27;d have to take care of locking and atomic ops manually, and unlike memory bugs, Zig doesn&#x27;t have a lot of built-in support for catching problems with that.<p>A language with manual memory allocation isn&#x27;t going to be the language of choice for writing web servers, for pretty obvious reasons. But for an application like squeezing the best performance out of a resource-constrained environment, the tradeoffs start to make sense.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;mitchellh&#x2F;libxev">https:&#x2F;&#x2F;github.com&#x2F;mitchellh&#x2F;libxev</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>