<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683190851271" as="style"/><link rel="stylesheet" href="styles.css?v=1683190851271"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tomscii.sig7.se/2021/01/Typing-latency-of-Zutty">Measured: Typing latency of Zutty compared to other terminal emulators (2021)</a> <span class="domain">(<a href="https://tomscii.sig7.se">tomscii.sig7.se</a>)</span></div><div class="subtext"><span>klaussilveira</span> | <span>58 comments</span></div><br/><div><div id="35808951" class="c"><input type="checkbox" id="c-35808951" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#35809206">next</a><span>|</span><label class="collapse" for="c-35808951">[-]</label><label class="expand" for="c-35808951">[13 more]</label></div><br/><div class="children"><div class="content">Summary:<p>1) Extremely fast GPU-accelerated terminals have a latency of slightly more than one frame due to only rendering once per frame (for performance and latency reasons).<p>2) Gnome-terminal sucks.<p>3) Old school terminals, like xterm, are extremely slow in practice, but look very fast on benchmarks like this, as they render on TTY input and do not wait (thus wasting time and latency rendering unseen changes).<p>4) This article is old, and misses out a lot of optimization work that has occurred on Alacritty.<p>5) The author of this article has a 60hz monitor. These numbers would be unreproducable on higher refresh monitors.</div><br/><div id="35809426" class="c"><input type="checkbox" id="c-35809426" checked=""/><div class="controls bullet"><span class="by">jyxent</span><span>|</span><a href="#35808951">parent</a><span>|</span><a href="#35811247">next</a><span>|</span><label class="collapse" for="c-35809426">[-]</label><label class="expand" for="c-35809426">[3 more]</label></div><br/><div class="children"><div class="content">A more recent test from last year still has not great latency numbers for Alacritty: <a href="https:&#x2F;&#x2F;www.lkhrs.com&#x2F;blog&#x2F;2022&#x2F;07&#x2F;terminal-latency&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.lkhrs.com&#x2F;blog&#x2F;2022&#x2F;07&#x2F;terminal-latency&#x2F;</a></div><br/><div id="35809585" class="c"><input type="checkbox" id="c-35809585" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#35808951">root</a><span>|</span><a href="#35809426">parent</a><span>|</span><a href="#35811247">next</a><span>|</span><label class="collapse" for="c-35809585">[-]</label><label class="expand" for="c-35809585">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, unfortunately he tested on OSX; notice <i>all</i> his numbers are bad, an unfortunate side effect of Apple unwilling (or unable) to focus on performance as a way to improve user experience and finally fix the compositor lag that&#x27;s been there since the dawn of OSX.</div><br/><div id="35809762" class="c"><input type="checkbox" id="c-35809762" checked=""/><div class="controls bullet"><span class="by">canttestthis</span><span>|</span><a href="#35808951">root</a><span>|</span><a href="#35809585">parent</a><span>|</span><a href="#35811247">next</a><span>|</span><label class="collapse" for="c-35809762">[-]</label><label class="expand" for="c-35809762">[1 more]</label></div><br/><div class="children"><div class="content">But relatively speaking the conclusions remain the same, with kitty being one of the fastest.</div><br/></div></div></div></div></div></div><div id="35811247" class="c"><input type="checkbox" id="c-35811247" checked=""/><div class="controls bullet"><span class="by">runnerup</span><span>|</span><a href="#35808951">parent</a><span>|</span><a href="#35809426">prev</a><span>|</span><a href="#35809077">next</a><span>|</span><label class="collapse" for="c-35811247">[-]</label><label class="expand" for="c-35811247">[3 more]</label></div><br/><div class="children"><div class="content">Can you expand on (3)? It seems at first glance that the end-to-end testing (USB input through to monitor photon output) performed in this test captures the whole of the user&#x27;s perception and experience.</div><br/><div id="35811733" class="c"><input type="checkbox" id="c-35811733" checked=""/><div class="controls bullet"><span class="by">amoss</span><span>|</span><a href="#35808951">root</a><span>|</span><a href="#35811247">parent</a><span>|</span><a href="#35811540">next</a><span>|</span><label class="collapse" for="c-35811733">[-]</label><label class="expand" for="c-35811733">[1 more]</label></div><br/><div class="children"><div class="content">Latency and throughput are not inverses, although they may exhibit anti-correlation over small ranges. A low latency does not imply high throughput. In particular xterm does not buffer input &#x2F; rendering, so while individual keystrokes produce a response quickly, when there is a high volume of text the throughput will be lower than other approaches.<p>This will still feel laggy, just a different kind of lag to the one that you perceive using a high latency terminal.</div><br/></div></div><div id="35811540" class="c"><input type="checkbox" id="c-35811540" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35808951">root</a><span>|</span><a href="#35811247">parent</a><span>|</span><a href="#35811733">prev</a><span>|</span><a href="#35809077">next</a><span>|</span><label class="collapse" for="c-35811540">[-]</label><label class="expand" for="c-35811540">[1 more]</label></div><br/><div class="children"><div class="content">you definitely will not get 3ms latency by measuring usb input through to monitor photon output on a 60hz or 120hz monitor, not even in xterm<p>i think you did not understand the article</div><br/></div></div></div></div><div id="35809077" class="c"><input type="checkbox" id="c-35809077" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#35808951">parent</a><span>|</span><a href="#35811247">prev</a><span>|</span><a href="#35809112">next</a><span>|</span><label class="collapse" for="c-35809077">[-]</label><label class="expand" for="c-35809077">[3 more]</label></div><br/><div class="children"><div class="content">For 1), aren’t there two gpu-based terminal emulators on that list with under 16ms latency on a 60Hz display. I think that should mean less than one frame but I don’t really understand the lack of variance in the measurements. I think if reported latencies are very low, the software methodology doesn’t work so well.<p>Am I missing something?</div><br/><div id="35809611" class="c"><input type="checkbox" id="c-35809611" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#35808951">root</a><span>|</span><a href="#35809077">parent</a><span>|</span><a href="#35811547">next</a><span>|</span><label class="collapse" for="c-35809611">[-]</label><label class="expand" for="c-35809611">[1 more]</label></div><br/><div class="children"><div class="content">The only other GPU accelerated one I see is Kitty. Current Alacritty numbers are closer to Kitty than rxvt.<p>Kitty statically renders at 100hz, thus skews numbers a bit; however, this also proves all this guy measured was &quot;time to next frame&quot;, not actual performance numbers.</div><br/></div></div><div id="35811547" class="c"><input type="checkbox" id="c-35811547" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35808951">root</a><span>|</span><a href="#35809077">parent</a><span>|</span><a href="#35809611">prev</a><span>|</span><a href="#35809112">next</a><span>|</span><label class="collapse" for="c-35811547">[-]</label><label class="expand" for="c-35811547">[1 more]</label></div><br/><div class="children"><div class="content">in the ideal case where every keystroke shows up in the next frame you should get an average of 8.3ms on a 60hz display, with a range from 0 (i did say this was ideal) to 16.7ms</div><br/></div></div></div></div><div id="35809112" class="c"><input type="checkbox" id="c-35809112" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#35808951">parent</a><span>|</span><a href="#35809077">prev</a><span>|</span><a href="#35809691">next</a><span>|</span><label class="collapse" for="c-35809112">[-]</label><label class="expand" for="c-35809112">[2 more]</label></div><br/><div class="children"><div class="content">Related to #1, has anyone tried rendering right before the compositor? That should allow sub-frame latency.</div><br/><div id="35809657" class="c"><input type="checkbox" id="c-35809657" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#35808951">root</a><span>|</span><a href="#35809112">parent</a><span>|</span><a href="#35809691">next</a><span>|</span><label class="collapse" for="c-35809657">[-]</label><label class="expand" for="c-35809657">[1 more]</label></div><br/><div class="children"><div class="content">Alacritty is adding scheduled frames, a technique used by modern game engines to reduce frame variance and latency, hopefully in time for 0.13.<p>To get any better, you&#x27;d really want something like windowed VRR to consistently work on your target OS, and then any issues in Alacritty solved (if any) to take advantage of that.</div><br/></div></div></div></div><div id="35809691" class="c"><input type="checkbox" id="c-35809691" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#35808951">parent</a><span>|</span><a href="#35809112">prev</a><span>|</span><a href="#35809206">next</a><span>|</span><label class="collapse" for="c-35809691">[-]</label><label class="expand" for="c-35809691">[1 more]</label></div><br/><div class="children"><div class="content">Given the vast majority of the market has been and continues to be 60hz, their testing on a 60hz monitor isn&#x27;t just understandable, it&#x27;s highly relevant.<p>If a terminal program running on current low-end PC hardware can&#x27;t handle updating&#x2F;drawing within 1&#x2F;60th of a second, something is very wrong.</div><br/></div></div></div></div><div id="35809206" class="c"><input type="checkbox" id="c-35809206" checked=""/><div class="controls bullet"><span class="by">Tharre</span><span>|</span><a href="#35808951">prev</a><span>|</span><a href="#35808126">next</a><span>|</span><label class="collapse" for="c-35809206">[-]</label><label class="expand" for="c-35809206">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This program measures end-to-end latency: it emits keypress events and captures the screen to note when it gets updated (as actually visible to the user)<p>&gt; [...]<p>&gt; The screen resolution was 1920x1080 and the LCD refresh rate 60 Hz<p>How exactly can xterm have an average end-to-end latency of 2ms, if on average you need to wait 8ms for the next frame?</div><br/><div id="35809676" class="c"><input type="checkbox" id="c-35809676" checked=""/><div class="controls bullet"><span class="by">codnee</span><span>|</span><a href="#35809206">parent</a><span>|</span><a href="#35808126">next</a><span>|</span><label class="collapse" for="c-35809676">[-]</label><label class="expand" for="c-35809676">[2 more]</label></div><br/><div class="children"><div class="content">By sending all key-press events an average of 2ms before the next frame is rendered</div><br/><div id="35812039" class="c"><input type="checkbox" id="c-35812039" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#35809206">root</a><span>|</span><a href="#35809676">parent</a><span>|</span><a href="#35808126">next</a><span>|</span><label class="collapse" for="c-35812039">[-]</label><label class="expand" for="c-35812039">[1 more]</label></div><br/><div class="children"><div class="content">But the next frame takes a while to actually show up on the screen, so the &quot;as actually visible to the user&quot; part simply can&#x27;t be right. This may be isolated latency of just the program, but definitely not something reflecting real-world user experience, it&#x27;s 1-2 orders of magnitude off in that regard.</div><br/></div></div></div></div></div></div><div id="35808126" class="c"><input type="checkbox" id="c-35808126" checked=""/><div class="controls bullet"><span class="by">smlavine</span><span>|</span><a href="#35809206">prev</a><span>|</span><a href="#35808660">next</a><span>|</span><label class="collapse" for="c-35808126">[-]</label><label class="expand" for="c-35808126">[14 more]</label></div><br/><div class="children"><div class="content">I use st daily. Having it open side by side with xterm (and also, by the way, typing out this comment in Firefox), I don&#x27;t see how the differences mentioned in the article are relevant to the user experience. The character appears before my finger lifts from the key. Perhaps improvement &#x2F;could&#x2F; be made, but I don&#x27;t think it&#x27;d be worth it. There are other things to prioritize.<p>It is interesting to see the numbers laid out like this, though.</div><br/><div id="35810349" class="c"><input type="checkbox" id="c-35810349" checked=""/><div class="controls bullet"><span class="by">syntheweave</span><span>|</span><a href="#35808126">parent</a><span>|</span><a href="#35808315">next</a><span>|</span><label class="collapse" for="c-35810349">[-]</label><label class="expand" for="c-35810349">[4 more]</label></div><br/><div class="children"><div class="content">Latency becomes more relevant the less you are able to muscle-memory your way through an input. Audio apps often need relatively short latencies(&lt;5ms is considered professionally useful) because musicians are hearing, responding and adjusting to match time, so when they do something and the delay on output is perceptible, their timing starts to oscillate.<p>On the other hand, if I&#x27;m drawing on a graphics tablet, and I&#x27;ve trained up some muscle memory skills with blind contour exercises, I don&#x27;t care that much about application latency because I&#x27;m using the tactile feedback to know what the pen is doing. I only have to look to see where the cursor starts, everything else is minor adjustment.<p>Keyboarding is also definitely more on the muscle-memory end of the spectrum: you look to see errors, but you can generally type a whole password without seeing it, once you&#x27;ve practiced.</div><br/><div id="35811173" class="c"><input type="checkbox" id="c-35811173" checked=""/><div class="controls bullet"><span class="by">jlarocco</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35810349">parent</a><span>|</span><a href="#35808315">next</a><span>|</span><label class="collapse" for="c-35811173">[-]</label><label class="expand" for="c-35811173">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but the article isn&#x27;t about audio apps or drawing with a graphics tablet; it&#x27;s about typing delay in terminal emulators.<p>I have to agree with the OP here.  I&#x27;ve used urxvt almost every day for years (I remember using it on a laptop with 32 MB of memory), and have never once had a problem with typing latency.  I didn&#x27;t even realize it was a thing people bothered to measure until I saw this article.</div><br/><div id="35811563" class="c"><input type="checkbox" id="c-35811563" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35811173">parent</a><span>|</span><a href="#35808315">next</a><span>|</span><label class="collapse" for="c-35811563">[-]</label><label class="expand" for="c-35811563">[2 more]</label></div><br/><div class="children"><div class="content">there&#x27;s always someone in these threads who says something like this, and to be honest <a href="https:&#x2F;&#x2F;danluu.com&#x2F;keyboard-latency&#x2F;#does-keyboard-latency-matter" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;keyboard-latency&#x2F;#does-keyboard-latency-m...</a> could benefit from a stronger argument that latency impedes performance or pleasure specifically for keyboard tasks rather than touchscreen or stylus tasks</div><br/><div id="35812619" class="c"><input type="checkbox" id="c-35812619" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35811563">parent</a><span>|</span><a href="#35808315">next</a><span>|</span><label class="collapse" for="c-35812619">[-]</label><label class="expand" for="c-35812619">[1 more]</label></div><br/><div class="children"><div class="content">I can only offer anecdote and no concrete measurements. But I&#x27;ve used bad terminal emulators and good ones, and I can really notice the difference. When the letters appear even a few frames after they should, there&#x27;s a definite (if mild) feeling of discomfort. Like some kind of sensory-motor &quot;friction&quot;. I can still get work done, but I&#x27;m just a little less happy.<p>There was another HN thread recently where this topic came up, I posted about the human nervous system as a prediction-feedback system where we should expect even small latencies to have a bad effect. And someone replied with the interesting insight that 10-100ms latency feels like &quot;you are using the tool&quot;, while &lt;10ms latency feels like &quot;the tool is an extension of your body&quot;. (I&#x27;d quote the whole thing but I think there&#x27;s an HN rule against that.)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35055607" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35055607</a><p>I&#x27;d certainly like to see an experiment where typing latency could be controlled artificially, on a high refresh rate monitor. It would test what level of latency&#x2F;jitter has a perceptible effect on objective typing error rates, and subjective ratings of &quot;satisfaction&quot;. Ask them to compare two text input fields where one has more latency than the other, see what degrees of difference are noticeable, to determine the &quot;resolution&quot; of time perception for fine motor tasks. I would wager that for good typists the &quot;threshold of perceptibility&quot; is as low as 10ms, and perhaps even lower. But that&#x27;s based on my own intuition and experience; I&#x27;d love to know for sure.</div><br/></div></div></div></div></div></div></div></div><div id="35808315" class="c"><input type="checkbox" id="c-35808315" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#35808126">parent</a><span>|</span><a href="#35810349">prev</a><span>|</span><a href="#35808660">next</a><span>|</span><label class="collapse" for="c-35808315">[-]</label><label class="expand" for="c-35808315">[9 more]</label></div><br/><div class="children"><div class="content">I wonder if your keyboard latency dominates?<p>In older games like CS 1.6 I believe I could feel the difference between say 10 and 40 ms ping. Maybe PS&#x2F;2 keyboards were faster. I got the feeling older computers were way faster to respond ... but I might remember wrong.</div><br/><div id="35808568" class="c"><input type="checkbox" id="c-35808568" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35808315">parent</a><span>|</span><a href="#35808594">next</a><span>|</span><label class="collapse" for="c-35808568">[-]</label><label class="expand" for="c-35808568">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I got the feeling older computers were way faster to respond ... but I might remember wrong<p>I don&#x27;t know the specific devices you&#x27;ve been using over time, but in general the measurements in the following article back up your memory: <a href="https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;</a></div><br/></div></div><div id="35808594" class="c"><input type="checkbox" id="c-35808594" checked=""/><div class="controls bullet"><span class="by">lasr_velocirptr</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35808315">parent</a><span>|</span><a href="#35808568">prev</a><span>|</span><a href="#35808581">next</a><span>|</span><label class="collapse" for="c-35808594">[-]</label><label class="expand" for="c-35808594">[2 more]</label></div><br/><div class="children"><div class="content">PS&#x2F;2 Keyboards are faster than a USB keyboard with slow-speed negotiation with the host computer but for USB keyboards with high speed negotiation, they are at par[1]<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wdgULBpRoXk&amp;t=1766s">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wdgULBpRoXk&amp;t=1766s</a></div><br/><div id="35811200" class="c"><input type="checkbox" id="c-35811200" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35808594">parent</a><span>|</span><a href="#35808581">next</a><span>|</span><label class="collapse" for="c-35811200">[-]</label><label class="expand" for="c-35811200">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the theory. At &quot;full bandwidth&quot;, with frequent polling, in theory, it should be possible to have excellent latency.<p>In practice, if you actually measure time from keypress to event, you&#x27;ll find that modern &quot;gaming&quot; keyboards are actually laggy[0].<p>0. <a href="https:&#x2F;&#x2F;danluu.com&#x2F;keyboard-latency&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;keyboard-latency&#x2F;</a></div><br/></div></div></div></div><div id="35808581" class="c"><input type="checkbox" id="c-35808581" checked=""/><div class="controls bullet"><span class="by">mprovost</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35808315">parent</a><span>|</span><a href="#35808594">prev</a><span>|</span><a href="#35808855">next</a><span>|</span><label class="collapse" for="c-35808581">[-]</label><label class="expand" for="c-35808581">[4 more]</label></div><br/><div class="children"><div class="content">You remember... right. The Apple 2e blows away modern computers (in terms of latency).<p><a href="https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;</a></div><br/><div id="35809254" class="c"><input type="checkbox" id="c-35809254" checked=""/><div class="controls bullet"><span class="by">Mr_Minderbinder</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35808581">parent</a><span>|</span><a href="#35808855">next</a><span>|</span><label class="collapse" for="c-35809254">[-]</label><label class="expand" for="c-35809254">[3 more]</label></div><br/><div class="children"><div class="content">Pointless to compare those toy computers against cherry-picked modern desktop which is the equivalent of an old supercomputer. Indeed if you look at the numbers for the older workstations: SGI Indy, NeXTcube, Symbolics 3620 they are not that different and even worse than the newer machines. 30ms is not remarkable these days, with proper gaming keyboard, gaming monitor, config etc. you can get 5ms or less for the whole chain.</div><br/><div id="35811639" class="c"><input type="checkbox" id="c-35811639" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35809254">parent</a><span>|</span><a href="#35811081">next</a><span>|</span><label class="collapse" for="c-35811639">[-]</label><label class="expand" for="c-35811639">[1 more]</label></div><br/><div class="children"><div class="content">old supercomputers also sucked at latency too, and the modern desktop isn&#x27;t cherry-picked<p>it&#x27;s common for computers with less latency to also have less throughput; an arduino, the avr kind, can reliably respond to inputs in less than 200 nanoseconds<p>but these &#x27;toy&#x27; computers are capable of running a word processor or spreadsheet, writing email, browsing the web (without js), compiling c, running an ide, etc.  the zx spectrum even had a first-person 3-d shoot-em-up called elite.  so i don&#x27;t think it&#x27;s pointless</div><br/></div></div><div id="35811081" class="c"><input type="checkbox" id="c-35811081" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35809254">parent</a><span>|</span><a href="#35811639">prev</a><span>|</span><a href="#35808855">next</a><span>|</span><label class="collapse" for="c-35811081">[-]</label><label class="expand" for="c-35811081">[1 more]</label></div><br/><div class="children"><div class="content">Unless you can produce actual measurements following the same methodology, for these mythical &quot;non-cherrypicked&quot; modern machines, I am going to call bullshit here.</div><br/></div></div></div></div></div></div><div id="35808855" class="c"><input type="checkbox" id="c-35808855" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#35808126">root</a><span>|</span><a href="#35808315">parent</a><span>|</span><a href="#35808581">prev</a><span>|</span><a href="#35808660">next</a><span>|</span><label class="collapse" for="c-35808855">[-]</label><label class="expand" for="c-35808855">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more about consistency. If delay is consistent, you get used to it, but if it&#x27;s all over the place it&#x27;s more noticeable.<p>I prefer to cap FPS in games for the same reason, if my PC can&#x27;t deliver consistent frame rate.</div><br/></div></div></div></div></div></div><div id="35808660" class="c"><input type="checkbox" id="c-35808660" checked=""/><div class="controls bullet"><span class="by">philjohn</span><span>|</span><a href="#35808126">prev</a><span>|</span><a href="#35811230">next</a><span>|</span><label class="collapse" for="c-35808660">[-]</label><label class="expand" for="c-35808660">[2 more]</label></div><br/><div class="children"><div class="content">Would be great to see Wezterm, it&#x27;s always felt snappy, and Wez is a damn smart cookie.</div><br/><div id="35809897" class="c"><input type="checkbox" id="c-35809897" checked=""/><div class="controls bullet"><span class="by">alwillis</span><span>|</span><a href="#35808660">parent</a><span>|</span><a href="#35811230">next</a><span>|</span><label class="collapse" for="c-35809897">[-]</label><label class="expand" for="c-35809897">[1 more]</label></div><br/><div class="children"><div class="content">+1 for WezTerm.</div><br/></div></div></div></div><div id="35811230" class="c"><input type="checkbox" id="c-35811230" checked=""/><div class="controls bullet"><span class="by">esjeon</span><span>|</span><a href="#35808660">prev</a><span>|</span><a href="#35808319">next</a><span>|</span><label class="collapse" for="c-35811230">[-]</label><label class="expand" for="c-35811230">[1 more]</label></div><br/><div class="children"><div class="content">In case of st, it actually delays the rendering. Its default config says min-latency is 8ms, and max-latency is 33ms. This probably is why OP got 20ms as an average value.<p>The thing is that suckless people simply want to render less, and they have always kept a way to delay rendering in st. Also, the current latency is good enough that no one really complains. TBH, it&#x27;s about 1~2 frame latency on 60 fps displays, and you hardly notice the difference.</div><br/></div></div><div id="35808319" class="c"><input type="checkbox" id="c-35808319" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#35811230">prev</a><span>|</span><a href="#35810256">next</a><span>|</span><label class="collapse" for="c-35808319">[-]</label><label class="expand" for="c-35808319">[3 more]</label></div><br/><div class="children"><div class="content">&gt; xterm does direct rendering via Xlib, which is the primary reason it can be so fast in responding to user input. This is also the reason why its throughput is, on the other hand, rather poor.<p>What&#x27;s throughput in this case?</div><br/><div id="35808349" class="c"><input type="checkbox" id="c-35808349" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#35808319">parent</a><span>|</span><a href="#35810256">next</a><span>|</span><label class="collapse" for="c-35808349">[-]</label><label class="expand" for="c-35808349">[2 more]</label></div><br/><div class="children"><div class="content">My guess is the rate at which stdout from a process shows up in the terminal?<p>I think Terminal.app on macOS is likely the inverse of this… it likely has a fair amount of input lag, but holy moly can it handle a lot of output being dumped at once without breaking a sweat.</div><br/><div id="35808711" class="c"><input type="checkbox" id="c-35808711" checked=""/><div class="controls bullet"><span class="by">adamwk</span><span>|</span><a href="#35808319">root</a><span>|</span><a href="#35808349">parent</a><span>|</span><a href="#35810256">next</a><span>|</span><label class="collapse" for="c-35808711">[-]</label><label class="expand" for="c-35808711">[1 more]</label></div><br/><div class="children"><div class="content">I thought terminal.app has very short latency, looking back at the benchmarks written about here <a href="https:&#x2F;&#x2F;danluu.com&#x2F;term-latency&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;term-latency&#x2F;</a>. Terminal.app’s latency measures around 5ms beating most other terminals. (It’s a shame it still doesn’t support true color.)</div><br/></div></div></div></div></div></div><div id="35810256" class="c"><input type="checkbox" id="c-35810256" checked=""/><div class="controls bullet"><span class="by">platzhirsch</span><span>|</span><a href="#35808319">prev</a><span>|</span><a href="#35809113">next</a><span>|</span><label class="collapse" for="c-35810256">[-]</label><label class="expand" for="c-35810256">[1 more]</label></div><br/><div class="children"><div class="content">Curious how foot compares.</div><br/></div></div><div id="35809113" class="c"><input type="checkbox" id="c-35809113" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#35810256">prev</a><span>|</span><a href="#35808651">next</a><span>|</span><label class="collapse" for="c-35809113">[-]</label><label class="expand" for="c-35809113">[1 more]</label></div><br/><div class="children"><div class="content">Zutty is pretty cool, although lack of bidi text rendering is very unfortunate.  I also wonder how Konsole would fare in these tests, it seems fairly snappy.</div><br/></div></div><div id="35808651" class="c"><input type="checkbox" id="c-35808651" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#35809113">prev</a><span>|</span><a href="#35808414">next</a><span>|</span><label class="collapse" for="c-35808651">[-]</label><label class="expand" for="c-35808651">[7 more]</label></div><br/><div class="children"><div class="content">Software latency measurement consistently understates latency which magnifies 1-2 frame differences. Unfortunately, camera-based measurement is a lot more work.</div><br/><div id="35808737" class="c"><input type="checkbox" id="c-35808737" checked=""/><div class="controls bullet"><span class="by">snazz</span><span>|</span><a href="#35808651">parent</a><span>|</span><a href="#35809172">next</a><span>|</span><label class="collapse" for="c-35808737">[-]</label><label class="expand" for="c-35808737">[5 more]</label></div><br/><div class="children"><div class="content">There’s an iPhone app called Is It Snappy that records in slow motion and makes it pretty easy. I think the camera maxes out at 240 fps so it’s not perfect but it lets you measure true end-to-end latency.</div><br/><div id="35809139" class="c"><input type="checkbox" id="c-35809139" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#35808651">root</a><span>|</span><a href="#35808737">parent</a><span>|</span><a href="#35809172">next</a><span>|</span><label class="collapse" for="c-35809139">[-]</label><label class="expand" for="c-35809139">[4 more]</label></div><br/><div class="children"><div class="content">Yeah this is the easiest way to get started. You probably want a low travel keyboard and ideally a low-latency-variance one to make it easier to find the start. It can be tricky to find where the update ends too because you usually see several frames of lcd switching.<p>The more advanced version is putting together a microcontroller which acts as a usb keyboard pressing a key, then backspace, then the key again, and uses a light sensor aimed at the right part of the screen to detect rendering in a repeatable way (slightly different fonts&#x2F; positions might change when it triggers but that’s likely on the order of a few ms tops, much less than the variance from frame boundaries).</div><br/><div id="35809583" class="c"><input type="checkbox" id="c-35809583" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#35808651">root</a><span>|</span><a href="#35809139">parent</a><span>|</span><a href="#35809172">next</a><span>|</span><label class="collapse" for="c-35809583">[-]</label><label class="expand" for="c-35809583">[3 more]</label></div><br/><div class="children"><div class="content">Or you could just have an led on your microcontroller that sends the keypress, and catch both the monitor and the led with the high speed camera</div><br/><div id="35812058" class="c"><input type="checkbox" id="c-35812058" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#35808651">root</a><span>|</span><a href="#35809583">parent</a><span>|</span><a href="#35811169">next</a><span>|</span><label class="collapse" for="c-35812058">[-]</label><label class="expand" for="c-35812058">[1 more]</label></div><br/><div class="children"><div class="content">The goal with a hardware device is partly avoiding having to label the begin&#x2F;end times on a bunch of videos.</div><br/></div></div><div id="35811169" class="c"><input type="checkbox" id="c-35811169" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#35808651">root</a><span>|</span><a href="#35809583">parent</a><span>|</span><a href="#35812058">prev</a><span>|</span><a href="#35809172">next</a><span>|</span><label class="collapse" for="c-35811169">[-]</label><label class="expand" for="c-35811169">[1 more]</label></div><br/><div class="children"><div class="content">Or use an USB HDMI capture card, and not involve a monitor in the process.</div><br/></div></div></div></div></div></div></div></div><div id="35809172" class="c"><input type="checkbox" id="c-35809172" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#35808651">parent</a><span>|</span><a href="#35808737">prev</a><span>|</span><a href="#35808414">next</a><span>|</span><label class="collapse" for="c-35809172">[-]</label><label class="expand" for="c-35809172">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I don’t really understand what the difference in latencies reported here would mean for the observed latency distribution of an actual end-to-end test. The latencies reported here are less than the difference in latency one should expect between the top and bottom of a screen (depending on vsync…). The repeatable way to measure these things is with a little embedded device which pretends to be a keyboard and uses a light sensor, but that’s a lot of work to set up even if you don’t need to take and label a bunch of videos yourself.</div><br/></div></div></div></div><div id="35808414" class="c"><input type="checkbox" id="c-35808414" checked=""/><div class="controls bullet"><span class="by">nathanwh</span><span>|</span><a href="#35808651">prev</a><span>|</span><a href="#35809171">next</a><span>|</span><label class="collapse" for="c-35808414">[-]</label><label class="expand" for="c-35808414">[4 more]</label></div><br/><div class="children"><div class="content">Alacritty being so slow is surprising to me here. I only use it on macOS, but it feels faster than kitty when I&#x27;m looking at application logs scrolling quickly across the screen. Perhaps responding to typing events has different latency than tailing a log file or listening to stdout?</div><br/><div id="35808763" class="c"><input type="checkbox" id="c-35808763" checked=""/><div class="controls bullet"><span class="by">the_jeremy</span><span>|</span><a href="#35808414">parent</a><span>|</span><a href="#35809171">next</a><span>|</span><label class="collapse" for="c-35808763">[-]</label><label class="expand" for="c-35808763">[3 more]</label></div><br/><div class="children"><div class="content">The latencies are different, and kitty is slower at this because the author doesn&#x27;t care about huge output[0]:<p>&gt; Some people have asked why kitty does not perform better than terminal XXX in the test of sinking large amounts of data, such as catting a large text file. The answer is because this is not a goal for kitty. kitty deliberately throttles input parsing and output rendering to minimize resource usage while still being able to sink output faster than any real world program can produce it. Reducing CPU usage, and hence battery drain while achieving instant response times and smooth scrolling to a human eye is a far more important goal.<p>0: <a href="https:&#x2F;&#x2F;sw.kovidgoyal.net&#x2F;kitty&#x2F;performance&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sw.kovidgoyal.net&#x2F;kitty&#x2F;performance&#x2F;</a></div><br/><div id="35809078" class="c"><input type="checkbox" id="c-35809078" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#35808414">root</a><span>|</span><a href="#35808763">parent</a><span>|</span><a href="#35808909">next</a><span>|</span><label class="collapse" for="c-35809078">[-]</label><label class="expand" for="c-35809078">[1 more]</label></div><br/><div class="children"><div class="content">I use &#x27;yes | head -n 1000000&#x27; for a throughput test, and kitty is about 5x faster than xterm and 1&#x2F;3 the speed of alacritty (zutty does not appear to be packaged in my OS).  It&#x27;s rather unusual to see something that is held up by terminal rendering (sbcl&#x27;s build process used to be, and they recommended using xterm for faster builds, so 5x faster than xterm is probably &quot;good enough&quot; there).</div><br/></div></div><div id="35808909" class="c"><input type="checkbox" id="c-35808909" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#35808414">root</a><span>|</span><a href="#35808763">parent</a><span>|</span><a href="#35809078">prev</a><span>|</span><a href="#35809171">next</a><span>|</span><label class="collapse" for="c-35808909">[-]</label><label class="expand" for="c-35808909">[1 more]</label></div><br/><div class="children"><div class="content">This sounds backwards from both an energy perspective and human factors perspective. I don&#x27;t understand the throughput vs. smooth scrolling tradeoff though.</div><br/></div></div></div></div></div></div><div id="35809171" class="c"><input type="checkbox" id="c-35809171" checked=""/><div class="controls bullet"><span class="by">helsinki</span><span>|</span><a href="#35808414">prev</a><span>|</span><a href="#35809781">next</a><span>|</span><label class="collapse" for="c-35809171">[-]</label><label class="expand" for="c-35809171">[1 more]</label></div><br/><div class="children"><div class="content">What about cmder? Pretty sure it would be the slowest.</div><br/></div></div><div id="35809781" class="c"><input type="checkbox" id="c-35809781" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#35809171">prev</a><span>|</span><a href="#35808773">next</a><span>|</span><label class="collapse" for="c-35809781">[-]</label><label class="expand" for="c-35809781">[2 more]</label></div><br/><div class="children"><div class="content">Would xterm against xcb be faster?</div><br/><div id="35811652" class="c"><input type="checkbox" id="c-35811652" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35809781">parent</a><span>|</span><a href="#35808773">next</a><span>|</span><label class="collapse" for="c-35811652">[-]</label><label class="expand" for="c-35811652">[1 more]</label></div><br/><div class="children"><div class="content">i doubt it; xlib&#x27;s problem is mostly usability, not speed</div><br/></div></div></div></div><div id="35808773" class="c"><input type="checkbox" id="c-35808773" checked=""/><div class="controls bullet"><span class="by">throwaway280382</span><span>|</span><a href="#35809781">prev</a><span>|</span><label class="collapse" for="c-35808773">[-]</label><label class="expand" for="c-35808773">[5 more]</label></div><br/><div class="children"><div class="content">For terminal aficionados here, which terminal works well with chatGPT ? I want chatGPT to predict my next keystroke, based on my previous commands I typed.</div><br/><div id="35812376" class="c"><input type="checkbox" id="c-35812376" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#35808773">parent</a><span>|</span><a href="#35809249">next</a><span>|</span><label class="collapse" for="c-35812376">[-]</label><label class="expand" for="c-35812376">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.warp.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.warp.dev&#x2F;</a><p><a href="https:&#x2F;&#x2F;docs.warp.dev&#x2F;features&#x2F;warp-ai&#x2F;ai-command-search" rel="nofollow">https:&#x2F;&#x2F;docs.warp.dev&#x2F;features&#x2F;warp-ai&#x2F;ai-command-search</a></div><br/></div></div><div id="35809249" class="c"><input type="checkbox" id="c-35809249" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#35808773">parent</a><span>|</span><a href="#35812376">prev</a><span>|</span><a href="#35810768">next</a><span>|</span><label class="collapse" for="c-35809249">[-]</label><label class="expand" for="c-35809249">[2 more]</label></div><br/><div class="children"><div class="content">GPT doesn&#x27;t work that way. Any such shell would have to send a GPT request for every single keystroke, and you&#x27;d hit the API ratelimit very quickly. It would also be very expensive.</div><br/><div id="35810202" class="c"><input type="checkbox" id="c-35810202" checked=""/><div class="controls bullet"><span class="by">LanternLight83</span><span>|</span><a href="#35808773">root</a><span>|</span><a href="#35809249">parent</a><span>|</span><a href="#35810768">next</a><span>|</span><label class="collapse" for="c-35810202">[-]</label><label class="expand" for="c-35810202">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a solid use case for local models are they&#x27;re optimized for consumer hardware-- someone clever could preserve as much context as possible between requests</div><br/></div></div></div></div><div id="35810768" class="c"><input type="checkbox" id="c-35810768" checked=""/><div class="controls bullet"><span class="by">16bitvoid</span><span>|</span><a href="#35808773">parent</a><span>|</span><a href="#35809249">prev</a><span>|</span><label class="collapse" for="c-35810768">[-]</label><label class="expand" for="c-35810768">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you just use Fish or zsh-autosuggestions? I don&#x27;t see the benefit of using a web api or AI for every keystroke when the current solutions work well enough.</div><br/></div></div></div></div></div></div></div></div></div></body></html>