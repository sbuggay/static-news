<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707901257900" as="style"/><link rel="stylesheet" href="styles.css?v=1707901257900"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.deusinmachina.net/p/compiling-history-a-brief-tour-of">Compiling History: A brief tour of C compilers</a> <span class="domain">(<a href="https://www.deusinmachina.net">www.deusinmachina.net</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>20 comments</span></div><br/><div><div id="39367150" class="c"><input type="checkbox" id="c-39367150" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#39367385">next</a><span>|</span><label class="collapse" for="c-39367150">[-]</label><label class="expand" for="c-39367150">[3 more]</label></div><br/><div class="children"><div class="content">I was hoping for a more thorough survey of the compilers and their history. Notably missing is any mention of Intel’s compiler, the Cray compiler, or the competition between Borland and Watcom C compilers. There was a big span of time when GCC wasn’t the only game in town! And also no mention of the more fringe compilers like TCC or the newer cproc. I understand it was meant to be brief, but this felt a bit too brief for my taste.</div><br/><div id="39367523" class="c"><input type="checkbox" id="c-39367523" checked=""/><div class="controls bullet"><span class="by">ludocode</span><span>|</span><a href="#39367150">parent</a><span>|</span><a href="#39367385">next</a><span>|</span><label class="collapse" for="c-39367523">[-]</label><label class="expand" for="c-39367523">[2 more]</label></div><br/><div class="children"><div class="content">I was definitely hoping for a look at modern compilers. This article was written last month, yet its history ends with the release of LLVM. There&#x27;s quite a lot of development in small C compilers lately!<p>- TinyCC, SCC (Simple C Compiler) and Kefir are all fairly serious projects in active development.<p>- QBE is a new optimizing backend much simpler than LLVM; cproc and cparser are two of the C compilers that target it, in addition to its own minic.<p>- There&#x27;s the bootstrapping work of stage0, M2-Planet, and mescc.<p>- chibicc is an educational C compiler based on the author&#x27;s earlier 8cc compiler. The author is writing a book about it.<p>- lacc is another simple compiler that works well, although development appears to have stalled.<p>I think a lot of these projects are inspired by the problem that GCC and Clang&#x2F;LLVM are now gigantic C++ projects. A pure C system like OpenBSD or Linux&#x2F;musl&#x2F;BusyBox ought to be able to compile itself without relying on C++. We really need a production quality open source C compiler that is actually written in C. I&#x27;m hopeful one of these compilers can achieve that someday.</div><br/><div id="39367719" class="c"><input type="checkbox" id="c-39367719" checked=""/><div class="controls bullet"><span class="by">sigsev_251</span><span>|</span><a href="#39367150">root</a><span>|</span><a href="#39367523">parent</a><span>|</span><a href="#39367385">next</a><span>|</span><label class="collapse" for="c-39367719">[-]</label><label class="expand" for="c-39367719">[1 more]</label></div><br/><div class="children"><div class="content">- Though freeware and not foss, there is also pellesc over at Windows land, with almost full C23 support.<p>- For small 8 bit systems, SDCC is an excellent choice, supporting even C23 features! Also its lead maintainer is a committee member with really useful contributions to the standard.<p>- I have heard the RiscOS compiler is pretty cool and supports modern standards. That one uses the Norcroft frontend.<p>I agree with you in that we need a production level C compiler written in C. Though that is not a simple task and the C community nowadays prefers to engage on infighting over pedantic issues or rust rather than working together. A simple example of this is the lack of a modern library ecosystem, while everyone and their mother has their own custom build system. Even though C is sold as a performant language, there isn&#x27;t a single parallelism library like OneTBB, Kokkos or HPX over at C++. Don&#x27;t get me started on vendors not offering good standard support (Microsoft, macos-libc, OpenBSD libc)...<p>One correction though, cparser uses libfirm as a backend, not qbe. Also the author of chibicc has stopped writing that book AFAIK.<p>Bonus non-c based entries:
- The zig community is working on arocc. Judging by the awesomeness of zig cc, these are really good news.
- Nvidia offers their EDG based nvc with OpenACC support for free these days, which is cool.<p>Edit: formatting</div><br/></div></div></div></div></div></div><div id="39367385" class="c"><input type="checkbox" id="c-39367385" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39367150">prev</a><span>|</span><a href="#39366661">next</a><span>|</span><label class="collapse" for="c-39367385">[-]</label><label class="expand" for="c-39367385">[1 more]</label></div><br/><div class="children"><div class="content">FTA: <i>“After a new compiler was written for this new language, it was renamed to C, and the rest is history. This was a significant breakthrough, as, until then, kernels were written in Assembly.”</i><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Burroughs_MCP" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Burroughs_MCP</a>: <i>“In 1961, the MCP was the first OS written exclusively in a high-level language.”</i><p>That’s about a decade before C.</div><br/></div></div><div id="39366661" class="c"><input type="checkbox" id="c-39366661" checked=""/><div class="controls bullet"><span class="by">blobsburgers</span><span>|</span><a href="#39367385">prev</a><span>|</span><a href="#39366610">next</a><span>|</span><label class="collapse" for="c-39366661">[-]</label><label class="expand" for="c-39366661">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Standard C library: newlib (850k lines), glibc (1.2M lines), musl (82k lines) or uClibC-ng (251k lines)<p>A big shout out to the musl developers. I was debugging a program&#x27;s use of posix_spawn and went down a rabbit hole of looking at all the libc implementations from the BSDs to the ones mentioned above, and found that musl was by far the most elegant and easiest to follow. It&#x27;s the sort of code we all wish we could write the first time.</div><br/></div></div><div id="39366610" class="c"><input type="checkbox" id="c-39366610" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39366661">prev</a><span>|</span><a href="#39364836">next</a><span>|</span><label class="collapse" for="c-39366610">[-]</label><label class="expand" for="c-39366610">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that Stallman wanted $150 (in 1987 dollars, so over $400 today) for a tape containing a copy of GCC, clearly showing the difference between &quot;free as in speech&quot; and &quot;free as in beer&quot;.</div><br/><div id="39367053" class="c"><input type="checkbox" id="c-39367053" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39366610">parent</a><span>|</span><a href="#39367754">next</a><span>|</span><label class="collapse" for="c-39367053">[-]</label><label class="expand" for="c-39367053">[1 more]</label></div><br/><div class="children"><div class="content">It was free as in beer to download through ftp.<p>The money for the tape presumably covered the cost of the tape and of access to a computer and a tape drive and the time spent by someone to write the tape and handle packing and shipping, with a small markup.</div><br/></div></div><div id="39367754" class="c"><input type="checkbox" id="c-39367754" checked=""/><div class="controls bullet"><span class="by">Tor3</span><span>|</span><a href="#39366610">parent</a><span>|</span><a href="#39367053">prev</a><span>|</span><a href="#39364836">next</a><span>|</span><label class="collapse" for="c-39367754">[-]</label><label class="expand" for="c-39367754">[1 more]</label></div><br/><div class="children"><div class="content">From the GPL 2.1 licence:
&quot;You may charge a fee for the physical act of transferring a copy,..&quot;<p>That ($400 in today&#x27;s value) isn&#x27;t an unfair price for doing all the work necessary to ship out a tape. It&#x27;s actually quite cheap. If I were to do that, using the tapes we had back then, I would charge more (I would have to take time from my working hours to go through that process).</div><br/></div></div></div></div><div id="39364836" class="c"><input type="checkbox" id="c-39364836" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39366610">prev</a><span>|</span><a href="#39365724">next</a><span>|</span><label class="collapse" for="c-39364836">[-]</label><label class="expand" for="c-39364836">[10 more]</label></div><br/><div class="children"><div class="content">I took a look at the original K&amp;R book not long ago, and was surprised how sparse of a reference it was.<p>For non-Unix platforms, the only header mentioned is &lt;stdio.h&gt;, but it does includes such functions&#x2F;macros as isupper, system, calloc, cfree, exit, and _exit.<p>For Unix, there is some mention of other headers, but many functions don&#x27;t seem to be associated with headers at all since they return `int` and as such don&#x27;t need a declaration. Headers are mostly for constants, typedefs, and structs.<p>I also noticed that: long float is equivalent to double, unsigned is only allowed on plain int, and scanf %h is a top-level specifier instead of a modifier.</div><br/><div id="39367843" class="c"><input type="checkbox" id="c-39367843" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#39364836">parent</a><span>|</span><a href="#39365405">next</a><span>|</span><label class="collapse" for="c-39367843">[-]</label><label class="expand" for="c-39367843">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s one other thing that&#x27;s different in those early Cs, there was no union, and structs worked differently. Effectively a field in a struct was just an offset, and all offset names were part of a global namespace of all field offsets - you could use any field name with any struct pointer - which is how you did the equivalent of unions - the v6&#x2F;v7 unix kernels used that for block device structures, they all began with the same first fields (a block queue) followed by per-device stuff</div><br/></div></div><div id="39365405" class="c"><input type="checkbox" id="c-39365405" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#39364836">parent</a><span>|</span><a href="#39367843">prev</a><span>|</span><a href="#39366844">next</a><span>|</span><label class="collapse" for="c-39365405">[-]</label><label class="expand" for="c-39365405">[7 more]</label></div><br/><div class="children"><div class="content">K&amp;R C was almost perfect, with its simplicity, minimalist elegance, and power. It would have been perfect if it was not for the addition of “-&gt;” which was unnecessary; it was done perhaps to simplify the compiler.</div><br/><div id="39367110" class="c"><input type="checkbox" id="c-39367110" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39364836">root</a><span>|</span><a href="#39365405">parent</a><span>|</span><a href="#39366068">next</a><span>|</span><label class="collapse" for="c-39367110">[-]</label><label class="expand" for="c-39367110">[1 more]</label></div><br/><div class="children"><div class="content">K&amp;R C didn&#x27;t have a `void` return type nor even check for the number of function arguments. Later C versions may have been bloated, but K&amp;R&#x27;s simplicity was often at odds with a minimal level of protection against the human stupidity. (Or you have a different definition of K&amp;R C, which is normally used to call what was described in the <i>first</i> edition of TCPL in 1978.)</div><br/></div></div><div id="39366068" class="c"><input type="checkbox" id="c-39366068" checked=""/><div class="controls bullet"><span class="by">ByQuyzzy</span><span>|</span><a href="#39364836">root</a><span>|</span><a href="#39365405">parent</a><span>|</span><a href="#39367110">prev</a><span>|</span><a href="#39366502">next</a><span>|</span><label class="collapse" for="c-39366068">[-]</label><label class="expand" for="c-39366068">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s weird to see you downvoted for this mere opinion. I agree - C has collected a LOT of garbage over the years. C++ is even worse and if you&#x27;ve ever used Smalltalk or Common Lisp, it barely even seems like OO.</div><br/></div></div><div id="39366502" class="c"><input type="checkbox" id="c-39366502" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39364836">root</a><span>|</span><a href="#39365405">parent</a><span>|</span><a href="#39366068">prev</a><span>|</span><a href="#39366844">next</a><span>|</span><label class="collapse" for="c-39366502">[-]</label><label class="expand" for="c-39366502">[4 more]</label></div><br/><div class="children"><div class="content">`-&gt;` is completely redundant with `.`. I suspect it may be a relic from an earlier version of C that did not have a complete type system.</div><br/><div id="39367125" class="c"><input type="checkbox" id="c-39367125" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#39364836">root</a><span>|</span><a href="#39366502">parent</a><span>|</span><a href="#39366844">next</a><span>|</span><label class="collapse" for="c-39367125">[-]</label><label class="expand" for="c-39367125">[3 more]</label></div><br/><div class="children"><div class="content">&quot;-&gt;&quot; is taken from the IBM PL&#x2F;I language, which was an important source of various syntax elements of C (the other 2 main sources being BCPL and Algol 68).<p>It was added because the indirection operator &quot;*&quot; has the wrong position in C, it is prefix instead of being postfix, like in the languages where it had first appeared, i.e. Euler and Pascal, which had inherited it from Euler (both are Wirth languages).<p>Had &quot;*&quot; been postfix, &quot;.*&quot; could have always been used instead of &quot;-&gt;&quot;. As it is, &quot;-&gt;&quot; eliminates a pair of parentheses that is needed when the indirection is followed by other postfix operators, like array indexing or structure member selection, which happens very frequently.<p>IIRC, in one of his papers about the history of C, Dennis Ritchie has recognized several mistakes in the design of C and one of them was the prefix &quot;*&quot;, besides others like the precedence of &quot;&amp;&quot; and &quot;|&quot;.<p>In PL&#x2F;I &quot;-&gt;&quot; was the only indirection operator, while CPL had no explicit indirection, the indirection was implicit whenever a pointer was used in an expression, like with the C++ references. The CPL pointers (which were named references, &quot;pointer&quot; is a term introduced later by PL&#x2F;I) could use a special assignment operator, which assigned the address of an expression, not its value.<p>While &quot;-&gt;&quot; is somewhat redundant, its sole purpose being to eliminate some parentheses, it is no more redundant than e.g. the existence of both &quot;for&quot; and &quot;while&quot; or of &quot;do ... while&quot; when &quot;break&quot; exists, or of the comma operator, or of several other redundant features of C, which offer alternative ways of writing the same thing, with slightly shorter variants for certain use cases. While C has much less redundancy than Perl (which is proud of it), it still has much more than I consider good for a programming language.<p>When structures had been added to C, they had realized that the wrong position of &quot;*&quot; requires extra parentheses, but they must have had plenty of code written in late B and early C that had used &quot;*&quot;, so instead of redefining &quot;*&quot; they have chosen the easier path of taking the structures from PL&#x2F;I together with all their syntax elements used in PL&#x2F;I, i.e. the keyword &quot;struct&quot; and the operators &quot;.&quot; and &quot;-&gt;&quot;.</div><br/><div id="39367814" class="c"><input type="checkbox" id="c-39367814" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#39364836">root</a><span>|</span><a href="#39367125">parent</a><span>|</span><a href="#39366844">next</a><span>|</span><label class="collapse" for="c-39367814">[-]</label><label class="expand" for="c-39367814">[2 more]</label></div><br/><div class="children"><div class="content">Hey array indexing is postfix, so let&#x27;s just use the old &quot;arrays decay to pointers&quot; staple, but obviously in reverse:<p><pre><code>    typedef struct {
        int a;
        int b;
    } foo;

    int main(void) {
        foo one = { 1, 2 };
        foo * const p = &amp;one;
        p[0].b = 13;   &#x2F;&#x2F; Look ma no -&gt; !
        printf(&quot;Now we have { %d, %d }\n&quot;, one.a, one.b);
        return 0;
    }
</code></pre>
Of course one could go all nasty and flip the base and index:<p><pre><code>        0[p].b = 13;
</code></pre>
But hey that&#x27;s just being silly.<p>In all seriousness, thanks a lot for the historic review of C syntax! Very interesting, as someone who really likes C enough to (ab)use it whenever possible.<p>I <i>know</i> that a-&gt;b is equivalent to (*a).b, but still the difference makes sense to my brain which first learned assembly. It&#x27;s much &quot;lighter-feeling&quot;, not having to evaluate the &quot;entire&quot; structure just to get to a single field. :) Weird, but I really like this little piece of syntactic sugar. Yum.</div><br/><div id="39367861" class="c"><input type="checkbox" id="c-39367861" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#39364836">root</a><span>|</span><a href="#39367814">parent</a><span>|</span><a href="#39366844">next</a><span>|</span><label class="collapse" for="c-39367861">[-]</label><label class="expand" for="c-39367861">[1 more]</label></div><br/><div class="children"><div class="content">or just &quot;(*p).b = 13;&quot;</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39366844" class="c"><input type="checkbox" id="c-39366844" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#39364836">parent</a><span>|</span><a href="#39365405">prev</a><span>|</span><a href="#39365724">next</a><span>|</span><label class="collapse" for="c-39366844">[-]</label><label class="expand" for="c-39366844">[1 more]</label></div><br/><div class="children"><div class="content">It was published in 1978.  Surprising that in 45 years, a couple of things have changed?</div><br/></div></div></div></div><div id="39365724" class="c"><input type="checkbox" id="c-39365724" checked=""/><div class="controls bullet"><span class="by">mianos</span><span>|</span><a href="#39364836">prev</a><span>|</span><label class="collapse" for="c-39365724">[-]</label><label class="expand" for="c-39365724">[1 more]</label></div><br/><div class="children"><div class="content">Haha, even returning a structure still seems a bit fancy to me. I remember at the time, thinking, how can they return all that data and went straight to whatever &#x27;-S&#x27; was in those days (-E?) to look at how it worked in assembly.</div><br/></div></div></div></div></div></div></div></body></html>