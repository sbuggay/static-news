<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724230876544" as="style"/><link rel="stylesheet" href="styles.css?v=1724230876544"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://muratbuffalo.blogspot.com/2024/08/making-database-systems-usable.html">Making database systems usable</a> <span class="domain">(<a href="http://muratbuffalo.blogspot.com">muratbuffalo.blogspot.com</a>)</span></div><div class="subtext"><span>jamesblonde</span> | <span>83 comments</span></div><br/><div><div id="41303365" class="c"><input type="checkbox" id="c-41303365" checked=""/><div class="controls bullet"><span class="by">otoolep</span><span>|</span><a href="#41304660">next</a><span>|</span><label class="collapse" for="c-41303365">[-]</label><label class="expand" for="c-41303365">[6 more]</label></div><br/><div class="children"><div class="content">&gt;They care less about impressive benchmarks or clever algorithms, and more about whether they can operate and use a database efficiently to query, update, analyze, and persist their data with minimal headache.<p>Hugely important, and I would add &quot;backup-and-restore&quot; to that list. At risk of sounding conceited, ease of use is a primary goal of rqlite[1] -- because in the real world databases must be <i>operated</i>[2]. I never add a feature if it&#x27;s going to measurably decrease how easy it is to operate the database.<p>[1] <a href="https:&#x2F;&#x2F;www.rqlite.io" rel="nofollow">https:&#x2F;&#x2F;www.rqlite.io</a><p>[2] <a href="https:&#x2F;&#x2F;docs.google.com&#x2F;presentation&#x2F;d&#x2F;1Q8lQgCaODlecHa2hS-OeMGoij22oMZ_xhyeRTrQnn6o&#x2F;edit#slide=id.ge8e3d69953_0_35" rel="nofollow">https:&#x2F;&#x2F;docs.google.com&#x2F;presentation&#x2F;d&#x2F;1Q8lQgCaODlecHa2hS-Oe...</a><p>Disclaimer: I&#x27;m the creator of rqlite.</div><br/><div id="41303665" class="c"><input type="checkbox" id="c-41303665" checked=""/><div class="controls bullet"><span class="by">otoolep</span><span>|</span><a href="#41303365">parent</a><span>|</span><a href="#41304383">next</a><span>|</span><label class="collapse" for="c-41303665">[-]</label><label class="expand" for="c-41303665">[3 more]</label></div><br/><div class="children"><div class="content">Or, I should say, I don&#x27;t add the feature until I can figure out how it can made be easy and intuitive <i>to</i> use. That&#x27;s assuming the feature is even coherent with the existing feature set of the database.<p>Of course, it&#x27;s easy for me to do this. I am not developing the database for commercial reasons, so can just say &quot;no&quot; to an idea if I want. That said, I&#x27;ve found that many ideas which didn&#x27;t seem interesting to me when an end-user first proposed them become compelling once I think more about the operational pain (and it&#x27;s almost always operational) they are experiencing.<p><i>Automatic backups to S3</i>[1] was such a feature. I was sceptical -- &quot;just run a script, call the backup API, and upload yourself&quot; was my attitude. But the built-in support has become popular.<p>[1] <a href="https:&#x2F;&#x2F;www.philipotoole.com&#x2F;adding-automatic-s3-backups-to-rqlite&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.philipotoole.com&#x2F;adding-automatic-s3-backups-to-...</a></div><br/><div id="41303908" class="c"><input type="checkbox" id="c-41303908" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41303365">root</a><span>|</span><a href="#41303665">parent</a><span>|</span><a href="#41304383">next</a><span>|</span><label class="collapse" for="c-41303908">[-]</label><label class="expand" for="c-41303908">[2 more]</label></div><br/><div class="children"><div class="content">The distance between a large effort and a moderate effort is not very long; from the user&#x27;s perspective, both things are in the realm of the Hassle.<p>The chasm between a small required effort and zero effort is <i>vast</i>, from the user&#x27;s perspective.<p>Any product person will tell you that. Hitting the right zero-effort target is what separates a runaway success from a tepid reaction.</div><br/><div id="41304342" class="c"><input type="checkbox" id="c-41304342" checked=""/><div class="controls bullet"><span class="by">spinningslate</span><span>|</span><a href="#41303365">root</a><span>|</span><a href="#41303908">parent</a><span>|</span><a href="#41304383">next</a><span>|</span><label class="collapse" for="c-41304342">[-]</label><label class="expand" for="c-41304342">[1 more]</label></div><br/><div class="children"><div class="content">yes, definitely.  I find it helpful to think of usability and friction as an inverse square law relation [0].  Small increases in friction (x-axis) cause dramatic drop-off in usability (y-axis) to begin with, then correspondingly less so.  Specific user tolerance will vary, but adoption broadly follows a similar path - exponential drop off.<p>I&#x27;ve never seen any data to back this up in a quantitative sense (though interested if anyone has?).  Nevertheless, I&#x27;ve still found it useful as a qualitative rule of thumb in a positive sense: shaving off small edges of friction can have non-linear return in adoption and satisfaction.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inverse-square_law" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inverse-square_law</a></div><br/></div></div></div></div></div></div><div id="41304383" class="c"><input type="checkbox" id="c-41304383" checked=""/><div class="controls bullet"><span class="by">makmanalp</span><span>|</span><a href="#41303365">parent</a><span>|</span><a href="#41303665">prev</a><span>|</span><a href="#41304660">next</a><span>|</span><label class="collapse" for="c-41304383">[-]</label><label class="expand" for="c-41304383">[2 more]</label></div><br/><div class="children"><div class="content">Add schema migrations and bulk loads to this. So many systems crap out doing things like schema migrations at scale. Query latencies degrade over time due to internal structures keeping track of things, stuff runs out of buffer &#x2F; log space in memory or on disk, you have a traffic spike but you can&#x27;t pause or throttle a 40 hour long ALTER, things that should never lock do lock for indeterminate times during cutover, stuff craps out after cutover due to surprising behavior but there is no rollback, or even worse I&#x27;ve seen things just flat out crash with some random assert fail or segfault.<p>It&#x27;s a world of pain, and there are so much scar tissue of third party tooling doing crazy stuff dealing with this problem among large companies that really should be the DB vendor&#x27;s problem.</div><br/><div id="41305433" class="c"><input type="checkbox" id="c-41305433" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41303365">root</a><span>|</span><a href="#41304383">parent</a><span>|</span><a href="#41304660">next</a><span>|</span><label class="collapse" for="c-41305433">[-]</label><label class="expand" for="c-41305433">[1 more]</label></div><br/><div class="children"><div class="content">If you spend time reading docs – I mean <i>really</i> reading them, you’ll probably find out why something locked. For example, MySQL 8.? can extend metadata locks to cover foreign key relationships. This seemingly innocuous line in docs can cause the entire DB to grind to a halt under load.<p>I’m not saying this is good, only that RDBMS management is very much still in the land of arcane incantations, and anyone saying otherwise is selling something. It’s also why I have a job, so from my perspective it isn’t all bad.</div><br/></div></div></div></div></div></div><div id="41304660" class="c"><input type="checkbox" id="c-41304660" checked=""/><div class="controls bullet"><span class="by">pjs_</span><span>|</span><a href="#41303365">prev</a><span>|</span><a href="#41304616">next</a><span>|</span><label class="collapse" for="c-41304660">[-]</label><label class="expand" for="c-41304660">[20 more]</label></div><br/><div class="children"><div class="content">A huge fraction (not 100%, but maybe 80%) of my frustration in trying to get technical people to use a database is that they have such a hard time understanding JOINs.<p>People endlessly want hacks, workarounds, and un-normalized data structures, for a single reason - they don&#x27;t want to have to think about JOIN. It&#x27;s not actually for performance reasons, it&#x27;s not actually for any reason other than it&#x27;s easier to imagine a big table with lots of columns.<p>I&#x27;m actually sympathetic to that reticence but what I am not sympathetic about is this: why, in 2024, can&#x27;t the computer figure out multi-table joins for me?<p>Unless your schema is really fucked up, there should only be one or two actually sensible ways to join across multiple tables. Like say I have apples in boxes in houses. I have an apple table, a box table, and a house table. apples have a box_id, boxes have a house_id. Now I want to find all the apples in a house. Do two joins, cool. But literally everyone seems to write this by hand, and it means that crud apps end up with thousands of nearly identical queries which are mostly just boringly spelling out the chain of joins that needs to be applied.<p>When I started using SQLAlchemy, I naively assumed that a trivial functionality of such a sophisticated ORM would be to implement `apple.join(house)`, automatically figuring out that `box` is the necessary intermediate step. SQLAlchemy even has all the additional relationship information to figure out the details of how those joins need to work. But after weeks of reading the documentation I realized that this is not a supported feature.<p>In the end I wrote a join tool myself, which can automatically find paths between distant tables in the schema, but it seems ludicrous to have to homebrew something like that.<p>I&#x27;m not a trained software engineer but it seems like this must be a very generic problem -- is there a name for the problem? Are there accepted solutions or no-go-theorems on what is possible? I have searched the internet a lot and mostly just find people saying &quot;oh we just type out all combinatorially-many possible queries&quot;... apologies in advance if I am very ignorant here</div><br/><div id="41308274" class="c"><input type="checkbox" id="c-41308274" checked=""/><div class="controls bullet"><span class="by">arkh</span><span>|</span><a href="#41304660">parent</a><span>|</span><a href="#41304833">next</a><span>|</span><label class="collapse" for="c-41308274">[-]</label><label class="expand" for="c-41308274">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unless your schema is really fucked up<p>So most enterprise schema who have outlived multiple applications. Usually due to time constraint, lack of database administrators and complex business needs. Excel is the king of databases for a reason.</div><br/></div></div><div id="41304833" class="c"><input type="checkbox" id="c-41304833" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#41304660">parent</a><span>|</span><a href="#41308274">prev</a><span>|</span><a href="#41305499">next</a><span>|</span><label class="collapse" for="c-41304833">[-]</label><label class="expand" for="c-41304833">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really a problem of there being combinatorially many ways to join table A to table B, but rather that unless the join is fully-specified those ways will mostly produce different results. Your tool would need to sniff out these ambiguous cases and either fail or prompt the user to specify what they mean. In either case the user isn&#x27;t saved from understanding joins.</div><br/><div id="41305789" class="c"><input type="checkbox" id="c-41305789" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41304833">parent</a><span>|</span><a href="#41305499">next</a><span>|</span><label class="collapse" for="c-41305789">[-]</label><label class="expand" for="c-41305789">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>”but rather that unless the join is fully-specified those ways will mostly produce different results.”</i><p>As a SQL non-expert, I think this is why we are averse to joins, because it’s easy to end up with more rows in the result than you intended, and it’s not always clear how to verify you haven’t ended up in this scenario.</div><br/><div id="41306946" class="c"><input type="checkbox" id="c-41306946" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41305789">parent</a><span>|</span><a href="#41306155">next</a><span>|</span><label class="collapse" for="c-41306946">[-]</label><label class="expand" for="c-41306946">[1 more]</label></div><br/><div class="children"><div class="content">I wish there were a way to specify the expected join cardinality syntactically for 1:1 joins.<p><pre><code>    SELECT * FROM order JOIN_ONE customer USING (customer_id)
</code></pre>
Malloy has join_one: <a href="https:&#x2F;&#x2F;docs.malloydata.dev&#x2F;documentation&#x2F;language&#x2F;join" rel="nofollow">https:&#x2F;&#x2F;docs.malloydata.dev&#x2F;documentation&#x2F;language&#x2F;join</a></div><br/></div></div><div id="41306155" class="c"><input type="checkbox" id="c-41306155" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41305789">parent</a><span>|</span><a href="#41306946">prev</a><span>|</span><a href="#41305499">next</a><span>|</span><label class="collapse" for="c-41306155">[-]</label><label class="expand" for="c-41306155">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, but someone who is averse to joins is not a non-expert in SQL, they are a total novice. The answer is like any other programming language. You simply must learn the language fundamentals in order to use it.</div><br/></div></div></div></div></div></div><div id="41305499" class="c"><input type="checkbox" id="c-41305499" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41304660">parent</a><span>|</span><a href="#41304833">prev</a><span>|</span><a href="#41304846">next</a><span>|</span><label class="collapse" for="c-41305499">[-]</label><label class="expand" for="c-41305499">[8 more]</label></div><br/><div class="children"><div class="content">&gt; People endlessly want hacks, workarounds, and un-normalized data structures, for a single reason - they don&#x27;t want to have to think about JOIN. It&#x27;s not actually for performance reasons, it&#x27;s not actually for any reason other than it&#x27;s easier to imagine a big table with lots of columns.<p>That&#x27;s because, inexplicably, devs by and large don&#x27;t know SQL, and don&#x27;t want to learn it. It&#x27;s an absurdly simple language that should take a competent person a day to get a baseline level of knowledge, and perhaps a week to be extremely comfortable with.<p>As an aside, something you can do is create views (non-materialized) for whatever queries are desired. The counter-arguments to this are that is slows development velocity, but then, so does devs who don&#x27;t know how to do joins.</div><br/><div id="41305680" class="c"><input type="checkbox" id="c-41305680" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41305499">parent</a><span>|</span><a href="#41304846">next</a><span>|</span><label class="collapse" for="c-41305680">[-]</label><label class="expand" for="c-41305680">[7 more]</label></div><br/><div class="children"><div class="content">it&#x27;s &quot;absurdly simple&quot;, but then you get presented with a bunch of weird things that look like abstraction ceilings like &quot;oh you can&#x27;t refer to the select clause alias you made in the filter because despite that showing up first lexicographically the ordering is different&quot; and &quot;oh you don&#x27;t have to refer to the table name except when you do because of ambiguity issues&quot;.<p>I think there&#x27;s a beautiful space for some SQL-like language that just operates a bit more like a general-purpose language in a more regular fashion. Bonus points for ones where you don&#x27;t query tables but point at indexes or table scans and the like (resolving the &quot;programmer writes query that is super non-performant because they assume an index is present when it&#x27;s not&quot;).<p>I think it&#x27;s still super straightforward to sit down and learn it, but it&#x27;s really unfortunate that we spend a bunch of time in school learning data structures and then SQL tries really hard to hide all that, making it pretty opaque despite people intuitively understanding B-Trees or indexes.</div><br/><div id="41306463" class="c"><input type="checkbox" id="c-41306463" checked=""/><div class="controls bullet"><span class="by">iTokio</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41305680">parent</a><span>|</span><a href="#41306742">next</a><span>|</span><label class="collapse" for="c-41306463">[-]</label><label class="expand" for="c-41306463">[2 more]</label></div><br/><div class="children"><div class="content">SQL separates query definition from  implementation because there is a planning phase between them that can be sometimes quite complex.<p>To choose the best path to retrieve data, you have to know what are the possible paths (using the underlying data structures, indexes but also different algorithms to filter, join…), but you should also know some data metrics to evaluate if some shortcuts are worth it (a seq scan can be the best choice with a small table..).<p>And the thing that will trip most humans, is that you need to reevaluate the plan if the underlying assumptions change (data distribution has become something that you never expected).<p>Note that the planner is also NOT always right, it heavily relies on heuristics and data metrics that can be skewed or not up to date.
Some databases allow the use of hints to choose an index or a specific path.</div><br/><div id="41307133" class="c"><input type="checkbox" id="c-41307133" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41306463">parent</a><span>|</span><a href="#41306742">next</a><span>|</span><label class="collapse" for="c-41307133">[-]</label><label class="expand" for="c-41307133">[1 more]</label></div><br/><div class="children"><div class="content">My honest experience in a skilled team has been that people more or less start off thinking &quot;OK, what indices do we need to make this performant&quot;, work off of that, and then in the end try to have queries that hit those ones.<p>I understand the value of full declarative planning with heuristics, but sometimes the query writers do in fact have a better understanding of the data that will go in.<p>And beyond that, having consistent plans is actually better in some ideologies! Instead of a query suddenly changing tactics in a data- and time-dependent way, having consistent behavior at the planning phase means that you can apply general engineering maintenance tactics. Keep an eye on query perf, improve things that need to be improved... there are still the possibility of hitting absolutely nasty issues, but the fact that every SQL debugging session starts with &quot;well we gotta run EXPLAIN first after the fact&quot; is actually kind of odd!</div><br/></div></div></div></div><div id="41306742" class="c"><input type="checkbox" id="c-41306742" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41305680">parent</a><span>|</span><a href="#41306463">prev</a><span>|</span><a href="#41306837">next</a><span>|</span><label class="collapse" for="c-41306742">[-]</label><label class="expand" for="c-41306742">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;oh you don&#x27;t have to refer to the table name except when you do because of ambiguity issues&quot;<p>Maybe it&#x27;s easier if you think of it like helpful syntactic sugar?<p>&gt; I think there&#x27;s a beautiful space for some SQL-like language that just operates a bit more like a general-purpose language in a more regular fashion. Bonus points for ones where you don&#x27;t query tables but point at indexes or table scans and the like<p>That sounds like imperative programming, which is fine for most things, but [generally] not RDBMS (or IaC, but that&#x27;s a completely separate topic). You can&#x27;t possibly know the state of a given table or index – the cardinality of columns, the relative grouping of tuples to one another, etc. While you <i>can</i> hint at index usage (natively with MySQL, via extension with Postgres), that&#x27;s as close as the planner will let you get, because it knows these things better than you do.<p>&gt; resolving the &quot;programmer writes query that is super non-performant because they assume an index is present when it&#x27;s not&quot;<p>More frequently, I see &quot;programmer writes query that is super non-performant because they haven&#x27;t read the docs, and don&#x27;t know the requirements for the planner to use the index.&quot; A few examples:<p>* Given a table with columns foo, bar, baz, with an index on (foo, bar), a query with a predicate on `bar` alone is [generally] non-sargeable. Postgres <i>can</i> do this, but it&#x27;s rare, and unlikely to perform as well as you&#x27;d want anyway.<p>* Indices on columns are unlikely to be used for aggregations like GROUP BY, except in very specific circumstances for MySQL [0] (I&#x27;m not sure what limitations Postgres has on this).<p>* Not knowing that a leading wildcard on a predicate (e.g. `WHERE user_name LIKE &#x27;%ara&#x27;`) will, except under two circumstances [1], skip using an index.<p>&gt; despite people intuitively understanding B-Trees or indexes.<p>You say that, but the sheer number of devs I&#x27;ve talked to who are unaware that UUIDv4 is an abysmally bad choice WRT performance for indices – primary or secondary – says otherwise.<p>[0]: <a href="https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.4&#x2F;en&#x2F;group-by-optimization.html" rel="nofollow">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.4&#x2F;en&#x2F;group-by-optimizatio...</a><p>[1]: Postgres can create trigram indices, which can search with these, at the expense of the index being quite large. Both MySQL and Postgres can make use of the REVERSE() function to create a reverse index on the column, which can then be used in a query with the username also reversed.</div><br/><div id="41307147" class="c"><input type="checkbox" id="c-41307147" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41306742">parent</a><span>|</span><a href="#41306837">next</a><span>|</span><label class="collapse" for="c-41307147">[-]</label><label class="expand" for="c-41307147">[1 more]</label></div><br/><div class="children"><div class="content">In the universe in which I &quot;know&quot; what index to use (an assumption that can be contested!), you saying &quot;well silly you, the planner is too stupid to figure this out&quot; is not a great defense of the system!<p>My serious belief is that all the SQL variants are generally great, but I just want this to be incremented with some lower-level language that I can be more explicit with, from time to time. If only because sometimes there are operational needs.<p>The fact that the best we get with this is planner _hints_ is still to this day surprising to me. Hints! I am in control of the machine, why shouldn&#x27;t it just listen to me! (and to stop the &quot;but random data analyst could break thing&quot;, this is why we have invented permission systems)</div><br/></div></div></div></div><div id="41306837" class="c"><input type="checkbox" id="c-41306837" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41305680">parent</a><span>|</span><a href="#41306742">prev</a><span>|</span><a href="#41304846">next</a><span>|</span><label class="collapse" for="c-41306837">[-]</label><label class="expand" for="c-41306837">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think it&#x27;s still super straightforward to sit down and learn it, but it&#x27;s really unfortunate that we spend a bunch of time in school learning data structures and then SQL tries really hard to hide all that, making it pretty opaque despite people intuitively understanding B-Trees or indexes.<p>That&#x27;s one of the best things about SQL, it&#x27;s declarative nature. I describe the end result, data I want to receive — not the instructions on how it should be done. There&#x27;s no control flow, there&#x27;s no program state, which means that my mental model of it is so much simpler.</div><br/><div id="41306879" class="c"><input type="checkbox" id="c-41306879" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41306837">parent</a><span>|</span><a href="#41304846">next</a><span>|</span><label class="collapse" for="c-41306879">[-]</label><label class="expand" for="c-41306879">[1 more]</label></div><br/><div class="children"><div class="content">Yes but for performance you need to know how it is done, which defeats the declarative point.<p>I&#x27;ve read countless articles on how to rearrange the &quot;declaration of what you want&quot; in order to get the database to do it in a fast way.</div><br/></div></div></div></div></div></div></div></div><div id="41304846" class="c"><input type="checkbox" id="c-41304846" checked=""/><div class="controls bullet"><span class="by">rawgabbit</span><span>|</span><a href="#41304660">parent</a><span>|</span><a href="#41305499">prev</a><span>|</span><a href="#41305082">next</a><span>|</span><label class="collapse" for="c-41304846">[-]</label><label class="expand" for="c-41304846">[4 more]</label></div><br/><div class="children"><div class="content">Most databases have the concept of foreign keys. You declare how the tables relate to each other. You can then write a script that queries this metadata to write the join for you. I did this sort of thing over twenty years ago.</div><br/><div id="41306598" class="c"><input type="checkbox" id="c-41306598" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41304846">parent</a><span>|</span><a href="#41305082">next</a><span>|</span><label class="collapse" for="c-41306598">[-]</label><label class="expand" for="c-41306598">[3 more]</label></div><br/><div class="children"><div class="content">Most ORMs have this feature as well and sorry to say you will
hit edge cases where the join is ambiguous and have to manually specify it pretty fast.</div><br/><div id="41307103" class="c"><input type="checkbox" id="c-41307103" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41306598">parent</a><span>|</span><a href="#41305082">next</a><span>|</span><label class="collapse" for="c-41307103">[-]</label><label class="expand" for="c-41307103">[2 more]</label></div><br/><div class="children"><div class="content">&gt; where the join is ambiguous<p>Join table that maps to an entity in the middle.<p>You can even have multiple columns that have foreign keys against various tables, like some_table_id, other_table_id, another_table_id with only the needed ones being filled out.<p>And in practice, this will be way more manageable than the dynamic mess of the OTLT pattern (table_name and table_id): <a href="https:&#x2F;&#x2F;www.red-gate.com&#x2F;simple-talk&#x2F;blogs&#x2F;when-the-fever-is-over-and-ones-work-is-done&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.red-gate.com&#x2F;simple-talk&#x2F;blogs&#x2F;when-the-fever-is...</a><p>It&#x27;s not like you have to particularly care about the fact that most of those columns will be empty in practice, as opposed to making your database hard to query or throwing constraints aside altogether.</div><br/><div id="41307330" class="c"><input type="checkbox" id="c-41307330" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41307103">parent</a><span>|</span><a href="#41305082">next</a><span>|</span><label class="collapse" for="c-41307330">[-]</label><label class="expand" for="c-41307330">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Join table that maps to an entity in the middle.<p>I&#x27;m not not sure what you mean. Are you saying that instead of FK&#x2F;PK relations like:<p><pre><code>    user.residence_country_id        = country.id 
    plus user.citizenship_country_id = country.id
</code></pre>
You would reify every edge like:<p><pre><code>    user.residence_link_id           = link_user_residence.user_id
    link_user_residence.country_id   = country.id
    user.citizenship_link_id         = link_user_citizenship.user_id
    link_user_citizenship.country_id = country.id
</code></pre>
Even then, the reverse &quot;I have a country gimme a user&quot; request is ambiguous.</div><br/></div></div></div></div></div></div></div></div><div id="41305082" class="c"><input type="checkbox" id="c-41305082" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#41304660">parent</a><span>|</span><a href="#41304846">prev</a><span>|</span><a href="#41304616">next</a><span>|</span><label class="collapse" for="c-41305082">[-]</label><label class="expand" for="c-41305082">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>In the end I wrote a join tool myself, which can automatically find paths between distant tables in the schema, but it seems ludicrous to have to homebrew something like that.</i><p>I mean, I think the issue is just that there are lots of possible paths so it can&#x27;t be automated.<p>If you want to join employees to buildings, is it where their desk is assigned today, or where their desk was assigned two years ago, or where their team is based even though they work remotely, or where they last badged in?<p>Sure you can build a tool to find all potential joins based on foreign keys, but then how do you know which is correct unless you understand what the tables mean? And then if you understand what the tables mean, writing the join out yourself is trivial.<p>&gt; <i>Unless your schema is really fucked up, there should only be one or two actually sensible ways to join across multiple tables.</i><p>In my experience, having just one or two ways is for simple&#x2F;toy projects. Lots of joins in no way means a schema is &quot;fucked up&quot;. It probably just means it&#x27;s correctly modeling actual relationships, correctly normalized.</div><br/><div id="41306766" class="c"><input type="checkbox" id="c-41306766" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41304660">root</a><span>|</span><a href="#41305082">parent</a><span>|</span><a href="#41304616">next</a><span>|</span><label class="collapse" for="c-41306766">[-]</label><label class="expand" for="c-41306766">[1 more]</label></div><br/><div class="children"><div class="content">Real-world example: Someone wants Job-Application by Country, but that could mean via Applicant&#x27;s Residence, the Applicant&#x27;s Nationality, the Requisition Primary location, or one of the Requisition&#x27;s Satellite Offices, etc.<p>... And god help you if someday Requisitions need to have <i>Revisions</i> too.</div><br/></div></div></div></div></div></div><div id="41304616" class="c"><input type="checkbox" id="c-41304616" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41304660">prev</a><span>|</span><a href="#41302544">next</a><span>|</span><label class="collapse" for="c-41304616">[-]</label><label class="expand" for="c-41304616">[15 more]</label></div><br/><div class="children"><div class="content">Something thats always bugged me about relational database modelling is how you have to use table relationships for everything. Humans have a special category for ownership (eg Order owns DeliveryAddress), which works differently from other kinds of relationships. Eg Order references Products.<p>This problem is heightened by the fact that a SQL table typically can&#x27;t store composite types. Like, you can&#x27;t make a column of lists-of-strings. Every modelling problem is solved by using <i>more tables</i>. And any nontrivial application ends up with a table explosion. You have to study your database very closely, then write complex, slow, join-heavy queries, just to get the information about simple stuff - like an order.<p>Solving every problem with tables might seem clever from a technical perspective, but its just not how humans think. There&#x27;s a reason document databases like mongodb are popular. Even if they are worse technically, they&#x27;re much easier to use and reason about.<p>There&#x27;s no reason SQL databases couldn&#x27;t support nested data. Postgres sort of does already via JSON fields. But it feels like you have to fight the database to do it.</div><br/><div id="41304757" class="c"><input type="checkbox" id="c-41304757" checked=""/><div class="controls bullet"><span class="by">stult</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41304708">next</a><span>|</span><label class="collapse" for="c-41304757">[-]</label><label class="expand" for="c-41304757">[2 more]</label></div><br/><div class="children"><div class="content">Your argument is a variant of the object–relational impedance mismatch problem[1]. It&#x27;s easier for us to reason about objects (or functions and types) than it is to think in terms of SQL tables, so it is much easier to develop complex logic or domain models in general purpose programming languages. Yet data storage and retrieval is much, much more efficient with relational databases, and it is generally a good practice to logically separate the data storage layer from the rest of the system anyway. But implementing that layer to translate from the relational model to the object model frequently involves tons of finicky, manually crafted SQL statements embedded in general purpose code where the linting&#x2F;type checking&#x2F;static analysis tooling often isn&#x27;t great for the embedded SQL. The only other alternatives are using an ORM that automagically handles most if not all of the relational-object mapping or a NoSQL solution like Mongo that avoids the mismatch altogether. Both those alternatives typically involve sacrificing performance and scalability, however, and the limitations and quirks of each frequently contribute to bugs (e.g., schema drift in document DBs, or implementation details of the ORM that make it hard to map nested relationships).<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object%E2%80%93relational_impedance_mismatch" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object%E2%80%93relational_impe...</a></div><br/><div id="41305655" class="c"><input type="checkbox" id="c-41305655" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41304616">root</a><span>|</span><a href="#41304757">parent</a><span>|</span><a href="#41304708">next</a><span>|</span><label class="collapse" for="c-41305655">[-]</label><label class="expand" for="c-41305655">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s just about storage and retrievel being efficient. Sometimes it _is_ easier to think in terms of tables.<p>I have a bunch of posts, written by various authors, on various sites. Store that in some OOP way, with ownership going in some direction (For example, sites own posts). Now look up the most recent posts for authors. Look up the most recent posts per site. Look up the most prolific authors. Do the authors work cross-site? Maybe they don&#x27;t but people use the same name across sites.<p>There are plenty of times I have put things into a database not for perf reasons but simply because it&#x27;s easier to do queries that way than to write a bunch of bespoke logic at each variant of certain queries, simply due to ownership arrows being all over the place</div><br/></div></div></div></div><div id="41304708" class="c"><input type="checkbox" id="c-41304708" checked=""/><div class="controls bullet"><span class="by">minkles</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41304757">prev</a><span>|</span><a href="#41306875">next</a><span>|</span><label class="collapse" for="c-41304708">[-]</label><label class="expand" for="c-41304708">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a poor understanding and laziness. SQL is type and schema first and people hate that because it makes things hard and complicated up front. Table explosions are rare if you know what you are doing. Many people don&#x27;t any more.<p>As for join heavy, complexity, this is not necessarily a problem in reality. It&#x27;s incredibly easy to scale this out to huge systems (relatively) cheaply.<p>Believe me as they scale up, they look way less hard and less complicated than arbitrary and poorly enforced schemas in document databases. I could write an essay on how to fuck up MongoDB (or any document store) because I spent nearly 2 years unfucking one.</div><br/></div></div><div id="41306875" class="c"><input type="checkbox" id="c-41306875" checked=""/><div class="controls bullet"><span class="by">ekimekim</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41304708">prev</a><span>|</span><a href="#41306857">next</a><span>|</span><label class="collapse" for="c-41306875">[-]</label><label class="expand" for="c-41306875">[1 more]</label></div><br/><div class="children"><div class="content">This is changing. Postgres (as you noted) supports JSON, and it also has excellent native support for arrays, range types, and composite types. For example:<p><pre><code>    CREATE TYPE number_with_unit (
        value DOUBLE PRECISION,
        unit TEXT
    );

    CREATE TABLE example (
        height number_with_unit, -- our composite type, eg. (6, &#x27;ft&#x27;) or (180, &#x27;cm&#x27;)
        known_aliases TEXT[], -- list of string
        active_times TSRANGE, -- time range, ie. (start, end) timestamp pair
    );

    SELECT height.unit,
           known_aliases[1] AS primary_alias,
           upper(active_times) - lower(active_times) AS time_active 
    FROM example;</code></pre></div><br/></div></div><div id="41306857" class="c"><input type="checkbox" id="c-41306857" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41306875">prev</a><span>|</span><a href="#41304651">next</a><span>|</span><label class="collapse" for="c-41306857">[-]</label><label class="expand" for="c-41306857">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Something thats always bugged me about relational database modelling is how you have to use table relationships for everything.<p>This is pretty much the definition of what a RDBMS is.  The tables provide the relations via designated columns.  Relation navigation is therefore possible in either direction given an established relationship and very often possible starting from any table in the pathological case.<p>If this conceptual model is not appropriate, it is best not to use it to begin with.<p>&gt; This problem is heightened by the fact that a SQL table typically can&#x27;t store composite types.<p>That is not what RDBMS&#x27; are designed to do, even though many vendors now support some form of composite data types (like JSON).  Just like a moped is not designed to move a family across a continent.<p>Pick the persistent storage mechanism which best fits the problem at hand:<p>- If the problem calls for a document structure, use a document database.<p>- If the problem calls for a directed graph structure, use a graph database.<p>- If the problem calls for a relational structure, use a RDBMS.<p>- If the problem calls for some combination of the above, consider using multiple storage technologies.<p>None are perfect, but starting with the most appropriate persistent store can eliminate the weaknesses others would introduce in the same solution space.</div><br/></div></div><div id="41304651" class="c"><input type="checkbox" id="c-41304651" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41306857">prev</a><span>|</span><a href="#41304666">next</a><span>|</span><label class="collapse" for="c-41304651">[-]</label><label class="expand" for="c-41304651">[4 more]</label></div><br/><div class="children"><div class="content">Easier to reason about in that they don&#x27;t force you to clarify your thoughts, which will come back to bite your head off. And there&#x27;s a pretty significant long term price to be paid. I would rather write Cobol than deal with MongoDB.</div><br/><div id="41308165" class="c"><input type="checkbox" id="c-41308165" checked=""/><div class="controls bullet"><span class="by">yas_hmaheshwari</span><span>|</span><a href="#41304616">root</a><span>|</span><a href="#41304651">parent</a><span>|</span><a href="#41306690">next</a><span>|</span><label class="collapse" for="c-41308165">[-]</label><label class="expand" for="c-41308165">[1 more]</label></div><br/><div class="children"><div class="content">Nicely put!<p>I see new grads talking about MERN stack (with M for Mongo), and always have an urge to correct them that replace M with Mysql</div><br/></div></div><div id="41306690" class="c"><input type="checkbox" id="c-41306690" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41304616">root</a><span>|</span><a href="#41304651">parent</a><span>|</span><a href="#41308165">prev</a><span>|</span><a href="#41304666">next</a><span>|</span><label class="collapse" for="c-41306690">[-]</label><label class="expand" for="c-41306690">[2 more]</label></div><br/><div class="children"><div class="content">This is all nice and good but I&#x27;ve never once seen someone correctly clarify their thoughts ahead of time that doesn&#x27;t end up being the wrong model as the code evolves.<p>The only schemas that survive long term are the ones that create such a tangled ball of foreign keys that migrations are infeasible. Great advice for anyone looking to leave a legacy.</div><br/><div id="41308028" class="c"><input type="checkbox" id="c-41308028" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41304616">root</a><span>|</span><a href="#41306690">parent</a><span>|</span><a href="#41304666">next</a><span>|</span><label class="collapse" for="c-41308028">[-]</label><label class="expand" for="c-41308028">[1 more]</label></div><br/><div class="children"><div class="content">At least they exist, and force you to refactor the code to match reality.<p>Document databases tend to take on a life of their own; and since they encourage shortcuts, the slope is typically down.</div><br/></div></div></div></div></div></div><div id="41304666" class="c"><input type="checkbox" id="c-41304666" checked=""/><div class="controls bullet"><span class="by">jeeyoungk</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41304651">prev</a><span>|</span><a href="#41305471">next</a><span>|</span><label class="collapse" for="c-41304666">[-]</label><label class="expand" for="c-41304666">[1 more]</label></div><br/><div class="children"><div class="content">+1<p>For example, BigQuery has natural support for arrays and nested data, and it&#x27;s quite nice &#x2F; essential for good data modeling. For example, &quot;tags&quot; can be stored as `Array&lt;Struct&lt;Key, Value&gt;&gt;`, and this can be used to implement things like, &quot;search with fields with particular tags&quot;.<p>This reduces the cognitive burden of remembering which tables join with which, especially if we know that a relationship is solely relevant in one context. I.e. Tags can only be joined to the main table, and no other joins are sensical.</div><br/></div></div><div id="41305471" class="c"><input type="checkbox" id="c-41305471" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41304666">prev</a><span>|</span><a href="#41307830">next</a><span>|</span><label class="collapse" for="c-41305471">[-]</label><label class="expand" for="c-41305471">[2 more]</label></div><br/><div class="children"><div class="content">Non-scalar data violates 1NF [0]. You _can_ have composite types, arrays, JSON, etc. as others have said, but you are likely giving up relational integrity in doing so, which is the raison d&#x27;être of RDBMS. The reason they&#x27;re so strict is to protect you from yourself (and others). When you get a foreign key violation, that should be cause for alarm, not an annoyance to figure out how to overcome.<p>&gt; Solving every problem with tables might seem clever from a technical perspective, but its just not how humans think.<p>Not without practice, no. You can in fact learn to do data modeling.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;First_normal_form" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;First_normal_form</a></div><br/><div id="41307182" class="c"><input type="checkbox" id="c-41307182" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#41304616">root</a><span>|</span><a href="#41305471">parent</a><span>|</span><a href="#41307830">next</a><span>|</span><label class="collapse" for="c-41307182">[-]</label><label class="expand" for="c-41307182">[1 more]</label></div><br/><div class="children"><div class="content">Composite types can be atomic--a string is a composite type. The point (123, 456) is a composite type but is atomic.<p>Good discussion at <a href="https:&#x2F;&#x2F;dba.stackexchange.com&#x2F;questions&#x2F;2342&#x2F;what-is-atomic-relation-in-first-normal-form" rel="nofollow">https:&#x2F;&#x2F;dba.stackexchange.com&#x2F;questions&#x2F;2342&#x2F;what-is-atomic-...</a></div><br/></div></div></div></div><div id="41307830" class="c"><input type="checkbox" id="c-41307830" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41305471">prev</a><span>|</span><a href="#41305411">next</a><span>|</span><label class="collapse" for="c-41307830">[-]</label><label class="expand" for="c-41307830">[1 more]</label></div><br/><div class="children"><div class="content">Like some siblings mention, this is the object-relational impedance mismatch. A decent ORM like SQLAlchemy goes some way to closing this gap. Less good ORMs like Django don&#x27;t help much at all, though.<p>When you talk about &quot;just&quot; using nested data in your database you seem to be forgetting a whole load of problems that relational databases solve like concurrency issues, write performance, data integrity and consistency etc. The book <i>Designing Data-Intensive Applications</i> by Kleppmann is an essential read.</div><br/></div></div><div id="41305411" class="c"><input type="checkbox" id="c-41305411" checked=""/><div class="controls bullet"><span class="by">Swizec</span><span>|</span><a href="#41304616">parent</a><span>|</span><a href="#41307830">prev</a><span>|</span><a href="#41302544">next</a><span>|</span><label class="collapse" for="c-41305411">[-]</label><label class="expand" for="c-41305411">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Like, you can&#x27;t make a column of lists-of-strings.<p>Most relational databases have supported lists-of-strings (arrays) for about 10 years now. All of them supported lists-of-strings even before that, if you were okay doing a bit of app-level work on top of your SQL.<p>Relational databases these days support full JSON. And they&#x27;re faster at it than many json-first databases :)<p>edit: Actually I&#x27;m wrong. SQL added support for arrays in 1999, a full 25 years ago.
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SQL:1999" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SQL:1999</a> <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;30109111&#x2F;at-what-version-of-the-sql-standard-did-arrays-appear" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;30109111&#x2F;at-what-version...</a></div><br/></div></div></div></div><div id="41302544" class="c"><input type="checkbox" id="c-41302544" checked=""/><div class="controls bullet"><span class="by">jamesblonde</span><span>|</span><a href="#41304616">prev</a><span>|</span><a href="#41304372">next</a><span>|</span><label class="collapse" for="c-41302544">[-]</label><label class="expand" for="c-41302544">[15 more]</label></div><br/><div class="children"><div class="content">Prof Murat is calling for examples of how LLMs can help make DBs more usable.<p>I note that Julius.ai is making data analytics easier - just upload some data and ask for some charts and it does an ok job.<p>The problem of going from natural language to SQL is still a far from solved problem. The main benchmark for this is Bird-Bench and accuracy is only in the high 60s - <a href="https:&#x2F;&#x2F;bird-bench.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bird-bench.github.io&#x2F;</a><p>I have been working on making tables queryable using function calling, where you a fixed number of canned queries based on the primary key and an event-time column. PyData talk on this - <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dRcjTe5qgwM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dRcjTe5qgwM</a></div><br/><div id="41303420" class="c"><input type="checkbox" id="c-41303420" checked=""/><div class="controls bullet"><span class="by">jalcazar</span><span>|</span><a href="#41302544">parent</a><span>|</span><a href="#41302845">next</a><span>|</span><label class="collapse" for="c-41303420">[-]</label><label class="expand" for="c-41303420">[2 more]</label></div><br/><div class="children"><div class="content">Gemini generating SQL queries from natural language could be an example of AI making DBs more usable. There is more people speaking natural language than SQL<p><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;bigquery&#x2F;docs&#x2F;write-sql-gemini#prompt_to_generate_sql_queries" rel="nofollow">https:&#x2F;&#x2F;cloud.google.com&#x2F;bigquery&#x2F;docs&#x2F;write-sql-gemini#prom...</a></div><br/><div id="41303726" class="c"><input type="checkbox" id="c-41303726" checked=""/><div class="controls bullet"><span class="by">jamesblonde</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41303420">parent</a><span>|</span><a href="#41302845">next</a><span>|</span><label class="collapse" for="c-41303726">[-]</label><label class="expand" for="c-41303726">[1 more]</label></div><br/><div class="children"><div class="content">Bird-bench has gemini on 69.03% on the test set.
That is a long way from something you can build on.</div><br/></div></div></div></div><div id="41302845" class="c"><input type="checkbox" id="c-41302845" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41302544">parent</a><span>|</span><a href="#41303420">prev</a><span>|</span><a href="#41302959">next</a><span>|</span><label class="collapse" for="c-41302845">[-]</label><label class="expand" for="c-41302845">[11 more]</label></div><br/><div class="children"><div class="content"><i>&gt; The problem of going from natural language to SQL is still a far from solved problem.</i><p>Is there any improvement going from natural language to something other than SQL? Certainly SQL can be cut out of the picture if it is what confuses these systems.</div><br/><div id="41302926" class="c"><input type="checkbox" id="c-41302926" checked=""/><div class="controls bullet"><span class="by">zerodensity</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41302845">parent</a><span>|</span><a href="#41302959">next</a><span>|</span><label class="collapse" for="c-41302926">[-]</label><label class="expand" for="c-41302926">[10 more]</label></div><br/><div class="children"><div class="content">What would that &quot;something other&quot; be? If the goal is to talk to a SQL database the output from the LLM would benefit from being SQL.</div><br/><div id="41303171" class="c"><input type="checkbox" id="c-41303171" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41302926">parent</a><span>|</span><a href="#41302959">next</a><span>|</span><label class="collapse" for="c-41303171">[-]</label><label class="expand" for="c-41303171">[9 more]</label></div><br/><div class="children"><div class="content"><i>&gt; What would that &quot;something other&quot; be?</i><p>Depends. Where is the problem? Is it the quirkiness of SQL? Perhaps something like QUEL or Datalog would yield better results? Is it declarative programming that it struggles with? GPT, for example, seems to be optimized for Python in particular. Perhaps an imperative approach is easier for the LLM to understand? It doesn&#x27;t even have to be a language suitable for humans. Perhaps it would fare better with something like SQLite&#x27;s byte code language?<p><i>&gt; If the goal is to talk to a SQL database</i><p>While being able to talk to an existing SQL database would no doubt simplify the problem in a lot of cases, which is of merit, I doubt that is the actual goal. The user doesn&#x27;t care about the technology, as they say. Getting the expected results out of the database is undoubtedly the actual goal.<p>SQL as a target is all well and good if it works reliably, but the claim was that it doesn&#x27;t. If some other target performs better, there is no need to cling to SQL. It is merely an implementation detail.</div><br/><div id="41303350" class="c"><input type="checkbox" id="c-41303350" checked=""/><div class="controls bullet"><span class="by">sgbeal</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41303171">parent</a><span>|</span><a href="#41303208">next</a><span>|</span><label class="collapse" for="c-41303350">[-]</label><label class="expand" for="c-41303350">[2 more]</label></div><br/><div class="children"><div class="content">&gt; there is no need to cling to SQL. It is merely an implementation detail.<p>It is, in fact, also the interface. To use your example of SQLite bytecode: once your tool generates it, there is no way to feed that into SQLite. The bytecode is an implementation detail, with SQL being the public interface.</div><br/><div id="41303411" class="c"><input type="checkbox" id="c-41303411" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41303350">parent</a><span>|</span><a href="#41303208">next</a><span>|</span><label class="collapse" for="c-41303411">[-]</label><label class="expand" for="c-41303411">[1 more]</label></div><br/><div class="children"><div class="content">But, to stick with your example, you can then modify SQLite to accept byte code input – or straight up write your own database engine that uses said byte code. We already know how to solve that kind of problem. This is, comparatively speaking, child&#x27;s play.<p>It is recognized that SQL as a target would theoretically provide a less labour intensive path for reasons of integrating into what already exists, but that only holds if natural language to SQL gets solved, and is not enough harder to solve than an alternative target.<p>A reasonable stretch goal, but if another target gets you there first, it would be foolhardy to cling to SQL. Replacing the database interface is a <i>much</i> simpler problem to solve.</div><br/></div></div></div></div><div id="41303208" class="c"><input type="checkbox" id="c-41303208" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41303171">parent</a><span>|</span><a href="#41303350">prev</a><span>|</span><a href="#41302959">next</a><span>|</span><label class="collapse" for="c-41303208">[-]</label><label class="expand" for="c-41303208">[6 more]</label></div><br/><div class="children"><div class="content">I think the problem is the quirkiness on the English side, not the SQL side. You could translate datalog to SQL or vice versa, but understanding intention from arbitrary english is much harder. And often query results must be 100% accurate and reliable.</div><br/><div id="41303301" class="c"><input type="checkbox" id="c-41303301" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41303208">parent</a><span>|</span><a href="#41302959">next</a><span>|</span><label class="collapse" for="c-41303301">[-]</label><label class="expand" for="c-41303301">[5 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I think the problem is the quirkiness on the English side</i><p>While likely, the question asked if there was any improvement shown with other targets to validate that assumption. There is no benefit in thinking.<p><i>&gt; And often query results must be 100% accurate and reliable.</i><p>It seems that is impossible. Even the human programmers struggle to reliably convert natural language to SQL according to the aforementioned test study. They are slightly better than the known alternatives, but far from perfect. But if another target can get closer to human-level performance, that is significant.</div><br/><div id="41304504" class="c"><input type="checkbox" id="c-41304504" checked=""/><div class="controls bullet"><span class="by">yuliyp</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41303301">parent</a><span>|</span><a href="#41304663">next</a><span>|</span><label class="collapse" for="c-41304504">[-]</label><label class="expand" for="c-41304504">[2 more]</label></div><br/><div class="children"><div class="content">When I find someone claiming a suspicious data analysis result I can ask them for the SQL and investigate it to see if there&#x27;s a bug in it (or further investigate where the data being queried comes from). If the abstraction layer between LLM prompt and data back is removed, I&#x27;m left with (just like other LLM answers) some words but no way to know if they&#x27;re correct.</div><br/><div id="41305643" class="c"><input type="checkbox" id="c-41305643" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41304504">parent</a><span>|</span><a href="#41304663">next</a><span>|</span><label class="collapse" for="c-41305643">[-]</label><label class="expand" for="c-41305643">[1 more]</label></div><br/><div class="children"><div class="content">1. How would the abstraction be removed? Language generation is what LLMs do; a language abstraction is what you are getting out, no matter what. There is no magic involved.<p>2. The language has to represent a valid computer program. That is as true of SQL as any other target. You can know that it is correct by reading it.</div><br/></div></div></div></div><div id="41304663" class="c"><input type="checkbox" id="c-41304663" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41303301">parent</a><span>|</span><a href="#41304504">prev</a><span>|</span><a href="#41302959">next</a><span>|</span><label class="collapse" for="c-41304663">[-]</label><label class="expand" for="c-41304663">[2 more]</label></div><br/><div class="children"><div class="content">Once you have SQL, you have datalog. Once you have datalog, you have SQL. The problem isn&#x27;t the target, it is getting sufficiently rigorous and structured output from the LLM to target anything.</div><br/><div id="41305666" class="c"><input type="checkbox" id="c-41305666" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41302544">root</a><span>|</span><a href="#41304663">parent</a><span>|</span><a href="#41302959">next</a><span>|</span><label class="collapse" for="c-41305666">[-]</label><label class="expand" for="c-41305666">[1 more]</label></div><br/><div class="children"><div class="content">So you already claimed, but, still, curiously we have no answer to the question. If you don&#x27;t know, why not just say so?<p>That said, if you have ever used these tools to generate code, you will know that they are much better at some languages than others. In the general case, the target really is the problem sometimes. Does that carry into this particular narrow case? I don&#x27;t know. What do the comparison results show?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41302959" class="c"><input type="checkbox" id="c-41302959" checked=""/><div class="controls bullet"><span class="by">7thpower</span><span>|</span><a href="#41302544">parent</a><span>|</span><a href="#41302845">prev</a><span>|</span><a href="#41304372">next</a><span>|</span><label class="collapse" for="c-41302959">[-]</label><label class="expand" for="c-41302959">[1 more]</label></div><br/><div class="children"><div class="content">This was basically the only reasonable way I found to create a consistent user experience. I think of them as natural language BI, where you have canned reports to answer common categories of questions.</div><br/></div></div></div></div><div id="41304372" class="c"><input type="checkbox" id="c-41304372" checked=""/><div class="controls bullet"><span class="by">flowerlad</span><span>|</span><a href="#41302544">prev</a><span>|</span><a href="#41305924">next</a><span>|</span><label class="collapse" for="c-41304372">[-]</label><label class="expand" for="c-41304372">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Users cannot interact with the database directly</i><p>It is not super hard to find UI designed for end users, these days.<p>If you know the basics such as what a relational database is, then here’s is a good UI: <a href="https:&#x2F;&#x2F;visualdb.com" rel="nofollow">https:&#x2F;&#x2F;visualdb.com</a></div><br/><div id="41304764" class="c"><input type="checkbox" id="c-41304764" checked=""/><div class="controls bullet"><span class="by">minkles</span><span>|</span><a href="#41304372">parent</a><span>|</span><a href="#41305924">next</a><span>|</span><label class="collapse" for="c-41304764">[-]</label><label class="expand" for="c-41304764">[2 more]</label></div><br/><div class="children"><div class="content">People have forgotten we had this back in 1997 with MS Access.<p>I built a whole ERP system with it, single handedly including the hardware, software, networking and the workstation deployments without really breaking a sweat. We have gone off the rails somewhere.</div><br/><div id="41304862" class="c"><input type="checkbox" id="c-41304862" checked=""/><div class="controls bullet"><span class="by">flowerlad</span><span>|</span><a href="#41304372">root</a><span>|</span><a href="#41304764">parent</a><span>|</span><a href="#41305924">next</a><span>|</span><label class="collapse" for="c-41304862">[-]</label><label class="expand" for="c-41304862">[1 more]</label></div><br/><div class="children"><div class="content">Right but Access is outdated. Microsoft tried to make a web version of Access, but gave up. Now they recommend Power Apps but it’s support for databases is pretty weak.</div><br/></div></div></div></div></div></div><div id="41305924" class="c"><input type="checkbox" id="c-41305924" checked=""/><div class="controls bullet"><span class="by">hi41</span><span>|</span><a href="#41304372">prev</a><span>|</span><a href="#41305920">next</a><span>|</span><label class="collapse" for="c-41305924">[-]</label><label class="expand" for="c-41305924">[3 more]</label></div><br/><div class="children"><div class="content">How do you create the correct indexes? If we create index for all the conditions in a where clause wouldn’t the number of indexes become too many? I don’t fully grasp how to best create indexes. Does anyone have good reference and examples?</div><br/><div id="41306859" class="c"><input type="checkbox" id="c-41306859" checked=""/><div class="controls bullet"><span class="by">beart</span><span>|</span><a href="#41305924">parent</a><span>|</span><a href="#41306886">next</a><span>|</span><label class="collapse" for="c-41306859">[-]</label><label class="expand" for="c-41306859">[1 more]</label></div><br/><div class="children"><div class="content">Creating good indexes is a nuanced problem to solve. It is highly dependent on the primary use case of the data. For instance, if you have a table representing varieties of beer, you are likely to present an interface for searching by brand, or type (ipa, pilsner). Those would be good targets for indexes. However, you probably won&#x27;t often search by color, so it won&#x27;t be worth indexing that column.<p>Typically I would add any indexes initially that I know will be heavy hitters, then refine as needed based on actual use. Most databases provide tools to help identify missing indexes for common queries.</div><br/></div></div><div id="41306886" class="c"><input type="checkbox" id="c-41306886" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#41305924">parent</a><span>|</span><a href="#41306859">prev</a><span>|</span><a href="#41305920">next</a><span>|</span><label class="collapse" for="c-41306886">[-]</label><label class="expand" for="c-41306886">[1 more]</label></div><br/><div class="children"><div class="content">Mostly where EXPLAIN ANALYZE points to.</div><br/></div></div></div></div><div id="41305920" class="c"><input type="checkbox" id="c-41305920" checked=""/><div class="controls bullet"><span class="by">delifue</span><span>|</span><a href="#41305924">prev</a><span>|</span><a href="#41303000">next</a><span>|</span><label class="collapse" for="c-41305920">[-]</label><label class="expand" for="c-41305920">[1 more]</label></div><br/><div class="children"><div class="content">&gt; “Find all flights from Detroit to Beijing” ... which must be joined twice with flight info to express our query<p>Actually this can be done by nested query, without joining. I prefer nested query than joins. Because join is &quot;global&quot; and nested query is &quot;local&quot; (global means interfering with the whole SQL statement). The local one is easier to understand.</div><br/></div></div><div id="41303000" class="c"><input type="checkbox" id="c-41303000" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41305920">prev</a><span>|</span><a href="#41305377">next</a><span>|</span><label class="collapse" for="c-41303000">[-]</label><label class="expand" for="c-41303000">[3 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s a huge difference between how you design:<p>1. A database that&#x27;s meant to be understood by programmers, make queries by the application efficient in space and time, and provide strong referential integrity.<p>2. A database that&#x27;s meant to be played with by humans, where duplication is fine, referential integrity is a nice-to-have, every column is okay to be nullable, tables should contain complete objects as understood by the user that map 1-1ish to the real world, that eliminate as many opaque ids as feasible, and foreign keys might exist but aren&#x27;t enforced in any direction.<p>The latter database is far more ergonomic and you won&#x27;t run up against a user frustratingly bashing their keyboard because the database just refuses to do what they want. The stakes in #2 style databases are extremely low-- let the user destroy their copy of the database it&#x27;s fine, we can reload from the last save.<p>The nice thing is that it seems very possible to go from #1 -&gt; #2 mechanically, and hand that off to the users who want to play with it.</div><br/><div id="41303720" class="c"><input type="checkbox" id="c-41303720" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#41303000">parent</a><span>|</span><a href="#41304573">next</a><span>|</span><label class="collapse" for="c-41303720">[-]</label><label class="expand" for="c-41303720">[1 more]</label></div><br/><div class="children"><div class="content">The 4GL dream hinges on figuring out how to transition from #2 -&gt; #1 seamlessly. The spectrum is wider and more complex than &quot;Excel -&gt; Postgres&quot; but even solving that journey would be a good start. It could save us all from a whole a bunch of ~needless engineering work.<p>&gt; it seems very possible to go from #1 -&gt; #2 mechanically, and hand that off to the users who want to play with it<p>NocoDB seems like a reasonable attempt of taking this approach for Postgres.</div><br/></div></div><div id="41304573" class="c"><input type="checkbox" id="c-41304573" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41303000">parent</a><span>|</span><a href="#41303720">prev</a><span>|</span><a href="#41305377">next</a><span>|</span><label class="collapse" for="c-41304573">[-]</label><label class="expand" for="c-41304573">[1 more]</label></div><br/><div class="children"><div class="content">Some technical design elements can enable this style of non-programmer usage that most databases engines do not currently support.<p>First, treat each column separately in the physical engine (column store). Users ought to never need to worry about column count limits, row byte limits, or sparsity. Similarly, schema operators such as adding, removing, or reordering columns ought to always be instant atomic changes.<p>Imagine how much faster it would be possible to explore the schema design space if changes were instant and didn’t require “migration scripts” or data copies from an old table to a new one. It would make the database feel more like a spreadsheet!<p>Next, there ought to be Git-style forking and merging so that creating a test environment should also be a lightweight operation just like creating a local branch in a Git repo. Merging changes can be either schema only or schema+data -- the latter to support slowly-changing “master data” editing workflows. Currently, few if any database support the equivalent of a pull request with reviews to merge data. Hence the excessively complex access controls that could all be replaced with a single &quot;peer review&quot; operation.<p>I’ve seen a fancy category-theoretic approach where forks of the database can receive live data updates from production. This would allow UAT and similar environments to be evergreen with zero infrastructure code such as nightly ETL sync jobs.<p>Many operational tasks can be eliminated by tying live environments of both the code and data to Git branches of a single (mono) repo. Now the code and data schema <i>can’t</i> go out of sync! Literally impossible. No need for scaffolding, or ORMs, or any of those layers of overcomplicted abstractions! The schema is just “there”, in the repo, always representing reality.<p>Sprinkle on a Microsoft Access style form designer but with HTML5 and guest user support and you have a billion dollar product.</div><br/></div></div></div></div><div id="41305377" class="c"><input type="checkbox" id="c-41305377" checked=""/><div class="controls bullet"><span class="by">kak3a</span><span>|</span><a href="#41303000">prev</a><span>|</span><a href="#41303355">next</a><span>|</span><label class="collapse" for="c-41305377">[-]</label><label class="expand" for="c-41305377">[1 more]</label></div><br/><div class="children"><div class="content">Author talked about usability problem with database, it&#x27;s oxymoron usability problem in this site where all the text are in gray which makes reading very painful. Had to use &quot;Darken Text&quot; Chrome ext so it is not killing my eye!</div><br/></div></div><div id="41303355" class="c"><input type="checkbox" id="c-41303355" checked=""/><div class="controls bullet"><span class="by">trollied</span><span>|</span><a href="#41305377">prev</a><span>|</span><a href="#41303460">next</a><span>|</span><label class="collapse" for="c-41303355">[-]</label><label class="expand" for="c-41303355">[7 more]</label></div><br/><div class="children"><div class="content">I think the core of this is the age old problem that people would rather invent crappy technologies that end up being a pain instead of taking some time to learn a standard, SQL.<p>SQL is not going to go away. It&#x27;s relatively easy to learn.</div><br/><div id="41308197" class="c"><input type="checkbox" id="c-41308197" checked=""/><div class="controls bullet"><span class="by">yas_hmaheshwari</span><span>|</span><a href="#41303355">parent</a><span>|</span><a href="#41303943">next</a><span>|</span><label class="collapse" for="c-41308197">[-]</label><label class="expand" for="c-41308197">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree!<p>I was thinking of this quote about regex, apt in this situation:<p>&quot;A programmer had a problem with Sql.  So he thought of using an ORM. Now he has two problems&quot;<p>Choose your battles wisely</div><br/></div></div><div id="41303943" class="c"><input type="checkbox" id="c-41303943" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41303355">parent</a><span>|</span><a href="#41308197">prev</a><span>|</span><a href="#41303543">next</a><span>|</span><label class="collapse" for="c-41303943">[-]</label><label class="expand" for="c-41303943">[1 more]</label></div><br/><div class="children"><div class="content">In other words, people would rather make many tiny, seemingly easy steps than a few really impactful but seemingly arduous steps.<p>Teach SQL a spoonful at a time then, I suppose. Do not start from having the students to read Codd&#x27;s original papers.<p>OTOH SQL is not the best <i>language:</i> it&#x27;s both too wordy and too terse, it&#x27;s not composable in many important cases, it does not map nicely to set-theoretic operations. But a transpiler to SQL that would offer a vastly better experience is yet to take the world by storm.</div><br/></div></div><div id="41303543" class="c"><input type="checkbox" id="c-41303543" checked=""/><div class="controls bullet"><span class="by">morkalork</span><span>|</span><a href="#41303355">parent</a><span>|</span><a href="#41303943">prev</a><span>|</span><a href="#41303996">next</a><span>|</span><label class="collapse" for="c-41303543">[-]</label><label class="expand" for="c-41303543">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s shocking how many developers are afraid of SQL, it hurts my soul.</div><br/><div id="41304779" class="c"><input type="checkbox" id="c-41304779" checked=""/><div class="controls bullet"><span class="by">minkles</span><span>|</span><a href="#41303355">root</a><span>|</span><a href="#41303543">parent</a><span>|</span><a href="#41304104">next</a><span>|</span><label class="collapse" for="c-41304779">[-]</label><label class="expand" for="c-41304779">[1 more]</label></div><br/><div class="children"><div class="content">20+ years ago no one was afraid of it. Our front end web folk were doing SQL quite happily. Now they can&#x27;t even consume an API without problems.<p>I think the demand for staff has lowered standards considerably.</div><br/></div></div><div id="41304104" class="c"><input type="checkbox" id="c-41304104" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41303355">root</a><span>|</span><a href="#41303543">parent</a><span>|</span><a href="#41304779">prev</a><span>|</span><a href="#41303996">next</a><span>|</span><label class="collapse" for="c-41304104">[-]</label><label class="expand" for="c-41304104">[1 more]</label></div><br/><div class="children"><div class="content">I honestly don&#x27;t get it, it&#x27;s not rocket science, and compared to freakin MongoDB it&#x27;s a Sunday walk in the park.</div><br/></div></div></div></div></div></div><div id="41303460" class="c"><input type="checkbox" id="c-41303460" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#41303355">prev</a><span>|</span><label class="collapse" for="c-41303460">[-]</label><label class="expand" for="c-41303460">[8 more]</label></div><br/><div class="children"><div class="content">&gt; You youngins may not remember, but pre-2005 we had to call a travel agent to book our flights and get paper tickets in return. This sucked, we don&#x27;t have any transparency in to the process, we couldn&#x27;t explore options (price, convenience, dates, airports) and customize our trip. Having access to flight booking via web was really a great improvement for user experience.<p>I&#x27;m going to disagree. I could call my travel agent and say &quot;I am going to Chicago on &lt;date&gt; I need to be there by &lt;time&gt; call me back with a couple of nonstop options. And I&#x27;ll need a room at the Hilton and Towers for two nights.&quot;<p>vs. today I can spend my own time navigating travel sites, avoiding their dark patterns, wondering if I&#x27;m <i>really</i> getting the best prices, making sure I understand the terms (is this refundable? are any checked bags included?) etc and then do the same for the hotel booking.<p>If you work in a business with a travel department or assistants who can manage your travel you have an idea, compared to the hassle of doing it all yourself.</div><br/><div id="41303808" class="c"><input type="checkbox" id="c-41303808" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41303460">parent</a><span>|</span><a href="#41303795">next</a><span>|</span><label class="collapse" for="c-41303808">[-]</label><label class="expand" for="c-41303808">[1 more]</label></div><br/><div class="children"><div class="content">As usual:<p>* Relegate it to an agent: have to trust the agent, have to pay the agent, saves you time.<p>* DIY: have to spend time, have to have some expertise, saves you money.<p>A middle ground existed back in the day, too: you could visit a physical office of an airline and buy a physical ticket there, at the cost of some time and the narrow choice, but it saved you some money compared to an agent, and the clerk could provide a limited assistance.</div><br/></div></div><div id="41303795" class="c"><input type="checkbox" id="c-41303795" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#41303460">parent</a><span>|</span><a href="#41303808">prev</a><span>|</span><a href="#41303965">next</a><span>|</span><label class="collapse" for="c-41303795">[-]</label><label class="expand" for="c-41303795">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  wondering if I&#x27;m really getting the best prices<p>Curious why you assume you were getting the best price before?</div><br/><div id="41303858" class="c"><input type="checkbox" id="c-41303858" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41303460">root</a><span>|</span><a href="#41303795">parent</a><span>|</span><a href="#41303965">next</a><span>|</span><label class="collapse" for="c-41303858">[-]</label><label class="expand" for="c-41303858">[3 more]</label></div><br/><div class="children"><div class="content">But &quot;before&quot; you did not have an option and thus the need to wonder!<p>&quot;One who has a watch always knows what time is it. One who has two watches is never certain about anything.&quot;</div><br/><div id="41304166" class="c"><input type="checkbox" id="c-41304166" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#41303460">root</a><span>|</span><a href="#41303858">parent</a><span>|</span><a href="#41303965">next</a><span>|</span><label class="collapse" for="c-41304166">[-]</label><label class="expand" for="c-41304166">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the paradox of having too many choices. Sounds like a good thing, but it causes anxiety.</div><br/><div id="41305412" class="c"><input type="checkbox" id="c-41305412" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41303460">root</a><span>|</span><a href="#41304166">parent</a><span>|</span><a href="#41303965">next</a><span>|</span><label class="collapse" for="c-41305412">[-]</label><label class="expand" for="c-41305412">[1 more]</label></div><br/><div class="children"><div class="content">Making a choice means making decisions. Making decisions can definitely be taxing, especially when yourself or your social circle insists that decisions were &quot;good&quot;, &quot;smart&quot;, or otherwise met a standard of excellence.<p>Suddenly you end up in a situation where you need <i>to prove yourself</i>, else the smartass cousin or your own resentful self will constantly remind you how you played the fool when you could have made a much better choice, obvious in hindsight.<p>An agent (human or machine) that chooses the tickets for you because you can&#x27;t be bothered with such mundane trivialities may be quite desirable for some.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>