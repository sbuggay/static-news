<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731056467293" as="style"/><link rel="stylesheet" href="styles.css?v=1731056467293"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xnacly.me/posts/2024/rust-pldev/">Why I love Rust for tokenising and parsing</a> <span class="domain">(<a href="https://xnacly.me">xnacly.me</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>52 comments</span></div><br/><div><div id="42084603" class="c"><input type="checkbox" id="c-42084603" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#42084905">next</a><span>|</span><label class="collapse" for="c-42084603">[-]</label><label class="expand" for="c-42084603">[3 more]</label></div><br/><div class="children"><div class="content">This is, to me, an odd way to approach parsing. I get the impression the author is relatively inexperienced with Rust and the PL ideas it builds on.<p>A few notes:<p>* The AST would, I believe, be much simpler defined as an algebraic data types. It&#x27;s not like the sqlite grammar is going to randomly grow new nodes that requires the extensibility their convoluted encoding requires. The encoding they uses looks like what someone familiar with OO, but not algebraic data types, would come up with.<p>* &quot;Macros work different in most languages. However they are used for mostly the same reasons: code deduplication and less repetition.&quot; That could be said for any abstraction mechanism. E.g. functions. The defining features of macros is they run at compile-time.<p>* The work on parser combinators would be a good place to start to see how to structure parsing in a clean way.</div><br/><div id="42085195" class="c"><input type="checkbox" id="c-42085195" checked=""/><div class="controls bullet"><span class="by">huijzer</span><span>|</span><a href="#42084603">parent</a><span>|</span><a href="#42084905">next</a><span>|</span><label class="collapse" for="c-42085195">[-]</label><label class="expand" for="c-42085195">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I get the impression the author is relatively inexperienced<p>The author never claimed to be an experienced programmer. The title of the blog is &quot;Why I love ...&quot;. Your notes look fair to me, but calling out inexperience is unnecessary IMO. I love it if someone loves programming. I think that&#x27;s great. Experience will come.</div><br/><div id="42085299" class="c"><input type="checkbox" id="c-42085299" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42084603">root</a><span>|</span><a href="#42085195">parent</a><span>|</span><a href="#42084905">next</a><span>|</span><label class="collapse" for="c-42085299">[-]</label><label class="expand" for="c-42085299">[1 more]</label></div><br/><div class="children"><div class="content">If someone didn&#x27;t study the state of the art of tokenising and parsing and still wants to write about it, it&#x27;s absolutely ok to call it out as being written by someone who has only a vague idea of what they&#x27;re talking about.</div><br/></div></div></div></div></div></div><div id="42084905" class="c"><input type="checkbox" id="c-42084905" checked=""/><div class="controls bullet"><span class="by">gritzko</span><span>|</span><a href="#42084603">prev</a><span>|</span><a href="#42084220">next</a><span>|</span><label class="collapse" for="c-42084905">[-]</label><label class="expand" for="c-42084905">[2 more]</label></div><br/><div class="children"><div class="content">I have the experience of writing parsers (lexers) in Ragel, using Go, Java C++, and C.
I must say, once you have some boilerplate generator in place, raw C is as good as the Rust code the author describes. Maybe even better because simplicity.
For example, this is the most of code necessary to have a JSON parser:
<a href="https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;JSON.lex">https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;JSON.lex</a><p>In fact, that eBNF only produces the lexer. The parser part is not that impressive either, 120 LoC and quite repetitive <a href="https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;JSON.c">https:&#x2F;&#x2F;github.com&#x2F;gritzko&#x2F;librdx&#x2F;blob&#x2F;master&#x2F;JSON.c</a><p>So, I believe, a parser infrastructure evolves till it only needs eBNF to make a parser. That is the saturation point.</div><br/><div id="42085120" class="c"><input type="checkbox" id="c-42085120" checked=""/><div class="controls bullet"><span class="by">dvdkon</span><span>|</span><a href="#42084905">parent</a><span>|</span><a href="#42084220">next</a><span>|</span><label class="collapse" for="c-42085120">[-]</label><label class="expand" for="c-42085120">[1 more]</label></div><br/><div class="children"><div class="content">That repetitivness can be seen as a downside, not a virtue. And I feel that Rust&#x27;s ADTs make working with the resulting syntax tree much easier.<p>Though I agree that a little code generation and&#x2F;or macro magic can make C significantly more workable.</div><br/></div></div></div></div><div id="42084220" class="c"><input type="checkbox" id="c-42084220" checked=""/><div class="controls bullet"><span class="by">ryandv</span><span>|</span><a href="#42084905">prev</a><span>|</span><a href="#42083729">next</a><span>|</span><label class="collapse" for="c-42084220">[-]</label><label class="expand" for="c-42084220">[16 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know. Having written a small parser [0] for Forsyth-Edwards chess notation [1] Haskell takes the cake here in terms of simplicity and legibility; it reads almost as clearly as BNF, and there is very little technical ceremony involved, letting you focus on the actual grammar of whatever it is you are trying to parse.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;ryandv&#x2F;chesskell&#x2F;blob&#x2F;master&#x2F;src&#x2F;Chess&#x2F;FastFenParser.hs">https:&#x2F;&#x2F;github.com&#x2F;ryandv&#x2F;chesskell&#x2F;blob&#x2F;master&#x2F;src&#x2F;Chess&#x2F;Fa...</a><p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forsyth%E2%80%93Edwards_Notation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forsyth%E2%80%93Edwards_Notati...</a></div><br/><div id="42084398" class="c"><input type="checkbox" id="c-42084398" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42084220">parent</a><span>|</span><a href="#42084368">next</a><span>|</span><label class="collapse" for="c-42084398">[-]</label><label class="expand" for="c-42084398">[9 more]</label></div><br/><div class="children"><div class="content">Haskell definitely takes the cake in terms of leveraging parser combinators, but you’re still stuck with Haskell to deal with the result.</div><br/><div id="42085385" class="c"><input type="checkbox" id="c-42085385" checked=""/><div class="controls bullet"><span class="by">zxexz</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084398">parent</a><span>|</span><a href="#42084980">next</a><span>|</span><label class="collapse" for="c-42085385">[-]</label><label class="expand" for="c-42085385">[1 more]</label></div><br/><div class="children"><div class="content">As someone who really enjoys Haskell, I used to think like that. But I realized for problems like parsing, it really is just excellent.</div><br/></div></div><div id="42084980" class="c"><input type="checkbox" id="c-42084980" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084398">parent</a><span>|</span><a href="#42085385">prev</a><span>|</span><a href="#42084933">next</a><span>|</span><label class="collapse" for="c-42084980">[-]</label><label class="expand" for="c-42084980">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what they call a &quot;win-win&quot;.</div><br/></div></div><div id="42084933" class="c"><input type="checkbox" id="c-42084933" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084398">parent</a><span>|</span><a href="#42084980">prev</a><span>|</span><a href="#42084712">next</a><span>|</span><label class="collapse" for="c-42084933">[-]</label><label class="expand" for="c-42084933">[2 more]</label></div><br/><div class="children"><div class="content">For some of us, &quot;being stuck with Haskell&quot; isn&#x27;t a problem.</div><br/><div id="42085198" class="c"><input type="checkbox" id="c-42085198" checked=""/><div class="controls bullet"><span class="by">anilakar</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084933">parent</a><span>|</span><a href="#42084712">next</a><span>|</span><label class="collapse" for="c-42085198">[-]</label><label class="expand" for="c-42085198">[1 more]</label></div><br/><div class="children"><div class="content">For the rest, being stuck with real-world problems instead of self-inflicted ones is preferable :-)</div><br/></div></div></div></div><div id="42084712" class="c"><input type="checkbox" id="c-42084712" checked=""/><div class="controls bullet"><span class="by">instig007</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084398">parent</a><span>|</span><a href="#42084933">prev</a><span>|</span><a href="#42084984">next</a><span>|</span><label class="collapse" for="c-42084712">[-]</label><label class="expand" for="c-42084712">[1 more]</label></div><br/><div class="children"><div class="content">don&#x27;t make it sound as if it&#x27;s bad, it&#x27;s actually superb on all these levels: the typelevel, the SMP runtime,  and throughput.</div><br/></div></div><div id="42084984" class="c"><input type="checkbox" id="c-42084984" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084398">parent</a><span>|</span><a href="#42084712">prev</a><span>|</span><a href="#42084368">next</a><span>|</span><label class="collapse" for="c-42084984">[-]</label><label class="expand" for="c-42084984">[3 more]</label></div><br/><div class="children"><div class="content">$ echo &quot;Haskell&quot; | sed &#x27;s&#x2F;ke&#x2F;-ki&#x27;<p>Has-kill<p>$</div><br/><div id="42085002" class="c"><input type="checkbox" id="c-42085002" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084984">parent</a><span>|</span><a href="#42084368">next</a><span>|</span><label class="collapse" for="c-42085002">[-]</label><label class="expand" for="c-42085002">[2 more]</label></div><br/><div class="children"><div class="content">| sed &#x27;&#x2F;k&#x2F;sk&#x27;<p>Has-skill<p>$</div><br/><div id="42085207" class="c"><input type="checkbox" id="c-42085207" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42085002">parent</a><span>|</span><a href="#42084368">next</a><span>|</span><label class="collapse" for="c-42085207">[-]</label><label class="expand" for="c-42085207">[1 more]</label></div><br/><div class="children"><div class="content">Write the full transform in Haskell?</div><br/></div></div></div></div></div></div></div></div><div id="42084368" class="c"><input type="checkbox" id="c-42084368" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42084220">parent</a><span>|</span><a href="#42084398">prev</a><span>|</span><a href="#42084789">next</a><span>|</span><label class="collapse" for="c-42084368">[-]</label><label class="expand" for="c-42084368">[5 more]</label></div><br/><div class="children"><div class="content">But this is not unaided Haskell, it&#x27;s a parser combinator library, isn&#x27;t it?<p>Do you see an obvious reason why a similar approach won&#x27;t work in Rust? E.g. winnow [1] seems to offer declarative enough style, and there are several more parser combinator libraries in Rust.<p>[1]: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;winnow&#x2F;latest&#x2F;winnow&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;winnow&#x2F;latest&#x2F;winnow&#x2F;</a></div><br/><div id="42084635" class="c"><input type="checkbox" id="c-42084635" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084368">parent</a><span>|</span><a href="#42084968">next</a><span>|</span><label class="collapse" for="c-42084635">[-]</label><label class="expand" for="c-42084635">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    data Color = Color
        { r :: Word8
        , b :: Word8
        , c :: Word8
        } deriving Show

    hex_primary :: Parser Word8
    hex_primary = toWord8 &lt;$&gt; sat isHexDigit &lt;*&gt; sat isHexDigit
        where toWord8 a b = read [&#x27;0&#x27;, &#x27;x&#x27;, a, b]

    hex_color :: Parser Color
    hex_color = do
        _ &lt;- char &#x27;#&#x27;
        Color &lt;$&gt; hex_primary &lt;*&gt; hex_primary &lt;*&gt; hex_primary
</code></pre>
Sure, it works in Rust, but it&#x27;s a pretty far cry from being as simple or legible - there&#x27;s a lot of extra boilerplate in the Rust.</div><br/><div id="42085096" class="c"><input type="checkbox" id="c-42085096" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084635">parent</a><span>|</span><a href="#42085214">next</a><span>|</span><label class="collapse" for="c-42085096">[-]</label><label class="expand" for="c-42085096">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a stretch to call parser combinator code in Haskell simple or legible. Most Haskell code is simple and legible if you know enough Haskell to read it, but Haskell isn&#x27;t exactly a simple or legible language.<p>Haskell demonstrates the use of parser combinators very well, but I&#x27;d still use parser combinators in another language. Parser combinators are implemented in plenty of languages, including Rust, and actually doing anything with the parsed output becomes a lot easier once you leave the Haskell domain.</div><br/></div></div><div id="42085214" class="c"><input type="checkbox" id="c-42085214" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084635">parent</a><span>|</span><a href="#42085096">prev</a><span>|</span><a href="#42084968">next</a><span>|</span><label class="collapse" for="c-42085214">[-]</label><label class="expand" for="c-42085214">[1 more]</label></div><br/><div class="children"><div class="content">The nom crate has an RGB parser example: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;nom&#x2F;latest&#x2F;nom&#x2F;#example" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;nom&#x2F;latest&#x2F;nom&#x2F;#example</a><p>It’s slightly longer, but more legible.</div><br/></div></div></div></div><div id="42084968" class="c"><input type="checkbox" id="c-42084968" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42084220">root</a><span>|</span><a href="#42084368">parent</a><span>|</span><a href="#42084635">prev</a><span>|</span><a href="#42084789">next</a><span>|</span><label class="collapse" for="c-42084968">[-]</label><label class="expand" for="c-42084968">[1 more]</label></div><br/><div class="children"><div class="content">But it doesn&#x27;t take much to go from 0 to a parser combinator library.  I roll my own each year for advent of code.  It starts at like 100 lines of code (which practically writes itself - very hard to stray outside of what the types enforce) and I grow it a bit over the month when I find missing niceties.</div><br/></div></div></div></div><div id="42084789" class="c"><input type="checkbox" id="c-42084789" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#42084220">parent</a><span>|</span><a href="#42084368">prev</a><span>|</span><a href="#42083729">next</a><span>|</span><label class="collapse" for="c-42084789">[-]</label><label class="expand" for="c-42084789">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t consider FEN a great <i>parsing</i> example, simply because it can be implement in a simple function with a single loop.<p>Just a few days ago, I wrote a FEN &quot;parser&quot; for an experimental quad-bitboard impelementation.  It almost wrote itself.<p>P.S.: I am the author of chessIO on Hackage</div><br/></div></div></div></div><div id="42083729" class="c"><input type="checkbox" id="c-42083729" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42084220">prev</a><span>|</span><a href="#42084455">next</a><span>|</span><label class="collapse" for="c-42083729">[-]</label><label class="expand" for="c-42083729">[7 more]</label></div><br/><div class="children"><div class="content">So, just to kick this off: I wrote an eBPF disassembler and (half-hearted) emulator in Rust and I also found it a pleasant language to do parsing-type stuff in. But: I think the author cuts against their argument when they manage to necessitate a macro less than 1&#x2F;6th of the way into their case study. A macro isn&#x27;t quite code-gen, but it also doesn&#x27;t quite feel like working idiomatically within the language, either.<p>Again: not throwing shade. I think this is a place where Rust is genuinely quite strong.</div><br/><div id="42084265" class="c"><input type="checkbox" id="c-42084265" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#42083729">parent</a><span>|</span><a href="#42083777">next</a><span>|</span><label class="collapse" for="c-42084265">[-]</label><label class="expand" for="c-42084265">[3 more]</label></div><br/><div class="children"><div class="content">How can one define an infinite grammar in Rust?<p>E.g., a context-free rule S ::= abc|aabbcc|aaabbbccc|... can effectively parse a^Nb^Nc^N which is an example of context-sensitive grammar.<p>This is a simple example, but something like that can be seen in practice. One example is when language allows definition of operators.<p>So, how does Rust handle that?</div><br/><div id="42085259" class="c"><input type="checkbox" id="c-42085259" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42083729">root</a><span>|</span><a href="#42084265">parent</a><span>|</span><a href="#42084400">next</a><span>|</span><label class="collapse" for="c-42085259">[-]</label><label class="expand" for="c-42085259">[1 more]</label></div><br/><div class="children"><div class="content">Using parser combinator library &quot;nom&quot;, this should probably do what you&#x27;d want:<p><pre><code>    fn parse_abc(input: &amp;str, n: usize) -&gt; IResult&lt;&amp;str, (Vec&lt;char&gt;, Vec&lt;char&gt;, Vec&lt;char&gt;)&gt; {
      let (input, result) = tuple(( many_m_n(n, n, char(&#x27;a&#x27;)),
                                  many_m_n(n, n, char(&#x27;b&#x27;)),
                                  many_m_n(n, n, char(&#x27;c&#x27;))
                            ))(input)?;
      Ok((input, result)) 
    }
    
</code></pre>
It parses (the beginning of) the input, ensuring `n` repetitions of &#x27;a&#x27;, &#x27;b&#x27;, and &#x27;c&#x27;. Parse errors are reported through the return type, and the remaining characters are returned for the application to deal with as it sees fit.<p><a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c641c407591e1eb7ce451f5865250f56" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a></div><br/></div></div><div id="42084400" class="c"><input type="checkbox" id="c-42084400" checked=""/><div class="controls bullet"><span class="by">ryandv</span><span>|</span><a href="#42083729">root</a><span>|</span><a href="#42084265">parent</a><span>|</span><a href="#42085259">prev</a><span>|</span><a href="#42083777">next</a><span>|</span><label class="collapse" for="c-42084400">[-]</label><label class="expand" for="c-42084400">[1 more]</label></div><br/><div class="children"><div class="content">In Haskell I think it&#x27;s something like:<p><pre><code>    {-# LANGUAGE OverloadedStrings #-}
    import Data.Attoparsec.Text
    import qualified Data.Text as T

    type ParseError = String

    csgParse :: T.Text -&gt; Either ParseError Int
    csgParse = eitherResult . parse parser where
    parser = do
        as &lt;- many&#x27; $ char &#x27;a&#x27;
        let n = length as
        count n $ char &#x27;b&#x27;
        count n $ char &#x27;c&#x27;
        char &#x27;\n&#x27;
        return n

    ghci&gt; csgParse &quot;aaabbbccc\n&quot;
    Right 3</code></pre></div><br/></div></div></div></div><div id="42083801" class="c"><input type="checkbox" id="c-42083801" checked=""/><div class="controls bullet"><span class="by">jamra</span><span>|</span><a href="#42083729">parent</a><span>|</span><a href="#42083777">prev</a><span>|</span><a href="#42084455">next</a><span>|</span><label class="collapse" for="c-42083801">[-]</label><label class="expand" for="c-42083801">[2 more]</label></div><br/><div class="children"><div class="content">Link us your eBPF disassembler if you can. Sounds cool.</div><br/><div id="42083969" class="c"><input type="checkbox" id="c-42083969" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42083729">root</a><span>|</span><a href="#42083801">parent</a><span>|</span><a href="#42084455">next</a><span>|</span><label class="collapse" for="c-42083969">[-]</label><label class="expand" for="c-42083969">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not. If you wrote one, it&#x27;d be more interesting than mine.</div><br/></div></div></div></div></div></div><div id="42084455" class="c"><input type="checkbox" id="c-42084455" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#42083729">prev</a><span>|</span><a href="#42083842">next</a><span>|</span><label class="collapse" for="c-42084455">[-]</label><label class="expand" for="c-42084455">[4 more]</label></div><br/><div class="children"><div class="content">Something that was hard when I wrote a full AST parser in Rust was representing a hierarchy of concrete AST types, with upcasting and downcasting. I was able to figure out a way, but it required some really weird type shenanigans (eg PhantomData) and some macros. Looks like they had to do crazy macros here too<p>Curious what the rest of the prior art looks like</div><br/><div id="42084496" class="c"><input type="checkbox" id="c-42084496" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42084455">parent</a><span>|</span><a href="#42084773">next</a><span>|</span><label class="collapse" for="c-42084496">[-]</label><label class="expand" for="c-42084496">[1 more]</label></div><br/><div class="children"><div class="content">Hmmm, yeah Rust’s ADTs and matching syntax would be great. Until you got to the up&#x2F;down casting. I’m inexperienced enough in Rust to know if there’s good ways to handle it. Dynamic traits maybe?</div><br/></div></div><div id="42084773" class="c"><input type="checkbox" id="c-42084773" checked=""/><div class="controls bullet"><span class="by">ainiriand</span><span>|</span><a href="#42084455">parent</a><span>|</span><a href="#42084496">prev</a><span>|</span><a href="#42083842">next</a><span>|</span><label class="collapse" for="c-42084773">[-]</label><label class="expand" for="c-42084773">[2 more]</label></div><br/><div class="children"><div class="content">Sorry to bother you, but would that be open-source by any chance? Is there any public repo available? Thank you.</div><br/><div id="42085177" class="c"><input type="checkbox" id="c-42085177" checked=""/><div class="controls bullet"><span class="by">yu3zhou4</span><span>|</span><a href="#42084455">root</a><span>|</span><a href="#42084773">parent</a><span>|</span><a href="#42083842">next</a><span>|</span><label class="collapse" for="c-42085177">[-]</label><label class="expand" for="c-42085177">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it can work as a quick glimpse into how parser and lexer can work in Rust <a href="https:&#x2F;&#x2F;github.com&#x2F;jmaczan&#x2F;0x6b73746b">https:&#x2F;&#x2F;github.com&#x2F;jmaczan&#x2F;0x6b73746b</a><p>I wrote it long time ago and it’s not fully implemented tho</div><br/></div></div></div></div></div></div><div id="42083842" class="c"><input type="checkbox" id="c-42083842" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#42084455">prev</a><span>|</span><a href="#42084194">next</a><span>|</span><label class="collapse" for="c-42083842">[-]</label><label class="expand" for="c-42083842">[4 more]</label></div><br/><div class="children"><div class="content">Related, I love Rob Pike&#x27;s talk about lexical Scanning in Go (2011).<p>Educational and elegant approach.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HxaD_trXwRE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HxaD_trXwRE</a></div><br/><div id="42084310" class="c"><input type="checkbox" id="c-42084310" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#42083842">parent</a><span>|</span><a href="#42084393">next</a><span>|</span><label class="collapse" for="c-42084310">[-]</label><label class="expand" for="c-42084310">[2 more]</label></div><br/><div class="children"><div class="content">That talk is great, but I remember some discussion later about Go actually NOT using this technique because of goroutine scheduling overhead and&#x2F;or inefficient memory allocation patterns? The best discussion I could find is [1].<p>Another great talk about making efficient lexers and parsers is Andrew Kelley&#x27;s &quot;Practical Data Oriented Design&quot; [2]. Summary: &quot;it explains various strategies one can use to reduce memory footprint of programs while also making the program cache friendly which increase throughput&quot;.<p>--<p>1: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31649617">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31649617</a><p>2: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IroPQ150F6c" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IroPQ150F6c</a></div><br/><div id="42084381" class="c"><input type="checkbox" id="c-42084381" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#42083842">root</a><span>|</span><a href="#42084310">parent</a><span>|</span><a href="#42084393">next</a><span>|</span><label class="collapse" for="c-42084381">[-]</label><label class="expand" for="c-42084381">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I actually remember that too, this article mentions it:<p><i>Coroutines for Go</i> - <a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;coro" rel="nofollow">https:&#x2F;&#x2F;research.swtch.com&#x2F;coro</a><p><i>The parallelism provided by the goroutines caused races and eventually led to abandoning the design in favor of the lexer storing state in an object, which was a more faithful simulation of a coroutine. Proper coroutines would have avoided the races and been more efficient than goroutines.</i></div><br/></div></div></div></div><div id="42084393" class="c"><input type="checkbox" id="c-42084393" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42083842">parent</a><span>|</span><a href="#42084310">prev</a><span>|</span><a href="#42084194">next</a><span>|</span><label class="collapse" for="c-42084393">[-]</label><label class="expand" for="c-42084393">[1 more]</label></div><br/><div class="children"><div class="content">I feel like that talk has more to do with expressing concurrency, in problems where concurrency is a natural thing to think about, than it does with lexing.</div><br/></div></div></div></div><div id="42084194" class="c"><input type="checkbox" id="c-42084194" checked=""/><div class="controls bullet"><span class="by">ketzo</span><span>|</span><a href="#42083842">prev</a><span>|</span><a href="#42084137">next</a><span>|</span><label class="collapse" for="c-42084194">[-]</label><label class="expand" for="c-42084194">[3 more]</label></div><br/><div class="children"><div class="content">So how do you debug code written with macros like this, or come into it as a new user of the codebase?<p>I’m imagining seeing the node! macro used, and seeing the macro definition, but still having a tough time knowing exactly what code is produced.<p>Do I just use the Example and see what type hints I get from it? Can I hover over it in my IDE and see an expanded version? Do I need to reference the compiled code to be sure?<p>(I do all my work in JS&#x2F;TS so I don’t touch any macros; just curious about the workflow here!)</div><br/><div id="42084307" class="c"><input type="checkbox" id="c-42084307" checked=""/><div class="controls bullet"><span class="by">schneems</span><span>|</span><a href="#42084194">parent</a><span>|</span><a href="#42084394">next</a><span>|</span><label class="collapse" for="c-42084307">[-]</label><label class="expand" for="c-42084307">[1 more]</label></div><br/><div class="children"><div class="content">Run:<p><pre><code>    $ cargo expand
</code></pre>
And you’ll see the resulting code.<p>Rust is really several languages, ”vanilla” rust, declarative macros and proc macros. Each have a slightly different capability set and different dialect. You get used to working with each in turn over time.<p>Also unit tests is generally a good playground area to understand the impacts of modifying a macro.</div><br/></div></div><div id="42084394" class="c"><input type="checkbox" id="c-42084394" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#42084194">parent</a><span>|</span><a href="#42084307">prev</a><span>|</span><a href="#42084137">next</a><span>|</span><label class="collapse" for="c-42084394">[-]</label><label class="expand" for="c-42084394">[1 more]</label></div><br/><div class="children"><div class="content">rust-analyzer, the Rust LSP used in e.g. VSCode, can expand declarative and proc macros recursively.<p>it isn&#x27;t too bad, although the fewer proc macros in a code base, the better. declarative macros are slightly easier to grok, but much easier to maintain and test. (i feel the same way about opaque codegen in other languages.)</div><br/></div></div></div></div><div id="42084137" class="c"><input type="checkbox" id="c-42084137" checked=""/><div class="controls bullet"><span class="by">WiSaGaN</span><span>|</span><a href="#42084194">prev</a><span>|</span><a href="#42084149">next</a><span>|</span><label class="collapse" for="c-42084137">[-]</label><label class="expand" for="c-42084137">[1 more]</label></div><br/><div class="children"><div class="content">I think except macros, most of these features are ML family language features as well. Rust stands out because it can implement this in an efficient, zero overhead abstraction way.</div><br/></div></div><div id="42084149" class="c"><input type="checkbox" id="c-42084149" checked=""/><div class="controls bullet"><span class="by">kldx</span><span>|</span><a href="#42084137">prev</a><span>|</span><a href="#42084639">next</a><span>|</span><label class="collapse" for="c-42084149">[-]</label><label class="expand" for="c-42084149">[1 more]</label></div><br/><div class="children"><div class="content">I like MegaParsec in haskell quite expressive, based on my limited experience using nom in Rust</div><br/></div></div><div id="42084639" class="c"><input type="checkbox" id="c-42084639" checked=""/><div class="controls bullet"><span class="by">jurschreuder</span><span>|</span><a href="#42084149">prev</a><span>|</span><a href="#42083892">next</a><span>|</span><label class="collapse" for="c-42084639">[-]</label><label class="expand" for="c-42084639">[2 more]</label></div><br/><div class="children"><div class="content">I cannot agree less, C++ is the best and always will be. You youngsters made up this new dialect that can also compile with the C++ compiler. This is like people putting VS Code in dark mode thinking they&#x27;re now also working in the Terminal like the Gods of Binary.</div><br/><div id="42084701" class="c"><input type="checkbox" id="c-42084701" checked=""/><div class="controls bullet"><span class="by">arlort</span><span>|</span><a href="#42084639">parent</a><span>|</span><a href="#42083892">next</a><span>|</span><label class="collapse" for="c-42084701">[-]</label><label class="expand" for="c-42084701">[1 more]</label></div><br/><div class="children"><div class="content">Rust being a dialect of c++ is certainly a novel take</div><br/></div></div></div></div><div id="42083892" class="c"><input type="checkbox" id="c-42083892" checked=""/><div class="controls bullet"><span class="by">sksxihve</span><span>|</span><a href="#42084639">prev</a><span>|</span><a href="#42084533">next</a><span>|</span><label class="collapse" for="c-42083892">[-]</label><label class="expand" for="c-42083892">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found that the logos crate is really nice for writing lexers in rust<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;logos&#x2F;0.14.2&#x2F;logos&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;logos&#x2F;0.14.2&#x2F;logos&#x2F;</a></div><br/></div></div><div id="42084533" class="c"><input type="checkbox" id="c-42084533" checked=""/><div class="controls bullet"><span class="by">omani</span><span>|</span><a href="#42083892">prev</a><span>|</span><a href="#42083871">next</a><span>|</span><label class="collapse" for="c-42084533">[-]</label><label class="expand" for="c-42084533">[1 more]</label></div><br/><div class="children"><div class="content">this is the third day in a row this article is being posted here.<p>this time it got traction. funny how HN works.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42055954">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42055954</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42058920">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42058920</a></div><br/></div></div><div id="42083871" class="c"><input type="checkbox" id="c-42083871" checked=""/><div class="controls bullet"><span class="by">jamra</span><span>|</span><a href="#42084533">prev</a><span>|</span><label class="collapse" for="c-42083871">[-]</label><label class="expand" for="c-42083871">[6 more]</label></div><br/><div class="children"><div class="content">Does anyone have a good EBNF notation for Sqlite? I tried to make a tree-sitter grammar, which produces C code and great Rust bindings for it. But they use some lemon parser. Not sure how to read the grammar from that.</div><br/><div id="42085068" class="c"><input type="checkbox" id="c-42085068" checked=""/><div class="controls bullet"><span class="by">mingodad</span><span>|</span><a href="#42083871">parent</a><span>|</span><a href="#42084421">next</a><span>|</span><label class="collapse" for="c-42085068">[-]</label><label class="expand" for="c-42085068">[1 more]</label></div><br/><div class="children"><div class="content">The lemon tool that is used by SQLite can output the grammar as SQL database that you can manipulate.
There is <a href="https:&#x2F;&#x2F;github.com&#x2F;ricomariani&#x2F;CG-SQL-author">https:&#x2F;&#x2F;github.com&#x2F;ricomariani&#x2F;CG-SQL-author</a> that goes way beyond and you&#x27;ll need to create the Rust generation, you can play with it here with a Lua backend <a href="https:&#x2F;&#x2F;mingodad.github.io&#x2F;CG-SQL-Lua-playground&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mingodad.github.io&#x2F;CG-SQL-Lua-playground&#x2F;</a> .<p>Also I&#x27;m collecting several LALR(1) grammars here <a href="https:&#x2F;&#x2F;mingodad.github.io&#x2F;parsertl-playground&#x2F;playground&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mingodad.github.io&#x2F;parsertl-playground&#x2F;playground&#x2F;</a> that is an Yacc&#x2F;Lex compatible online editor&#x2F;interpreter that can generate EBNF for railroad diagram, SQL, C++ from the grammars, select &quot;SQLite3 parser (partially working)&quot; from &quot;Examples&quot; then click &quot;Parse&quot; to see the parse tree for the content in &quot;Input source&quot;.<p>I also created <a href="https:&#x2F;&#x2F;mingodad.github.io&#x2F;plgh&#x2F;json2ebnf.html" rel="nofollow">https:&#x2F;&#x2F;mingodad.github.io&#x2F;plgh&#x2F;json2ebnf.html</a> to have a unified view of tree-sitter grammars and <a href="https:&#x2F;&#x2F;mingodad.github.io&#x2F;lua-wasm-playground&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mingodad.github.io&#x2F;lua-wasm-playground&#x2F;</a> where there is an Lua script to generate an alternative EBNF to write tree-sitter grammars that can later be converted to the standard &quot;grammar.js&quot;.</div><br/></div></div><div id="42084421" class="c"><input type="checkbox" id="c-42084421" checked=""/><div class="controls bullet"><span class="by">rstuart4133</span><span>|</span><a href="#42083871">parent</a><span>|</span><a href="#42085068">prev</a><span>|</span><a href="#42084459">next</a><span>|</span><label class="collapse" for="c-42084421">[-]</label><label class="expand" for="c-42084421">[1 more]</label></div><br/><div class="children"><div class="content">Not EBNF or anything standard, but possibly readable enough.  It is an LR(1) grammar that has tested on all the test cases in Sqlite&#x27;s test suite at the time:<p><a href="https:&#x2F;&#x2F;lrparsing.sourceforge.net&#x2F;doc&#x2F;examples&#x2F;lrparsing-sqlite.py" rel="nofollow">https:&#x2F;&#x2F;lrparsing.sourceforge.net&#x2F;doc&#x2F;examples&#x2F;lrparsing-sql...</a><p>The grammer contains things you won&#x27;t have seen before, like Prio().  Think of them as macros.  It all gets translated to LR(1) productions which you can ask it to print out.  LR(1) productions are simpler than EBNF.  They look like:<p><pre><code>   symbol1 := symbol2 symbol3
   symbol1 := symbol4 symbol3
   symbol3 := token1 symbol2 token2
   ...
</code></pre>
Documentation on what the macros do, and how to get it to spit out the LR1(1) productions is here:<p><a href="https:&#x2F;&#x2F;lrparsing.sourceforge.net&#x2F;doc&#x2F;html&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lrparsing.sourceforge.net&#x2F;doc&#x2F;html&#x2F;</a><p>It was used to do a similar task the OP is attempting.</div><br/></div></div><div id="42084459" class="c"><input type="checkbox" id="c-42084459" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#42083871">parent</a><span>|</span><a href="#42084421">prev</a><span>|</span><a href="#42084072">next</a><span>|</span><label class="collapse" for="c-42084459">[-]</label><label class="expand" for="c-42084459">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps this ANTLR v4 sqlite grammar? [1]<p>--<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;antlr&#x2F;grammars-v4&#x2F;tree&#x2F;master&#x2F;sql&#x2F;sqlite">https:&#x2F;&#x2F;github.com&#x2F;antlr&#x2F;grammars-v4&#x2F;tree&#x2F;master&#x2F;sql&#x2F;sqlite</a></div><br/></div></div><div id="42084072" class="c"><input type="checkbox" id="c-42084072" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#42083871">parent</a><span>|</span><a href="#42084459">prev</a><span>|</span><a href="#42084113">next</a><span>|</span><label class="collapse" for="c-42084072">[-]</label><label class="expand" for="c-42084072">[1 more]</label></div><br/><div class="children"><div class="content">It looks pretty much like BNF. Not too far off, anyway. <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;src&#x2F;doc&#x2F;trunk&#x2F;doc&#x2F;lemon.html#syntax" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;src&#x2F;doc&#x2F;trunk&#x2F;doc&#x2F;lemon.html#syntax</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>