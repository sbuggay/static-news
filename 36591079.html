<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688547651855" as="style"/><link rel="stylesheet" href="styles.css?v=1688547651855"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thunderseethe.dev/posts/type-inference/">Designing a Language Without a Parser</a>Â <span class="domain">(<a href="https://thunderseethe.dev">thunderseethe.dev</a>)</span></div><div class="subtext"><span>thunderseethe</span> | <span>75 comments</span></div><br/><div><div id="36592554" class="c"><input type="checkbox" id="c-36592554" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#36591427">next</a><span>|</span><label class="collapse" for="c-36592554">[-]</label><label class="expand" for="c-36592554">[34 more]</label></div><br/><div class="children"><div class="content">&gt; However, once I start constructing a parser, progress slows to a crawl<p>I can&#x27;t really relate here. The parser is the easiest part of a compiler; the work only increases from there. I feel like if you ran out of steam at the parser, you never had enough steam to write a whole compiler. I don&#x27;t think removing the parser will take you across the finish line if you otherwise were running out of steam.<p>My advice is to write your language in vertical slices. Write the parsing, semantic checking, and code generation for the simplest features first and progressively add feature slices, rather than trying to write the entire parser for a fully-baked language before proceeding. Consider including &quot;print&quot; as a built-in statement so you can print things out (and thus write tests) before you have working expressions and function calls.</div><br/><div id="36593052" class="c"><input type="checkbox" id="c-36593052" checked=""/><div class="controls bullet"><span class="by">smasher164</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36596147">next</a><span>|</span><label class="collapse" for="c-36593052">[-]</label><label class="expand" for="c-36593052">[23 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think removing the parser will take you across the finish line if you otherwise were running out of steam.<p>Everyone&#x27;s different. The problem with parsing isn&#x27;t the difficulty, but rather the potential for endless bikeshedding. You&#x27;re having to make a ton of opinionated decisions that in turn produce more questions about your syntax. If your personality is like mine in that it&#x27;s a bit obsessive &quot;completing&quot; a phase, then parsing feels like an endless quagmire. In comparison, AST -&gt; type inference -&gt; codegen feels more structured and straightforward.</div><br/><div id="36596423" class="c"><input type="checkbox" id="c-36596423" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593052">parent</a><span>|</span><a href="#36594502">next</a><span>|</span><label class="collapse" for="c-36596423">[-]</label><label class="expand" for="c-36596423">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The problem with parsing isn&#x27;t the difficulty, but rather the potential for endless bikeshedding. You&#x27;re having to make a ton of opinionated decisions that in turn produce more questions about your syntax.<p>Considering the author is talking about an endless graveyard of abandoned projects it kind of sounds like ADHD. I have ADHD and have a similar problem.<p>I still do endless bikeshedding where I&#x27;ll do things like insist on zero memory allocations or streams&#x2F;iterators over slices and those arbitrary limitations will completely compromise the project. Either I never finish it because I can&#x27;t get it to work, or I get it to work but it sucks because of stuff like &quot;the amount of work to avoid memory allocation might be much larger than the work of just making a damn memory allocation&quot;.</div><br/></div></div><div id="36594502" class="c"><input type="checkbox" id="c-36594502" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593052">parent</a><span>|</span><a href="#36596423">prev</a><span>|</span><a href="#36593877">next</a><span>|</span><label class="collapse" for="c-36594502">[-]</label><label class="expand" for="c-36594502">[15 more]</label></div><br/><div class="children"><div class="content">That explains why Lisp is so convenient for implementing DSLs.  Homoiconicity skips all the bike shedding around syntax and parsing.</div><br/><div id="36595669" class="c"><input type="checkbox" id="c-36595669" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36594502">parent</a><span>|</span><a href="#36594863">next</a><span>|</span><label class="collapse" for="c-36595669">[-]</label><label class="expand" for="c-36595669">[9 more]</label></div><br/><div class="children"><div class="content">I used to like Lisp&#x27;s homoiconicity.  These days, I&#x27;m not even sure the concept makes any sense?  What is it even supposed to mean?<p>Lisp has (simple) syntax for creating literals and writing code.  But when you inspect your data from the inside of Lisp, they don&#x27;t have any more (or less) relation to that syntax than eg Python does.<p>Eg no modern Lisp stores a function as an S-Expr of its syntax.  You get an opaque piece of data that you can do certain operations on, just like in eg Python or Haskell.<p>Lisp using S-Expressions is an interesting syntax choice, but that&#x27;s it.  It doesn&#x27;t by itself have any deeper impact on the language.  (Of course, socially it does have a deeper impact, because it makes it simple for language users to write macros that look exactly like built-in parts of the language, instead of bolted on.<p>But that&#x27;s all in human brains and social interactions, nothing fancy going on here on a technical level.<p>If you wouldn&#x27;t mind much more tediousness, you could implement seamless macros in almost any language as a pre-processing step.)</div><br/><div id="36595942" class="c"><input type="checkbox" id="c-36595942" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36595669">parent</a><span>|</span><a href="#36596161">next</a><span>|</span><label class="collapse" for="c-36595942">[-]</label><label class="expand" for="c-36595942">[1 more]</label></div><br/><div class="children"><div class="content">Of course, compilers exist, so in a sense all code is data.<p>Besides the social stuff, S-expressions make it orders of magnitude simpler to build the infrastructure required to support seamless macros (just look at procedural macros in Rust for a recent example)</div><br/></div></div><div id="36596161" class="c"><input type="checkbox" id="c-36596161" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36595669">parent</a><span>|</span><a href="#36595942">prev</a><span>|</span><a href="#36595923">next</a><span>|</span><label class="collapse" for="c-36596161">[-]</label><label class="expand" for="c-36596161">[5 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t imagine someone who has ever written a Lisp macro coming away thinking &quot;there&#x27;s nothing special about s-expressions&quot;. Honestly, sounds like you&#x27;re commenting on something you have absolutely no knowledge of.</div><br/><div id="36596312" class="c"><input type="checkbox" id="c-36596312" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36596161">parent</a><span>|</span><a href="#36595923">next</a><span>|</span><label class="collapse" for="c-36596312">[-]</label><label class="expand" for="c-36596312">[4 more]</label></div><br/><div class="children"><div class="content">Great ad hominem!<p>I have used Scheme, Racket and Common Lisp (SBCL) since the 1990s (before mostly switching to the ML family of languages).  I read &#x27;On Lisp&#x27; cover to cover.  I know what I am talking about.  You can still disagree with me, of course.  But don&#x27;t do it of the basis of me not having used enough Lisp.<p>S-Expressions make it easier to write macros that blend seamlessly into the host language.  But there&#x27;s no magic to them (compared to macros you could do as pre-processing in any other language) beyond that.<p>S-Expressions are a neat syntax.  But homoiconicity is a weird concept; if it is coherent at all, it only pertains to the surface syntax level of the language.</div><br/><div id="36597138" class="c"><input type="checkbox" id="c-36597138" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36596312">parent</a><span>|</span><a href="#36595923">next</a><span>|</span><label class="collapse" for="c-36597138">[-]</label><label class="expand" for="c-36597138">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I know what I am talking about.<p>Sorry, but you manifestly don&#x27;t:<p>&gt; there&#x27;s no magic to them (compared to macros you could do as pre-processing in any other language)<p>The &quot;magic&quot; of s-expressions is that they make it easy to operate on the source code of a program <i>as a hierarchical data structure</i> (i.e. as an AST) rather than <i>as text</i>.  That turns out to be an <i>extremely</i> powerful lever.  It is is one of the reasons Lisp has lasted as long and been as influential as it has.  I&#x27;m sorry if this sounds like an ad-hominem, but if you think there is &quot;no magic&quot; to S-expressions the most likely explanation is that you don&#x27;t really understand them.  There is nothing comparable in any other language.  There&#x27;s a reason that they are still in use today.  Indeed, there is a reason that they keep getting re-invented again and again.  HTML, XML, and JSON are all (badly) reinvented s-expressions.<p>&gt; homoiconicity is a weird concept<p>No, it isn&#x27;t.  It is simple and straightforward: homoiconicity is where the primary representation of programs is a data structure in a primitive type of the language itself.  It isn&#x27;t any weirder than (say) recursion.  If you think it&#x27;s weird that is more evidence that you don&#x27;t actually understand it.</div><br/><div id="36597550" class="c"><input type="checkbox" id="c-36597550" checked=""/><div class="controls bullet"><span class="by">iopq</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36597138">parent</a><span>|</span><a href="#36597264">next</a><span>|</span><label class="collapse" for="c-36597550">[-]</label><label class="expand" for="c-36597550">[1 more]</label></div><br/><div class="children"><div class="content">But Rust macros also do this, the procedural macros operate on the AST of the macro<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;procedural-macros.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;procedural-macros.html</a></div><br/></div></div><div id="36597264" class="c"><input type="checkbox" id="c-36597264" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36597138">parent</a><span>|</span><a href="#36597550">prev</a><span>|</span><a href="#36595923">next</a><span>|</span><label class="collapse" for="c-36597264">[-]</label><label class="expand" for="c-36597264">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The &quot;magic&quot; of s-expressions is that they make it easy to operate on the source code of a program as a hierarchical data structure<p>where exactly is the magic? it&#x27;s just tuple unpacking? like congrats you&#x27;ve constrained yourself to the absolute bare minimum and you&#x27;ve made it work. i mean i guess congrats for getting it to work at all but it&#x27;s not magical, it&#x27;s tedious. if you showed me a homoiconic language that did somehow pull off the magic trick of being more expressive than tuples then i would be indeed enchanted (mathematica at least manages to put lipstick on the whole exercise).</div><br/></div></div></div></div></div></div></div></div><div id="36595923" class="c"><input type="checkbox" id="c-36595923" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36595669">parent</a><span>|</span><a href="#36596161">prev</a><span>|</span><a href="#36594863">next</a><span>|</span><label class="collapse" for="c-36595923">[-]</label><label class="expand" for="c-36595923">[2 more]</label></div><br/><div class="children"><div class="content">Well sure, if you hand wave away the main benefit of sexps then there arenât many benefits.</div><br/><div id="36596322" class="c"><input type="checkbox" id="c-36596322" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36595923">parent</a><span>|</span><a href="#36594863">next</a><span>|</span><label class="collapse" for="c-36596322">[-]</label><label class="expand" for="c-36596322">[1 more]</label></div><br/><div class="children"><div class="content">Oh, S-Expressions are great for certain kinds of things.<p>I&#x27;m just having a problem with the concept of homoiconicity being touted as both coherent, and something that goes deeper than the very surface syntax level.</div><br/></div></div></div></div></div></div><div id="36594863" class="c"><input type="checkbox" id="c-36594863" checked=""/><div class="controls bullet"><span class="by">nielsbot</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36594502">parent</a><span>|</span><a href="#36595669">prev</a><span>|</span><a href="#36593877">next</a><span>|</span><label class="collapse" for="c-36594863">[-]</label><label class="expand" for="c-36594863">[5 more]</label></div><br/><div class="children"><div class="content">Lisp: &quot;We got around parsing by getting rid of the syntax!&quot; :)</div><br/><div id="36595675" class="c"><input type="checkbox" id="c-36595675" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36594863">parent</a><span>|</span><a href="#36593877">next</a><span>|</span><label class="collapse" for="c-36595675">[-]</label><label class="expand" for="c-36595675">[4 more]</label></div><br/><div class="children"><div class="content">Lisp has syntax.  It&#x27;s just usually fairly straightforward (for the most parts).<p>Forth also has an interesting simple syntax.</div><br/><div id="36596203" class="c"><input type="checkbox" id="c-36596203" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36595675">parent</a><span>|</span><a href="#36593877">next</a><span>|</span><label class="collapse" for="c-36596203">[-]</label><label class="expand" for="c-36596203">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Lisp has no syntax&quot; really means &quot;Lisp has no specific syntax&quot;. Any well-parenthesized S-expr is a syntactically valid Lisp program, even if it is nonsensical. Most other languages (including Forth) have keyword and syntax-dependent structuring.</div><br/><div id="36596297" class="c"><input type="checkbox" id="c-36596297" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36596203">parent</a><span>|</span><a href="#36593877">next</a><span>|</span><label class="collapse" for="c-36596297">[-]</label><label class="expand" for="c-36596297">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Any well-parenthesized S-expr is a syntactically valid Lisp program, even if it is nonsensical.<p>Which version of Lisp are you talking about?  A very brief web search showed eg <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40210896&#x2F;syntax-error-in-dr-racket" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40210896&#x2F;syntax-error-in...</a><p>For something really simple, try `(define define)` in Scheme.<p>I&#x27;d say Forth has less syntax than Lisp.  But that&#x27;s perhaps a reflection of most Forth implementations using some clever tricks to offload much of what&#x27;s handled by syntax in other languages.<p>Eg defining new functions (ie &#x27;words&#x27; in Forth terms) is not done via a special syntactic construct in Forth, but via &#x27;immediate words&#x27;.  The lines are a but blurry, though.</div><br/><div id="36596351" class="c"><input type="checkbox" id="c-36596351" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36596297">parent</a><span>|</span><a href="#36593877">next</a><span>|</span><label class="collapse" for="c-36596351">[-]</label><label class="expand" for="c-36596351">[1 more]</label></div><br/><div class="children"><div class="content">This is not a Lisp syntax error, this is a &#x27;cond&#x27; macro syntax error.<p>The language has no syntax, the constructs within the language can and do impose additional restrictions (not extensions - restrictions) when evaluated. You may not find the distinction useful, but it is there.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36593877" class="c"><input type="checkbox" id="c-36593877" checked=""/><div class="controls bullet"><span class="by">thunderseethe</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593052">parent</a><span>|</span><a href="#36594502">prev</a><span>|</span><a href="#36595908">next</a><span>|</span><label class="collapse" for="c-36593877">[-]</label><label class="expand" for="c-36593877">[1 more]</label></div><br/><div class="children"><div class="content">This captures exactly the sentiment I was trying to express.<p>Thanks for chiming in!</div><br/></div></div><div id="36595908" class="c"><input type="checkbox" id="c-36595908" checked=""/><div class="controls bullet"><span class="by">danybittel</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593052">parent</a><span>|</span><a href="#36593877">prev</a><span>|</span><a href="#36593745">next</a><span>|</span><label class="collapse" for="c-36595908">[-]</label><label class="expand" for="c-36595908">[1 more]</label></div><br/><div class="children"><div class="content">You need to better define the goal of your PL. If you have an exact vision of your end user and what she or he is going to use it for, it becomes easier to navigate any trade offs.</div><br/></div></div><div id="36593745" class="c"><input type="checkbox" id="c-36593745" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593052">parent</a><span>|</span><a href="#36595908">prev</a><span>|</span><a href="#36596147">next</a><span>|</span><label class="collapse" for="c-36593745">[-]</label><label class="expand" for="c-36593745">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The problem with parsing isn&#x27;t the difficulty, but rather the potential for endless bikeshedding. You&#x27;re having to make a ton of opinionated decisions that in turn produce more questions about your syntax.<p>I fail to see your point. OP was commenting on the technical difficulty of actually rolling out a parser, but you&#x27;re not arguing the technical side. You&#x27;re arguing the project management sides where &quot;endless bike shedding&quot; results in code churn. That&#x27;s not the parser&#x27;s fault, but the person&#x27;s fault. You&#x27;re bound to get hung up on details regardless of what part of the project you&#x27;re working on, because it&#x27;s not the parser compelling you to get hung up on details.</div><br/><div id="36594674" class="c"><input type="checkbox" id="c-36594674" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593745">parent</a><span>|</span><a href="#36593867">next</a><span>|</span><label class="collapse" for="c-36594674">[-]</label><label class="expand" for="c-36594674">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s not the parser&#x27;s fault, but the person&#x27;s fault. You&#x27;re bound to get hung up on details regardless of what part of the project you&#x27;re working on, because it&#x27;s not the parser compelling you to get hung up on details.<p>Disagree. The fact that you&#x27;re working on &quot;a parser&quot; creates the bad project structure that leads you to get hung up on details: a parser whose backend doesn&#x27;t exist yet inherently has unclear requirements and a lot of bikesheddy decisions to make.</div><br/></div></div><div id="36593867" class="c"><input type="checkbox" id="c-36593867" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593745">parent</a><span>|</span><a href="#36594674">prev</a><span>|</span><a href="#36596147">next</a><span>|</span><label class="collapse" for="c-36593867">[-]</label><label class="expand" for="c-36593867">[2 more]</label></div><br/><div class="children"><div class="content">but it is. language syntax design is a total sinkhole. you give me a spec - I&#x27;ll crap out a parser for you. tell me to design a textual language and chances are pretty good I won&#x27;t get back to you. and if I do, chances are really high that you&#x27;re gonna want me to do something different.</div><br/><div id="36596205" class="c"><input type="checkbox" id="c-36596205" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36593867">parent</a><span>|</span><a href="#36596147">next</a><span>|</span><label class="collapse" for="c-36596205">[-]</label><label class="expand" for="c-36596205">[1 more]</label></div><br/><div class="children"><div class="content">&gt; language syntax design is a total sinkhole.<p>Sintax design, not implementing a parser.<p>You&#x27;re arguing that you might not make up your mind and feel compelled to churn parts of your implementation due to your indecisiveness.<p>That&#x27;s not the parser&#x27;s fault, and I fail to see how anyone avoids this indecisiveness by replacing a proper parser with a bunch of ad-hoc hacks.<p>&gt; chances are really high that you&#x27;re gonna want me to do something different.<p>So what? Just work on it. How many parser generator tools are there? It&#x27;s as if people have been doing this for decades.</div><br/></div></div></div></div></div></div></div></div><div id="36596147" class="c"><input type="checkbox" id="c-36596147" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36593052">prev</a><span>|</span><a href="#36595155">next</a><span>|</span><label class="collapse" for="c-36596147">[-]</label><label class="expand" for="c-36596147">[1 more]</label></div><br/><div class="children"><div class="content">&gt; rather than trying to write the entire parser for a fully-baked language before proceeding.<p>I see programmers, even experienced ones, making this mistake all the time when implementing larger changes. They try to get the whole thing implemented at once even when it&#x27;s obvious from the outset that there are multiple sub-features that can be more easily implemented separately, so one can focus all their efforts on it, make sure it&#x27;s well tested and clean, before moving on to the next sub-feature.</div><br/></div></div><div id="36595155" class="c"><input type="checkbox" id="c-36595155" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36596147">prev</a><span>|</span><a href="#36594353">next</a><span>|</span><label class="collapse" for="c-36595155">[-]</label><label class="expand" for="c-36595155">[1 more]</label></div><br/><div class="children"><div class="content">I have a better idea. Do the code gen while writing out the parser. It won&#x27;t be the fastest language and the codebase would be a mess and you will most likely have correctness problems but it&#x27;s the fastest way to production. The classic 3 stage compiler design (tokenizing&#x2F;lexing&#x2F;parsing -&gt; AST -&gt; optional lowering&#x2F;bytecode etc. -&gt; JIT&#x2F;code gen)  is only important if you want to semantic analysis and optimization. They are kinda redundant for prototyping (plus cranelift and LLVM exist, you can focus on the backend after you get your language design in order). Do a quick peephole optimization pass on the generated instructions if things get too slow.<p>If we are being honest here, most people just want their own better Python&#x2F;Go&#x2F;Rust. I doubt your average engineer is truly interested in the subtleties of compiler design and memory layout optimization. A single pass compiler, built like the olden day of yore, is the best option for most.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;One-pass_compiler" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;One-pass_compiler</a><p>Leave the 3 stage design for homework (or if you are being paid to do so).</div><br/></div></div><div id="36594353" class="c"><input type="checkbox" id="c-36594353" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36595155">prev</a><span>|</span><a href="#36592671">next</a><span>|</span><label class="collapse" for="c-36594353">[-]</label><label class="expand" for="c-36594353">[1 more]</label></div><br/><div class="children"><div class="content">My first language, I spent months on the parser and then gave up. As I learned more I got better until now, I can write a hand-rolled parser for a simple language in under a day. There&#x27;s a technique to making syntax which is easy to read&#x2F;write and easy to parse with a look-ahead parser.<p>For more complicated languages, there are tools like tree-sitter and ANTLR4. You can even extend an existing tree-sitter grammar to augment a language without having to re-write the base language parser.</div><br/></div></div><div id="36592671" class="c"><input type="checkbox" id="c-36592671" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36594353">prev</a><span>|</span><a href="#36594992">next</a><span>|</span><label class="collapse" for="c-36592671">[-]</label><label class="expand" for="c-36592671">[4 more]</label></div><br/><div class="children"><div class="content">Parser for &quot;4-lulz language&quot; or something that will also be used in IDEs, so has robust error recovery, can perform partial updates, etc?<p>I feel it&#x27;s just that it is possible to say that work on the parser side is completed<p>meanwhile optimizations? you can probably endlessly improve stuff</div><br/><div id="36592737" class="c"><input type="checkbox" id="c-36592737" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36592671">parent</a><span>|</span><a href="#36594832">next</a><span>|</span><label class="collapse" for="c-36592737">[-]</label><label class="expand" for="c-36592737">[2 more]</label></div><br/><div class="children"><div class="content">Talking about the same thing as the article: hobby&#x2F;learning languages. If you click the links to the author&#x27;s projects you can see they have yet to finish a compiler or really even come close. Definitely not talking about sophisticated production-grade languages here; OP is trying to complete their first compiler <i>at all</i>. I think writing compilers is a really neat and useful learning project but you have to be smart about not biting off more than you can chew.<p>I would absolutely recommend not supporting incremental compilation or error recovery in your first compiler. Just stop everything at the first error. Save that for your second hobby compiler, or better yet, the first commercial compiler that you get paid to work on.</div><br/><div id="36593060" class="c"><input type="checkbox" id="c-36593060" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36592737">parent</a><span>|</span><a href="#36594832">next</a><span>|</span><label class="collapse" for="c-36593060">[-]</label><label class="expand" for="c-36593060">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>writing compilers is a really neat and useful learning project but you have to be smart about not biting off more than you can chew.</i><p>Writing compilers is an especially useful project when you learn roughly how much you <i>can</i> chew. (Algol 68 is a nice example of a bunch of smart people, with relevant domain expertise, biting off way too much for the machines of the time.)</div><br/></div></div></div></div><div id="36594832" class="c"><input type="checkbox" id="c-36594832" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36592554">root</a><span>|</span><a href="#36592671">parent</a><span>|</span><a href="#36592737">prev</a><span>|</span><a href="#36594992">next</a><span>|</span><label class="collapse" for="c-36594832">[-]</label><label class="expand" for="c-36594832">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re reaching higher</div><br/></div></div></div></div><div id="36594992" class="c"><input type="checkbox" id="c-36594992" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36592671">prev</a><span>|</span><a href="#36596356">next</a><span>|</span><label class="collapse" for="c-36594992">[-]</label><label class="expand" for="c-36594992">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Consider including &quot;print&quot; as a built-in statement<p>I really wish Python 3 had taken that advice. ;-)</div><br/></div></div><div id="36596356" class="c"><input type="checkbox" id="c-36596356" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36594992">prev</a><span>|</span><a href="#36594269">next</a><span>|</span><label class="collapse" for="c-36596356">[-]</label><label class="expand" for="c-36596356">[1 more]</label></div><br/><div class="children"><div class="content">Yep, it was tremendously correct to start with (iirc) &#x27;assert_eq&#x27; and &#x27;print&#x27; as the two first statements in my language when building out the compiler. It meant I could start writing a test suite and assemble a larger and larger set of functionality as I went.<p>On the other hand I do really hate the task of writing parsers, so I can relate to people who think it&#x27;s the worst&#x2F;most difficult part. But I think other parts are probably harder, like getting type system stuff right.</div><br/></div></div><div id="36594269" class="c"><input type="checkbox" id="c-36594269" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#36592554">parent</a><span>|</span><a href="#36596356">prev</a><span>|</span><a href="#36591427">next</a><span>|</span><label class="collapse" for="c-36594269">[-]</label><label class="expand" for="c-36594269">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. Parsers are tedious to write and obscure corner cases crop up over the course of development that make us completely change our approach to parsing or the grammar. You have to be pretty expert to get the grammar and parsing to work right the first time. Type inference is tough, but itâs not difficult the way writing a parser is. Codegen (suboptimal but functional) is even easier.<p>But yeah, write the vertical slice and implement a print builtin are good tips.</div><br/></div></div></div></div><div id="36591427" class="c"><input type="checkbox" id="c-36591427" checked=""/><div class="controls bullet"><span class="by">wpietri</span><span>|</span><a href="#36592554">prev</a><span>|</span><a href="#36591497">next</a><span>|</span><label class="collapse" for="c-36591427">[-]</label><label class="expand" for="c-36591427">[4 more]</label></div><br/><div class="children"><div class="content">Ooh, I like this. Too many people start projects at the logical beginning. But what you really want early on in a project is to maximize speed of exploration of the interesting parts.<p>To me there&#x27;s a clear analogy with startups. The naive conception of starting a company is that you get a pile of money so you can hire a bunch of people and create important infrastructure. But with startups, you&#x27;re trying something new, so the most efficient use of time is to find the riskiest hypotheses and test them as directly as possible. That often involves doing things that seem wrong if you proceed in the &quot;logical&quot; way. E.g., I knew a successful UGC company that didn&#x27;t implement accounts and logins until like 6 months in. But that was fine, because actual accounts were not needed to figure out whether the business worked.</div><br/><div id="36593603" class="c"><input type="checkbox" id="c-36593603" checked=""/><div class="controls bullet"><span class="by">dcz_self</span><span>|</span><a href="#36591427">parent</a><span>|</span><a href="#36595991">next</a><span>|</span><label class="collapse" for="c-36593603">[-]</label><label class="expand" for="c-36593603">[2 more]</label></div><br/><div class="children"><div class="content">Start in the middle. It&#x27;s the most interesting part, too. After all, that&#x27;s the core of your idea.<p>I don&#x27;t know where I heard this, but the idea is so important to me that I saved it on my blog: <a href="https:&#x2F;&#x2F;dorotac.eu&#x2F;posts&#x2F;in_the_middle&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dorotac.eu&#x2F;posts&#x2F;in_the_middle&#x2F;</a></div><br/><div id="36595390" class="c"><input type="checkbox" id="c-36595390" checked=""/><div class="controls bullet"><span class="by">mjcohen</span><span>|</span><a href="#36591427">root</a><span>|</span><a href="#36593603">parent</a><span>|</span><a href="#36595991">next</a><span>|</span><label class="collapse" for="c-36595390">[-]</label><label class="expand" for="c-36595390">[1 more]</label></div><br/><div class="children"><div class="content">That is also a good way to start an improv scene. Figure out later, if at all, what is really going on.</div><br/></div></div></div></div><div id="36595991" class="c"><input type="checkbox" id="c-36595991" checked=""/><div class="controls bullet"><span class="by">danybittel</span><span>|</span><a href="#36591427">parent</a><span>|</span><a href="#36593603">prev</a><span>|</span><a href="#36591497">next</a><span>|</span><label class="collapse" for="c-36595991">[-]</label><label class="expand" for="c-36595991">[1 more]</label></div><br/><div class="children"><div class="content">That is sort of the idea of the MVP (minimum viable product).<p>I prefer the analogy of painting. You start with collecting references, exploring ideas in a sketchbook, make color tests, draw outlines on canvas, use big brushes for colors, refine with smaller and smaller details.<p>The problem is, that programming is <i>all details &#x2F; only details</i>. There is no easy way to use big brushstrokes, so you have to improvise and not loose the overview. It doesn&#x27;t help that engineers love details.</div><br/></div></div></div></div><div id="36591497" class="c"><input type="checkbox" id="c-36591497" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#36591427">prev</a><span>|</span><a href="#36592770">next</a><span>|</span><label class="collapse" for="c-36591497">[-]</label><label class="expand" for="c-36591497">[11 more]</label></div><br/><div class="children"><div class="content">While I agree designing syntax before you know your semantics is unwise, please consider also that there are several actually parserless languages extant: lisps, forths, APLs, smalltalks, various Edinburgh languages, etc.<p>(Esterel âIIRCâ is the only language of which I&#x27;m aware that explicitly has two syntaxes, one traditionally parser based and one that, in principle, could be parserless)</div><br/><div id="36592691" class="c"><input type="checkbox" id="c-36592691" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36591497">parent</a><span>|</span><a href="#36593180">next</a><span>|</span><label class="collapse" for="c-36592691">[-]</label><label class="expand" for="c-36592691">[8 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like the term parserless in this context. its not like you can just mmap an lisp source file and cast it to the Ast type from the article.<p>Parsing something might be trivial but its still parsing</div><br/><div id="36592915" class="c"><input type="checkbox" id="c-36592915" checked=""/><div class="controls bullet"><span class="by">mostlylurks</span><span>|</span><a href="#36591497">root</a><span>|</span><a href="#36592691">parent</a><span>|</span><a href="#36592792">next</a><span>|</span><label class="collapse" for="c-36592915">[-]</label><label class="expand" for="c-36592915">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Not parsed ahead of time&quot; might be the better qualification. At least in some forths you can cease parsing the file (in the &quot;outer interpreter&quot;) at any point and perform any kind of computation or IO that you&#x27;ve previously defined, and based on that do whatever you want with the rest of the text of the source file (or just the next couple of tokens if you want), including parsing it manually in some other manner than what the outer interpreter would do by default. I haven&#x27;t gone that deep in lisp, but I hear reader macros allow something similar, though perhaps they might be more restrictive by requiring a transformation into valid lisp trees &#x2F; values, whereas forth allows you to just do whatever, and if that happens to have the side effect of adding new functions to the dictionary, so be it.</div><br/></div></div><div id="36592792" class="c"><input type="checkbox" id="c-36592792" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#36591497">root</a><span>|</span><a href="#36592691">parent</a><span>|</span><a href="#36592915">prev</a><span>|</span><a href="#36593180">next</a><span>|</span><label class="collapse" for="c-36592792">[-]</label><label class="expand" for="c-36592792">[6 more]</label></div><br/><div class="children"><div class="content">in that case, pretend I wrote &quot;grammarless&quot;<p>(in the examples above âwhich missed the prologsâ I&#x27;m pretty sure the parsing is trivial on the order of &quot;you can see everything that handles &#x27;parsing&#x27; without needing to scroll a window&quot;, and in several of those examples it&#x27;d still be true even if your windows were only 25 lines long)</div><br/><div id="36593382" class="c"><input type="checkbox" id="c-36593382" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#36591497">root</a><span>|</span><a href="#36592792">parent</a><span>|</span><a href="#36593788">next</a><span>|</span><label class="collapse" for="c-36593382">[-]</label><label class="expand" for="c-36593382">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; in that case, pretend I wrote &quot;grammarless&quot;
</code></pre>
Gonna call you out on that as well. Forth, sure. Forth is...Forth.<p>But Lisp is not grammarless. Smalltalk is not either. The Lisp reader, notably Common Lisp, is a non-trivial piece of code. The Common Lisp lambda list, as a language construct, is not trivial either. (Dare I mention the CL LOOP macro?) Just because everything is &quot;a list, symbol, or constant&quot; does necessarily make the parsing problem trivial.<p>It SEEMS simple, but then you get into it, and you find you fall into the weeds.</div><br/><div id="36593774" class="c"><input type="checkbox" id="c-36593774" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36591497">root</a><span>|</span><a href="#36593382">parent</a><span>|</span><a href="#36593788">next</a><span>|</span><label class="collapse" for="c-36593774">[-]</label><label class="expand" for="c-36593774">[3 more]</label></div><br/><div class="children"><div class="content">It seems those in this discussion arguing that they don&#x27;t need a parser or a grammar simply aren&#x27;t aware they&#x27;re implementing ad-hoc parsers and grammars but doing it poorly.</div><br/><div id="36594118" class="c"><input type="checkbox" id="c-36594118" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#36591497">root</a><span>|</span><a href="#36593774">parent</a><span>|</span><a href="#36593788">next</a><span>|</span><label class="collapse" for="c-36594118">[-]</label><label class="expand" for="c-36594118">[2 more]</label></div><br/><div class="children"><div class="content">Not only am I exactly aware of that, I am even <i>advocating</i> it.<p>OP wants to write a hobby language, not reimplement Common Lisp.<p>If OP wants sexprs, they can get quick-and-dirty sexprs by:<p><pre><code>  (1) substituting spaces around each paren in the input
  (2) breaking input up into a list of whitespace separated words
  (3) folding over the resulting list (by looking at its parens) into a tree
</code></pre>
Sure, that&#x27;s done poorly. However, it takes under 15 minutes (and under 15 lines?) to get them past their sticking point, and <i>if</i> the rest of their language (especially the part that differs from all other languages) actually turns out to be worth pursuing, they can always implement (or import) a real âor at least a betterâ reader later.<p>See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36593060">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36593060</a></div><br/><div id="36596350" class="c"><input type="checkbox" id="c-36596350" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36591497">root</a><span>|</span><a href="#36594118">parent</a><span>|</span><a href="#36593788">next</a><span>|</span><label class="collapse" for="c-36596350">[-]</label><label class="expand" for="c-36596350">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If OP wants sexprs, they can get quick-and-dirty sexprs by:<p>You know what it takes to implement a parser for s expressions?<p>E := atom | &#x27;(&#x27; *E &#x27;)&#x27;<p>With atom expanding to all data types you wish to support.<p>Let&#x27;s presume using a parser generator is an insurmountable task for someone developing a parser. In a hand-rolled packrat parser, this whole grammar is implemented with a couple of functions.<p>Is writing two functions too much work for someone wanting to write their own parser?<p>Your ad-hoc trick is much more work than actually implementing a proper, maintainable parser.</div><br/></div></div></div></div></div></div></div></div><div id="36593788" class="c"><input type="checkbox" id="c-36593788" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#36591497">root</a><span>|</span><a href="#36592792">parent</a><span>|</span><a href="#36593382">prev</a><span>|</span><a href="#36593180">next</a><span>|</span><label class="collapse" for="c-36593788">[-]</label><label class="expand" for="c-36593788">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in that case, pretend I wrote &quot;grammarless&quot;<p>You are always parsing a grammar. It seems you simply aren&#x27;t aware of it.<p>Every single time you write code that expects to find a certain type of token after another type of token, you have a grammar.</div><br/></div></div></div></div></div></div><div id="36593180" class="c"><input type="checkbox" id="c-36593180" checked=""/><div class="controls bullet"><span class="by">jdougan</span><span>|</span><a href="#36591497">parent</a><span>|</span><a href="#36592691">prev</a><span>|</span><a href="#36593885">next</a><span>|</span><label class="collapse" for="c-36593180">[-]</label><label class="expand" for="c-36593180">[1 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t compiled, but the way Smalltalk-72 did ?integrated into the rest of the execution? parsing is worth understanding.<p><a href="http:&#x2F;&#x2F;worrydream.com&#x2F;EarlyHistoryOfSmalltalk&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;worrydream.com&#x2F;EarlyHistoryOfSmalltalk&#x2F;</a></div><br/></div></div><div id="36593885" class="c"><input type="checkbox" id="c-36593885" checked=""/><div class="controls bullet"><span class="by">prmph</span><span>|</span><a href="#36591497">parent</a><span>|</span><a href="#36593180">prev</a><span>|</span><a href="#36592770">next</a><span>|</span><label class="collapse" for="c-36593885">[-]</label><label class="expand" for="c-36593885">[1 more]</label></div><br/><div class="children"><div class="content">I had the same thought as the OP about a language I wanted to design to explore some concepts, and thought of using JSON as the syntax, with the grammar defined as a JSON schema.</div><br/></div></div></div></div><div id="36592770" class="c"><input type="checkbox" id="c-36592770" checked=""/><div class="controls bullet"><span class="by">djedr</span><span>|</span><a href="#36591497">prev</a><span>|</span><a href="#36596766">next</a><span>|</span><label class="collapse" for="c-36592770">[-]</label><label class="expand" for="c-36592770">[4 more]</label></div><br/><div class="children"><div class="content">This is one thing I designed Jevko[0][1] for.<p>If you have an idea for a format or a language and would like to quickly start hacking on the layer above the syntax, Jevko is an option.<p>It&#x27;s meant to be even simpler and hackable than S-expressions.<p>It gets you from a string to a tree in the least amount of steps.<p>See here[2] if interested.<p>Happy hacking!<p>[0] <a href="https:&#x2F;&#x2F;jevko.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jevko.org&#x2F;</a>
[1] <a href="https:&#x2F;&#x2F;djedr.github.io&#x2F;posts&#x2F;jevko-2022-02-22.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;djedr.github.io&#x2F;posts&#x2F;jevko-2022-02-22.html</a>
[2] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;djedr&#x2F;151241f1a9a5bc627059dd9b23fc7432" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;djedr&#x2F;151241f1a9a5bc627059dd9b23fc74...</a></div><br/><div id="36592804" class="c"><input type="checkbox" id="c-36592804" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36592770">parent</a><span>|</span><a href="#36593987">next</a><span>|</span><label class="collapse" for="c-36592804">[-]</label><label class="expand" for="c-36592804">[2 more]</label></div><br/><div class="children"><div class="content">With the square brackets it has a bit of a Rebol feel to it. Was that intentional or coincidental?</div><br/><div id="36593250" class="c"><input type="checkbox" id="c-36593250" checked=""/><div class="controls bullet"><span class="by">djedr</span><span>|</span><a href="#36592770">root</a><span>|</span><a href="#36592804">parent</a><span>|</span><a href="#36593987">next</a><span>|</span><label class="collapse" for="c-36593250">[-]</label><label class="expand" for="c-36593250">[1 more]</label></div><br/><div class="children"><div class="content">I suppose a bit of both.<p>I was more directly inspired by Lisps, but I do prefer the original M-expressions and the syntactic choices that REBOL and Red make.<p>I think placing the operator before the opening bracket better emphasizes its special significance and can reduce nesting for constructs like `f[x][y]` (vs. `((f x) y)` in Lisps). Square brackets somehow seem more aesthetically pleasing to me. And there is a practical reason to prefer them, especially if your syntax uses only one kind of brackets -- square brackets are the easiest to type on an average keyboard.<p>So REBOL-like syntax is nicer. As were M-expressions. They probably didn&#x27;t catch on, because they were not minimal enough, compared to S-expressions. And maybe because S-expressions were fully implemented first.</div><br/></div></div></div></div><div id="36593987" class="c"><input type="checkbox" id="c-36593987" checked=""/><div class="controls bullet"><span class="by">marssaxman</span><span>|</span><a href="#36592770">parent</a><span>|</span><a href="#36592804">prev</a><span>|</span><a href="#36596766">next</a><span>|</span><label class="collapse" for="c-36593987">[-]</label><label class="expand" for="c-36593987">[1 more]</label></div><br/><div class="children"><div class="content">Nice project. Thank you for sharing.</div><br/></div></div></div></div><div id="36596766" class="c"><input type="checkbox" id="c-36596766" checked=""/><div class="controls bullet"><span class="by">pie_flavor</span><span>|</span><a href="#36592770">prev</a><span>|</span><a href="#36592984">next</a><span>|</span><label class="collapse" for="c-36596766">[-]</label><label class="expand" for="c-36596766">[2 more]</label></div><br/><div class="children"><div class="content">One great resource for making a language without a parser, not just delaying it but never writing it at all, is JetBrains&#x27; MPS[0]. It lets you make languages in a <i>projectional</i> editor: rather than a syntax parsed into an AST, you edit the AST directly in a series of GUI cells pretending to be an editor, much as in MS Word, so rather than writing a parser from syntax to AST, you write a renderer from AST to syntax.<p>Benefits of this approach include there being no such thing as a syntax ambiguity, language extensions being as easy to make as libraries, the language being easy to write by non-programmers, and a JetBrains IDE for your language - at the cost of not being able to use any <i>other</i> editor.<p>A great example of such a language is mbeddr[1].<p>[0]: <a href="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;mps&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jetbrains.com&#x2F;mps&#x2F;</a><p>[1]: <a href="http:&#x2F;&#x2F;mbeddr.com&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;mbeddr.com&#x2F;</a></div><br/><div id="36597532" class="c"><input type="checkbox" id="c-36597532" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36596766">parent</a><span>|</span><a href="#36592984">next</a><span>|</span><label class="collapse" for="c-36597532">[-]</label><label class="expand" for="c-36597532">[1 more]</label></div><br/><div class="children"><div class="content">Just last week I went through the calculator tutorial and I gotta say nah this ain&#x27;t it.<p>I had hope even though I knew what the deal with projectional was going in and indeed I was disappointed. The number of proprietary &quot;dsl&quot;s you have to grok to be proficient at using MPS is just mind-boggling and that&#x27;s coming from someone that designs dsls for a living. Like by the time you get to codegen you&#x27;re already 3 or 4 deep. And it&#x27;s only for codegen, where you&#x27;re generating Java, that you get the full projectional editor treatment. Everything else is just a gui form for some small &quot;dsl&quot; with effectively dropdowns, so you might as well just call it an API for a configuration system rather than a language. Like there&#x27;s zero composition for the structure &quot;language&quot; and the editor &quot;language&quot;. You&#x27;re literally just toggling forms.<p>It&#x27;s just a complete turn-off because even if it is &quot;powerful&quot; it&#x27;s completely non-portable - you cannot ship anything without shipping MPS to orchestrate the cascade of dsls.<p>I tried to get mbeddr to work but could not even though I can drive gradle and etc fine.<p>Overall really disappointing.</div><br/></div></div></div></div><div id="36592984" class="c"><input type="checkbox" id="c-36592984" checked=""/><div class="controls bullet"><span class="by">glonq</span><span>|</span><a href="#36596766">prev</a><span>|</span><a href="#36591502">next</a><span>|</span><label class="collapse" for="c-36592984">[-]</label><label class="expand" for="c-36592984">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I canât tell you why I keep returning to this venture when Iâve failed at it so many times.</i><p>Sorry if this sounds stupid or obvious, but with this kind of thing I find that it&#x27;s easier to cross the finish line if you maintain humble goals.  Focus on just getting a working end-to-end MVP.  Refine and enhance it down the road; don&#x27;t get stuck trying to make version 0 an awesomely praiseworthy effort.</div><br/><div id="36593899" class="c"><input type="checkbox" id="c-36593899" checked=""/><div class="controls bullet"><span class="by">thunderseethe</span><span>|</span><a href="#36592984">parent</a><span>|</span><a href="#36591502">next</a><span>|</span><label class="collapse" for="c-36593899">[-]</label><label class="expand" for="c-36593899">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely! That&#x27;s what I&#x27;m attempting this time. I&#x27;m hoping if I start with literally just the lambda calc + integer literals I can get something working e2e and layer stuff on top from there</div><br/></div></div></div></div><div id="36591502" class="c"><input type="checkbox" id="c-36591502" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#36592984">prev</a><span>|</span><a href="#36594739">next</a><span>|</span><label class="collapse" for="c-36591502">[-]</label><label class="expand" for="c-36591502">[3 more]</label></div><br/><div class="children"><div class="content">This is one of the cases where you actually <i>do</i> want Lisp-style s-expressions, because they don&#x27;t need any real parsing; functionally speaking, they are <i>already</i> the AST. (This is why you sometimes hear people saying that Lisp &quot;doesn&#x27;t have syntax&quot;.)</div><br/><div id="36592097" class="c"><input type="checkbox" id="c-36592097" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#36591502">parent</a><span>|</span><a href="#36591833">next</a><span>|</span><label class="collapse" for="c-36592097">[-]</label><label class="expand" for="c-36592097">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is why you sometimes hear people saying that Lisp &quot;doesn&#x27;t have syntax&quot;.<p>The other reason is that a language like Common Lisp is defined in terms of the data-structures used by the language and the language has no unique text representation: the âdefaultâ reader uses a slightly extended version of s-expressions, but any data structure in the language can be evaluated and any transform from text to data structures can be a textual syntax for Common Lisp.</div><br/></div></div><div id="36591833" class="c"><input type="checkbox" id="c-36591833" checked=""/><div class="controls bullet"><span class="by">patrec</span><span>|</span><a href="#36591502">parent</a><span>|</span><a href="#36592097">prev</a><span>|</span><a href="#36594739">next</a><span>|</span><label class="collapse" for="c-36591833">[-]</label><label class="expand" for="c-36591833">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. And if you are paren-phobic, you could also have a look at Postscript, Forth or even Smalltalk&#x2F;Self -- the last two are about the most minimal you can get with infix operators (but no precedence) and &quot;keyword-arguments&quot; (sort of), well, unless you want to go all-in on infix, and do APL.</div><br/></div></div></div></div><div id="36594739" class="c"><input type="checkbox" id="c-36594739" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36591502">prev</a><span>|</span><a href="#36595602">next</a><span>|</span><label class="collapse" for="c-36594739">[-]</label><label class="expand" for="c-36594739">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an interesting anecdote in the same spirit of skipping uninteresting work. Back when I worked with a rather experienced Haskell developer, he also wanted to design a language but dreaded the part where a parser was needed. Besides that, he took the further shortcut of representing functions in his language using functions in the host language Haskell. That is to say, the AST for functions contains Haskell functions. This technique is called higher-order abstract syntax.<p>Naturally there are limitations here. There&#x27;s not much you can do to poke into the structure of Haskell functions other than evaluating them, so any sort of optimization and code gen work must happen by evaluating the function in Haskell, which gives you more of a challenge in designing the AST.<p>That said so far the author&#x27;s language resembles simply typed lambda calculus and this is generally too simple. The meat of the language hasn&#x27;t actually been designed yet in this post.</div><br/></div></div><div id="36595602" class="c"><input type="checkbox" id="c-36595602" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#36594739">prev</a><span>|</span><a href="#36596078">next</a><span>|</span><label class="collapse" for="c-36595602">[-]</label><label class="expand" for="c-36595602">[1 more]</label></div><br/><div class="children"><div class="content">The parser design space is really interesting, but recursive descent seems to be the best go to, and you donât have to think about parsing theory much. Or you could go with no syntax (lisp or scheme style), or a structured language (but youâll need to do your own editor for that).<p>You could also try doing an embedded DSL in Haskell or even Kotlin if you just want to get your feet wet.</div><br/></div></div><div id="36596078" class="c"><input type="checkbox" id="c-36596078" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#36595602">prev</a><span>|</span><a href="#36591437">next</a><span>|</span><label class="collapse" for="c-36596078">[-]</label><label class="expand" for="c-36596078">[1 more]</label></div><br/><div class="children"><div class="content">I have been thinking for quite some time about using XML for this. It is pure AST you can relatively conveniently author as text.<p>Having nice syntax is a good thing, yet no matter what the syntax is, it ends up as an AST. And the structure of AST records and the ways they can be combined matters quite a lot, I would say more than text syntax. XML makes it visible and easy to experiment with without getting distracted by text syntax niceties.</div><br/></div></div><div id="36591437" class="c"><input type="checkbox" id="c-36591437" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#36596078">prev</a><span>|</span><a href="#36593910">next</a><span>|</span><label class="collapse" for="c-36591437">[-]</label><label class="expand" for="c-36591437">[4 more]</label></div><br/><div class="children"><div class="content">One option you could also try is to use an existing language&#x27;s syntax. Plenty of languages have high quality parser libraries by now, like swc&#x2F;rome&#x2F;acorn for JavaScript, rustc_parse for Rust, et. Of course syntax is influenced by semantics, so you&#x27;ll end up wanting to remove or add syntax, but you could probably get decently far before that ends up a problem.</div><br/><div id="36591857" class="c"><input type="checkbox" id="c-36591857" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36591437">parent</a><span>|</span><a href="#36593910">next</a><span>|</span><label class="collapse" for="c-36591857">[-]</label><label class="expand" for="c-36591857">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Of course syntax is influenced by semantics<p>Only to the extent that AST structure depends on syntax. For something like s-expressions defining new semantics never requires new syntax since arbitrary trees suffice to syntactically express any AST.</div><br/><div id="36592991" class="c"><input type="checkbox" id="c-36592991" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#36591437">root</a><span>|</span><a href="#36591857">parent</a><span>|</span><a href="#36593659">next</a><span>|</span><label class="collapse" for="c-36592991">[-]</label><label class="expand" for="c-36592991">[1 more]</label></div><br/><div class="children"><div class="content">One of my exploratory projects while I still though that academics career made sense involved replacing smalltalk&#x27;s stack based bytecode with incrementally transformed S-expression trees. Naturally the first thing I went out to do was writing S-expression reader and writer in smalltalk, my advisor at the time told me that it is pointless busywork and I should just use ST literal syntax, it looked somewhat ugly with all the # there, but saved a lot of time.<p>Well, 12 years later (ie. early 2023) I realized that I don&#x27;t really have any kind of cool sideproject and started implementing the same idea in C (with the added goal of the VM being natively multithreaded with fine-grained locking along the lines of JikesRVM and WebKit). Well, I have stub implementations of classes needed for the AST representation and S-expression reader and writerâ¦</div><br/></div></div><div id="36593659" class="c"><input type="checkbox" id="c-36593659" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#36591437">root</a><span>|</span><a href="#36591857">parent</a><span>|</span><a href="#36592991">prev</a><span>|</span><a href="#36593910">next</a><span>|</span><label class="collapse" for="c-36593659">[-]</label><label class="expand" for="c-36593659">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but if you&#x27;re using an existing language grammar, it will almost certainly be influenced by the language&#x27;s semantics, unless that language happens to be lisp (and even then most lisps are not pure s-expressions)</div><br/></div></div></div></div></div></div><div id="36593910" class="c"><input type="checkbox" id="c-36593910" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36591437">prev</a><span>|</span><a href="#36592202">next</a><span>|</span><label class="collapse" for="c-36593910">[-]</label><label class="expand" for="c-36593910">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Without fail by the time Iâve managed to produce an Abstract Syntax Tree (AST) Iâve lost all steam.</i><p>Lisp helps with this. You have the syntax settled, and can concentrate on the language from the get-go with all your steam.</div><br/></div></div><div id="36592202" class="c"><input type="checkbox" id="c-36592202" checked=""/><div class="controls bullet"><span class="by">porcoda</span><span>|</span><a href="#36593910">prev</a><span>|</span><a href="#36593072">next</a><span>|</span><label class="collapse" for="c-36592202">[-]</label><label class="expand" for="c-36592202">[1 more]</label></div><br/><div class="children"><div class="content">I like this.  The focus on lexing&#x2F;parsing for language implementation often overshadows the fact that the bulk of the work in any language effort is in the semantics and analysis (e.g., everything after one has a parse tree).  On the production compiler I get paid to work on, front end work makes up at most 10% of the team time and effort.  Even on experimental language projects that we occasionally play with, the front end is usually given minimal attention - just enough to have a syntax that we can use to start instantiating ASTs and doing the interesting work.  More often than not, I punt on a front end altogether and just piggyback on some existing language (e.g., Haskell, ML, etc) and basically explore the semantics or analysis questions I&#x27;m interested in via a DSL-style embedding and ignore syntax altogether.</div><br/></div></div><div id="36593072" class="c"><input type="checkbox" id="c-36593072" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#36592202">prev</a><span>|</span><a href="#36597409">next</a><span>|</span><label class="collapse" for="c-36593072">[-]</label><label class="expand" for="c-36593072">[1 more]</label></div><br/><div class="children"><div class="content">I always start with the AST and just work forward and backward from there.</div><br/></div></div><div id="36591931" class="c"><input type="checkbox" id="c-36591931" checked=""/><div class="controls bullet"><span class="by">ftomassetti</span><span>|</span><a href="#36597409">prev</a><span>|</span><a href="#36591460">next</a><span>|</span><label class="collapse" for="c-36591931">[-]</label><label class="expand" for="c-36591931">[1 more]</label></div><br/><div class="children"><div class="content">Honestly designing a parser is easy: just start using ANTLR and perhaps add later an AST layer. However if you do not want to go that I suggest looking in projectional editing, for example JetBrains MPS or Freon by Jos Warmer</div><br/></div></div><div id="36591460" class="c"><input type="checkbox" id="c-36591460" checked=""/><div class="controls bullet"><span class="by">zarathustreal</span><span>|</span><a href="#36591931">prev</a><span>|</span><label class="collapse" for="c-36591460">[-]</label><label class="expand" for="c-36591460">[2 more]</label></div><br/><div class="children"><div class="content">See also: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;PROGRAM-PROOF-Samuel-Mimram&#x2F;dp&#x2F;B08C97TD9G" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amazon.com&#x2F;PROGRAM-PROOF-Samuel-Mimram&#x2F;dp&#x2F;B08C97...</a></div><br/><div id="36592461" class="c"><input type="checkbox" id="c-36592461" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36591460">parent</a><span>|</span><label class="collapse" for="c-36592461">[-]</label><label class="expand" for="c-36592461">[1 more]</label></div><br/><div class="children"><div class="content">Also available for free from the author: <a href="https:&#x2F;&#x2F;www.lix.polytechnique.fr&#x2F;Labo&#x2F;Samuel.Mimram&#x2F;teaching&#x2F;INF551&#x2F;course.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.lix.polytechnique.fr&#x2F;Labo&#x2F;Samuel.Mimram&#x2F;teaching...</a> [pdf]<p>Course page: <a href="https:&#x2F;&#x2F;www.lix.polytechnique.fr&#x2F;Labo&#x2F;Samuel.Mimram&#x2F;teaching&#x2F;INF551&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.lix.polytechnique.fr&#x2F;Labo&#x2F;Samuel.Mimram&#x2F;teaching...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>