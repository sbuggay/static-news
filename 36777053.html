<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689757254306" as="style"/><link rel="stylesheet" href="styles.css?v=1689757254306"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.citusdata.com/blog/2023/07/18/citus-12-schema-based-sharding-for-postgres/">Citus 12: Schema-based sharding for PostgreSQL</a>Â <span class="domain">(<a href="https://www.citusdata.com">www.citusdata.com</a>)</span></div><div class="subtext"><span>mulander</span> | <span>40 comments</span></div><br/><div><div id="36778029" class="c"><input type="checkbox" id="c-36778029" checked=""/><div class="controls bullet"><span class="by">mslot</span><span>|</span><a href="#36778185">next</a><span>|</span><label class="collapse" for="c-36778029">[-]</label><label class="expand" for="c-36778029">[3 more]</label></div><br/><div class="children"><div class="content">Nice to see this on HN :)<p>The high-level is: You enable a setting and every CREATE SCHEMA creates a new shard. All the tables in the schema will be co-located so you can have efficient joins &amp; foreign keys between the tables.<p>On top of that, you can also have reference tables that are replicated to all nodes, again for fast joins &amp; foreign keys with all schemas.<p>Everything else is about making every PostgreSQL feature work as seamlessly as if there was no sharding. You can still do things like transactions across schemas, create and use custom types, access controls, work with other extensions, use procedures, etc.</div><br/><div id="36781392" class="c"><input type="checkbox" id="c-36781392" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#36778029">parent</a><span>|</span><a href="#36778185">next</a><span>|</span><label class="collapse" for="c-36781392">[-]</label><label class="expand" for="c-36781392">[2 more]</label></div><br/><div class="children"><div class="content">Is there any way to have that automatically create n copies of the data across shards?<p>Something like a &quot;min-copies 2&quot; setting, which would ensure the shared data has at least one viable alternative in case of hardware failure (etc).</div><br/><div id="36782491" class="c"><input type="checkbox" id="c-36782491" checked=""/><div class="controls bullet"><span class="by">mslot</span><span>|</span><a href="#36778029">root</a><span>|</span><a href="#36781392">parent</a><span>|</span><a href="#36778185">next</a><span>|</span><label class="collapse" for="c-36782491">[-]</label><label class="expand" for="c-36782491">[1 more]</label></div><br/><div class="children"><div class="content">Historically, there has been, but we have found physical replication is ultimately a lot more performant, robust, and tweakable. Citus users &amp; platforms generally use physical replication of each node for high availability.<p>For instance, the ability to quickly spin up a new replica using a disk snapshot is very useful and only feasible at the server level.<p>It is still possible to replicate shards (via the citus.shard_replication_factor setting), but it only helps for scaling read throughput, at the cost of lower write throughput.</div><br/></div></div></div></div></div></div><div id="36778185" class="c"><input type="checkbox" id="c-36778185" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#36778029">prev</a><span>|</span><a href="#36779873">next</a><span>|</span><label class="collapse" for="c-36778185">[-]</label><label class="expand" for="c-36778185">[5 more]</label></div><br/><div class="children"><div class="content">Does Oracle support anything like this?  Or <i>any other</i> DBMS in widespread use, for that matter?<p>The promise behind this approach to DB sharding has great potential.  Simultaneously impressive, novel, and badass.<p>I wish this had been available ten years ago at a few of my startups!</div><br/><div id="36780474" class="c"><input type="checkbox" id="c-36780474" checked=""/><div class="controls bullet"><span class="by">isoos</span><span>|</span><a href="#36778185">parent</a><span>|</span><a href="#36782398">next</a><span>|</span><label class="collapse" for="c-36780474">[-]</label><label class="expand" for="c-36780474">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the definition of widespread use, but e.g. CockroachDB and YugabyteDB offer scaling of a subset of Postgresql features (and extending on the cluster capabilities).<p>Nevertheless, Citus is now a promising open source alternative.</div><br/></div></div><div id="36782398" class="c"><input type="checkbox" id="c-36782398" checked=""/><div class="controls bullet"><span class="by">sokols</span><span>|</span><a href="#36778185">parent</a><span>|</span><a href="#36780474">prev</a><span>|</span><a href="#36780067">next</a><span>|</span><label class="collapse" for="c-36782398">[-]</label><label class="expand" for="c-36782398">[1 more]</label></div><br/><div class="children"><div class="content">There is Oracle RAC Sharding, but AFAIK  it works only at a partition level.</div><br/></div></div><div id="36780067" class="c"><input type="checkbox" id="c-36780067" checked=""/><div class="controls bullet"><span class="by">brightball</span><span>|</span><a href="#36778185">parent</a><span>|</span><a href="#36782398">prev</a><span>|</span><a href="#36779873">next</a><span>|</span><label class="collapse" for="c-36780067">[-]</label><label class="expand" for="c-36780067">[2 more]</label></div><br/><div class="children"><div class="content">I watched a Citus demo a few months back and it blew me away. I hear upgrades are the big challenge.</div><br/><div id="36783558" class="c"><input type="checkbox" id="c-36783558" checked=""/><div class="controls bullet"><span class="by">krab</span><span>|</span><a href="#36778185">root</a><span>|</span><a href="#36780067">parent</a><span>|</span><a href="#36779873">next</a><span>|</span><label class="collapse" for="c-36783558">[-]</label><label class="expand" for="c-36783558">[1 more]</label></div><br/><div class="children"><div class="content">Not really. It&#x27;s comparable to a regular Postgres upgrade.<p>But you can screw it up - see <a href="https:&#x2F;&#x2F;github.com&#x2F;citusdata&#x2F;citus&#x2F;discussions&#x2F;6934">https:&#x2F;&#x2F;github.com&#x2F;citusdata&#x2F;citus&#x2F;discussions&#x2F;6934</a></div><br/></div></div></div></div></div></div><div id="36779873" class="c"><input type="checkbox" id="c-36779873" checked=""/><div class="controls bullet"><span class="by">skunkworker</span><span>|</span><a href="#36778185">prev</a><span>|</span><a href="#36777870">next</a><span>|</span><label class="collapse" for="c-36779873">[-]</label><label class="expand" for="c-36779873">[3 more]</label></div><br/><div class="children"><div class="content">Having used schema based sharding in postgres before, I hope citus has a way around connection pooling and pgbouncer, as if you use pgbouncer transaction pooling your search_path could disappear at any time.</div><br/><div id="36779951" class="c"><input type="checkbox" id="c-36779951" checked=""/><div class="controls bullet"><span class="by">mulander</span><span>|</span><a href="#36779873">parent</a><span>|</span><a href="#36779986">next</a><span>|</span><label class="collapse" for="c-36779951">[-]</label><label class="expand" for="c-36779951">[1 more]</label></div><br/><div class="children"><div class="content">Great observation! :)<p>We worked upstream to have `search_path` properly handled (tracked per client) by pgbouncer.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;pgbouncer&#x2F;pgbouncer&#x2F;commit&#x2F;8c18fc4d213ad425841434767b71616dc3386102">https:&#x2F;&#x2F;github.com&#x2F;pgbouncer&#x2F;pgbouncer&#x2F;commit&#x2F;8c18fc4d213ad4...</a><p>Check config.md in that commit for a verbose, humanized description.</div><br/></div></div></div></div><div id="36777870" class="c"><input type="checkbox" id="c-36777870" checked=""/><div class="controls bullet"><span class="by">pickledish</span><span>|</span><a href="#36779873">prev</a><span>|</span><a href="#36780387">next</a><span>|</span><label class="collapse" for="c-36777870">[-]</label><label class="expand" for="c-36777870">[12 more]</label></div><br/><div class="children"><div class="content">Hm, question for people a bit more familiar with Postgres -- what is meant by &quot;schema&quot; here?<p>My definition is &quot;the columns and column types of a table&quot;, but, that doesn&#x27;t seem to make sense with what they&#x27;re talking about here (&quot;large&quot; and &quot;small&quot; schemas probably aren&#x27;t referring to wide and narrow tables for example, and I don&#x27;t see how sharding by my definition of &quot;schema&quot; could even make sense anyways)</div><br/><div id="36778011" class="c"><input type="checkbox" id="c-36778011" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#36777870">parent</a><span>|</span><a href="#36777908">next</a><span>|</span><label class="collapse" for="c-36778011">[-]</label><label class="expand" for="c-36778011">[3 more]</label></div><br/><div class="children"><div class="content">Schemas are namespaces (actually called that internally  in Postgres).<p>The SQL standard defines a two level namespace hierarchy. A single &quot;instance&quot; of contains multiple catalogs and each catalog contains multiple schemas (and each schema then contains objects like tables, views, types, functions etc).<p>Many database products use the term &quot;database&quot; instead of &quot;catalog&quot; e.g. in Postgres and SQL Server. But &quot;schema&quot; is used quite uniformly. MySQL&#x27;s &quot;databases&quot; are in fact &quot;schemas&quot; though.</div><br/><div id="36783160" class="c"><input type="checkbox" id="c-36783160" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#36777870">root</a><span>|</span><a href="#36778011">parent</a><span>|</span><a href="#36778048">next</a><span>|</span><label class="collapse" for="c-36783160">[-]</label><label class="expand" for="c-36783160">[1 more]</label></div><br/><div class="children"><div class="content">I always vaguely wonder why no one allowed a full hierarchical schema path. I expect it  is probably because &quot;the standard sez one level of schema only&quot;</div><br/></div></div><div id="36778048" class="c"><input type="checkbox" id="c-36778048" checked=""/><div class="controls bullet"><span class="by">pickledish</span><span>|</span><a href="#36777870">root</a><span>|</span><a href="#36778011">parent</a><span>|</span><a href="#36783160">prev</a><span>|</span><a href="#36777908">next</a><span>|</span><label class="collapse" for="c-36778048">[-]</label><label class="expand" for="c-36778048">[1 more]</label></div><br/><div class="children"><div class="content">Whew boy, that&#x27;s a more sizable hierarchy than I thought was going on under the hood lol, I guess I&#x27;ve got some reading to do. TY for the pointers!</div><br/></div></div></div></div><div id="36777908" class="c"><input type="checkbox" id="c-36777908" checked=""/><div class="controls bullet"><span class="by">mulander</span><span>|</span><a href="#36777870">parent</a><span>|</span><a href="#36778011">prev</a><span>|</span><a href="#36777937">next</a><span>|</span><label class="collapse" for="c-36777908">[-]</label><label class="expand" for="c-36777908">[4 more]</label></div><br/><div class="children"><div class="content">Schemas are groupings of tables and other entities that can be defined within a database. You can think of them like of a namespace in programming languages. You can have the same table definition, within the same database, defined multiple times (each in a different schema) and each holding different data.<p>By large and small we are referring to the amount of data each schema holds currently. They can grow over time and some of them may become very big while others will remain small (storage wise).</div><br/><div id="36778094" class="c"><input type="checkbox" id="c-36778094" checked=""/><div class="controls bullet"><span class="by">pickledish</span><span>|</span><a href="#36777870">root</a><span>|</span><a href="#36777908">parent</a><span>|</span><a href="#36777937">next</a><span>|</span><label class="collapse" for="c-36778094">[-]</label><label class="expand" for="c-36778094">[3 more]</label></div><br/><div class="children"><div class="content">Ah, interesting ok<p>&gt; You can have the same table definition, within the same database, defined multiple times (each in a different schema) and each holding different data.<p>So in this respect, each table within a schema indeed already acts like a &quot;shard&quot; of the overall table<p>Is this enforced? Like, if I create a table &quot;messages&quot; in schema A and a table &quot;messages&quot; in table B, must they have the same columns&#x2F;column types, or is that just convention</div><br/><div id="36778171" class="c"><input type="checkbox" id="c-36778171" checked=""/><div class="controls bullet"><span class="by">mulander</span><span>|</span><a href="#36777870">root</a><span>|</span><a href="#36778094">parent</a><span>|</span><a href="#36777937">next</a><span>|</span><label class="collapse" for="c-36778171">[-]</label><label class="expand" for="c-36778171">[2 more]</label></div><br/><div class="children"><div class="content">They can be different, as long as your application can handle them being different (which makes sense for microservices as an example).</div><br/><div id="36778219" class="c"><input type="checkbox" id="c-36778219" checked=""/><div class="controls bullet"><span class="by">pickledish</span><span>|</span><a href="#36777870">root</a><span>|</span><a href="#36778171">parent</a><span>|</span><a href="#36777937">next</a><span>|</span><label class="collapse" for="c-36778219">[-]</label><label class="expand" for="c-36778219">[1 more]</label></div><br/><div class="children"><div class="content">I see! Fascinating, thanks for the help :)</div><br/></div></div></div></div></div></div></div></div><div id="36777937" class="c"><input type="checkbox" id="c-36777937" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36777870">parent</a><span>|</span><a href="#36777908">prev</a><span>|</span><a href="#36777884">next</a><span>|</span><label class="collapse" for="c-36777937">[-]</label><label class="expand" for="c-36777937">[2 more]</label></div><br/><div class="children"><div class="content">Not to be rude...but the same things as every other ANSI SQL database. Nothing PostgreSQL specific here.<p>Schema is the thing you get from `CREATE SCHEMA`...a namespace of tables&#x2F;functions&#x2F;views&#x2F;etc.</div><br/><div id="36778013" class="c"><input type="checkbox" id="c-36778013" checked=""/><div class="controls bullet"><span class="by">pickledish</span><span>|</span><a href="#36777870">root</a><span>|</span><a href="#36777937">parent</a><span>|</span><a href="#36777884">next</a><span>|</span><label class="collapse" for="c-36778013">[-]</label><label class="expand" for="c-36778013">[1 more]</label></div><br/><div class="children"><div class="content">Ah I see! Yeah I guess it&#x27;s just a concept I&#x27;ve never run into before; unfortunate that it shares a name with the &quot;other&quot; concept of schema used by e.g. <a href="https:&#x2F;&#x2F;json-schema.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;json-schema.org</a><p>Thank you!</div><br/></div></div></div></div><div id="36777884" class="c"><input type="checkbox" id="c-36777884" checked=""/><div class="controls bullet"><span class="by">Hovertruck</span><span>|</span><a href="#36777870">parent</a><span>|</span><a href="#36777937">prev</a><span>|</span><a href="#36777924">next</a><span>|</span><label class="collapse" for="c-36777884">[-]</label><label class="expand" for="c-36777884">[1 more]</label></div><br/><div class="children"><div class="content">Schema is a proper noun in Postgres: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;ddl-schemas.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;ddl-schemas.html</a></div><br/></div></div><div id="36777924" class="c"><input type="checkbox" id="c-36777924" checked=""/><div class="controls bullet"><span class="by">ubertaco</span><span>|</span><a href="#36777870">parent</a><span>|</span><a href="#36777884">prev</a><span>|</span><a href="#36780387">next</a><span>|</span><label class="collapse" for="c-36777924">[-]</label><label class="expand" for="c-36777924">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen MySQL clients&#x2F;docs also use &quot;schema&quot; to refer to &quot;this collection of tables&quot;, basically what SQLite would call &quot;a database&quot;.<p>The words get really fuzzy here when you try to get a concrete and ubiquitous definition, though.<p>Best I can do is to say, in these queries:<p><pre><code>    use foo;
    select id, name from foo.people where id &lt; 10;

</code></pre>
...&quot;foo&quot; is the schema in MySQL and, apparently, Postgres parlance.</div><br/></div></div></div></div><div id="36780387" class="c"><input type="checkbox" id="c-36780387" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#36777870">prev</a><span>|</span><a href="#36780126">next</a><span>|</span><label class="collapse" for="c-36780387">[-]</label><label class="expand" for="c-36780387">[2 more]</label></div><br/><div class="children"><div class="content">What happens if one node lost their shards due to external event? (e.g. Disk corruption, physcially destroyed like OVH Cloud) I do understand we still have to actively backup but I rather not serve any data than serving wrong data at the time of severe outage. Also I want to see any forward error correction code (FECC) would be implemented in Citus so we can do this on the fly rather than relying on RAID, e.g. RAID10, RAIDZ1, RAIDZ2</div><br/><div id="36782583" class="c"><input type="checkbox" id="c-36782583" checked=""/><div class="controls bullet"><span class="by">mslot</span><span>|</span><a href="#36780387">parent</a><span>|</span><a href="#36780126">next</a><span>|</span><label class="collapse" for="c-36782583">[-]</label><label class="expand" for="c-36782583">[1 more]</label></div><br/><div class="children"><div class="content">The answer is mostly the same as for PostgreSQL, since Citus stores data in regular PostgreSQL tables.<p>It&#x27;s a good idea to set up archival into blob storage &#x2F; S3 using a tool like WAL-G for disaster recovery purposes, and streaming replication using a tool like Patroni.<p>(Or use a managed service like Azure Cosmos DB for PostgreSQL)<p>If a node is down and cannot be quickly recovered then the remaining shards are still available for reads and writes, except for DDLs.</div><br/></div></div></div></div><div id="36780126" class="c"><input type="checkbox" id="c-36780126" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#36780387">prev</a><span>|</span><a href="#36778866">next</a><span>|</span><label class="collapse" for="c-36780126">[-]</label><label class="expand" for="c-36780126">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s advantage over having tenant id as distribution column? Seems like you make schema name the distribution column. Maybe gross setups where same name function definition varies between schemas (been there done that, don&#x27;t want to do it again)<p>Seems like article only offers ease of use. Guess I&#x27;ve never used microservices enough to consider that use case<p>Couldn&#x27;t the microservice case be handled by having distributed tables with no distribution column? ie today I&#x27;d create a distribution column &amp; fill it with the same value on every row<p>Can one have a reference schema which can be efficiently used alongside every other schema? Guess that&#x27;s public schema with create_reference_table&#x2F;create_distributed_function</div><br/><div id="36783292" class="c"><input type="checkbox" id="c-36783292" checked=""/><div class="controls bullet"><span class="by">mslot</span><span>|</span><a href="#36780126">parent</a><span>|</span><a href="#36782533">next</a><span>|</span><label class="collapse" for="c-36783292">[-]</label><label class="expand" for="c-36783292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s advantage over having tenant id as distribution column?<p>Ease of use is definitely the main one. If you&#x27;re willing to put in the work required to use tenant ID as a distribution column (add it to tables, primary keys, foreign keys, filters, joins), then it&#x27;s a more scalable approach.<p>A challenge with sharding by tenant ID is that many applications use a normalized data model, meaning not all tables obviously have a tenant ID column. When you use a schema per tenant on vanilla PostgreSQL, no additional steps are typically required to enable schema-based sharding.<p>There are some other benefits of schema-based sharding such as custom table definitions, simpler &amp; more versatile access control, and longer term we expect it will be easier to pin a large tenant to a node using schemas, or distribute the tables of ultra-large tenants (by some other dimension). Of course, row-based sharding has other benefits like parallel cross-tenant queries and global DDL.<p>&gt; Couldn&#x27;t the microservice case be handled by having distributed tables with no distribution column?<p>Absolutely. We first implemented the notion of single shard distributed tables with a NULL distribution column, and then built schema-based sharding on top as a convenience layer.<p>&gt; Can one have a reference schema which can be efficiently used alongside every other schema? Guess that&#x27;s public schema with create_reference_table&#x2F;create_distributed_function<p>Yes, public schema (or other another non-distributed schema) can have reference tables &amp; distributed tables as usual, and tables in distributed schemas can have foreign keys &#x2F; local joins with reference tables.</div><br/></div></div><div id="36782533" class="c"><input type="checkbox" id="c-36782533" checked=""/><div class="controls bullet"><span class="by">janpio</span><span>|</span><a href="#36780126">parent</a><span>|</span><a href="#36783292">prev</a><span>|</span><a href="#36778866">next</a><span>|</span><label class="collapse" for="c-36782533">[-]</label><label class="expand" for="c-36782533">[1 more]</label></div><br/><div class="children"><div class="content">One reasons why some prefer multi tenancy via schemas instead of a tent ant column: Reading a column with the wrong tenant id happens easily, just forget the where in a query. Across schemas, this is much harder to get wrong as a schema has to be explicitly named in a query.</div><br/></div></div></div></div><div id="36778866" class="c"><input type="checkbox" id="c-36778866" checked=""/><div class="controls bullet"><span class="by">mariocesar</span><span>|</span><a href="#36780126">prev</a><span>|</span><a href="#36778112">next</a><span>|</span><label class="collapse" for="c-36778866">[-]</label><label class="expand" for="c-36778866">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m having trouble getting CitusDB to work with RDS, even though I&#x27;d really like to use it with AWS. Whenever I try to research how to make it happen, I get stuck in a lot of challenges and end up concluding that it might not be possible. While I could use Azure instead, I&#x27;m hesitant because I have a lot of resources and infrastructure in AWS and it wouldn&#x27;t make sense to move the database layer. The idea of having to do DBA and Ops work on my own EC2 instances is overwhelming. I would appreciate any guidance on how to use RDS with Citus on their documentation. It&#x27;s concerning that Citus might be withholding information about the possibility of using RDS, given that Microsoft is its partner.</div><br/><div id="36783580" class="c"><input type="checkbox" id="c-36783580" checked=""/><div class="controls bullet"><span class="by">krab</span><span>|</span><a href="#36778866">parent</a><span>|</span><a href="#36779760">next</a><span>|</span><label class="collapse" for="c-36783580">[-]</label><label class="expand" for="c-36783580">[1 more]</label></div><br/><div class="children"><div class="content">Because you can&#x27;t install extensions to RDS, I think it can&#x27;t be done unless AWS chooses to support it.<p>You can still install Postgres + Citus on EC2 or use some 3rd party service to manage it for you.</div><br/></div></div><div id="36779760" class="c"><input type="checkbox" id="c-36779760" checked=""/><div class="controls bullet"><span class="by">AlexB138</span><span>|</span><a href="#36778866">parent</a><span>|</span><a href="#36783580">prev</a><span>|</span><a href="#36780428">next</a><span>|</span><label class="collapse" for="c-36779760">[-]</label><label class="expand" for="c-36779760">[2 more]</label></div><br/><div class="children"><div class="content">Microsoft isn&#x27;t its &quot;partner&quot;, they were entirely bought by Microsoft. The goal is to make the technology an advantage for Azure, as I understand it. It&#x27;s very unlikely you&#x27;ll see them offer first-party support for RDS, or CloudSQL.</div><br/><div id="36780276" class="c"><input type="checkbox" id="c-36780276" checked=""/><div class="controls bullet"><span class="by">janee</span><span>|</span><a href="#36778866">root</a><span>|</span><a href="#36779760">parent</a><span>|</span><a href="#36780428">next</a><span>|</span><label class="collapse" for="c-36780276">[-]</label><label class="expand" for="c-36780276">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s a bit of a shame they were bought by one of the cloud providers.<p>Would&#x27;ve been great if something like Cruncy Bridge, PgAnalyze and Citus were merged into one company so that you have managed Postgres over the 3 major providers with the best pg tech out the box.<p>Having your DB and apps in different providers is a stuff up, the latency and data transfer costs killed us, so Citus was a non start (we don&#x27;t want to manage it ourselves in EC2).</div><br/></div></div></div></div><div id="36780428" class="c"><input type="checkbox" id="c-36780428" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#36778866">parent</a><span>|</span><a href="#36779760">prev</a><span>|</span><a href="#36779108">next</a><span>|</span><label class="collapse" for="c-36780428">[-]</label><label class="expand" for="c-36780428">[1 more]</label></div><br/><div class="children"><div class="content">Checkout stackgres: <a href="https:&#x2F;&#x2F;stackgres.io&#x2F;install&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackgres.io&#x2F;install&#x2F;</a><p>They are offering Citus integration</div><br/></div></div><div id="36779108" class="c"><input type="checkbox" id="c-36779108" checked=""/><div class="controls bullet"><span class="by">aamederen</span><span>|</span><a href="#36778866">parent</a><span>|</span><a href="#36780428">prev</a><span>|</span><a href="#36778112">next</a><span>|</span><label class="collapse" for="c-36779108">[-]</label><label class="expand" for="c-36779108">[1 more]</label></div><br/><div class="children"><div class="content">You can run Citus on EC2 for now.</div><br/></div></div></div></div><div id="36778112" class="c"><input type="checkbox" id="c-36778112" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#36778866">prev</a><span>|</span><label class="collapse" for="c-36778112">[-]</label><label class="expand" for="c-36778112">[5 more]</label></div><br/><div class="children"><div class="content">love citus!  this is useful.<p>one gotcha: schemas are a weird old thing in SQL that are kinda the worst of all worlds, basically more like prefixing your SQL object names than a real level of indirection. Schema objects can&#x27;t be manipulated as a batch, they don&#x27;t provide the isolation &#x2F; access control of databases, and can&#x27;t be manipulated in DML and require stored procedures to manipulate.</div><br/><div id="36778239" class="c"><input type="checkbox" id="c-36778239" checked=""/><div class="controls bullet"><span class="by">mslot</span><span>|</span><a href="#36778112">parent</a><span>|</span><a href="#36779298">next</a><span>|</span><label class="collapse" for="c-36778239">[-]</label><label class="expand" for="c-36778239">[1 more]</label></div><br/><div class="children"><div class="content">True, though I&#x27;d phrase it more as a middle ground. Which model is best depends on your needs.<p>A big advantage of schemas over databases is that you can access different schemas over the same connection, which allows much higher density, since connections are a scarce resource in PostgreSQL. You can also have shared tables.<p>A big advantage over row-based sharding is that you can have variations of the table definitions or a different set of tables altogether in each schema. Plus for the purpose of sharding it&#x27;s easier to use, since normalized data models complicate row-based sharding.</div><br/></div></div><div id="36779298" class="c"><input type="checkbox" id="c-36779298" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36778112">parent</a><span>|</span><a href="#36778239">prev</a><span>|</span><a href="#36778626">next</a><span>|</span><label class="collapse" for="c-36779298">[-]</label><label class="expand" for="c-36779298">[2 more]</label></div><br/><div class="children"><div class="content">Schemas are namespaces, a convenience feature, not a security feature.</div><br/><div id="36780070" class="c"><input type="checkbox" id="c-36780070" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#36778112">root</a><span>|</span><a href="#36779298">parent</a><span>|</span><a href="#36778626">next</a><span>|</span><label class="collapse" for="c-36780070">[-]</label><label class="expand" for="c-36780070">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly the reason I went for YugabyteDB tablespaces implementation on one of past projects. Dedicated database locked down to selected nodes for full isolation.</div><br/></div></div></div></div><div id="36778626" class="c"><input type="checkbox" id="c-36778626" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36778112">parent</a><span>|</span><a href="#36779298">prev</a><span>|</span><label class="collapse" for="c-36778626">[-]</label><label class="expand" for="c-36778626">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Schema objects can&#x27;t be manipulated as a batch,<p>I would make a partitioned table, and put each partition in its own schema.</div><br/></div></div></div></div></div></div></div></div></div></body></html>