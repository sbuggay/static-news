<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728291677326" as="style"/><link rel="stylesheet" href="styles.css?v=1728291677326"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://aarol.dev/posts/go-contentlength/">How do HTTP servers figure out Content-Length?</a> <span class="domain">(<a href="https://aarol.dev">aarol.dev</a>)</span></div><div class="subtext"><span>misonic</span> | <span>24 comments</span></div><br/><div><div id="41763387" class="c"><input type="checkbox" id="c-41763387" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#41763055">next</a><span>|</span><label class="collapse" for="c-41763387">[-]</label><label class="expand" for="c-41763387">[4 more]</label></div><br/><div class="children"><div class="content">I think the article should be called &quot;How do Go standard library HTTP servers figure out Content-Length?&quot;.<p>In most HTTP server implementations from other languages I&#x27;ve worked with I recall having to either:<p>- explicitly define the Content-Length up-front (clients then usually don&#x27;t like it if you send too little and servers don&#x27;t like it if you send too much)<p>- have a single &quot;write&quot; operation with an object where the Content-Length can be figured out quite easily<p>- turn on chunking myself and handle the chunk writing myself<p>I don&#x27;t recall having seen the kind of automatic chunking described in the article before (and I&#x27;m not too sure whether I&#x27;m a fan of it).</div><br/><div id="41763515" class="c"><input type="checkbox" id="c-41763515" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41763387">parent</a><span>|</span><a href="#41763874">next</a><span>|</span><label class="collapse" for="c-41763515">[-]</label><label class="expand" for="c-41763515">[2 more]</label></div><br/><div class="children"><div class="content">I believe the closest prior art would be PHP. It buffers a response by default until the buffer is full or `flush()` gets called, and will automatically set `Content-Encoding: chunked` if `Content-Length` wasn&#x27;t explicitly set. Any subsequent writes will be automatically chunked.<p>This approach makes sense from the API standpoint because the caller generally has no idea whether the chunked encoding is necessary, or even its very existence. Honestly that&#x27;s less confusing than what express.js does to the middleware function: `app.get(&quot;&#x2F;&quot;, (req, res) =&gt; { ... })` and `app.get(&quot;&#x2F;&quot;, (req, res, next) =&gt; { ... })` behave differently because it tries to infer the presence of `next` by probing `Function.prototype.length`.</div><br/><div id="41763769" class="c"><input type="checkbox" id="c-41763769" checked=""/><div class="controls bullet"><span class="by">nolok</span><span>|</span><a href="#41763387">root</a><span>|</span><a href="#41763515">parent</a><span>|</span><a href="#41763874">next</a><span>|</span><label class="collapse" for="c-41763769">[-]</label><label class="expand" for="c-41763769">[1 more]</label></div><br/><div class="children"><div class="content">Fun thing about that : core PHP used to and still is very very close to HTTP, to the point where I would say your average decent PHP programmer used to knows more about how HTTP work that your average other similar language where the web library abstract stuff. Eg a PHP dev knows a form has to be multipart&#x2F;form-data if you send files etc ...<p>But one of the if not THE major exception is this : buffering and flushing works automagically and a lot of PHP dev end up massively blindsinded by it at some point<p>PS: with the rise of modern PHP and it&#x27;s high quality object based framework, this become less and less true<p>PS2: I am not in ANY way saying anything good or bad or superior or inferior about any dev here, just a difference in approach</div><br/></div></div></div></div></div></div><div id="41763055" class="c"><input type="checkbox" id="c-41763055" checked=""/><div class="controls bullet"><span class="by">pkulak</span><span>|</span><a href="#41763387">prev</a><span>|</span><a href="#41763843">next</a><span>|</span><label class="collapse" for="c-41763055">[-]</label><label class="expand" for="c-41763055">[7 more]</label></div><br/><div class="children"><div class="content">And if you set your own content length header, most http servers will respect it and not chunk. That way, you can stream a 4-gig file that you know the size of per the metadata. This makes downloading nicer because browsers and such will then show a progress bar and time estimate.<p>However, you better be right! I just found a bug in some really old code that was gzipping every response when it was appropriate (ie, asked for, textual, etc). But it was ignoring the content-length header! So, if it was set manually, it would then be wrong after compression. That caused insidious bugs for years. The fix, obviously, was to just delete that manual header if the stream was going to be compressed.</div><br/><div id="41763347" class="c"><input type="checkbox" id="c-41763347" checked=""/><div class="controls bullet"><span class="by">bugtodiffer</span><span>|</span><a href="#41763055">parent</a><span>|</span><a href="#41763843">next</a><span>|</span><label class="collapse" for="c-41763347">[-]</label><label class="expand" for="c-41763347">[6 more]</label></div><br/><div class="children"><div class="content">Did you see if you could turn this into HTTP Request Smuggling? Or something else with security impact?<p>Sounds like a powerful bug you have, potentially.</div><br/><div id="41763408" class="c"><input type="checkbox" id="c-41763408" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#41763055">root</a><span>|</span><a href="#41763347">parent</a><span>|</span><a href="#41763843">next</a><span>|</span><label class="collapse" for="c-41763408">[-]</label><label class="expand" for="c-41763408">[5 more]</label></div><br/><div class="children"><div class="content">To me it sounds like the server handled the request just fine and reused the header (which was wrong.)
The client then had the problem of a wrong response.</div><br/><div id="41763457" class="c"><input type="checkbox" id="c-41763457" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#41763055">root</a><span>|</span><a href="#41763408">parent</a><span>|</span><a href="#41763843">next</a><span>|</span><label class="collapse" for="c-41763457">[-]</label><label class="expand" for="c-41763457">[4 more]</label></div><br/><div class="children"><div class="content">If you say to read 1000 bytes from memory and then pass a 900 bytes long array, that&#x27;s a security bug that can cause crash, corrupt data, and leaking stuff that shouldn&#x27;t have leaked.</div><br/><div id="41763664" class="c"><input type="checkbox" id="c-41763664" checked=""/><div class="controls bullet"><span class="by">michaelmior</span><span>|</span><a href="#41763055">root</a><span>|</span><a href="#41763457">parent</a><span>|</span><a href="#41763648">next</a><span>|</span><label class="collapse" for="c-41763664">[-]</label><label class="expand" for="c-41763664">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bug for sure, but I think whether it&#x27;s a security issue could depend on the language. If the callee is able to determine the length of the array, it can just return an error instead of a potential buffer overrun.</div><br/></div></div><div id="41763648" class="c"><input type="checkbox" id="c-41763648" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#41763055">root</a><span>|</span><a href="#41763457">parent</a><span>|</span><a href="#41763664">prev</a><span>|</span><a href="#41763843">next</a><span>|</span><label class="collapse" for="c-41763648">[-]</label><label class="expand" for="c-41763648">[2 more]</label></div><br/><div class="children"><div class="content">The size of the buffer and how many bytes are written have nothing intrinsically linked to what the header says. It&#x27;s a bug sure but does not mean there&#x27;s any security issue on the server.</div><br/><div id="41763853" class="c"><input type="checkbox" id="c-41763853" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#41763055">root</a><span>|</span><a href="#41763648">parent</a><span>|</span><a href="#41763843">next</a><span>|</span><label class="collapse" for="c-41763853">[-]</label><label class="expand" for="c-41763853">[1 more]</label></div><br/><div class="children"><div class="content">It will likely generate corrupt files on the client as well.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41763843" class="c"><input type="checkbox" id="c-41763843" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#41763055">prev</a><span>|</span><a href="#41763850">next</a><span>|</span><label class="collapse" for="c-41763843">[-]</label><label class="expand" for="c-41763843">[1 more]</label></div><br/><div class="children"><div class="content">Chunked progress is fun, not many know it supports more than just sending chunk size but can synchronously multiplex information!<p>e.g I drafted this a long time ago, because if you generate something live and send it in a streaming fashion, well you can&#x27;t have progress reporting since you don&#x27;t know the final size in bytes, even though server side you know how far you&#x27;re into generating.<p>This was used for multiple things like generating CSV exports from a bunch of RDBM records, or compressed tarballs from a set of files, or a bunch of other silly things like generating  sequences (Fibonacci, random integers, whatever...), that could take &quot;a while&quot; (as in, enough to be friendly and report progress).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;lloeki&#x2F;http-chunked-progress&#x2F;blob&#x2F;master&#x2F;draft-lnageleisen-http-chunked-progress-00">https:&#x2F;&#x2F;github.com&#x2F;lloeki&#x2F;http-chunked-progress&#x2F;blob&#x2F;master&#x2F;...</a></div><br/></div></div><div id="41763477" class="c"><input type="checkbox" id="c-41763477" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#41763850">prev</a><span>|</span><a href="#41763910">next</a><span>|</span><label class="collapse" for="c-41763477">[-]</label><label class="expand" for="c-41763477">[1 more]</label></div><br/><div class="children"><div class="content">Note that there can be trailer fields (the phrase &quot;trailing header&quot; is both an oxymoron and a good description of it): <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Headers&#x2F;Trailer" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Headers&#x2F;Tr...</a></div><br/></div></div><div id="41763910" class="c"><input type="checkbox" id="c-41763910" checked=""/><div class="controls bullet"><span class="by">pknerd</span><span>|</span><a href="#41763477">prev</a><span>|</span><a href="#41763498">next</a><span>|</span><label class="collapse" for="c-41763910">[-]</label><label class="expand" for="c-41763910">[3 more]</label></div><br/><div class="children"><div class="content">Why would someone implement the chunk logic when websockets are here? Am I missing something? What are the use cases?</div><br/><div id="41763995" class="c"><input type="checkbox" id="c-41763995" checked=""/><div class="controls bullet"><span class="by">rsynnott</span><span>|</span><a href="#41763910">parent</a><span>|</span><a href="#41763992">next</a><span>|</span><label class="collapse" for="c-41763995">[-]</label><label class="expand" for="c-41763995">[1 more]</label></div><br/><div class="children"><div class="content">HTTP&#x2F;1.1 came out in 1997. It’s extremely well supported. Websockets were only standardised in 2011, and still have proxy traversal issues.<p>You can absolutely assume that http 1.1 will work on basically anything; websockets are more finicky even now, and certainly were back in the day.</div><br/></div></div><div id="41763992" class="c"><input type="checkbox" id="c-41763992" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#41763910">parent</a><span>|</span><a href="#41763995">prev</a><span>|</span><a href="#41763498">next</a><span>|</span><label class="collapse" for="c-41763992">[-]</label><label class="expand" for="c-41763992">[1 more]</label></div><br/><div class="children"><div class="content">chunked-encoding is a method of encoding an HTTP response body. The semantics for HTTP responses still apply, caching, compression, etc.<p>Websockets are different protocol that is started up via HTTP.</div><br/></div></div></div></div><div id="41763498" class="c"><input type="checkbox" id="c-41763498" checked=""/><div class="controls bullet"><span class="by">_ache_</span><span>|</span><a href="#41763910">prev</a><span>|</span><label class="collapse" for="c-41763498">[-]</label><label class="expand" for="c-41763498">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Anyone who has implemented a simple HTTP server can tell you that it is a really simple protocol<p>It&#x27;s not. Like, hell no. That is so complex. Multiplexing, underlying TCP specifications, Server Push, Stream prioritization (vs priorization !), encryption (ALPN or NPN ?), extension like HSTS, CORS, WebDav or HLS, ...<p>It&#x27;s a great protocol, nowhere near simple.<p>&gt; Basically, it’s a text file that has some specific rules to make parsing it easier.<p>Nope, since HTTP&#x2F;2 that is just a textual representation, not the real &quot;on the wire&quot; protocol. HTTP&#x2F;2 is 10 now.</div><br/><div id="41763601" class="c"><input type="checkbox" id="c-41763601" checked=""/><div class="controls bullet"><span class="by">TickleSteve</span><span>|</span><a href="#41763498">parent</a><span>|</span><label class="collapse" for="c-41763601">[-]</label><label class="expand" for="c-41763601">[5 more]</label></div><br/><div class="children"><div class="content">He was referring to HTTP 1.0 &amp; 1.1</div><br/><div id="41763771" class="c"><input type="checkbox" id="c-41763771" checked=""/><div class="controls bullet"><span class="by">_ache_</span><span>|</span><a href="#41763498">root</a><span>|</span><a href="#41763601">parent</a><span>|</span><a href="#41763735">next</a><span>|</span><label class="collapse" for="c-41763771">[-]</label><label class="expand" for="c-41763771">[3 more]</label></div><br/><div class="children"><div class="content">Should have say that so (Nowhere does the article say ‘up to HTTP&#x2F;1.1’ even talking about HTTP&#x2F;2 and HTTP&#x2F;3).<p>HTTP&#x2F;1.0 is simple. HTTP&#x2F;1.1 is undoubtedly more complex but manageable.<p>The statement that HTTP is simple is just not true. Even if Go makes it look easy.</div><br/><div id="41763810" class="c"><input type="checkbox" id="c-41763810" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#41763498">root</a><span>|</span><a href="#41763771">parent</a><span>|</span><a href="#41763735">next</a><span>|</span><label class="collapse" for="c-41763810">[-]</label><label class="expand" for="c-41763810">[2 more]</label></div><br/><div class="children"><div class="content">Every example in the article explicitly states HTTP 1.1, only at the end does it have a remark about how HTTP 2 and 3 don&#x27;t have chunking as they have their own streaming mechanisms. The basic HTTP protocol <i>is</i> simple, but 2&#x2F;3 are no longer the basic HTTP protocols.</div><br/><div id="41763972" class="c"><input type="checkbox" id="c-41763972" checked=""/><div class="controls bullet"><span class="by">_ache_</span><span>|</span><a href="#41763498">root</a><span>|</span><a href="#41763810">parent</a><span>|</span><a href="#41763735">next</a><span>|</span><label class="collapse" for="c-41763972">[-]</label><label class="expand" for="c-41763972">[1 more]</label></div><br/><div class="children"><div class="content">My point is HTTP isn&#x27;t HTTP&#x2F;1.1. There is a lot under the wood, even with HTTP&#x2F;1.1. Actually, the fact that the whole article explains an implementation of an HTTP header is against the fact that it&#x27;s simple.<p>So when the article say &quot;All HTTP requests look something like this&quot;, that&#x27;s false, that is not a big deal but it spread that idea that HTTP is easy and it&#x27;s not.</div><br/></div></div></div></div></div></div><div id="41763735" class="c"><input type="checkbox" id="c-41763735" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41763498">root</a><span>|</span><a href="#41763601">parent</a><span>|</span><a href="#41763771">prev</a><span>|</span><label class="collapse" for="c-41763735">[-]</label><label class="expand" for="c-41763735">[1 more]</label></div><br/><div class="children"><div class="content">Which is reasonably simple that you can build a complete 1.0 server in C in an afternoon, and add some 1.1 stuff like keep-alives, content-length, etc. I did that for fun once, on github.com&#x2F;lionkor&#x2F;http</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>