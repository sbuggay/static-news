<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726045273281" as="style"/><link rel="stylesheet" href="styles.css?v=1726045273281"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wegmueller.it/blog/posts/2024-09-02-rust-on-illumos">Rust in illumos</a> <span class="domain">(<a href="https://wegmueller.it">wegmueller.it</a>)</span></div><div class="subtext"><span>vermaden</span> | <span>42 comments</span></div><br/><div><div id="41506984" class="c"><input type="checkbox" id="c-41506984" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41505938">next</a><span>|</span><label class="collapse" for="c-41506984">[-]</label><label class="expand" for="c-41506984">[14 more]</label></div><br/><div class="children"><div class="content">This article really comes at some of the crux of packaging pains for many languages. The &quot;distro ships the software&quot; idea is something so many modern language toolkits are pretty far away from (and, as someone constantly burned by Debian packaging choices, something I&#x27;m pretty happy with as well). But without a good answer, there&#x27;s going to be frustration.<p>When distros are charging themselves with things like security, shared libraries do become a bit load bearing. And for users, the idea that you update some lib once instead of &quot;number of software vendor&quot; times is tempting! But as a software developer, I really really enjoy how I can ship a thing with exactly a certain set of versions, so it&#x27;s almost an anti-feature to have a distro swap out functionality out from under me.<p>Of course there can be balances and degrees to this. But a part of me feels like the general trend of software packaging is leaning towards &quot;you bundle one thing at a time&quot;, away from &quot;you have a system running N things&quot;, and in that model I don&#x27;t know where distro packagers are (at least for server software).</div><br/><div id="41507528" class="c"><input type="checkbox" id="c-41507528" checked=""/><div class="controls bullet"><span class="by">Scramblejams</span><span>|</span><a href="#41506984">parent</a><span>|</span><a href="#41507107">next</a><span>|</span><label class="collapse" for="c-41507528">[-]</label><label class="expand" for="c-41507528">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I really really enjoy how I can ship a thing with exactly a certain set of versions<p>Just curious, how do you handle security monitoring and updates when doing this?<p>I&#x27;ve been exposed to two major approaches:<p>At $FAANG we&#x27;re on a treadmill where company CI force builds your stuff every time anything in your requirements.txt releases a new version (semver respected, at least) because in the absence of targeted CVE monitoring (which itself won&#x27;t cover you 100%), that&#x27;s the only practical way they see to keep up with security updates. If a dependency change breaks your project and you leave it broken for too long, peeps above you start getting autocut tickets. This leads to a lot of ongoing maintenance work for the life of the project because eventually you get forced into newer minor and eventually major versions whether you like it or not.<p>Outside of $FAANG I&#x27;ve gotten a whole lot of mileage building customer software on top of Debian- or Ubuntu-packaged dependencies. This allows me to rely on the distro for security updates without the churn, and I&#x27;m only forced to take newer dependencies when the distro version goes EOL. Obviously this constrains my library selection a lot, but if you can do it there&#x27;s very little maintenance work compared to the other approach.<p>I&#x27;d like to hear how others handle this because both approaches obviously have considerable downsides.</div><br/><div id="41508959" class="c"><input type="checkbox" id="c-41508959" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507528">parent</a><span>|</span><a href="#41507981">next</a><span>|</span><label class="collapse" for="c-41508959">[-]</label><label class="expand" for="c-41508959">[2 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget the third option: don&#x27;t. Updates are necessary when the customer asks for them. Most customers won&#x27;t, and if they do, they don&#x27;t know they need an update if you compile everything statically.<p>Personally, the update story is why I find developing on Windows much easier than developing on Linux. Instead of hundreds of small, independent packages, you can just target the _massive_ Windows API. You can take the &quot;living off the land&quot; approach on Linux too, but it&#x27;s harder, often relying on magical IOCTLs and magical file paths rather than library function calls.<p>Not that I think the Win32&#x2F;WinRT API is particularly well-designed, but at least the API is there, guaranteed to be available, and only breaks in extremely rare circumstances.</div><br/><div id="41509295" class="c"><input type="checkbox" id="c-41509295" checked=""/><div class="controls bullet"><span class="by">lars_francke</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41508959">parent</a><span>|</span><a href="#41507981">next</a><span>|</span><label class="collapse" for="c-41509295">[-]</label><label class="expand" for="c-41509295">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know where you reside and what kind of software you build.<p>With the European Cyber Resilience Act coming into full effect late 2027&#x2F;early 2028 (depends on when it&#x27;s finally signed) this will not always be an option anymore for a lot of people.<p>a) You&#x27;ll have to provide SBOMs so you can&#x27;t (legally) &quot;hide&quot; stuff in your binary<p>b) Security updates are mandatory for known exploitable vulnerabilities and other things, so you can&#x27;t wait until a customer asks.<p>This will take a few years before it bites (see GDPR) but the fines can be just as bad.</div><br/></div></div></div></div><div id="41507981" class="c"><input type="checkbox" id="c-41507981" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507528">parent</a><span>|</span><a href="#41508959">prev</a><span>|</span><a href="#41507751">next</a><span>|</span><label class="collapse" for="c-41507981">[-]</label><label class="expand" for="c-41507981">[1 more]</label></div><br/><div class="children"><div class="content">I strive for the latter approach as much as possible. I&#x27;m happy doing more work as a developer (like using a slightly older version of libraries or languages) to ensure that I build on a stable base that gets security updates without tons of major version api churn.</div><br/></div></div><div id="41507751" class="c"><input type="checkbox" id="c-41507751" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507528">parent</a><span>|</span><a href="#41507981">prev</a><span>|</span><a href="#41508257">next</a><span>|</span><label class="collapse" for="c-41507751">[-]</label><label class="expand" for="c-41507751">[1 more]</label></div><br/><div class="children"><div class="content">To be honest I&#x27;m fortunate enough to where maintenance work by sticking to &quot;the latest and greatest&quot; for application-level stuff is not hard. For system-level stuff in general it&#x27;s been about relying on Debian or Ubuntu stuff, but then application-level management for the top layer (&quot;the application&quot;, so to speak). I&#x27;ve only rarely been in situations where Debian packaging outright meant we couldn&#x27;t move forward on something (one funny and annoying one was gettext being too old, but gettext is so coupled with libc for some reason that we couldn&#x27;t just compile a fresh version...)<p>The joys of not having to deal wit the extremes of any problem...</div><br/></div></div><div id="41508257" class="c"><input type="checkbox" id="c-41508257" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507528">parent</a><span>|</span><a href="#41507751">prev</a><span>|</span><a href="#41507107">next</a><span>|</span><label class="collapse" for="c-41508257">[-]</label><label class="expand" for="c-41508257">[1 more]</label></div><br/><div class="children"><div class="content">Keeping up with the &#x27;treadmill&#x27; you described is perhaps the main job of a Linux distribution.  See, e.g. <a href="https:&#x2F;&#x2F;release.debian.org&#x2F;transitions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;release.debian.org&#x2F;transitions&#x2F;</a> for one example of how this can work practically.</div><br/></div></div></div></div><div id="41507107" class="c"><input type="checkbox" id="c-41507107" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#41506984">parent</a><span>|</span><a href="#41507528">prev</a><span>|</span><a href="#41505938">next</a><span>|</span><label class="collapse" for="c-41507107">[-]</label><label class="expand" for="c-41507107">[7 more]</label></div><br/><div class="children"><div class="content">I think it would be pretty natural for a distro to run it&#x27;s own crates.io&#x2F;PyPI&#x2F;NPM mirror to build packages against, and have a unified set of library versions for the entire OS that way. Maybe not even a server, maybe just a giant Git repo or whatever, filtered down to the set of packages they actually use. Have any of them tried this?</div><br/><div id="41507803" class="c"><input type="checkbox" id="c-41507803" checked=""/><div class="controls bullet"><span class="by">thristian</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507107">parent</a><span>|</span><a href="#41508282">next</a><span>|</span><label class="collapse" for="c-41507803">[-]</label><label class="expand" for="c-41507803">[3 more]</label></div><br/><div class="children"><div class="content">Debian <i>effectively</i> does this. It doesn&#x27;t actually implement the crates.io API, but when building a Rust package they tell cargo &quot;look in this directory for dependencies, don&#x27;t talk to the network&quot;.<p>As I understand it, the process goes something like this:<p>- Debian wants to package a Rust tool<p>- They examine the tool&#x27;s Cargo.toml file to determine its immediate dependencies<p>- Those Rust dependencies are converted into Debian package names<p>- Generate a Debian package definition that lists those dependencies under &quot;Build-Depends&quot;<p>- When building the Debian package in an isolated environment, Build-Depends packages are installed, providing things like `rustc` and `cargo` as well as putting the dependencies&#x27; source into the &quot;local dependencies&quot; directory<p>- Cargo runs, configured to only look in the &quot;local dependencies&quot; directory for dependencies<p>- the resulting binary is scooped up and packaged</div><br/><div id="41508577" class="c"><input type="checkbox" id="c-41508577" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507803">parent</a><span>|</span><a href="#41508760">next</a><span>|</span><label class="collapse" for="c-41508577">[-]</label><label class="expand" for="c-41508577">[1 more]</label></div><br/><div class="children"><div class="content">Is there some documentation on how to do this yourself? It sounds very useful for building software meant to be binary distributed.</div><br/></div></div><div id="41508760" class="c"><input type="checkbox" id="c-41508760" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507803">parent</a><span>|</span><a href="#41508577">prev</a><span>|</span><a href="#41508282">next</a><span>|</span><label class="collapse" for="c-41508760">[-]</label><label class="expand" for="c-41508760">[1 more]</label></div><br/><div class="children"><div class="content">Is this documented anywhere?</div><br/></div></div></div></div><div id="41508282" class="c"><input type="checkbox" id="c-41508282" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507107">parent</a><span>|</span><a href="#41507803">prev</a><span>|</span><a href="#41507179">next</a><span>|</span><label class="collapse" for="c-41508282">[-]</label><label class="expand" for="c-41508282">[1 more]</label></div><br/><div class="children"><div class="content">Haskell has Stackage[1] which maintains globally consistent sets of Haskell packages that build together. It’s of course a huge pain to maintain, probably exponentially harder wrt &lt;size of package registry&gt; &#x2F; &lt;size of Hackage&gt;. Also highly depends on whether the language and ecosystem helps and encourages library authors to maintain compatibility; I don’t think Rust does.<p>[1] <a href="https:&#x2F;&#x2F;www.stackage.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.stackage.org&#x2F;</a></div><br/></div></div><div id="41507179" class="c"><input type="checkbox" id="c-41507179" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507107">parent</a><span>|</span><a href="#41508282">prev</a><span>|</span><a href="#41507754">next</a><span>|</span><label class="collapse" for="c-41507179">[-]</label><label class="expand" for="c-41507179">[1 more]</label></div><br/><div class="children"><div class="content">I’m not aware of any that have; this would require them to become experts in running parallel infra, in many languages and with varied setups, and would mean that they’re not longer self-contained. That feels antithetical to their goals to me at least.</div><br/></div></div><div id="41507754" class="c"><input type="checkbox" id="c-41507754" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41506984">root</a><span>|</span><a href="#41507107">parent</a><span>|</span><a href="#41507179">prev</a><span>|</span><a href="#41505938">next</a><span>|</span><label class="collapse" for="c-41507754">[-]</label><label class="expand" for="c-41507754">[1 more]</label></div><br/><div class="children"><div class="content">I mean Ubuntu has a bunch of python libs. The problem is that you need to make a universe of mutually compatible libs, so if _any_ of the libs have old-ish dependencies, that holds back so much.<p>I think what happens in practice is package maintainers do the work to get things up to date, and so only include a subset.</div><br/></div></div></div></div></div></div><div id="41505938" class="c"><input type="checkbox" id="c-41505938" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41506984">prev</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41505938">[-]</label><label class="expand" for="c-41505938">[11 more]</label></div><br/><div class="children"><div class="content">&gt; The development model of illumos is different from Linux and thus there are no Rust drivers in upstream illumos yet. But that is to be expected for new things. In our model, we take the time to mature new tech in a fork, and for rust, the Oxide fork has taken that role. In there, we have several drivers for the Oxide Networking stack that are in rust. Based on that some experience could be gained.<p>Soft forks are also good, but doesn&#x27;t illumos have a stable driver ABI, such that you could just make your drivers completely independently? I thought that was how it had ex. Nvidia drivers ( <a href="https:&#x2F;&#x2F;docs.openindiana.org&#x2F;dev&#x2F;graphics-stack&#x2F;#nvidia" rel="nofollow">https:&#x2F;&#x2F;docs.openindiana.org&#x2F;dev&#x2F;graphics-stack&#x2F;#nvidia</a> )</div><br/><div id="41508275" class="c"><input type="checkbox" id="c-41508275" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41505938">parent</a><span>|</span><a href="#41506299">next</a><span>|</span><label class="collapse" for="c-41508275">[-]</label><label class="expand" for="c-41508275">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if Illumos follows the Sun model of &quot;interface contracts&quot;, which allows for downstreams to get timely notice of upcoming backwards-incompatible changes to unstable interfaces.  Of course, Illumos can choose to make some intra-kernel interfaces stable.</div><br/><div id="41508840" class="c"><input type="checkbox" id="c-41508840" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41508275">parent</a><span>|</span><a href="#41506299">next</a><span>|</span><label class="collapse" for="c-41508840">[-]</label><label class="expand" for="c-41508840">[1 more]</label></div><br/><div class="children"><div class="content">The answer is definitely not &quot;no&quot;, but as far as I&#x27;m aware we haven&#x27;t found any particular cases where that level of formalism and that specific style of arrangement would help.<p>In an open source world where multiple shipping operating systems are based on (different snapshots of) the same core code and interfaces, it seems much more valuable to try and push straight to Committed interfaces (public, stable, documented) where we can.<p>There are plenty of cases where people use Uncommitted interfaces today in things that they layer on top in appliances and so on, but mostly it&#x27;s expected that those people are paying attention to what&#x27;s being worked on and integrated.    When folks pull new changes from illumos-gate into their release engineering branches or soft forks, they&#x27;re generally doing that explicitly and testing that things still work for them.<p>Also, unlike the distributions (who ship artefacts to users) it doesn&#x27;t really make much sense for us to version illumos itself.  This makes it a bit harder to reason about when it would be acceptable to renege on an interface contract, etc.  In general we try to move things to Committed over time, and then generally try very hard never to break or remove those things after that point.</div><br/></div></div></div></div><div id="41506299" class="c"><input type="checkbox" id="c-41506299" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41505938">parent</a><span>|</span><a href="#41508275">prev</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41506299">[-]</label><label class="expand" for="c-41506299">[8 more]</label></div><br/><div class="children"><div class="content">Even if there is a stable ABI driver to the point where upstream is oblivious of any Rust stuff going on inside drivers, that doesn&#x27;t solve the problem of fragmentation amongst forks (assuming upstreaming to Illumos is a goal).</div><br/><div id="41506892" class="c"><input type="checkbox" id="c-41506892" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41506299">parent</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41506892">[-]</label><label class="expand" for="c-41506892">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m part of the illumos core team and I&#x27;m quite keen to use Rust in the base of illumos, FWIW.  There several contexts in which we could make good use of it, and the primary challenges in most cases is either one of release engineering or the resultant binary sizes.  I&#x27;m confident we&#x27;ll be able to work them out, it&#x27;ll just take more exploration and effort!<p>The rough areas where I think things would be useful, and probably also roughly the order in which I would seek to do them:<p>* Rust in the tools we use to build the software.  We have a fair amount of Perl and Python and shell script that goes into doing things like making sure the build products are correctly formed, preparing things for packaging, diffing the binary artefacts from two different builds, etc.  It would be pretty easy to use regular Cargo-driven Rust development for these tools, to the extent that they don&#x27;t represent shipped artefacts.<p>* Rust to make C-compatible shared libraries.  We ship a lot of libraries in the base system, and I could totally see redoing some of the parts that are harder to get right (e.g., things that poke at cryptographic keys, or do a lot of string parsing, or complex maths!) in Rust.  I suspect we would _not_ want to use Cargo for these bits, and probably try to minimise the dependencies and keep tight control on the size of the output binaries etc.<p>* Rust to make kernel modules.  Kernel modules are pretty similar to C shared libraries, in that we expect them to have few dependencies and probably not be built through Cargo using crates.io and so on.<p>* Rust to make executable programs like daemons and command-line commands.  I think here the temptation to use more dependencies will increase, and so this will be the hardest thing to figure out.<p>The other thing beyond those challenges is that we want the build to work completely offline, _and_ we don&#x27;t want to needlessly unpack and &quot;vendor&quot; (to use the vernacular) a lot of external files.  So we&#x27;d probably be looking at using some of the facilities Cargo is growing to use an offline local clone of parts of a repository, and some way to reliably populate that while not inhibiting the ease of development, etc.<p>Nothing insurmountable, just a lot of effort, like most things that are worth doing!</div><br/><div id="41507123" class="c"><input type="checkbox" id="c-41507123" checked=""/><div class="controls bullet"><span class="by">marvin-hansen</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41506892">parent</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41507123">[-]</label><label class="expand" for="c-41507123">[6 more]</label></div><br/><div class="children"><div class="content">Have you explored building with Bazel? What you describe as a problem is roughly what Bazel solves: Polyglot complex builds from fully vendored deps.<p>Just pointing this out because I had a fair share of issues with Cargo and ultimately moved to Bazel and a bit later to BuildBuddy as CI. Since then my builds are reliable, run a lot faster and even stuff like cross compilation in a cluster works flawlessly.<p>Obviously there is some complexity implied when moving to Bazel, but the bigger question is whether the  capabilities of your current build solution keep up with the complexity of your requirements?</div><br/><div id="41507412" class="c"><input type="checkbox" id="c-41507412" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41507123">parent</a><span>|</span><a href="#41507143">next</a><span>|</span><label class="collapse" for="c-41507412">[-]</label><label class="expand" for="c-41507412">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not hugely excited about Bazel, or really any of the more complex build tools made either directly for, or in the image of, the large corporate monorepo tooling.<p>Right now we have decades of accumulated make stuff, with some orchestrating shell.  It&#x27;s good in parts, and not in others.  What I would ideally like is some bespoke software that produces a big Ninja file to build literally everything.  A colleague at Oxide spent at least a few hours poking at a generator that might eventually suit us, and while it&#x27;s not anywhere near finished I thought it was a promising beginning I&#x27;d like us to pursue eventually!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;oxidecomputer&#x2F;eos">https:&#x2F;&#x2F;github.com&#x2F;oxidecomputer&#x2F;eos</a></div><br/></div></div><div id="41507143" class="c"><input type="checkbox" id="c-41507143" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41507123">parent</a><span>|</span><a href="#41507412">prev</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41507143">[-]</label><label class="expand" for="c-41507143">[4 more]</label></div><br/><div class="children"><div class="content">(Not Josh, not involved with illumos, do work at Oxide)<p>For at least one project at Oxide we use buck2, which is conceptually in a similar place. I’d like to use it more but am still too new to wield it effectively. In general I would love to see more “here’s how to move to buck&#x2F;bazel when you outgrow cargo) content.</div><br/><div id="41507209" class="c"><input type="checkbox" id="c-41507209" checked=""/><div class="controls bullet"><span class="by">marvin-hansen</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41507143">parent</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41507209">[-]</label><label class="expand" for="c-41507209">[3 more]</label></div><br/><div class="children"><div class="content">Here you go!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;examples&#x2F;tree&#x2F;main&#x2F;rust-examples">https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;examples&#x2F;tree&#x2F;main&#x2F;rust-exampl...</a><p>I wrote all of those examples and contributed them back to Bazel because I&#x27;ve been there...<p>Personally, I prefer the Bazel ecosystem by a wide margin over buck2. By technology alone, buck2 is better, but as my requirements were growing, I needed a lot more mature rule sets such as rules OCI to build and publish container images without Docker and buck2 simply doesn&#x27;t have the ecosystem available to support complex builds beyond a certain level. It may get there one day.</div><br/><div id="41507247" class="c"><input type="checkbox" id="c-41507247" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41507209">parent</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41507247">[-]</label><label class="expand" for="c-41507247">[2 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>I fully agree with the ecosystem comments; I’m just a Buck fan because it’s in Rust and I like the “no built in rules” concept, but it’s true that it’s much younger and seemingly less widely used. Regardless I should spend some time with Bazel.</div><br/><div id="41508687" class="c"><input type="checkbox" id="c-41508687" checked=""/><div class="controls bullet"><span class="by">marvin-hansen</span><span>|</span><a href="#41505938">root</a><span>|</span><a href="#41507247">parent</a><span>|</span><a href="#41507428">next</a><span>|</span><label class="collapse" for="c-41508687">[-]</label><label class="expand" for="c-41508687">[1 more]</label></div><br/><div class="children"><div class="content">Here is another thing worth sharing. Database integration tests on Bazel used to be difficult. Ultimately I&#x27;ve found an elegant solution:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;diesel-rs&#x2F;diesel&#x2F;blob&#x2F;master&#x2F;examples&#x2F;postgres&#x2F;custom_arrays&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;diesel-rs&#x2F;diesel&#x2F;blob&#x2F;master&#x2F;examples&#x2F;pos...</a><p>The parallel testing with dangling transactions isn&#x27;t Diesel or Postgres specific. You can do the same with pure SQL and any relational DB that supports transactions.<p>For CI, BuildBuddy can spin up Docker in a remote execution host, then you write a custom util that tests if the DB container is already running and if not starts one, out that in a test and then let Bazel execute all integration tests in parallel. For some weird reasons, all tests have to be in one file per insolated remote execution host, so I created one per table.<p>Incremental builds that compile, tests, build and publish images usually complete in about one minute. That&#x27;s thanks to the 80 Core BuildBuddy cluster with remote cache.<p>GitHub took about an hour back in April when the repo was half in size.<p>There is real gain in terms of developer velocity.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41507428" class="c"><input type="checkbox" id="c-41507428" checked=""/><div class="controls bullet"><span class="by">turtle_heck</span><span>|</span><a href="#41505938">prev</a><span>|</span><a href="#41508564">next</a><span>|</span><label class="collapse" for="c-41507428">[-]</label><label class="expand" for="c-41507428">[1 more]</label></div><br/><div class="children"><div class="content">&gt; for one would love to have people help me with the new Installer[0] and with the package Forge[1]<p>Those repos really need some basic high-level information about what they are and how they work, the Forge doesn&#x27;t even have a README.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Toasterson&#x2F;illumos-installer">https:&#x2F;&#x2F;github.com&#x2F;Toasterson&#x2F;illumos-installer</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;toasterson&#x2F;forge">https:&#x2F;&#x2F;github.com&#x2F;toasterson&#x2F;forge</a></div><br/></div></div><div id="41508564" class="c"><input type="checkbox" id="c-41508564" checked=""/><div class="controls bullet"><span class="by">fake-name</span><span>|</span><a href="#41507428">prev</a><span>|</span><a href="#41507982">next</a><span>|</span><label class="collapse" for="c-41508564">[-]</label><label class="expand" for="c-41508564">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  The Debian approach of putting everything into one system and only having one version of each dependency is not feasible for a huge international community of people that develop together but never meet.<p>I find this to be overbroad and incorrect in the larger case.<p>I want one version that has been reasonably tested for everything <i>but</i> the parts I&#x27;m developing or working with. Having just one version for everyone generally means it&#x27;s probably going to work, and maybe even has been tested.<p>For my own stuff, I am happy to manage the dependencies myself, but moving away from the debian approach harms the <i>system</i> in general.</div><br/></div></div><div id="41506543" class="c"><input type="checkbox" id="c-41506543" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#41507982">prev</a><span>|</span><label class="collapse" for="c-41506543">[-]</label><label class="expand" for="c-41506543">[13 more]</label></div><br/><div class="children"><div class="content">&gt; The development model of illumos is different from Linux and thus there are no Rust drivers in upstream illumos yet. But that is to be expected for new things. In our model, we take the time to mature new tech in a fork, and for rust, the Oxide fork has taken that role.<p>This is silly. Virtually all illumos development is done by Oxide. There is no other upstream to speak of.<p>As far as I am concerned, illumos <i>is</i> Oxide.<p>Also, it&#x27;s <i>illumos</i>, in lower case.</div><br/><div id="41507158" class="c"><input type="checkbox" id="c-41507158" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41506543">parent</a><span>|</span><a href="#41507149">next</a><span>|</span><label class="collapse" for="c-41507158">[-]</label><label class="expand" for="c-41507158">[1 more]</label></div><br/><div class="children"><div class="content">Telling someone they don’t exist is a bold move.<p>Our (Oxide’s) distro isn’t even listed on the main page for illumos.<p>Also the author is using the lower case i as far as I can see?</div><br/></div></div><div id="41507149" class="c"><input type="checkbox" id="c-41507149" checked=""/><div class="controls bullet"><span class="by">dvtkrlbs</span><span>|</span><a href="#41506543">parent</a><span>|</span><a href="#41507158">prev</a><span>|</span><a href="#41507189">next</a><span>|</span><label class="collapse" for="c-41507149">[-]</label><label class="expand" for="c-41507149">[5 more]</label></div><br/><div class="children"><div class="content">Illumos is not Oxide. Oxide is just using a in house distribution of illumos for their needs. Illumos created is created 14 years ago by Solaris developers to swap the closed source bits by open source implementations.</div><br/><div id="41507161" class="c"><input type="checkbox" id="c-41507161" checked=""/><div class="controls bullet"><span class="by">dvtkrlbs</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507149">parent</a><span>|</span><a href="#41507189">next</a><span>|</span><label class="collapse" for="c-41507161">[-]</label><label class="expand" for="c-41507161">[4 more]</label></div><br/><div class="children"><div class="content">Looking at the last commits it does not seems like majority upstream development is not done by Oxide (I did not look at it extensively)</div><br/><div id="41507206" class="c"><input type="checkbox" id="c-41507206" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507161">parent</a><span>|</span><a href="#41507189">next</a><span>|</span><label class="collapse" for="c-41507206">[-]</label><label class="expand" for="c-41507206">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    user@machine:~&#x2F;illumos-gate$ git log --since 2023-09-10 | grep ^Author | awk -F @ &#x27;{print $2}&#x27; | sed &#x27;s&#x2F;&gt;$&#x2F;&#x2F;&#x27; | sort | uniq -c | sort -n | tail
         11 mnx.io
         16 grumpf.hope-2000.org
         18 gmail.com
         21 oxide.computer
         29 hamachi.org
         36 richlowe.net
         37 racktopsystems.com
         71 fiddaman.net
         91 fingolfin.org
        125 me.com
</code></pre>
I&#x27;m not going to post names because that feels a touch icky, but a little bit of cross-comparison suggests that one of those domains should be combined with oxide (read: I search for names and they work there) in a way that does probably make Oxide more than 50% of commits in the last year. Though even if that&#x27;s true it doesn&#x27;t make them the only player or anything.</div><br/><div id="41508106" class="c"><input type="checkbox" id="c-41508106" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507206">parent</a><span>|</span><a href="#41507189">next</a><span>|</span><label class="collapse" for="c-41508106">[-]</label><label class="expand" for="c-41508106">[2 more]</label></div><br/><div class="children"><div class="content">Considering that Oxide&#x27;s CTO is a longtime prominent Solaris guy, it&#x27;s not shocking. I wouldn&#x27;t surprised if that&#x27;s the whole reason they use ilumos.</div><br/><div id="41508845" class="c"><input type="checkbox" id="c-41508845" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41508106">parent</a><span>|</span><a href="#41507189">next</a><span>|</span><label class="collapse" for="c-41508845">[-]</label><label class="expand" for="c-41508845">[1 more]</label></div><br/><div class="children"><div class="content">You can read a bit about our decision making process on the host OS and hypervisor in Oxide RFD 26: <a href="https:&#x2F;&#x2F;rfd.shared.oxide.computer&#x2F;rfd&#x2F;0026" rel="nofollow">https:&#x2F;&#x2F;rfd.shared.oxide.computer&#x2F;rfd&#x2F;0026</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41507189" class="c"><input type="checkbox" id="c-41507189" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41506543">parent</a><span>|</span><a href="#41507149">prev</a><span>|</span><label class="collapse" for="c-41507189">[-]</label><label class="expand" for="c-41507189">[6 more]</label></div><br/><div class="children"><div class="content">Okay, but that&#x27;s just... not true. Joyent is still around, OmniOS is doing their thing. Oxide is a major player, but they&#x27;re not the only player.</div><br/><div id="41507380" class="c"><input type="checkbox" id="c-41507380" checked=""/><div class="controls bullet"><span class="by">turtle_heck</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507189">parent</a><span>|</span><a href="#41507388">next</a><span>|</span><label class="collapse" for="c-41507380">[-]</label><label class="expand" for="c-41507380">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  Joyent is still around<p>They are but they&#x27;re no longer contributing to illumos...</div><br/><div id="41507395" class="c"><input type="checkbox" id="c-41507395" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507380">parent</a><span>|</span><a href="#41507388">next</a><span>|</span><label class="collapse" for="c-41507395">[-]</label><label class="expand" for="c-41507395">[3 more]</label></div><br/><div class="children"><div class="content">The remainder of the staff working on SmartOS, and the remaining IP like trademarks, and customers and so on, were all bought from Samsung by MNX so they could take it over.  They&#x27;re doing a great job over there with it, and unlike Samsung they actually want it!</div><br/><div id="41507648" class="c"><input type="checkbox" id="c-41507648" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507395">parent</a><span>|</span><a href="#41507388">next</a><span>|</span><label class="collapse" for="c-41507648">[-]</label><label class="expand" for="c-41507648">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  and unlike Samsung<p>So what did Samsung do with Joyent? Just a failed acquisition or were there plans?</div><br/><div id="41509098" class="c"><input type="checkbox" id="c-41509098" checked=""/><div class="controls bullet"><span class="by">panick21_</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507648">parent</a><span>|</span><a href="#41507388">next</a><span>|</span><label class="collapse" for="c-41509098">[-]</label><label class="expand" for="c-41509098">[1 more]</label></div><br/><div class="children"><div class="content">From what I learned from Podcasts, they did a massive build-out of datacenters with Joyant technology for internal use as Samsung. But I don&#x27;t know if that continued. Love to hear from Bryan more on that.</div><br/></div></div></div></div></div></div></div></div><div id="41507388" class="c"><input type="checkbox" id="c-41507388" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#41506543">root</a><span>|</span><a href="#41507189">parent</a><span>|</span><a href="#41507380">prev</a><span>|</span><label class="collapse" for="c-41507388">[-]</label><label class="expand" for="c-41507388">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Joyent is still around<p>Just in name. It&#x27;s mostly Samsung infrastructure.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>