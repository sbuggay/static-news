<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724230876544" as="style"/><link rel="stylesheet" href="styles.css?v=1724230876544"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.thatgeoguy.ca/blog/2023/01/04/reflections-on-transducers/">Reflecting on transducers in Scheme (2023)</a>Â <span class="domain">(<a href="https://www.thatgeoguy.ca">www.thatgeoguy.ca</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>35 comments</span></div><br/><div><div id="41304642" class="c"><input type="checkbox" id="c-41304642" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41304074">next</a><span>|</span><label class="collapse" for="c-41304642">[-]</label><label class="expand" for="c-41304642">[4 more]</label></div><br/><div class="children"><div class="content">I wrote the transducers srfi.<p>I don&#x27;t really mind schemes monomorphic nature and chose to adhere to it and leave a generic transduce form for whenever there is a good way to implement it in a portable way. There is really nothing stopping anyone from extending SRFI-171 with a generic transduce form (and some more transducers that I left out because didn&#x27;t really think it through). Such a project has my blessing and I would be happy to mark the SRFI as superseded.<p>A vector-reduce form would be trivial but icky, and I chose not to do it to not have to have the continuation safety discussion. I have an idea to make thread and continuation safe transducers with immutable and visible state, but the first PoC was pretty slow. (I am going to say it... I miss c++ move semantics. Ouch)<p>Anyway, if I read things correctly the complaint that srfi-171 has delete dupes and delete neighbor dupes forgets that transducers are not always used to or from a data structure. They are oblivious to context. That is why both are necessary.<p>The SRFI document was written for someone who already knows what a transducer is, and specifies an API that implementers are to follow. I did not intend for it to be user documentation. User documentation is severely lacking. I was hoping for it to make it into r7rs-large (hubris. I know) and then I would make some kind of push to document it better. As it is now I have very little computer time.<p>Regarding why transducers are faster I am still pretty certain it has to do with mutation and boxing. Looking at the assembly generated by srfi-171 in chez I don&#x27;t really see that much aggressive inlining - and I don&#x27;t think chez would fare much worse with srfi-158.  Generators and accumulators use set! everywhere, meaning chez (and guile) doesn&#x27;t really try to keep the values unboxed or typed. That incurs quite a slowdown. It does use more state though.<p>Sorry about the messy response. Typing this while walking home.<p>In short: his library looks fine. Use it. From what I can see the only differences are ordering of clauses to make the transduce form generic and naming conventions. His library shadows a bunch of bindings in a non-compatible way. The transduce form is still not generic but moves the list-, vector-, generator- part of transduce into a &quot;folder&quot;. Which is fine. But a generic dispatch would be nicer.<p>Ask me anything I guess.</div><br/><div id="41305154" class="c"><input type="checkbox" id="c-41305154" checked=""/><div class="controls bullet"><span class="by">ThatGeoGuy</span><span>|</span><a href="#41304642">parent</a><span>|</span><a href="#41304074">next</a><span>|</span><label class="collapse" for="c-41305154">[-]</label><label class="expand" for="c-41305154">[3 more]</label></div><br/><div class="children"><div class="content">Author of the post here, hi! Funny to see this resurface again, I have made a number of changes to the transducers library since this blog post (see: <a href="https:&#x2F;&#x2F;wiki.call-cc.org&#x2F;eggref&#x2F;5&#x2F;transducers" rel="nofollow">https:&#x2F;&#x2F;wiki.call-cc.org&#x2F;eggref&#x2F;5&#x2F;transducers</a>).<p><i>A vector-reduce form would be trivial but icky, and I chose not to do it to not have to have the continuation safety discussion.</i><p>I am not sure what &quot;continuation safety&quot; refers to in this context but I wanted a library that would give me a good out-of-the-box experience and have support for commonly used Scheme types. I have not yet added any folders&#x2F;collectors&#x2F;transducers specific to some types (like anything related to streams or SRFI-69), but I think a broad swath of types and patterns are currently covered.<p>I think in particular my griped regarding vectors were that collectors such as `collect-vector`, `collect-u8vector`, etc. were not implemented. There is a chance to break out of these collectors using continuations but that&#x27;s not really a good argument to not have them (I hope this is not what you&#x27;re referring to!).<p><i>Anyway, if I read things correctly the complaint that srfi-171 has delete dupes and delete neighbor dupes forgets that transducers are not always used to or from a data structure. They are oblivious to context. That is why both are necessary.</i><p>I think this is exactly my argument: they are oblivious to context and actually do the wrong thing by default. I&#x27;ve seen this happen in Rust with users preferring `dedup` or `dedup_by` (from the Itertools crate) rather than just constructing a HashSet or BTreeSet. It almost always is used as a shortcut to save on a data structure, and time and again I&#x27;ve seen it break workflows because it requires that the chain of items is first sorted.<p>I think this is is particularly damning for a library that means to be general purpose. If users want to implement this themselves and maintain it within their own code-bases, they&#x27;re certainly welcome to; however, I don&#x27;t personally think making this kind of deduping &quot;easy&quot; helps folks in the general sense. You&#x27;d be better off collecting into a set or bag of some kind, and then transducing a second time.<p><i>From what I can see the only differences are ordering of clauses to make the transduce form generic and naming conventions. His library shadows a bunch of bindings in a non-compatible way. The transduce form is still not generic but moves the list-, vector-, generator- part of transduce into a &quot;folder&quot;. Which is fine. But a generic dispatch would be nicer.</i><p>Shadowing bindings in a &quot;non-compatible&quot; way can be bad, but it also helps to make programs more clean. If you&#x27;re using transducers across your codebase, you almost certainly aren&#x27;t also using e.g. SRFI-1&#x27;s filter.<p>As for generic dispatch: I agree wholeheartedly. I wish we had something like Clojure protocols that didn&#x27;t suck. I&#x27;ve looked into ways to (ab)use variant records for this sort of thing, but you run into an open&#x2F;closed problem on extending the API. This is really something that needs to be solved at the language level and something like COOPS &#x2F; GOOPS incurs a degree of both conceptual and actual performance overhead that makes them somewhat unsatisfying :(<p>And also: thank you for SRFI-171. I disagree with some of the design decisions but had it not been written I probably wouldn&#x27;t have even considered transducers as something worth having.</div><br/><div id="41307604" class="c"><input type="checkbox" id="c-41307604" checked=""/><div class="controls bullet"><span class="by">woolion</span><span>|</span><a href="#41304642">root</a><span>|</span><a href="#41305154">parent</a><span>|</span><a href="#41307867">next</a><span>|</span><label class="collapse" for="c-41307604">[-]</label><label class="expand" for="c-41307604">[1 more]</label></div><br/><div class="children"><div class="content">Small unrelated bug report: in your &quot;Book review: Bernoulli&#x27;s Fallacy&quot; article, there is a link to: <a href="https:&#x2F;&#x2F;www.thatgeoguy.ca&#x2F;blog&#x2F;%7B%7B%20site.baseurl%20%7D%7D&#x2F;2021&#x2F;03&#x2F;07&#x2F;review-the-little-typer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.thatgeoguy.ca&#x2F;blog&#x2F;%7B%7B%20site.baseurl%20%7D%7...</a><p>I don&#x27;t have much time to read through all this now but I&#x27;ll check later, looks like great write-ups!</div><br/></div></div><div id="41307867" class="c"><input type="checkbox" id="c-41307867" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41304642">root</a><span>|</span><a href="#41305154">parent</a><span>|</span><a href="#41307604">prev</a><span>|</span><a href="#41304074">next</a><span>|</span><label class="collapse" for="c-41307867">[-]</label><label class="expand" for="c-41307867">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It almost always is used as a shortcut to save on a data structure, and time and again I&#x27;ve seen it break workflows because it requires that the chain of items is first sorted.<p>I am not sure I understand. I almost never use transducers to create data structures. I use them as a way to create general processing steps. The standard example is how they are used in clojure&#x27;s channels. In such a context you need both dedup and dedup-neighbors.<p>To be frank, I don&#x27;t really care much for the *-transduce functions. I think a general purpose looping facility is a better choice almost always. For those things I use <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~bjoli&#x2F;goof-loop" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~bjoli&#x2F;goof-loop</a> which is always going to be faster than transducers unless you have very very smart compiler (or perhaps a tracing JIT).<p>I think that transducers should be integrated into the standard library to make sense so that you can for example pass them to a port constructor.<p>Anyway, your library looks much more complete, and pretty similar to the SRFI. The differences are mostly cosmetic.</div><br/></div></div></div></div></div></div><div id="41304074" class="c"><input type="checkbox" id="c-41304074" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41304642">prev</a><span>|</span><a href="#41304171">next</a><span>|</span><label class="collapse" for="c-41304074">[-]</label><label class="expand" for="c-41304074">[14 more]</label></div><br/><div class="children"><div class="content">Fun article.  I&#x27;m somewhat still in the camp of loving Common Lisp&#x27;s LOOP over many of the newer tools that are for looping over things.  Articles like this do a good job of shining light on a lot of the concerns.<p>Quick nit&#x2F;question.  For the fold method, I don&#x27;t think I&#x27;ve seen it called sentinel value.  Usually it is seed or initial?<p>Now, my main question.  Transducer?  I&#x27;m curious on the etymology of that word.  By itself, I don&#x27;t think I could ever guess what it was referencing. :(</div><br/><div id="41304097" class="c"><input type="checkbox" id="c-41304097" checked=""/><div class="controls bullet"><span class="by">zappacino</span><span>|</span><a href="#41304074">parent</a><span>|</span><a href="#41307193">next</a><span>|</span><label class="collapse" for="c-41304097">[-]</label><label class="expand" for="c-41304097">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK, the term was popularized by Rich Hickey in Clojure&#x27;s implementation [1]. His talk introducing the concept goes into the etymology specifically. If I remember correctly it&#x27;s something like &quot;to carry across.&quot;<p>[1] <a href="https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;transducers" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;transducers</a></div><br/></div></div><div id="41307193" class="c"><input type="checkbox" id="c-41307193" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41304074">parent</a><span>|</span><a href="#41304097">prev</a><span>|</span><a href="#41305228">next</a><span>|</span><label class="collapse" for="c-41307193">[-]</label><label class="expand" for="c-41307193">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen the use of the word transducer first in SERIES, a Common Lisp library for iteration by Richard C. Waters.<p>for example: <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node352.html#SECTION003423000000000000000" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node352.html#...</a></div><br/></div></div><div id="41305228" class="c"><input type="checkbox" id="c-41305228" checked=""/><div class="controls bullet"><span class="by">ThatGeoGuy</span><span>|</span><a href="#41304074">parent</a><span>|</span><a href="#41307193">prev</a><span>|</span><a href="#41304114">next</a><span>|</span><label class="collapse" for="c-41305228">[-]</label><label class="expand" for="c-41305228">[1 more]</label></div><br/><div class="children"><div class="content"><i>Quick nit&#x2F;question. For the fold method, I don&#x27;t think I&#x27;ve seen it called sentinel value. Usually it is seed or initial?</i><p>I think in Scheme it is common to call it knil, mirroring how lists use nil as the &quot;sentinel&quot; value which marks the end of a proper list. I opted to name it sentinel in that article (and in the docs) for two reasons:<p>1. Sentinel values are a common topic in many languages <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sentinel_value" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sentinel_value</a><p>2. Transducers necessarily abstract across a lot more than loops &#x2F; lists. Lisps do a lot of really cool (and optimized) stuff with lists alone and Scheme is no different in this regard. However, because of how Scheme primarily exports list operations in (scheme base) is really easy to run into a situation where lists are used in an ad-hoc way where another data structure is more appropriate. This includes vectors, sets, mappings, hashmaps, etc. Transducers-the-library is meant to be general across operations that work on all of these types, so I chose language that intentionally departs from thinking in a list-focused way.<p><i>Now, my main question. Transducer? I&#x27;m curious on the etymology of that word. By itself, I don&#x27;t think I could ever guess what it was referencing. :(</i><p>This is from Rich Hickey&#x27;s presentation: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6mTbuzafcII" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6mTbuzafcII</a><p>It&#x27;s not a reducer, because they serve as higher-order functions that operate on reducers. Instead, the values they accept are transient through the function(s), so they transduce. You should watch the video, I think Rich explains the origins of his language very well.</div><br/></div></div><div id="41304114" class="c"><input type="checkbox" id="c-41304114" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41304074">parent</a><span>|</span><a href="#41305228">prev</a><span>|</span><a href="#41304144">next</a><span>|</span><label class="collapse" for="c-41304114">[-]</label><label class="expand" for="c-41304114">[5 more]</label></div><br/><div class="children"><div class="content">Transducers are not loops. You can create transducers and pass them as arguments to functions, that in their turn can prepend or append then.<p>They are composable algorithmic transformations.</div><br/><div id="41305910" class="c"><input type="checkbox" id="c-41305910" checked=""/><div class="controls bullet"><span class="by">RhysU</span><span>|</span><a href="#41304074">root</a><span>|</span><a href="#41304114">parent</a><span>|</span><a href="#41304431">next</a><span>|</span><label class="collapse" for="c-41305910">[-]</label><label class="expand" for="c-41305910">[2 more]</label></div><br/><div class="children"><div class="content">&gt; composable algorithmic transformations<p>This phrasing always feels pointlessly fancy. I may be understeeped in the right lore.<p>What is a non-composable, non-algorithmic transformation? A composable, non-algorithmic transformation? A non-composable, algorithmic transformation?<p>Maybe there&#x27;s some constraint on the domain vs the range buried in &quot;transformation&quot;?</div><br/><div id="41308252" class="c"><input type="checkbox" id="c-41308252" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41304074">root</a><span>|</span><a href="#41305910">parent</a><span>|</span><a href="#41304431">next</a><span>|</span><label class="collapse" for="c-41308252">[-]</label><label class="expand" for="c-41308252">[1 more]</label></div><br/><div class="children"><div class="content">There are lots of examples of non-composable transformations. Two functions are not necessarily composable. Call&#x2F;cc does not compose with the current continuation, whereas delimited continuations do.<p>Algorithmic transformations are algorithmic. The result is well-defined.<p>It is a succinct way of saying that a transducer is a well-defined (in terms of input and output) transformation that can be combined with other transducers.<p>I didn&#x27;t make up the lingo.</div><br/></div></div></div></div><div id="41304431" class="c"><input type="checkbox" id="c-41304431" checked=""/><div class="controls bullet"><span class="by">drcode</span><span>|</span><a href="#41304074">root</a><span>|</span><a href="#41304114">parent</a><span>|</span><a href="#41305910">prev</a><span>|</span><a href="#41304144">next</a><span>|</span><label class="collapse" for="c-41304431">[-]</label><label class="expand" for="c-41304431">[2 more]</label></div><br/><div class="children"><div class="content">composable algorithmic transformation in the streets<p>but mostly an alternative to LOOP in the sheets</div><br/><div id="41304675" class="c"><input type="checkbox" id="c-41304675" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41304074">root</a><span>|</span><a href="#41304431">parent</a><span>|</span><a href="#41304144">next</a><span>|</span><label class="collapse" for="c-41304675">[-]</label><label class="expand" for="c-41304675">[1 more]</label></div><br/><div class="children"><div class="content">Sure. But in that case it is somewhere between map(car)-and-friends and LOOP.<p>Which is a situation where they add very little. Being able to use them as an intermediate step wherever data flows is probably the only place I use them myself. In channels, in file-readers etc. in places where you really need speed you should of course reach for whatever loop construct you prefer.</div><br/></div></div></div></div></div></div><div id="41304144" class="c"><input type="checkbox" id="c-41304144" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#41304074">parent</a><span>|</span><a href="#41304114">prev</a><span>|</span><a href="#41305052">next</a><span>|</span><label class="collapse" for="c-41304144">[-]</label><label class="expand" for="c-41304144">[1 more]</label></div><br/><div class="children"><div class="content">You are correct with your question, SRFI 1[0] describes the knil argument as the &quot;seed&quot; or fold state (the latter for a recursive implementation). A sentinel value usually refers to a final value.<p>Regarding the etymology: transform + reduce = transduce<p>[0] <a href="https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-1&#x2F;srfi-1.html#fold" rel="nofollow">https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-1&#x2F;srfi-1.html#fold</a></div><br/></div></div><div id="41305052" class="c"><input type="checkbox" id="c-41305052" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#41304074">parent</a><span>|</span><a href="#41304144">prev</a><span>|</span><a href="#41305146">next</a><span>|</span><label class="collapse" for="c-41305052">[-]</label><label class="expand" for="c-41305052">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t be alone in thinking that LOOP usage produces nearly unreadable code. It&#x27;s extremely difficult to figure out what the intended behavior is if you don&#x27;t have decades of reading them under your belt.</div><br/><div id="41305123" class="c"><input type="checkbox" id="c-41305123" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41304074">root</a><span>|</span><a href="#41305052">parent</a><span>|</span><a href="#41305146">next</a><span>|</span><label class="collapse" for="c-41305123">[-]</label><label class="expand" for="c-41305123">[2 more]</label></div><br/><div class="children"><div class="content">Meh.  It is like any other construct in this regard.  If you let it get complicated, it can be complicated.  Most of the time, you should be able to keep it short.<p>Pointedly, though, it was hilarious to me how much Java began to look like typical LOOP constructs with Collectors.</div><br/><div id="41307759" class="c"><input type="checkbox" id="c-41307759" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#41304074">root</a><span>|</span><a href="#41305123">parent</a><span>|</span><a href="#41305146">next</a><span>|</span><label class="collapse" for="c-41307759">[-]</label><label class="expand" for="c-41307759">[1 more]</label></div><br/><div class="children"><div class="content">Why not make multiple forms, then? The readability would certainly be increased if the writer were able to move beyond &quot;loop&quot;.<p>This smells more like for-loop insecurity than anything.</div><br/></div></div></div></div></div></div><div id="41305146" class="c"><input type="checkbox" id="c-41305146" checked=""/><div class="controls bullet"><span class="by">0x3444ac53</span><span>|</span><a href="#41304074">parent</a><span>|</span><a href="#41305052">prev</a><span>|</span><a href="#41304171">next</a><span>|</span><label class="collapse" for="c-41305146">[-]</label><label class="expand" for="c-41305146">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a fan of the 
```
(let [ loop (fn [...] 
```</div><br/></div></div></div></div><div id="41304171" class="c"><input type="checkbox" id="c-41304171" checked=""/><div class="controls bullet"><span class="by">jiehong</span><span>|</span><a href="#41304074">prev</a><span>|</span><a href="#41305010">next</a><span>|</span><label class="collapse" for="c-41304171">[-]</label><label class="expand" for="c-41304171">[6 more]</label></div><br/><div class="children"><div class="content">Nice to see Scheme being active. It is really used much in companies?<p>While the author speaks about Rust iterators at first, Transducers seem better in the end.<p>In Java 23, the introduction of gatherers seems to be an attempt at having a more open set of functions of a stream, which transducers donât suffer from.<p>Rust Iterators seems to also have this limited sed of actions available (but some crate like tap seem to allow to .pipe() a function).</div><br/><div id="41304476" class="c"><input type="checkbox" id="c-41304476" checked=""/><div class="controls bullet"><span class="by">veqq</span><span>|</span><a href="#41304171">parent</a><span>|</span><a href="#41308156">next</a><span>|</span><label class="collapse" for="c-41304476">[-]</label><label class="expand" for="c-41304476">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It is really used much in companies?<p>Cisco seems to use Chez for something mysterious, a video game company scripted in Scheme, stopped and restarted again. I know a guy who does option trading in Racket, I have some large valuation models in Racket (most of the system is in and Common Lisp). I know a few guys who do vague data analysis and scripting in scheme (especially Guile or Gerbil for some reason) where their clients only care about the result. <a href="https:&#x2F;&#x2F;www.itasoftware.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.itasoftware.com&#x2F;</a> is in scheme. There are some dead webshops(?) like <a href="https:&#x2F;&#x2F;www.greghendershott.com&#x2F;2018&#x2F;05&#x2F;extramaze-llc-using-racket-postgresql-aws-but-no-ads-or-js.html" rel="nofollow">https:&#x2F;&#x2F;www.greghendershott.com&#x2F;2018&#x2F;05&#x2F;extramaze-llc-using-...</a> or <a href="https:&#x2F;&#x2F;defn.io&#x2F;2019&#x2F;08&#x2F;20&#x2F;racket-ecommerce&#x2F;" rel="nofollow">https:&#x2F;&#x2F;defn.io&#x2F;2019&#x2F;08&#x2F;20&#x2F;racket-ecommerce&#x2F;</a><p>That&#x27;s about it.</div><br/><div id="41304562" class="c"><input type="checkbox" id="c-41304562" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41304171">root</a><span>|</span><a href="#41304476">parent</a><span>|</span><a href="#41308156">next</a><span>|</span><label class="collapse" for="c-41304562">[-]</label><label class="expand" for="c-41304562">[3 more]</label></div><br/><div class="children"><div class="content">ITA used Common Lisp. The game company you mentioned is probably Naughty Dog who created &quot;Game Oriented Assembly Language&quot; for their games. GOAL was created in Common Lisp but was Scheme-like. They switched away after being acquired by Sony and needing to fit in better, they brought it back later on though.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Game_Oriented_Assembly_Lisp" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Game_Oriented_Assembly_Lisp</a></div><br/><div id="41304654" class="c"><input type="checkbox" id="c-41304654" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41304171">root</a><span>|</span><a href="#41304562">parent</a><span>|</span><a href="#41308156">next</a><span>|</span><label class="collapse" for="c-41304654">[-]</label><label class="expand" for="c-41304654">[2 more]</label></div><br/><div class="children"><div class="content">Never try to fit in after being acquired. Be what they acquired.</div><br/><div id="41306984" class="c"><input type="checkbox" id="c-41306984" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41304171">root</a><span>|</span><a href="#41304654">parent</a><span>|</span><a href="#41308156">next</a><span>|</span><label class="collapse" for="c-41306984">[-]</label><label class="expand" for="c-41306984">[1 more]</label></div><br/><div class="children"><div class="content">Sony had a policy: games are implemented in C++, no ifs, ands, or buts. Once you&#x27;re acquired, you play by the parent&#x27;s rules.<p>That said, they did sneak Scheme (specifically, Racket) in the back door, by making their C++ engine data-driven and using Racket programs to generate and munge the data consumed by the engine.</div><br/></div></div></div></div></div></div></div></div><div id="41308156" class="c"><input type="checkbox" id="c-41308156" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41304171">parent</a><span>|</span><a href="#41304476">prev</a><span>|</span><a href="#41305010">next</a><span>|</span><label class="collapse" for="c-41308156">[-]</label><label class="expand" for="c-41308156">[1 more]</label></div><br/><div class="children"><div class="content">SISCOG in Lisbon used to be a big Common Lisp shop in the early 2000&#x27;s, not sure how much of it they still use 20 years later.</div><br/></div></div></div></div><div id="41305010" class="c"><input type="checkbox" id="c-41305010" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41304171">prev</a><span>|</span><a href="#41306034">next</a><span>|</span><label class="collapse" for="c-41305010">[-]</label><label class="expand" for="c-41305010">[1 more]</label></div><br/><div class="children"><div class="content">Unified iterators help a lot with improving code quality. Most of the time when consuming sequences, I couldn&#x27;t care less what kind of collection I&#x27;m dealing with.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;codr7&#x2F;sharpl#iterators">https:&#x2F;&#x2F;github.com&#x2F;codr7&#x2F;sharpl#iterators</a></div><br/></div></div><div id="41306034" class="c"><input type="checkbox" id="c-41306034" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#41305010">prev</a><span>|</span><a href="#41303912">next</a><span>|</span><label class="collapse" for="c-41306034">[-]</label><label class="expand" for="c-41306034">[4 more]</label></div><br/><div class="children"><div class="content">My big takeaway is that Google has a Common Lisp Style Guide. Makes you wonder what they use Common Lisp for.</div><br/><div id="41306988" class="c"><input type="checkbox" id="c-41306988" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41306034">parent</a><span>|</span><a href="#41306997">prev</a><span>|</span><a href="#41303912">next</a><span>|</span><label class="collapse" for="c-41306988">[-]</label><label class="expand" for="c-41306988">[1 more]</label></div><br/><div class="children"><div class="content">They acquired ITA Software in like 2012. ITA&#x27;s QPX search engine is largely written in Common Lisp. Unlike Sony, q.v. in another comment thread, Google decided not to mess too much with a good thing and let them keep their Lisp codebase without following bitwize&#x27;s corollary to Greenspun&#x27;s Tenth Rule (every sufficiently complicated Common Lisp or Scheme program will eventually be rewritten in C++, Java, or Python).</div><br/></div></div></div></div><div id="41303912" class="c"><input type="checkbox" id="c-41303912" checked=""/><div class="controls bullet"><span class="by">tonyg</span><span>|</span><a href="#41306034">prev</a><span>|</span><a href="#41303564">next</a><span>|</span><label class="collapse" for="c-41303912">[-]</label><label class="expand" for="c-41303912">[4 more]</label></div><br/><div class="children"><div class="content">I wonder if the author considered SRFI-42 at all? It looks, at a glance, similar.</div><br/><div id="41304090" class="c"><input type="checkbox" id="c-41304090" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41303912">parent</a><span>|</span><a href="#41303564">next</a><span>|</span><label class="collapse" for="c-41304090">[-]</label><label class="expand" for="c-41304090">[3 more]</label></div><br/><div class="children"><div class="content">They are not similar at all, except that they might overlap. Transducers are functions that perform one-way transformations of data. Srfi-42 is couple of loop macros.<p>I wrote both srfi-171 (mentioned in the post) and this looping macro <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~bjoli&#x2F;goof-loop" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~bjoli&#x2F;goof-loop</a> which is probably the most powerful one scheme (at least that generates fast code) has to offer until someone reimpmements Olin&#x27;s loops.</div><br/><div id="41304912" class="c"><input type="checkbox" id="c-41304912" checked=""/><div class="controls bullet"><span class="by">tonyg</span><span>|</span><a href="#41303912">root</a><span>|</span><a href="#41304090">parent</a><span>|</span><a href="#41303564">next</a><span>|</span><label class="collapse" for="c-41304912">[-]</label><label class="expand" for="c-41304912">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They are not similar at all, except that they might overlap.<p>(Well, which is it?)<p>Perhaps I was misled by the intro to the article, that wished for something like Rust&#x27;s iterators: generic data-source-neutral map&#x2F;filter&#x2F;zip&#x2F;etc utilities, static dispatch, extensible. Srfi-42, Racket&#x27;s for&#x2F;* system, and your goof-loop all seem to fit the bill. Obviously the article ended up at a dynamically dispatched system, like -171, but to start with it didn&#x27;t seem like it had to have headed in that direction.<p>&gt; Srfi-42 is couple of loop macros.<p>This is decidedly ungenerous, especially given its historical relationship to Barzilay&#x27;s work and descendants.</div><br/><div id="41308136" class="c"><input type="checkbox" id="c-41308136" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#41303912">root</a><span>|</span><a href="#41304912">parent</a><span>|</span><a href="#41303564">next</a><span>|</span><label class="collapse" for="c-41308136">[-]</label><label class="expand" for="c-41308136">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (Well, which is it?)<p>The more I have though about these things, the less I see them as something similar. They overlap because they are sold as an alternative to map, filter etc. I think that is a pretty non-exciting use case that is better served by proper looping facilities.<p>What is interesting about transducers is that they can be the basis for a generic protocol for transformations. You can make a transducer and use it on a list, pass it to a port constructor to have it preprocess everything read from the port, pass it to an asynchronous channel, make it into a generator.<p>That is something not served by looping macros.<p>&gt; This is decidedly ungenerous<p>I did not mean to disparage srfi-42. It _is_ a couple of looping macros (that set the bar for descendants), which I mean is what sets it apart from the exciting use cases of transducers. I think a language should have both.<p>Racket took srfi-42 and showed that it doesn&#x27;t have to use mutation. The reference implementation of SRFI-42 uses set! quite a lot which tanks performance in many schemes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>