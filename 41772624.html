<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728378068696" as="style"/><link rel="stylesheet" href="styles.css?v=1728378068696"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/">An illustrated proof of the CAP theorem (2018)</a> <span class="domain">(<a href="https://mwhittaker.github.io">mwhittaker.github.io</a>)</span></div><div class="subtext"><span>tripdout</span> | <span>55 comments</span></div><br/><div><div id="41773455" class="c"><input type="checkbox" id="c-41773455" checked=""/><div class="controls bullet"><span class="by">refibrillator</span><span>|</span><a href="#41774709">next</a><span>|</span><label class="collapse" for="c-41773455">[-]</label><label class="expand" for="c-41773455">[8 more]</label></div><br/><div class="children"><div class="content">CAP theorem is great, though it does omit latency. Which leads you to the logical extension, PACELC [1]:<p>If there is a network Partition you must choose Availability or Consistency, Else the tradeoff is Latency vs Consistency.<p>This offers practical intuition for certain design choices.<p>For example Google Spanner [2] is a distributed DB that offers globally consistent reads&#x2F;writes, but to achieve high performance (low latency) nodes must synchronize with multiple extremely accurate reference clocks (GPS &amp; atomic) and follow a complex two phase commit protocol that ensures transactional linearizability using lower bounds and uncertainty of timestamps.<p>As another example, your multicore CPU leverages a cache coherency protocol that faces remarkably similar tradeoffs. Perhaps others have made this connection before…it does feel like some sort of universal law of physics.<p>[1] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;PACELC_theorem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;PACELC_theorem</a><p>[2] <a href="https:&#x2F;&#x2F;static.googleusercontent.com&#x2F;media&#x2F;research.google.com&#x2F;en&#x2F;&#x2F;archive&#x2F;spanner-osdi2012.pdf" rel="nofollow">https:&#x2F;&#x2F;static.googleusercontent.com&#x2F;media&#x2F;research.google.c...</a></div><br/><div id="41774145" class="c"><input type="checkbox" id="c-41774145" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#41773455">parent</a><span>|</span><a href="#41773774">next</a><span>|</span><label class="collapse" for="c-41774145">[-]</label><label class="expand" for="c-41774145">[2 more]</label></div><br/><div class="children"><div class="content">Is a Partition meaningfully distinguishable from especially high Latency?</div><br/></div></div><div id="41773774" class="c"><input type="checkbox" id="c-41773774" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41773455">parent</a><span>|</span><a href="#41774145">prev</a><span>|</span><a href="#41774709">next</a><span>|</span><label class="collapse" for="c-41773774">[-]</label><label class="expand" for="c-41773774">[5 more]</label></div><br/><div class="children"><div class="content">CAP doesn&#x27;t omit latency. Availability essentially is latency.<p>PACELC only says that even during normal operation you still need to make tradeoff between availability and latency whereas CAP only deals with a tradeoff during a partition event.</div><br/><div id="41773804" class="c"><input type="checkbox" id="c-41773804" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41773455">root</a><span>|</span><a href="#41773774">parent</a><span>|</span><a href="#41774709">next</a><span>|</span><label class="collapse" for="c-41773804">[-]</label><label class="expand" for="c-41773804">[4 more]</label></div><br/><div class="children"><div class="content">Availability&#x27;s definition:<p>&gt; every request received by a non-failing node in the system must result in a response<p>I don&#x27;t believe that encodes latency<p>Instead, here&#x27;s consistency:<p>&gt; any read operation that begins after a write operation completes must return that value, or the result of a later write operation<p>&quot;after a write operation completes&quot; feels like where latency kicks in? Because within that space you can play around with completing a write operation to get what you want.</div><br/><div id="41773867" class="c"><input type="checkbox" id="c-41773867" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41773455">root</a><span>|</span><a href="#41773804">parent</a><span>|</span><a href="#41774709">next</a><span>|</span><label class="collapse" for="c-41773867">[-]</label><label class="expand" for="c-41773867">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s impossible to distinguish between high latency and unavailability. You can model unavailability as infinite latency.<p>In a real system you can wait for a partition event to resolve itself before replying which preserves consistency at the cost of latency (availability).</div><br/><div id="41773907" class="c"><input type="checkbox" id="c-41773907" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41773455">root</a><span>|</span><a href="#41773867">parent</a><span>|</span><a href="#41774709">next</a><span>|</span><label class="collapse" for="c-41773907">[-]</label><label class="expand" for="c-41773907">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In a real system you can wait for a partition event to resolve itself before replying which preserves consistency at the cost of latency (availability).<p>This is true, but PACELC states that even if there is no partition you still have a consistency vs latency tradeoff (because the processes that guarantee consistency eat up latency in form of network roundtrips)</div><br/><div id="41773928" class="c"><input type="checkbox" id="c-41773928" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41773455">root</a><span>|</span><a href="#41773907">parent</a><span>|</span><a href="#41774709">next</a><span>|</span><label class="collapse" for="c-41773928">[-]</label><label class="expand" for="c-41773928">[1 more]</label></div><br/><div class="children"><div class="content">100%, I don&#x27;t think what we&#x27;re saying conflicts. There is _always_ a tradeoff between consistency and availability whether you&#x27;re thinking of PAC or PACELC. PACELC just makes it explicit that this tradeoff exists whether you&#x27;re partitioned or not.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41774709" class="c"><input type="checkbox" id="c-41774709" checked=""/><div class="controls bullet"><span class="by">puzzledobserver</span><span>|</span><a href="#41773455">prev</a><span>|</span><a href="#41773973">next</a><span>|</span><label class="collapse" for="c-41774709">[-]</label><label class="expand" for="c-41774709">[1 more]</label></div><br/><div class="children"><div class="content">One thing that I&#x27;ve always wondered about: Is the CAP theorem really making a non-trivial claim?<p>If a distributed system is consistent and available, it must return the last written value, and successfully do this all the time. How can it do this if the system is partitioned, and the node receiving the last write was unable to propagate this to other nodes?<p>The proof described in this website appears to confirm this. Am I missing something?</div><br/></div></div><div id="41773973" class="c"><input type="checkbox" id="c-41773973" checked=""/><div class="controls bullet"><span class="by">stevebmark</span><span>|</span><a href="#41774709">prev</a><span>|</span><a href="#41773673">next</a><span>|</span><label class="collapse" for="c-41773973">[-]</label><label class="expand" for="c-41773973">[2 more]</label></div><br/><div class="children"><div class="content">I prefer the walkthrough of the CAP theorem in “Designing Data Intensive Applications,” which says that the CAP “theorem” is an undefined and generally unhelpful concept in distributed systems. “Available” has no formal definition.<p>And it’s confusing that it’s three letters, because it’s not “choose two”. It’s not that a system is “partition tolerant,” it’s if there’s a network partition, you choose availability or consistency. And obviously you choose availability for the distributed systems you most commonly encounter.</div><br/><div id="41774967" class="c"><input type="checkbox" id="c-41774967" checked=""/><div class="controls bullet"><span class="by">yas_hmaheshwari</span><span>|</span><a href="#41773973">parent</a><span>|</span><a href="#41773673">next</a><span>|</span><label class="collapse" for="c-41774967">[-]</label><label class="expand" for="c-41774967">[1 more]</label></div><br/><div class="children"><div class="content">I also like the fact that how he says that that theorem was a good theorem for the time but is now not that relevant<p>Maybe PACELC is better theorem, maybe not - but I guess three letter acronyms would always rule better than a six letter one</div><br/></div></div></div></div><div id="41773673" class="c"><input type="checkbox" id="c-41773673" checked=""/><div class="controls bullet"><span class="by">vzaliva</span><span>|</span><a href="#41773973">prev</a><span>|</span><a href="#41773548">next</a><span>|</span><label class="collapse" for="c-41773673">[-]</label><label class="expand" for="c-41773673">[2 more]</label></div><br/><div class="children"><div class="content">The text left me wanting a more formal treatment of the theorem. I went ahead and found a paper which does just that:<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;564585.564601" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;564585.564601</a>
PDF: <a href="https:&#x2F;&#x2F;users.ece.cmu.edu&#x2F;~adrian&#x2F;731-sp04&#x2F;readings&#x2F;GL-cap.pdf" rel="nofollow">https:&#x2F;&#x2F;users.ece.cmu.edu&#x2F;~adrian&#x2F;731-sp04&#x2F;readings&#x2F;GL-cap.p...</a></div><br/><div id="41774481" class="c"><input type="checkbox" id="c-41774481" checked=""/><div class="controls bullet"><span class="by">fithisux</span><span>|</span><a href="#41773673">parent</a><span>|</span><a href="#41773548">next</a><span>|</span><label class="collapse" for="c-41774481">[-]</label><label class="expand" for="c-41774481">[1 more]</label></div><br/><div class="children"><div class="content">I was always wondering the same. Thank you for the references. Above I asked for a mechanized proof.</div><br/></div></div></div></div><div id="41773548" class="c"><input type="checkbox" id="c-41773548" checked=""/><div class="controls bullet"><span class="by">magnio</span><span>|</span><a href="#41773673">prev</a><span>|</span><a href="#41773412">next</a><span>|</span><label class="collapse" for="c-41773548">[-]</label><label class="expand" for="c-41773548">[5 more]</label></div><br/><div class="children"><div class="content">The &quot;proof&quot; is kind of weird. We assume there exists a system that has all three of CAP, but how can we assume that system has the layout in the post with two servers and one client?</div><br/><div id="41773941" class="c"><input type="checkbox" id="c-41773941" checked=""/><div class="controls bullet"><span class="by">sushibowl</span><span>|</span><a href="#41773548">parent</a><span>|</span><a href="#41773412">next</a><span>|</span><label class="collapse" for="c-41773941">[-]</label><label class="expand" for="c-41773941">[4 more]</label></div><br/><div class="children"><div class="content">The proof is not really formal, but you could view the shown system as a minimal subset of an arbitrarily shaped large system.<p>For the system to be distributed it must have at least two nodes, and to be available all nodes must respond to requests. So however the rest of the system is shaped, the proof still holds.</div><br/><div id="41774825" class="c"><input type="checkbox" id="c-41774825" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#41773548">root</a><span>|</span><a href="#41773941">parent</a><span>|</span><a href="#41774602">next</a><span>|</span><label class="collapse" for="c-41774825">[-]</label><label class="expand" for="c-41774825">[1 more]</label></div><br/><div class="children"><div class="content">The minimal subset is too small. It should have a second client, to avoid solutions like &quot;the client stores a copy of all the messages it sent, so it can detect the stale value&quot;.</div><br/></div></div><div id="41774602" class="c"><input type="checkbox" id="c-41774602" checked=""/><div class="controls bullet"><span class="by">evertedsphere</span><span>|</span><a href="#41773548">root</a><span>|</span><a href="#41773941">parent</a><span>|</span><a href="#41774825">prev</a><span>|</span><a href="#41773412">next</a><span>|</span><label class="collapse" for="c-41774602">[-]</label><label class="expand" for="c-41774602">[2 more]</label></div><br/><div class="children"><div class="content">what if the graph remains connected when you remove that link, so the two nodes can communicate <i>through</i> other nodes?</div><br/><div id="41774651" class="c"><input type="checkbox" id="c-41774651" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#41773548">root</a><span>|</span><a href="#41774602">parent</a><span>|</span><a href="#41773412">next</a><span>|</span><label class="collapse" for="c-41774651">[-]</label><label class="expand" for="c-41774651">[1 more]</label></div><br/><div class="children"><div class="content">Partitioning is defined so that all, or at least arbitrarily many, of the communication links may be down.<p>In practice you&#x27;re absolutely right and one approach to distributed systems is to make partition tolerance less important by having lots of redundant links instead.</div><br/></div></div></div></div></div></div></div></div><div id="41773412" class="c"><input type="checkbox" id="c-41773412" checked=""/><div class="controls bullet"><span class="by">jascha_eng</span><span>|</span><a href="#41773548">prev</a><span>|</span><a href="#41772952">next</a><span>|</span><label class="collapse" for="c-41773412">[-]</label><label class="expand" for="c-41773412">[3 more]</label></div><br/><div class="children"><div class="content">This is trivial but the problem is that especially consistency is not a binary choice. Heck even non distributed systems can give you varying consistency guarantees it&#x27;s the whole point of isolation levels of most RDBMS.<p>It&#x27;s good to visualize that there is a trade off to be made. However that trade off does not have to be binary. You can get a bit more consistency for a little less partition tolerance or availability. All of Designing data intensive applications is about those trade offs.</div><br/><div id="41774006" class="c"><input type="checkbox" id="c-41774006" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#41773412">parent</a><span>|</span><a href="#41772952">next</a><span>|</span><label class="collapse" for="c-41774006">[-]</label><label class="expand" for="c-41774006">[2 more]</label></div><br/><div class="children"><div class="content">Consistency in CAP and Consistency in ACID have entirely separate meanings.</div><br/><div id="41775017" class="c"><input type="checkbox" id="c-41775017" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41773412">root</a><span>|</span><a href="#41774006">parent</a><span>|</span><a href="#41772952">next</a><span>|</span><label class="collapse" for="c-41775017">[-]</label><label class="expand" for="c-41775017">[1 more]</label></div><br/><div class="children"><div class="content">The C in ACID has a different definition of Consistency, yet the combination of guarantees given by ACID should also imply Consistency in the distributed system sense, right? I.e. a distributed database that claims to be ACID cannot sacrifice consistency [edit: at least for some isolation levels].</div><br/></div></div></div></div></div></div><div id="41772952" class="c"><input type="checkbox" id="c-41772952" checked=""/><div class="controls bullet"><span class="by">whatshisface</span><span>|</span><a href="#41773412">prev</a><span>|</span><a href="#41773199">next</a><span>|</span><label class="collapse" for="c-41772952">[-]</label><label class="expand" for="c-41772952">[11 more]</label></div><br/><div class="children"><div class="content">How about this:<p>1. A read is returned with a map of the network the replying node has become consistent with.<p>2. A client that is not satisfied with the map can read again from the other partition.<p>These two steps get around the proof by changing one of its assumptions (that the operation to read a value can only involve a request to one node).</div><br/><div id="41773143" class="c"><input type="checkbox" id="c-41773143" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#41772952">parent</a><span>|</span><a href="#41773659">next</a><span>|</span><label class="collapse" for="c-41773143">[-]</label><label class="expand" for="c-41773143">[1 more]</label></div><br/><div class="children"><div class="content">You’re certainly allowed to make the client a more active participant in your consensus protocol, but then it needs to play by the same rules if you want the system to have guarantees. For example, you need to handle network partitions between clients and some servers, and you need to be able to reconcile multiple reads from servers that might have seen different sets of writes. The CAP theorem still applies to the system as a whole.</div><br/></div></div><div id="41773659" class="c"><input type="checkbox" id="c-41773659" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41772952">parent</a><span>|</span><a href="#41773143">prev</a><span>|</span><a href="#41773117">next</a><span>|</span><label class="collapse" for="c-41773659">[-]</label><label class="expand" for="c-41773659">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a plan for doing writes in that scenario?  It&#x27;s not proper availability without writes.<p>If the partitions are configured for consistency, and they can&#x27;t hear from each other, then at most one will accept writes.  If the client relays metadata between the partitions to make the write happen in both, then you don&#x27;t actually have a partition anymore.<p>Also in practical terms, the nodes almost always have better contact with each other than the client has to the nodes.  The situation where the client can connect to both sides of a partition is unlikely enough that if you add code for it you&#x27;re probably getting negative value.  It wastes time and can add scary bugs.</div><br/></div></div><div id="41773117" class="c"><input type="checkbox" id="c-41773117" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#41772952">parent</a><span>|</span><a href="#41773659">prev</a><span>|</span><a href="#41773333">next</a><span>|</span><label class="collapse" for="c-41773117">[-]</label><label class="expand" for="c-41773117">[6 more]</label></div><br/><div class="children"><div class="content">Consider the following sequence* of events:<p>1. client A reads from partition X<p>2. client A is unsatisfied with the network map, and requests another read from partition Y<p>3. (meanwhile) client B writes a value to partition X<p>4. client A reads from partition Y, sees the value is the same as partition X&#x27;s (stale) value, and accepts the value as consistent<p>This is the same kind of behavior you might get if your servers used e.g. a buggy version of Raft or something. You can&#x27;t get around the proof by just relabeling some of your server nodes as client nodes.<p>* In the spirit of distributed systems, I use this term loosely :)</div><br/><div id="41773175" class="c"><input type="checkbox" id="c-41773175" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41772952">root</a><span>|</span><a href="#41773117">parent</a><span>|</span><a href="#41773333">next</a><span>|</span><label class="collapse" for="c-41773175">[-]</label><label class="expand" for="c-41773175">[5 more]</label></div><br/><div class="children"><div class="content">The value is now stale, but it was correct at some point between the read starting and the read finishing, right?<p>That can happen with <i>any</i> read.  Even without any partitions.  Can&#x27;t it?<p>In that case I don&#x27;t see the problem.</div><br/><div id="41773302" class="c"><input type="checkbox" id="c-41773302" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41772952">root</a><span>|</span><a href="#41773175">parent</a><span>|</span><a href="#41773333">next</a><span>|</span><label class="collapse" for="c-41773302">[-]</label><label class="expand" for="c-41773302">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The value is now stale, but it was correct at some point between the read starting and the read finishing, right?<p>Not necessarily. Maybe both versions of it were from partial writes that were never committed, so your invariants are violated (if we&#x27;re talking about e.g. a credit account A and debit account B scenario).<p>&gt; That can happen with any read. Even without any partitions. Can&#x27;t it?<p>Depends on your isolation level. If your system has serializable transactions then it&#x27;s supposed to give you a history equivalent to one where all transactions were executed serially, for example.</div><br/><div id="41773554" class="c"><input type="checkbox" id="c-41773554" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41772952">root</a><span>|</span><a href="#41773302">parent</a><span>|</span><a href="#41773333">next</a><span>|</span><label class="collapse" for="c-41773554">[-]</label><label class="expand" for="c-41773554">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Not necessarily. Maybe both versions of it were from partial writes that were never committed, so your invariants are violated (if we&#x27;re talking about e.g. a credit account A and debit account B scenario).<p>I&#x27;m pretty sure the scenario above is looking at committed writes.<p>If you&#x27;re reading uncommitted writes, you&#x27;re not really in the market for consistency to being with.  (Or you could be handling consistency by waiting to see if the transaction succeeds or fails, making sure it would fail if the data you read got backed out.  But in that situation nothing goes wrong here.)<p>&gt; Depends on your isolation level. If your system has serializable transactions then it&#x27;s supposed to give you a history equivalent to one where all transactions were executed serially, for example.<p>Even then, a new write can happen before your &quot;read finished&quot; packet arrives at the client, making the read stale.  Your entire transaction is now doomed to fail, but you won&#x27;t know until you try to start committing it.<p>For pure read operations, I&#x27;m not convinced it&#x27;s a proper stale read unless the value was stale <i>before the read operation started</i>.</div><br/><div id="41773956" class="c"><input type="checkbox" id="c-41773956" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41772952">root</a><span>|</span><a href="#41773554">parent</a><span>|</span><a href="#41773333">next</a><span>|</span><label class="collapse" for="c-41773956">[-]</label><label class="expand" for="c-41773956">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m pretty sure the scenario above is looking at committed writes.<p>&gt; If you&#x27;re reading uncommitted writes, you&#x27;re not really in the market for consistency to being with.<p>But what does &quot;committed&quot; mean when you&#x27;re only reading from one partition in a partitioned scenario? You literally can&#x27;t tell whether what you&#x27;re reading is committed or not (or rather, you have to build your own protocol for when a write is considered committed).<p>&gt; For pure read operations, I&#x27;m not convinced it&#x27;s a proper stale read unless the value was stale before the read operation started.<p>I think you can get a read that is half from a prior stale operation and half from a subsequent uncommitted operation, or something on those lines.</div><br/><div id="41774237" class="c"><input type="checkbox" id="c-41774237" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41772952">root</a><span>|</span><a href="#41773956">parent</a><span>|</span><a href="#41773333">next</a><span>|</span><label class="collapse" for="c-41774237">[-]</label><label class="expand" for="c-41774237">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But what does &quot;committed&quot; mean when you&#x27;re only reading from one partition in a partitioned scenario?<p>I would say you can&#x27;t make new commits in that situation?  I don&#x27;t know, I didn&#x27;t make up the scenario, I think you need to figure out your own answer and&#x2F;or get clarification from fallingsquirrel if you want to talk about that kind of problem.<p>&gt; I think you can get a read that is half from a prior stale operation and half from a subsequent uncommitted operation, or something on those lines.<p>What&#x27;s the full timeline for that?<p>If you&#x27;re specifically talking about the ABA problem, that&#x27;s trivial to fix with a generation counter.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41773116" class="c"><input type="checkbox" id="c-41773116" checked=""/><div class="controls bullet"><span class="by">satisfice</span><span>|</span><a href="#41772952">parent</a><span>|</span><a href="#41773333">prev</a><span>|</span><a href="#41773199">next</a><span>|</span><label class="collapse" for="c-41773116">[-]</label><label class="expand" for="c-41773116">[1 more]</label></div><br/><div class="children"><div class="content">How can it know what it is consistent with? Anything could have happened since the last update. All it knows is that it most recently got an update at a certain time. It may or may not be consistent.</div><br/></div></div></div></div><div id="41773199" class="c"><input type="checkbox" id="c-41773199" checked=""/><div class="controls bullet"><span class="by">dmitry-vsl</span><span>|</span><a href="#41772952">prev</a><span>|</span><a href="#41773624">next</a><span>|</span><label class="collapse" for="c-41773199">[-]</label><label class="expand" for="c-41773199">[3 more]</label></div><br/><div class="children"><div class="content">So, it&#x27;s impossible to transfer a value from one machine to another if there&#x27;s no network connection between them? How did this extremely trivial observation become a well-known theorem?</div><br/><div id="41774071" class="c"><input type="checkbox" id="c-41774071" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#41773199">parent</a><span>|</span><a href="#41773298">next</a><span>|</span><label class="collapse" for="c-41774071">[-]</label><label class="expand" for="c-41774071">[1 more]</label></div><br/><div class="children"><div class="content">So, when it was originally phrased, the primary thing that you would have learned about databases, was that they enable ACID transactions. (And if you were a practitioner you would have learned about the various isolation levels and dirty reads and dirty writes.)<p>But if you wanted to go from this level to implementation, typically you could get a prototype working, but it would be slow. When things are slow, the WD-40 of the programming world is to add a cache. And this is where you get the quip that there are only two hard problems in computing, cache invalidation and naming things. (The “and off-by-one errors” is a later addition.) The problem is that cache invalidation shows up as consistency bugs in your database. Someone does a rare combination of commits and rollbacks and some cache doesn&#x27;t get wiped quite as fast as it needs to, or is wiped overoptimistically causing a pull from uncommitted data, and your isolation level has dropped to READ UNCOMMITTED.<p>The CAP theorem was originally raised as a conjecture, something like, “once you shard the database, I don&#x27;t think there&#x27;s any way to solve these cache problems without one of the replicas just going silent for arbitrarily long pauses while it tries to at least partially synchronize its cache with the other shards.” Phrased that way, you can understand why it was a conjecture, it relies on nobody at MIT having a super clever way to deal with caches and cleverly routing the synchronization around the sharding.<p>BUT, you can make that statement for many different reasons, and this was not for Pedagogical Reasons, its point was rather Evangelism! The author was attempting to introduce the idea of Eventual Consistency, and gain adoption by ditching all of the wisdom about ACID transactions. This antagonism was deliberate, eventual consistency became the E in a rival acronym BASE. And so the argument was that we could explore a new corner of design-space.<p>It was later that someone decided they could prove it by coming up with a universal subgraph, “whatever connection you&#x27;ve got, it has to contain this: two nodes, fighting over one value, with a network connection possibly passing through other nodes but we can abstract all that away.” And then you have a proof, and then you have a bunch of people comparing the proof to the stated claims of various database vendors, and finding that over and over they claim to be both shardable with high availability among the shards, and to support ACID transactions that keep everything consistent. It turns out those statements are usually made assuming a happy path!<p>(You also get Paxos and Raft, “here is how to get consistency without arbitrary latency on two-phase commit via majority vote”, and the Jepsen blog “you said this had consistency level X, let’s fuzz it and see if we can generate a counterexample”, and some interesting exceptions like Datomic saying “this one part is not scalable and it&#x27;s a single point of failure to sacrifice P for the CAP theorem’s sake, but in exchange we can simplify our C and A guarantees so that you can scale the reads of the system consistently.”)</div><br/></div></div><div id="41773298" class="c"><input type="checkbox" id="c-41773298" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41773199">parent</a><span>|</span><a href="#41774071">prev</a><span>|</span><a href="#41773624">next</a><span>|</span><label class="collapse" for="c-41773298">[-]</label><label class="expand" for="c-41773298">[1 more]</label></div><br/><div class="children"><div class="content">Because, sadly, a lot of system designers want to believe they have a way around it.</div><br/></div></div></div></div><div id="41773624" class="c"><input type="checkbox" id="c-41773624" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41773199">prev</a><span>|</span><a href="#41773051">next</a><span>|</span><label class="collapse" for="c-41773624">[-]</label><label class="expand" for="c-41773624">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>An Illustrated Proof of the CAP Theorem</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17528817">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17528817</a> - July 2018 (71 comments)</div><br/></div></div><div id="41773051" class="c"><input type="checkbox" id="c-41773051" checked=""/><div class="controls bullet"><span class="by">ljsprague</span><span>|</span><a href="#41773624">prev</a><span>|</span><a href="#41773775">next</a><span>|</span><label class="collapse" for="c-41773051">[-]</label><label class="expand" for="c-41773051">[7 more]</label></div><br/><div class="children"><div class="content">Is availability sacrificed more often than the other two?</div><br/><div id="41773785" class="c"><input type="checkbox" id="c-41773785" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41773051">parent</a><span>|</span><a href="#41773131">next</a><span>|</span><label class="collapse" for="c-41773785">[-]</label><label class="expand" for="c-41773785">[1 more]</label></div><br/><div class="children"><div class="content">It depends purely on the application you&#x27;re writing. Many applications prefer availability over consistency, but the application is built to cope with inconsistent data.</div><br/></div></div><div id="41773131" class="c"><input type="checkbox" id="c-41773131" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41773051">parent</a><span>|</span><a href="#41773785">prev</a><span>|</span><a href="#41773360">next</a><span>|</span><label class="collapse" for="c-41773131">[-]</label><label class="expand" for="c-41773131">[4 more]</label></div><br/><div class="children"><div class="content">Properties are only sacrificed during partitions. Due to Murphy&#x27;s Law, if you assume partitions never happen they will happen more often but if you can tolerate partitions they happen really rarely.</div><br/><div id="41773786" class="c"><input type="checkbox" id="c-41773786" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41773051">root</a><span>|</span><a href="#41773131">parent</a><span>|</span><a href="#41773186">next</a><span>|</span><label class="collapse" for="c-41773786">[-]</label><label class="expand" for="c-41773786">[1 more]</label></div><br/><div class="children"><div class="content">That is not true with PACELC<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PACELC_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PACELC_theorem</a></div><br/></div></div><div id="41773186" class="c"><input type="checkbox" id="c-41773186" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#41773051">root</a><span>|</span><a href="#41773131">parent</a><span>|</span><a href="#41773786">prev</a><span>|</span><a href="#41773360">next</a><span>|</span><label class="collapse" for="c-41773186">[-]</label><label class="expand" for="c-41773186">[2 more]</label></div><br/><div class="children"><div class="content">There are plenty of systems that sacrifice consistency even while the network is fully connected, in the name of performance—for example, DNS, or any system with a caching proxy server.</div><br/><div id="41773300" class="c"><input type="checkbox" id="c-41773300" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41773051">root</a><span>|</span><a href="#41773186">parent</a><span>|</span><a href="#41773360">next</a><span>|</span><label class="collapse" for="c-41773300">[-]</label><label class="expand" for="c-41773300">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, CAP is about the best possible behavior a system can have but you can always do worse.</div><br/></div></div></div></div></div></div><div id="41773360" class="c"><input type="checkbox" id="c-41773360" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41773051">parent</a><span>|</span><a href="#41773131">prev</a><span>|</span><a href="#41773775">next</a><span>|</span><label class="collapse" for="c-41773360">[-]</label><label class="expand" for="c-41773360">[1 more]</label></div><br/><div class="children"><div class="content">Not really. Both are all over because they address vastly different (literally incompatible) needs.<p>There is a fair bit of industry hype in the past decade or so around eventually consistent systems, because a lot of components of a business <i>can</i> use them, and that opens up a lot of extremely desirable performance options that can be fine tuned to the moon.  But they&#x27;re a real nightmare to use (i.e. often literally impossible) for anything that needs to be correct, so they are often just used <i>in addition to</i> the more classical consistency-oriented databases like postgres.</div><br/></div></div></div></div><div id="41773775" class="c"><input type="checkbox" id="c-41773775" checked=""/><div class="controls bullet"><span class="by">DarkmSparks</span><span>|</span><a href="#41773051">prev</a><span>|</span><a href="#41772947">next</a><span>|</span><label class="collapse" for="c-41773775">[-]</label><label class="expand" for="c-41773775">[1 more]</label></div><br/><div class="children"><div class="content">The problem with the example is it never actually visualises a partition, because the client can always reach both servers.<p>an actual partition is when clients and servers are partitioned and cant talk to each other.<p>solving for the situation presented is fairly trivial, and is pretty much exactly what blockchain systems solve.</div><br/></div></div><div id="41772947" class="c"><input type="checkbox" id="c-41772947" checked=""/><div class="controls bullet"><span class="by">mrybczyn</span><span>|</span><a href="#41773775">prev</a><span>|</span><a href="#41773802">next</a><span>|</span><label class="collapse" for="c-41772947">[-]</label><label class="expand" for="c-41772947">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!  That makes a lot more sense than several other descriptions of the proof I have read (and promptly forgotten!)</div><br/></div></div><div id="41773802" class="c"><input type="checkbox" id="c-41773802" checked=""/><div class="controls bullet"><span class="by">lysecret</span><span>|</span><a href="#41772947">prev</a><span>|</span><a href="#41774472">next</a><span>|</span><label class="collapse" for="c-41773802">[-]</label><label class="expand" for="c-41773802">[1 more]</label></div><br/><div class="children"><div class="content">I always think of capital asset pricing theorem first.</div><br/></div></div><div id="41774472" class="c"><input type="checkbox" id="c-41774472" checked=""/><div class="controls bullet"><span class="by">fithisux</span><span>|</span><a href="#41773802">prev</a><span>|</span><a href="#41773370">next</a><span>|</span><label class="collapse" for="c-41774472">[-]</label><label class="expand" for="c-41774472">[1 more]</label></div><br/><div class="children"><div class="content">Is there a formalization of this proof? Lean, Coq, .... ?</div><br/></div></div><div id="41773645" class="c"><input type="checkbox" id="c-41773645" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#41773370">prev</a><span>|</span><a href="#41773359">next</a><span>|</span><label class="collapse" for="c-41773645">[-]</label><label class="expand" for="c-41773645">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>&quot;G2 returns v0 to our client after the client had already written 
v1 to G1. This is inconsistent.&quot;</i><p>This is absolutely true <i>IF AND ONLY IF</i> client and servers (and data) have no notion of <i>time</i>...<p>If client and servers are say, synchronized to a central clock, and do include a timestamp with any data updated, and include timestamps with any response&#x2F;&quot;done&quot; messages and check those timestamps for accuracy (the client should perform timestamp checking as well as the servers), and if the client checks timestamps of response messages from different servers, it could then check different servers that it would later connect with, to see if they had been updated appropriately or not.<p>If later-connected-to-servers that should have been updated were not appropriately updated, then the client (if client and server are exchanging data and timestamp information) could decide how to proceed at that point.<p>If a later-connected-to-server was determined to be inconsistent, then depending upon how the client code was written, it could do many things to mitigate the problem.  It could notify other servers that it knows about of data inconsistency on the inconsistent server(s), for example...<p>Hmm, now that I think about it, on any distributed database, for any given row of data, there should not be one, but TWO timestamp fields, one for the time that the data was updated on the first server it was updated on, i.e., the one the client connected to.<p>The second timestamp field would be for the time that a secondary given distributed server received the data and processed it...<p>Those two fields could be separated by mere nanoseconds of time (if distributed servers are tightly coupled), but it could be up to weeks if a secondary server was knocked offline for a long enough time period...<p>But see, if the client software is software engineered properly, and contains the client&#x27;s history, then the client (or main server, or server multiplexing proxy) can check the veracity of any arbitrary distributed server it connects to by asking it to &quot;read me back this data&quot;, getting its timestamps and comparing with the local copies...<p>All of that coupled with databases that do not delete&#x2F;overwrite old records when data is updated, but rather keep a log of all updates with a timestamp, aka &quot;append-only&quot; aka &quot;immutable&quot; database, such as InfluxDB, Apache Cassandra, CouchDB, SQL Server Temporal Tables, (and I think that RethinkDB may have done something like that in the past) should equate to, at the very least, the client being able to know if a given server in a distributed system was updated properly (is consistent), or not...<p>If it were engineered properly, the client itself could determine what to do under such anomalous conditions...<p>It could even take it upon itself to update the server properly <i>IF</i> it contained a copy of the correct most up-to-date data <i>AND</i> had the authority to do so... which wouldn&#x27;t be the case for some types of applications (i.e., banking, due to necessary security constraints), but might be the case for other types of applications (i.e., a distributed social media app, where the client is posting to the user&#x27;s own account and has total permission to update any of the user&#x27;s data as needed...)<p>Maybe a better question to ask when dealing with the CAP theorem is not so much &quot;is it true&quot;, so much as &quot;what kind of distributed database requires consistency such that the CAP theorem is required?&quot; (i.e., banking), and &quot;what kind of distributed database doesn&#x27;t require consistency such that the CAP theorem isn&#x27;t required?&quot; (i.e., distributed social media over a plethora of distributed servers)...<p>If we see that CAP is required in only some specifc types of database&#x2F;application&#x2F;database contexts, then perhaps those specific databases&#x2F;applications&#x2F;distributed systems -- should be individually separated from non-CAP requiring ones...<p>This being said, I think Michael Stonebraker is a brilliant Computer Scientist, and I have tremendous respect for him and the CAP Theorem...</div><br/></div></div><div id="41773359" class="c"><input type="checkbox" id="c-41773359" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#41773645">prev</a><span>|</span><label class="collapse" for="c-41773359">[-]</label><label class="expand" for="c-41773359">[5 more]</label></div><br/><div class="children"><div class="content">What if the client just reads from every server and compares the timestamps?</div><br/><div id="41773815" class="c"><input type="checkbox" id="c-41773815" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41773359">parent</a><span>|</span><a href="#41774008">next</a><span>|</span><label class="collapse" for="c-41773815">[-]</label><label class="expand" for="c-41773815">[1 more]</label></div><br/><div class="children"><div class="content">It is possible but difficult at scale.<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;112600.112601" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;112600.112601</a><p><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;spanner&#x2F;docs&#x2F;true-time-external-consistency" rel="nofollow">https:&#x2F;&#x2F;cloud.google.com&#x2F;spanner&#x2F;docs&#x2F;true-time-external-con...</a></div><br/></div></div><div id="41774008" class="c"><input type="checkbox" id="c-41774008" checked=""/><div class="controls bullet"><span class="by">googledocsftw</span><span>|</span><a href="#41773359">parent</a><span>|</span><a href="#41773815">prev</a><span>|</span><a href="#41773594">next</a><span>|</span><label class="collapse" for="c-41774008">[-]</label><label class="expand" for="c-41774008">[1 more]</label></div><br/><div class="children"><div class="content">Read from every server is not necessarily possible, unless we assume no network partitions.</div><br/></div></div><div id="41773594" class="c"><input type="checkbox" id="c-41773594" checked=""/><div class="controls bullet"><span class="by">af3d</span><span>|</span><a href="#41773359">parent</a><span>|</span><a href="#41774008">prev</a><span>|</span><a href="#41773577">next</a><span>|</span><label class="collapse" for="c-41773594">[-]</label><label class="expand" for="c-41773594">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, timestamps are <i>not</i> immutable. The system clock can be miscalibrated or even deliberately manipulated. It is however something of an open question. CAP is still a bit lacking in terms of rigorous mathematical proof (albeit the arguments are pretty convincing).</div><br/></div></div><div id="41773577" class="c"><input type="checkbox" id="c-41773577" checked=""/><div class="controls bullet"><span class="by">coolThingsFirst</span><span>|</span><a href="#41773359">parent</a><span>|</span><a href="#41773594">prev</a><span>|</span><label class="collapse" for="c-41773577">[-]</label><label class="expand" for="c-41773577">[1 more]</label></div><br/><div class="children"><div class="content">it violates the consistency rule.
it must get the value that it was written</div><br/></div></div></div></div></div></div></div></div></div></body></html>