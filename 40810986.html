<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719565266066" as="style"/><link rel="stylesheet" href="styles.css?v=1719565266066"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Launch HN: Hatchet (YC W24) – Open-source task queue, now with a cloud version</a> </div><div class="subtext"><span>abelanger</span> | <span>93 comments</span></div><br/><div><div id="40817301" class="c"><input type="checkbox" id="c-40817301" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#40811509">next</a><span>|</span><label class="collapse" for="c-40817301">[-]</label><label class="expand" for="c-40817301">[8 more]</label></div><br/><div class="children"><div class="content">Can somebody explain why would I use it instead a simple Redis&#x2F;SQS&#x2F;Postgres queue implemented in 50 LOC (+ some grafana panel for monitoring) (which is pretty much mandatory even for a wrapper of this or any other service)? I&#x27;m not trying to mock it, it&#x27;s a serious question. What is implied by &quot;task queue&quot; that makes it worth bothering to use a dedicated service?</div><br/><div id="40817933" class="c"><input type="checkbox" id="c-40817933" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40817301">parent</a><span>|</span><a href="#40818217">next</a><span>|</span><label class="collapse" for="c-40817933">[-]</label><label class="expand" for="c-40817933">[3 more]</label></div><br/><div class="children"><div class="content">I have a bunch of different queues that used SAQ (~50 LoC for the whole setup) and deployed it to production. A lot of them use LLMs, and when one of them failed it was near impossible to debug. Every workflow has over a dozen connected tasks, and every task can run on over a dozen separate rows before completing... I was spending hours in log files (often unsuccessfully)<p>The dashboard in Hatchet has a great GUI where you can navigate between all the tasks, see how they all connect, see the data passed in to each one, see the return results from each task, and each one has a log box you can print information to. You can rerun tasks, override variables, trigger identical workflows, filter tasks by metadata<p>It&#x27;s dramatically reduced the amount of time it takes me to spot, identify, and fix bugs. I miss the simplicity of SAQ but that&#x27;s the reason I switched and it&#x27;s paid off already</div><br/><div id="40818222" class="c"><input type="checkbox" id="c-40818222" checked=""/><div class="controls bullet"><span class="by">yuppiepuppie</span><span>|</span><a href="#40817301">root</a><span>|</span><a href="#40817933">parent</a><span>|</span><a href="#40818217">next</a><span>|</span><label class="collapse" for="c-40818222">[-]</label><label class="expand" for="c-40818222">[2 more]</label></div><br/><div class="children"><div class="content">Is that a problem with the underlying infrastructure though? Im not seeing how using postgres queues would solve your issue... Instead it seems like an issue with your client lib, SAQ not providing the appropriate tooling to debug.<p>FWIW, Ive used both dramatiq&#x2F;celery with redis in heavy prod environments and never had an issue with debugging. And Im having a tough time understanding how switching the underlying queue infrastructure would have made my life easier.</div><br/><div id="40818348" class="c"><input type="checkbox" id="c-40818348" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40817301">root</a><span>|</span><a href="#40818222">parent</a><span>|</span><a href="#40818217">next</a><span>|</span><label class="collapse" for="c-40818348">[-]</label><label class="expand" for="c-40818348">[1 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s not a problem with the underlying infrastructure. I believe the OP was asking why use this product, not why is this specific infrastructure necessary. The infrastructure before was working fine (with SAQ at least, Celery was an absolute mess of SIGFAULTs), so that was not really part of my decision. I actually really liked SAQ and probably preferred it from an infra perspective.<p>It&#x27;s nice to be running on Postgres (i.e. not really having to worry about payload size, I heard some people were passing images from task to task) but for me that is just a nicety and wasn&#x27;t a reason to switch.<p>If you&#x27;re happy with your current infra, happy with the visibility, and there&#x27;s nothing lacking in the development perspective, then yeah probably not much point in switching your infra to begin with [1]. But if you&#x27;re building complicated workflows, and just want your code to run with an extreme level of visibility, it&#x27;s worth checking out Hatchet.<p>[1] I&#x27;m sure the founders would have more to say here, but as a consumer I&#x27;m not really deep in the architecture of the product. Best I could do could be to give you 100 reasons I will never use Celery again XD</div><br/></div></div></div></div></div></div><div id="40818217" class="c"><input type="checkbox" id="c-40818217" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#40817301">parent</a><span>|</span><a href="#40817933">prev</a><span>|</span><a href="#40817478">next</a><span>|</span><label class="collapse" for="c-40818217">[-]</label><label class="expand" for="c-40818217">[2 more]</label></div><br/><div class="children"><div class="content">You can use celery with postgres without issues if you want the stuff you don&#x27;t get with that, like tweakable retries, tweakable amounts of prefetch and other important-at-scale things. Plus out of the box working sdk with higher level patterns for you developers. Like what if devs want to track how long something waited in the queue or a metric about retries etc, things that you&#x27;d have to roll by hand.</div><br/><div id="40818766" class="c"><input type="checkbox" id="c-40818766" checked=""/><div class="controls bullet"><span class="by">mathnmusic</span><span>|</span><a href="#40817301">root</a><span>|</span><a href="#40818217">parent</a><span>|</span><a href="#40817478">next</a><span>|</span><label class="collapse" for="c-40818766">[-]</label><label class="expand" for="c-40818766">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can use celery with postgres without issues<p>How? This issue still seems to be open after 6 years: <a href="https:&#x2F;&#x2F;github.com&#x2F;celery&#x2F;celery&#x2F;issues&#x2F;5149">https:&#x2F;&#x2F;github.com&#x2F;celery&#x2F;celery&#x2F;issues&#x2F;5149</a></div><br/></div></div></div></div><div id="40817478" class="c"><input type="checkbox" id="c-40817478" checked=""/><div class="controls bullet"><span class="by">altdataseller</span><span>|</span><a href="#40817301">parent</a><span>|</span><a href="#40818217">prev</a><span>|</span><a href="#40817480">next</a><span>|</span><label class="collapse" for="c-40817478">[-]</label><label class="expand" for="c-40817478">[1 more]</label></div><br/><div class="children"><div class="content">I also want the answer to this question. Instinctually i want to say if you’re asking this Q it means you don’t need it (just like most people dont need Kubernetes&#x2F;Snowflake&#x2F;data lakes)</div><br/></div></div><div id="40817480" class="c"><input type="checkbox" id="c-40817480" checked=""/><div class="controls bullet"><span class="by">nextworddev</span><span>|</span><a href="#40817301">parent</a><span>|</span><a href="#40817478">prev</a><span>|</span><a href="#40811509">next</a><span>|</span><label class="collapse" for="c-40817480">[-]</label><label class="expand" for="c-40817480">[1 more]</label></div><br/><div class="children"><div class="content">It’s always dev ex, and saving time for these things.</div><br/></div></div></div></div><div id="40811509" class="c"><input type="checkbox" id="c-40811509" checked=""/><div class="controls bullet"><span class="by">dalberto</span><span>|</span><a href="#40817301">prev</a><span>|</span><a href="#40811993">next</a><span>|</span><label class="collapse" for="c-40811509">[-]</label><label class="expand" for="c-40811509">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m super interested in a Postgres-only task queue, but I&#x27;m still unclear from your post whether the only broker dependency is PostgreSQL. You mention working towards getting rid of the RabbitMQ dependency but the existence of RabbitMQ in your stack is dissonant with the statement &#x27;a conviction that PostgreSQL is the right choice for a task queue&#x27;. In my mind, if you are using Postgres as a queue, I&#x27;m not sure why you&#x27;d also have RabbitMQ.</div><br/><div id="40811580" class="c"><input type="checkbox" id="c-40811580" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40811509">parent</a><span>|</span><a href="#40811993">next</a><span>|</span><label class="collapse" for="c-40811580">[-]</label><label class="expand" for="c-40811580">[10 more]</label></div><br/><div class="children"><div class="content">We&#x27;re using RabbitMQ for pub&#x2F;sub between different components of our engine. The actual task queue is entirely backed by Postgres, but things like streaming events between different workers are done through RabbitMQ at the moment, as well as sending a message from one component to another when you distribute the engine components. I&#x27;ve written a little more about this here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39643940">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39643940</a>.<p>We&#x27;re eventually going to support a lightweight Postgres-backed messaging table, but the number of pub&#x2F;sub messages sent through RabbitMQ is typically an order of magnitude higher than the number of tasks sent.</div><br/><div id="40811792" class="c"><input type="checkbox" id="c-40811792" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40811580">parent</a><span>|</span><a href="#40811809">next</a><span>|</span><label class="collapse" for="c-40811792">[-]</label><label class="expand" for="c-40811792">[6 more]</label></div><br/><div class="children"><div class="content">Do you find it frustrating that what people basically want is:<p>(1) you, for free<p>(2) develop all the functionality of RabbitMQ as a Postgres extension with the most permissive license<p>(3) in order to have it on RDS<p>(4) and never hear from you again?<p>This is a colorful exaggeration. But it’s true. It is playing out with the pgvecto-rs people too.<p>People don’t want Postgres because it is good. They want it because it is offered by RDS, which makes it good.</div><br/><div id="40812499" class="c"><input type="checkbox" id="c-40812499" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40811792">parent</a><span>|</span><a href="#40812034">next</a><span>|</span><label class="collapse" for="c-40812499">[-]</label><label class="expand" for="c-40812499">[1 more]</label></div><br/><div class="children"><div class="content">While I understand the sentiment, we see it very differently. We&#x27;re interested in creating the best product possible, and being open source helps with that. The users who are self-hosting in our Discord give extremely high quality feedback and post feature ideas and discussions which shape the direction of the product. There&#x27;s plenty of room for Hatchet the OSS repo and Hatchet the cloud version to coexist.<p>&gt; develop all the functionality of RabbitMQ as a Postgres extension with the most permissive license<p>That&#x27;s fair - we&#x27;re not going to develop all the functionality of RabbitMQ on Postgres (if we were, we probably would have started with a amqp-compatible broker). We&#x27;re building the orchestration layer that sits on top of the underlying message queue and database to manage the lifecycle of a remotely-invoked function.</div><br/></div></div><div id="40812034" class="c"><input type="checkbox" id="c-40812034" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40811792">parent</a><span>|</span><a href="#40812499">prev</a><span>|</span><a href="#40812205">next</a><span>|</span><label class="collapse" for="c-40812034">[-]</label><label class="expand" for="c-40812034">[3 more]</label></div><br/><div class="children"><div class="content">So true.<p>The advice of &quot;commoditize your complements&quot; is working out great for amazon.  Ironically, AWS is almost a commodity itself, and the OSS community could flip the  table, but we haven&#x27;t figured out how to do it.</div><br/><div id="40812415" class="c"><input type="checkbox" id="c-40812415" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40812034">parent</a><span>|</span><a href="#40812205">next</a><span>|</span><label class="collapse" for="c-40812415">[-]</label><label class="expand" for="c-40812415">[2 more]</label></div><br/><div class="children"><div class="content">AWS is a commodity, albeit an expensive one. After all, it has competitors like GCP, which some people like me actually prefer.</div><br/><div id="40818428" class="c"><input type="checkbox" id="c-40818428" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40812415">parent</a><span>|</span><a href="#40812205">next</a><span>|</span><label class="collapse" for="c-40818428">[-]</label><label class="expand" for="c-40818428">[1 more]</label></div><br/><div class="children"><div class="content">I would say the lock-in is considerable. To avoid the lock-in (maybe you go full Kubernetes on EC2) then it’s ton more work.</div><br/></div></div></div></div></div></div><div id="40812205" class="c"><input type="checkbox" id="c-40812205" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40811792">parent</a><span>|</span><a href="#40812034">prev</a><span>|</span><a href="#40811809">next</a><span>|</span><label class="collapse" for="c-40812205">[-]</label><label class="expand" for="c-40812205">[1 more]</label></div><br/><div class="children"><div class="content">At least pgvector is financially supported by AWS.</div><br/></div></div></div></div><div id="40811809" class="c"><input type="checkbox" id="c-40811809" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40811580">parent</a><span>|</span><a href="#40811792">prev</a><span>|</span><a href="#40812610">next</a><span>|</span><label class="collapse" for="c-40811809">[-]</label><label class="expand" for="c-40811809">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s feasible, having Postgres as the only dependency would greatly simplify deployment and management for smaller scale systems.<p>Great job so far-  The flow-based UI <i>with triggers</i> is killer!  AFAIK, this surpasses what Celery includes.</div><br/></div></div><div id="40812610" class="c"><input type="checkbox" id="c-40812610" checked=""/><div class="controls bullet"><span class="by">dalberto</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40811580">parent</a><span>|</span><a href="#40811809">prev</a><span>|</span><a href="#40811993">next</a><span>|</span><label class="collapse" for="c-40812610">[-]</label><label class="expand" for="c-40812610">[2 more]</label></div><br/><div class="children"><div class="content">That makes sense, though a bit disappointing. One hope of using Postgres as a task queue is simplifying your overall stack. Having to host RabbitMQ partially defeats that. I&#x27;ll stay tuned for the Postgres-backed messaging!</div><br/><div id="40813020" class="c"><input type="checkbox" id="c-40813020" checked=""/><div class="controls bullet"><span class="by">tiraz</span><span>|</span><a href="#40811509">root</a><span>|</span><a href="#40812610">parent</a><span>|</span><a href="#40811993">next</a><span>|</span><label class="collapse" for="c-40813020">[-]</label><label class="expand" for="c-40813020">[1 more]</label></div><br/><div class="children"><div class="content">Then maybe Procrastinate (<a href="https:&#x2F;&#x2F;procrastinate.readthedocs.io&#x2F;en&#x2F;main&#x2F;" rel="nofollow">https:&#x2F;&#x2F;procrastinate.readthedocs.io&#x2F;en&#x2F;main&#x2F;</a>) is something for you (I just contributed some features to it). It has very good documentation, MIT license, and also some nice features like job scheduling, priorities, cancellation, etc.</div><br/></div></div></div></div></div></div></div></div><div id="40811993" class="c"><input type="checkbox" id="c-40811993" checked=""/><div class="controls bullet"><span class="by">numlocked</span><span>|</span><a href="#40811509">prev</a><span>|</span><a href="#40817908">next</a><span>|</span><label class="collapse" for="c-40811993">[-]</label><label class="expand" for="c-40811993">[6 more]</label></div><br/><div class="children"><div class="content">Being MIT licensed, does that mean that another company could also offer this as a hosted solution? Did you think about encumbering with a license that allowed commercial use, but prohibited resale?<p>Also, somewhat related, years ago I wrote a very small framework for fan-out of Django-based tasks in Celery. We have been running it in production for years. It doesn&#x27;t have adoption beyond our company, but I think there are some good ideas in it. Feel free to take a look if it&#x27;s of interest! <a href="https:&#x2F;&#x2F;github.com&#x2F;groveco&#x2F;django-sprinklers">https:&#x2F;&#x2F;github.com&#x2F;groveco&#x2F;django-sprinklers</a></div><br/><div id="40815012" class="c"><input type="checkbox" id="c-40815012" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40811993">parent</a><span>|</span><a href="#40814314">next</a><span>|</span><label class="collapse" for="c-40815012">[-]</label><label class="expand" for="c-40815012">[1 more]</label></div><br/><div class="children"><div class="content">Very cool! Does it support the latest version of Celery?<p>And to answer the question, no, the license doesn&#x27;t restrict a company from offering a hosted version of Hatchet. We chose the license that we&#x27;d want to see if we were making a decision to adopt Hatchet.<p>That said, managing and running the cloud version is significantly from a version meant for one org -- the infra surrounding the cloud version manages hundreds and eventually thousands of different tenants. While it&#x27;s all the same open-source engine + API, there&#x27;s a lot of work required to distribute the different engine components in a way that&#x27;s reliable and supports partitioning databases between tenants.</div><br/></div></div><div id="40814314" class="c"><input type="checkbox" id="c-40814314" checked=""/><div class="controls bullet"><span class="by">911e</span><span>|</span><a href="#40811993">parent</a><span>|</span><a href="#40815012">prev</a><span>|</span><a href="#40813641">next</a><span>|</span><label class="collapse" for="c-40814314">[-]</label><label class="expand" for="c-40814314">[1 more]</label></div><br/><div class="children"><div class="content">I’m also interested in understand the context for MIT instead of dual licensing for commercial needs, what’s the current best strategy ?</div><br/></div></div><div id="40813641" class="c"><input type="checkbox" id="c-40813641" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40811993">parent</a><span>|</span><a href="#40814314">prev</a><span>|</span><a href="#40814767">next</a><span>|</span><label class="collapse" for="c-40813641">[-]</label><label class="expand" for="c-40813641">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that it matters... all the cloud providers has simple queues and more complex orchestrators available already.<p>I do think their cloud offering is interesting, and being PostgreSQL backed is a big plus for in-house development.</div><br/></div></div><div id="40814767" class="c"><input type="checkbox" id="c-40814767" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#40811993">parent</a><span>|</span><a href="#40813641">prev</a><span>|</span><a href="#40817908">next</a><span>|</span><label class="collapse" for="c-40814767">[-]</label><label class="expand" for="c-40814767">[2 more]</label></div><br/><div class="children"><div class="content">I feel like just rehosting an actively maintained github repo would draw significant negative PR. And even if not, I feel like part of this business plan revolves around becoming a relatively big part of the ecosystem; one or two cloud providers potentially poaching your customers with a drop down option could easily be worth more in advertising than you’re losing in subscription dollars.<p>I’m guessing :shrug:</div><br/></div></div></div></div><div id="40817908" class="c"><input type="checkbox" id="c-40817908" checked=""/><div class="controls bullet"><span class="by">grogenaut</span><span>|</span><a href="#40811993">prev</a><span>|</span><a href="#40812179">next</a><span>|</span><label class="collapse" for="c-40817908">[-]</label><label class="expand" for="c-40817908">[1 more]</label></div><br/><div class="children"><div class="content">Shameless plug since I never get to do those: <a href="https:&#x2F;&#x2F;github.com&#x2F;gaffo&#x2F;jorb">https:&#x2F;&#x2F;github.com&#x2F;gaffo&#x2F;jorb</a><p>There&#x27;s many great distributed job runners out there. I&#x27;ve never found one for go that lets me have the features without running 7 processes and message queues sprawled over hosts and docker containers.<p>jorb is just a framework to slap into a go script when you want to fire a lot of work at your computer and let it run it to completion.<p>I&#x27;ve tried to build this many times and this is the first time I&#x27;ve gotten it to stick.<p>Yes you can do this with core go primitives but I find this abstraction to be a lot better and (eventually) was easier to debug deadlocks.<p>I&#x27;m just putting it here cause it&#x27;s semi related.</div><br/></div></div><div id="40812179" class="c"><input type="checkbox" id="c-40812179" checked=""/><div class="controls bullet"><span class="by">acaloiar</span><span>|</span><a href="#40817908">prev</a><span>|</span><a href="#40813297">next</a><span>|</span><label class="collapse" for="c-40812179">[-]</label><label class="expand" for="c-40812179">[7 more]</label></div><br/><div class="children"><div class="content">I love seeing commercial activity around using Postgres as a queue. Last year I wrote a post titled &quot;Choose Postgres queue technology&quot; that spent quite a bit of time on the front page here. I don&#x27;t think it&#x27;s likely that my post actually sparked new development in this area, but for the people who were already using Postgres queues in their applications, I hope it made them feel more comfortable talking about it in public. And I&#x27;ve seen a notable increase in public discussions around the idea, and they&#x27;re not all met with derision. There&#x27;s long been a dogma around Postgres and relational databases being the wrong tool for the job, and indeed they are not perfect, but neither is adding Redis or RabbitMQ to our software stacks simply to support queue use cases. Kudos to the Hatchet team! I hope you all find success.</div><br/><div id="40814594" class="c"><input type="checkbox" id="c-40814594" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40812179">parent</a><span>|</span><a href="#40816599">next</a><span>|</span><label class="collapse" for="c-40814594">[-]</label><label class="expand" for="c-40814594">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I remember reading the post and the discussion surrounding it being very high quality!<p>I particularly like the section on escape hatches - though you start to see the issue with this approach when you use something like Celery, where the docs and Github issues contain a number of warnings about using Redis. RabbitMQ also tends to be very feature-rich from an MQ perspective compared to Redis, so it gets more and more difficult to support both over time.<p>We&#x27;d like to build in escape hatches as well - this starts with the application code being the exact same whether you&#x27;re on cloud or self-hosted - and adding support for things like archiving task result storage to the object store of your choice, or swapping out the pub&#x2F;sub system.</div><br/></div></div><div id="40816599" class="c"><input type="checkbox" id="c-40816599" checked=""/><div class="controls bullet"><span class="by">bgentry</span><span>|</span><a href="#40812179">parent</a><span>|</span><a href="#40814594">prev</a><span>|</span><a href="#40813580">next</a><span>|</span><label class="collapse" for="c-40816599">[-]</label><label class="expand" for="c-40816599">[1 more]</label></div><br/><div class="children"><div class="content">I remember that post and I’ve read it a few times, thank you for it! I was already working on River at the time but it was refreshing to see the case made so strongly by another person who gets it.<p>- Blake, co-author of riverqueue.com &#x2F; <a href="https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;river">https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;river</a> :)</div><br/></div></div><div id="40813580" class="c"><input type="checkbox" id="c-40813580" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40812179">parent</a><span>|</span><a href="#40816599">prev</a><span>|</span><a href="#40813240">next</a><span>|</span><label class="collapse" for="c-40813580">[-]</label><label class="expand" for="c-40813580">[1 more]</label></div><br/><div class="children"><div class="content">I mostly agree... a traditional RDBMS can vertically scale a lot on modern hardware.  It&#x27;s usually easier for devs to reason with.  And odds are already part of your stack.  You can go a long way with just PostgreSQL.  It works well for traditional RDBMS cases, works well enough as a Document store and other uses as well.  The plugin ecosystem is pretty diverse as well, more than most competing options.<p>Where I defer is if you already have Redis in the mix, I might be inclined to reach for it first in a lot of scenarios.  If you have complex distribution needs then something more like RabbitMQ would be better.</div><br/></div></div><div id="40813240" class="c"><input type="checkbox" id="c-40813240" checked=""/><div class="controls bullet"><span class="by">mikejulietbravo</span><span>|</span><a href="#40812179">parent</a><span>|</span><a href="#40813580">prev</a><span>|</span><a href="#40814248">next</a><span>|</span><label class="collapse" for="c-40813240">[-]</label><label class="expand" for="c-40813240">[1 more]</label></div><br/><div class="children"><div class="content">I remember reading that post, there were a lot of good ideas in the comments</div><br/></div></div><div id="40814248" class="c"><input type="checkbox" id="c-40814248" checked=""/><div class="controls bullet"><span class="by">hipadev23</span><span>|</span><a href="#40812179">parent</a><span>|</span><a href="#40813240">prev</a><span>|</span><a href="#40813297">next</a><span>|</span><label class="collapse" for="c-40814248">[-]</label><label class="expand" for="c-40814248">[2 more]</label></div><br/><div class="children"><div class="content">&gt; neither is adding Redis or RabbitMQ to our software stacks simply to support queue use cases<p>I disagree that &quot;adding Redis to our software stack&quot; to support a queue is problematic. It&#x27;s a single process and extremely simple. Instead now with tools like this, you&#x27;re clobbering up your database with temporal tasks alongside your operational data.</div><br/><div id="40817494" class="c"><input type="checkbox" id="c-40817494" checked=""/><div class="controls bullet"><span class="by">altdataseller</span><span>|</span><a href="#40812179">root</a><span>|</span><a href="#40814248">parent</a><span>|</span><a href="#40813297">next</a><span>|</span><label class="collapse" for="c-40817494">[-]</label><label class="expand" for="c-40817494">[1 more]</label></div><br/><div class="children"><div class="content">Out of all the processes&#x2F;infrastructure ive had to manage in my career, Redis has been the simplest, and least hassle out of all of them. Even when you add Redis sentinel to the picture, it just does its job</div><br/></div></div></div></div></div></div><div id="40813297" class="c"><input type="checkbox" id="c-40813297" checked=""/><div class="controls bullet"><span class="by">mads_quist</span><span>|</span><a href="#40812179">prev</a><span>|</span><a href="#40815335">next</a><span>|</span><label class="collapse" for="c-40813297">[-]</label><label class="expand" for="c-40813297">[1 more]</label></div><br/><div class="children"><div class="content">Awesome! Reducing moving parts is always a great thing!For 99.9% of teams this is a great alternative to rely only on the database the team&#x27;s already using. For those teams that use MongoDB, I created something similar (and simpler of course): <a href="https:&#x2F;&#x2F;allquiet.app&#x2F;open-source&#x2F;mongo-queueing" rel="nofollow">https:&#x2F;&#x2F;allquiet.app&#x2F;open-source&#x2F;mongo-queueing</a>
The package is C#, but the idea could be adapted to practically any language that has a MongoDB driver.</div><br/></div></div><div id="40815335" class="c"><input type="checkbox" id="c-40815335" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40813297">prev</a><span>|</span><a href="#40812427">next</a><span>|</span><label class="collapse" for="c-40815335">[-]</label><label class="expand" for="c-40815335">[3 more]</label></div><br/><div class="children"><div class="content">I’ve been through a whole journey with distributed tasks queues - from celery, to arq, to recently hatchet. Not only is hatchet the only solution that doesn’t make me want to tear my hair out, but the visibility the product gives you is amazing! Being able to visually explore logs, props, refrigerate specific queues etc has been a game changer,<p>Also, minor thing, but the granularity around rate limiting and queues also feels like quite the luxury. Excited for more here too<p>Cool to see them on the front page, congrats on the launch</div><br/><div id="40816057" class="c"><input type="checkbox" id="c-40816057" checked=""/><div class="controls bullet"><span class="by">tecoholic</span><span>|</span><a href="#40815335">parent</a><span>|</span><a href="#40812427">next</a><span>|</span><label class="collapse" for="c-40816057">[-]</label><label class="expand" for="c-40816057">[2 more]</label></div><br/><div class="children"><div class="content">After multiple years fighting with Celery, we moved to Prefect last year and have been mostly happy with it. The only sticking point for me has been “tasks can’t start tasks, will have to be sub-flows” part. Did you ever try out Prefect and can share anything from the experience?</div><br/><div id="40817891" class="c"><input type="checkbox" id="c-40817891" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40815335">root</a><span>|</span><a href="#40816057">parent</a><span>|</span><a href="#40812427">next</a><span>|</span><label class="collapse" for="c-40817891">[-]</label><label class="expand" for="c-40817891">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have any experience with prefect, but I have to say one of my favorite things about SAQ (Simple Async Queue) was a task was a task was a task. You could enqueue them from anywhere, nest them, repeat them, skip them, whichever.<p>With hatchet theres been a little bit of a dance trying to get workflows and runs to play nicely, but all in all I was able to get everything I needed working without much trouble. You end up running quite a few more tasks than needed (essentially no-ops), or wrapping small tasks in wrapper workflows, but from both a implementation and implication standpoint, there&#x27;s almost no difference.<p>10&#x2F;10 solved problem with SAQ, 8&#x2F;10 not an issue with Hatchet... 2&#x2F;10 smh celerey</div><br/></div></div></div></div></div></div><div id="40812427" class="c"><input type="checkbox" id="c-40812427" checked=""/><div class="controls bullet"><span class="by">cyral</span><span>|</span><a href="#40815335">prev</a><span>|</span><a href="#40813359">next</a><span>|</span><label class="collapse" for="c-40812427">[-]</label><label class="expand" for="c-40812427">[14 more]</label></div><br/><div class="children"><div class="content">How does this compare to Temporal or Inngest? I&#x27;ve been investigating them and the durable execution pattern recently and would like to implement one soon.</div><br/><div id="40813180" class="c"><input type="checkbox" id="c-40813180" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40812427">parent</a><span>|</span><a href="#40813704">next</a><span>|</span><label class="collapse" for="c-40813180">[-]</label><label class="expand" for="c-40813180">[1 more]</label></div><br/><div class="children"><div class="content">Re Inngest - there are a few differences:<p>1. Hatchet is MIT licensed and designed to be self-hosted in production, with cloud as an alternative. While the Inngest dev server is open source, it doesn&#x27;t support self-hosting: <a href="https:&#x2F;&#x2F;www.inngest.com&#x2F;docs&#x2F;self-hosting" rel="nofollow">https:&#x2F;&#x2F;www.inngest.com&#x2F;docs&#x2F;self-hosting</a>.<p>2. Inngest is built on an HTTP webhook model while Hatchet is built on a long-lived, client-initiated gRPC connection. While we support HTTP webhooks for serverless environments, a core part of the Hatchet platform is built to display the health of a long-lived worker and provide worker-level metrics that can be used for autoscaling. All async runtimes that we&#x27;ve worked on in the past have eventually migrated off of serverless for a number of reasons, like reducing latency or having more control over things like runtime environment and DB connections. AFIAK the concept of a worker or worker health doesn&#x27;t exist in Inngest.<p>There are the finer details which we can hash out in the other thread, but both products rely on events, tasks and durable workflows as core concepts, and there&#x27;s a lot of overlap.</div><br/></div></div><div id="40813704" class="c"><input type="checkbox" id="c-40813704" checked=""/><div class="controls bullet"><span class="by">ensignavenger</span><span>|</span><a href="#40812427">parent</a><span>|</span><a href="#40813180">prev</a><span>|</span><a href="#40812515">next</a><span>|</span><label class="collapse" for="c-40813704">[-]</label><label class="expand" for="c-40813704">[1 more]</label></div><br/><div class="children"><div class="content">Hatchet and Temproral are MIT licensed and therefore usable by anyone, I can&#x27;t find the license for Inngest, but in another comment they say it is &quot;source available&quot; and self hostable, not sure under what terms, but smart companies that avoid vendor lock in will want to steer well clear of it if they can.</div><br/></div></div><div id="40812515" class="c"><input type="checkbox" id="c-40812515" checked=""/><div class="controls bullet"><span class="by">pm90</span><span>|</span><a href="#40812427">parent</a><span>|</span><a href="#40813704">prev</a><span>|</span><a href="#40813325">next</a><span>|</span><label class="collapse" for="c-40812515">[-]</label><label class="expand" for="c-40812515">[2 more]</label></div><br/><div class="children"><div class="content">Temporal is kinda difficult to self host. Plus you have to buy into their specific paradigm&#x2F;terminology for running tasks. This tool seems a lot more generic.</div><br/><div id="40812807" class="c"><input type="checkbox" id="c-40812807" checked=""/><div class="controls bullet"><span class="by">gabrielruttner</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40812515">parent</a><span>|</span><a href="#40813325">next</a><span>|</span><label class="collapse" for="c-40812807">[-]</label><label class="expand" for="c-40812807">[1 more]</label></div><br/><div class="children"><div class="content">We’ve heard and experienced the paradigm&#x2F;terminology thing and are focusing heavily on devex. It&#x27;s common to hear that only one engineer on a team will have experience with or knowledge of how things are architected with Temporal, which creates silos and makes it very difficult to debug when things are going wrong.<p>With Hatchet, the starting point is a single function call that gets enqueued according to a configuration you&#x27;ve set to respective different fairness and concurrency constraints. Durable workflows can be built on top of that, but the entire platform should feel intuitive and familiar to anyone working in the codebase.</div><br/></div></div></div></div><div id="40813325" class="c"><input type="checkbox" id="c-40813325" checked=""/><div class="controls bullet"><span class="by">BhavdeepSethi</span><span>|</span><a href="#40812427">parent</a><span>|</span><a href="#40812515">prev</a><span>|</span><a href="#40812987">next</a><span>|</span><label class="collapse" for="c-40813325">[-]</label><label class="expand" for="c-40813325">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t look like Inngest allows you to self-host either.</div><br/></div></div><div id="40812987" class="c"><input type="checkbox" id="c-40812987" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#40812427">parent</a><span>|</span><a href="#40813325">prev</a><span>|</span><a href="#40813359">next</a><span>|</span><label class="collapse" for="c-40812987">[-]</label><label class="expand" for="c-40812987">[8 more]</label></div><br/><div class="children"><div class="content">Chiming in as the founder of <a href="https:&#x2F;&#x2F;www.inngest.com" rel="nofollow">https:&#x2F;&#x2F;www.inngest.com</a>.  It looks like Hatchet is trying to catch up with us, though some immediate differences:<p>* Inngest is fully event driven, with replays, fan-outs, `step.waitForEvent` to automatically pause and resume durable functions when specific events are received, declarative cancellation based off of events, etc.<p>* We have real-time metrics, tracing, etc. out of the box in our UI<p>* Out of the box support for TS, Python, Golang, Java.  We&#x27;re also interchangeable with zero-downtime language and cloud migrations<p>* I don&#x27;t know Hatchet&#x27;s local dev story, but it&#x27;s a one-liner for us<p>* Batching, to turn eg. 100 events into a single execution<p>* Concurrency, throttling, rate limiting, and debouncing, built in and operate at a function level<p>* Support for your own multi-tenancy keys, allowing you to create queues and set concurrency limits for your own concurrency<p>* Works serverless, servers, or anywhere<p>* And, specifically, it&#x27;s all procedural and doesn&#x27;t have to be a DAG.<p>We&#x27;ve also invested heavily in flow control — the aspects of batching, concurrency, custom multi-tenancy controls, etc. are all things that you have to layer over other systems.<p>I expect because we&#x27;ve been around for a couple of years that newer folks like Hatchet end up trying to replicate some of what we&#x27;ve done, though building this takes quite some time.  Either way, happy to see our API and approach start to spread :)</div><br/><div id="40813750" class="c"><input type="checkbox" id="c-40813750" checked=""/><div class="controls bullet"><span class="by">p10jkle</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40812987">parent</a><span>|</span><a href="#40813464">next</a><span>|</span><label class="collapse" for="c-40813750">[-]</label><label class="expand" for="c-40813750">[3 more]</label></div><br/><div class="children"><div class="content">Maybe let them have their launch? Mitchell said it best:<p><a href="https:&#x2F;&#x2F;x.com&#x2F;mitchellh&#x2F;status&#x2F;1759626842817069290?s=46&amp;t=57h-biZQp-Dcp0k83SJHlg" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;mitchellh&#x2F;status&#x2F;1759626842817069290?s=46&amp;t=57...</a></div><br/><div id="40815824" class="c"><input type="checkbox" id="c-40815824" checked=""/><div class="controls bullet"><span class="by">cyral</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40813750">parent</a><span>|</span><a href="#40814234">next</a><span>|</span><label class="collapse" for="c-40815824">[-]</label><label class="expand" for="c-40815824">[1 more]</label></div><br/><div class="children"><div class="content">I specifically asked about Inngest, so their comment is very helpful (more so than those only focused on the open source or licensing issue)</div><br/></div></div><div id="40814234" class="c"><input type="checkbox" id="c-40814234" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40813750">parent</a><span>|</span><a href="#40815824">prev</a><span>|</span><a href="#40813464">next</a><span>|</span><label class="collapse" for="c-40814234">[-]</label><label class="expand" for="c-40814234">[1 more]</label></div><br/><div class="children"><div class="content">Ah, yes, fair.  Someone (and I don&#x27;t know who) mentioned our company so I did jump in... kind of fair, too.  I&#x27;l leave this thread :)</div><br/></div></div></div></div><div id="40813464" class="c"><input type="checkbox" id="c-40813464" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40812987">parent</a><span>|</span><a href="#40813750">prev</a><span>|</span><a href="#40813190">next</a><span>|</span><label class="collapse" for="c-40813464">[-]</label><label class="expand" for="c-40813464">[1 more]</label></div><br/><div class="children"><div class="content">If we’re going to give credit where credit’s due, the history of durable execution traces back to the ideas of AWS step functions and Azure durable functions alongside the original Cadence and Conductor project. A lot of the features here are attempting to make patterns in those projects accessible to a wider range of developers.<p>Hatchet is also event driven [1], has built-in support for tracing and metrics, and has a TS [2], Python [3] and Golang SDK [4], has support for throttling and rate limiting [5], concurrency with custom multi-tenancy keys [6], works on serverless [7], and supports procedural workflows [8].<p>That said, there are certainly lots of things to work on. Batching and better tracing are on our roadmap. And while we don’t have a Java SDK, we do have a Github discussion for future SDKs that you can vote on here: <a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;discussions&#x2F;436">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;discussions&#x2F;436</a>.<p>[1] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;triggering-runs&#x2F;event-trigger">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;triggering-runs&#x2F;event...</a><p>[2] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;typescript-sdk">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;typescript-sdk</a><p>[3] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;python-sdk">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;python-sdk</a><p>[4] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;go-sdk">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;sdks&#x2F;go-sdk</a><p>[5] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;rate-limits">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;rate-limits</a><p>[6] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;concurrency&#x2F;round-robin#how-to-use-group_round_robin">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;concurrency&#x2F;round-rob...</a><p>[7] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;webhooks">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;webhooks</a><p>[8] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;child-workflows">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;child-workflows</a></div><br/></div></div><div id="40813190" class="c"><input type="checkbox" id="c-40813190" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40812987">parent</a><span>|</span><a href="#40813464">prev</a><span>|</span><a href="#40815833">next</a><span>|</span><label class="collapse" for="c-40813190">[-]</label><label class="expand" for="c-40813190">[2 more]</label></div><br/><div class="children"><div class="content">But we can&#x27;t self host, right?<p>So it&#x27;s locked in.</div><br/><div id="40813398" class="c"><input type="checkbox" id="c-40813398" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40813190">parent</a><span>|</span><a href="#40815833">next</a><span>|</span><label class="collapse" for="c-40813398">[-]</label><label class="expand" for="c-40813398">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re source available, and a helm chart will be coming soon.  We&#x27;re actually doing the last of any queue migrations now.<p>One of our key aspects is reliability.  We were apprehensive of officially supporting self hosting with awkward queue and state store migrations until you could &quot;Set it and forget it&quot;.  Otherwise, you&#x27;re almost certainly going to be many versions behind with a very tedious upgrade path.<p>So, if you&#x27;re a cowboy, totally self hostable.  If you&#x27;re not (which makes sense — you&#x27;re using durable execution), check back in a short amount of time :)</div><br/></div></div></div></div><div id="40815833" class="c"><input type="checkbox" id="c-40815833" checked=""/><div class="controls bullet"><span class="by">cyral</span><span>|</span><a href="#40812427">root</a><span>|</span><a href="#40812987">parent</a><span>|</span><a href="#40813190">prev</a><span>|</span><a href="#40813359">next</a><span>|</span><label class="collapse" for="c-40815833">[-]</label><label class="expand" for="c-40815833">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, if you build a .NET API we will give it a try.</div><br/></div></div></div></div></div></div><div id="40813359" class="c"><input type="checkbox" id="c-40813359" checked=""/><div class="controls bullet"><span class="by">didip</span><span>|</span><a href="#40812427">prev</a><span>|</span><a href="#40812449">next</a><span>|</span><label class="collapse" for="c-40813359">[-]</label><label class="expand" for="c-40813359">[3 more]</label></div><br/><div class="children"><div class="content">I am surprised that there&#x27;s still money for this type of OSS SaaS companies.<p>Aren&#x27;t all the money go to AI companies these days (even the unicorns didn&#x27;t do well with their IPOs. E.g. Hashicorp).<p>That said, I love every single addition to the Go community so thumbs up from me.</div><br/><div id="40816361" class="c"><input type="checkbox" id="c-40816361" checked=""/><div class="controls bullet"><span class="by">kevdoran</span><span>|</span><a href="#40813359">parent</a><span>|</span><a href="#40814328">next</a><span>|</span><label class="collapse" for="c-40816361">[-]</label><label class="expand" for="c-40816361">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of AI startups that fall in the category of LLM API consumers (Anthropic&#x2F;OpenAI wrappers). Or, as I heard the CTO of one of them joking, &quot;we&#x27;re actually more EC2 wrappers than OpenAI wrappers&quot;.<p>The problem we often hit when building apps on top of LLMs is managing LLM context windows (and sometimes swappable LLM providers). For which you need different types of worker&#x2F;consumer&#x2F;queue setups.<p>TypeScript is amazing for building full-stack web apps quickly. For a decade my go-to was Django, but everything just goes so much faster with endpoints &amp; frontend all in the same place. But, finding a good job&#x2F;queue service is a little more of a challenge in this world that &quot;just setup Celery&quot;. BullMQ is great, but doesn&#x27;t work with &quot;distributed&quot; Redis providers like Upstash (Vercel&#x27;s choice).<p>So, in a roundabout way, an offering like this is in a super-duper position for AI money :)</div><br/></div></div><div id="40814328" class="c"><input type="checkbox" id="c-40814328" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40813359">parent</a><span>|</span><a href="#40816361">prev</a><span>|</span><a href="#40812449">next</a><span>|</span><label class="collapse" for="c-40814328">[-]</label><label class="expand" for="c-40814328">[1 more]</label></div><br/><div class="children"><div class="content">It does seem like some really great options are emerging in the Go community, and a lot of newer execution frameworks are supporting Go as one of the first languages. Another great addition is <a href="https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;river">https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;river</a>.</div><br/></div></div></div></div><div id="40812449" class="c"><input type="checkbox" id="c-40812449" checked=""/><div class="controls bullet"><span class="by">fangpenlin</span><span>|</span><a href="#40813359">prev</a><span>|</span><a href="#40813377">next</a><span>|</span><label class="collapse" for="c-40812449">[-]</label><label class="expand" for="c-40812449">[3 more]</label></div><br/><div class="children"><div class="content">Hatchet looks pretty awesome. I was thinking about using it to replace my Celery worker. However, the problem is that I can only use the gRPC client to create a task (correct me if I am wrong). What I want is to be able to commit a bunch of database rows altogether with the background task itself directly. The benefit of doing so with a PostgreSQL database is that all the rows will be in the same transaction. With traditional background worker solutions, you will run into two problems:<p>1. Commit changes in the db first: if you fail to enqueue the task, there will be data rows hanging in the db but no task to process them<p>2. Push the task first: the task may kick start too early, and the DB transaction is not committed yet, it cannot find the rows still in transaction. You will need to retry failure<p>We also looked at Celery and hope it can provide a similar offer, but the issue seems open for years:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;celery&#x2F;celery&#x2F;issues&#x2F;5149">https:&#x2F;&#x2F;github.com&#x2F;celery&#x2F;celery&#x2F;issues&#x2F;5149</a><p>With the needs, I build a simple Python library on top of SQLAlchemy:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;LaunchPlatform&#x2F;bq">https:&#x2F;&#x2F;github.com&#x2F;LaunchPlatform&#x2F;bq</a><p>It would be super cool if Hatchet also supports native SQL inserts with ORM frameworks. Without the ability to commit tasks with all other data rows, I think it&#x27;s missing out a bit of the benefit of using a database as the worker queue backend.</div><br/><div id="40812674" class="c"><input type="checkbox" id="c-40812674" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40812449">parent</a><span>|</span><a href="#40813377">next</a><span>|</span><label class="collapse" for="c-40812674">[-]</label><label class="expand" for="c-40812674">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s correct, you can only create tasks via the gRPC client, Hatchet can&#x27;t hook into the same transaction as your inserts or updates.<p>It seems like a very lightweight tasks table in your existing PG database which represents whether or not the task has been written to Hatchet would solve both of these cases. Once Hatchet is sent the workflow&#x2F;task to execute, it&#x27;s guaranteed to be enqueued&#x2F;requeued. That way, you could get the other benefits of Hatchet with still getting transactional enqueueing. We could definitely add this for certain ORM frameworks&#x2F;SDKs with enough interest.</div><br/><div id="40818664" class="c"><input type="checkbox" id="c-40818664" checked=""/><div class="controls bullet"><span class="by">bennyp101</span><span>|</span><a href="#40812449">root</a><span>|</span><a href="#40812674">parent</a><span>|</span><a href="#40813377">next</a><span>|</span><label class="collapse" for="c-40818664">[-]</label><label class="expand" for="c-40818664">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if you could use LISTEN&#x2F;NOTIFY so when a task name and payload are committed to a &#x27;tasks&#x27; table, then it enqueues the job as if you had done so via gRPC?</div><br/></div></div></div></div></div></div><div id="40813377" class="c"><input type="checkbox" id="c-40813377" checked=""/><div class="controls bullet"><span class="by">mind-blight</span><span>|</span><a href="#40812449">prev</a><span>|</span><a href="#40811822">next</a><span>|</span><label class="collapse" for="c-40813377">[-]</label><label class="expand" for="c-40813377">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really curious how you folks compare to something like Apache Airflow. They do a similar durable execution w&#x2F; DAGs on top of postgres and redis. They&#x27;re Python-only (one definite difference). I&#x27;m curious what other comparisons you see<p>ETA: I really like the idea of this being entirely built on Postgres. That makes infrastructure a lot easier to manage</div><br/><div id="40814163" class="c"><input type="checkbox" id="c-40814163" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40813377">parent</a><span>|</span><a href="#40811822">next</a><span>|</span><label class="collapse" for="c-40814163">[-]</label><label class="expand" for="c-40814163">[1 more]</label></div><br/><div class="children"><div class="content">While the execution model is very similar to Airflow, we&#x27;re primarily targeting async jobs which are spawned from an application, while Airflow is primarily for data pipelines. The connector ecosystem of Airflow is very powerful and not something that we&#x27;re trying to replace.<p>That&#x27;s not to say you can&#x27;t use Hatchet for data pipelines - this is a common use-case. But you probably don&#x27;t want to use Hatchet for big data pipelines where payload sizes are very large and you&#x27;re working with payloads that aren&#x27;t JSON serializable.<p>Airflow also tends to be quite slow when the task itself is short-lived. We don&#x27;t have benchmarks, but you can have a look at Windmill&#x27;s benchmarks on this: <a href="https:&#x2F;&#x2F;www.windmill.dev&#x2F;docs&#x2F;misc&#x2F;benchmarks&#x2F;competitors#results">https:&#x2F;&#x2F;www.windmill.dev&#x2F;docs&#x2F;misc&#x2F;benchmarks&#x2F;competitors#re...</a>.</div><br/></div></div></div></div><div id="40811822" class="c"><input type="checkbox" id="c-40811822" checked=""/><div class="controls bullet"><span class="by">nickzelei</span><span>|</span><a href="#40813377">prev</a><span>|</span><a href="#40812582">next</a><span>|</span><label class="collapse" for="c-40811822">[-]</label><label class="expand" for="c-40811822">[2 more]</label></div><br/><div class="children"><div class="content">Interesting and congrats on the launch!<p>I am definitely a fan of all things postgres and it&#x27;s great to see another solution that uses it.<p>My main thing is the RabbitMQ dependency (that seems to be a topic of interest in this thread). Getting rid of that and just depending on PG seems like the main path forward that would increase adoption. 
Right now I&#x27;d be considering something like this over using a tool like Rabbit (if I were making that consideration.)<p>You also compare yourself against Celery and BullMQ, but there is also talk in the readme around durable execution.
That to me puts you in the realm of Temporal. How would you say you compare&#x2F;compete with Temporal? Are you looking to compete with them?<p>EDIT: I also understand that Rabbit comes with certain things (or rather, lacks certain things) that you are building ontop of, which is cool. It&#x27;s easy to say: why are you using rabbit?? but if it&#x27;s allowing you to function like it with new additions&#x2F;features, seems like a good thing!</div><br/><div id="40812355" class="c"><input type="checkbox" id="c-40812355" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40811822">parent</a><span>|</span><a href="#40812582">next</a><span>|</span><label class="collapse" for="c-40812355">[-]</label><label class="expand" for="c-40812355">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My main thing is the RabbitMQ dependency (that seems to be a topic of interest in this thread). Getting rid of that and just depending on PG seems like the main path forward that would increase adoption.<p>Yep, we agree - this is more a matter of bandwidth as well as figuring out the final definition of the pub&#x2F;sub interface. While we wouldn&#x27;t prefer to maintain two message queue implementations, we likely won&#x27;t drop the RabbitMQ implementation entirely, even if we offer Postgres as an alternative. So if we do need to support two implementations, we&#x27;d prefer to build out a core set of features that we&#x27;re happy with first. That said, the message queue API is definitely stabilizing (<a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;blob&#x2F;31cf5be248ff9ed7b37c241a972b1007b0f8b429&#x2F;internal&#x2F;msgqueue&#x2F;msgqueue.go#L151">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet&#x2F;blob&#x2F;31cf5be248ff9ed7...</a>), so I hope we can pick this up in the coming months.<p>&gt; You also compare yourself against Celery and BullMQ, but there is also talk in the readme around durable execution. That to me puts you in the realm of Temporal. How would you say you compare&#x2F;compete with Temporal? Are you looking to compete with them?<p>Yes, our child workflows feature is an alternative to Temporal which lets you execute Temporal-like workflows. These are durable from the perspective of the parent step which executes them, as any events generated by the child workflows get replayed if the parent step re-executes. Non-parent steps are the equivalent of a Temporal activity, while parent steps are the equivalent of a Temporal workflow.<p>Our longer-term goal is to build a better developer experience than Temporal, centered around observability and worker management. On the observability side, we&#x27;re investing heavily in our dashboard, eventing, alerting and logging features. On the worker management side, we&#x27;d love to integrate more natively with worker runtime environments to handle use-cases like autoscaling.</div><br/></div></div></div></div><div id="40812582" class="c"><input type="checkbox" id="c-40812582" checked=""/><div class="controls bullet"><span class="by">wenbin</span><span>|</span><a href="#40811822">prev</a><span>|</span><a href="#40815691">next</a><span>|</span><label class="collapse" for="c-40812582">[-]</label><label class="expand" for="c-40812582">[1 more]</label></div><br/><div class="children"><div class="content">Looks awesome.<p>We&#x27;ve been using Celery at ListenNotes.com since 2017. I agree that observability of Celery tasks is not great.</div><br/></div></div><div id="40815691" class="c"><input type="checkbox" id="c-40815691" checked=""/><div class="controls bullet"><span class="by">n00bskoolbus</span><span>|</span><a href="#40812582">prev</a><span>|</span><a href="#40811992">next</a><span>|</span><label class="collapse" for="c-40815691">[-]</label><label class="expand" for="c-40815691">[3 more]</label></div><br/><div class="children"><div class="content">This looks really awesome! We were just discussing at work how we&#x27;re having a hard time finding a framework for a task queue that supports dependant tasks and has support for Python &amp; TS. I suppose writing that out it does feel like a pretty specific requirement. I&#x27;m glad to see this pop up though, feels very relevant to me right now.<p>A question around workflows having just skimmed your docs. Is it possible to define a workflow that has steps in Python and a TS app?</div><br/><div id="40815827" class="c"><input type="checkbox" id="c-40815827" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40815691">parent</a><span>|</span><a href="#40811992">next</a><span>|</span><label class="collapse" for="c-40815827">[-]</label><label class="expand" for="c-40815827">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! Yes, our recommended approach is to write a parent workflow which calls child workflows registered on a different worker. We have users who are managing a set of Python functions from a Typescript backend with this approach.<p>It&#x27;s also possible to have a single DAG workflow (instead of parent&#x2F;child) that has steps across multiple languages, but you&#x27;ll need to use a relatively undocumented method called `RegisterAction` within each SDK and use the API to register the DAG (instead of using the built-in helpers) for this use-case. So we recommend using the parent&#x2F;child workflows instead.</div><br/><div id="40815844" class="c"><input type="checkbox" id="c-40815844" checked=""/><div class="controls bullet"><span class="by">n00bskoolbus</span><span>|</span><a href="#40815691">root</a><span>|</span><a href="#40815827">parent</a><span>|</span><a href="#40811992">next</a><span>|</span><label class="collapse" for="c-40815844">[-]</label><label class="expand" for="c-40815844">[1 more]</label></div><br/><div class="children"><div class="content">Ah okay that makes sense! Thanks for the reply, will definitely try hatchet out!</div><br/></div></div></div></div></div></div><div id="40811992" class="c"><input type="checkbox" id="c-40811992" checked=""/><div class="controls bullet"><span class="by">gabev</span><span>|</span><a href="#40815691">prev</a><span>|</span><a href="#40818363">next</a><span>|</span><label class="collapse" for="c-40811992">[-]</label><label class="expand" for="c-40811992">[2 more]</label></div><br/><div class="children"><div class="content">Hey, this is Gabe from zenfetch. Been following you guys for a few months now since your first launch. I definitely resonate with all the problems you&#x27;ve described regarding celery shortcomings &#x2F; other distributed task queues. We&#x27;re on celery right now and have been through the ringer with various workflow platforms. Only reason we haven&#x27;t switched to Hatchet is because we are finally in a stable place, though that might change soon in which case I&#x27;d be very open to jumping ship.<p>I know a lot of folks are going after the AI agent workflow orchestration platform, do you see yourselves progressing there?<p>In my head, Hatchet coupled with BAML (<a href="https:&#x2F;&#x2F;www.boundaryml.com&#x2F;">https:&#x2F;&#x2F;www.boundaryml.com&#x2F;</a>) could be an incredible combination to support these AI agents. Congrats on the launch</div><br/><div id="40812246" class="c"><input type="checkbox" id="c-40812246" checked=""/><div class="controls bullet"><span class="by">gabrielruttner</span><span>|</span><a href="#40811992">parent</a><span>|</span><a href="#40818363">next</a><span>|</span><label class="collapse" for="c-40812246">[-]</label><label class="expand" for="c-40812246">[1 more]</label></div><br/><div class="children"><div class="content">Hi Gabe, also Gabe here. Yes, this is a core usecase we&#x27;re continuing to develop. Prior to Hatchet I spent some time as a contractor building LLM agents where I was frustrated with the state-of-tooling for orchestration and lock in of some of these platforms.<p>To that end, we’re building Hatchet to orchestrate agents with features that are common like streaming from running workers to frontend [1] and rate limiting [2] without imposing too many opinions on core application logic.<p>[1] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;streaming">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;streaming</a>
[2] <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;rate-limits">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;home&#x2F;features&#x2F;rate-limits</a></div><br/></div></div></div></div><div id="40818363" class="c"><input type="checkbox" id="c-40818363" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#40811992">prev</a><span>|</span><a href="#40811653">next</a><span>|</span><label class="collapse" for="c-40818363">[-]</label><label class="expand" for="c-40818363">[1 more]</label></div><br/><div class="children"><div class="content">Is .NET&#x2F;C# support on the roadmap?</div><br/></div></div><div id="40811653" class="c"><input type="checkbox" id="c-40811653" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#40818363">prev</a><span>|</span><a href="#40812077">next</a><span>|</span><label class="collapse" for="c-40811653">[-]</label><label class="expand" for="c-40811653">[2 more]</label></div><br/><div class="children"><div class="content">What happened to the Terraform management tool? Pivot?</div><br/><div id="40811817" class="c"><input type="checkbox" id="c-40811817" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40811653">parent</a><span>|</span><a href="#40812077">next</a><span>|</span><label class="collapse" for="c-40811817">[-]</label><label class="expand" for="c-40811817">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, pretty much - that was more of a side project while figuring out what to work on next. Plus the Terraform licensing changes were on the horizon and I became a little frustrated with the whole ecosystem.<p>Part of the reason for working on Hatchet (this version) was that I built the Terraform management tool on top of Temporal and felt there was room for improvement.<p>(for those curious - <a href="https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet-v1-archived">https:&#x2F;&#x2F;github.com&#x2F;hatchet-dev&#x2F;hatchet-v1-archived</a>)</div><br/></div></div></div></div><div id="40812077" class="c"><input type="checkbox" id="c-40812077" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40811653">prev</a><span>|</span><a href="#40815033">next</a><span>|</span><label class="collapse" for="c-40812077">[-]</label><label class="expand" for="c-40812077">[5 more]</label></div><br/><div class="children"><div class="content">Looks cool, but I’m still team everything-in-Postgres</div><br/><div id="40812183" class="c"><input type="checkbox" id="c-40812183" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#40812077">parent</a><span>|</span><a href="#40813881">prev</a><span>|</span><a href="#40815033">next</a><span>|</span><label class="collapse" for="c-40812183">[-]</label><label class="expand" for="c-40812183">[2 more]</label></div><br/><div class="children"><div class="content">This uses Postgres</div><br/><div id="40818523" class="c"><input type="checkbox" id="c-40818523" checked=""/><div class="controls bullet"><span class="by">e-brake</span><span>|</span><a href="#40812077">root</a><span>|</span><a href="#40812183">parent</a><span>|</span><a href="#40815033">next</a><span>|</span><label class="collapse" for="c-40818523">[-]</label><label class="expand" for="c-40818523">[1 more]</label></div><br/><div class="children"><div class="content">And RabbitMQ :S</div><br/></div></div></div></div></div></div><div id="40815033" class="c"><input type="checkbox" id="c-40815033" checked=""/><div class="controls bullet"><span class="by">distributedsean</span><span>|</span><a href="#40812077">prev</a><span>|</span><a href="#40812737">next</a><span>|</span><label class="collapse" for="c-40815033">[-]</label><label class="expand" for="c-40815033">[1 more]</label></div><br/><div class="children"><div class="content">Nice, looks really good. High time a decent task queue came along that is usable with the Node ecosystem.</div><br/></div></div><div id="40812737" class="c"><input type="checkbox" id="c-40812737" checked=""/><div class="controls bullet"><span class="by">ocolegro</span><span>|</span><a href="#40815033">prev</a><span>|</span><a href="#40814808">next</a><span>|</span><label class="collapse" for="c-40812737">[-]</label><label class="expand" for="c-40812737">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been using hatchet for cloud deployments and have really enjoyed the reliable execution &#x2F; observability, congrats on the launch.</div><br/></div></div><div id="40814808" class="c"><input type="checkbox" id="c-40814808" checked=""/><div class="controls bullet"><span class="by">soohoonchoi</span><span>|</span><a href="#40812737">prev</a><span>|</span><a href="#40814189">next</a><span>|</span><label class="collapse" for="c-40814808">[-]</label><label class="expand" for="c-40814808">[1 more]</label></div><br/><div class="children"><div class="content">we use hatchet to orchestrate our long running backend jobs. it provided us with scalability, reliability, and observability into our tasks with a couple lines of code.</div><br/></div></div><div id="40814189" class="c"><input type="checkbox" id="c-40814189" checked=""/><div class="controls bullet"><span class="by">thevivekshukla</span><span>|</span><a href="#40814808">prev</a><span>|</span><a href="#40811941">next</a><span>|</span><label class="collapse" for="c-40814189">[-]</label><label class="expand" for="c-40814189">[3 more]</label></div><br/><div class="children"><div class="content">Seems interesting, what are the plans on Rust SDK?</div><br/><div id="40814449" class="c"><input type="checkbox" id="c-40814449" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40814189">parent</a><span>|</span><a href="#40811941">next</a><span>|</span><label class="collapse" for="c-40814449">[-]</label><label class="expand" for="c-40814449">[2 more]</label></div><br/><div class="children"><div class="content">We&#x27;d like to stabilize our existing 3 SDKs and create a proper spec for future SDKs to implement. While we use proto definitions and openapi to generate clients, there are a lot of decisions made while calling these APIs that are undocumented but kept consistent between TS, Python and Go.<p>Once that&#x27;s done and we consider our core API stable, there&#x27;s a good chance we&#x27;ll start tackling a new set of SDKs later this year.</div><br/><div id="40816518" class="c"><input type="checkbox" id="c-40816518" checked=""/><div class="controls bullet"><span class="by">plasma</span><span>|</span><a href="#40814189">root</a><span>|</span><a href="#40814449">parent</a><span>|</span><a href="#40811941">next</a><span>|</span><label class="collapse" for="c-40816518">[-]</label><label class="expand" for="c-40816518">[1 more]</label></div><br/><div class="children"><div class="content">Project looks interesting, would welcome seeing an API (or c# client) to be able to use it.</div><br/></div></div></div></div></div></div><div id="40811941" class="c"><input type="checkbox" id="c-40811941" checked=""/><div class="controls bullet"><span class="by">jusonchan81</span><span>|</span><a href="#40814189">prev</a><span>|</span><a href="#40811438">next</a><span>|</span><label class="collapse" for="c-40811941">[-]</label><label class="expand" for="c-40811941">[2 more]</label></div><br/><div class="children"><div class="content">What are some real world use cases you see customers using this for?</div><br/><div id="40814369" class="c"><input type="checkbox" id="c-40814369" checked=""/><div class="controls bullet"><span class="by">gabrielruttner</span><span>|</span><a href="#40811941">parent</a><span>|</span><a href="#40811438">next</a><span>|</span><label class="collapse" for="c-40814369">[-]</label><label class="expand" for="c-40814369">[1 more]</label></div><br/><div class="children"><div class="content">Folks are using us for long-lived tasks traditionally considered background jobs, as well as near-real-time background jobs. Our latency is acceptable for requests where users may still be waiting, such as LLM&#x2F;GPU inference. Some concrete examples:<p>1. Repository&#x2F;document ingestion and indexing fanout for applications like code generation or legal tech LLM agents<p>2. Orchestrating cloud deployment pipelines<p>3. Web scraping and post-processing<p>4. GPU inference jobs requiring multiple steps, compute classes, or batches</div><br/></div></div></div></div><div id="40811438" class="c"><input type="checkbox" id="c-40811438" checked=""/><div class="controls bullet"><span class="by">michaelmarkell</span><span>|</span><a href="#40811941">prev</a><span>|</span><a href="#40816176">next</a><span>|</span><label class="collapse" for="c-40811438">[-]</label><label class="expand" for="c-40811438">[4 more]</label></div><br/><div class="children"><div class="content">can you run the whole task as a postgres transaction? like if i want to make an idempotent job by only updating some status to &quot;complete&quot; once the job finishes.</div><br/><div id="40811529" class="c"><input type="checkbox" id="c-40811529" checked=""/><div class="controls bullet"><span class="by">abelanger</span><span>|</span><a href="#40811438">parent</a><span>|</span><a href="#40813391">next</a><span>|</span><label class="collapse" for="c-40811529">[-]</label><label class="expand" for="c-40811529">[1 more]</label></div><br/><div class="children"><div class="content">No, the whole task doesn&#x27;t execute as a postgres transaction. Transactions will update the status of a task (and higher-order concepts like workflows) and assign&#x2F;unassign work to workers, but they&#x27;re short-lived by design.<p>For some more detail -- to ensure we can&#x27;t assign duplicate work, we track which workers are assigned to jobs by using the concept of a WorkerSemaphore, where each worker slot is backed by a row in the WorkerSemaphore table. When assigning tasks, we scan the WorkerSemaphore table and use `FOR UPDATE SKIP LOCKED` to skip any locked rows help by other assignment transactions. We also have a uniqueness constraint on the task id across all WorkerSemaphores to ensure that no more than 1 task can be acquired by a semaphore.<p>This is slightly different to the way most pg-backed queues work, where `FOR UPDATE SKIP LOCKED` is done on the task level, but this is because not every worker maintains its own connection to the database in Hatchet, so we use this pattern to assign tasks across multiple workers and route the task via gRPC to the correct worker after the transaction completes.</div><br/></div></div><div id="40813391" class="c"><input type="checkbox" id="c-40813391" checked=""/><div class="controls bullet"><span class="by">mind-blight</span><span>|</span><a href="#40811438">parent</a><span>|</span><a href="#40811529">prev</a><span>|</span><a href="#40811557">next</a><span>|</span><label class="collapse" for="c-40813391">[-]</label><label class="expand" for="c-40813391">[1 more]</label></div><br/><div class="children"><div class="content">Long running transactions can easily lock up your database. I&#x27;d definitely avoid  those. You&#x27;re better off writing status records to the DB and using those to determine whether something is running, failing, etc.</div><br/></div></div><div id="40811557" class="c"><input type="checkbox" id="c-40811557" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#40811438">parent</a><span>|</span><a href="#40813391">prev</a><span>|</span><a href="#40816176">next</a><span>|</span><label class="collapse" for="c-40811557">[-]</label><label class="expand" for="c-40811557">[1 more]</label></div><br/><div class="children"><div class="content">Not a Hatchet user, but this doesn’t sound like a Hatchet-specific question. Long running transactions could be problematic depending on the details. I handle idempotency by not holding a transaction and instead only upserting records in jobs and using the job record itself to get the status. For example, if you want to know if a PDF has had all of its pages OCR’d, look at all of the job records for the PDF and aggregate them by status. If they’re all complete you’re good to go.</div><br/></div></div></div></div><div id="40816176" class="c"><input type="checkbox" id="c-40816176" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#40811438">prev</a><span>|</span><a href="#40816316">next</a><span>|</span><label class="collapse" for="c-40816176">[-]</label><label class="expand" for="c-40816176">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve built several message queues over the years.<p>I hated the configuration and management complexity of RabbitMQ and Celery and pretty much everything else.<p>My ultimate goal was to build a message queue that was extremely fast and required absolutely zero config and was HTTP based thus has no requirement for any specific client.<p>I developed one in Python that was pretty complete but slow, then developing a prototype in Rust that was extremely fast but incomplete.<p>The latest is sasquatch.  Its written in golang, uses sqlite for the db and behaves in a very similar way to Amazon SQS in that connections are HTTP and it uses long polling to wait for messages.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;crowdwave&#x2F;sasquatch">https:&#x2F;&#x2F;github.com&#x2F;crowdwave&#x2F;sasquatch</a><p>Its only in the very early stages of development at this stage and likely isn&#x27;t even compiling but most of the code is in place.  I&#x27;m hoping to get around to next phase of development soon.<p>I just love the idea of a message queue that is a single static binary and when you run it, you have a fully functioning message queue with nothing more to do - not even fiddling with Postgres.<p>Absolute zero config, not minutes, hours or days of futzing with configs and blogs and tutorials.</div><br/></div></div><div id="40816316" class="c"><input type="checkbox" id="c-40816316" checked=""/><div class="controls bullet"><span class="by">smallshen</span><span>|</span><a href="#40816176">prev</a><span>|</span><a href="#40814281">next</a><span>|</span><label class="collapse" for="c-40816316">[-]</label><label class="expand" for="c-40816316">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering what is the difference from <a href="https:&#x2F;&#x2F;docs.urlinks.io&#x2F;gateway-chain&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.urlinks.io&#x2F;gateway-chain&#x2F;</a> .
There are a lot similar concepts, like very similar. Hatchet feels like same product but with money from VCs.</div><br/><div id="40816359" class="c"><input type="checkbox" id="c-40816359" checked=""/><div class="controls bullet"><span class="by">pizzafeelsright</span><span>|</span><a href="#40816316">parent</a><span>|</span><a href="#40814281">next</a><span>|</span><label class="collapse" for="c-40816359">[-]</label><label class="expand" for="c-40816359">[1 more]</label></div><br/><div class="children"><div class="content">So there&#x27;s a market.</div><br/></div></div></div></div></div></div></div></div></div></body></html>