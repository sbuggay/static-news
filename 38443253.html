<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701248458725" as="style"/><link rel="stylesheet" href="styles.css?v=1701248458725"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mcyoung.xyz/2023/11/27/simd-base64/">Designing a SIMD Algorithm from Scratch</a> <span class="domain">(<a href="https://mcyoung.xyz">mcyoung.xyz</a>)</span></div><div class="subtext"><span>ingve</span> | <span>71 comments</span></div><br/><div><div id="38444105" class="c"><input type="checkbox" id="c-38444105" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#38446844">next</a><span>|</span><label class="collapse" for="c-38444105">[-]</label><label class="expand" for="c-38444105">[14 more]</label></div><br/><div class="children"><div class="content">Great article, and it’s pretty interesting to see portable simd in use. I tried reproducing the benchmarks on a Zen 3 system, and I’m getting identical speedups. On my M1 mbp, the perf gains start around 1.4x, gradually increasing to 2x @ 110 bytes of input length. A bit less gains than on x86_64, but I’d say it fulfils its goal.<p>Although looking at the code, this article confirms my experience that Rust has rather poor ergonomics for simd and pointer-related work (and performance engineering in general).</div><br/><div id="38444611" class="c"><input type="checkbox" id="c-38444611" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38444105">parent</a><span>|</span><a href="#38445534">next</a><span>|</span><label class="collapse" for="c-38444611">[-]</label><label class="expand" for="c-38444611">[12 more]</label></div><br/><div class="children"><div class="content">I disagree with the ergonomics being poor. C++ SSE intrinsics are significantly worse, with ugly underscores and names that are hard to remember.</div><br/><div id="38444658" class="c"><input type="checkbox" id="c-38444658" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444611">parent</a><span>|</span><a href="#38444680">next</a><span>|</span><label class="collapse" for="c-38444658">[-]</label><label class="expand" for="c-38444658">[5 more]</label></div><br/><div class="children"><div class="content">Being more ergonomic than C++ is a low bar anyways, we should hold ourselves to a higher standard. For starters, field offset syntax is painful (see Gankra&#x27;s post on this topic) and pointer manipulation lacks syntactic sugar. I also believe unsigned integer promotion and UFCS would improve ergonomics with high-perf code (although I&#x27;m aware this is not going to be included in Rust).</div><br/><div id="38445222" class="c"><input type="checkbox" id="c-38445222" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444658">parent</a><span>|</span><a href="#38444680">next</a><span>|</span><label class="collapse" for="c-38445222">[-]</label><label class="expand" for="c-38445222">[4 more]</label></div><br/><div class="children"><div class="content">At that point it is better to have some kind of DSL that should <i>not</i> be in the main language, because it would target a much lower level than a typical program. The best effort I&#x27;ve seen in this scene was Google&#x27;s Highway [1] (not to be confused with HighwayHash) and I even once attempted to recreate it in Rust, but it is still a bit far from my ideal.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway</a></div><br/><div id="38450669" class="c"><input type="checkbox" id="c-38450669" checked=""/><div class="controls bullet"><span class="by">superjan</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38445222">parent</a><span>|</span><a href="#38447460">next</a><span>|</span><label class="collapse" for="c-38450669">[-]</label><label class="expand" for="c-38450669">[1 more]</label></div><br/><div class="children"><div class="content">I agree about having a DSL. It may not need to be low level, you could have an array language like APL&#x2F;J. But glsl would work for me too, the important thing is to lure developers to expose parallelism.</div><br/></div></div><div id="38447460" class="c"><input type="checkbox" id="c-38447460" checked=""/><div class="controls bullet"><span class="by">janwas</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38445222">parent</a><span>|</span><a href="#38450669">prev</a><span>|</span><a href="#38444680">next</a><span>|</span><label class="collapse" for="c-38447460">[-]</label><label class="expand" for="c-38447460">[2 more]</label></div><br/><div class="children"><div class="content">Thanks :) We&#x27;re always curious to hear how it could be improved?</div><br/><div id="38454617" class="c"><input type="checkbox" id="c-38454617" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38447460">parent</a><span>|</span><a href="#38444680">next</a><span>|</span><label class="collapse" for="c-38454617">[-]</label><label class="expand" for="c-38454617">[1 more]</label></div><br/><div class="children"><div class="content">I think Highway is already good enough as a non-DSL. I had something like GLSL in mind, but more blended to the parent language.</div><br/></div></div></div></div></div></div></div></div><div id="38444680" class="c"><input type="checkbox" id="c-38444680" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444611">parent</a><span>|</span><a href="#38444658">prev</a><span>|</span><a href="#38444805">next</a><span>|</span><label class="collapse" for="c-38444680">[-]</label><label class="expand" for="c-38444680">[4 more]</label></div><br/><div class="children"><div class="content">Check out the Clang extended vector extension for C, IMHO that&#x27;s the perfect way to add portable SIMD to a language. Doing it through a library will always be clumsy.</div><br/><div id="38444900" class="c"><input type="checkbox" id="c-38444900" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444680">parent</a><span>|</span><a href="#38451465">next</a><span>|</span><label class="collapse" for="c-38444900">[-]</label><label class="expand" for="c-38444900">[2 more]</label></div><br/><div class="children"><div class="content">It quickly runs into __builtin functions though, which is not very different from intrinsics with a better and portable name. Rust `Simd` type is much more consistent with corresponding scalar types compared to that.</div><br/><div id="38445111" class="c"><input type="checkbox" id="c-38445111" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444900">parent</a><span>|</span><a href="#38451465">next</a><span>|</span><label class="collapse" for="c-38445111">[-]</label><label class="expand" for="c-38445111">[1 more]</label></div><br/><div class="children"><div class="content">True, I think the builtins were necessary where the existing C operators don&#x27;t map well to a specific SIMD feature (from what I&#x27;ve seen it&#x27;s mostly &quot;reduce&quot; actions to reduce SIMD lanes into a single value). Still, a lot can be done without having to pepper the code with builtin functions, and the result is much more readable than purely intrinsic-based code.<p>But a &quot;new&quot; language like Rust would have the freedom to add special language syntax and operators for such things instead of going the C++ way of &quot;just add it to the stdlib&quot; (which IMHO is almost always the wrong place... it should either go into a regular cargo dependency, or into the language itself).</div><br/></div></div></div></div><div id="38451465" class="c"><input type="checkbox" id="c-38451465" checked=""/><div class="controls bullet"><span class="by">vt240</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444680">parent</a><span>|</span><a href="#38444900">prev</a><span>|</span><a href="#38444805">next</a><span>|</span><label class="collapse" for="c-38451465">[-]</label><label class="expand" for="c-38451465">[1 more]</label></div><br/><div class="children"><div class="content">I loved the Intel Cilk Plus project. I was sad to see it was abandoned.  It always felt like a very natural syntax at least to me.</div><br/></div></div></div></div><div id="38444805" class="c"><input type="checkbox" id="c-38444805" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444611">parent</a><span>|</span><a href="#38444680">prev</a><span>|</span><a href="#38445444">next</a><span>|</span><label class="collapse" for="c-38444805">[-]</label><label class="expand" for="c-38444805">[1 more]</label></div><br/><div class="children"><div class="content">Those intrinsics are specified by Intel, not C++</div><br/></div></div><div id="38445444" class="c"><input type="checkbox" id="c-38445444" checked=""/><div class="controls bullet"><span class="by">bottled_poe</span><span>|</span><a href="#38444105">root</a><span>|</span><a href="#38444611">parent</a><span>|</span><a href="#38444805">prev</a><span>|</span><a href="#38445534">next</a><span>|</span><label class="collapse" for="c-38445444">[-]</label><label class="expand" for="c-38445444">[1 more]</label></div><br/><div class="children"><div class="content">As if semantics are a significant productivity factor, get off ya high horse.</div><br/></div></div></div></div><div id="38445534" class="c"><input type="checkbox" id="c-38445534" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38444105">parent</a><span>|</span><a href="#38444611">prev</a><span>|</span><a href="#38446844">next</a><span>|</span><label class="collapse" for="c-38445534">[-]</label><label class="expand" for="c-38445534">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t read through the article yet, but as a Rust eng... I sort of agree, but ... I mean, pointer &amp; raw memory related work is <i>deliberately</i> kneecapped in the name of safety, the language wants you to really think about what you&#x27;re doing.<p>But yep portable SIMD in Rust is still not a good story, compared to C++. And getting down to raw byte regions, pointer &amp; buffer manipulation, etc requires becoming comfortable with Pin, MaybeUninit, etc. Both portable simd and allocator_api have been sitting unstable for years. And the barrier to entry is a bit higher, and it&#x27;s more awkward ... mostly on purpose<p>But there&#x27;s nothing stopping one from building one&#x27;s own abstractions (or using 3rd party crates etc) to make these things more ergonomic within one&#x27;s own program?</div><br/></div></div></div></div><div id="38446844" class="c"><input type="checkbox" id="c-38446844" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38444105">prev</a><span>|</span><a href="#38444556">next</a><span>|</span><label class="collapse" for="c-38446844">[-]</label><label class="expand" for="c-38446844">[18 more]</label></div><br/><div class="children"><div class="content">It is crazy sometimes how you try to program something the best you ever could with classical C++, and then someone comes along and makes a version using SIMD that is over 10x faster (but less portable code).<p>I really wish compilers were better at auto vectorization. And some support added for annotations in the language to locally allow reordering some operations, ...</div><br/><div id="38450349" class="c"><input type="checkbox" id="c-38450349" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#38446844">parent</a><span>|</span><a href="#38450306">next</a><span>|</span><label class="collapse" for="c-38450349">[-]</label><label class="expand" for="c-38450349">[1 more]</label></div><br/><div class="children"><div class="content">Good SIMD code requires careful consideration of how your data is laid out in memory. This makes auto vectorization really difficult since the compiler can’t fix your data for you outside of very local contexts</div><br/></div></div><div id="38450306" class="c"><input type="checkbox" id="c-38450306" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#38446844">parent</a><span>|</span><a href="#38450349">prev</a><span>|</span><a href="#38449621">next</a><span>|</span><label class="collapse" for="c-38450306">[-]</label><label class="expand" for="c-38450306">[1 more]</label></div><br/><div class="children"><div class="content">You could just use CUDA, which is C++ designed for GPUs, the ultimate SIMD machine of today.<p>Or ROCm (basically CUDA but for AMD).<p>I always was a fan of Microsoft&#x27;s C++AMP though. I thought that was easiest to get into. Too bad it never stuck though.</div><br/></div></div><div id="38449621" class="c"><input type="checkbox" id="c-38449621" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38446844">parent</a><span>|</span><a href="#38450306">prev</a><span>|</span><a href="#38447450">next</a><span>|</span><label class="collapse" for="c-38449621">[-]</label><label class="expand" for="c-38449621">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It is crazy sometimes how you try to program something the best you ever could with classical C++, and then someone comes along and makes a version using SIMD that is over 10x faster (but less portable code).<p>But that’s one of the points of a systems programming language (of which C++ is one) — it tries to be portably as efficient as possible but makes it easy to do target-specific programming when required.<p>&gt; I really wish compilers were better at auto vectorization<p>FORTRAN compilers sure are, since aliasing is not allowed.  C++ is kneecapped by following C’s memory model.</div><br/><div id="38452632" class="c"><input type="checkbox" id="c-38452632" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38449621">parent</a><span>|</span><a href="#38450299">next</a><span>|</span><label class="collapse" for="c-38452632">[-]</label><label class="expand" for="c-38452632">[3 more]</label></div><br/><div class="children"><div class="content">But why is C++ refusing to add &quot;restrict&quot; to its spec? C has restrict in its spec, C++ has not. Of course compilers inherit restrict from C, but it&#x27;s not super portable due to C++ not officially supporting it. But why?!</div><br/><div id="38455361" class="c"><input type="checkbox" id="c-38455361" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38452632">parent</a><span>|</span><a href="#38455428">next</a><span>|</span><label class="collapse" for="c-38455361">[-]</label><label class="expand" for="c-38455361">[1 more]</label></div><br/><div class="children"><div class="content">In or out of the spec doesn&#x27;t really matter. You can use __restrict__ in C++ and any compiler will diligently accept it, if not for the occasional warning.<p>The larger issue is that C and C++ have convoluted aliasing rules which makes reasoning and flagging non-aliased regions hard. The most innocent of cast can break strict aliasing rules and send you in horrible debugging scenarios. The sad side effect being people adding -fno-strict-aliasing to -O2&#x2F;3.</div><br/></div></div><div id="38455428" class="c"><input type="checkbox" id="c-38455428" checked=""/><div class="controls bullet"><span class="by">WanderPanda</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38452632">parent</a><span>|</span><a href="#38455361">prev</a><span>|</span><a href="#38450299">next</a><span>|</span><label class="collapse" for="c-38455428">[-]</label><label class="expand" for="c-38455428">[1 more]</label></div><br/><div class="children"><div class="content">I was wondering the same! I just recently came across the restrict keyword (thanks to someone mentioning it on HN) but I have never seen it being mentioned before, even though I was looking into all sorts of optimizations (also ChatGPT would never bring it up on its own).<p>Since with templating everything seems to be going header only anyways, I feel like we should give the compiler more power to reason about the memory layout, even through multiple levels of function invocation&#x2F;inlining.<p>I wrote some library where basically all shapes can be infered at compile-time (through templates) but the compiler only rarely seems to take advantage of this.</div><br/></div></div></div></div><div id="38450299" class="c"><input type="checkbox" id="c-38450299" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38449621">parent</a><span>|</span><a href="#38452632">prev</a><span>|</span><a href="#38449920">next</a><span>|</span><label class="collapse" for="c-38450299">[-]</label><label class="expand" for="c-38450299">[1 more]</label></div><br/><div class="children"><div class="content">Fortran compilers can assume that (many) dummy arguments to a particular procedure reference do not alias each other, true.  But there are many other ways in which aliasing can happen in a conforming Fortran program.</div><br/></div></div><div id="38449920" class="c"><input type="checkbox" id="c-38449920" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38449621">parent</a><span>|</span><a href="#38450299">prev</a><span>|</span><a href="#38447450">next</a><span>|</span><label class="collapse" for="c-38449920">[-]</label><label class="expand" for="c-38449920">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just aliasing. gcc is quite bad at autovectorising in general, clang is much better.<p>Here&#x27;s a trivial algorithm that gcc borks over because &#x27;bool&#x27; is used instead of &#x27;int&#x27;, even fixing that the codegen isn&#x27;t great:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;hf7szo78E" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;hf7szo78E</a></div><br/></div></div></div></div><div id="38447450" class="c"><input type="checkbox" id="c-38447450" checked=""/><div class="controls bullet"><span class="by">janwas</span><span>|</span><a href="#38446844">parent</a><span>|</span><a href="#38449621">prev</a><span>|</span><a href="#38446944">next</a><span>|</span><label class="collapse" for="c-38447450">[-]</label><label class="expand" for="c-38447450">[1 more]</label></div><br/><div class="children"><div class="content">This happens regularly in my experience :)
Also, when using a SIMD wrapper library, it can actually be quite portable in practice.</div><br/></div></div><div id="38448022" class="c"><input type="checkbox" id="c-38448022" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#38446844">parent</a><span>|</span><a href="#38446944">prev</a><span>|</span><a href="#38444556">next</a><span>|</span><label class="collapse" for="c-38448022">[-]</label><label class="expand" for="c-38448022">[7 more]</label></div><br/><div class="children"><div class="content">There are unfortunately a lot of serial guarantees that are unavoidable even if compilers could optimize perfectly. For example: &#x27;for(double v: vec) sum+=v&#x27;<p>Floating point addition is not associative, so summing each value in order is not the same as summing every 8th element, then summing the remainder, which is how SIMD handles it. So even though this is an obvious optimization for compilers, they will prioritize the serial guarantee over the optimization unless you tell it to relax that particular guarantee.<p>It&#x27;s a mess and I agree with janwas: use a library (and in particular: use Google Highway) or something like Intel&#x27;s ISPC when your hot path needs this.</div><br/><div id="38448053" class="c"><input type="checkbox" id="c-38448053" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38448022">parent</a><span>|</span><a href="#38444556">next</a><span>|</span><label class="collapse" for="c-38448053">[-]</label><label class="expand" for="c-38448053">[6 more]</label></div><br/><div class="children"><div class="content">Hence my suggestion for language support. Add some language syntax where you can say: &quot;add these doubles, order doesn&#x27;t matter&quot;, which allows the compiler to use SIMD</div><br/><div id="38448085" class="c"><input type="checkbox" id="c-38448085" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38448053">parent</a><span>|</span><a href="#38444556">next</a><span>|</span><label class="collapse" for="c-38448085">[-]</label><label class="expand" for="c-38448085">[5 more]</label></div><br/><div class="children"><div class="content">-ffast-math if you want to push the onus on the compiler.<p>Problem is you need to enforce that requirement on all user compilations, and I don&#x27;t know what for MSVC. In-language would be nice.</div><br/><div id="38448130" class="c"><input type="checkbox" id="c-38448130" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38448085">parent</a><span>|</span><a href="#38444556">next</a><span>|</span><label class="collapse" for="c-38448130">[-]</label><label class="expand" for="c-38448130">[4 more]</label></div><br/><div class="children"><div class="content">-ffast-math is global though and can break other libraries. I mean local, vectorization compatible but portable syntax, without actually writing it (let compiler do the work)</div><br/><div id="38456295" class="c"><input type="checkbox" id="c-38456295" checked=""/><div class="controls bullet"><span class="by">singhrac</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38448130">parent</a><span>|</span><a href="#38449832">next</a><span>|</span><label class="collapse" for="c-38456295">[-]</label><label class="expand" for="c-38456295">[1 more]</label></div><br/><div class="children"><div class="content">One of the things I struggled with in Rust’s portable_simd is that I think fadd_fast and simd intrinsics don’t mix well. This makes writing dot products only ok, rather than really easy. Here’s (one) reference: <a href="https:&#x2F;&#x2F;internals.rust-lang.org&#x2F;t&#x2F;suggestion-ffastmath-intrinsics-in-stable&#x2F;14447&#x2F;31" rel="nofollow noreferrer">https:&#x2F;&#x2F;internals.rust-lang.org&#x2F;t&#x2F;suggestion-ffastmath-intri...</a></div><br/></div></div><div id="38449832" class="c"><input type="checkbox" id="c-38449832" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38448130">parent</a><span>|</span><a href="#38456295">prev</a><span>|</span><a href="#38448177">next</a><span>|</span><label class="collapse" for="c-38449832">[-]</label><label class="expand" for="c-38449832">[1 more]</label></div><br/><div class="children"><div class="content">According to <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40699071&#x2F;can-i-make-my-compiler-use-fast-math-on-a-per-function-basis" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40699071&#x2F;can-i-make-my-c...</a> you  annotate it with: __attribute__((optimize(&quot;-ffast-math&quot;)))<p>I tried it with:<p><pre><code>  double sum1(double arr[128]) {
    double tot = 0.0;
    for (int i=0; i&lt;128; i++) {
      tot += arr[i];
    }
    return tot;
  }

  __attribute__((optimize(&quot;-ffast-math&quot;)))
  double sum2(double arr[128]) {
    double tot = 0.0;
    for (int i=0; i&lt;128; i++) {
      tot += arr[i];
    }
    return tot;
  }
</code></pre>
The Compiler Explorer (gcc 13.2, --std=c++20 -march=native -O3) generates two different bodies for those:<p><pre><code>    sum1(double*):
        lea     rax, [rdi+1024]
        vxorpd  xmm0, xmm0, xmm0
    .L2:
        vaddsd  xmm0, xmm0, QWORD PTR [rdi]
        add     rdi, 32
        vaddsd  xmm0, xmm0, QWORD PTR [rdi-24]
        vaddsd  xmm0, xmm0, QWORD PTR [rdi-16]
        vaddsd  xmm0, xmm0, QWORD PTR [rdi-8]
        cmp     rax, rdi
        jne     .L2
        ret
    sum2(double*):
        lea     rax, [rdi+1024]
        vxorpd  xmm0, xmm0, xmm0
    .L6:
        vaddpd  ymm0, ymm0, YMMWORD PTR [rdi]
        add     rdi, 32
        cmp     rax, rdi
        jne     .L6
        vextractf64x2   xmm1, ymm0, 0x1
        vaddpd  xmm1, xmm1, xmm0
        vunpckhpd       xmm0, xmm1, xmm1
        vaddpd  xmm0, xmm0, xmm1
        vzeroupper
        ret
</code></pre>
It is still compiler-specific and non-portable, but at least it is not global.</div><br/></div></div><div id="38448177" class="c"><input type="checkbox" id="c-38448177" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#38446844">root</a><span>|</span><a href="#38448130">parent</a><span>|</span><a href="#38449832">prev</a><span>|</span><a href="#38444556">next</a><span>|</span><label class="collapse" for="c-38448177">[-]</label><label class="expand" for="c-38448177">[1 more]</label></div><br/><div class="children"><div class="content">Totally fair. I&#x27;m with you.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38444556" class="c"><input type="checkbox" id="c-38444556" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#38446844">prev</a><span>|</span><a href="#38444629">next</a><span>|</span><label class="collapse" for="c-38444556">[-]</label><label class="expand" for="c-38444556">[2 more]</label></div><br/><div class="children"><div class="content">Small note - while the compiler wasn&#x27;t able to optimize that specific popcount implementation to a single instruction, it can for some other implementations, though it&#x27;s of course very picky: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;T69KxWWW8" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;T69KxWWW8</a></div><br/></div></div><div id="38444629" class="c"><input type="checkbox" id="c-38444629" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#38444556">prev</a><span>|</span><a href="#38456031">next</a><span>|</span><label class="collapse" for="c-38444629">[-]</label><label class="expand" for="c-38444629">[2 more]</label></div><br/><div class="children"><div class="content">&gt; _mm256_cvtps_epu32 that represent a low-level operation in a specific instruction set (this is a float to int cast from AVX2)<p>That instruction is from AVX-512. There’s no AVX2 float to int cast. There’s in AVX1, the int is signed and the instruction is _mm256_cvtps_epi32.</div><br/><div id="38445610" class="c"><input type="checkbox" id="c-38445610" checked=""/><div class="controls bullet"><span class="by">mattsan</span><span>|</span><a href="#38444629">parent</a><span>|</span><a href="#38456031">next</a><span>|</span><label class="collapse" for="c-38445610">[-]</label><label class="expand" for="c-38445610">[1 more]</label></div><br/><div class="children"><div class="content">In Lua we have indexes off by one and in SIMD we have keyboard letters off by one</div><br/></div></div></div></div><div id="38456031" class="c"><input type="checkbox" id="c-38456031" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#38444629">prev</a><span>|</span><a href="#38443625">next</a><span>|</span><label class="collapse" for="c-38456031">[-]</label><label class="expand" for="c-38456031">[3 more]</label></div><br/><div class="children"><div class="content">ISPC is just better, compared to bolting SIMD on C++ or Rust. Also, it supports dynamic dispatching, a feature that is painful to implement yourself.</div><br/><div id="38456142" class="c"><input type="checkbox" id="c-38456142" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#38456031">parent</a><span>|</span><a href="#38443625">next</a><span>|</span><label class="collapse" for="c-38456142">[-]</label><label class="expand" for="c-38456142">[2 more]</label></div><br/><div class="children"><div class="content">Is it easy to call into ISPC from C++ and rust for small subroutines like the ones in TFA?</div><br/><div id="38456851" class="c"><input type="checkbox" id="c-38456851" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#38456031">root</a><span>|</span><a href="#38456142">parent</a><span>|</span><a href="#38443625">next</a><span>|</span><label class="collapse" for="c-38456851">[-]</label><label class="expand" for="c-38456851">[1 more]</label></div><br/><div class="children"><div class="content">Yes, extremely easy. ISPC emits objects and header files, which can be directly linked&#x2F;included from C++. Dynamic dispatching happens automatically and the widest version of the called function gets selected according to the runtime architecture.</div><br/></div></div></div></div></div></div><div id="38443625" class="c"><input type="checkbox" id="c-38443625" checked=""/><div class="controls bullet"><span class="by">uo21tp5hoyg</span><span>|</span><a href="#38456031">prev</a><span>|</span><a href="#38446120">next</a><span>|</span><label class="collapse" for="c-38443625">[-]</label><label class="expand" for="c-38443625">[6 more]</label></div><br/><div class="children"><div class="content">Wow I really like that little mini-map on the right...</div><br/><div id="38444504" class="c"><input type="checkbox" id="c-38444504" checked=""/><div class="controls bullet"><span class="by">joennlae</span><span>|</span><a href="#38443625">parent</a><span>|</span><a href="#38446120">next</a><span>|</span><label class="collapse" for="c-38444504">[-]</label><label class="expand" for="c-38444504">[5 more]</label></div><br/><div class="children"><div class="content">+1. Does someone know how to do that?</div><br/><div id="38444576" class="c"><input type="checkbox" id="c-38444576" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#38443625">root</a><span>|</span><a href="#38444504">parent</a><span>|</span><a href="#38444735">next</a><span>|</span><label class="collapse" for="c-38444576">[-]</label><label class="expand" for="c-38444576">[1 more]</label></div><br/><div class="children"><div class="content">Firefox only: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36757542">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36757542</a></div><br/></div></div><div id="38444735" class="c"><input type="checkbox" id="c-38444735" checked=""/><div class="controls bullet"><span class="by">m1el</span><span>|</span><a href="#38443625">root</a><span>|</span><a href="#38444504">parent</a><span>|</span><a href="#38444576">prev</a><span>|</span><a href="#38444793">next</a><span>|</span><label class="collapse" for="c-38444735">[-]</label><label class="expand" for="c-38444735">[1 more]</label></div><br/><div class="children"><div class="content">The minimap contains a copy of the content, but with `transform: scale`.
The rest is handling `window.onscroll` and mouse events on the overlay.</div><br/></div></div><div id="38444793" class="c"><input type="checkbox" id="c-38444793" checked=""/><div class="controls bullet"><span class="by">Klaster_1</span><span>|</span><a href="#38443625">root</a><span>|</span><a href="#38444504">parent</a><span>|</span><a href="#38444735">prev</a><span>|</span><a href="#38446120">next</a><span>|</span><label class="collapse" for="c-38444793">[-]</label><label class="expand" for="c-38444793">[2 more]</label></div><br/><div class="children"><div class="content">Found a canvas-based library for this: <a href="https:&#x2F;&#x2F;larsjung.de&#x2F;pagemap&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;larsjung.de&#x2F;pagemap&#x2F;</a>. Definitely not what OP uses, where the minimap is a shrunk copy of the content markup, with all the drawbacks, such as page search finding the same item twice.</div><br/><div id="38444838" class="c"><input type="checkbox" id="c-38444838" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#38443625">root</a><span>|</span><a href="#38444793">parent</a><span>|</span><a href="#38446120">next</a><span>|</span><label class="collapse" for="c-38444838">[-]</label><label class="expand" for="c-38444838">[1 more]</label></div><br/><div class="children"><div class="content">The author should really add at least aria-hidden=&quot;true&quot; to the minimap element.</div><br/></div></div></div></div></div></div></div></div><div id="38446120" class="c"><input type="checkbox" id="c-38446120" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#38443625">prev</a><span>|</span><a href="#38444721">next</a><span>|</span><label class="collapse" for="c-38446120">[-]</label><label class="expand" for="c-38446120">[1 more]</label></div><br/><div class="children"><div class="content">How does this compare to fastbase64[0]? Great article, I&#x27;m happy to see this sort of thing online. I wish I could share the author&#x27;s optimism about portable SIMD libraries.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;lemire&#x2F;fastbase64">https:&#x2F;&#x2F;github.com&#x2F;lemire&#x2F;fastbase64</a></div><br/></div></div><div id="38444721" class="c"><input type="checkbox" id="c-38444721" checked=""/><div class="controls bullet"><span class="by">alex_suzuki</span><span>|</span><a href="#38446120">prev</a><span>|</span><a href="#38443632">next</a><span>|</span><label class="collapse" for="c-38444721">[-]</label><label class="expand" for="c-38444721">[6 more]</label></div><br/><div class="children"><div class="content">Awesome writeup. Leaves me with the distinct impression that „I‘ll never be this smart“.</div><br/><div id="38447925" class="c"><input type="checkbox" id="c-38447925" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#38444721">parent</a><span>|</span><a href="#38445273">next</a><span>|</span><label class="collapse" for="c-38447925">[-]</label><label class="expand" for="c-38447925">[1 more]</label></div><br/><div class="children"><div class="content">Try doing AoC &#x27;23 in APL&#x2F;j&#x2F;k, BQN or Python&#x2F;numpy (meaning, not idiomatic python, but everything with numpy) or cuda etc. It&#x27;s fun and it will teach you these types of smarts; a lot of the post is very natural on how you think about solving things in those languages. After while you start seeing problems in that form.</div><br/></div></div><div id="38445273" class="c"><input type="checkbox" id="c-38445273" checked=""/><div class="controls bullet"><span class="by">hnisoss</span><span>|</span><a href="#38444721">parent</a><span>|</span><a href="#38447925">prev</a><span>|</span><a href="#38449867">next</a><span>|</span><label class="collapse" for="c-38445273">[-]</label><label class="expand" for="c-38445273">[2 more]</label></div><br/><div class="children"><div class="content">Ah, it&#x27;s just not your field of work. Just like average person is not soft.engineer or physicist or... you get the point. Few months of dedicated study and you would be able to do similar for sure.</div><br/><div id="38445821" class="c"><input type="checkbox" id="c-38445821" checked=""/><div class="controls bullet"><span class="by">VitruviusBen</span><span>|</span><a href="#38444721">root</a><span>|</span><a href="#38445273">parent</a><span>|</span><a href="#38449867">next</a><span>|</span><label class="collapse" for="c-38445821">[-]</label><label class="expand" for="c-38445821">[1 more]</label></div><br/><div class="children"><div class="content">Dunning Kruger effect?</div><br/></div></div></div></div><div id="38449867" class="c"><input type="checkbox" id="c-38449867" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#38444721">parent</a><span>|</span><a href="#38445273">prev</a><span>|</span><a href="#38445664">next</a><span>|</span><label class="collapse" for="c-38449867">[-]</label><label class="expand" for="c-38449867">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2016&#x2F;02&#x2F;05&#x2F;smart&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2016&#x2F;02&#x2F;05&#x2F;smart&#x2F;</a></div><br/></div></div><div id="38445664" class="c"><input type="checkbox" id="c-38445664" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38444721">parent</a><span>|</span><a href="#38449867">prev</a><span>|</span><a href="#38443632">next</a><span>|</span><label class="collapse" for="c-38445664">[-]</label><label class="expand" for="c-38445664">[1 more]</label></div><br/><div class="children"><div class="content">If you ever had occasion to have an employer and&#x2F;or project where this was called for, you could probably &quot;be this smart&quot;; it just comes down to interest and necessity.<p>I dip in and out of these waters (performance optimization, more systems bare metal engineering), but basically on personal projects. I wish I had jobs where it was more called for, but it&#x27;s not what most industry work needs.</div><br/></div></div></div></div><div id="38443632" class="c"><input type="checkbox" id="c-38443632" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#38444721">prev</a><span>|</span><a href="#38443484">next</a><span>|</span><label class="collapse" for="c-38443632">[-]</label><label class="expand" for="c-38443632">[10 more]</label></div><br/><div class="children"><div class="content">Interesting article! Right at the start, the first example of a non-vectorized popcnt implementation is said to produce “comically bad code, frankly”, but in release mode with the native target CPU, it does appear to be vectorising the function fairly ok?<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;WE1Eq65jY" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;WE1Eq65jY</a></div><br/><div id="38443744" class="c"><input type="checkbox" id="c-38443744" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38443632">parent</a><span>|</span><a href="#38444013">next</a><span>|</span><label class="collapse" for="c-38443744">[-]</label><label class="expand" for="c-38443744">[2 more]</label></div><br/><div class="children"><div class="content">I mean ideally you’d probably want this to be lowered to a popcnt instruction.</div><br/><div id="38443835" class="c"><input type="checkbox" id="c-38443835" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#38443632">root</a><span>|</span><a href="#38443744">parent</a><span>|</span><a href="#38444013">next</a><span>|</span><label class="collapse" for="c-38443835">[-]</label><label class="expand" for="c-38443835">[1 more]</label></div><br/><div class="children"><div class="content">Yes, just because you see SIMD instructions doesn&#x27;t mean the code is fast. You need the correct instructions.<p>Not relevant to this example, which is `popcount`ing only a single number, but AVX512 did also introduce SIMD popcount instructions for getting many inputs at a time. Also true for other useful bit-funs like leading or trailing zeros.
So if you&#x27;re using zmm registers, you can do way better than that godbolt example.</div><br/></div></div></div></div><div id="38444013" class="c"><input type="checkbox" id="c-38444013" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#38443632">parent</a><span>|</span><a href="#38443744">prev</a><span>|</span><a href="#38448998">next</a><span>|</span><label class="collapse" for="c-38444013">[-]</label><label class="expand" for="c-38444013">[6 more]</label></div><br/><div class="children"><div class="content">The following should produce equivalent output:<p><pre><code>  pub fn popcnt(mut x: u32) -&gt; u32 {
    x.count_ones()
  }
</code></pre>
which gets compiled to:<p><pre><code>  example::popcnt:
        popcnt  eax, edi
        ret
</code></pre>
For large bit vectors, an AVX2 implementation can outperform POPCNT. See &quot;Faster Population Counts Using AVX2 Instructions&quot; at <a href="https:&#x2F;&#x2F;academic.oup.com&#x2F;comjnl&#x2F;article&#x2F;61&#x2F;1&#x2F;111&#x2F;3852071" rel="nofollow noreferrer">https:&#x2F;&#x2F;academic.oup.com&#x2F;comjnl&#x2F;article&#x2F;61&#x2F;1&#x2F;111&#x2F;3852071</a><p>32 bits is not large enough, and the code Rust produces is indeed comically bad.</div><br/><div id="38456956" class="c"><input type="checkbox" id="c-38456956" checked=""/><div class="controls bullet"><span class="by">rwaksmunski</span><span>|</span><a href="#38443632">root</a><span>|</span><a href="#38444013">parent</a><span>|</span><a href="#38444217">next</a><span>|</span><label class="collapse" for="c-38456956">[-]</label><label class="expand" for="c-38456956">[1 more]</label></div><br/><div class="children"><div class="content">TIL: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.usize.html#method.count_ones" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.usize.html#method.co...</a></div><br/></div></div><div id="38444217" class="c"><input type="checkbox" id="c-38444217" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#38443632">root</a><span>|</span><a href="#38444013">parent</a><span>|</span><a href="#38456956">prev</a><span>|</span><a href="#38448998">next</a><span>|</span><label class="collapse" for="c-38444217">[-]</label><label class="expand" for="c-38444217">[4 more]</label></div><br/><div class="children"><div class="content">Would the equivalent c++ code run through LLVM generate a different output?</div><br/><div id="38444290" class="c"><input type="checkbox" id="c-38444290" checked=""/><div class="controls bullet"><span class="by">asb</span><span>|</span><a href="#38443632">root</a><span>|</span><a href="#38444217">parent</a><span>|</span><a href="#38448998">next</a><span>|</span><label class="collapse" for="c-38444290">[-]</label><label class="expand" for="c-38444290">[3 more]</label></div><br/><div class="children"><div class="content">LLVM has a LoopIdiomRecognize pass which will, amongst other patterns, try to detect a loop implementing popcount [1] and convert it to the llvm.ctpop.* intrinsic [2]. I&#x27;ve not looked at why it&#x27;s not matching this loop, but the sibling comment suggesting to just use `.count_ones` seems like the right answer for Rust. In C or C++ I&#x27;d strongly recommend using `__builtin_popcount` (provided by both Clang and GCC).<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;08a6968127f04a40d767bf3fe296bc36667c89eb&#x2F;llvm&#x2F;lib&#x2F;Transforms&#x2F;Scalar&#x2F;LoopIdiomRecognize.cpp#L1557">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;blob&#x2F;08a6968127f04a40d7...</a>
[2]: <a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#llvm-ctpop-intrinsic" rel="nofollow noreferrer">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#llvm-ctpop-intrinsic</a></div><br/><div id="38446947" class="c"><input type="checkbox" id="c-38446947" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#38443632">root</a><span>|</span><a href="#38444290">parent</a><span>|</span><a href="#38448998">next</a><span>|</span><label class="collapse" for="c-38446947">[-]</label><label class="expand" for="c-38446947">[2 more]</label></div><br/><div class="children"><div class="content">`std::popcount` was added to the stl in C++20 <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;numeric&#x2F;popcount" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;numeric&#x2F;popcount</a></div><br/><div id="38448411" class="c"><input type="checkbox" id="c-38448411" checked=""/><div class="controls bullet"><span class="by">asb</span><span>|</span><a href="#38443632">root</a><span>|</span><a href="#38446947">parent</a><span>|</span><a href="#38448998">next</a><span>|</span><label class="collapse" for="c-38448411">[-]</label><label class="expand" for="c-38448411">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for pointing that out - definitely a better choice for C++.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38448998" class="c"><input type="checkbox" id="c-38448998" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#38443632">parent</a><span>|</span><a href="#38444013">prev</a><span>|</span><a href="#38443484">next</a><span>|</span><label class="collapse" for="c-38448998">[-]</label><label class="expand" for="c-38448998">[1 more]</label></div><br/><div class="children"><div class="content">autovectorization is hit and miss. I recently wrote this which has to count the bits in a result mask of vector operations and it turns into popcnt just fine.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;zT9Whcnco" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;zT9Whcnco</a></div><br/></div></div></div></div><div id="38443484" class="c"><input type="checkbox" id="c-38443484" checked=""/><div class="controls bullet"><span class="by">gbin</span><span>|</span><a href="#38443632">prev</a><span>|</span><a href="#38450281">next</a><span>|</span><label class="collapse" for="c-38443484">[-]</label><label class="expand" for="c-38443484">[2 more]</label></div><br/><div class="children"><div class="content">This is a pretty good trial for Rust Simd! What were the most surprising quirks of it when you inspected the generated code?</div><br/><div id="38445184" class="c"><input type="checkbox" id="c-38445184" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#38443484">parent</a><span>|</span><a href="#38450281">next</a><span>|</span><label class="collapse" for="c-38445184">[-]</label><label class="expand" for="c-38445184">[1 more]</label></div><br/><div class="children"><div class="content">Not OP, but one thing that surprised me was if you are doing rust Simd in a library, and part of the code is marked #[inline] but others are not you might see catastrophic performance regressions. We saw an issue where the SIMD version was over 10x slower because we missed marking one function as inline. Essentially rustc converted it from an intrinsic to a regular function call.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;107617#issuecomment-1422000166">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;107617#issuecomment...</a></div><br/></div></div></div></div><div id="38450281" class="c"><input type="checkbox" id="c-38450281" checked=""/><div class="controls bullet"><span class="by">intalentive</span><span>|</span><a href="#38443484">prev</a><span>|</span><a href="#38446711">next</a><span>|</span><label class="collapse" for="c-38450281">[-]</label><label class="expand" for="c-38450281">[3 more]</label></div><br/><div class="children"><div class="content">SIMD is pretty intuitive if you’ve used deep learning libraries, NumPy, array based or even functional languages</div><br/><div id="38450374" class="c"><input type="checkbox" id="c-38450374" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38450281">parent</a><span>|</span><a href="#38446711">next</a><span>|</span><label class="collapse" for="c-38450374">[-]</label><label class="expand" for="c-38450374">[2 more]</label></div><br/><div class="children"><div class="content">NumPy roadmap: 
<a href="https:&#x2F;&#x2F;numpy.org&#x2F;neps&#x2F;roadmap.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;numpy.org&#x2F;neps&#x2F;roadmap.html</a> :<p>&gt; <i>Improvements to NumPy’s performance are important to many users. We have focused this effort on Universal SIMD (see NEP 38 — Using SIMD optimization instructions for performance) intrinsics which provide nice improvements across various hardware platforms via an abstraction layer. The infrastructure is in place, and we welcome follow-on PRs to add SIMD support across all relevant NumPy functions</i><p>&quot;NEP 38 — Using SIMD optimization instructions for performance&quot; (2019) 
<a href="https:&#x2F;&#x2F;numpy.org&#x2F;neps&#x2F;nep-0038-SIMD-optimizations.html#nep38" rel="nofollow noreferrer">https:&#x2F;&#x2F;numpy.org&#x2F;neps&#x2F;nep-0038-SIMD-optimizations.html#nep3...</a><p>NumPy docs &gt; CPU&#x2F;SIMD Optimizations: 
<a href="https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;reference&#x2F;simd&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;reference&#x2F;simd&#x2F;index.html</a><p>std::simd: 
<a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;simd&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;simd&#x2F;index.html</a><p>&quot;Show HN: SimSIMD vs SciPy: How AVX-512 and SVE make SIMD nicer and ML 10x faster&quot; (2023-10) 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37808036">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37808036</a><p>&quot;Standard library support for SIMD&quot; (2023-10)  
<a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;standard-library-support-for-simd&#x2F;35138" rel="nofollow noreferrer">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;standard-library-support-for-si...</a></div><br/><div id="38455308" class="c"><input type="checkbox" id="c-38455308" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38450281">root</a><span>|</span><a href="#38450374">parent</a><span>|</span><a href="#38446711">next</a><span>|</span><label class="collapse" for="c-38455308">[-]</label><label class="expand" for="c-38455308">[1 more]</label></div><br/><div class="children"><div class="content">Automatic vectorization &gt; Techniques: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Automatic_vectorization#Techniques" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Automatic_vectorization#Techni...</a><p>SIMD: Single instruction, multiple data: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Single_instruction,_multiple_data" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Single_instruction,_multiple_d...</a><p>Category:SIMD computing: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Category:SIMD_computing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Category:SIMD_computing</a><p>Vectorization: Introduction: 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36159017">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36159017</a> :<p>&gt; <i>GPGPU &gt; Vectorization, Stream Processing &gt; Compute kernels: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;General-purpose_computing_on_graphics_processing_units#Vectorization" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;General-purpose_computing_on_g...</a> </i></div><br/></div></div></div></div></div></div><div id="38446711" class="c"><input type="checkbox" id="c-38446711" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38450281">prev</a><span>|</span><a href="#38446612">next</a><span>|</span><label class="collapse" for="c-38446711">[-]</label><label class="expand" for="c-38446711">[1 more]</label></div><br/><div class="children"><div class="content">the minimap on this page is so cool</div><br/></div></div></div></div></div></div></div></body></html>