<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706432456069" as="style"/><link rel="stylesheet" href="styles.css?v=1706432456069"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://typing.readthedocs.io/en/latest/source/typing_anti_pitch.html">Reasons to avoid static type checking</a> <span class="domain">(<a href="https://typing.readthedocs.io">typing.readthedocs.io</a>)</span></div><div class="subtext"><span>samwho</span> | <span>35 comments</span></div><br/><div><div id="39163295" class="c"><input type="checkbox" id="c-39163295" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39163209">next</a><span>|</span><label class="collapse" for="c-39163295">[-]</label><label class="expand" for="c-39163295">[7 more]</label></div><br/><div class="children"><div class="content">I’ve written a <i>lot</i> of production Python and also a <i>lot</i> of thoroughly and rigorously statically typed code in C++. I use both regularly but there are clear tradeoffs in this regard. The main reason to avoid static type checking is that the programming language makes it difficult to do it effectively due to trading it away for other benefits. This does not change the intrinsic value of static type checking.<p>Python works great for cases where the scope of a particular function is tightly constrained around a tightly constrained set of inputs. In this scenario, it is relatively easy to test fitness for purpose, and that testing can replace static type checking as a practical matter. Many bugs sneak through in Python that C++ would find at compile-time, but that’s okay because the domain is so narrow that you can squeeze them out in testing with minimal overhead.<p>The minute you start trying to build a more generalized library of functionality in Python, the combinatorial bug factory starts to become a major drag. While you can add type checking, it is clumsy, slow, and less thorough in practice than you would expect with C++. Python is not designed to provide the degree of static type checking something like C++ can. Many types of code benefit from thorough static type checking, and for those use cases something like Python has a high cost.<p>This is fine. I understand the problems for which both languages are best suited. Right tool for the job and all that. Static type checking is generally beneficial in software but it isn’t always worth paying the tariff if the problem domain is narrow enough. It is quite possible to overfit static type checking to simple cases that don’t justify the effort.</div><br/><div id="39163496" class="c"><input type="checkbox" id="c-39163496" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#39163295">parent</a><span>|</span><a href="#39163318">next</a><span>|</span><label class="collapse" for="c-39163496">[-]</label><label class="expand" for="c-39163496">[3 more]</label></div><br/><div class="children"><div class="content">I’d probably agree with you 5 years ago, but in those 5 years typescript has shown that you can take a completely dynamic language, add a very powerful and well thought out type system and the resulting language is so much better for non-trivial projects.<p>So if you ask me, who has been programming Python since before new-style classes, if types make sense for Python, the answer is a resounding ‘yes’: just steal as much typescript typing as possible.</div><br/><div id="39163693" class="c"><input type="checkbox" id="c-39163693" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#39163295">root</a><span>|</span><a href="#39163496">parent</a><span>|</span><a href="#39163564">next</a><span>|</span><label class="collapse" for="c-39163693">[-]</label><label class="expand" for="c-39163693">[1 more]</label></div><br/><div class="children"><div class="content">I wish we&#x27;d steal more. TS type systel and syntax is much better that what we have.<p>And I hope one day iter[] and callable[] will be made available, cause importing typing sucks.</div><br/></div></div><div id="39163564" class="c"><input type="checkbox" id="c-39163564" checked=""/><div class="controls bullet"><span class="by">LarsDu88</span><span>|</span><a href="#39163295">root</a><span>|</span><a href="#39163496">parent</a><span>|</span><a href="#39163693">prev</a><span>|</span><a href="#39163318">next</a><span>|</span><label class="collapse" for="c-39163564">[-]</label><label class="expand" for="c-39163564">[1 more]</label></div><br/><div class="children"><div class="content">And not only that, but you can take that statically typed code and build JIT compilers on top of them</div><br/></div></div></div></div><div id="39163318" class="c"><input type="checkbox" id="c-39163318" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#39163295">parent</a><span>|</span><a href="#39163496">prev</a><span>|</span><a href="#39163209">next</a><span>|</span><label class="collapse" for="c-39163318">[-]</label><label class="expand" for="c-39163318">[3 more]</label></div><br/><div class="children"><div class="content">Yes. Great to read this type of nuanced comment. This nails it. Sometimes components are generic enough that type checking does not add any value. Type checking is useful when you want to frame your logic in terms of your business domain. But you don&#x27;t want your business domain to leak into low level reusable components. Why constrain them to a specific domain when they could suit multiple domains without any effort.<p>Just think of a function which generates a random number for a lottery app. Do you want to call the function &#x27;generateRandomNumber&#x27; or &#x27;generateLotteryNumber&#x27;? There is no reason to constrain your function to the &#x27;lottery&#x27; use case when it could also serve an infinite number of other use cases.<p>The function which is used as a dependency shouldn&#x27;t concern itself with the specific business case towards which it will be applied.<p>As you move towards the leaves of the dependency hierarchy, the abstraction becomes more about technology and less about business domain.</div><br/><div id="39163390" class="c"><input type="checkbox" id="c-39163390" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#39163295">root</a><span>|</span><a href="#39163318">parent</a><span>|</span><a href="#39163209">next</a><span>|</span><label class="collapse" for="c-39163390">[-]</label><label class="expand" for="c-39163390">[2 more]</label></div><br/><div class="children"><div class="content">I don’t quite follow here - you can still declare interfaces (Protocol) to declare what behavior your code needs.</div><br/><div id="39163422" class="c"><input type="checkbox" id="c-39163422" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#39163295">root</a><span>|</span><a href="#39163390">parent</a><span>|</span><a href="#39163209">next</a><span>|</span><label class="collapse" for="c-39163422">[-]</label><label class="expand" for="c-39163422">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t work very well for generic concepts. For example, let&#x27;s say I have a dependency which exposes a function which takes a URLDefinition as an argument.<p>Maybe the dependent logic already has a similar type to represent URLs but maybe it&#x27;s called URLInfo... The property names might be slightly different. Maybe URLInfo has a Host and Port property starting with capital letters but URLDefinition properties are all lower case.<p>IMO, this is a huge mistake. URLs should simply be treated as plain strings that way you don&#x27;t need to worry about unnecessary interface mismatches. Inventing complex interfaces instead of just representing concepts as primitives  adds unnecessary friction.</div><br/></div></div></div></div></div></div></div></div><div id="39163209" class="c"><input type="checkbox" id="c-39163209" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#39163295">prev</a><span>|</span><a href="#39163416">next</a><span>|</span><label class="collapse" for="c-39163209">[-]</label><label class="expand" for="c-39163209">[3 more]</label></div><br/><div class="children"><div class="content">Scepticism is warranted for partial type checking. Something I&#x27;ve noticed in partially-typed situations is they are the worst of all worlds. The type checker soaks up a lot of time, but the silly bugs that type checking would have caught still get through. Having 1 library that doesn&#x27;t support type hints is a major problem if I&#x27;m trying to use a type checker.<p>Therefore, I think &quot;... the authors have no desire to ever make type hints mandatory, even by convention.&quot; is useless. I&#x27;m sure the authors are honest about their desires, but frankly either everything gets type checked or practically nothing does. It is unlikely that there is a social equilibrium where some things get checked and some do not. Not only that, but clever libraries that aren&#x27;t written with type checking in mind are often a devil to hint retroactively.</div><br/><div id="39163313" class="c"><input type="checkbox" id="c-39163313" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39163209">parent</a><span>|</span><a href="#39163246">next</a><span>|</span><label class="collapse" for="c-39163313">[-]</label><label class="expand" for="c-39163313">[1 more]</label></div><br/><div class="children"><div class="content">Strong agree that half-assed type checking is the worst of both worlds. Most of the effort of real type checking but only a fraction of the real-world benefit.</div><br/></div></div><div id="39163246" class="c"><input type="checkbox" id="c-39163246" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#39163209">parent</a><span>|</span><a href="#39163313">prev</a><span>|</span><a href="#39163416">next</a><span>|</span><label class="collapse" for="c-39163246">[-]</label><label class="expand" for="c-39163246">[1 more]</label></div><br/><div class="children"><div class="content">I think there is a big difference in what we type-check. The interfaces of public methods should be declared and type-checked. What happens inside a function not so much.</div><br/></div></div></div></div><div id="39163416" class="c"><input type="checkbox" id="c-39163416" checked=""/><div class="controls bullet"><span class="by">arialdomartini</span><span>|</span><a href="#39163209">prev</a><span>|</span><a href="#39163216">next</a><span>|</span><label class="collapse" for="c-39163416">[-]</label><label class="expand" for="c-39163416">[1 more]</label></div><br/><div class="children"><div class="content">The wrong assumption in that page is that Static Typing implies the need for type hints or annotations.<p>In fact, type inference is a thing.<p>Most of the languages with Hindley Millner type system (such as oCaml, F#, Haskell, PureScript) do feel dynamic (e.g., developer does not need to hint the compiler) yet they are purely static typed.<p>What is the argument against having Python checking the types, without asking the developers to change their code?</div><br/></div></div><div id="39163216" class="c"><input type="checkbox" id="c-39163216" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#39163416">prev</a><span>|</span><a href="#39162711">next</a><span>|</span><label class="collapse" for="c-39163216">[-]</label><label class="expand" for="c-39163216">[6 more]</label></div><br/><div class="children"><div class="content">Personal opinion here but I’d put TypeScript in the S-tier for “static typing overall enjoyable-ness,” Java in D-tier and it pains me to say Python in F-tier.</div><br/><div id="39163374" class="c"><input type="checkbox" id="c-39163374" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#39163216">parent</a><span>|</span><a href="#39163227">next</a><span>|</span><label class="collapse" for="c-39163374">[-]</label><label class="expand" for="c-39163374">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve recently removed type checking in a Python project because it was causing more false positives than true positives, and working around the type checker&#x27;s complaints was just getting too tedious.<p>I&#x27;m a big fan of type checking in general, and Typescript is a great example of a type checker that allows you to statically define all the dynamic idioms that you&#x27;d normally use. But for various reasons, that just doesn&#x27;t seem to have happened in the Python ecosystem. Instead, you can either write normal dynamic Python without types, or you can restrict yourself to a vaguely Java-like subset of Python with hard-to-use generics and confusing rules about forward references.<p>I wonder if it would have been better to have taken the Typescript approach and have Mypy and all its annotations developed as a separate language, rather than as part of the Python language, with the expectation that they could eventually be merged at some point. As it is, it feels like both sides have been very constrained: Mypy has struggled to innovate on expressive type-level syntax because it only operates on standard Python code, and Python has struggled with balancing the various goals that different groups have for youry annotations.<p>The result is a kind of mess where it&#x27;s still painful to type basic things like generics (yes, that&#x27;s changing, but not if you need to support older Python versions), but you also have weird syntax that requires type annotations, even if they&#x27;re meaningless (like with dataclasses).</div><br/></div></div><div id="39163227" class="c"><input type="checkbox" id="c-39163227" checked=""/><div class="controls bullet"><span class="by">th0ma5</span><span>|</span><a href="#39163216">parent</a><span>|</span><a href="#39163374">prev</a><span>|</span><a href="#39163486">next</a><span>|</span><label class="collapse" for="c-39163227">[-]</label><label class="expand" for="c-39163227">[2 more]</label></div><br/><div class="children"><div class="content">Are those tiers good or bad? What is the order?</div><br/><div id="39163235" class="c"><input type="checkbox" id="c-39163235" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#39163216">root</a><span>|</span><a href="#39163227">parent</a><span>|</span><a href="#39163486">next</a><span>|</span><label class="collapse" for="c-39163235">[-]</label><label class="expand" for="c-39163235">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tier_list" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tier_list</a></div><br/></div></div></div></div><div id="39163486" class="c"><input type="checkbox" id="c-39163486" checked=""/><div class="controls bullet"><span class="by">BigJono</span><span>|</span><a href="#39163216">parent</a><span>|</span><a href="#39163227">prev</a><span>|</span><a href="#39162711">next</a><span>|</span><label class="collapse" for="c-39163486">[-]</label><label class="expand" for="c-39163486">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how you can put TS in the S-tier when the community is hell bent on making every codebase as unreadable and complicated as possible.</div><br/><div id="39163726" class="c"><input type="checkbox" id="c-39163726" checked=""/><div class="controls bullet"><span class="by">petesergeant</span><span>|</span><a href="#39163216">root</a><span>|</span><a href="#39163486">parent</a><span>|</span><a href="#39162711">next</a><span>|</span><label class="collapse" for="c-39163726">[-]</label><label class="expand" for="c-39163726">[1 more]</label></div><br/><div class="children"><div class="content">&gt; when the community is hell bent on making every codebase as unreadable and complicated as possible<p>I don’t understand what you’re getting at, but clearly you’re expressing some pain here: what are some examples?</div><br/></div></div></div></div></div></div><div id="39162711" class="c"><input type="checkbox" id="c-39162711" checked=""/><div class="controls bullet"><span class="by">luhg</span><span>|</span><a href="#39163216">prev</a><span>|</span><a href="#39163505">next</a><span>|</span><label class="collapse" for="c-39162711">[-]</label><label class="expand" for="c-39162711">[3 more]</label></div><br/><div class="children"><div class="content">Feels like a bunch of BS excuses.</div><br/><div id="39163073" class="c"><input type="checkbox" id="c-39163073" checked=""/><div class="controls bullet"><span class="by">BenoitP</span><span>|</span><a href="#39162711">parent</a><span>|</span><a href="#39163057">next</a><span>|</span><label class="collapse" for="c-39163073">[-]</label><label class="expand" for="c-39163073">[1 more]</label></div><br/><div class="children"><div class="content">Yeah the formulation is quite biased, but to some extent there is some truth in the statements:<p>&gt; Your codebase is old, large and has been working fine without static type checking for years. While Python’s type system is designed to allow gradual adoption of static type checking, the total cost of adding type annotations to a large extant codebase can be prohibitive.<p>That&#x27;s a convoluted and quite dishonest way of warning that you&#x27;re trapped if you don&#x27;t enforce types from the start; but it does have the merit of being on the list.</div><br/></div></div><div id="39163057" class="c"><input type="checkbox" id="c-39163057" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#39162711">parent</a><span>|</span><a href="#39163073">prev</a><span>|</span><a href="#39163505">next</a><span>|</span><label class="collapse" for="c-39163057">[-]</label><label class="expand" for="c-39163057">[1 more]</label></div><br/><div class="children"><div class="content">Which is great as it documents that there aren&#x27;t any real ones.</div><br/></div></div></div></div><div id="39163505" class="c"><input type="checkbox" id="c-39163505" checked=""/><div class="controls bullet"><span class="by">rich_sasha</span><span>|</span><a href="#39162711">prev</a><span>|</span><a href="#39163038">next</a><span>|</span><label class="collapse" for="c-39163505">[-]</label><label class="expand" for="c-39163505">[2 more]</label></div><br/><div class="children"><div class="content">There are cars and motorbikes, and many other things. They have different benefits and costs.<p>Python is a motorbike. It is small, convenient, nippy, fuel-efficient. It is also terribly unsafe, holds no luggage and no protection from the weather.<p>Statically-typed languages are cars. Stable, safe, predictable, require a lot of infrequent maintenance, weather-proof. Not convenient in heavy traffic, but hey, you put on the heater seats and the stereo and you don&#x27;t mind queuing.<p>Now, I find the effort to add typing to Python like trying to make the motorbike safe. You double the wheels to have a full 4-wheel vehicle, add a roof and windshield... And you end up with something that has th upsides of neither a car nor a motorbike.<p>Where people find it convenient, sure. But the evangelism of &quot;types everywhere&quot; seems to not get it.</div><br/><div id="39163735" class="c"><input type="checkbox" id="c-39163735" checked=""/><div class="controls bullet"><span class="by">petesergeant</span><span>|</span><a href="#39163505">parent</a><span>|</span><a href="#39163038">next</a><span>|</span><label class="collapse" for="c-39163735">[-]</label><label class="expand" for="c-39163735">[1 more]</label></div><br/><div class="children"><div class="content">To steal someone else’s comment from above, I feel like TypeScript has disproved this, and that you lose almost nothing and gain a huge amount with a high-quality optional typing system</div><br/></div></div></div></div><div id="39163038" class="c"><input type="checkbox" id="c-39163038" checked=""/><div class="controls bullet"><span class="by">nmca</span><span>|</span><a href="#39163505">prev</a><span>|</span><a href="#39162954">next</a><span>|</span><label class="collapse" for="c-39163038">[-]</label><label class="expand" for="c-39163038">[3 more]</label></div><br/><div class="children"><div class="content">I eagerly await ruff-but-for-type-checking. Python type checkers are all excruciatingly slow at the moment.</div><br/><div id="39163151" class="c"><input type="checkbox" id="c-39163151" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#39163038">parent</a><span>|</span><a href="#39163523">next</a><span>|</span><label class="collapse" for="c-39163151">[-]</label><label class="expand" for="c-39163151">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Speed is one factor, but also standardisation.<p>I’ve always been using mypy, but heard good things about pyright. It’s what VSCode uses by default as well, unless you jump through hoops. So I have pyright in the IDE and mypy everywhere else, yet they don’t agree with one another in various cases. Exhaustiveness checking and type inference in structural pattern matching, and async TaskGroups are some examples. One of my code bases has mixed “type: ignore” and “pyright: ignore” (forget the exact syntax) for that reason. Pretty bizarre and not something you’d see in any other language!<p>I wonder why mypy isn’t the blessed standard and pyright was able to catch up on (and in parts overtake) it. Mypy had a large head start and enjoys tons of development effort. Good job to Microsoft I suppose?</div><br/></div></div><div id="39163523" class="c"><input type="checkbox" id="c-39163523" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#39163038">parent</a><span>|</span><a href="#39163151">prev</a><span>|</span><a href="#39162954">next</a><span>|</span><label class="collapse" for="c-39163523">[-]</label><label class="expand" for="c-39163523">[1 more]</label></div><br/><div class="children"><div class="content">Use dmypy - the daemon version of mypy (installed when you install mypy) that runs 10x the speed for local edits&#x2F;changes.<p><a href="https:&#x2F;&#x2F;mypy.readthedocs.io&#x2F;en&#x2F;stable&#x2F;mypy_daemon.html" rel="nofollow">https:&#x2F;&#x2F;mypy.readthedocs.io&#x2F;en&#x2F;stable&#x2F;mypy_daemon.html</a><p>(But I also await ruff type checking)</div><br/></div></div></div></div><div id="39162954" class="c"><input type="checkbox" id="c-39162954" checked=""/><div class="controls bullet"><span class="by">typechksux</span><span>|</span><a href="#39163038">prev</a><span>|</span><a href="#39163297">next</a><span>|</span><label class="collapse" for="c-39162954">[-]</label><label class="expand" for="c-39162954">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Pleasing static type checkers requires a non-zero amount of busy work<p>Heck yeah! Why would I want to find problems ahead of time when the whole thing could blow up at runtime with cryptic errors. Or better yet, no errors because I’m such a ducking elite programmer that I never make mistakes. Read the code. The code don’t lie!<p>This is a lame, low effort blog post. Jesus Christ.</div><br/></div></div><div id="39163297" class="c"><input type="checkbox" id="c-39163297" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#39162954">prev</a><span>|</span><a href="#39162660">next</a><span>|</span><label class="collapse" for="c-39163297">[-]</label><label class="expand" for="c-39163297">[4 more]</label></div><br/><div class="children"><div class="content">Personally, I don&#x27;t use type checking because the benefits are extremely marginal given how I write software.<p>- I avoid complex function&#x2F;method interfaces. My coding philosophy revolves around relying on simple primitives as arguments and return values and keep complex state fully encapsulated.<p>- I use a TDD e2e approach which gives me excellent code coverage and catches &#x27;type mismatches&#x27; early as such issues cause functionality problems that are caught in my tests. Type checking is redundant.<p>- My software is made up of small modules. The lower level modules are generic enough that it doesn&#x27;t make sense to restrict to specific types or assume a specific business domain.<p>At a psychological level, I find that type checking tends to encourage developers to design complex function&#x2F;method interfaces which lead to worse, harder to maintain software and encourages leaky abstractions and passing around &#x27;live instances&#x27;. It encourages developers to add unnecessary constraints which make low level modules less versatile and cover fewer use cases than they could otherwise have.<p>Interface names of low level modules often end up unnecessarily referencing the specific business domain which should be a higher level concern.</div><br/><div id="39163405" class="c"><input type="checkbox" id="c-39163405" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#39163297">parent</a><span>|</span><a href="#39162660">next</a><span>|</span><label class="collapse" for="c-39163405">[-]</label><label class="expand" for="c-39163405">[3 more]</label></div><br/><div class="children"><div class="content">Thats what I call &quot;Uncle Bobs ossification disease&quot; where you spend too much time on process and not enough on getting shit done.
Because you break everything up stuff just piles up and makes it harder to change things, everything is intertwined through (often unwarranted) reuse and even the non-reused stuff is smeared over a dozen and dozen of functions that are used only at a single call site.
But wait there&#x27;s more, for every of these functions theres half a dozen tests that ossify some implementation detail (because function boundaries are no longer meaningful).<p>You end up with thousands of lines of code that do very little except for being the physical incarnation of &quot;the process&quot; god.<p>That stuff is so 2000.<p>Type systems give you robustness and whole program consistency proofs without a single line of extra code. No manually writing tests to ensure type safety and you get help writing semantically meaningfull functions, instead of whole object graphs that need to be called in a complex dance just to avoid having 4 function arguments.</div><br/><div id="39163448" class="c"><input type="checkbox" id="c-39163448" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#39163297">root</a><span>|</span><a href="#39163405">parent</a><span>|</span><a href="#39162660">next</a><span>|</span><label class="collapse" for="c-39163448">[-]</label><label class="expand" for="c-39163448">[2 more]</label></div><br/><div class="children"><div class="content">If you saw how little code my projects require, you would realize that this is incorrect.<p>I&#x27;ve built a decentralized cryptocurrency exchange that can work with most blockchains in just 5000 lines of code. Has been running for 4 years with zero bugs.<p>I&#x27;ve written a cryptocurrency from scratch with only about 4000 lines of code and have not had any bug reported after 3 years of continuous operation. On the other hand, projects like Bitcoin and Ethereum are hundreds of thousands of lines.<p>I&#x27;ve also written a no-code platform in less than 4k lines of code which supports complex views with real time updates, pagination, indexing, access control, multi-tenancy and has been bug-free since it launched. I built the whole thing in about 3 months part time.<p>All of these built with plain JavaScript&#x2F;Node.js. I can support all of these projects in parallel because I rarely need to update them.</div><br/><div id="39163587" class="c"><input type="checkbox" id="c-39163587" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#39163297">root</a><span>|</span><a href="#39163448">parent</a><span>|</span><a href="#39162660">next</a><span>|</span><label class="collapse" for="c-39163587">[-]</label><label class="expand" for="c-39163587">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I rarely need to update them.<p>Not really a good project to measure ossification on then.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>