<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695978061139" as="style"/><link rel="stylesheet" href="styles.css?v=1695978061139"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://swiftrocks.com/how-async-await-works-internally-in-swift">How async/await works internally in Swift</a> <span class="domain">(<a href="https://swiftrocks.com">swiftrocks.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>26 comments</span></div><br/><div><div id="37700349" class="c"><input type="checkbox" id="c-37700349" checked=""/><div class="controls bullet"><span class="by">novok</span><span>|</span><a href="#37699098">next</a><span>|</span><label class="collapse" for="c-37700349">[-]</label><label class="expand" for="c-37700349">[5 more]</label></div><br/><div class="children"><div class="content">Swift async&#x2F;await is such a foot gun that induces deadlock over deadlock, and whats even worse, deadlocks the entire app so you cannot report and  notice this deadlock state in the app itself, which makes you blind.  I almost never had this problem with dispatch, you could fairly reliably guarantee and reason about some backup queues being able to detect these states and report the deadlock state.<p>IMO I would recommend not interacting with async&#x2F;await as much as possible and stick to dispatch queues you can reason about far more easily.</div><br/><div id="37700900" class="c"><input type="checkbox" id="c-37700900" checked=""/><div class="controls bullet"><span class="by">tcldr</span><span>|</span><a href="#37700349">parent</a><span>|</span><a href="#37700589">next</a><span>|</span><label class="collapse" for="c-37700900">[-]</label><label class="expand" for="c-37700900">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re doing to get into deadlocks, but when used as prescribed, I personally haven&#x27;t run in to these issues.<p>Swift concurrency is still in a transitory period, and with that comes some warnings about how you can mix it with legacy concurrency primitives. i.e. not holding a lock across Task boundaries.<p>However, it&#x27;s fairly well documented. There&#x27;s a talk &#x27;Swift concurrency: Behind the scenes&#x27; [1], that goes into detail on this. View from around the 25 min mark.<p>[1] <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;wwdc21&#x2F;10254?time=1614" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.apple.com&#x2F;wwdc21&#x2F;10254?time=1614</a></div><br/></div></div><div id="37700589" class="c"><input type="checkbox" id="c-37700589" checked=""/><div class="controls bullet"><span class="by">andreasley</span><span>|</span><a href="#37700349">parent</a><span>|</span><a href="#37700900">prev</a><span>|</span><a href="#37700765">next</a><span>|</span><label class="collapse" for="c-37700589">[-]</label><label class="expand" for="c-37700589">[1 more]</label></div><br/><div class="children"><div class="content">Do you happen to have some links to information about the issues you mentioned?<p>Swift async&#x2F;await has worked excellently for me so far. The biggest issue is that most libraries aren&#x27;t updated to use it (and sometimes couldn&#x27;t be, because they require Custom Actor Executors, which weren&#x27;t available until Swift 5.9).<p>I found the following video helpful to better understand Swift async&#x2F;await:
&quot;Swift concurrency: Behind the scenes&quot; <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;videos&#x2F;play&#x2F;wwdc2021&#x2F;10254" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.apple.com&#x2F;videos&#x2F;play&#x2F;wwdc2021&#x2F;10254</a></div><br/></div></div><div id="37700765" class="c"><input type="checkbox" id="c-37700765" checked=""/><div class="controls bullet"><span class="by">secretsatan</span><span>|</span><a href="#37700349">parent</a><span>|</span><a href="#37700589">prev</a><span>|</span><a href="#37700763">next</a><span>|</span><label class="collapse" for="c-37700765">[-]</label><label class="expand" for="c-37700765">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not really played around with async&#x2F;await because I immediately found issues trying to replace my GCD code, swift still doesn&#x27;t have the fine grained control GCD offers.<p>I replaced some of my other async code with Combine, which I do really like now, it&#x27;s proving itself to be pretty solid</div><br/></div></div><div id="37700763" class="c"><input type="checkbox" id="c-37700763" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#37700349">parent</a><span>|</span><a href="#37700765">prev</a><span>|</span><a href="#37699098">next</a><span>|</span><label class="collapse" for="c-37700763">[-]</label><label class="expand" for="c-37700763">[1 more]</label></div><br/><div class="children"><div class="content">I’m curious what sort of data structures you’re using where you’re hitting deadlocks? Are you by chance doing shared mutation of lists?<p>I’ve written several async Swift apps and not hid deadlocks but I also tend to structure my data in ways that avoid shared rw access where possible.</div><br/></div></div></div></div><div id="37699098" class="c"><input type="checkbox" id="c-37699098" checked=""/><div class="controls bullet"><span class="by">keltex</span><span>|</span><a href="#37700349">prev</a><span>|</span><a href="#37697234">next</a><span>|</span><label class="collapse" for="c-37699098">[-]</label><label class="expand" for="c-37699098">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been playing around with Swift and SwiftUI for the past few months and the thing that baffles me is why are certain features only available with a minimum iOS version.<p>For example async required iOS 15.0. Why is this tied to the OS? Why can&#x27;t they include newer runtimes be downloadable like Node &#x2F; Java &#x2F; .NET etc?<p>Other examples are from SwiftUI. For example the NavigationStack appears much more useful than the older NavigationView but that requires iOS 16. Which means that you can&#x27;t support anything older than an iPhone X.</div><br/><div id="37699427" class="c"><input type="checkbox" id="c-37699427" checked=""/><div class="controls bullet"><span class="by">e28eta</span><span>|</span><a href="#37699098">parent</a><span>|</span><a href="#37699122">next</a><span>|</span><label class="collapse" for="c-37699427">[-]</label><label class="expand" for="c-37699427">[1 more]</label></div><br/><div class="children"><div class="content">Here’s a blog post where they describe the rationale behind switching from app-specific swift versions to bundling it with the OS.<p><a href="https:&#x2F;&#x2F;www.swift.org&#x2F;blog&#x2F;abi-stability-and-apple&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.swift.org&#x2F;blog&#x2F;abi-stability-and-apple&#x2F;</a></div><br/></div></div><div id="37699122" class="c"><input type="checkbox" id="c-37699122" checked=""/><div class="controls bullet"><span class="by">macintosh-hd</span><span>|</span><a href="#37699098">parent</a><span>|</span><a href="#37699427">prev</a><span>|</span><a href="#37700592">next</a><span>|</span><label class="collapse" for="c-37699122">[-]</label><label class="expand" for="c-37699122">[5 more]</label></div><br/><div class="children"><div class="content">I think it comes down to Apple trying to avoid as much fragmentation as possible. Fragmentation makes debugging, troubleshooting, and development a nightmare. It’s not an objective good but everything has its trade offs.</div><br/><div id="37699472" class="c"><input type="checkbox" id="c-37699472" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#37699098">root</a><span>|</span><a href="#37699122">parent</a><span>|</span><a href="#37700592">next</a><span>|</span><label class="collapse" for="c-37699472">[-]</label><label class="expand" for="c-37699472">[4 more]</label></div><br/><div class="children"><div class="content">FWIW, as the application developer, it increases fragmentation, as more of the code in your app is determined by what version of the OS the user is running. If Apple were developing and debugging everyone&#x27;s apps, that argument would make sense (but, of course, they are not). If you truly want to minimize costs for development and debugging by minimizing fragmentation you want to provide the most uniform and stable interface as possible for the developer and let the app then operate as identically as possible across every device it will ever work on, not just today but into the future.</div><br/><div id="37699714" class="c"><input type="checkbox" id="c-37699714" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37699098">root</a><span>|</span><a href="#37699472">parent</a><span>|</span><a href="#37700592">next</a><span>|</span><label class="collapse" for="c-37699714">[-]</label><label class="expand" for="c-37699714">[3 more]</label></div><br/><div class="children"><div class="content">Most Apple users always run the latest iOS version. And the vast majority of apps aren’t seeing major new OS features each iOS release anymore that they just have to adopt to stay competitive - they can focus on their business these days.<p>So in that kind of market, this approach does reduce support costs because you just pick a target iOS version to support and test with devices running that and you know newer devices will also just work.</div><br/><div id="37700751" class="c"><input type="checkbox" id="c-37700751" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#37699098">root</a><span>|</span><a href="#37699714">parent</a><span>|</span><a href="#37699862">next</a><span>|</span><label class="collapse" for="c-37700751">[-]</label><label class="expand" for="c-37700751">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Most Apple users always run the latest iOS version.<p>I assume you&#x27;re talking about the latest iOS version for their device, which may or may not be the latest iOS version released by Apple. I was running around with an iPhone 5 until 2019ish when apps stopped working altogether.</div><br/></div></div><div id="37699862" class="c"><input type="checkbox" id="c-37699862" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37699098">root</a><span>|</span><a href="#37699714">parent</a><span>|</span><a href="#37700751">prev</a><span>|</span><a href="#37700592">next</a><span>|</span><label class="collapse" for="c-37699862">[-]</label><label class="expand" for="c-37699862">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how this would reduce support costs compared to shipping the runtime with the app. Couldn&#x27;t you just pick a target iOS&#x2F;Swift runtime version and support that even if the runtime wasn&#x27;t tied to the iOS version?</div><br/></div></div></div></div></div></div></div></div><div id="37700592" class="c"><input type="checkbox" id="c-37700592" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#37699098">parent</a><span>|</span><a href="#37699122">prev</a><span>|</span><a href="#37699678">next</a><span>|</span><label class="collapse" for="c-37700592">[-]</label><label class="expand" for="c-37700592">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s a bad design that leaves many functional old devices in the dust</div><br/></div></div><div id="37699678" class="c"><input type="checkbox" id="c-37699678" checked=""/><div class="controls bullet"><span class="by">saled</span><span>|</span><a href="#37699098">parent</a><span>|</span><a href="#37700592">prev</a><span>|</span><a href="#37699290">next</a><span>|</span><label class="collapse" for="c-37699678">[-]</label><label class="expand" for="c-37699678">[1 more]</label></div><br/><div class="children"><div class="content">My understanding for the reasoning behind this is that they don&#x27;t want apps to have to ship the runtime stuff to avoid downloads and app sizes getting large.<p>That could be fixed by just shipping an updated shared library to all phones similar to how Google play services works on Android, but I guess they figure if you&#x27;re updating anyway you might as well just update the whole OS.</div><br/></div></div><div id="37699290" class="c"><input type="checkbox" id="c-37699290" checked=""/><div class="controls bullet"><span class="by">wahnfrieden</span><span>|</span><a href="#37699098">parent</a><span>|</span><a href="#37699678">prev</a><span>|</span><a href="#37699270">next</a><span>|</span><label class="collapse" for="c-37699290">[-]</label><label class="expand" for="c-37699290">[1 more]</label></div><br/><div class="children"><div class="content">ASync has been backported to 13</div><br/></div></div><div id="37699270" class="c"><input type="checkbox" id="c-37699270" checked=""/><div class="controls bullet"><span class="by">newZWhoDis</span><span>|</span><a href="#37699098">parent</a><span>|</span><a href="#37699290">prev</a><span>|</span><a href="#37697234">next</a><span>|</span><label class="collapse" for="c-37699270">[-]</label><label class="expand" for="c-37699270">[1 more]</label></div><br/><div class="children"><div class="content">Well for starters, if you were actually playing around with async&#x2F;await on iOS you’d quickly find out it was back ported to iOS13.<p>It is frustrating though, although in my case 40% of my DAU are already on iOS 17 (&gt;3m devices) so it’s not the end of the world.</div><br/></div></div></div></div><div id="37699134" class="c"><input type="checkbox" id="c-37699134" checked=""/><div class="controls bullet"><span class="by">perfectstorm</span><span>|</span><a href="#37697234">prev</a><span>|</span><a href="#37699843">next</a><span>|</span><label class="collapse" for="c-37699134">[-]</label><label class="expand" for="c-37699134">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Apple was one of the companies at the time that recognised the need for a safer, modern alternative to these languages. While no amount of compiler features can prevent you from introducing logic errors, they believed programming languages should be able to prevent undefined behavior, and this vision eventually led to the birth of Swift: a language that prioritized memory safety.<p>i&#x27;m pretty sure that&#x27;s not the reason for the birth of Swift. Trying to access the 20th element from an array of 2 elements would cause a crash in almost all languages including Objective-C which Swift replaced.</div><br/><div id="37699518" class="c"><input type="checkbox" id="c-37699518" checked=""/><div class="controls bullet"><span class="by">greiskul</span><span>|</span><a href="#37699134">parent</a><span>|</span><a href="#37699154">next</a><span>|</span><label class="collapse" for="c-37699518">[-]</label><label class="expand" for="c-37699518">[1 more]</label></div><br/><div class="children"><div class="content">Trying to access the 20th element in an array of 2 elements in C, or objective C for that matter, may instead of crashing, print out a security key, or give someone access to your credit card information. Security bugs are order of magnitude more dangerous than availability bugs. The industry is finally realizing that as we mature software engineering as a proper discipline. Human beings will write bugs, that&#x27;s just a fact of life, we need to make sure the impact of those bugs is as small as possible. And the best tools we have for that, is programming languages where entire classes of bugs don&#x27;t even exist anymore.</div><br/></div></div><div id="37699154" class="c"><input type="checkbox" id="c-37699154" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#37699134">parent</a><span>|</span><a href="#37699518">prev</a><span>|</span><a href="#37699550">next</a><span>|</span><label class="collapse" for="c-37699154">[-]</label><label class="expand" for="c-37699154">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Trying to access the 20th element from an array of 2 elements would cause a crash in almost all languages including Objective-C<p>It depends on which <i>part</i> of objective C you’re referring to:  the C part, or the objective part. ObjC has NSArray, which has safe, bounds checked accessors. But ObjC is a strict superset of C, and C has very unsafe C-style arrays. In the latter, you definitely don’t always get a simple crash for accessing out of bounds… you get UB and buffer overflow exploits, same as C.</div><br/><div id="37699489" class="c"><input type="checkbox" id="c-37699489" checked=""/><div class="controls bullet"><span class="by">greiskul</span><span>|</span><a href="#37699134">root</a><span>|</span><a href="#37699154">parent</a><span>|</span><a href="#37699550">next</a><span>|</span><label class="collapse" for="c-37699489">[-]</label><label class="expand" for="c-37699489">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, people that shit on memory safety don&#x27;t understand that memory bugs don&#x27;t just lead to your program crashing. That has never been a problem. The problem is that they lead to you having to roll out fixes in a hurry in a race against hackers, with the company and safety of customer data on the line. A program crash is just an availability issue, a security bug can be an existential risk for a company.</div><br/></div></div></div></div><div id="37699550" class="c"><input type="checkbox" id="c-37699550" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#37699134">parent</a><span>|</span><a href="#37699154">prev</a><span>|</span><a href="#37699843">next</a><span>|</span><label class="collapse" for="c-37699550">[-]</label><label class="expand" for="c-37699550">[1 more]</label></div><br/><div class="children"><div class="content">This part of the article is actually backwards. The interesting basic part about Swift isn&#x27;t that it has bounds checks on arrays (which everyone also does), it&#x27;s that it also has bounds checks on integer overflow, which half the &quot;safe&quot; languages turn into silent logic errors.</div><br/></div></div></div></div><div id="37699843" class="c"><input type="checkbox" id="c-37699843" checked=""/><div class="controls bullet"><span class="by">wereHamster</span><span>|</span><a href="#37699134">prev</a><span>|</span><label class="collapse" for="c-37699843">[-]</label><label class="expand" for="c-37699843">[3 more]</label></div><br/><div class="children"><div class="content">&gt; […] the so-called “precursor programming languages” like C++ or Obj-C.<p>Like if there were no other languages before C++ or Obj-C, eh? What about C? Or Fortran? Or Ada? Speaking of Ada…<p>&gt; Apple was one of the companies at the time that recognised the need for a safer, modern alternative to these languages.<p>People recognised need for safer languages way before Swift was created.</div><br/><div id="37700944" class="c"><input type="checkbox" id="c-37700944" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#37699843">parent</a><span>|</span><a href="#37700903">next</a><span>|</span><label class="collapse" for="c-37700944">[-]</label><label class="expand" for="c-37700944">[1 more]</label></div><br/><div class="children"><div class="content">Swift is a very modern language and very few languages get close to its safety. Rust does and goes beyond, Zig probably is very similar.</div><br/></div></div><div id="37700903" class="c"><input type="checkbox" id="c-37700903" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37699843">parent</a><span>|</span><a href="#37700944">prev</a><span>|</span><label class="collapse" for="c-37700903">[-]</label><label class="expand" for="c-37700903">[1 more]</label></div><br/><div class="children"><div class="content">Since 1958 actually, had UNIX not been originally available as free beer, C wouldn&#x27;t have taken over the world.</div><br/></div></div></div></div></div></div></div></div></div></body></html>