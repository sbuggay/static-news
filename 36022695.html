<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684746064258" as="style"/><link rel="stylesheet" href="styles.css?v=1684746064258"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/lawrie/fpga_pio">Recreating RP2040 PIO Interface in an FPGA</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>f_devd</span> | <span>31 comments</span></div><br/><div><div id="36025937" class="c"><input type="checkbox" id="c-36025937" checked=""/><div class="controls bullet"><span class="by">qiqitori</span><span>|</span><a href="#36023579">next</a><span>|</span><label class="collapse" for="c-36025937">[-]</label><label class="expand" for="c-36025937">[2 more]</label></div><br/><div class="children"><div class="content">The RP2040&#x27;s PIO is awesome. Here are two retro-related projects I did in the last ~year.<p>You can capture video in a weird format with PIO on one core, and output it with PIO (in a standard format like VGA, or even DVI) on the other core, like here: <a href="https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2022&#x2F;09&#x2F;raspberry-pi-pico-15-6-khz-analog-rgb-to-vga-adapter-part-1-poc-wip&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2022&#x2F;09&#x2F;raspberry-pi-pico-15-6-khz...</a><p>Or you can implement old DACs that expect a weird input data format, to a certain extent, like here: <a href="https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2023&#x2F;03&#x2F;raspberry-pi-pico-implementation-of-the-ym3012-dac-mono&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.qiqitori.com&#x2F;2023&#x2F;03&#x2F;raspberry-pi-pico-implemen...</a><p>(Now I&#x27;m almost at the end of my sabbatical but think these projects (and others) were totally worth doing even if it meant living off savings, heh.)</div><br/><div id="36027142" class="c"><input type="checkbox" id="c-36027142" checked=""/><div class="controls bullet"><span class="by">polpo</span><span>|</span><a href="#36025937">parent</a><span>|</span><a href="#36023579">next</a><span>|</span><label class="collapse" for="c-36027142">[-]</label><label class="expand" for="c-36027142">[1 more]</label></div><br/><div class="children"><div class="content">PIO is indeed awesome! A while ago I was wondering if the RP2040 could be used as a scandoubler (and talking about it with the Chrissy who left a comment on your blog). I was originally discouraged and decided to not pursue it because the ADCs on the RP2040 are just too slow to capture video, so I&#x27;m happy to see the results of your effort!</div><br/></div></div></div></div><div id="36023579" class="c"><input type="checkbox" id="c-36023579" checked=""/><div class="controls bullet"><span class="by">Accujack</span><span>|</span><a href="#36025937">prev</a><span>|</span><a href="#36026519">next</a><span>|</span><label class="collapse" for="c-36023579">[-]</label><label class="expand" for="c-36023579">[4 more]</label></div><br/><div class="children"><div class="content">As soon as I read about the programmable I&#x2F;O setup, it reminded me of the Propeller series chips from Parallax.  The &quot;cogs&quot; that are the main processors of those chips aren&#x27;t as general use as something like the STM32 cores, but they do certain things very, very well.</div><br/><div id="36023611" class="c"><input type="checkbox" id="c-36023611" checked=""/><div class="controls bullet"><span class="by">mysterydip</span><span>|</span><a href="#36023579">parent</a><span>|</span><a href="#36026519">next</a><span>|</span><label class="collapse" for="c-36023611">[-]</label><label class="expand" for="c-36023611">[3 more]</label></div><br/><div class="children"><div class="content">The P2 is a huge step up from the old propeller. If you haven&#x27;t checked it out, I recommend it. &quot;smart pins&quot; are able to do all kinds of things, almost like having mini cores along with the main cogs. I used it for a project and was able to achieve all my goals. Really happy with it.</div><br/><div id="36023978" class="c"><input type="checkbox" id="c-36023978" checked=""/><div class="controls bullet"><span class="by">yetanotherloser</span><span>|</span><a href="#36023579">root</a><span>|</span><a href="#36023611">parent</a><span>|</span><a href="#36026519">next</a><span>|</span><label class="collapse" for="c-36023978">[-]</label><label class="expand" for="c-36023978">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve got me intrigued,but also wanting more specifics. Did you share any details of this anywhere you can link to? (don&#x27;t worry if not, I&#x27;m just nosy)</div><br/><div id="36024035" class="c"><input type="checkbox" id="c-36024035" checked=""/><div class="controls bullet"><span class="by">mysterydip</span><span>|</span><a href="#36023579">root</a><span>|</span><a href="#36023978">parent</a><span>|</span><a href="#36026519">next</a><span>|</span><label class="collapse" for="c-36024035">[-]</label><label class="expand" for="c-36024035">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.parallax.com&#x2F;propeller-2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.parallax.com&#x2F;propeller-2&#x2F;</a> tons of improvements in terms of memory access etc, but pay attention to the &quot;64 smart pins&quot; section specifically. I use them to buffer out sub-microsecond waveforms 3ms at a time. I send it off to the smart pins then my cog is freed up for other things. I also previously used some for an HDMI GUI.</div><br/></div></div></div></div></div></div></div></div><div id="36026519" class="c"><input type="checkbox" id="c-36026519" checked=""/><div class="controls bullet"><span class="by">cdcarter</span><span>|</span><a href="#36023579">prev</a><span>|</span><a href="#36022900">next</a><span>|</span><label class="collapse" for="c-36026519">[-]</label><label class="expand" for="c-36026519">[4 more]</label></div><br/><div class="children"><div class="content">I stumbled upon this project a few weeks ago, while starting to get a better handle on how to use PIO (and the rest of the RP2040 infrastructure, like PIO&#x2F;DMA interactions). I searched for it at first, thinking that an HDL implementation of PIO would be a good way to test and simulate PIO interactions and timings. It turns out there are some neat and more specific PIO simulator&#x2F;emulator projects out there, so I&#x27;ve moved that way.<p>Still, this project is quite interesting. I have a design I&#x27;m working on that would really benefit from 4 PIO blocks all cooperating on a piece of RP silicon. Since that&#x27;s not likely to ship anytime soon, I am vaguely interested in piecing together some HDL that stitches together a RISC-V core with several PIOs.</div><br/><div id="36026636" class="c"><input type="checkbox" id="c-36026636" checked=""/><div class="controls bullet"><span class="by">robomartin</span><span>|</span><a href="#36026519">parent</a><span>|</span><a href="#36022900">next</a><span>|</span><label class="collapse" for="c-36026636">[-]</label><label class="expand" for="c-36026636">[3 more]</label></div><br/><div class="children"><div class="content">Not sure I understand what you are saying.  If you have an FPGA you can do anything you want, better and faster than the RP PIO hardware.  Why replicate it?<p>If you are talking about creating microcoded state machines in an FPGA, once again, this is the kind of thing that is almost trivial.  Examples of subsystems can can be implemented this way are dynamic RAM controllers, sophisticated programmable image processors&#x2F;scalers, etc.</div><br/><div id="36027012" class="c"><input type="checkbox" id="c-36027012" checked=""/><div class="controls bullet"><span class="by">cdcarter</span><span>|</span><a href="#36026519">root</a><span>|</span><a href="#36026636">parent</a><span>|</span><a href="#36027074">next</a><span>|</span><label class="collapse" for="c-36027012">[-]</label><label class="expand" for="c-36027012">[1 more]</label></div><br/><div class="children"><div class="content">I considered addressing this point in my initial post, but decided not to open the can of worms. You&#x27;re right, if I have an FPGA I can do anything I want. But what I want to do is take existing RP2040 PIO programs, and write RP2040 SDK C code to run them and interact with them, but I want to drive more pins and manage more state than the RP2040 offers. If I have a design that takes two RP2040s today and some very careful communication between them, I&#x27;d love to try and run it on FPGA but not throw out all the work.</div><br/></div></div><div id="36027074" class="c"><input type="checkbox" id="c-36027074" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#36026519">root</a><span>|</span><a href="#36026636">parent</a><span>|</span><a href="#36027012">prev</a><span>|</span><a href="#36022900">next</a><span>|</span><label class="collapse" for="c-36027074">[-]</label><label class="expand" for="c-36027074">[1 more]</label></div><br/><div class="children"><div class="content">One thing that&#x27;s nice is that if you have this, you can use an FPGA as a devkit, figure out all the bits and pieces that you need, then use the RP2040 in a &quot;final&quot; product.<p>FPGAs are obviously cool and powerful, but there&#x27;s a pretty big cost differential.<p>On top of that, an FPGA is not a replacement for a CPU in itself. Soft cores are costly in gates. Of course &quot;FPGA + CPU&quot; is a thing, but in that case... if you can get away with a CPU by itself your tooling gets a lot simpler.</div><br/></div></div></div></div></div></div><div id="36022900" class="c"><input type="checkbox" id="c-36022900" checked=""/><div class="controls bullet"><span class="by">sfrigon</span><span>|</span><a href="#36026519">prev</a><span>|</span><a href="#36022824">next</a><span>|</span><label class="collapse" for="c-36022900">[-]</label><label class="expand" for="c-36022900">[15 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting!<p>If AMD incorporates scaled down Xilinx&#x27;s FPGAs into their x86-family product line, that could bring a lot of RasperryPi&#x27;s community effort into a mainstream products too (home PC) and let us experiment embedded software directly on our PC! ...and break our main PC during our experiments too, oopsie. But it would be worth it haha.</div><br/><div id="36023414" class="c"><input type="checkbox" id="c-36023414" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36022900">parent</a><span>|</span><a href="#36023737">next</a><span>|</span><label class="collapse" for="c-36023414">[-]</label><label class="expand" for="c-36023414">[1 more]</label></div><br/><div class="children"><div class="content">Always keep in mind that one of the harshest limits on PC design is the number of pins on the CPU.<p>I really doubt we will see GPIO pins available directly from the CPU, and if they don&#x27;t come directly from there, there isn&#x27;t much difference from using a PCIe or USB adapter.<p>Or, in other words, what you want can already be done about as well as it will ever get. The hype for adding FPGAs into PCs is for using them as co-processors, completely inaccessible for any other hardware.</div><br/></div></div><div id="36023737" class="c"><input type="checkbox" id="c-36023737" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#36022900">parent</a><span>|</span><a href="#36023414">prev</a><span>|</span><a href="#36023099">next</a><span>|</span><label class="collapse" for="c-36023737">[-]</label><label class="expand" for="c-36023737">[4 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re asking for now exists, Zen 4 mobile SKUs allegedly ship a Xilinx design on the die for &quot;AI Acceleration&quot; (some of their Versal fabric over some weird bus), that has absolutely 0 external software consumers beyond some vaporware about video effect software for Windows 11 e.g. background image removal and background noise removal. They really just aren&#x27;t very easy to program or use externally, and require lots of integration work, and that remains a major limiting factor in practice. The pure silicon-area overhead is also pretty severe compared to a fixed ASIC (think ~50-100x worse), limiting their practical size.<p>There are other considerations; large FPGAs are kind of slow to program and have limited or fixed support for multi-tenancy, for example, you have to carve up the device into fixed units ahead of time and divvy those out, and unused resources cannot be re-used. It seems like &quot;time-multiplexed&quot; FPGAs, such as what Tabula was trying to accomplish before going bankrupt, might be better suited for that, which has other tradeoffs. I do wish you could get something high-speed, attached to a desktop class processor.<p>Fun peripherals aren&#x27;t really the reason for the RPi&#x27;s large community, anyway. That result is mostly a mix of software support, pricing, and being in the right place at the right time.</div><br/><div id="36024087" class="c"><input type="checkbox" id="c-36024087" checked=""/><div class="controls bullet"><span class="by">yetanotherloser</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023737">parent</a><span>|</span><a href="#36025106">next</a><span>|</span><label class="collapse" for="c-36024087">[-]</label><label class="expand" for="c-36024087">[1 more]</label></div><br/><div class="children"><div class="content">&quot;compared to a fixed ASIC&quot; seems like a bit of a harsh comparison.<p>The ideal fixed ASIC is as die-facilities-efficient a solution to a particular problem as you&#x27;re going to get. The ideal FPGA is as generalised a solution to a large bucket of problems as you can get. Do they have to compete?<p>Ease of programmability though, there I agree and more. A chip facility can&#x27;t be exciting or even interesting if it&#x27;s hidden behind being a giant pain in the backside to drive.<p>(disclaimer: I used to be really interested in this stuff, but the problems I was interested in were eaten up by general processors and simple uses of GPUs and I&#x27;m just not interesting enough to have problems that really justify exciting hardware any more... more power to you if you still do)</div><br/></div></div><div id="36025106" class="c"><input type="checkbox" id="c-36025106" checked=""/><div class="controls bullet"><span class="by">oscillonoscope</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023737">parent</a><span>|</span><a href="#36024087">prev</a><span>|</span><a href="#36027256">next</a><span>|</span><label class="collapse" for="c-36025106">[-]</label><label class="expand" for="c-36025106">[1 more]</label></div><br/><div class="children"><div class="content">Coarse Grained Reconfigurable Arrays (CGRAs) are the only way I see accelerators taking off. They reconfigure a lot faster and I believe they have better area utilization at the expense of bit-level programmability. I don&#x27;t see many use cases for the FPGAs bit-level reconfiguration in an accelerator anyway so I doubt it would be missed.</div><br/></div></div><div id="36027256" class="c"><input type="checkbox" id="c-36027256" checked=""/><div class="controls bullet"><span class="by">robomartin</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023737">parent</a><span>|</span><a href="#36025106">prev</a><span>|</span><a href="#36023099">next</a><span>|</span><label class="collapse" for="c-36027256">[-]</label><label class="expand" for="c-36027256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Fun peripherals aren&#x27;t really the reason for the RPi&#x27;s large community<p>What many might not realize is that the RP2040 got a massive boost due to supply chain issues affecting the STM32 line.  We had to choice but to redesign a board to adopt the RP2040 when STM32&#x27;s were being quoted at 50+ week lead times.  It was a black swan event like no other.<p>We would have never touched the RP2040 without such an overwhelming forcing function in place.  The chip has serious shortcomings (example: no security) and the company could not give one shit about the needs of professional product developers.  Just asking for proper support under Windows was a nightmare.<p>Not sure if things have changed, at the time they seem to have no understanding of how real products are developed, tested, qualified, certified, evolved and supported over time.<p>It&#x27;s one thing to make little boards for educational markets.  It&#x27;s quite another to build embedded systems that are part of complex multidisciplinary products non-trivial service lifetime and support.<p>We dropped the RP2040 like a hot potato as soon as STM32&#x27;s became available.<p>Making the decision to redesign the boards was a no-brainer.  On the one side you are dealing with a company that makes educational boards that have the luxury of appealing to an audience that shrugs off such things as reliability, tools and manufacturing process integration.  On the other side (STM), you have the support of an organization and an ecosystem that has been dedicated to meeting the needs of professional product developers for decades.  The difference, from my side of the fence, is impossible to miss.  Black swan events sometimes make you do things you will live to regret.  For me, this was one of them.<p>BTW, I do like aspects of this chip.  Someone should take it and run with it in a professional manner.  Raspberry Pi Ltd. isn&#x27;t that company.  It wasn&#x27;t until an engineer from India did the hard work to attempt to create a better experience under Windows that the company &quot;released&quot; a solution.  This &quot;solution&quot; resorts to such things as reinstalling VSCode.  Brilliant.</div><br/></div></div></div></div><div id="36023099" class="c"><input type="checkbox" id="c-36023099" checked=""/><div class="controls bullet"><span class="by">ThrowawayTestr</span><span>|</span><a href="#36022900">parent</a><span>|</span><a href="#36023737">prev</a><span>|</span><a href="#36023310">next</a><span>|</span><label class="collapse" for="c-36023099">[-]</label><label class="expand" for="c-36023099">[8 more]</label></div><br/><div class="children"><div class="content">While I love the idea of FPGA co-processors on CPUs, I&#x27;m wondering how useful they could be. I guess you could replace the video transcoding unit so you&#x27;re not tied to one codec but how often do those change anyway.</div><br/><div id="36023196" class="c"><input type="checkbox" id="c-36023196" checked=""/><div class="controls bullet"><span class="by">sfrigon</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023099">parent</a><span>|</span><a href="#36023555">next</a><span>|</span><label class="collapse" for="c-36023196">[-]</label><label class="expand" for="c-36023196">[5 more]</label></div><br/><div class="children"><div class="content">I must admit I did not think this whole thing fully.<p>But what was interesting to me was the fact that you could add a peripheral that was not initially intended by the manufacturers, making a mainstream motherboard more versatile.<p>For you it may be a video transcoding unit, for someone else it may be an SPI or I2C device, PCIe, or extra ethernet, or high quality audio.<p>I&#x27;m not sure what peripherals were implemented by the community for the RP2040 either, maybe they would not make sense on a PC.</div><br/><div id="36023253" class="c"><input type="checkbox" id="c-36023253" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023196">parent</a><span>|</span><a href="#36023257">next</a><span>|</span><label class="collapse" for="c-36023253">[-]</label><label class="expand" for="c-36023253">[3 more]</label></div><br/><div class="children"><div class="content">Doesnât PCIe already get you that today? Either with an existing PCIe -&gt; X bridge chip, or an FPGA with PCIe capability?<p>Itâs not cheap, and you need to write device drivers etc - but thatâs the case regardless.</div><br/><div id="36023455" class="c"><input type="checkbox" id="c-36023455" checked=""/><div class="controls bullet"><span class="by">sfrigon</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023253">parent</a><span>|</span><a href="#36023257">next</a><span>|</span><label class="collapse" for="c-36023455">[-]</label><label class="expand" for="c-36023455">[2 more]</label></div><br/><div class="children"><div class="content">Maybe PCIe already does something similar, that&#x27;s not something I have knowledge about.<p>Though there is a small difference in my opinion, where, from the point of view of the CPU, it should behave as a normal interface, thus the driver should already exist, and only require a change in the device tree (for linux).<p>It would still require quite a bit of work:
- The PIO has to behave bug-for-bug compatible with an existing driver
- The exposed pins need have the proper voltage levels &amp; electrical protection<p>.. but that&#x27;s just fantasy for now.</div><br/><div id="36026336" class="c"><input type="checkbox" id="c-36026336" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023455">parent</a><span>|</span><a href="#36023257">next</a><span>|</span><label class="collapse" for="c-36026336">[-]</label><label class="expand" for="c-36026336">[1 more]</label></div><br/><div class="children"><div class="content">sounds like PCIe, as mentioned.<p>there are a few FPGA dev kits which are set up this way.  I have one which has a dual core Atom CPU and a large FPGA connected via PCIe, and the speed is <i>fast</i>.</div><br/></div></div></div></div></div></div><div id="36023257" class="c"><input type="checkbox" id="c-36023257" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023196">parent</a><span>|</span><a href="#36023253">prev</a><span>|</span><a href="#36023555">next</a><span>|</span><label class="collapse" for="c-36023257">[-]</label><label class="expand" for="c-36023257">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure what peripherals were implemented by the community for the RP2040 either, maybe they would not make sense on a PC.<p>Well, someone implemented bit-banging Ethernet TX: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35810281" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35810281</a></div><br/></div></div></div></div><div id="36023555" class="c"><input type="checkbox" id="c-36023555" checked=""/><div class="controls bullet"><span class="by">Accujack</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023099">parent</a><span>|</span><a href="#36023196">prev</a><span>|</span><a href="#36023310">next</a><span>|</span><label class="collapse" for="c-36023555">[-]</label><label class="expand" for="c-36023555">[2 more]</label></div><br/><div class="children"><div class="content">Check out the Xilinx &quot;Zynq&quot; series of FPGAs.   They have a lot of uses.</div><br/><div id="36023580" class="c"><input type="checkbox" id="c-36023580" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36022900">root</a><span>|</span><a href="#36023555">parent</a><span>|</span><a href="#36023310">next</a><span>|</span><label class="collapse" for="c-36023580">[-]</label><label class="expand" for="c-36023580">[1 more]</label></div><br/><div class="children"><div class="content">In that case the CPU is basically the co-processor for the FPGA. I&#x27;ve yet to see a use that wasn&#x27;t primarily using the FPGA because it needed to be an FPGA, they&#x27;re not great if you just want to run something fast (outside of a few small uses).</div><br/></div></div></div></div></div></div><div id="36023310" class="c"><input type="checkbox" id="c-36023310" checked=""/><div class="controls bullet"><span class="by">coupdejarnac</span><span>|</span><a href="#36022900">parent</a><span>|</span><a href="#36023099">prev</a><span>|</span><a href="#36022824">next</a><span>|</span><label class="collapse" for="c-36023310">[-]</label><label class="expand" for="c-36023310">[1 more]</label></div><br/><div class="children"><div class="content">You can already experiment with fpgas on a pc. Get Vivado, and then you can code and simulate logic.</div><br/></div></div></div></div><div id="36022824" class="c"><input type="checkbox" id="c-36022824" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#36022900">prev</a><span>|</span><label class="collapse" for="c-36022824">[-]</label><label class="expand" for="c-36022824">[5 more]</label></div><br/><div class="children"><div class="content">that&#x27;s very cool, maybe one day it can be burnt into a CPLD or integrated into other MCUs&#x27; designs directly.<p>Motorola used to have CPM, TI has PRU for higher end chips.<p>All of these are doing similar things: using software to create IO peripherals on the fly.</div><br/><div id="36022960" class="c"><input type="checkbox" id="c-36022960" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#36022824">parent</a><span>|</span><label class="collapse" for="c-36022960">[-]</label><label class="expand" for="c-36022960">[4 more]</label></div><br/><div class="children"><div class="content">The Pi engineers claim that at least some aspects of PIO are &quot;patent-pending,&quot; [0] so a 1:1 reimplementation in another MCU would probably infringe on some claim or another eventually.<p>Yes, software defined I&#x2F;O is not uncommon which is one reason I&#x27;m quite curious about the specific claims in the PIO patents. Another good example is the Infineon Peripheral Control Processor (PCP) used in Tricore. It&#x27;s much more powerful ISA wise than PIO, but conceptually extremely similar.<p>0: <a href="https:&#x2F;&#x2F;forums.raspberrypi.com&#x2F;viewtopic.php?t=307115#p1837408" rel="nofollow">https:&#x2F;&#x2F;forums.raspberrypi.com&#x2F;viewtopic.php?t=307115#p18374...</a></div><br/><div id="36023062" class="c"><input type="checkbox" id="c-36023062" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36022824">root</a><span>|</span><a href="#36022960">parent</a><span>|</span><a href="#36028269">next</a><span>|</span><label class="collapse" for="c-36023062">[-]</label><label class="expand" for="c-36023062">[1 more]</label></div><br/><div class="children"><div class="content">Disgusting stuff.<p>Meantime, RISC-V is trying to standardize GPIO, Watchdogs and other common peripheral interfaces.</div><br/></div></div><div id="36028269" class="c"><input type="checkbox" id="c-36028269" checked=""/><div class="controls bullet"><span class="by">MayeulC</span><span>|</span><a href="#36022824">root</a><span>|</span><a href="#36022960">parent</a><span>|</span><a href="#36023062">prev</a><span>|</span><a href="#36023371">next</a><span>|</span><label class="collapse" for="c-36028269">[-]</label><label class="expand" for="c-36028269">[1 more]</label></div><br/><div class="children"><div class="content">I came here to inquire about this. The relevant patents haven&#x27;t been published yet? I wouldn&#x27;t include this in a commercial design due to potential infringement.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>