<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731747659969" as="style"/><link rel="stylesheet" href="styles.css?v=1731747659969"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://security.googleblog.com/2024/11/retrofitting-spatial-safety-to-hundreds.html">Retrofitting spatial safety to lines of C++</a> <span class="domain">(<a href="https://security.googleblog.com">security.googleblog.com</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>32 comments</span></div><br/><div><div id="42155365" class="c"><input type="checkbox" id="c-42155365" checked=""/><div class="controls bullet"><span class="by">vblanco</span><span>|</span><a href="#42154910">next</a><span>|</span><label class="collapse" for="c-42155365">[-]</label><label class="expand" for="c-42155365">[1 more]</label></div><br/><div class="children"><div class="content">Game developers have been doing this since forever, its one of their main reasons to avoid the STL.<p>EASTL has this as a feature by default, and unreal engine container library has the boundchecks enabled on most games. The performance cost of those boundchecks in practice is well worth the reduction of bugs even on performance sensitive code.</div><br/></div></div><div id="42154910" class="c"><input type="checkbox" id="c-42154910" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42155365">prev</a><span>|</span><a href="#42155324">next</a><span>|</span><label class="collapse" for="c-42154910">[-]</label><label class="expand" for="c-42154910">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We’ve begun by enabling hardened libc++, which adds bounds checking to standard C++ data structures, eliminating a significant class of spatial safety bugs.<p>Well, it&#x27;s 2024 and remember arguing this 20+ years ago. Programs have bugs that bounds checking catches. And making it a language built-in exposes it to compiler optimizations specifically targeting bounds checks, eliminating many and bringing the dynamic cost down immensely. Just turning them on in libraries doesn&#x27;t necessarily expose all the compiler optimizations, but it&#x27;s a start. Safety checks should really be built into the language.</div><br/></div></div><div id="42155324" class="c"><input type="checkbox" id="c-42155324" checked=""/><div class="controls bullet"><span class="by">DLoupe</span><span>|</span><a href="#42154910">prev</a><span>|</span><a href="#42154518">next</a><span>|</span><label class="collapse" for="c-42155324">[-]</label><label class="expand" for="c-42155324">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The safety checks have uncovered over 1,000 bugs<p>In most implementations of the standard library, safety checks can be enabled with a simple #define. In some, it&#x27;s the default behavior in DEBUG mode. I wonder what this library improves on that and why these bugs have not been discovered before.</div><br/><div id="42155332" class="c"><input type="checkbox" id="c-42155332" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42155324">parent</a><span>|</span><a href="#42154518">next</a><span>|</span><label class="collapse" for="c-42155332">[-]</label><label class="expand" for="c-42155332">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a great question (_LIBCPP_DEBUG was already a thing in libc++), and AFAIK the answer is supposedly &quot;it used to be too costly to enable these in production with libc++, and it no longer is.&quot; I have no first-hand insight as to how accurate this perception is.</div><br/></div></div></div></div><div id="42154518" class="c"><input type="checkbox" id="c-42154518" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42155324">prev</a><span>|</span><a href="#42154598">next</a><span>|</span><label class="collapse" for="c-42154518">[-]</label><label class="expand" for="c-42154518">[3 more]</label></div><br/><div class="children"><div class="content">Dlang added array bounds checking 20 years ago. It&#x27;s a huge win. As evidenced by the article noting that 40% of the memory safety bugs were spacial.<p>I used to have all kinds of problems with array overflows. I didn&#x27;t make them very often, but when I did, they took a long time to track down. They&#x27;ve been gone for 20 years now.<p>Note that it would be easy to add it to C&#x2F;C++:<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a><p>It would be the most <i>useful</i> and cost-effective enhancement ever.</div><br/><div id="42155331" class="c"><input type="checkbox" id="c-42155331" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#42154518">parent</a><span>|</span><a href="#42155314">next</a><span>|</span><label class="collapse" for="c-42155331">[-]</label><label class="expand" for="c-42155331">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing, I enjoy reading your posts in regards to how ahead of time Dlang was in adopting these improvements.<p>I wanted to ask: did you ever consider what was missing from Dlang to achieve widespread adoption? Clearly it was not features, so I&#x27;m wondering what that would be from your pespective.</div><br/></div></div><div id="42155314" class="c"><input type="checkbox" id="c-42155314" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42154518">parent</a><span>|</span><a href="#42155331">prev</a><span>|</span><a href="#42154598">next</a><span>|</span><label class="collapse" for="c-42155314">[-]</label><label class="expand" for="c-42155314">[1 more]</label></div><br/><div class="children"><div class="content">They have it already, it&#x27;s called std::span.</div><br/></div></div></div></div><div id="42154598" class="c"><input type="checkbox" id="c-42154598" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42154518">prev</a><span>|</span><a href="#42155130">next</a><span>|</span><label class="collapse" for="c-42154598">[-]</label><label class="expand" for="c-42154598">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Hardening libc++ resulted in an average 0.30% performance impact<p>Maybe what really happened is that compiler technology has improved such that they are able to remove most redundant checks, such that it only costs 0.30% today.  I can imagine things going the opposite direction 20 years ago, as in &quot;we removed some bounds checks and gained X% of performance&quot;.</div><br/><div id="42155109" class="c"><input type="checkbox" id="c-42155109" checked=""/><div class="controls bullet"><span class="by">panstromek</span><span>|</span><a href="#42154598">parent</a><span>|</span><a href="#42155130">next</a><span>|</span><label class="collapse" for="c-42155109">[-]</label><label class="expand" for="c-42155109">[1 more]</label></div><br/><div class="children"><div class="content">Probably yes, and branch prediction improved a lot since then, too. Bounds checks are easily predictable.</div><br/></div></div></div></div><div id="42155130" class="c"><input type="checkbox" id="c-42155130" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42154598">prev</a><span>|</span><a href="#42153898">next</a><span>|</span><label class="collapse" for="c-42155130">[-]</label><label class="expand" for="c-42155130">[3 more]</label></div><br/><div class="children"><div class="content">PSA: Perhaps this is stating the obvious, but if you want bounds checking in your own code, start replacing T* with std::span&lt;T&gt; or std::span&lt;T&gt;::iterator whenever the target is an array.</div><br/><div id="42155146" class="c"><input type="checkbox" id="c-42155146" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#42155130">parent</a><span>|</span><a href="#42153898">next</a><span>|</span><label class="collapse" for="c-42155146">[-]</label><label class="expand" for="c-42155146">[2 more]</label></div><br/><div class="children"><div class="content">std::span is not bounds checked.<p>gsl::span is</div><br/><div id="42155307" class="c"><input type="checkbox" id="c-42155307" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42155130">root</a><span>|</span><a href="#42155146">parent</a><span>|</span><a href="#42153898">next</a><span>|</span><label class="collapse" for="c-42155307">[-]</label><label class="expand" for="c-42155307">[1 more]</label></div><br/><div class="children"><div class="content">&gt; std::span is not bounds checked. gsl::span is<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;Pda9Me45P" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;Pda9Me45P</a> ?</div><br/></div></div></div></div></div></div><div id="42153898" class="c"><input type="checkbox" id="c-42153898" checked=""/><div class="controls bullet"><span class="by">alserio</span><span>|</span><a href="#42155130">prev</a><span>|</span><a href="#42153813">next</a><span>|</span><label class="collapse" for="c-42153898">[-]</label><label class="expand" for="c-42153898">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We first enabled hardened libc++ in our tests over a year ago. This allowed us to identify and fix hundreds of previously undetected bugs in our code and tests.<p>That&#x27;s something</div><br/></div></div><div id="42153813" class="c"><input type="checkbox" id="c-42153813" checked=""/><div class="controls bullet"><span class="by">dzogchen</span><span>|</span><a href="#42153898">prev</a><span>|</span><a href="#42154658">next</a><span>|</span><label class="collapse" for="c-42153813">[-]</label><label class="expand" for="c-42153813">[1 more]</label></div><br/><div class="children"><div class="content">To “lines of C++” and to “hundreds of  millions of lines of C++” is quite a different title.</div><br/></div></div><div id="42154658" class="c"><input type="checkbox" id="c-42154658" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42153813">prev</a><span>|</span><a href="#42151587">next</a><span>|</span><label class="collapse" for="c-42154658">[-]</label><label class="expand" for="c-42154658">[5 more]</label></div><br/><div class="children"><div class="content">Those who give up freedom for security deserve neither, especially if the security only benefits the user-hostile walled garden of the incumbents.</div><br/><div id="42155134" class="c"><input type="checkbox" id="c-42155134" checked=""/><div class="controls bullet"><span class="by">panstromek</span><span>|</span><a href="#42154658">parent</a><span>|</span><a href="#42151587">next</a><span>|</span><label class="collapse" for="c-42155134">[-]</label><label class="expand" for="c-42155134">[4 more]</label></div><br/><div class="children"><div class="content">Interestingly, the original quote is &quot;Those who would give up ESSENTIAL Liberty, to purchase a little TEMPORARY Safety, deserve neither Liberty nor Safety.&quot; which is quite different meaning. Otherwise you never have any safety, as safety is always at the expense of some freedom.<p>Arguably, this kind of work is the opposite - giving up non-essential freedom (in how you write code) for non-temporary (persistent) security.</div><br/><div id="42155189" class="c"><input type="checkbox" id="c-42155189" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42154658">root</a><span>|</span><a href="#42155134">parent</a><span>|</span><a href="#42151587">next</a><span>|</span><label class="collapse" for="c-42155189">[-]</label><label class="expand" for="c-42155189">[3 more]</label></div><br/><div class="children"><div class="content">You may want to look at what Big Tech is doing to the world and society and reconsider.</div><br/><div id="42155256" class="c"><input type="checkbox" id="c-42155256" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42154658">root</a><span>|</span><a href="#42155189">parent</a><span>|</span><a href="#42151587">next</a><span>|</span><label class="collapse" for="c-42155256">[-]</label><label class="expand" for="c-42155256">[2 more]</label></div><br/><div class="children"><div class="content">What does that have to do with bound checks?</div><br/><div id="42155290" class="c"><input type="checkbox" id="c-42155290" checked=""/><div class="controls bullet"><span class="by">panstromek</span><span>|</span><a href="#42154658">root</a><span>|</span><a href="#42155256">parent</a><span>|</span><a href="#42151587">next</a><span>|</span><label class="collapse" for="c-42155290">[-]</label><label class="expand" for="c-42155290">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a big bound check conspiracy, actually. Basically, Google will collaborate with US government to gather all the bounds, via Android. FBI will break into your house and look for all the `i &lt; length`, and if they don&#x27;t find them, they will terminate your `i++` on the spot. This is just the begining. Next time, they will go even for  `int = 0`. You&#x27;ll own nothing, just `for(;;)` and you&#x27;ll be happy.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42151587" class="c"><input type="checkbox" id="c-42151587" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42154658">prev</a><span>|</span><a href="#42153459">next</a><span>|</span><label class="collapse" for="c-42151587">[-]</label><label class="expand" for="c-42151587">[9 more]</label></div><br/><div class="children"><div class="content">New buzzword for old thing alert.</div><br/><div id="42153130" class="c"><input type="checkbox" id="c-42153130" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#42151587">parent</a><span>|</span><a href="#42153223">next</a><span>|</span><label class="collapse" for="c-42153130">[-]</label><label class="expand" for="c-42153130">[2 more]</label></div><br/><div class="children"><div class="content">People (both practitioners &amp; researchers) have been using the terms &quot;temporal&quot; and &quot;spatial&quot; to refer to different classes of C++ vulnerabilities for at least 12+ years, back when I was actually writing exploits for a job. It is not new at all, and anyone in the field within the past 6-7 years and worth their salt will instantly recognize them.</div><br/><div id="42153397" class="c"><input type="checkbox" id="c-42153397" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42151587">root</a><span>|</span><a href="#42153130">parent</a><span>|</span><a href="#42153223">next</a><span>|</span><label class="collapse" for="c-42153397">[-]</label><label class="expand" for="c-42153397">[1 more]</label></div><br/><div class="children"><div class="content">For whatever it&#x27;s worth, I&#x27;ve been doing this stupid shit - writing C++, that is - for 25 years, and this is the first time I&#x27;ve heard this term. (This is a data point rather than a complaint. But for a fee, it can become a complaint if you would like.)</div><br/></div></div></div></div><div id="42153223" class="c"><input type="checkbox" id="c-42153223" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#42151587">parent</a><span>|</span><a href="#42153130">prev</a><span>|</span><a href="#42153239">next</a><span>|</span><label class="collapse" for="c-42153223">[-]</label><label class="expand" for="c-42153223">[1 more]</label></div><br/><div class="children"><div class="content">This term is coming up more frequently in the C++ community as they discuss Rust&#x27;s safety features so to add more nuance to the discussion and focus on subsets of the problem to solve.<p>Note that there are some more heated takes on where these terms are being used. I tried to be as generous as possible in my description.</div><br/></div></div><div id="42153239" class="c"><input type="checkbox" id="c-42153239" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42151587">parent</a><span>|</span><a href="#42153223">prev</a><span>|</span><a href="#42151720">next</a><span>|</span><label class="collapse" for="c-42153239">[-]</label><label class="expand" for="c-42153239">[1 more]</label></div><br/><div class="children"><div class="content">Nah, &quot;spacial safety&quot; is a term of art among security folks and among PL folks who work on security.<p>It&#x27;s the part of memory safety that&#x27;s just about bounds. You can also call it &quot;bounds safety&quot; and folks will understand what you mean, but &quot;spacial safety&quot; is the more commonly used jargon.</div><br/></div></div><div id="42151720" class="c"><input type="checkbox" id="c-42151720" checked=""/><div class="controls bullet"><span class="by">vintagedave</span><span>|</span><a href="#42151587">parent</a><span>|</span><a href="#42153239">prev</a><span>|</span><a href="#42153459">next</a><span>|</span><label class="collapse" for="c-42151720">[-]</label><label class="expand" for="c-42151720">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll say.<p>&gt; Attackers regularly exploit spatial memory safety vulnerabilities, which occur when code accesses a memory allocation outside of its intended bounds<p>Isn&#x27;t that... &#x27;out of bounds memory access&#x27;?</div><br/><div id="42151928" class="c"><input type="checkbox" id="c-42151928" checked=""/><div class="controls bullet"><span class="by">moyix</span><span>|</span><a href="#42151587">root</a><span>|</span><a href="#42151720">parent</a><span>|</span><a href="#42151897">next</a><span>|</span><label class="collapse" for="c-42151928">[-]</label><label class="expand" for="c-42151928">[1 more]</label></div><br/><div class="children"><div class="content">[This is more of a reply to a deleted reply to you, but I don&#x27;t want my efforts to go to waste]<p>Spatial memory safety is a reasonably common term in the security &#x2F; PL field. You can see examples of it being used at least as far back as 2009: <a href="https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?hl=en&amp;as_sdt=0%2C33&amp;q=spatial+memory+safety&amp;btnG=" rel="nofollow">https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?hl=en&amp;as_sdt=0%2C33&amp;q=spa...</a><p>It&#x27;s in contrast to temporal memory safety, which deals with object lifetimes (use after free, for example).<p>Here Google is probably also referencing a 2022 post of theirs with a very similar title, dealing with temporal safety: <a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2022&#x2F;05&#x2F;retrofitting-temporal-memory-safety-on-c.html" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2022&#x2F;05&#x2F;retrofitting-tempora...</a><p>The terms are also in Wikipedia: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety#Classification_of_memory_safety_errors" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety#Classification_o...</a></div><br/></div></div><div id="42151897" class="c"><input type="checkbox" id="c-42151897" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#42151587">root</a><span>|</span><a href="#42151720">parent</a><span>|</span><a href="#42151928">prev</a><span>|</span><a href="#42151811">next</a><span>|</span><label class="collapse" for="c-42151897">[-]</label><label class="expand" for="c-42151897">[1 more]</label></div><br/><div class="children"><div class="content">Yes. It&#x27;s as opposed to temporal memory safety vulnerabilities, like use-after-free or data races.</div><br/></div></div></div></div></div></div><div id="42153459" class="c"><input type="checkbox" id="c-42153459" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#42151587">prev</a><span>|</span><label class="collapse" for="c-42153459">[-]</label><label class="expand" for="c-42153459">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; spatial safety vulnerabilities represent 40% of in-the-wild memory safety exploits<p>Rust advocates tend to turn stats like this into “40% of all security issues are memory safety”, which sounds very similar but is false.</div><br/><div id="42153518" class="c"><input type="checkbox" id="c-42153518" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42153459">parent</a><span>|</span><a href="#42155044">next</a><span>|</span><label class="collapse" for="c-42153518">[-]</label><label class="expand" for="c-42153518">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Rust advocates tend to turn stats like this into “40% of all security issues are memory safety”, which sounds very similar but is false.</i><p>You&#x27;re right that it&#x27;s false. Historically it&#x27;s been a much more damning 70% of vulnerabilities that were rooted in memory-unsafety.<p>According to the Google Security Blog, in a post linked to from the OP:<p><i>We’ll also share updated data on how the percentage of memory safety vulnerabilities in Android dropped from 76% to 24% over 6 years as development shifted to memory safe languages. [...] The percent of vulnerabilities caused by memory safety issues continues to correlate closely with the development language that’s used for new code. Memory safety issues, which accounted for 76% of Android vulnerabilities in 2019, and are currently 24% in 2024, well below the 70% industry norm, and continuing to drop.</i><p><a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;09&#x2F;eliminating-memory-safety-vulnerabilities-Android.html" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;09&#x2F;eliminating-memory-s...</a></div><br/></div></div><div id="42155044" class="c"><input type="checkbox" id="c-42155044" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42153459">parent</a><span>|</span><a href="#42153518">prev</a><span>|</span><label class="collapse" for="c-42155044">[-]</label><label class="expand" for="c-42155044">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re forgetting about temporal safety (use after free). Presumably that brings it up to the 70% of security issues being related to memory safety, which many studies have shown - remarkably consistently.</div><br/></div></div></div></div></div></div></div></div></div></body></html>