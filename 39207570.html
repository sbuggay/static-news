<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706864456339" as="style"/><link rel="stylesheet" href="styles.css?v=1706864456339"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/dgllghr/stanchion">Show HN: Stanchion – Column-oriented tables in SQLite</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>dgllghr</span> | <span>58 comments</span></div><br/><div><div id="39219897" class="c"><input type="checkbox" id="c-39219897" checked=""/><div class="controls bullet"><span class="by">alexgarcia-xyz</span><span>|</span><a href="#39220033">next</a><span>|</span><label class="collapse" for="c-39219897">[-]</label><label class="expand" for="c-39219897">[8 more]</label></div><br/><div class="children"><div class="content">This is an awesome project, I love SQLite extensions and I think they have a ton of use. Giants props to Dan here, I haven&#x27;t seen many SQLite extensions written in Zig, and I&#x27;m learning a ton reading through the source code.<p>The column-oriented data is stored in large BLOBs inside of regular SQLite tables. It uses the SQLite incremental BLOB I&#x2F;O API [0] to incrementally read&#x2F;write data in a column oriented way.<p>However, this project (and other SQLite extensions) will eventually hit a limit with SQLite&#x27;s virtual table API. When you create a virtual table, you can perform a number of optimizations on queries. For examples, SQLite will tell your virtual table implementation the WHERE clauses that appear on the virtual table, any ORDER BYs, which columns are SELECT&#x27;ed, and other limited information. This allows extension developers to do things like predicate + projection pushdowns to make queries faster.<p>Unfortunately, it doesn&#x27;t offer many ways to make analytical queries faster. For example, no matter what you do, a `SELECT COUNT(*) FROM my_vtab` will always iterate through every single row in your virtual table to determine a count. There&#x27;s no &quot;shortcut&quot; to provide top-level counts. Same with other aggregate functions like SUM() or AVERAGE(), SQLite will perform full scans and do calculations themselves.<p>So for this project, while column-oriented datasets could make analytical queries like that much faster, the SQLite API does limit you quite a bunch. I&#x27;m sure there are workarounds around this (by custom UDFs or exposing other query systems), but would be hefty to add.<p>That being said, I still love this project! Really would love to see if there&#x27;s any size benefit to this, and will definitely contribute more when I get a chance. Great job Dan!<p>[0] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;c3ref&#x2F;blob_open.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;c3ref&#x2F;blob_open.html</a></div><br/><div id="39221203" class="c"><input type="checkbox" id="c-39221203" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39219897">parent</a><span>|</span><a href="#39220938">next</a><span>|</span><label class="collapse" for="c-39221203">[-]</label><label class="expand" for="c-39221203">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for the kind words, Alex! You have probably written more great sqlite extensions than anyone, so your feedback is very meaningful.<p>You are right that there are limitations. The sqlite virtual table API is very clearly designed with row-oriented access in mind. However, there are still ways that stanchion makes analytical queries faster: lazily loading segments (which are the BLOBs that contain the actual values) so data that is not accessed is skipped, using encodings like bit packing to reduce the size of data that needs to be traversed on disk, and allowing users to specify a clustered index to ensure records are ordered in a way that allows querying to minimize data access.<p>One area that I want to explore more deeply is the xFindFunction callback in the virtual table API. It allows the a virtual table to &quot;overload&quot; a function with its own implementation. I believe there are some opportunities to work around some of the limitations you are describing, but I&#x27;m not even sure at this point if they can apply to aggregate functions.<p>This is all theoretical until there are solid benchmarks, which is something that I want to add in the near term. And if you know of any workarounds to the limitations that you think may be useful, I am all ears!</div><br/><div id="39222266" class="c"><input type="checkbox" id="c-39222266" checked=""/><div class="controls bullet"><span class="by">alexgarcia-xyz</span><span>|</span><a href="#39219897">root</a><span>|</span><a href="#39221203">parent</a><span>|</span><a href="#39220938">next</a><span>|</span><label class="collapse" for="c-39222266">[-]</label><label class="expand" for="c-39222266">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great to hear! The clustered index sounds really cool. Especially since SQLite tells you about ORDER BYs in xBestIndex (with the nOrderBy[0]), so it would be super cool to have super-fast ORDER BYs with those.<p>Very interested to see how xFindFunction works for you. One limitation I&#x27;ve found  is that you don&#x27;t know if a user uses a xFindFunction inside of xBestIndex (ie at query time), unless 1) it&#x27;s part of a WHERE clause and 2) only two arguments are provided, the first being a column value and the 2nd any literal. I&#x27;ve found this limiting in the past, only having 1 argument to work with in that narrow case. But I&#x27;m sure there&#x27;s clever tricks there!<p>One trick I&#x27;ve noticed: You can kindof detect a COUNT(*) with the `colUsed` field in xBestIndex. In that case, `colUsed` will be 0 (ie 0 columns are requested), so you can use that as a signal to just iterate over N times instead of accessing the underlying data. Still slow, but you can probably do something like ~1 million&#x2F;sec, but better than accessing the data that many times!<p>[0] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;vtab.html#order_by_and_orderbyconsumed" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;vtab.html#order_by_and_orderbyconsume...</a></div><br/><div id="39226451" class="c"><input type="checkbox" id="c-39226451" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#39219897">root</a><span>|</span><a href="#39222266">parent</a><span>|</span><a href="#39224052">next</a><span>|</span><label class="collapse" for="c-39226451">[-]</label><label class="expand" for="c-39226451">[1 more]</label></div><br/><div class="children"><div class="content">I may be missing something, but I&#x27;m not sure you need to detect COUNT(*) specifically.<p>For a query that&#x27;s just SELECT COUNT(*) FROM… SQLite will just iteratively call xNext&#x2F;xEof to count rows. As long as you don&#x27;t actually load data until some is requested by xColumn, what&#x27;s the point?<p>And the above (lazily loading only the requested columns) is exactly what I&#x27;d expect this extension to be doing already.</div><br/></div></div><div id="39224052" class="c"><input type="checkbox" id="c-39224052" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39219897">root</a><span>|</span><a href="#39222266">parent</a><span>|</span><a href="#39226451">prev</a><span>|</span><a href="#39220938">next</a><span>|</span><label class="collapse" for="c-39224052">[-]</label><label class="expand" for="c-39224052">[1 more]</label></div><br/><div class="children"><div class="content">That is a great trick for COUNT(*), thank you!<p>That&#x27;s disappointing about xFindFunction. Once I start digging into it more, I will let you know if I find any other clever tricks that you might be able to use in your extensions as well.<p>Have you ever reached out to the sqlite team about limitations in the virtual table mechanism that you have encountered? I&#x27;m curious how open they are to extending what is possible with virtual tables.</div><br/></div></div></div></div></div></div><div id="39220938" class="c"><input type="checkbox" id="c-39220938" checked=""/><div class="controls bullet"><span class="by">jerrysievert</span><span>|</span><a href="#39219897">parent</a><span>|</span><a href="#39221203">prev</a><span>|</span><a href="#39220353">next</a><span>|</span><label class="collapse" for="c-39220938">[-]</label><label class="expand" for="c-39220938">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The column-oriented data is stored in large BLOBs inside of regular SQLite tables.<p>this is similar to how citus and hydra columnar engines for postgres work - it seems to be a fairly successful use-case.</div><br/></div></div><div id="39220353" class="c"><input type="checkbox" id="c-39220353" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#39219897">parent</a><span>|</span><a href="#39220938">prev</a><span>|</span><a href="#39222325">next</a><span>|</span><label class="collapse" for="c-39220353">[-]</label><label class="expand" for="c-39220353">[1 more]</label></div><br/><div class="children"><div class="content">This is true, and I had the similar issues with the virtual table API. They did add some things, but they won&#x27;t do everything. There are some other problems with SQLite as well. However, there are benefits of SQLite, and I wrote some extensions, too.</div><br/></div></div><div id="39222325" class="c"><input type="checkbox" id="c-39222325" checked=""/><div class="controls bullet"><span class="by">m1sta_</span><span>|</span><a href="#39219897">parent</a><span>|</span><a href="#39220353">prev</a><span>|</span><a href="#39220033">next</a><span>|</span><label class="collapse" for="c-39222325">[-]</label><label class="expand" for="c-39222325">[1 more]</label></div><br/><div class="children"><div class="content">Is there any value in just treating rows as columns and vice versa?</div><br/></div></div></div></div><div id="39220033" class="c"><input type="checkbox" id="c-39220033" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#39219897">prev</a><span>|</span><a href="#39226591">next</a><span>|</span><label class="collapse" for="c-39220033">[-]</label><label class="expand" for="c-39220033">[6 more]</label></div><br/><div class="children"><div class="content">Note that DuckDB can ingest SQLite tables. If you need OLAP on your SQLite system today instead of whenever this is stable, consider pairing up DuckDB. In the simplest case if you don’t need amazing latency and have small data (&lt;1gb), I would copy the whole table from SQLite into an in-memory or temp file DuckDB, do your OLAP queries, then throw it away. For larger datasets, you can incrementally replicate the SQLite table into DuckDB by adding a logical clock column or something to the SQLite table, and then copy rows where logical_clock&gt;last_duckdb_change before running your next DuckDB query.<p>We’re currently doing a bake-off between a few databases for small datasets (&lt;10m rows) with dynamic schemas, and have pretty comparable read latencies between DuckDB and SQLite for our workflow, so you might be able to get away with switching wholesale from SQLite to DuckDB if you don’t do a lot of update.</div><br/><div id="39221264" class="c"><input type="checkbox" id="c-39221264" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39220033">parent</a><span>|</span><a href="#39220721">next</a><span>|</span><label class="collapse" for="c-39221264">[-]</label><label class="expand" for="c-39221264">[3 more]</label></div><br/><div class="children"><div class="content">DuckDB is great! But row-oriented storage is also great for many use cases. My goal is to provide a way for people to have access to the benefits of column-oriented storage without leaving behind the benefits of OLTP. Many people are already using sqlite and might not have the time&#x2F;energy&#x2F;budget to make a full switch to a new database. I also think there should be many options for embedded columnar storage, and right now there really aren&#x27;t.</div><br/><div id="39223712" class="c"><input type="checkbox" id="c-39223712" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#39220033">root</a><span>|</span><a href="#39221264">parent</a><span>|</span><a href="#39220721">next</a><span>|</span><label class="collapse" for="c-39223712">[-]</label><label class="expand" for="c-39223712">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely, it&#x27;s cool to see a real extension in this space, I didn&#x27;t mean to diminish your work at all. If it were a few years more mature I&#x27;d try it out. I just happen to be messing around with DuckDB today for this exact use-case, but your thing is new, so I can&#x27;t adopt it.</div><br/><div id="39224064" class="c"><input type="checkbox" id="c-39224064" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39220033">root</a><span>|</span><a href="#39223712">parent</a><span>|</span><a href="#39220721">next</a><span>|</span><label class="collapse" for="c-39224064">[-]</label><label class="expand" for="c-39224064">[1 more]</label></div><br/><div class="children"><div class="content">No diminishment taken :) I hope you find something that works for your needs</div><br/></div></div></div></div></div></div><div id="39220721" class="c"><input type="checkbox" id="c-39220721" checked=""/><div class="controls bullet"><span class="by">chrisjc</span><span>|</span><a href="#39220033">parent</a><span>|</span><a href="#39221264">prev</a><span>|</span><a href="#39226591">next</a><span>|</span><label class="collapse" for="c-39220721">[-]</label><label class="expand" for="c-39220721">[2 more]</label></div><br/><div class="children"><div class="content">Adding to this.<p><a href="https:&#x2F;&#x2F;duckdb.org&#x2F;2024&#x2F;01&#x2F;26&#x2F;multi-database-support-in-duckdb.html" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;2024&#x2F;01&#x2F;26&#x2F;multi-database-support-in-duck...</a><p>Unsure what the parent means by &quot;ingest&quot; SQLite tables (although i believe you can use COPY with sqlite tables in DuckDB), but you can interact with sqlite tables in DuckDB using the extension to attach to a sqlite db.<p><a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;extensions&#x2F;sqlite" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;extensions&#x2F;sqlite</a></div><br/><div id="39221068" class="c"><input type="checkbox" id="c-39221068" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#39220033">root</a><span>|</span><a href="#39220721">parent</a><span>|</span><a href="#39226591">next</a><span>|</span><label class="collapse" for="c-39221068">[-]</label><label class="expand" for="c-39221068">[1 more]</label></div><br/><div class="children"><div class="content">Yeah by ingest I mean COPY FROM or attach via the SQLite extension. Then you can `INSERT INTO duckdbTable (select * from sqliteDb.sqliteTable)` or similar. I don’t think duckdb aggregate on native SQLite format will have any advantage; I think the native duckdb format would be necessary to see a big advantage over doing the aggregate in SQLite directly based on my reading of the duckdb extension code.</div><br/></div></div></div></div></div></div><div id="39226591" class="c"><input type="checkbox" id="c-39226591" checked=""/><div class="controls bullet"><span class="by">ngrilly</span><span>|</span><a href="#39220033">prev</a><span>|</span><a href="#39220305">next</a><span>|</span><label class="collapse" for="c-39226591">[-]</label><label class="expand" for="c-39226591">[1 more]</label></div><br/><div class="children"><div class="content">Great example of Zig code, and of seamless interaction with C!</div><br/></div></div><div id="39220305" class="c"><input type="checkbox" id="c-39220305" checked=""/><div class="controls bullet"><span class="by">breadchris</span><span>|</span><a href="#39226591">prev</a><span>|</span><a href="#39223078">next</a><span>|</span><label class="collapse" for="c-39220305">[-]</label><label class="expand" for="c-39220305">[5 more]</label></div><br/><div class="children"><div class="content">It seems like there are a lot of extensions that are being built for sqlite. I would like to use these extensions, but I am skeptical about their support over time. I like sqlite for how freakin stable it is. How do people feel about sqlite extensions?</div><br/><div id="39224120" class="c"><input type="checkbox" id="c-39224120" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#39220305">parent</a><span>|</span><a href="#39220652">next</a><span>|</span><label class="collapse" for="c-39224120">[-]</label><label class="expand" for="c-39224120">[1 more]</label></div><br/><div class="children"><div class="content">My limitation with it is that it means I have to recompile sqlite for my use case. That&#x27;s sometimes easy and obvious to do, but it&#x27;s a lot more of a pain if it&#x27;s, say, the sqlite embedded in my language interpreter and I just signed myself up for compiling a custom Python to support my project.<p>That said, I just googled it and it turns out I&#x27;m being a bit dramatic— it&#x27;s actually not super hard to dynamically link Python to a custom-built sqlite: <a href="https:&#x2F;&#x2F;charlesleifer.com&#x2F;blog&#x2F;compiling-sqlite-for-use-with-python-applications&#x2F;" rel="nofollow">https:&#x2F;&#x2F;charlesleifer.com&#x2F;blog&#x2F;compiling-sqlite-for-use-with...</a></div><br/></div></div><div id="39220652" class="c"><input type="checkbox" id="c-39220652" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#39220305">parent</a><span>|</span><a href="#39224120">prev</a><span>|</span><a href="#39224611">next</a><span>|</span><label class="collapse" for="c-39220652">[-]</label><label class="expand" for="c-39220652">[2 more]</label></div><br/><div class="children"><div class="content">SQLite being as stable as it is means that even an unmaintained extension will probably continue to work for a very long time.</div><br/><div id="39223464" class="c"><input type="checkbox" id="c-39223464" checked=""/><div class="controls bullet"><span class="by">breadchris</span><span>|</span><a href="#39220305">root</a><span>|</span><a href="#39220652">parent</a><span>|</span><a href="#39224611">next</a><span>|</span><label class="collapse" for="c-39223464">[-]</label><label class="expand" for="c-39223464">[1 more]</label></div><br/><div class="children"><div class="content">that is what i was thinking about, which is encouraging.</div><br/></div></div></div></div><div id="39224611" class="c"><input type="checkbox" id="c-39224611" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#39220305">parent</a><span>|</span><a href="#39220652">prev</a><span>|</span><a href="#39223078">next</a><span>|</span><label class="collapse" for="c-39224611">[-]</label><label class="expand" for="c-39224611">[1 more]</label></div><br/><div class="children"><div class="content">I guess it depends on what kind of support time scale you&#x27;re wanting?<p>Popular curated extension collections like sqlean (<a href="https:&#x2F;&#x2F;github.com&#x2F;nalgeon&#x2F;sqlean">https:&#x2F;&#x2F;github.com&#x2F;nalgeon&#x2F;sqlean</a>) seem like they&#x27;ll have a shelf life of many years.</div><br/></div></div></div></div><div id="39223078" class="c"><input type="checkbox" id="c-39223078" checked=""/><div class="controls bullet"><span class="by">tbragin</span><span>|</span><a href="#39220305">prev</a><span>|</span><a href="#39225156">next</a><span>|</span><label class="collapse" for="c-39223078">[-]</label><label class="expand" for="c-39223078">[2 more]</label></div><br/><div class="children"><div class="content">Interesting project! Thank you for open sourcing and sharing. Agree that local and embedded analytics are an increasing trend, I see it too.<p>A couple of questions:<p>* I’m curious what the difficulties were in the implementation. I suspect it is quite a challenge to implement this support in the current SQLite architecture, and would curious to know which parts were tricky and any design trade-off you were faced with.<p>* Aside from ease-of-use (install extension, no need for a separate analytical database system), I wonder if there are additional benefits users can anticipate resulting from a single system architecture vs running an embedded OLAP store like DuckDB or clickhouse-local &#x2F; chdb side-by-side with SQLite? Do you anticipate performance or resource efficiency gains, for instance?<p>* I am also curious, what the main difficulty with bringing in a separate analytical database is, assuming it natively integrates with SQLite. I may be biased, but I doubt anything can approach the performance of native column-oriented systems, so I&#x27;m curious what the tipping point might be for using this extension vs using an embedded OLAP store in practice.<p>Btw, would love for you or someone in the community to benchmark Stanchion in ClickBench and submit results! (<a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickBench&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickBench&#x2F;</a>)<p>Disclaimer: I work on ClickHouse.</div><br/><div id="39223971" class="c"><input type="checkbox" id="c-39223971" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39223078">parent</a><span>|</span><a href="#39225156">next</a><span>|</span><label class="collapse" for="c-39223971">[-]</label><label class="expand" for="c-39223971">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your thoughtful questions!<p>* SQLite has rock solid support for transactionally persisting data to disk, which is a difficult and complex thing that stanchion gets almost for free. But the downside is fitting the architecture of stanchion into sqlite&#x27;s way of doing things. So that is a long way of saying yes, the biggest difficulty was first learning how sqlite works and the implementing features to work with sqlite.<p>* It&#x27;s a good question and certainly an area worth exploring. I don&#x27;t know the answer, but doing, for instance, a comparison of power consumption and performance on a phone for the same use case between sqlite+stanchion and chdb running side-by-side with sqlite would be very interesting. To spitball some ideas of areas that may benefit stanchion: caching (both code and data, application caching and hardware caching), data sharing (no need for decoding and re-encoding either within the host application or between databases), and unified transactions (this one is a stretch). As you mention, chDB (and also DuckDB) benefit from having an architecture designed for analytics.<p>* As mentioned elsewhere in these comments, the sqlite virtual table system does have some limitations, so I think you&#x27;re right when it comes to query performance. However, those limitations are limited to the way sqlite queries data in virtual tables, so I think stanchion can be competitive on data size on disk and potentially on insert performance.<p>I do plan to run and publish some benchmarks of stanchion against chDB and DuckDB in the near term. So far, I haven&#x27;t focused on performance with stanchion, but that will be more of a focus going forward. Plus it&#x27;s good to measure first and use that to track improvements. Stay tuned!</div><br/></div></div></div></div><div id="39225156" class="c"><input type="checkbox" id="c-39225156" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#39223078">prev</a><span>|</span><a href="#39225157">next</a><span>|</span><label class="collapse" for="c-39225156">[-]</label><label class="expand" for="c-39225156">[1 more]</label></div><br/><div class="children"><div class="content">Question: Why do you choose LGPL-3.0? For many, one of the most attractive features of SQLite is its license (or should I say lack thereof).<p>I realise some people view public domain as legally problematic. I think the best answer for that is public-domain equivalent licenses such as 0BSD [0] or MIT-0 [1] – technically still copyrighted, but effectively not, since they let you do <i>anything</i> under zero conditions. (There are other, possibly more well-known options such as Unlicense or WTFPL or CC0; however, those tend to upset lawyers more than 0BSD and MIT-0 do.)<p>Of course, it is your work, and you are free to license it however you like. Still, some potential users are going to be put off by the licensing.<p>[0] <a href="https:&#x2F;&#x2F;opensource.org&#x2F;license&#x2F;0bsd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;opensource.org&#x2F;license&#x2F;0bsd&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;opensource.org&#x2F;license&#x2F;mit-0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;opensource.org&#x2F;license&#x2F;mit-0&#x2F;</a></div><br/></div></div><div id="39225157" class="c"><input type="checkbox" id="c-39225157" checked=""/><div class="controls bullet"><span class="by">vincent-manis</span><span>|</span><a href="#39225156">prev</a><span>|</span><a href="#39224065">next</a><span>|</span><label class="collapse" for="c-39225157">[-]</label><label class="expand" for="c-39225157">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like an excellent project, and I hope it continues to a production release.<p>I do have one qualm, though. SQLite is written in C, and if I were writing plugins for it, I would seriously consider myself bound to using C for them, regardless of the merits of the language. I can easily imagine myself trying to build an extended SQLite library where one plugin is written in Zig, another in Rust, and perhaps a third in Hare. A fourth plugin might be written in C, but be built using Meson. Yet another plugin written in C is built with Bazel. And here I come, writing my plugin in Chibi Scheme!<p>Eventually, the toolchain needed to build the library and all its plugins overflows.<p>I would strongly recommend that people who write plugins for programs or libraries give serious consideration to using the programming language(s) and build system(s) of the parent software.</div><br/></div></div><div id="39224065" class="c"><input type="checkbox" id="c-39224065" checked=""/><div class="controls bullet"><span class="by">hifikuno</span><span>|</span><a href="#39225157">prev</a><span>|</span><a href="#39219927">next</a><span>|</span><label class="collapse" for="c-39224065">[-]</label><label class="expand" for="c-39224065">[1 more]</label></div><br/><div class="children"><div class="content">This is great. I love using DuckDB to do initial analytics on new datasets we get at work. The issue I run into a lot is that our sources can give us data that has non UTF-8 characters in it which DuckDB won&#x27;t read so I spend a bit of time just trying to find the few non UTF-8 characters in a multi-GB file.<p>SQLite does not seem to care about the bogus characters so I would be really interested in using Stanchion and SQLite to see if it speeds up my exploration.<p>Also, I do not know how I have never known about SQLite extensions before now. I feel like I just found out that Narwhals are actually real.</div><br/></div></div><div id="39219927" class="c"><input type="checkbox" id="c-39219927" checked=""/><div class="controls bullet"><span class="by">nattaylor</span><span>|</span><a href="#39224065">prev</a><span>|</span><a href="#39219531">next</a><span>|</span><label class="collapse" for="c-39219927">[-]</label><label class="expand" for="c-39219927">[2 more]</label></div><br/><div class="children"><div class="content">This is particularly interesting to me for Android&#x2F;iOS. I can&#x27;t even picture the use case where there&#x27;d be enough data on the device for the row-based format to b a bottleneck, but maybe some case that involves many, many aggregations</div><br/><div id="39220257" class="c"><input type="checkbox" id="c-39220257" checked=""/><div class="controls bullet"><span class="by">simcop2387</span><span>|</span><a href="#39219927">parent</a><span>|</span><a href="#39219531">next</a><span>|</span><label class="collapse" for="c-39220257">[-]</label><label class="expand" for="c-39220257">[1 more]</label></div><br/><div class="children"><div class="content">Maybe not a bottleneck but maybe it could improve battery life there for those tasks by being better performing</div><br/></div></div></div></div><div id="39219531" class="c"><input type="checkbox" id="c-39219531" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#39219927">prev</a><span>|</span><a href="#39219884">next</a><span>|</span><label class="collapse" for="c-39219531">[-]</label><label class="expand" for="c-39219531">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m excited to see how this compares to DuckDB. More local&#x2F;embedded analytics databases will be good for the industry.</div><br/><div id="39219565" class="c"><input type="checkbox" id="c-39219565" checked=""/><div class="controls bullet"><span class="by">lainga</span><span>|</span><a href="#39219531">parent</a><span>|</span><a href="#39219807">next</a><span>|</span><label class="collapse" for="c-39219565">[-]</label><label class="expand" for="c-39219565">[5 more]</label></div><br/><div class="children"><div class="content">Well, if Wikipedia&#x27;s anything to go by, it seems to be the first in-mem column-oriented DB written in Zig</div><br/><div id="39219783" class="c"><input type="checkbox" id="c-39219783" checked=""/><div class="controls bullet"><span class="by">Iridescent_</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219565">parent</a><span>|</span><a href="#39219807">next</a><span>|</span><label class="collapse" for="c-39219783">[-]</label><label class="expand" for="c-39219783">[4 more]</label></div><br/><div class="children"><div class="content">As far as I can tell, the linked github repository is written only in C. Zig is used only as build system<p>EDIT: nvm, the github stats seem to be completely wrong? It shows 96% C to me...<p>Found it, I believe this is the result of including code from SQLite in the repo</div><br/><div id="39219947" class="c"><input type="checkbox" id="c-39219947" checked=""/><div class="controls bullet"><span class="by">lr1970</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219783">parent</a><span>|</span><a href="#39221438">next</a><span>|</span><label class="collapse" for="c-39219947">[-]</label><label class="expand" for="c-39219947">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is because it includes SQlite source (in C) that dwarfs the size of columnar storage extension (in Zig).</div><br/></div></div><div id="39221438" class="c"><input type="checkbox" id="c-39221438" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219783">parent</a><span>|</span><a href="#39219947">prev</a><span>|</span><a href="#39219807">next</a><span>|</span><label class="collapse" for="c-39221438">[-]</label><label class="expand" for="c-39221438">[2 more]</label></div><br/><div class="children"><div class="content">Including the sqlite source is for the convenience of running unit tests without needing to rely on sqlite as an external dependency :)</div><br/><div id="39224660" class="c"><input type="checkbox" id="c-39224660" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39221438">parent</a><span>|</span><a href="#39219807">next</a><span>|</span><label class="collapse" for="c-39224660">[-]</label><label class="expand" for="c-39224660">[1 more]</label></div><br/><div class="children"><div class="content">Ahhh.  We (sqlitebrowser.org) used to do something along those lines in one of our repos too.<p>We moved to automatically grabbing the SQLite source as a step in our unit tests instead so we always have the latest SQLite release.<p>One less manual task that needs doing every time there&#x27;s a new SQLite release.<p>It turned out to be really easy to do, as the SQLite download page has hidden tags in it just for this purpose:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;sqlitebrowser&#x2F;sqlitebrowser&#x2F;blob&#x2F;7a31ef971a5f878383a43bd193c7d0c5d458a77a&#x2F;.github&#x2F;workflows&#x2F;build-appimage.yml#L27-L35">https:&#x2F;&#x2F;github.com&#x2F;sqlitebrowser&#x2F;sqlitebrowser&#x2F;blob&#x2F;7a31ef97...</a><p>In theory (!) it should be pretty easy to just copy the above code snippet into your unit testing setup, which would also reduce the line count of C code in your repo. :)<p>In the above code I&#x27;d probably use &quot;make -j `nproc`&quot; instead of the hard coded number of cpus (-j2) though, so it automatically uses however many are available.  Should probably update that. :)</div><br/></div></div></div></div></div></div></div></div><div id="39219807" class="c"><input type="checkbox" id="c-39219807" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#39219531">parent</a><span>|</span><a href="#39219565">prev</a><span>|</span><a href="#39219884">next</a><span>|</span><label class="collapse" for="c-39219807">[-]</label><label class="expand" for="c-39219807">[7 more]</label></div><br/><div class="children"><div class="content">DuckDB can read from several heterogenous sources, but is read only.<p>SQLite is limited to its own format but can write.<p>So very different use cases.</div><br/><div id="39219904" class="c"><input type="checkbox" id="c-39219904" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219807">parent</a><span>|</span><a href="#39219935">next</a><span>|</span><label class="collapse" for="c-39219904">[-]</label><label class="expand" for="c-39219904">[3 more]</label></div><br/><div class="children"><div class="content">Actually DuckDB has its own database format for persistence and can support writes. It’s not obvious from their documentation. People told me that on HN not long ago, as I thought the same than you.</div><br/><div id="39221050" class="c"><input type="checkbox" id="c-39221050" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219904">parent</a><span>|</span><a href="#39220342">next</a><span>|</span><label class="collapse" for="c-39221050">[-]</label><label class="expand" for="c-39221050">[1 more]</label></div><br/><div class="children"><div class="content">It can also write Parquet files and other formats.</div><br/></div></div><div id="39220342" class="c"><input type="checkbox" id="c-39220342" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219904">parent</a><span>|</span><a href="#39221050">prev</a><span>|</span><a href="#39219935">next</a><span>|</span><label class="collapse" for="c-39220342">[-]</label><label class="expand" for="c-39220342">[1 more]</label></div><br/><div class="children"><div class="content">Oh, thanks, TIL.</div><br/></div></div></div></div><div id="39219935" class="c"><input type="checkbox" id="c-39219935" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219807">parent</a><span>|</span><a href="#39219904">prev</a><span>|</span><a href="#39220050">next</a><span>|</span><label class="collapse" for="c-39219935">[-]</label><label class="expand" for="c-39219935">[1 more]</label></div><br/><div class="children"><div class="content">DuckDB isn&#x27;t optimized for writing speed, but it is not read-only.</div><br/></div></div><div id="39220050" class="c"><input type="checkbox" id="c-39220050" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39219807">parent</a><span>|</span><a href="#39219935">prev</a><span>|</span><a href="#39219884">next</a><span>|</span><label class="collapse" for="c-39220050">[-]</label><label class="expand" for="c-39220050">[2 more]</label></div><br/><div class="children"><div class="content">I’m looking at some DuckDB code right here that does `INSERT INTO … ON CONFLICT (id) DO UPDATE SET` so it can definitely do upserts :)</div><br/><div id="39220352" class="c"><input type="checkbox" id="c-39220352" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#39219531">root</a><span>|</span><a href="#39220050">parent</a><span>|</span><a href="#39219884">next</a><span>|</span><label class="collapse" for="c-39220352">[-]</label><label class="expand" for="c-39220352">[1 more]</label></div><br/><div class="children"><div class="content">Ok, I retract.</div><br/></div></div></div></div></div></div></div></div><div id="39219884" class="c"><input type="checkbox" id="c-39219884" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#39219531">prev</a><span>|</span><a href="#39224878">next</a><span>|</span><label class="collapse" for="c-39219884">[-]</label><label class="expand" for="c-39219884">[2 more]</label></div><br/><div class="children"><div class="content">If you are into alternative storage engines for SQLite, there is also an LSM (Log-Structured Merge-tree) extension in the main repository that is not announced nor documented but seems to work. It’s based on the SQLite 4 project.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;sqlite&#x2F;sqlite&#x2F;tree&#x2F;master&#x2F;ext&#x2F;lsm1">https:&#x2F;&#x2F;github.com&#x2F;sqlite&#x2F;sqlite&#x2F;tree&#x2F;master&#x2F;ext&#x2F;lsm1</a><p><a href="https:&#x2F;&#x2F;www.charlesleifer.com&#x2F;blog&#x2F;lsm-key-value-storage-in-sqlite3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.charlesleifer.com&#x2F;blog&#x2F;lsm-key-value-storage-in-...</a></div><br/><div id="39219934" class="c"><input type="checkbox" id="c-39219934" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#39219884">parent</a><span>|</span><a href="#39224878">next</a><span>|</span><label class="collapse" for="c-39219934">[-]</label><label class="expand" for="c-39219934">[1 more]</label></div><br/><div class="children"><div class="content">&quot;SQLite4 was an experimental rewrite of SQLite that was active from 2012 through 2014. All development work on SQLite4 has ended. Lessons learned from SQLite4 have been folded into the main SQLite3 product. SQLite4 was never released. There are no plans to revive it. You should be using SQLite3.&quot;<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;src4&#x2F;doc&#x2F;trunk&#x2F;www&#x2F;index.wiki" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;src4&#x2F;doc&#x2F;trunk&#x2F;www&#x2F;index.wiki</a></div><br/></div></div></div></div><div id="39224878" class="c"><input type="checkbox" id="c-39224878" checked=""/><div class="controls bullet"><span class="by">devdiary</span><span>|</span><a href="#39219884">prev</a><span>|</span><a href="#39221397">next</a><span>|</span><label class="collapse" for="c-39224878">[-]</label><label class="expand" for="c-39224878">[1 more]</label></div><br/><div class="children"><div class="content">Can you ELI5, how did you make this possible? I see the readme asking to download a binary and then also mentioning sqlite extension. I have never had exp with sqlite ext, so not quite sure how do they work. Appreciate how does this solution work under the hood.</div><br/></div></div><div id="39221397" class="c"><input type="checkbox" id="c-39221397" checked=""/><div class="controls bullet"><span class="by">didgetmaster</span><span>|</span><a href="#39224878">prev</a><span>|</span><a href="#39221282">next</a><span>|</span><label class="collapse" for="c-39221397">[-]</label><label class="expand" for="c-39221397">[3 more]</label></div><br/><div class="children"><div class="content">Is this really an important feature for DB users here?
I built my own hobby database system that was column oriented (using the metadata tagging system I invented for a file system replacement I built). It does lightning fast analytics and even outperforms SQLite in a bunch of other operations. I posted a benchmark video on my YouTube channel and made a free beta download available; but the response has been lukewarm at best.<p><a href="https:&#x2F;&#x2F;YouTube.com&#x2F;@didgetsdemos" rel="nofollow">https:&#x2F;&#x2F;YouTube.com&#x2F;@didgetsdemos</a>
<a href="https:&#x2F;&#x2F;www.didgets.com" rel="nofollow">https:&#x2F;&#x2F;www.didgets.com</a></div><br/><div id="39223705" class="c"><input type="checkbox" id="c-39223705" checked=""/><div class="controls bullet"><span class="by">lukevp</span><span>|</span><a href="#39221397">parent</a><span>|</span><a href="#39221282">next</a><span>|</span><label class="collapse" for="c-39223705">[-]</label><label class="expand" for="c-39223705">[2 more]</label></div><br/><div class="children"><div class="content">It’s not open source (or even source available), and it’s targeted at users who, what, use csv files but can’t use excel very well, but are searching for a new revolutionary file system?<p>I don’t really see a use case for your product based on the pitch page, just a lot of marketing speak that (to an engineer) seems like an apples and oranges comparison (eg. You’re running a local db, could be in memory even, and benchmarking it against Postgres, which is an incredibly flexible and comprehensive piece of software with multitenancy, transactions, replication, schema management, query planning, and a full on webserver? How is that the same product? Why not benchmark this against Excel? Cuz I’ve already got excel installed and I can open a CSV and grep for a string and count the matches in like 5 seconds. That seems to be what you’re competing against.<p>If you open source the code and make it a general purpose library (and not windows only) and market it toward developers, you might get some more interest.</div><br/><div id="39224769" class="c"><input type="checkbox" id="c-39224769" checked=""/><div class="controls bullet"><span class="by">didgetmaster</span><span>|</span><a href="#39221397">root</a><span>|</span><a href="#39223705">parent</a><span>|</span><a href="#39221282">next</a><span>|</span><label class="collapse" for="c-39224769">[-]</label><label class="expand" for="c-39224769">[1 more]</label></div><br/><div class="children"><div class="content">I never claimed that my project in its current form is a drop-in replacement for Postgres or even SQLite. It still lacks many features that those databases have accumulated over decades of development by large communities.<p>It is not just an in-memory DB. All its data is persisted on disk and I made sure whenever I did a benchmark on any query; that I was doing an apples-to-apples comparison.<p>Even though the beta consists of a Windows executable; there is nothing Windows specific about it. It is built to be cross-platform and it has been tested on Linux. With my small team, we just maintain a single platform at the moment for simplicity sake.<p>We have not yet open-sourced the code as you pointed out; but we have considered it. But if everyone just wants to dismiss it out of hand because it fails to check some box and just focuses on what it can&#x27;t do, instead of what it does well; then there might not be any point in doing so.</div><br/></div></div></div></div></div></div><div id="39221070" class="c"><input type="checkbox" id="c-39221070" checked=""/><div class="controls bullet"><span class="by">thamer</span><span>|</span><a href="#39220361">prev</a><span>|</span><a href="#39222152">next</a><span>|</span><label class="collapse" for="c-39221070">[-]</label><label class="expand" for="c-39221070">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;Data Storage Internals&quot; section[1] of the README sounds to me like it has its own column-oriented format for these tables, at least that&#x27;s how I&#x27;m reading the part about segments. Is that the case? If so, have you tried using Apache Arrow or Parquet to see how they compare?<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;dgllghr&#x2F;stanchion#data-storage-internals">https:&#x2F;&#x2F;github.com&#x2F;dgllghr&#x2F;stanchion#data-storage-internals</a></div><br/><div id="39221404" class="c"><input type="checkbox" id="c-39221404" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39221070">parent</a><span>|</span><a href="#39222152">next</a><span>|</span><label class="collapse" for="c-39221404">[-]</label><label class="expand" for="c-39221404">[1 more]</label></div><br/><div class="children"><div class="content">Yes it does. I have found it easier to start simple than try to integrate the complexity of Parquet whole hog. The Parquet format is also designed with the idea of having multiple columns in the same &quot;file&quot;. I&#x27;m sure there are ways to split the components of a Parquet file across multiple BLOBs and be able to append those BLOBs together to create a valid Parquet file, but that is more complexity and does not lend itself to existing Parquet code. Keeping the blobs separate is valuable because it means not touching data for columns that are not being read in queries.<p>My understanding is that Arrow has really focused on an in-memory format. It is binary, so it can be written to disk, but they are seemingly just scratching the surface on compression. Compression is a big advantage of columnar storage because really cool compression schemes like bit packing, run-length encoding, dictionary compression, etc. can be used to significantly reduce the size of data on disk.<p>Arrow interop especially is a great idea, though, regardless of the storage format. And if they are developing a storage-friendly version of arrow, I would certainly consider it.</div><br/></div></div></div></div><div id="39222152" class="c"><input type="checkbox" id="c-39222152" checked=""/><div class="controls bullet"><span class="by">thecowgoes</span><span>|</span><a href="#39221070">prev</a><span>|</span><a href="#39219544">next</a><span>|</span><label class="collapse" for="c-39222152">[-]</label><label class="expand" for="c-39222152">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t wait to see compression!<p>Any timeline for that?</div><br/><div id="39224012" class="c"><input type="checkbox" id="c-39224012" checked=""/><div class="controls bullet"><span class="by">dgllghr</span><span>|</span><a href="#39222152">parent</a><span>|</span><a href="#39219544">next</a><span>|</span><label class="collapse" for="c-39224012">[-]</label><label class="expand" for="c-39224012">[1 more]</label></div><br/><div class="children"><div class="content">Stanchion already has support for a few kinds of compression that leverage patterns in a sequence of data of the same type (DuckDB calls this &quot;lightweight compression&quot;). Stanchion supports: bit packing for booleans and integers and constant compression (if all the values in a run of data are the same, only store the value once). The next type of lightweight compression that is planned is Run Length Encoding (RLE). And I also want to add support for lossless byte encoding (probably zstd) at some point.</div><br/></div></div></div></div><div id="39223799" class="c"><input type="checkbox" id="c-39223799" checked=""/><div class="controls bullet"><span class="by">justina20</span><span>|</span><a href="#39219422">prev</a><span>|</span><label class="collapse" for="c-39223799">[-]</label><label class="expand" for="c-39223799">[1 more]</label></div><br/><div class="children"><div class="content">Too bad how difficult it is to get a legit and trusted online hacker, i have been scammed many times trying to get a job done by an hacker. I want to thank ( REMOTESPYHACKER ) for coming through for me and getting my job done. Now i have access to the text messages and photos of my partner without his knowledge. i can proudly recommend your good works to other people in need of hacking service. contact ( remote spy hacker @ gm ail c om )</div><br/></div></div></div></div></div></div></div></body></html>