<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692522055730" as="style"/><link rel="stylesheet" href="styles.css?v=1692522055730"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://helidon.io/nima">Helidon Níma: A Java microservices framework based on virtual threads</a> <span class="domain">(<a href="https://helidon.io">helidon.io</a>)</span></div><div class="subtext"><span>philonoist</span> | <span>102 comments</span></div><br/><div><div id="37195289" class="c"><input type="checkbox" id="c-37195289" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#37192415">next</a><span>|</span><label class="collapse" for="c-37195289">[-]</label><label class="expand" for="c-37195289">[6 more]</label></div><br/><div class="children"><div class="content">Not being well versed in the capabilities of the virtual threads. However, both the Servlet and the JAX-RS models are &quot;thread agnostic&quot; in that while we &quot;know&quot; we&#x27;re running on a thread, the API doesn&#x27;t expose it directly.<p>So, if something like Tomcat &quot;simply&quot; switch its internal threading model from the current model to the virtual model, would the applications know any different? Could you drag and drop a JAX-RS service or a Java Servlet into a container running on virtual threads, or would rapidly run into some leaky wall?<p>Seems like a virtual thread model of Tomcat would be quite useful in some scenarios.</div><br/><div id="37196966" class="c"><input type="checkbox" id="c-37196966" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#37195289">parent</a><span>|</span><a href="#37195592">next</a><span>|</span><label class="collapse" for="c-37196966">[-]</label><label class="expand" for="c-37196966">[2 more]</label></div><br/><div class="children"><div class="content">It definitely would. I - for one - won&#x27;t be rewriting our 20+ year old servlet app in anything else but servlets, because it has proven to be an exceptionally stable environment. More than virtual threads for Tomcat requests, I&#x27;d love  cheap, structured  threads to be run from within a request, eg to access the database while I&#x27;m reading a webservice.</div><br/><div id="37197019" class="c"><input type="checkbox" id="c-37197019" checked=""/><div class="controls bullet"><span class="by">mikko-apo</span><span>|</span><a href="#37195289">root</a><span>|</span><a href="#37196966">parent</a><span>|</span><a href="#37195592">next</a><span>|</span><label class="collapse" for="c-37197019">[-]</label><label class="expand" for="c-37197019">[1 more]</label></div><br/><div class="children"><div class="content">JDK21 has structured concurrency. It works with virtual threads so the main task will be moved aside (from the OS thread) until the sub tasks finnish.<p><a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;news&#x2F;2023&#x2F;06&#x2F;structured-concurrency-jdk-21&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.infoq.com&#x2F;news&#x2F;2023&#x2F;06&#x2F;structured-concurrency-jd...</a></div><br/></div></div></div></div><div id="37195592" class="c"><input type="checkbox" id="c-37195592" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#37195289">parent</a><span>|</span><a href="#37196966">prev</a><span>|</span><a href="#37192415">next</a><span>|</span><label class="collapse" for="c-37195592">[-]</label><label class="expand" for="c-37195592">[3 more]</label></div><br/><div class="children"><div class="content">In order to use those things, you have to write annotations.<p>With Nima, you just write the code to do the thing.<p>It&#x27;s a huge difference.<p>If you have the wisdom to see how toxic annotation-driven programming in Java is, you will like Nima.<p>Helidon Nima is more comparable to building services in golang. It&#x27;s more like Vert.x but with a serial API.</div><br/><div id="37195896" class="c"><input type="checkbox" id="c-37195896" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37195289">root</a><span>|</span><a href="#37195592">parent</a><span>|</span><a href="#37196687">next</a><span>|</span><label class="collapse" for="c-37195896">[-]</label><label class="expand" for="c-37195896">[1 more]</label></div><br/><div class="children"><div class="content">There are ways of writing Spring without annotations (or XML config): <a href="https:&#x2F;&#x2F;blog.frankel.ch&#x2F;annotation-free-spring&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.frankel.ch&#x2F;annotation-free-spring&#x2F;</a><p>Granted, they may not be used much, but if you have an existing application it&#x27;s probably easier to migrate away from the annotations than to switch to a different framework altogether.</div><br/></div></div><div id="37196687" class="c"><input type="checkbox" id="c-37196687" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#37195289">root</a><span>|</span><a href="#37195592">parent</a><span>|</span><a href="#37195896">prev</a><span>|</span><a href="#37192415">next</a><span>|</span><label class="collapse" for="c-37196687">[-]</label><label class="expand" for="c-37196687">[1 more]</label></div><br/><div class="children"><div class="content">Servlets existed before annotations, so no, you are wrong.</div><br/></div></div></div></div></div></div><div id="37192415" class="c"><input type="checkbox" id="c-37192415" checked=""/><div class="controls bullet"><span class="by">pandemic_region</span><span>|</span><a href="#37195289">prev</a><span>|</span><a href="#37191756">next</a><span>|</span><label class="collapse" for="c-37192415">[-]</label><label class="expand" for="c-37192415">[28 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not really grokking the code sample on their frontpage. What is it doing? Explain it like I am a Java developer with 18 years of experience.</div><br/><div id="37192478" class="c"><input type="checkbox" id="c-37192478" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37192415">parent</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37192478">[-]</label><label class="expand" for="c-37192478">[26 more]</label></div><br/><div class="children"><div class="content">It&#x27;s referencing other variables and functions that aren&#x27;t defined in that snippet. Presumably you can somewhat guess what it&#x27;s trying to do (call a function for each element of the response), but it doesn&#x27;t seem like a very good example. I also don&#x27;t quite understand how this utilises virtual threads effectively, isn&#x27;t the code still adding the elements of the list one at a time instead of concurrently?</div><br/><div id="37192518" class="c"><input type="checkbox" id="c-37192518" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192478">parent</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37192518">[-]</label><label class="expand" for="c-37192518">[25 more]</label></div><br/><div class="children"><div class="content">One at a time, not concurrently.</div><br/><div id="37192552" class="c"><input type="checkbox" id="c-37192552" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192518">parent</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37192552">[-]</label><label class="expand" for="c-37192552">[24 more]</label></div><br/><div class="children"><div class="content">so what&#x27;s the point? we can already write blocking code. The reason why people want to use reactive frameworks is because they don&#x27;t want to block threads just because some I&#x2F;O is happening.</div><br/><div id="37195481" class="c"><input type="checkbox" id="c-37195481" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192552">parent</a><span>|</span><a href="#37192600">next</a><span>|</span><label class="collapse" for="c-37195481">[-]</label><label class="expand" for="c-37195481">[1 more]</label></div><br/><div class="children"><div class="content">Point is exactly you can block because blocking is cheap with virtual thread and can have 100&#x27;s of thousand block calls with exhausting all system resources. VT takes few KBs of memory instead of few MBs of memory, so plentiful of VT is a feature. With this one can write plain blocking code get benefit of async scalability but with simple APIs structure and debuggable sync code.</div><br/></div></div><div id="37192600" class="c"><input type="checkbox" id="c-37192600" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192552">parent</a><span>|</span><a href="#37195481">prev</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37192600">[-]</label><label class="expand" for="c-37192600">[22 more]</label></div><br/><div class="children"><div class="content">Nima uses virtual threads where blocking call blocks only the current virtual thread but not the underlying carrier-thread, which can run another virtual thread while waiting i&#x2F;o to complete.</div><br/><div id="37192669" class="c"><input type="checkbox" id="c-37192669" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192600">parent</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37192669">[-]</label><label class="expand" for="c-37192669">[21 more]</label></div><br/><div class="children"><div class="content">But in this example, the entire code is still blocking because it has to wait for one call of &quot;callRemote&quot; to complete while waiting for the next one to be executed. So I don&#x27;t get the point.<p><pre><code>  for (int i = 0; i &lt; count; i++) {
    resp.add(callRemote(client));
  }</code></pre></div><br/><div id="37193169" class="c"><input type="checkbox" id="c-37193169" checked=""/><div class="controls bullet"><span class="by">mikko-apo</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192669">parent</a><span>|</span><a href="#37192995">next</a><span>|</span><label class="collapse" for="c-37193169">[-]</label><label class="expand" for="c-37193169">[6 more]</label></div><br/><div class="children"><div class="content">Before virtual threads, Java server would reserve a full OS thread while that code is being processed. OS threads use lots of memory and there might a limited number available. With a single incoming request or low traffic that is not a problem, but with many parallel requests the server would choke on using too much memory or OS threads.<p>Previously in Java if you wanted to avoid code that blocks the OS thread you would need to use callback based code or reactive programming: <a href="https:&#x2F;&#x2F;www.alibabacloud.com&#x2F;blog&#x2F;how-java-is-used-for-asynchronous-non-blocking-programming_597808" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.alibabacloud.com&#x2F;blog&#x2F;how-java-is-used-for-async...</a><p>Javascript moved on from callbacks to async&#x2F;await, which colors the async functions and requires the programmer to be aware of the issues related to async&#x2F;await.<p>For Java Project Loom takes a different approach. For example with server applications, the server would start running the code in a virtual thread and most of the code that looks like blocking will actually work like unblocking code. You get to use regular blocking code but you get async performance.<p>When the code needs to wait for a response, JVM can unmount the virtual thread from the OS thread and then the JVM can run another virtual thread in the OS thread. Once the response is returned and the OS thread is free, JVM can continue executing the original request.<p>There are some caveats to virtual threads. There is some overhead (but not a lot), some IO calls still block (but you don&#x27;t get an indication about using blocking IO) and you might stumble on new kinds of bugs related to resource exhaustion (try reserving a million OS file handles).<p>But no more async&#x2F;await, reactive programming, callbacks. Mostly just regular imperative blocking-looking code. I&#x27;m very excited about that.</div><br/><div id="37194987" class="c"><input type="checkbox" id="c-37194987" checked=""/><div class="controls bullet"><span class="by">fnord77</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37193169">parent</a><span>|</span><a href="#37192995">next</a><span>|</span><label class="collapse" for="c-37194987">[-]</label><label class="expand" for="c-37194987">[5 more]</label></div><br/><div class="children"><div class="content">what are the issues with async&#x2F;await?</div><br/><div id="37196979" class="c"><input type="checkbox" id="c-37196979" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37194987">parent</a><span>|</span><a href="#37195966">next</a><span>|</span><label class="collapse" for="c-37196979">[-]</label><label class="expand" for="c-37196979">[1 more]</label></div><br/><div class="children"><div class="content">Because that&#x27;s what &quot;blocking&quot; calls were invented to avoid.</div><br/></div></div><div id="37195966" class="c"><input type="checkbox" id="c-37195966" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37194987">parent</a><span>|</span><a href="#37196979">prev</a><span>|</span><a href="#37192995">next</a><span>|</span><label class="collapse" for="c-37195966">[-]</label><label class="expand" for="c-37195966">[3 more]</label></div><br/><div class="children"><div class="content">the mental gymnastics.<p>Having fun using async&#x2F;await in loops?
<a href="https:&#x2F;&#x2F;zellwk.com&#x2F;blog&#x2F;async-await-in-loops&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;zellwk.com&#x2F;blog&#x2F;async-await-in-loops&#x2F;</a><p>An actual blocking model is much easier to grok.</div><br/><div id="37196343" class="c"><input type="checkbox" id="c-37196343" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37195966">parent</a><span>|</span><a href="#37192995">next</a><span>|</span><label class="collapse" for="c-37196343">[-]</label><label class="expand" for="c-37196343">[2 more]</label></div><br/><div class="children"><div class="content">Things don’t have to be that way. You can reject the use of async&#x2F;await in contexts that aren’t aware of it (delegating it to special APIs that properly handle it).</div><br/><div id="37197024" class="c"><input type="checkbox" id="c-37197024" checked=""/><div class="controls bullet"><span class="by">mikko-apo</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37196343">parent</a><span>|</span><a href="#37192995">next</a><span>|</span><label class="collapse" for="c-37197024">[-]</label><label class="expand" for="c-37197024">[1 more]</label></div><br/><div class="children"><div class="content">Can you elaborate? Do you mean like the Promise API with the &quot;spesialisti APIs&quot;?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37192995" class="c"><input type="checkbox" id="c-37192995" checked=""/><div class="controls bullet"><span class="by">emccue</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192669">parent</a><span>|</span><a href="#37193169">prev</a><span>|</span><a href="#37192711">next</a><span>|</span><label class="collapse" for="c-37192995">[-]</label><label class="expand" for="c-37192995">[2 more]</label></div><br/><div class="children"><div class="content">A better example would be<p><pre><code>    var remoteResultA = callRemoteA(client);
    var remoteResultB = callRemoteB(f(remoteResultA));
</code></pre>
Where handling a request means you have to make two http calls and those two calls have some order dependence. I.E. the result of one is used to construct the call to get the other.<p>What virtual threads give is the ability to write the code like I did above and still get ideal performance, as opposed to.<p><pre><code>    callRemoteA(client)
       .then(remoteResultA -&gt; callRemoteB(f(remoteResultA)))
       .then(... your world lives here now ...);
</code></pre>
Virtual threads are, from a language semantics point of view, the same as regular threads. Virtual threads map maybe 10000 &quot;logical threads&quot; to a handful (maybe 8 or so) actual operating system threads.<p>The big difference is that for each regular Thread you have exactly one backing Operating System thread.</div><br/><div id="37193037" class="c"><input type="checkbox" id="c-37193037" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192995">parent</a><span>|</span><a href="#37192711">next</a><span>|</span><label class="collapse" for="c-37193037">[-]</label><label class="expand" for="c-37193037">[1 more]</label></div><br/><div class="children"><div class="content">I agree that this would be a better example that would make more sense (and I also think that the reasoning you provided should be added as context to that code snippet).</div><br/></div></div></div></div><div id="37192711" class="c"><input type="checkbox" id="c-37192711" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192669">parent</a><span>|</span><a href="#37192995">prev</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37192711">[-]</label><label class="expand" for="c-37192711">[12 more]</label></div><br/><div class="children"><div class="content">That entire section is running on a virtual thread, which is scheduled on a platform (OS) thread. While it blocks for each callRemote invocation the platform thread is free to process other virtual threads.<p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;20&#x2F;core&#x2F;virtual-threads.html#GUID-DC4306FC-D6C1-4BCC-AECE-48C32C1A8DAA" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;20&#x2F;core&#x2F;virtual-threa...</a></div><br/><div id="37192888" class="c"><input type="checkbox" id="c-37192888" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192711">parent</a><span>|</span><a href="#37192770">next</a><span>|</span><label class="collapse" for="c-37192888">[-]</label><label class="expand" for="c-37192888">[1 more]</label></div><br/><div class="children"><div class="content">In addition, this implementation detail might help in gaining some insight: &quot;The synchronous networking Java APIs, when run in a virtual thread, switch the underlying native socket into non-blocking mode. When an I&#x2F;O operation invoked from Java code does not complete immediately (the native socket returns EAGAIN - “not ready” &#x2F; “would block”), the underlying native socket is registered with a JVM-wide event notification mechanism (a Poller), and the virtual thread is parked. When the underlying I&#x2F;O operation is ready (an event arrives at the Poller), the virtual thread is unparked and the underlying socket operation is retried.&quot;<p><a href="https:&#x2F;&#x2F;inside.java&#x2F;2021&#x2F;05&#x2F;10&#x2F;networking-io-with-virtual-threads&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;inside.java&#x2F;2021&#x2F;05&#x2F;10&#x2F;networking-io-with-virtual-th...</a></div><br/></div></div><div id="37192770" class="c"><input type="checkbox" id="c-37192770" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192711">parent</a><span>|</span><a href="#37192888">prev</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37192770">[-]</label><label class="expand" for="c-37192770">[10 more]</label></div><br/><div class="children"><div class="content">Yeah but if for some reason, no other (or few other) request is coming in concurrently, then the CPU will just sit by idly. I don&#x27;t understand why you wouldn&#x27;t issue the &quot;callRemote&quot; calls concurrently, that seems like it&#x27;s missing the point of writing non-blocking code.</div><br/><div id="37192820" class="c"><input type="checkbox" id="c-37192820" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192770">parent</a><span>|</span><a href="#37193623">next</a><span>|</span><label class="collapse" for="c-37192820">[-]</label><label class="expand" for="c-37192820">[7 more]</label></div><br/><div class="children"><div class="content">Exactly. That&#x27;s the point. It is beneficial only when you have a huge number of requests relative to the number of platform threads.<p>The idea is that you can map a million of these virtual threads on to a small number of platform threads, and the JVM will schedule the work for you, to achieve maximum throughput without needing to write any complicated code. Virtual threads are for high throughput on concurrent blocking requests.<p>EDIT: the sequential calls to &quot;callRemote&quot; still process in sequence, blocking on each call. Don&#x27;t get confused there. But the overall HTTP request itself is running on a virtual thread and does not block other HTTP requests while waiting for the callRemote invocations to complete.</div><br/><div id="37192994" class="c"><input type="checkbox" id="c-37192994" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192820">parent</a><span>|</span><a href="#37193623">next</a><span>|</span><label class="collapse" for="c-37192994">[-]</label><label class="expand" for="c-37192994">[6 more]</label></div><br/><div class="children"><div class="content">&gt; EDIT: the sequential calls to &quot;callRemote&quot; still process in sequence, blocking on each call. Don&#x27;t get confused there. But the overall HTTP request itself is running on a virtual thread and does not block other HTTP requests while waiting for the callRemote invocations to complete.<p>Yeah I got that. But then the use case seems to be much narrower, because not every scenario is one where many concurrent requests come in at the same time. If you write non-blocking code you&#x27;ll get high throughput no matter the number of requests. Ok, maybe non-blocking code is harder to write (and I don&#x27;t think it&#x27;s actually that hard if you use, say, Kotlin coroutines), but honestly this seems to me like something that developers should learn eventually anyway.<p>Or maybe it&#x27;s me being weird. But I remember 10 years ago when node.js was being hyped for being &quot;fast&quot; because it was &quot;async&quot; and now suddenly using threads and blocking operations is again all the rage now.</div><br/><div id="37193146" class="c"><input type="checkbox" id="c-37193146" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192994">parent</a><span>|</span><a href="#37193623">next</a><span>|</span><label class="collapse" for="c-37193146">[-]</label><label class="expand" for="c-37193146">[5 more]</label></div><br/><div class="children"><div class="content">The difference now is that it&#x27;s implemented in the JVM instead of a library &#x2F; framework. It is easier, simpler, and probably more efficient. You can get higher throughput from existing code with minor refactoring.<p><pre><code>  Thread thread = Thread.ofVirtual().start(() -&gt; System.out.println(&quot;Hello&quot;));
  thread.join();</code></pre></div><br/><div id="37193515" class="c"><input type="checkbox" id="c-37193515" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37193146">parent</a><span>|</span><a href="#37193290">next</a><span>|</span><label class="collapse" for="c-37193515">[-]</label><label class="expand" for="c-37193515">[2 more]</label></div><br/><div class="children"><div class="content">Also there are some traceability issues involved in using asynchronous APIs: &quot;In the asynchronous style, each stage of a request might execute on a different thread, and every thread runs stages belonging to different requests in an interleaved fashion. This has deep implications for understanding program behavior: Stack traces provide no usable context, debuggers cannot step through request-handling logic, and profilers cannot associate an operation&#x27;s cost with its caller. &quot;<p><a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;444" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;444</a></div><br/><div id="37196360" class="c"><input type="checkbox" id="c-37196360" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37193515">parent</a><span>|</span><a href="#37193290">next</a><span>|</span><label class="collapse" for="c-37196360">[-]</label><label class="expand" for="c-37196360">[1 more]</label></div><br/><div class="children"><div class="content">In theory an async-aware runtime can stitch together a coherent and useful backtrace, but in practice most legacy tooling won’t :(</div><br/></div></div></div></div><div id="37193290" class="c"><input type="checkbox" id="c-37193290" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37193146">parent</a><span>|</span><a href="#37193515">prev</a><span>|</span><a href="#37193623">next</a><span>|</span><label class="collapse" for="c-37193290">[-]</label><label class="expand" for="c-37193290">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying that virtual threads aren&#x27;t a good thing (other runtimes than the JVM have had green threads for a very long time now), but that it doesn&#x27;t seem like such a paradigm shift. It&#x27;s still threads (with all the benefits and drawbacks), it&#x27;s just now that they have less overhead.<p>Presumably I could just keep an existing server written in Spring MVC or a similar technology and just wait for the underlying container to support virtual threads to get the same benefits. I believe Jetty already does support them. So why would I need a new framework?</div><br/><div id="37193411" class="c"><input type="checkbox" id="c-37193411" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37193290">parent</a><span>|</span><a href="#37193623">next</a><span>|</span><label class="collapse" for="c-37193411">[-]</label><label class="expand" for="c-37193411">[1 more]</label></div><br/><div class="children"><div class="content">It removes the need to write async code in many cases. It is a more straightforward and efficient way to accomplish what we have already been doing for years on the JVM.<p>You don&#x27;t need to switch frameworks<p><a href="https:&#x2F;&#x2F;spring.io&#x2F;blog&#x2F;2022&#x2F;10&#x2F;11&#x2F;embracing-virtual-threads" rel="nofollow noreferrer">https:&#x2F;&#x2F;spring.io&#x2F;blog&#x2F;2022&#x2F;10&#x2F;11&#x2F;embracing-virtual-threads</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="37193623" class="c"><input type="checkbox" id="c-37193623" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192770">parent</a><span>|</span><a href="#37192820">prev</a><span>|</span><a href="#37193362">next</a><span>|</span><label class="collapse" for="c-37193623">[-]</label><label class="expand" for="c-37193623">[1 more]</label></div><br/><div class="children"><div class="content">You certainly could make the callRemote calls in parallel, and there are easy and safe ways to do that (good old CompletableFuture or the new structured concurrency stuff). But doing that or not is completely independent of using Nima, so I think here they&#x27;re just showing some very simple code, because this is an example of using Nima, not an example of writing concurrent code in general.</div><br/></div></div><div id="37193362" class="c"><input type="checkbox" id="c-37193362" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#37192415">root</a><span>|</span><a href="#37192770">parent</a><span>|</span><a href="#37193623">prev</a><span>|</span><a href="#37192500">next</a><span>|</span><label class="collapse" for="c-37193362">[-]</label><label class="expand" for="c-37193362">[1 more]</label></div><br/><div class="children"><div class="content">Because concurrent calls are confusing and create bugs.<p>The point this train wreck of an example is trying to make (and failing) is that it&#x27;s fine to write sequential blocking code in your request handlers. They can take as long as they want ... seconds, minutes, days .... because the handler threads are now an infinite resource as far as the JVM is concerned.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37192500" class="c"><input type="checkbox" id="c-37192500" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37192415">parent</a><span>|</span><a href="#37192478">prev</a><span>|</span><a href="#37191756">next</a><span>|</span><label class="collapse" for="c-37192500">[-]</label><label class="expand" for="c-37192500">[1 more]</label></div><br/><div class="children"><div class="content">&quot;callRemote&quot; simulates a blocking outbound http-call.</div><br/></div></div></div></div><div id="37191756" class="c"><input type="checkbox" id="c-37191756" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37192415">prev</a><span>|</span><a href="#37192996">next</a><span>|</span><label class="collapse" for="c-37191756">[-]</label><label class="expand" for="c-37191756">[41 more]</label></div><br/><div class="children"><div class="content">I am looking forwarding to trying Nima. The blocker for me is IntelliJ supporting Java 21, which i believe will be this winter [1]; i don&#x27;t absolutely need IntelliJ, but i am very lazy.<p>At the moment, my apps are using either the JDK HttpServer, which is easy to use, but of questionable robustness and lacking websocket support, or a Netty-based server, which works very well and supports websockets, but is often awkward to program against because it&#x27;s asynchronous. Nima should combine a nice simple synchronous API with a fairly luxurious feature set and good scalability.<p>Of course, it will turn out there are things terribly wrong with it, because this is real life. But for now i&#x27;m optimistic!<p>[1] <a href="https:&#x2F;&#x2F;intellij-support.jetbrains.com&#x2F;hc&#x2F;en-us&#x2F;community&#x2F;posts&#x2F;13049784815250-Planned-release-date-of-2023-3-with-Java-21-support" rel="nofollow noreferrer">https:&#x2F;&#x2F;intellij-support.jetbrains.com&#x2F;hc&#x2F;en-us&#x2F;community&#x2F;po...</a></div><br/><div id="37197288" class="c"><input type="checkbox" id="c-37197288" checked=""/><div class="controls bullet"><span class="by">re-thc</span><span>|</span><a href="#37191756">parent</a><span>|</span><a href="#37195013">next</a><span>|</span><label class="collapse" for="c-37197288">[-]</label><label class="expand" for="c-37197288">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The blocker for me is IntelliJ supporting Java 21<p>Pretty sure this works with Java 20 with the loom previewed enabled.</div><br/></div></div><div id="37195013" class="c"><input type="checkbox" id="c-37195013" checked=""/><div class="controls bullet"><span class="by">SpaghettiCthulu</span><span>|</span><a href="#37191756">parent</a><span>|</span><a href="#37197288">prev</a><span>|</span><a href="#37192388">next</a><span>|</span><label class="collapse" for="c-37195013">[-]</label><label class="expand" for="c-37195013">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using intellij to write code that uses a Java 21 or 22 dev build for months. Do you perhaps mean support for running the IDE itself on Java 21?</div><br/><div id="37195622" class="c"><input type="checkbox" id="c-37195622" checked=""/><div class="controls bullet"><span class="by">gbear605</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37195013">parent</a><span>|</span><a href="#37192388">next</a><span>|</span><label class="collapse" for="c-37195622">[-]</label><label class="expand" for="c-37195622">[1 more]</label></div><br/><div class="children"><div class="content">IntelliJ doesn’t have support for Java 21 syntax features, right? I tried running a dev build, but I couldn’t get it to work.</div><br/></div></div></div></div><div id="37192388" class="c"><input type="checkbox" id="c-37192388" checked=""/><div class="controls bullet"><span class="by">Two4</span><span>|</span><a href="#37191756">parent</a><span>|</span><a href="#37195013">prev</a><span>|</span><a href="#37193332">next</a><span>|</span><label class="collapse" for="c-37192388">[-]</label><label class="expand" for="c-37192388">[8 more]</label></div><br/><div class="children"><div class="content">Non-MicroProfile Helidon uses a reactive interface for most things, which lends itself well to async operations. It a very nice, simple and powerful abstraction that makes async relatively easy. IMO anything webserver or client should be async when virtual threads aren&#x27;t available, due to Java having the tendency to quickly build up a ton of threads when you use the one-thread-per-request model. That being said, virtual threads does make that model viable at scale, so reactive async probably isn&#x27;t as necessary.</div><br/><div id="37193649" class="c"><input type="checkbox" id="c-37193649" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192388">parent</a><span>|</span><a href="#37195910">next</a><span>|</span><label class="collapse" for="c-37193649">[-]</label><label class="expand" for="c-37193649">[1 more]</label></div><br/><div class="children"><div class="content">Reactive APIs are horrible, and precisely what I&#x27;m trying to avoid.</div><br/></div></div><div id="37195910" class="c"><input type="checkbox" id="c-37195910" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192388">parent</a><span>|</span><a href="#37193649">prev</a><span>|</span><a href="#37193974">next</a><span>|</span><label class="collapse" for="c-37195910">[-]</label><label class="expand" for="c-37195910">[1 more]</label></div><br/><div class="children"><div class="content">Helidon 4 is massive refactoring to support Java 21&#x2F; virtual thread from grounds up to the point that most reactive stuff is removed and replaced plain sync APIs.</div><br/></div></div><div id="37193974" class="c"><input type="checkbox" id="c-37193974" checked=""/><div class="controls bullet"><span class="by">Svenskunganka</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192388">parent</a><span>|</span><a href="#37195910">prev</a><span>|</span><a href="#37192469">next</a><span>|</span><label class="collapse" for="c-37193974">[-]</label><label class="expand" for="c-37193974">[2 more]</label></div><br/><div class="children"><div class="content">The main problem I have with reactive programming in Java, at least with Project Reactor which is the only one I&#x27;ve used is the cryptic stack traces. You can regain some information by enabling runtime instrumentation to be used in development, but has too much of a performance hit to be used in production. It doesn&#x27;t produce much better stack traces either. Trying to read a profiler flamegraph is nigh impossible for reactive code. For the debugger, you need to manually insert breakpoints in each step of the chain, because otherwise you&#x27;ll just be looking around the reactive library&#x27;s internal code.<p>The other problems I have is that as soon as you need to do anything blocking (e.g talking to SQLite or RocksDB over JNI), the whole thing falls apart in terms of threading. Doing a HTTP request somewhere in a reactive chain that does some blocking operations - well shit now you&#x27;re blocking the reactor-http-netty-* threads, which are fixed so you&#x27;re worse off than with thread-per-request at that point. Or even just using Caffeine cache, or any caching library really, but Caffeine is one of few that prevents async stampede - well shit now you&#x27;re running on ForkJoin pool during cache misses, but &quot;reactive&quot; threads on cache hits. You can see how this quickly becomes a tangled mess of thread-hopping and avoiding blocking event loops, and it&#x27;s extremely complicated to get this right with how subscribeOn&#x2F;publishOn works and how the profiler can&#x27;t tell you which threads runs what code because the stack traces are filled with garbage.<p>You also opt out of a lot of what Java offers in terms of synchronization. Using the synchronization keyword is a big no-no, the JVM can park the thread while waiting for the lock. Now that thread cannot schedule other tasks just because that one task ran into lock contention, and it&#x27;s highly likely a fixed pool of threads. You&#x27;re basically left with CAS, AtomicLong&#x2F;AtomicBoolean&#x2F;etc, and that&#x27;s it. I&#x27;ve even seen BlockHound, project reactor&#x27;s tool to help you find if you are blocking somewhere, trigger &quot;Blocking call to LockSupport.park()!&quot; during a ConcurrentHashMap lookup. Add to this that most caching libraries are implemented on top of ConcurrentHashMap. Getting async right in reactive code has a huge mental overhead and you need intricate knowledge of the libraries you depend on, the platform you run on and what it is that actually enables async in the kernel, and where it is unavailable. Good example of this; that UUID library you use uses a CSPRNG. Have you set the JVM flag to read it from the non-blocking &#x2F;dev&#x2F;urandom rather than the default &#x2F;dev&#x2F;random on Linux?<p>I think reactive programming in Java is decent as long as all you&#x27;re really doing is accepting&#x2F;performing HTTP requests and talking to a database that has a reactive client connector. In essence, anything that strictly deals with networking, since that&#x27;s all that can really be made truly async currently, thanks to epoll&#x2F;kqueue&#x2F;iocp on linux&#x2F;mac&#x2F;windows respectively. Hopefully io_uring will broaden that to file IO as well eventually, but unfortunately that&#x27;s linux-only for now.<p>Contrast this with Go&#x27;s scheduler that just takes care of this for you - no need to think about it. Or Rust + Tokio, where it is explicit with tokio::spawn_blocking and offering async counterparts to std Mutex, RWLock, Channels, etc that doesn&#x27;t block the current thread on lock contention.</div><br/><div id="37194286" class="c"><input type="checkbox" id="c-37194286" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193974">parent</a><span>|</span><a href="#37192469">next</a><span>|</span><label class="collapse" for="c-37194286">[-]</label><label class="expand" for="c-37194286">[1 more]</label></div><br/><div class="children"><div class="content">not to distract from your valid points but, when used properly, Caffeine + Reactor can work together really nicely [1].<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;blob&#x2F;master&#x2F;examples&#x2F;coalescing-bulkloader-reactor&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;ben-manes&#x2F;caffeine&#x2F;blob&#x2F;master&#x2F;examples&#x2F;c...</a></div><br/></div></div></div></div><div id="37192469" class="c"><input type="checkbox" id="c-37192469" checked=""/><div class="controls bullet"><span class="by">strangemonad</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192388">parent</a><span>|</span><a href="#37193974">prev</a><span>|</span><a href="#37193332">next</a><span>|</span><label class="collapse" for="c-37192469">[-]</label><label class="expand" for="c-37192469">[3 more]</label></div><br/><div class="children"><div class="content">I’ve had no problems scaling jetty to 400-500 qps per node on small thread pools.</div><br/><div id="37193031" class="c"><input type="checkbox" id="c-37193031" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192469">parent</a><span>|</span><a href="#37193282">next</a><span>|</span><label class="collapse" for="c-37193031">[-]</label><label class="expand" for="c-37193031">[1 more]</label></div><br/><div class="children"><div class="content">Jetty can be used with virtual threads: <a href="https:&#x2F;&#x2F;webtide.com&#x2F;jetty-12-virtual-threads-support&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;webtide.com&#x2F;jetty-12-virtual-threads-support&#x2F;</a></div><br/></div></div><div id="37193282" class="c"><input type="checkbox" id="c-37193282" checked=""/><div class="controls bullet"><span class="by">Two4</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192469">parent</a><span>|</span><a href="#37193031">prev</a><span>|</span><a href="#37193332">next</a><span>|</span><label class="collapse" for="c-37193282">[-]</label><label class="expand" for="c-37193282">[1 more]</label></div><br/><div class="children"><div class="content">As soon as you start talking thread pools, you&#x27;re talking about async task dispatching at some level, even if it&#x27;s abstracted away at the API level. What I&#x27;m talking about is using a virtual thread, not event-driven shuttling of stateful objects between threads via task queues, to complete a request from start to finish.</div><br/></div></div></div></div></div></div><div id="37193332" class="c"><input type="checkbox" id="c-37193332" checked=""/><div class="controls bullet"><span class="by">gbear605</span><span>|</span><a href="#37191756">parent</a><span>|</span><a href="#37192388">prev</a><span>|</span><a href="#37192389">next</a><span>|</span><label class="collapse" for="c-37193332">[-]</label><label class="expand" for="c-37193332">[2 more]</label></div><br/><div class="children"><div class="content">The IntelliJ Early Access Program will be out sometime before then, if you’re willing to go for a potentially unstable IDE experience.</div><br/><div id="37194606" class="c"><input type="checkbox" id="c-37194606" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193332">parent</a><span>|</span><a href="#37192389">next</a><span>|</span><label class="collapse" for="c-37194606">[-]</label><label class="expand" for="c-37194606">[1 more]</label></div><br/><div class="children"><div class="content">I feel like i have a sufficiently unstable IDE experience using the general availability releases!</div><br/></div></div></div></div><div id="37192389" class="c"><input type="checkbox" id="c-37192389" checked=""/><div class="controls bullet"><span class="by">skinowski</span><span>|</span><a href="#37191756">parent</a><span>|</span><a href="#37193332">prev</a><span>|</span><a href="#37192996">next</a><span>|</span><label class="collapse" for="c-37192389">[-]</label><label class="expand" for="c-37192389">[27 more]</label></div><br/><div class="children"><div class="content">This is one of the things that bother me about Java; IDE dependency.</div><br/><div id="37192589" class="c"><input type="checkbox" id="c-37192589" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192389">parent</a><span>|</span><a href="#37194164">next</a><span>|</span><label class="collapse" for="c-37192589">[-]</label><label class="expand" for="c-37192589">[5 more]</label></div><br/><div class="children"><div class="content">IDE productivity, and it started with Smalltalk and Lisp Machines, was adopted by C++, Visual Basic and Delphi, among several 4GLs, several years before Java was invented.<p>Everyone is free to use Java in vi with make, if they feel happy doing so.<p>In fact, there were hardly any Java IDEs when the language was released in 1996, which were quickly provided by Smalltalk, Delphi and C++ vendors.</div><br/><div id="37196368" class="c"><input type="checkbox" id="c-37196368" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192589">parent</a><span>|</span><a href="#37194164">next</a><span>|</span><label class="collapse" for="c-37196368">[-]</label><label class="expand" for="c-37196368">[4 more]</label></div><br/><div class="children"><div class="content">Java is somewhat unique in how annoying the typical project is to work on without an IDE.</div><br/><div id="37196591" class="c"><input type="checkbox" id="c-37196591" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37196368">parent</a><span>|</span><a href="#37194164">next</a><span>|</span><label class="collapse" for="c-37196591">[-]</label><label class="expand" for="c-37196591">[3 more]</label></div><br/><div class="children"><div class="content">All languages are annoying to use without IDEs, unless we are talking about toy implementations.<p>I became an XEmacs user in 1995, because everything else in UNIX just sucked in comparison with PC, Mac OS and Amiga IDEs of the time.</div><br/><div id="37197016" class="c"><input type="checkbox" id="c-37197016" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37196591">parent</a><span>|</span><a href="#37194164">next</a><span>|</span><label class="collapse" for="c-37197016">[-]</label><label class="expand" for="c-37197016">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked on plenty of projects where I can navigate around in a pretty dumb text editor and run &quot;make&quot; and things mostly work. In Java land most things are several folders deep and things are injected in from places I don&#x27;t understand without tooling to show me what is going on. I mean, have you tried using jdb? It basically exists as an advertisement for an integrated debugger.</div><br/><div id="37197270" class="c"><input type="checkbox" id="c-37197270" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37197016">parent</a><span>|</span><a href="#37194164">next</a><span>|</span><label class="collapse" for="c-37197270">[-]</label><label class="expand" for="c-37197270">[1 more]</label></div><br/><div class="children"><div class="content">That is what many call gdb as well, so it isn&#x27;t far off.<p>As for messy code navigation, I have similar experiences in large C codebases, so maybe C is also unusable without IDEs.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37194164" class="c"><input type="checkbox" id="c-37194164" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192389">parent</a><span>|</span><a href="#37192589">prev</a><span>|</span><a href="#37192616">next</a><span>|</span><label class="collapse" for="c-37194164">[-]</label><label class="expand" for="c-37194164">[5 more]</label></div><br/><div class="children"><div class="content">Thats because Java IDE&#x27;s are <i>ridiculously</i> powerful. When I work in vscode and Python, I am always like: This is so much easier when I am using Java and Intellij.<p>It is not mere IDE <i>Dependency</i>. It is IDE <i>Supremacy</i>. Java  is the leader of the IDE master race - the other PL IDE&#x27;s need to squint to see how far ahead Java IDE&#x27;s are.</div><br/><div id="37195751" class="c"><input type="checkbox" id="c-37195751" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194164">parent</a><span>|</span><a href="#37194712">next</a><span>|</span><label class="collapse" for="c-37195751">[-]</label><label class="expand" for="c-37195751">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is not mere IDE Dependency. It is IDE Supremacy.<p>Just like how our current civilization is dependent on industrialized agriculture and distribution systems.<p>We cannot imagine how it would be possible to live without those functions. In a way, yes, it is &quot;supremacy&quot;, but only if you have access.</div><br/></div></div><div id="37194712" class="c"><input type="checkbox" id="c-37194712" checked=""/><div class="controls bullet"><span class="by">skinowski</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194164">parent</a><span>|</span><a href="#37195751">prev</a><span>|</span><a href="#37196630">next</a><span>|</span><label class="collapse" for="c-37194712">[-]</label><label class="expand" for="c-37194712">[2 more]</label></div><br/><div class="children"><div class="content">This is a fair point.<p>I&#x27;ve seen many frameworks shared in hackernews. But rarely do I see
anyone commenting on their IDE&#x27;s capability to be able to use that framework for go-lang, rust, c, c++, etc.<p>For example, Rust tokio 1.0:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25520353">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25520353</a><p>I don&#x27;t see anyone mentioning an IDE there.</div><br/><div id="37196720" class="c"><input type="checkbox" id="c-37196720" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194712">parent</a><span>|</span><a href="#37196630">next</a><span>|</span><label class="collapse" for="c-37196720">[-]</label><label class="expand" for="c-37196720">[1 more]</label></div><br/><div class="children"><div class="content">Because they tend to be on the stone age of tooling.<p>In what concerns C++, have a look at VCL, Firemonkey, Qt, Unreal, Godot, DirectX, Metal,...<p>All Apple frameworks for Objective-C and Swift.</div><br/></div></div></div></div><div id="37196630" class="c"><input type="checkbox" id="c-37196630" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194164">parent</a><span>|</span><a href="#37194712">prev</a><span>|</span><a href="#37192616">next</a><span>|</span><label class="collapse" for="c-37196630">[-]</label><label class="expand" for="c-37196630">[1 more]</label></div><br/><div class="children"><div class="content">While true, Smalltalk, Common Lisp and .NET are also part of the party.</div><br/></div></div></div></div><div id="37192616" class="c"><input type="checkbox" id="c-37192616" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192389">parent</a><span>|</span><a href="#37194164">prev</a><span>|</span><a href="#37192750">next</a><span>|</span><label class="collapse" for="c-37192616">[-]</label><label class="expand" for="c-37192616">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not so much that you can&#x27;t do Java without an IDE—Java is verbose in part because it doesn&#x27;t assume that you have an IDE to give you context—it&#x27;s that IntelliJ is such a good IDE that it&#x27;s hard to go back to weaker tooling once you&#x27;ve become comfortable with it.<p>All my co-workers use VS Code for TypeScript, but I feel crippled when I can&#x27;t use WebStorm. Not because I can&#x27;t program without it, but because I&#x27;m missing a powerful force multiplier.</div><br/><div id="37195114" class="c"><input type="checkbox" id="c-37195114" checked=""/><div class="controls bullet"><span class="by">ElectricalUnion</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192616">parent</a><span>|</span><a href="#37192750">next</a><span>|</span><label class="collapse" for="c-37195114">[-]</label><label class="expand" for="c-37195114">[2 more]</label></div><br/><div class="children"><div class="content">I used to think that WebStorm was terrible for refactoring; but somehow it&#x27;s still very far ahead of other editors like vscode, and vscode itself is very far ahead of almost everything else too.</div><br/><div id="37195296" class="c"><input type="checkbox" id="c-37195296" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37195114">parent</a><span>|</span><a href="#37192750">next</a><span>|</span><label class="collapse" for="c-37195296">[-]</label><label class="expand" for="c-37195296">[1 more]</label></div><br/><div class="children"><div class="content">WebStorm is worse than IntelliJ Java, but that&#x27;s because TypeScript is much harder to statically analyze. There are fewer safe refactorings in a language that has so much flexibility.</div><br/></div></div></div></div></div></div><div id="37192750" class="c"><input type="checkbox" id="c-37192750" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192389">parent</a><span>|</span><a href="#37192616">prev</a><span>|</span><a href="#37193219">next</a><span>|</span><label class="collapse" for="c-37192750">[-]</label><label class="expand" for="c-37192750">[8 more]</label></div><br/><div class="children"><div class="content">No it is straightforward to setup a Maven project manually and use Vim if that&#x27;s your preference.</div><br/><div id="37193436" class="c"><input type="checkbox" id="c-37193436" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192750">parent</a><span>|</span><a href="#37193219">next</a><span>|</span><label class="collapse" for="c-37193436">[-]</label><label class="expand" for="c-37193436">[7 more]</label></div><br/><div class="children"><div class="content">But then they complain they had to manually type an import statement ... before going back to their opinionating on how bad IDEs are.<p>I find the whole notion of software engineers rejecting software applications being useful as a concept while it being the primary focus of their own profession quite fascinating.</div><br/><div id="37194049" class="c"><input type="checkbox" id="c-37194049" checked=""/><div class="controls bullet"><span class="by">skinowski</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193436">parent</a><span>|</span><a href="#37193759">next</a><span>|</span><label class="collapse" for="c-37194049">[-]</label><label class="expand" for="c-37194049">[5 more]</label></div><br/><div class="children"><div class="content">If a developer does not want to try this framework because an IDE
does not yet support a particular version of java, then the situation
has gone beyond an IDE being just useful.<p>Personally I use various IDEs, light weight IDE&#x2F;Editors and even vi&#x2F;vim
depending on the language &amp; situation.<p>Think of it this way:<p>If I asked my team to develop a project&#x2F;POC with this framework and they
came back to me saying that they have to wait for (or prefer to wait for,
or whatever) jet brains to add java 21 support to do this,
I would not be very happy.</div><br/><div id="37195317" class="c"><input type="checkbox" id="c-37195317" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194049">parent</a><span>|</span><a href="#37194579">next</a><span>|</span><label class="collapse" for="c-37195317">[-]</label><label class="expand" for="c-37195317">[1 more]</label></div><br/><div class="children"><div class="content">JDK21 hasn&#x27;t even hit general availability yet according to its own schedule [0]. It seems a little impatient to get upset that tooling isn&#x27;t 100% there before it&#x27;s even released. Naturally tool vendors aren&#x27;t going to release their official support until they can test against the final version. This indeed is part of the maturity people do like about the Java ecosystem.<p>[0] <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;projects&#x2F;jdk&#x2F;21&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;projects&#x2F;jdk&#x2F;21&#x2F;</a></div><br/></div></div><div id="37194579" class="c"><input type="checkbox" id="c-37194579" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194049">parent</a><span>|</span><a href="#37195317">prev</a><span>|</span><a href="#37193759">next</a><span>|</span><label class="collapse" for="c-37194579">[-]</label><label class="expand" for="c-37194579">[3 more]</label></div><br/><div class="children"><div class="content">So you&#x27;re saying that you are unhappy that Jetbrains doesn&#x27;t officially support JDK21 yet? Cool story bro. It&#x27;s a tool preference. Same deal with any other language. Nothing is preventing your developers writing code for JDK21 today, even with the Jetbrains IDE. You can write and compile JDK21 projects and ignore any related highlighted syntax&#x2F;semantic errors.</div><br/><div id="37194675" class="c"><input type="checkbox" id="c-37194675" checked=""/><div class="controls bullet"><span class="by">skinowski</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194579">parent</a><span>|</span><a href="#37193759">next</a><span>|</span><label class="collapse" for="c-37194675">[-]</label><label class="expand" for="c-37194675">[2 more]</label></div><br/><div class="children"><div class="content">Good job on distorting my comments. Hopefully the developer who
made the original comment will read your recommendations and
will decide to give this framework a try.</div><br/><div id="37194723" class="c"><input type="checkbox" id="c-37194723" checked=""/><div class="controls bullet"><span class="by">xcv123</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37194675">parent</a><span>|</span><a href="#37193759">next</a><span>|</span><label class="collapse" for="c-37194723">[-]</label><label class="expand" for="c-37194723">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m saying your comments basically boiled down to that. You are unhappy that developers might prefer a tool that doesn&#x27;t officially support newer features of a language, even though it doesn&#x27;t really prevent them developing with the new features using the same or different IDE or a text editor or whatever. Same deal with C# or C++ and every other language supported by IDE&#x27;s, hence C.S.B. This is an issue with programming in general, not Java specific.</div><br/></div></div></div></div></div></div></div></div><div id="37193759" class="c"><input type="checkbox" id="c-37193759" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193436">parent</a><span>|</span><a href="#37194049">prev</a><span>|</span><a href="#37193219">next</a><span>|</span><label class="collapse" for="c-37193759">[-]</label><label class="expand" for="c-37193759">[1 more]</label></div><br/><div class="children"><div class="content">There are some weirdly hair-shirt beliefs about development practices in this industry.</div><br/></div></div></div></div></div></div><div id="37193219" class="c"><input type="checkbox" id="c-37193219" checked=""/><div class="controls bullet"><span class="by">skinowski</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37192389">parent</a><span>|</span><a href="#37192750">prev</a><span>|</span><a href="#37192996">next</a><span>|</span><label class="collapse" for="c-37193219">[-]</label><label class="expand" for="c-37193219">[5 more]</label></div><br/><div class="children"><div class="content">If a developer says &quot;The blocker for me is IntelliJ supporting Java 21&quot;,
clearly there&#x27;s an IDE dependency. Powerful enough for a developer
not to adopt a new framework.</div><br/><div id="37196737" class="c"><input type="checkbox" id="c-37196737" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193219">parent</a><span>|</span><a href="#37193729">next</a><span>|</span><label class="collapse" for="c-37196737">[-]</label><label class="expand" for="c-37196737">[1 more]</label></div><br/><div class="children"><div class="content">Java 21 is expected to be released in two months....<p>Being a bit entitled regarding support of preview features.<p>If said developer is savy enough to use a preview SDK, they should be able to cope with the downsides of lacking all the nice support.</div><br/></div></div><div id="37193729" class="c"><input type="checkbox" id="c-37193729" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193219">parent</a><span>|</span><a href="#37196737">prev</a><span>|</span><a href="#37192996">next</a><span>|</span><label class="collapse" for="c-37193729">[-]</label><label class="expand" for="c-37193729">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s entirely possible to write Java without an IDE. I&#x27;ve done it, and one of my colleagues has been using VSCode quite happily (we&#x27;ve bullied him into stopping because it doesn&#x27;t have a formatter and he keeps checking in wonky code - but that&#x27;s another story).<p>But writing <i>any</i> language is much more productive with a good IDE. For me, the added value in using Java 21 now rather than in a few months is not enough to outweigh giving up the use of an IDE.</div><br/><div id="37195678" class="c"><input type="checkbox" id="c-37195678" checked=""/><div class="controls bullet"><span class="by">4RealFreedom</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193729">parent</a><span>|</span><a href="#37194709">next</a><span>|</span><label class="collapse" for="c-37195678">[-]</label><label class="expand" for="c-37195678">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;code.visualstudio.com&#x2F;docs&#x2F;java&#x2F;java-linting" rel="nofollow noreferrer">https:&#x2F;&#x2F;code.visualstudio.com&#x2F;docs&#x2F;java&#x2F;java-linting</a></div><br/></div></div><div id="37194709" class="c"><input type="checkbox" id="c-37194709" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#37191756">root</a><span>|</span><a href="#37193729">parent</a><span>|</span><a href="#37195678">prev</a><span>|</span><a href="#37192996">next</a><span>|</span><label class="collapse" for="c-37194709">[-]</label><label class="expand" for="c-37194709">[1 more]</label></div><br/><div class="children"><div class="content">&gt; keeps checking in wonky code<p>Time to add a format check to pre-merge CI.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37192996" class="c"><input type="checkbox" id="c-37192996" checked=""/><div class="controls bullet"><span class="by">canvascritic</span><span>|</span><a href="#37191756">prev</a><span>|</span><a href="#37191534">next</a><span>|</span><label class="collapse" for="c-37192996">[-]</label><label class="expand" for="c-37192996">[1 more]</label></div><br/><div class="children"><div class="content">Oooh this looks promising. Seeing helidon nima&#x27;s take on java microservices with virtual threads is certainly a different direction. Way way back, while working with a java microservices codebase, we were stuck with OJ (ObscuraJ, to be honest I&#x27;m not sure if it was publicly available or internal, was so many years ago) and that was pure hell. The configuration overhead, especially the cumbersome dynamic routing setup, and layers upon layers of indirection and dependency injection was a headache. níma&#x27;s approach piques my interest, albeit with a bit of caution, will need to dig into the source more</div><br/></div></div><div id="37191534" class="c"><input type="checkbox" id="c-37191534" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#37192996">prev</a><span>|</span><a href="#37193066">next</a><span>|</span><label class="collapse" for="c-37191534">[-]</label><label class="expand" for="c-37191534">[10 more]</label></div><br/><div class="children"><div class="content">This is a killer &quot;app&quot; for Java 21. There&#x27;s now little reason to choose Kotlin or some other language to build efficient API&#x27;s etc.</div><br/><div id="37195775" class="c"><input type="checkbox" id="c-37195775" checked=""/><div class="controls bullet"><span class="by">4RealFreedom</span><span>|</span><a href="#37191534">parent</a><span>|</span><a href="#37192752">next</a><span>|</span><label class="collapse" for="c-37195775">[-]</label><label class="expand" for="c-37195775">[2 more]</label></div><br/><div class="children"><div class="content">I write both Kotlin and Java but Kotlin is my go to. Kotlin&#x27;s when statements alone are a reason to use it. Then there&#x27;s the null safety, extension functions, built in lazy initialization, and smart casts. Kotlin is just a joy to write in.</div><br/><div id="37196319" class="c"><input type="checkbox" id="c-37196319" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37191534">root</a><span>|</span><a href="#37195775">parent</a><span>|</span><a href="#37192752">next</a><span>|</span><label class="collapse" for="c-37196319">[-]</label><label class="expand" for="c-37196319">[1 more]</label></div><br/><div class="children"><div class="content">Plus...Kotlin is compatible with Java, so even a small improvement can still be reason enough to use it</div><br/></div></div></div></div><div id="37192752" class="c"><input type="checkbox" id="c-37192752" checked=""/><div class="controls bullet"><span class="by">jfengel</span><span>|</span><a href="#37191534">parent</a><span>|</span><a href="#37195775">prev</a><span>|</span><a href="#37193066">next</a><span>|</span><label class="collapse" for="c-37192752">[-]</label><label class="expand" for="c-37192752">[7 more]</label></div><br/><div class="children"><div class="content">Was there ever? What made Kotlin fundamentally different in that respect?<p>Kotlin is great for fixing some legacy design oopsies (Java really should have been smarter about null and it can&#x27;t be fixed without breaking legacy code), but I wouldn&#x27;t expect it to do something that was impossible or it infeasible in Java.</div><br/><div id="37193459" class="c"><input type="checkbox" id="c-37193459" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#37191534">root</a><span>|</span><a href="#37192752">parent</a><span>|</span><a href="#37192797">next</a><span>|</span><label class="collapse" for="c-37193459">[-]</label><label class="expand" for="c-37193459">[3 more]</label></div><br/><div class="children"><div class="content">Yes from a pure functional perspective, it&#x27;s really down to null handling at this point. But kotlin has a lot of nice syntactic sugar still. Same with Groovy.</div><br/><div id="37193666" class="c"><input type="checkbox" id="c-37193666" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37191534">root</a><span>|</span><a href="#37193459">parent</a><span>|</span><a href="#37196743">next</a><span>|</span><label class="collapse" for="c-37193666">[-]</label><label class="expand" for="c-37193666">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s really down to null handling at this point.<p>and reified generics, if you care about that sort of thing.<p>Plus immutability&#x2F;final by default, the stdlib being a joy to use, etc.</div><br/></div></div><div id="37196743" class="c"><input type="checkbox" id="c-37196743" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37191534">root</a><span>|</span><a href="#37193459">parent</a><span>|</span><a href="#37193666">prev</a><span>|</span><a href="#37192797">next</a><span>|</span><label class="collapse" for="c-37196743">[-]</label><label class="expand" for="c-37196743">[1 more]</label></div><br/><div class="children"><div class="content">We all know how Groovy ended.<p>Being syntax sugar isn&#x27;t enough to keep a language going.</div><br/></div></div></div></div><div id="37192797" class="c"><input type="checkbox" id="c-37192797" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#37191534">root</a><span>|</span><a href="#37192752">parent</a><span>|</span><a href="#37193459">prev</a><span>|</span><a href="#37193066">next</a><span>|</span><label class="collapse" for="c-37192797">[-]</label><label class="expand" for="c-37192797">[3 more]</label></div><br/><div class="children"><div class="content">Coroutines are one of the most prominent features of Kotlin, so it does make sense to bring this up in the discussion.<p>OTOH, I&#x27;m unconvinced that virtual threads make coroutines, reactive APIs etc. obsolete. Those are about structured concurrency, and with projet Loom, the structured concurrency proposal is still in the incubating stage.</div><br/><div id="37192950" class="c"><input type="checkbox" id="c-37192950" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37191534">root</a><span>|</span><a href="#37192797">parent</a><span>|</span><a href="#37193066">next</a><span>|</span><label class="collapse" for="c-37192950">[-]</label><label class="expand" for="c-37192950">[2 more]</label></div><br/><div class="children"><div class="content">SC will be a preview level API in Java 21: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;453" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;453</a></div><br/><div id="37195757" class="c"><input type="checkbox" id="c-37195757" checked=""/><div class="controls bullet"><span class="by">richbell</span><span>|</span><a href="#37191534">root</a><span>|</span><a href="#37192950">parent</a><span>|</span><a href="#37193066">next</a><span>|</span><label class="collapse" for="c-37195757">[-]</label><label class="expand" for="c-37195757">[1 more]</label></div><br/><div class="children"><div class="content">The magic of Kotlin&#x27;s structured concurrency is that it &quot;just works&quot; without you having to think about it, and it&#x27;s difficult to screw up. This looks a fair bit more involved, though I&#x27;m excited for it nonetheless.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37193066" class="c"><input type="checkbox" id="c-37193066" checked=""/><div class="controls bullet"><span class="by">rubicon33</span><span>|</span><a href="#37191534">prev</a><span>|</span><a href="#37194500">next</a><span>|</span><label class="collapse" for="c-37193066">[-]</label><label class="expand" for="c-37193066">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll take Scala + Akka over this.  Underrated multithreading framework to say the least.</div><br/><div id="37193868" class="c"><input type="checkbox" id="c-37193868" checked=""/><div class="controls bullet"><span class="by">mikmoila</span><span>|</span><a href="#37193066">parent</a><span>|</span><a href="#37194500">next</a><span>|</span><label class="collapse" for="c-37193868">[-]</label><label class="expand" for="c-37193868">[1 more]</label></div><br/><div class="children"><div class="content">Of course, this is not fully comparable to Akka, but you might find this interesting: <a href="https:&#x2F;&#x2F;github.com&#x2F;ebarlas&#x2F;game-of-life-csp">https:&#x2F;&#x2F;github.com&#x2F;ebarlas&#x2F;game-of-life-csp</a></div><br/></div></div></div></div><div id="37194500" class="c"><input type="checkbox" id="c-37194500" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#37193066">prev</a><span>|</span><a href="#37177209">next</a><span>|</span><label class="collapse" for="c-37194500">[-]</label><label class="expand" for="c-37194500">[2 more]</label></div><br/><div class="children"><div class="content">What problem does this solve?</div><br/><div id="37194636" class="c"><input type="checkbox" id="c-37194636" checked=""/><div class="controls bullet"><span class="by">cowsandmilk</span><span>|</span><a href="#37194500">parent</a><span>|</span><a href="#37177209">next</a><span>|</span><label class="collapse" for="c-37194636">[-]</label><label class="expand" for="c-37194636">[1 more]</label></div><br/><div class="children"><div class="content">Taking advantage of a new Java feature for pretty much what the feature is designed for.</div><br/></div></div></div></div><div id="37177209" class="c"><input type="checkbox" id="c-37177209" checked=""/><div class="controls bullet"><span class="by">philonoist</span><span>|</span><a href="#37194500">prev</a><span>|</span><a href="#37194933">next</a><span>|</span><label class="collapse" for="c-37177209">[-]</label><label class="expand" for="c-37177209">[1 more]</label></div><br/><div class="children"><div class="content">Elaborated here - <a href="https:&#x2F;&#x2F;medium.com&#x2F;helidon&#x2F;helidon-níma-helidon-on-virtual-threads-130bb2ea2088" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;helidon&#x2F;helidon-níma-helidon-on-virtual-t...</a></div><br/></div></div><div id="37194933" class="c"><input type="checkbox" id="c-37194933" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#37177209">prev</a><span>|</span><a href="#37192408">next</a><span>|</span><label class="collapse" for="c-37194933">[-]</label><label class="expand" for="c-37194933">[3 more]</label></div><br/><div class="children"><div class="content">I clicked on &quot;see the code&quot; and got: &quot;404 - page not found. The main branch of helidon does not contain the path nima.&quot;</div><br/><div id="37195068" class="c"><input type="checkbox" id="c-37195068" checked=""/><div class="controls bullet"><span class="by">ElectricalUnion</span><span>|</span><a href="#37194933">parent</a><span>|</span><a href="#37195505">next</a><span>|</span><label class="collapse" for="c-37195068">[-]</label><label class="expand" for="c-37195068">[1 more]</label></div><br/><div class="children"><div class="content">Yep and it says<p>&gt; The technology preview is now available with Helidon 4.0.0-ALPHA5. We will continue releasing previews as the development evolves.<p>and in the default branch `helidon-3.x` there&#x27;s no `nima` path too, same for a `helidon-4.x` branch.</div><br/></div></div></div></div><div id="37192408" class="c"><input type="checkbox" id="c-37192408" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#37194933">prev</a><span>|</span><label class="collapse" for="c-37192408">[-]</label><label class="expand" for="c-37192408">[7 more]</label></div><br/><div class="children"><div class="content">Great project but the name is very unfortunate for Chinese speakers.</div><br/><div id="37192431" class="c"><input type="checkbox" id="c-37192431" checked=""/><div class="controls bullet"><span class="by">pandemic_region</span><span>|</span><a href="#37192408">parent</a><span>|</span><a href="#37192433">next</a><span>|</span><label class="collapse" for="c-37192431">[-]</label><label class="expand" for="c-37192431">[5 more]</label></div><br/><div class="children"><div class="content">Care to elaborate?</div><br/><div id="37192574" class="c"><input type="checkbox" id="c-37192574" checked=""/><div class="controls bullet"><span class="by">phyrex</span><span>|</span><a href="#37192408">root</a><span>|</span><a href="#37192431">parent</a><span>|</span><a href="#37193962">next</a><span>|</span><label class="collapse" for="c-37192574">[-]</label><label class="expand" for="c-37192574">[2 more]</label></div><br/><div class="children"><div class="content">“Nima” could be read as “your momma” in mandarin</div><br/><div id="37193797" class="c"><input type="checkbox" id="c-37193797" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#37192408">root</a><span>|</span><a href="#37192574">parent</a><span>|</span><a href="#37193962">next</a><span>|</span><label class="collapse" for="c-37193797">[-]</label><label class="expand" for="c-37193797">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a weird name, because it&#x27;s a transliteration of the Greek word for &quot;thread&quot;, which would conventionally be &quot;nema&quot; in English (as in nematode worms, nematocysts, Treponema, etc).</div><br/></div></div></div></div><div id="37193962" class="c"><input type="checkbox" id="c-37193962" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#37192408">root</a><span>|</span><a href="#37192431">parent</a><span>|</span><a href="#37192574">prev</a><span>|</span><a href="#37192433">next</a><span>|</span><label class="collapse" for="c-37193962">[-]</label><label class="expand" for="c-37193962">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the most common Chinese swear word, &quot;your mother&quot; (你妈）.</div><br/><div id="37196920" class="c"><input type="checkbox" id="c-37196920" checked=""/><div class="controls bullet"><span class="by">meitham</span><span>|</span><a href="#37192408">root</a><span>|</span><a href="#37193962">parent</a><span>|</span><a href="#37192433">next</a><span>|</span><label class="collapse" for="c-37196920">[-]</label><label class="expand" for="c-37196920">[1 more]</label></div><br/><div class="children"><div class="content">“Zip” is penis in Arabic, so I remember at university our female colleagues would read it as an abbreviation “ZIP” zed-eye-pee to avoid the embarrassment!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>