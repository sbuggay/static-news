<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688461260284" as="style"/><link rel="stylesheet" href="styles.css?v=1688461260284"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/TylerGlaiel/Crashlogs">Show HN: Using C++23 &lt;stacktrace&gt; to get proper crash logs in C++ programs</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>TylerGlaiel</span> | <span>84 comments</span></div><br/><div><div id="36578047" class="c"><input type="checkbox" id="c-36578047" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#36578674">next</a><span>|</span><label class="collapse" for="c-36578047">[-]</label><label class="expand" for="c-36578047">[14 more]</label></div><br/><div class="children"><div class="content">This is my favorite macro:
&quot;#define WIN32_LEAN_AND_MEAN&quot;<p>Why is it that even though Github or what ever has cutsie unicorns (or whatever it is) as error messages it feels fake and contrived while this define just feels like some random dude at MS naming it before going off to write Solitaire?</div><br/><div id="36578151" class="c"><input type="checkbox" id="c-36578151" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#36578047">parent</a><span>|</span><a href="#36578775">next</a><span>|</span><label class="collapse" for="c-36578151">[-]</label><label class="expand" for="c-36578151">[5 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget `WIN32_EXTRA_LEAN`! Still no idea what that does&#x2F;did.<p>For those curious about WIN32_LEAN_AND_MEAN - it reduces compile time by not auto-including a number of windows headers: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20091130-00&#x2F;?p=15863" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20091130-00&#x2F;?p=15...</a></div><br/><div id="36578248" class="c"><input type="checkbox" id="c-36578248" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#36578047">root</a><span>|</span><a href="#36578151">parent</a><span>|</span><a href="#36578775">next</a><span>|</span><label class="collapse" for="c-36578248">[-]</label><label class="expand" for="c-36578248">[4 more]</label></div><br/><div class="children"><div class="content">Do you mean VC_EXTRALEAN? Or is WIN32_EXTRA_LEAN also a thing?</div><br/><div id="36578468" class="c"><input type="checkbox" id="c-36578468" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#36578047">root</a><span>|</span><a href="#36578248">parent</a><span>|</span><a href="#36578775">next</a><span>|</span><label class="collapse" for="c-36578468">[-]</label><label class="expand" for="c-36578468">[3 more]</label></div><br/><div class="children"><div class="content">First time I hear of VC_EXTRALEAN, always used WIN32_EXTRA_LEAN.</div><br/><div id="36582899" class="c"><input type="checkbox" id="c-36582899" checked=""/><div class="controls bullet"><span class="by">nikbackm</span><span>|</span><a href="#36578047">root</a><span>|</span><a href="#36578468">parent</a><span>|</span><a href="#36578775">next</a><span>|</span><label class="collapse" for="c-36582899">[-]</label><label class="expand" for="c-36582899">[2 more]</label></div><br/><div class="children"><div class="content">The bad news is that WIN32_EXTRA_LEAN has no effect, you have to define VC_EXTRALEAN if you want to exclude extra stuff from the MFC and VC headers.<p>The good news is also that it has no effect. :)<p>You can verify this for yourself by grepping the Visual Studio headers for VC_EXTRALEAN and WIN32_EXTRA_LEAN.</div><br/><div id="36583752" class="c"><input type="checkbox" id="c-36583752" checked=""/><div class="controls bullet"><span class="by">Tempest1981</span><span>|</span><a href="#36578047">root</a><span>|</span><a href="#36582899">parent</a><span>|</span><a href="#36578775">next</a><span>|</span><label class="collapse" for="c-36583752">[-]</label><label class="expand" for="c-36583752">[1 more]</label></div><br/><div class="children"><div class="content">But it did in 2005?<p>&gt; VC_EXTRALEAN defines WIN32_LEAN_AND_MEAN and a number of NOservice definitions, such as NOCOMM and NOSOUND.<p>&gt; <a href="https:&#x2F;&#x2F;gamedev.net&#x2F;forums&#x2F;topic&#x2F;367942-win32_lean_and_mean-vs-vc_extralean&#x2F;3423682&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gamedev.net&#x2F;forums&#x2F;topic&#x2F;367942-win32_lean_and_mean-...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="36578775" class="c"><input type="checkbox" id="c-36578775" checked=""/><div class="controls bullet"><span class="by">ghosty141</span><span>|</span><a href="#36578047">parent</a><span>|</span><a href="#36578151">prev</a><span>|</span><a href="#36578186">next</a><span>|</span><label class="collapse" for="c-36578775">[-]</label><label class="expand" for="c-36578775">[1 more]</label></div><br/><div class="children"><div class="content">As always, Raymond Chen wrote about it! <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20091130-00&#x2F;?p=15863" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20091130-00&#x2F;?p=15...</a><p>Its also my favorite btw.</div><br/></div></div><div id="36578186" class="c"><input type="checkbox" id="c-36578186" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#36578047">parent</a><span>|</span><a href="#36578775">prev</a><span>|</span><a href="#36582588">next</a><span>|</span><label class="collapse" for="c-36578186">[-]</label><label class="expand" for="c-36578186">[4 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve had to use this at my work a couple times. I forget the exact reasoning, but IIRC if you&#x27;re using including parts of the Win32 API, you get some things that would stomp on C or C++ names, which is bad. Macros like that one prevent loading things you don&#x27;t want.<p>One example was min and max - Win32 includes those which messes with trying to use std::min and std::max.</div><br/><div id="36581326" class="c"><input type="checkbox" id="c-36581326" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#36578047">root</a><span>|</span><a href="#36578186">parent</a><span>|</span><a href="#36578258">next</a><span>|</span><label class="collapse" for="c-36581326">[-]</label><label class="expand" for="c-36581326">[1 more]</label></div><br/><div class="children"><div class="content">not only min, max, other &quot;fun&quot; ones to debug are &quot;near&quot;, &quot;far&quot;, &quot;small&quot;</div><br/></div></div><div id="36578258" class="c"><input type="checkbox" id="c-36578258" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#36578047">root</a><span>|</span><a href="#36578186">parent</a><span>|</span><a href="#36581326">prev</a><span>|</span><a href="#36580586">next</a><span>|</span><label class="collapse" for="c-36578258">[-]</label><label class="expand" for="c-36578258">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s NOMINMAX, NOGDI, etc. for that.</div><br/></div></div><div id="36580586" class="c"><input type="checkbox" id="c-36580586" checked=""/><div class="controls bullet"><span class="by">smileybarry</span><span>|</span><a href="#36578047">root</a><span>|</span><a href="#36578186">parent</a><span>|</span><a href="#36578258">prev</a><span>|</span><a href="#36582588">next</a><span>|</span><label class="collapse" for="c-36580586">[-]</label><label class="expand" for="c-36580586">[1 more]</label></div><br/><div class="children"><div class="content">I think we had to use that when importing FDI.h (the CAB-extracting part of winapi) to avoid it bringing more legacy cruft.</div><br/></div></div></div></div><div id="36582588" class="c"><input type="checkbox" id="c-36582588" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36578047">parent</a><span>|</span><a href="#36578186">prev</a><span>|</span><a href="#36579481">next</a><span>|</span><label class="collapse" for="c-36582588">[-]</label><label class="expand" for="c-36582588">[1 more]</label></div><br/><div class="children"><div class="content">Probably because you&#x27;re the same generation as the dude at MS, whereas you want the kids at Github to get off your lawn?</div><br/></div></div><div id="36579481" class="c"><input type="checkbox" id="c-36579481" checked=""/><div class="controls bullet"><span class="by">LexiMax</span><span>|</span><a href="#36578047">parent</a><span>|</span><a href="#36582588">prev</a><span>|</span><a href="#36578158">next</a><span>|</span><label class="collapse" for="c-36579481">[-]</label><label class="expand" for="c-36579481">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always been a fan of _CRT_SECURE_NO_WARNINGS, personally.</div><br/></div></div></div></div><div id="36578674" class="c"><input type="checkbox" id="c-36578674" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36578047">prev</a><span>|</span><a href="#36582001">next</a><span>|</span><label class="collapse" for="c-36578674">[-]</label><label class="expand" for="c-36578674">[28 more]</label></div><br/><div class="children"><div class="content">There are parts of C++ standard library that no one should ever use.<p>The examples are: regex, iostreams, locale...<p>My main concern - this can also become such a dead weight.</div><br/><div id="36578759" class="c"><input type="checkbox" id="c-36578759" checked=""/><div class="controls bullet"><span class="by">verall</span><span>|</span><a href="#36578674">parent</a><span>|</span><a href="#36578754">next</a><span>|</span><label class="collapse" for="c-36578759">[-]</label><label class="expand" for="c-36578759">[22 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with std::regex? Seems to work fine for me.<p>And iostreams - they&#x27;re not great. Bad programming UI, poor performance, etc. Issues abound. But should you never use them? What do you use instead? *printf methods have lots of issues too. And so does depending on Boost::format. And so does writing your own Logger&#x2F;wrapping code (which is what everyone does AFAICT).<p>locale is bad though</div><br/><div id="36579928" class="c"><input type="checkbox" id="c-36579928" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578759">parent</a><span>|</span><a href="#36579023">next</a><span>|</span><label class="collapse" for="c-36579928">[-]</label><label class="expand" for="c-36579928">[6 more]</label></div><br/><div class="children"><div class="content">Well, `std::regex` is literally orders of magnitude slower than other common regex libraries found in JS, Python, Perl, C, etc. It allocates a ton, is poorly implemented, and can never be fixed due to ABI constraints. The entire &lt;regex&gt; subsystem is a mess and should have never been standardized as is.</div><br/><div id="36582864" class="c"><input type="checkbox" id="c-36582864" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36579928">parent</a><span>|</span><a href="#36580060">next</a><span>|</span><label class="collapse" for="c-36582864">[-]</label><label class="expand" for="c-36582864">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing wrong with the std::regex design as it is the standard.<p>std::regex only sucks because the developers of gcc and clang never bothered to optimize it. (Too much work and they have other stuff to worry about.)</div><br/><div id="36583154" class="c"><input type="checkbox" id="c-36583154" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36582864">parent</a><span>|</span><a href="#36580060">next</a><span>|</span><label class="collapse" for="c-36583154">[-]</label><label class="expand" for="c-36583154">[1 more]</label></div><br/><div class="children"><div class="content">std::regex also depends on locale, which is reason enough to avoid it, regardless of performance.</div><br/></div></div></div></div><div id="36580060" class="c"><input type="checkbox" id="c-36580060" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36579928">parent</a><span>|</span><a href="#36582864">prev</a><span>|</span><a href="#36579023">next</a><span>|</span><label class="collapse" for="c-36580060">[-]</label><label class="expand" for="c-36580060">[3 more]</label></div><br/><div class="children"><div class="content">While that is true it can still be a good thing to use on a non-perofrmance critical path instead of adding a dependency on an external library.<p>Maybe it shouldn&#x27;t be there and some better thing should be there, but given it exists ... as long as one is aware of alternatives using it is fine.</div><br/><div id="36580368" class="c"><input type="checkbox" id="c-36580368" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36580060">parent</a><span>|</span><a href="#36580130">next</a><span>|</span><label class="collapse" for="c-36580368">[-]</label><label class="expand" for="c-36580368">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s &quot;not fast but usable enough&quot; of course, but I would never ship std::regex code on any user facing software. Forget realtime, std::regex fails to be interactive in examples where other libraries resolve quickly.</div><br/></div></div><div id="36580130" class="c"><input type="checkbox" id="c-36580130" checked=""/><div class="controls bullet"><span class="by">TylerGlaiel</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36580060">parent</a><span>|</span><a href="#36580368">prev</a><span>|</span><a href="#36579023">next</a><span>|</span><label class="collapse" for="c-36580130">[-]</label><label class="expand" for="c-36580130">[1 more]</label></div><br/><div class="children"><div class="content">the last time I tried it (it was years ago) std::regex was taking a measurable number of milliseconds to evaluate which is kind of a very long time even outside of performance critical paths.</div><br/></div></div></div></div></div></div><div id="36579023" class="c"><input type="checkbox" id="c-36579023" checked=""/><div class="controls bullet"><span class="by">npsimons</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578759">parent</a><span>|</span><a href="#36579928">prev</a><span>|</span><a href="#36580564">next</a><span>|</span><label class="collapse" for="c-36579023">[-]</label><label class="expand" for="c-36579023">[7 more]</label></div><br/><div class="children"><div class="content">&gt; What do you use instead [of std::iostream]?<p>This is what I want to know. Having come from C to C++, iostreams were a big improvement over the &quot;strings&quot; and print functions of C. I even extended a base iostream class to have a &quot;teebuf&quot; logger, that could output to multiple streams and had the standard logging levels.<p>It&#x27;s been a while since I last had mastery of C++, but I&#x27;d like to hear what is as portable and better than iostreams.</div><br/><div id="36580675" class="c"><input type="checkbox" id="c-36580675" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36579023">parent</a><span>|</span><a href="#36580145">next</a><span>|</span><label class="collapse" for="c-36580675">[-]</label><label class="expand" for="c-36580675">[1 more]</label></div><br/><div class="children"><div class="content">Strings in C++ are nice, especially now that we have std::string_view, but &lt;iostream&gt; is one of the worst pieces of the C++ standard library.<p>- &lt;iostream&gt; makes localization more difficult, compared to printf (localizing &lt;iostream&gt; code is beyond awful)<p>- &lt;iostream&gt; makes thread safety more difficult, compared to printf (it is safe to printf&#x2F;fprintf from multiple threads, simultaneously, without any extra work)<p>- The &lt;iostream&gt; operator overloading syntax is bad (my sense is that the operator overloading abuse in &lt;iostream&gt; was a contributing factor for why Java doesn&#x27;t allow operator overloading)<p>- Streams in &lt;iostream&gt; are stateful, and it&#x27;s easy to accidentally leave them in the wrong state (radix, padding, field width, etc)<p>- Performance of &lt;iostream&gt;, out of the box, is mediocre (to get decent performance, you need to change some defaults)<p>The main advantage of &lt;iostream&gt; was that it provided type safety, but IMO that advantage has long since been irrelevant. You get type safety with std::printf, with most compilers, assuming you enable -Wformat on GCC or similar options in other compilers.<p>The only remaining advantage of &lt;iostream&gt; is that you can overload operator&lt;&lt;. I don&#x27;t think that&#x27;s much of an advantage, especially weighed against the numerous disadvantages.<p>Using std::printf is better and more portable. Libfmt is also better and more portable, and it is now part of the standard library as std::format.<p><a href="https:&#x2F;&#x2F;www.moria.us&#x2F;articles&#x2F;iostream-is-hopelessly-broken&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.moria.us&#x2F;articles&#x2F;iostream-is-hopelessly-broken&#x2F;</a></div><br/></div></div><div id="36580145" class="c"><input type="checkbox" id="c-36580145" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36579023">parent</a><span>|</span><a href="#36580675">prev</a><span>|</span><a href="#36580564">next</a><span>|</span><label class="collapse" for="c-36580145">[-]</label><label class="expand" for="c-36580145">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d like to hear what is as portable and better than iostreams<p>Have a look at fmtlib. The interface is more like printf, but type safe and format strings are parsed at compile time. I believe itâs what std::format is based on, which could also be an option for you depending on how recent your compiler&#x2F;language version is.</div><br/><div id="36580535" class="c"><input type="checkbox" id="c-36580535" checked=""/><div class="controls bullet"><span class="by">npsimons</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36580145">parent</a><span>|</span><a href="#36580564">next</a><span>|</span><label class="collapse" for="c-36580535">[-]</label><label class="expand" for="c-36580535">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The interface is more like printf<p>See, I don&#x27;t believe that&#x27;s an improvement. Having used printf in C, I was relieved to be able to &quot;redirect&quot; whatever to a stream, and not care about whether it should be &quot;%d&quot; or &quot;%02f&quot; or even if it was a struct&#x2F;class.<p>On top of this, treating files as streams, strings as streams, or even extending streams to make a tee-stream[0] all seem clunkier to me with a printf like system.<p>Maybe fmt fixes these problems, I don&#x27;t know. But I feel a lot of people don&#x27;t like iostreams because they have some form of Stockholm syndrome with printf.<p>[0] - <a href="https:&#x2F;&#x2F;wordaligned.org&#x2F;articles&#x2F;cpp-streambufs#tee-streams" rel="nofollow noreferrer">https:&#x2F;&#x2F;wordaligned.org&#x2F;articles&#x2F;cpp-streambufs#tee-streams</a></div><br/><div id="36580745" class="c"><input type="checkbox" id="c-36580745" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36580535">parent</a><span>|</span><a href="#36580754">next</a><span>|</span><label class="collapse" for="c-36580745">[-]</label><label class="expand" for="c-36580745">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe fmt fixes these problems, I don&#x27;t know.<p>Yeah, it looks like you did a lot of guesswork in that comment, and a lot of those guesses were inaccurate. Not really trying to be hostile here, but you did acknowledge that you were unfamiliar with std::format.<p>The part that fmtlib &#x2F; std::format has, which is printf-like, is the idea of having a format string and arguments, rather than having a bunch of separate, piecemeal strings.<p><pre><code>  &#x2F;&#x2F; Old printf code, works ok for most people
  std::printf(&quot;failed to clone %s from %s&quot;, target, src);
  &#x2F;&#x2F; &lt;iostream&gt;
  std::cout &lt;&lt; &quot;failed to clone &quot; &lt;&lt; target &lt;&lt; &quot; from &quot; &lt;&lt; src;
  &#x2F;&#x2F; New std::format &#x2F; fmtlib
  std::print(&quot;failed to clone {} from {}&quot;, target, src);
</code></pre>
You can see that you don&#x27;t need to remember what kind of format specifier you need. This is C++, and that kind of problem is solved with overloading.<p>The std::print interface can work equally well with FILE or std::ofstream, or whatever you want. This is C++, and so you can just use a templated output iteratorâor one of the overloads that creates one automatically.<p>There are a lot of problems with &lt;iostream&gt;. I think itâs telling that lots of languages have copied printf, but nobody (or almost nobody) thought &lt;iostream&gt; was good enough to copy. There are just too many serious design flaws with &lt;iostream&gt;. It would be one thing if &lt;iostream&gt; were just annoying to use, but it poses problems for localization, thread-safety, accidental misuse through its statefulness, and its operator overloading syntax is bad.</div><br/></div></div><div id="36580754" class="c"><input type="checkbox" id="c-36580754" checked=""/><div class="controls bullet"><span class="by">95014_refugee</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36580535">parent</a><span>|</span><a href="#36580745">prev</a><span>|</span><a href="#36582176">next</a><span>|</span><label class="collapse" for="c-36580754">[-]</label><label class="expand" for="c-36580754">[1 more]</label></div><br/><div class="children"><div class="content">Considering the origins of &quot;stockholm syndrome&quot; this may not be exactly the message you intended.<p>However, printf and its ilk get it right; presentation is a property of the context in which the entity is to be presented, not of the entity itself. You can kvetch about the markup syntax, or the type safety issues the C implementation has, but the architecture is fundamentally correct.</div><br/></div></div><div id="36582176" class="c"><input type="checkbox" id="c-36582176" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36580535">parent</a><span>|</span><a href="#36580754">prev</a><span>|</span><a href="#36580564">next</a><span>|</span><label class="collapse" for="c-36582176">[-]</label><label class="expand" for="c-36582176">[1 more]</label></div><br/><div class="children"><div class="content">fmtlib knows the types of all the arguments, and those types are checked against the format string at <i>compile</i> time. So type safety (&quot;%d&quot; vs &quot;%s&quot; etc) is not really an issue.<p>FWIW, I have waaaay more experience with iostreams than printf. I once wrote a replacement for most parts of std::ostream purely because I had a logging system that was loosely based on log4cxx (which is based on iostreams) and I needed much faster formatting.<p>Right now I&#x27;m in the process of switching to a different logging system that uses fmtlib. I can say that I really, really do not miss the extreme verbosity of iostreams at all. The statefulness I could take or leave, although on balance I&#x27;d say it&#x27;s usually more of a negative. Thankfully I don&#x27;t have to give up type safety or extensibility.<p>As for treating files&#x2F;strings&#x2F;whatever as streams--my impression of fmtlib is that it&#x27;s concerned primarily with formatting, which frankly I&#x27;m fine with. It can write to an in-memory buffer or to a FILE* or to a std::ostream, which covers pretty much all of my needs. Given the performance of iostreams (lots of virtual method calls) I never really saw the point of using it as a more generalized &#x27;streaming&#x27; interface, even knowing that it&#x27;s possible.</div><br/></div></div></div></div></div></div></div></div><div id="36580564" class="c"><input type="checkbox" id="c-36580564" checked=""/><div class="controls bullet"><span class="by">trws</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578759">parent</a><span>|</span><a href="#36579023">prev</a><span>|</span><a href="#36579357">next</a><span>|</span><label class="collapse" for="c-36580564">[-]</label><label class="expand" for="c-36580564">[1 more]</label></div><br/><div class="children"><div class="content">Itâs impossible to implement std::regex efficiently due to internal but exposed character handling requirements. To the sibling comments about iostream, thank vzeverovich and everyone that worked on fmt and turning it into std::format (edit: accidentally wrote std::fmt initially), which is vastly superior and not dependent on mutable global state.</div><br/></div></div><div id="36579357" class="c"><input type="checkbox" id="c-36579357" checked=""/><div class="controls bullet"><span class="by">plq</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578759">parent</a><span>|</span><a href="#36580564">prev</a><span>|</span><a href="#36578835">next</a><span>|</span><label class="collapse" for="c-36579357">[-]</label><label class="expand" for="c-36579357">[4 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s wrong with std::regex?<p>In my experience, stdlibc++ &lt;regex&gt; is VERY slow, especially on debug builds. We are using g_regex instead, which in turn uses pcre2.<p>&gt; And iostreams<p>&lt;iostream&gt; achieves too little with too much code. We instead use:<p><pre><code>    std::cout &lt;&lt; fmt::format(...);
</code></pre>
for simple output, loguru[1] for everything else. I feel like the fmt grammar&#x2F;mini-language is both nicely extensible and has hit the expressiveness sweet spot -- not too verbose (iostreams) nor too terse (printf).<p>I also like that fmt has helpers for pointers (fmt::ptr), enums (fmt::underlying) and arrays (fmt::join). It&#x27;s both easy on the eyes and feels consistent.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;loguru">https:&#x2F;&#x2F;github.com&#x2F;emilk&#x2F;loguru</a></div><br/><div id="36580486" class="c"><input type="checkbox" id="c-36580486" checked=""/><div class="controls bullet"><span class="by">fyrn_</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36579357">parent</a><span>|</span><a href="#36580239">next</a><span>|</span><label class="collapse" for="c-36580486">[-]</label><label class="expand" for="c-36580486">[2 more]</label></div><br/><div class="children"><div class="content">Consider
```
#include &lt;fmt&#x2F;os.h&gt;<p>...
fmt::print(...);
```
Instead, to save that potential double buffer copy.</div><br/><div id="36583853" class="c"><input type="checkbox" id="c-36583853" checked=""/><div class="controls bullet"><span class="by">plq</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36580486">parent</a><span>|</span><a href="#36580239">next</a><span>|</span><label class="collapse" for="c-36583853">[-]</label><label class="expand" for="c-36583853">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Still learning my way around the fmt library.</div><br/></div></div></div></div><div id="36580239" class="c"><input type="checkbox" id="c-36580239" checked=""/><div class="controls bullet"><span class="by">verall</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36579357">parent</a><span>|</span><a href="#36580486">prev</a><span>|</span><a href="#36578835">next</a><span>|</span><label class="collapse" for="c-36580239">[-]</label><label class="expand" for="c-36580239">[1 more]</label></div><br/><div class="children"><div class="content">fmt looks really nice. Probably worth pulling the dependency in for future projects.</div><br/></div></div></div></div><div id="36578835" class="c"><input type="checkbox" id="c-36578835" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578759">parent</a><span>|</span><a href="#36579357">prev</a><span>|</span><a href="#36578916">next</a><span>|</span><label class="collapse" for="c-36578835">[-]</label><label class="expand" for="c-36578835">[1 more]</label></div><br/><div class="children"><div class="content">iostreams are not great but are nothing compared to the awkwardness and lack of extensibility of printf style format strings.</div><br/></div></div><div id="36578916" class="c"><input type="checkbox" id="c-36578916" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578759">parent</a><span>|</span><a href="#36578835">prev</a><span>|</span><a href="#36579206">next</a><span>|</span><label class="collapse" for="c-36578916">[-]</label><label class="expand" for="c-36578916">[1 more]</label></div><br/><div class="children"><div class="content">1. Historically, std::regex was offered in GCC before it was actually fully implemented. Much hilarity ensued...<p>2. Some existing implementations have efficiency issues, e.g. performing many allocations.<p>3. It is claimed (e.g. by Titus Winters) that the ABI of std::regex is problematic, and without breaking it, the implementations cannot be good enough<p>See these points and others at:<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;e16s1m&#x2F;what_is_wrong_with_stdregex&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;e16s1m&#x2F;what_is_wrong_w...</a></div><br/></div></div><div id="36579206" class="c"><input type="checkbox" id="c-36579206" checked=""/><div class="controls bullet"><span class="by">scatters</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578759">parent</a><span>|</span><a href="#36578916">prev</a><span>|</span><a href="#36578754">next</a><span>|</span><label class="collapse" for="c-36579206">[-]</label><label class="expand" for="c-36579206">[1 more]</label></div><br/><div class="children"><div class="content">iostream is replaced by format.</div><br/></div></div></div></div><div id="36578754" class="c"><input type="checkbox" id="c-36578754" checked=""/><div class="controls bullet"><span class="by">the_svd_doctor</span><span>|</span><a href="#36578674">parent</a><span>|</span><a href="#36578759">prev</a><span>|</span><a href="#36582001">next</a><span>|</span><label class="collapse" for="c-36578754">[-]</label><label class="expand" for="c-36578754">[5 more]</label></div><br/><div class="children"><div class="content">Can you expand on the problems with regex?</div><br/><div id="36578899" class="c"><input type="checkbox" id="c-36578899" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578754">parent</a><span>|</span><a href="#36578827">next</a><span>|</span><label class="collapse" for="c-36578899">[-]</label><label class="expand" for="c-36578899">[1 more]</label></div><br/><div class="children"><div class="content">The implementations are bad and implementers are refusing to fix their own bad implementations so as to not break their own ABI, but that has nothing to do with C++ the standard.</div><br/></div></div><div id="36578827" class="c"><input type="checkbox" id="c-36578827" checked=""/><div class="controls bullet"><span class="by">dkersten</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578754">parent</a><span>|</span><a href="#36578899">prev</a><span>|</span><a href="#36582001">next</a><span>|</span><label class="collapse" for="c-36578827">[-]</label><label class="expand" for="c-36578827">[3 more]</label></div><br/><div class="children"><div class="content">From what Iâve heard, std::regex is notoriously inefficient (lots of memory allocations, no allocator support). But Iâve never used it myself.</div><br/><div id="36578898" class="c"><input type="checkbox" id="c-36578898" checked=""/><div class="controls bullet"><span class="by">TylerGlaiel</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578827">parent</a><span>|</span><a href="#36582001">next</a><span>|</span><label class="collapse" for="c-36578898">[-]</label><label class="expand" for="c-36578898">[2 more]</label></div><br/><div class="children"><div class="content">oh yeah C++ regex is stupidly inefficient, like &quot;python is faster&quot; inefficient. I tried to use it for text replacements and pretty much immediately abandoned it</div><br/><div id="36579046" class="c"><input type="checkbox" id="c-36579046" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36578674">root</a><span>|</span><a href="#36578898">parent</a><span>|</span><a href="#36582001">next</a><span>|</span><label class="collapse" for="c-36579046">[-]</label><label class="expand" for="c-36579046">[1 more]</label></div><br/><div class="children"><div class="content">Apparently typical implementations of std::regex are inefficient like &quot;&#x27;popen(&quot;perl..&quot;)&#x27; is faster&quot; is inefficient!<p>I thing boost::regex is significantly faster although not particularly fast</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36582001" class="c"><input type="checkbox" id="c-36582001" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#36578674">prev</a><span>|</span><a href="#36579305">next</a><span>|</span><label class="collapse" for="c-36582001">[-]</label><label class="expand" for="c-36582001">[2 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t care about exotica like async or signal safety, and just need to see the callstack from arbitray points, this can do the job without C++23:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Ardour&#x2F;ardour&#x2F;blob&#x2F;master&#x2F;libs&#x2F;pbd&#x2F;stacktrace.cc">https:&#x2F;&#x2F;github.com&#x2F;Ardour&#x2F;ardour&#x2F;blob&#x2F;master&#x2F;libs&#x2F;pbd&#x2F;stackt...</a><p>(2 different implementations, one for POSIX-y systems with the execinfo.h header, and one for Windows)<p>The demange() function is elsewhere.</div><br/><div id="36582505" class="c"><input type="checkbox" id="c-36582505" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36582001">parent</a><span>|</span><a href="#36579305">next</a><span>|</span><label class="collapse" for="c-36582505">[-]</label><label class="expand" for="c-36582505">[1 more]</label></div><br/><div class="children"><div class="content">Ime the execinfo.h backtraces are unfortunately not that useful in practice, due to being unable to resolve symbol names of static functions. But FWIW, you can use it for async signals with the _fd variant.</div><br/></div></div></div></div><div id="36579305" class="c"><input type="checkbox" id="c-36579305" checked=""/><div class="controls bullet"><span class="by">evmar</span><span>|</span><a href="#36582001">prev</a><span>|</span><a href="#36578554">next</a><span>|</span><label class="collapse" for="c-36579305">[-]</label><label class="expand" for="c-36579305">[3 more]</label></div><br/><div class="children"><div class="content">The code:<p><pre><code>    &#x2F;&#x2F;a decent amount of this was copied&#x2F;modified from backward.cpp (https:&#x2F;&#x2F;github.com&#x2F;bombela&#x2F;backward-cpp)
</code></pre>
The license on the other side of that link:<p><pre><code>    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.</code></pre></div><br/><div id="36582019" class="c"><input type="checkbox" id="c-36582019" checked=""/><div class="controls bullet"><span class="by">Rexxar</span><span>|</span><a href="#36579305">parent</a><span>|</span><a href="#36579503">next</a><span>|</span><label class="collapse" for="c-36582019">[-]</label><label class="expand" for="c-36582019">[1 more]</label></div><br/><div class="children"><div class="content">Both have &quot;MIT License&quot; and he explicitly acknowledge the source. He probably forgot that he had to add an additional line with &quot;Copyright 2013 Google Inc.&quot; in his own license file.</div><br/></div></div><div id="36579503" class="c"><input type="checkbox" id="c-36579503" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#36579305">parent</a><span>|</span><a href="#36582019">prev</a><span>|</span><a href="#36578554">next</a><span>|</span><label class="collapse" for="c-36579503">[-]</label><label class="expand" for="c-36579503">[1 more]</label></div><br/><div class="children"><div class="content">This is only an issue if the original author chooses to enforce.  You don&#x27;t know - this code may have been given special permission to omit the notice by the original author.   It isn&#x27;t up to random joe to find copyrights they think have been violated.</div><br/></div></div></div></div><div id="36578554" class="c"><input type="checkbox" id="c-36578554" checked=""/><div class="controls bullet"><span class="by">elsamuko</span><span>|</span><a href="#36579305">prev</a><span>|</span><a href="#36582542">next</a><span>|</span><label class="collapse" for="c-36578554">[-]</label><label class="expand" for="c-36578554">[11 more]</label></div><br/><div class="children"><div class="content">A question:  
Would it be possible to pass the stacktrace of the current thread to another, so that the stacktrace would be traceable across threadpools or worker threads?</div><br/><div id="36578649" class="c"><input type="checkbox" id="c-36578649" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#36578554">parent</a><span>|</span><a href="#36582542">next</a><span>|</span><label class="collapse" for="c-36578649">[-]</label><label class="expand" for="c-36578649">[10 more]</label></div><br/><div class="children"><div class="content">I am not sure if i understand the question correctly. But once collected, stack traces are just regular object  that can be passed around thread as other object. It&#x27;s possible that some implementation have references to some stack addresses (like for example the address of a function parameter), in which case you would need to serialize the stack trace before storing them&#x2F; moving then another thread.</div><br/><div id="36578702" class="c"><input type="checkbox" id="c-36578702" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36578649">parent</a><span>|</span><a href="#36582542">next</a><span>|</span><label class="collapse" for="c-36578702">[-]</label><label class="expand" for="c-36578702">[9 more]</label></div><br/><div class="children"><div class="content">&gt; once collected, stack traces are just regular object that can be passed around thread as other object.<p>&gt; It&#x27;s possible that some implementation have references to some stack addresses (like for example the address of a function parameter), in which case you would need to serialize the stack trace before storing them&#x2F; moving then another thread.<p>So which of these two mutually exclusive options is it? As I understand it, that <i>was</i> the question.</div><br/><div id="36579091" class="c"><input type="checkbox" id="c-36579091" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36578702">parent</a><span>|</span><a href="#36578926">next</a><span>|</span><label class="collapse" for="c-36579091">[-]</label><label class="expand" for="c-36579091">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So which of these two mutually exclusive options is it? As I understand it, that was the question.<p>Well the stack_entry&#x2F;stack_trace object can be moved around between thread, as in the object itself is copyable and movable. 
However, the handle_type is implementation defined, so it might be the case that  extracting the information out of the object only works on the producing thread.</div><br/></div></div><div id="36578926" class="c"><input type="checkbox" id="c-36578926" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36578702">parent</a><span>|</span><a href="#36579091">prev</a><span>|</span><a href="#36578849">next</a><span>|</span><label class="collapse" for="c-36578926">[-]</label><label class="expand" for="c-36578926">[1 more]</label></div><br/><div class="children"><div class="content">As far as I understand, basic_stack trace is just a container of stacktrace_entries, which are Regular types. So the default distinct-objects type safety rules apply.<p>You should be able to, for example, collect the stacktace on one thread, transport it to another and print it.</div><br/></div></div><div id="36578849" class="c"><input type="checkbox" id="c-36578849" checked=""/><div class="controls bullet"><span class="by">elsamuko</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36578702">parent</a><span>|</span><a href="#36578926">prev</a><span>|</span><a href="#36582542">next</a><span>|</span><label class="collapse" for="c-36578849">[-]</label><label class="expand" for="c-36578849">[6 more]</label></div><br/><div class="children"><div class="content">When I debug multithreaded programs, the stacktrace of a breakpoint usually ends somewhere in a worker thread.
What I want is that the worker thread&#x27;s stacktrace part is replaced by the one who put the work into it.  
Kinda like the program wasn&#x27;t multithreaded at all.</div><br/><div id="36579014" class="c"><input type="checkbox" id="c-36579014" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36578849">parent</a><span>|</span><a href="#36579057">next</a><span>|</span><label class="collapse" for="c-36579014">[-]</label><label class="expand" for="c-36579014">[3 more]</label></div><br/><div class="children"><div class="content">Ah. I guess you can capture the stack trace at task creation point, then stitch together a new stack trace by replacing the generic common prefix of your worker thread trace with the task creation one.<p>But you can&#x27;t use the basic_stacktrace container itself as it is immutable and not constructibe from a range, so you have to roll your own. You should be able to use the stacktrace_entries though.<p>Most importantly, I expect that capturing a stacktrace is quite expensive, so you might not be able to do it at task creation time, and it is too late to do it later. Maybe you want this only in debug mode.<p>Note I haven&#x27;t actually tried any if this, it is just guesswork.</div><br/><div id="36579131" class="c"><input type="checkbox" id="c-36579131" checked=""/><div class="controls bullet"><span class="by">elsamuko</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36579014">parent</a><span>|</span><a href="#36579057">next</a><span>|</span><label class="collapse" for="c-36579131">[-]</label><label class="expand" for="c-36579131">[2 more]</label></div><br/><div class="children"><div class="content">Exactly this.  
I didn&#x27;t try this, and I suppose that some low level pointer rewriting would be necessary to do this.
I&#x27;m not sure if it&#x27;s expensive though, maybe you can replace the pointers without resolving the stacktrace.</div><br/><div id="36579419" class="c"><input type="checkbox" id="c-36579419" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36579131">parent</a><span>|</span><a href="#36579057">next</a><span>|</span><label class="collapse" for="c-36579419">[-]</label><label class="expand" for="c-36579419">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that to get the stacktrace of the task creation you have to traverse the stack at that point in time. You can&#x27;t really do it later. And stack traversal using DWARF unwind info, for example, is neither cheap nor simple. You might have better luck if you compile with frame pointer though.</div><br/></div></div></div></div></div></div><div id="36579057" class="c"><input type="checkbox" id="c-36579057" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36578849">parent</a><span>|</span><a href="#36579014">prev</a><span>|</span><a href="#36578945">next</a><span>|</span><label class="collapse" for="c-36579057">[-]</label><label class="expand" for="c-36579057">[1 more]</label></div><br/><div class="children"><div class="content">I think what you looking for is &quot;task tracing&quot; not really stack tracing. The relationship between the task (like where was a task added in the thread pool) are not reflected in the stacktrace the way you want them.
To address those, you need to have special handshake between the debugger and your task api. You can also instrument the &quot;add_task&quot; function call to log every time a task is added to you queue and do some some offline stack stiching.</div><br/></div></div><div id="36578945" class="c"><input type="checkbox" id="c-36578945" checked=""/><div class="controls bullet"><span class="by">TylerGlaiel</span><span>|</span><a href="#36578554">root</a><span>|</span><a href="#36578849">parent</a><span>|</span><a href="#36579057">prev</a><span>|</span><a href="#36582542">next</a><span>|</span><label class="collapse" for="c-36578945">[-]</label><label class="expand" for="c-36578945">[1 more]</label></div><br/><div class="children"><div class="content">if you actually wanted to you could probably wrap thread to pass the stacktrace of the spawning thread into the worker thread whenever you spawn a thread and then output that upon a crash as well. the library seems pretty simple and flexible.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36582542" class="c"><input type="checkbox" id="c-36582542" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36578554">prev</a><span>|</span><a href="#36579456">next</a><span>|</span><label class="collapse" for="c-36582542">[-]</label><label class="expand" for="c-36582542">[5 more]</label></div><br/><div class="children"><div class="content">This does not even remotely look to be signal safe to me?</div><br/><div id="36582611" class="c"><input type="checkbox" id="c-36582611" checked=""/><div class="controls bullet"><span class="by">simfoo</span><span>|</span><a href="#36582542">parent</a><span>|</span><a href="#36579456">next</a><span>|</span><label class="collapse" for="c-36582611">[-]</label><label class="expand" for="c-36582611">[4 more]</label></div><br/><div class="children"><div class="content">The signal handler just saves the trace and then wakes up another thread which does the reporting. The signaled thread uses only &lt;stacktrace&gt; and mutex&#x2F;cv, all signal-safe as far as I can tell.</div><br/><div id="36582695" class="c"><input type="checkbox" id="c-36582695" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36582542">root</a><span>|</span><a href="#36582611">parent</a><span>|</span><a href="#36579456">next</a><span>|</span><label class="collapse" for="c-36582695">[-]</label><label class="expand" for="c-36582695">[3 more]</label></div><br/><div class="children"><div class="content">The crashing thread might hold a lock in the memory allocator - which could either self deadlock when saving the stack trace (which certainly seems to do memory allocation and thus isn&#x27;t a-signal safe), or could deadlock with the crash reporting thread which definitely allocates memory all over.<p>I also quite doubt that std::mutex, and even more so std::condition_variable are guaranteed to be signal safe.</div><br/><div id="36582776" class="c"><input type="checkbox" id="c-36582776" checked=""/><div class="controls bullet"><span class="by">simfoo</span><span>|</span><a href="#36582542">root</a><span>|</span><a href="#36582695">parent</a><span>|</span><a href="#36579456">next</a><span>|</span><label class="collapse" for="c-36582776">[-]</label><label class="expand" for="c-36582776">[2 more]</label></div><br/><div class="children"><div class="content">stack_trace allows you to specify a custom allocator, which would protect against a lock held in the allocator (never ran into this in the real world though).<p>You&#x27;re right about mutex &amp; cv in the general case though</div><br/><div id="36583036" class="c"><input type="checkbox" id="c-36583036" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#36582542">root</a><span>|</span><a href="#36582776">parent</a><span>|</span><a href="#36579456">next</a><span>|</span><label class="collapse" for="c-36583036">[-]</label><label class="expand" for="c-36583036">[1 more]</label></div><br/><div class="children"><div class="content">That assumes the specified allocator actually controls all allocations - somewhat doubtful across all platforms as things like dl_iterate_phdr() IIRC allocate memory (and take locks). And there&#x27;s a lot more to writing signal safe code than not calling malloc. Unless an interface documents to be signal safe you&#x27;re take better of assuming it is not.<p>FWIW I&#x27;ve run into malloc self dreadlocks due to rare signals plenty of time :(. In production workloads.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36579456" class="c"><input type="checkbox" id="c-36579456" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#36582542">prev</a><span>|</span><a href="#36580731">next</a><span>|</span><label class="collapse" for="c-36579456">[-]</label><label class="expand" for="c-36579456">[1 more]</label></div><br/><div class="children"><div class="content">I may be wrong, but as I recall it is good form to chain exception filter calls by making note of the return from `SetUnhandledExceptionFilter`.  For example, if I want to use `&lt;stacktrace&gt;` and do copy-on-write using memory protection in the same program.</div><br/></div></div><div id="36580731" class="c"><input type="checkbox" id="c-36580731" checked=""/><div class="controls bullet"><span class="by">koyote</span><span>|</span><a href="#36579456">prev</a><span>|</span><a href="#36580197">next</a><span>|</span><label class="collapse" for="c-36580731">[-]</label><label class="expand" for="c-36580731">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I am doing something wrong but the example code does not seem to work on VS 2022 (no output file after a div by zero or stack overflow crash).</div><br/></div></div><div id="36580197" class="c"><input type="checkbox" id="c-36580197" checked=""/><div class="controls bullet"><span class="by">r2vcap</span><span>|</span><a href="#36580731">prev</a><span>|</span><a href="#36577992">next</a><span>|</span><label class="collapse" for="c-36580197">[-]</label><label class="expand" for="c-36580197">[1 more]</label></div><br/><div class="children"><div class="content">Yet another library feature that will be used by nobody... While having a standard library is good, system programming presents tricky aspects like async-safety that are not adequately addressed. Therefore, considering the challenges involved, I believe it would be better to utilize existing libraries like crashpad to handle such scenarios.</div><br/></div></div><div id="36577992" class="c"><input type="checkbox" id="c-36577992" checked=""/><div class="controls bullet"><span class="by">catiopatio</span><span>|</span><a href="#36580197">prev</a><span>|</span><a href="#36579217">next</a><span>|</span><label class="collapse" for="c-36577992">[-]</label><label class="expand" for="c-36577992">[16 more]</label></div><br/><div class="children"><div class="content">Reliable in-process crash reporting is exceptionally difficult.<p>The code must be fully async-safe, which means you cannot use &lt;stacktrace&gt;. You also cannot acquire mutexes, use any of the standard allocators, etc etc etc.</div><br/><div id="36578642" class="c"><input type="checkbox" id="c-36578642" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36577992">parent</a><span>|</span><a href="#36578094">next</a><span>|</span><label class="collapse" for="c-36578642">[-]</label><label class="expand" for="c-36578642">[3 more]</label></div><br/><div class="children"><div class="content">The best way I&#x27;ve found is - patching LLVM&#x27;s libunwind to make it fully async-signal safe, and sending the stack trace to another thread for symbolization. This is implemented in ClickHouse.</div><br/><div id="36578965" class="c"><input type="checkbox" id="c-36578965" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36578642">parent</a><span>|</span><a href="#36578094">next</a><span>|</span><label class="collapse" for="c-36578965">[-]</label><label class="expand" for="c-36578965">[2 more]</label></div><br/><div class="children"><div class="content">1. Can you link to that?<p>2. Have these changes been offered as patch for libunwind or boost::stacktrace?</div><br/><div id="36580265" class="c"><input type="checkbox" id="c-36580265" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36578965">parent</a><span>|</span><a href="#36578094">next</a><span>|</span><label class="collapse" for="c-36580265">[-]</label><label class="expand" for="c-36580265">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;libunwind&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;libunwind&#x2F;</a><p>There were multiple steps:<p>1. Avoid using malloc&#x2F;free inside libunwind.<p>2. Avoid using FDECache that required a mutex.<p>3. Avoid using dl_iterate_phdr (a mutex inside libc).<p>4. Protection from dereferencing wrong pointers due to incorrect unwind tables.<p>Most of the changes were integrated to libunwind, but not everything.
Example: <a href="https:&#x2F;&#x2F;bugs.llvm.org&#x2F;show_bug.cgi?id=48186" rel="nofollow noreferrer">https:&#x2F;&#x2F;bugs.llvm.org&#x2F;show_bug.cgi?id=48186</a></div><br/></div></div></div></div></div></div><div id="36578094" class="c"><input type="checkbox" id="c-36578094" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#36577992">parent</a><span>|</span><a href="#36578642">prev</a><span>|</span><a href="#36578944">next</a><span>|</span><label class="collapse" for="c-36578094">[-]</label><label class="expand" for="c-36578094">[9 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the benefit of in-process crash reporting compared to just using something like crashpad&#x2F;breakpad?<p>To the extent that in-process crash reporting is even possible... seems the most common class of crashes would be entirely unrecoverable.</div><br/><div id="36578942" class="c"><input type="checkbox" id="c-36578942" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36578094">parent</a><span>|</span><a href="#36578214">next</a><span>|</span><label class="collapse" for="c-36578942">[-]</label><label class="expand" for="c-36578942">[5 more]</label></div><br/><div class="children"><div class="content">Ease of integration, because having literally <i>anything</i> is typically better than nothing. Honestly Crashpad isn&#x27;t fun to integrate unless you use a fork like backtrace&#x27;s (which adds CMake support), which I think doesn&#x27;t help. I don&#x27;t know of any alternatives.<p>A version of Crashpad or something like it with a single turnkey server for database dumps, a one-line &quot;defaults are good enough&quot; integration, would be a real great thing to see.</div><br/><div id="36579077" class="c"><input type="checkbox" id="c-36579077" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36578942">parent</a><span>|</span><a href="#36578214">next</a><span>|</span><label class="collapse" for="c-36579077">[-]</label><label class="expand" for="c-36579077">[4 more]</label></div><br/><div class="children"><div class="content">I found Sentry&#x27;s crash reporting (which uses crashpad) simple enough to configure into an existing CMake build within an afternoon.<p>Building Sentry&#x2F;crashpad from source in a few lines of CMake: <a href="https:&#x2F;&#x2F;github.com&#x2F;ArmageddonGames&#x2F;ZQuestClassic&#x2F;commit&#x2F;3471ec702c90aa9a759fd9c9a2683bd3c33d7cb0#diff-1e7de1ae2d059d21e1dd75d5812d5a34b0222cef273b7c3a2af62eb747f9d20aR559-R575">https:&#x2F;&#x2F;github.com&#x2F;ArmageddonGames&#x2F;ZQuestClassic&#x2F;commit&#x2F;3471...</a><p>And a few lines in the main function: <a href="https:&#x2F;&#x2F;github.com&#x2F;ArmageddonGames&#x2F;ZQuestClassic&#x2F;commit&#x2F;3471ec702c90aa9a759fd9c9a2683bd3c33d7cb0">https:&#x2F;&#x2F;github.com&#x2F;ArmageddonGames&#x2F;ZQuestClassic&#x2F;commit&#x2F;3471...</a></div><br/><div id="36579643" class="c"><input type="checkbox" id="c-36579643" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36579077">parent</a><span>|</span><a href="#36578214">next</a><span>|</span><label class="collapse" for="c-36579643">[-]</label><label class="expand" for="c-36579643">[3 more]</label></div><br/><div class="children"><div class="content">Neat, I didn&#x27;t know Sentry also had a good fork, I haven&#x27;t tried it! But in contrast, here&#x27;s an in-process fault library that I whipped up (from forking Phusion Passenger) about 10 years ago that I still reach for sometimes, which is surprisingly robust to most of the original complaints about async safety, but still not perfect: <a href="https:&#x2F;&#x2F;github.com&#x2F;thoughtpolice&#x2F;libfault">https:&#x2F;&#x2F;github.com&#x2F;thoughtpolice&#x2F;libfault</a><p>You add one C file and 6 lines of code in `main()`, and you can do this in pretty much any programming language with a tiny extra bit of glue. It takes 3 minutes to do this in any C&#x2F;C++ codebase of mine. It is build system agnostic and works immediately, with zero outside deps. It&#x27;s <i>something</i>, and that&#x27;s better than nothing, in practice. So people reach for that. I reach for it. And not just because I wrote it.<p>I want to be clear: Crashpad is 10000x better than mine in every way, except this <i>one</i> way. And I really wish it wasn&#x27;t. To add onto this, I really don&#x27;t like CMake for example, so this problem isn&#x27;t just a &quot;well I like my thing.&quot; I want something that will also work in my Java programs, or Rust programs, for instance! Sometimes they crash too. I don&#x27;t need to add any dependencies except like 2 or 3 C function calls, which almost every langauge supports with a native FFI out of the box. The friction is extremely low.<p>I&#x27;m reminded of something Yann Collet once said about the design of zstd, and getting people to adopt new compression technology. If you make a compressor and it&#x27;s better than an alternative in one or more dimensions, but worse in another (size, decompressor speed), then friction is actually <i>significantly</i> increased by that one failure. But if you make it better in <i>every</i> dimension -- so it gives an equal ratio and compression and decompression are always better than alternatives -- the friction is eliminated and people will just reach for it. Even though you only did worse in <i>one</i> spot, people find ways to make it matter. It really makes people think twice. But if it&#x27;s always better, in every way, then using and reaching for it is just instinctive -- it replaces the old thing entirely.<p>So that&#x27;s what I really wish we had here. I think that&#x27;s what you would need to see a lot better crash handling and reporting become more widely used. There needs to be a version of Crashpad, or any robust out of process crash collector, that you can just drop into any language and any build system with a little C glue (or Rust! Sure! Whatever!) in 5 minutes and it should have a crash database server and crash handler process <i>which should instantly work</i> for most uses.</div><br/><div id="36579687" class="c"><input type="checkbox" id="c-36579687" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36579643">parent</a><span>|</span><a href="#36578214">next</a><span>|</span><label class="collapse" for="c-36579687">[-]</label><label class="expand" for="c-36579687">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing, I&#x27;m sure that will come in handy for me some day!<p>This all feels like a failure of our modern OSes - why must the application layer know how to report on when it crashes? It seems like functionality that the OS should provide! Instead, we&#x27;re stuck reaching for these random extensions solving the same problem in the same way everywhere - or, if you&#x27;re lucky, this gets provided by the language framework for &quot;free&quot; to application developers (but not the language developers).</div><br/><div id="36580154" class="c"><input type="checkbox" id="c-36580154" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36579687">parent</a><span>|</span><a href="#36578214">next</a><span>|</span><label class="collapse" for="c-36580154">[-]</label><label class="expand" for="c-36580154">[1 more]</label></div><br/><div class="children"><div class="content">Actually, that&#x27;s a really a good point. It&#x27;s also especially weird considering we get lots of <i>debugging</i> support through the OS stack on every system. They have APIs, libraries, tools, etc. But actual crash control, a kind of thing where you want black box recordings after the fact, isn&#x27;t really a thing anywhere unless you roll it yourself. It&#x27;s a big shame.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36578214" class="c"><input type="checkbox" id="c-36578214" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36578094">parent</a><span>|</span><a href="#36578942">prev</a><span>|</span><a href="#36578592">next</a><span>|</span><label class="collapse" for="c-36578214">[-]</label><label class="expand" for="c-36578214">[1 more]</label></div><br/><div class="children"><div class="content">I guess it is easier to print out some interesting process variables, compared to trying to save and then make sense of dumps etc.</div><br/></div></div><div id="36578592" class="c"><input type="checkbox" id="c-36578592" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36578094">parent</a><span>|</span><a href="#36578214">prev</a><span>|</span><a href="#36578190">next</a><span>|</span><label class="collapse" for="c-36578592">[-]</label><label class="expand" for="c-36578592">[1 more]</label></div><br/><div class="children"><div class="content">It has value in embedded code where you can stop the world to handle or log fault conditions.</div><br/></div></div></div></div><div id="36578944" class="c"><input type="checkbox" id="c-36578944" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#36577992">parent</a><span>|</span><a href="#36578094">prev</a><span>|</span><a href="#36579217">next</a><span>|</span><label class="collapse" for="c-36578944">[-]</label><label class="expand" for="c-36578944">[3 more]</label></div><br/><div class="children"><div class="content">What is async-unsafe in using `&lt;stacktrace&gt;`?<p>As for not using standard allocators - not a problem, just have a fixed area set aside as a buffer for crash reporting. Yes, it might not fit an extremely long report, but it&#x27;s not that much of an issue.</div><br/><div id="36579001" class="c"><input type="checkbox" id="c-36579001" checked=""/><div class="controls bullet"><span class="by">catiopatio</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36578944">parent</a><span>|</span><a href="#36579217">next</a><span>|</span><label class="collapse" for="c-36579001">[-]</label><label class="expand" for="c-36579001">[2 more]</label></div><br/><div class="children"><div class="content">Itâs not guaranteed to be async-safe. From the C++ proposal (P0881R7):<p>&gt; Note about signal safety: this proposal does not attempt to provide a signal-safe solution for capturing and decoding stacktraces. Such functionality currently is not implementable on some of the popular platforms.<p><a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2020&#x2F;p0881r7.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2020&#x2F;p08...</a><p>[edit] Replying here, because HN is doing its occasional obnoxious rate-limiting of replies:<p>Signal-safe and async-safe <i>are</i> effectively the same thing, and âasync-safeâ <i>absolutely isnât</i> the same thing as âthread-safeâ.<p>A code path that acquires a mutex can be thread-safe; thatâs absolutely not async-safe.<p>If boost implemented a fully async-safe stack unwinder, complete with DWARF expression support, Apple compact unwind encoding support, and all the other features required across platforms, then good for them â but thatâs not what &lt;stacktrace&gt; is guaranteed to provide, and such a thing is <i>still</i> not sufficient to implement anything but the most barebones portion of a real crash reporter.</div><br/><div id="36579255" class="c"><input type="checkbox" id="c-36579255" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#36577992">root</a><span>|</span><a href="#36579001">parent</a><span>|</span><a href="#36579217">next</a><span>|</span><label class="collapse" for="c-36579255">[-]</label><label class="expand" for="c-36579255">[1 more]</label></div><br/><div class="children"><div class="content">1. signal-safe and async-safe&#x2F;thread-safe is not quite the same thing, but fair enough.<p>2. The boost::stacktrace library (on which the standardization was mostly based IIANM) has a `safe_dump_to()` function for these cases.<p>See here: <a href="https:&#x2F;&#x2F;github.com&#x2F;boostorg&#x2F;stacktrace&#x2F;blob&#x2F;develop&#x2F;include&#x2F;boost&#x2F;stacktrace&#x2F;safe_dump_to.hpp#L81">https:&#x2F;&#x2F;github.com&#x2F;boostorg&#x2F;stacktrace&#x2F;blob&#x2F;develop&#x2F;include&#x2F;...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>