<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729155666290" as="style"/><link rel="stylesheet" href="styles.css?v=1729155666290"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gist.github.com/jackrusher/5139396">Hofstadter on Lisp (1983)</a> <span class="domain">(<a href="https://gist.github.com">gist.github.com</a>)</span></div><div class="subtext"><span>Eric_WVGG</span> | <span>160 comments</span></div><br/><div><div id="41862994" class="c"><input type="checkbox" id="c-41862994" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#41866884">next</a><span>|</span><label class="collapse" for="c-41862994">[-]</label><label class="expand" for="c-41862994">[5 more]</label></div><br/><div class="children"><div class="content">In case anyone else is confused by what the functions named &quot;oval&quot; and &quot;snot&quot; mean in the following example:<p><pre><code>  &gt; (cond ((eq (oval pi) pie) (oval (snot pie pi)))
  (t (eval (snoc (rac pi) pi))))
</code></pre>
I realised after a few seconds that they are meant to be &quot;eval&quot; and &quot;snoc&quot; instead.  The above code should be written as the following instead:<p><pre><code>  (cond ((eq (eval pi) pie)
         (eval (snoc pie pi)))
        (t (eval (snoc (rac pi) pi))))
</code></pre>
This article has been a fascinating read, by the way.  Kudos to the maintainer of the Gist post.  I am also sharing these corrections as comments on the Gist post.<p>EDIT #1: Downloaded a copy of the original Scientific American article from <a href="https:&#x2F;&#x2F;www.jstor.org&#x2F;stable&#x2F;24968822" rel="nofollow">https:&#x2F;&#x2F;www.jstor.org&#x2F;stable&#x2F;24968822</a> and confirmed that indeed the functions &quot;oval&quot; and &quot;snot&quot; are misspellings of &quot;eval&quot; and &quot;snoc&quot;.<p>EDIT #2: Fixed typo in this comment highlighted by @fuzztester below.</div><br/><div id="41863652" class="c"><input type="checkbox" id="c-41863652" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41862994">parent</a><span>|</span><a href="#41863410">next</a><span>|</span><label class="collapse" for="c-41863652">[-]</label><label class="expand" for="c-41863652">[2 more]</label></div><br/><div class="children"><div class="content">&gt;confirmed that indeed the functions &quot;oval&quot; and &quot;snot&quot; are misspellings of &quot;eval&quot; and &quot;snot&quot;.<p>Correction of your correction:<p>confirmed that indeed the functions &quot;oval&quot; and &quot;snot&quot; are misspellings of &quot;eval&quot; and &quot;<i>snoc</i>&quot;.<p>And I guess snoc is cons  reversed and rac is car  reversed.</div><br/><div id="41864153" class="c"><input type="checkbox" id="c-41864153" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#41862994">root</a><span>|</span><a href="#41863652">parent</a><span>|</span><a href="#41863410">next</a><span>|</span><label class="collapse" for="c-41864153">[-]</label><label class="expand" for="c-41864153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Correction of your correction<p>Thanks!  Fixed.<p>&gt; And I guess snoc is cons reversed and rac is car reversed.<p>Indeed!  That&#x27;s exactly how those functions are introduced in the article.  Quoting from the article:<p><i>&gt; The functions rdc and snoc are analogous to cdr and cons, only backwards.</i></div><br/></div></div></div></div><div id="41863410" class="c"><input type="checkbox" id="c-41863410" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41862994">parent</a><span>|</span><a href="#41863652">prev</a><span>|</span><a href="#41866884">next</a><span>|</span><label class="collapse" for="c-41863410">[-]</label><label class="expand" for="c-41863410">[2 more]</label></div><br/><div class="children"><div class="content">OCR maybe?</div><br/><div id="41867116" class="c"><input type="checkbox" id="c-41867116" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41862994">root</a><span>|</span><a href="#41863410">parent</a><span>|</span><a href="#41866884">next</a><span>|</span><label class="collapse" for="c-41867116">[-]</label><label class="expand" for="c-41867116">[1 more]</label></div><br/><div class="children"><div class="content">maybe LLM &quot;reformat&#x2F;rewrite this&quot;?</div><br/></div></div></div></div></div></div><div id="41866884" class="c"><input type="checkbox" id="c-41866884" checked=""/><div class="controls bullet"><span class="by">furyofantares</span><span>|</span><a href="#41862994">prev</a><span>|</span><a href="#41861304">next</a><span>|</span><label class="collapse" for="c-41866884">[-]</label><label class="expand" for="c-41866884">[2 more]</label></div><br/><div class="children"><div class="content">40 years ago, and 20 years into the field:<p>&gt; February, 1983<p>&gt; IN previous columns I have written quite often about the field of artificial intelligence - the search for ways to program computers so that they might come to behave with flexibility, common sense, insight, creativity, self awareness, humor, and so on.<p>This is very amusing to me because it reads like a list of things LLMs truly stink at. Though at least they finally represent some nonzero amount of movement in that direction.</div><br/><div id="41867067" class="c"><input type="checkbox" id="c-41867067" checked=""/><div class="controls bullet"><span class="by">zyklu5</span><span>|</span><a href="#41866884">parent</a><span>|</span><a href="#41861304">next</a><span>|</span><label class="collapse" for="c-41867067">[-]</label><label class="expand" for="c-41867067">[1 more]</label></div><br/><div class="children"><div class="content">You must interact with more interesting people than I because to me LLMs have demonstrated as much &quot;common sense, insight, creativity, self awareness, humor&quot; as the average person I run into (actually maybe more but that makes me sound crazy to myself).</div><br/></div></div></div></div><div id="41861304" class="c"><input type="checkbox" id="c-41861304" checked=""/><div class="controls bullet"><span class="by">oaktowner</span><span>|</span><a href="#41866884">prev</a><span>|</span><a href="#41866572">next</a><span>|</span><label class="collapse" for="c-41861304">[-]</label><label class="expand" for="c-41861304">[10 more]</label></div><br/><div class="children"><div class="content">I just love his writing so much -- he captures what I felt when I discovered Lisp. As a kid learning programming in the 80s, I had already done some BASIC, Fortran, Pascal and COBOL in high school and early college. There were differences, of course, but they had some fundamental commonality.<p>At UC Berkeley, however, the first computer science class was taught in Scheme (a dialect of Lisp)...and it absolutely blew me away. Hofstadter is right: it feels the closest to math (reminding me a <i>ton</i> of my math theory classes). It was the first <i>beautiful</i> language I discovered.<p>(edit: I forgot to paste in the quote I loved!)<p>&quot;...Lisp and Algol, are built around a kernel that seems as natural as a branch of mathematics. The kernel of Lisp has a crystalline purity that not only appeals to the esthetic sense, but also makes Lisp a far more flexible language than most others.&quot;</div><br/><div id="41863008" class="c"><input type="checkbox" id="c-41863008" checked=""/><div class="controls bullet"><span class="by">Jeff_Brown</span><span>|</span><a href="#41861304">parent</a><span>|</span><a href="#41863500">next</a><span>|</span><label class="collapse" for="c-41863008">[-]</label><label class="expand" for="c-41863008">[8 more]</label></div><br/><div class="children"><div class="content">Have you tried Haskell? It feels much closer to math to me. Definitions, not procedures. It even <i>looks</i> like math.</div><br/><div id="41863350" class="c"><input type="checkbox" id="c-41863350" checked=""/><div class="controls bullet"><span class="by">oaktowner</span><span>|</span><a href="#41861304">root</a><span>|</span><a href="#41863008">parent</a><span>|</span><a href="#41867173">next</a><span>|</span><label class="collapse" for="c-41863350">[-]</label><label class="expand" for="c-41863350">[5 more]</label></div><br/><div class="children"><div class="content">No! After about 10 years of writing software professionally, I moved over to product management, and my time spent coding decreased drastically (in the last 15 years, only some Python to show my kids a thing or two).<p>But I&#x27;d love to try! Maybe I&#x27;ll take an online class for fun.</div><br/><div id="41864278" class="c"><input type="checkbox" id="c-41864278" checked=""/><div class="controls bullet"><span class="by">Jeff_Brown</span><span>|</span><a href="#41861304">root</a><span>|</span><a href="#41863350">parent</a><span>|</span><a href="#41867173">next</a><span>|</span><label class="collapse" for="c-41864278">[-]</label><label class="expand" for="c-41864278">[4 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t recommend it highly enough. You&#x27;re already familiar with laziness from Lisp, but purity is another head-trip. It made me a better programmer in any language, and even a better software architect before I&#x27;ve written a line of code.<p>And algebraic data types make it possible to make your code conform to reality in ways that classes can&#x27;t. Once you&#x27;re exposed to them, it&#x27;s very much like learning about addition after having been able to multiply for your whole life. (In fact that&#x27;s more than a metaphor -- it&#x27;s what&#x27;s happening, in a category theoretic sense.)<p>Haskell has other cool stuff too -- lenses, effect systems, recursion schemes, searching for functions based on their type signatures, really it&#x27;s a very long list -- but I think laziness, purity and ADTs are the ones that really changed my brain for the better.</div><br/><div id="41864839" class="c"><input type="checkbox" id="c-41864839" checked=""/><div class="controls bullet"><span class="by">sourcepluck</span><span>|</span><a href="#41861304">root</a><span>|</span><a href="#41864278">parent</a><span>|</span><a href="#41865980">next</a><span>|</span><label class="collapse" for="c-41864839">[-]</label><label class="expand" for="c-41864839">[1 more]</label></div><br/><div class="children"><div class="content">Have you tried Coalton? It&#x27;s a Common Lisp library that adds Haskell-esque (or near-Haskell) type wonders, and which smoothly interoperates with your Common Lisp code.<p>Your comment is great though, consider me convinced. I&#x27;ve done a bit of messing with Lisp, but really would like to try write something in Haskell, or slog through a book or two, some day.</div><br/></div></div><div id="41865980" class="c"><input type="checkbox" id="c-41865980" checked=""/><div class="controls bullet"><span class="by">chamomeal</span><span>|</span><a href="#41861304">root</a><span>|</span><a href="#41864278">parent</a><span>|</span><a href="#41864839">prev</a><span>|</span><a href="#41867173">next</a><span>|</span><label class="collapse" for="c-41865980">[-]</label><label class="expand" for="c-41865980">[2 more]</label></div><br/><div class="children"><div class="content">Damn that was a really good pitch. I think I’m too dumb to learn Haskell though lol. I’m struggling enough with immutability in clojure!!</div><br/><div id="41867076" class="c"><input type="checkbox" id="c-41867076" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41861304">root</a><span>|</span><a href="#41865980">parent</a><span>|</span><a href="#41867173">next</a><span>|</span><label class="collapse" for="c-41867076">[-]</label><label class="expand" for="c-41867076">[1 more]</label></div><br/><div class="children"><div class="content">Haskell makes it easier, because immutability comes more natural there.</div><br/></div></div></div></div></div></div></div></div><div id="41867173" class="c"><input type="checkbox" id="c-41867173" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41861304">root</a><span>|</span><a href="#41863008">parent</a><span>|</span><a href="#41863350">prev</a><span>|</span><a href="#41865297">next</a><span>|</span><label class="collapse" for="c-41867173">[-]</label><label class="expand" for="c-41867173">[1 more]</label></div><br/><div class="children"><div class="content">Maybe Haskell is more like Bourbaki math, whereas Lisp is more like Russian style maths (ala Vladimir Arnold). I prefer the latter tbh, and I come to programming from a maths background. We are all different. Lisp to me is yet to be surpassed in terms of ergonomics when transfering my thoughts into computer code.</div><br/></div></div><div id="41865297" class="c"><input type="checkbox" id="c-41865297" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41861304">root</a><span>|</span><a href="#41863008">parent</a><span>|</span><a href="#41867173">prev</a><span>|</span><a href="#41863500">next</a><span>|</span><label class="collapse" for="c-41865297">[-]</label><label class="expand" for="c-41865297">[1 more]</label></div><br/><div class="children"><div class="content">Personal anecdote: I got a lot more out of lisp that stuck with me than Haskell. Occasionally I say &quot;oh this is a monad&quot; or think about a type signature, but that&#x27;s about it.</div><br/></div></div></div></div><div id="41863500" class="c"><input type="checkbox" id="c-41863500" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#41861304">parent</a><span>|</span><a href="#41863008">prev</a><span>|</span><a href="#41866572">next</a><span>|</span><label class="collapse" for="c-41863500">[-]</label><label class="expand" for="c-41863500">[1 more]</label></div><br/><div class="children"><div class="content">At the risk of diverging off from the original post, I also think that calling it &quot;math&quot; might make things a bit murky (and this is coming from someone who wanted to be algebraic topologist!)<p>It _is_ an elegant and minimal expression of a style of programming that is ubiquitous among dynamically-typed, garbage-collected languages. And it&#x27;s a &quot;theory&quot; in the sense that it seems complete, and that you can think of ways to solve problems into Scheme and translate that into other dynamically-typed languages and still end with an elegant solution. Emphasis on the elegant (since minimal, wart-free, consistent and orthogonal, etc.).<p>Scheme was a simplification and a &quot;cleaning up&quot; compared to conventional Lisps of the time (lexical scoping, single shared namespace for functions and variables etc.)</div><br/></div></div></div></div><div id="41866572" class="c"><input type="checkbox" id="c-41866572" checked=""/><div class="controls bullet"><span class="by">smrq</span><span>|</span><a href="#41861304">prev</a><span>|</span><a href="#41861244">next</a><span>|</span><label class="collapse" for="c-41866572">[-]</label><label class="expand" for="c-41866572">[1 more]</label></div><br/><div class="children"><div class="content">I certainly know the Lisp information in this article already, but it&#x27;s still a fun read. Hofstadter just has a charming way with words.<p>I found this bit extra amusing:<p>&gt;It would be nice as well as useful if we could create an inverse operation to readers-digest-condensed-version called rejoyce that, given any two words, would create a novel beginning and ending with them, respectively - and such that James Joyce would have written it (had he thought of it). Thus execution of the Lisp statement (rejoyce &#x27;Stately &#x27;Yes) would result in the Lisp genie generating from scratch the entire novel Ulysses. Writing this function is left as an exercise for the reader.<p>It took a while, but we got there. I don&#x27;t think 2024&#x27;s AI is quite what he had in mind in 1983, but you have to admit that reproducing text given a little seeding is a task that quite suits the AI of today.</div><br/></div></div><div id="41861244" class="c"><input type="checkbox" id="c-41861244" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#41866572">prev</a><span>|</span><a href="#41863435">next</a><span>|</span><label class="collapse" for="c-41861244">[-]</label><label class="expand" for="c-41861244">[23 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Attempting to take the car or cdr of nil causes (or should cause) the Lisp genie to cough out an error message, just as attempting to divide by zero should evoke an error message.</i><p>Interestingly, this is no longer the case.  Modern Lisps now evaluate (car nil) and (cdr nil) to nil.  In the original Lisp defined by John McCarthy, indeed CAR and CDR were undefined for NIL.  Quoting from &lt;<a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;367177.367199" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;367177.367199</a>&gt;:<p><i>&gt; Here NIL is an atomic symbol used to terminate lists.</i><p><i>&gt; car [x] is defined if and only if x is not atomic.</i><p><i>&gt; cdr [x] is also defined when x is not atomic.</i><p>However, both Common Lisp and Emacs Lisp define (car nil) and (cdr nil) to be nil.  Quoting from &lt;<a href="https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;f_car_c.htm" rel="nofollow">https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;f_car...</a>&gt;:<p><i>&gt; If x is a cons, car returns the car of that cons. If x is nil, car returns nil.</i><p><i>&gt; If x is a cons, cdr returns the cdr of that cons. If x is nil, cdr returns nil.</i><p>Also, quoting from &lt;<a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;elisp&#x2F;List-Elements.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;elisp&#x2F;Li...</a>&gt;:<p><i>&gt; Function: car cons-cell ... As a special case, if cons-cell is nil, this function returns nil.  Therefore, any list is a valid argument.  An error is signaled if the argument is not a cons cell or nil. </i><p><i>&gt; Function: cdr cons-cell ... As a special case, if cons-cell is nil, this function returns nil; therefore, any list is a valid argument.  An error is signaled if the argument is not a cons cell or nil.</i></div><br/><div id="41861327" class="c"><input type="checkbox" id="c-41861327" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#41861244">parent</a><span>|</span><a href="#41862379">next</a><span>|</span><label class="collapse" for="c-41861327">[-]</label><label class="expand" for="c-41861327">[4 more]</label></div><br/><div class="children"><div class="content">I was curious what it is like on Maclisp.  Here is a complete telnet session with Lars Brinkhoff&#x27;s public ITS:<p><pre><code>  $ telnet its.pdp10.se 10003
  Trying 88.99.191.74...
  Connected to pdp10.se.
  Escape character is &#x27;^]&#x27;.


  Connected to the KA-10 simulator MTY device, line 0

  ^Z
  TT ITS.1652. DDT.1548.
  TTY 21
  3. Lusers, Fair Share = 99%
  Welcome to ITS!

  For brief information, type ?
  For a list of colon commands, type :? and press Enter.
  For the full info system, type :INFO and Enter.

  Happy hacking!
  :LOGIN SUSAM
  TT: SUSAM; SUSAM MAIL - NON-EXISTENT DIRECTORY
  :LISP

  LISP 2156
  Alloc? n


  *
  (status lispversion)
  &#x2F;2156
  (car nil)
  NIL
  (cdr nil)
  NIL
  ^Z
  50107)   XCT 11   :LOGOUT

  TT ITS 1652  Console 21 Free. 19:55:07
  ^]
  telnet&gt; ^D Connection closed.
  $</code></pre></div><br/><div id="41863165" class="c"><input type="checkbox" id="c-41863165" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41861327">parent</a><span>|</span><a href="#41862379">next</a><span>|</span><label class="collapse" for="c-41863165">[-]</label><label class="expand" for="c-41863165">[3 more]</label></div><br/><div class="children"><div class="content">I recall reading that in early versions of Maclisp, taking the CAR or CDR of NIL worked differently: Taking its CAR would signal an error as you would expect, however taking its CDR would return the symbol plist of NIL, as internally the operation of CDR on the location of a symbol would access its plist, and that&#x27;s how it was commonly done before there was a specific form for it (and it actually still worked that way into Lisp Machine Lisp, provided you took the CDR of the locative of a symbol).<p>Apparently the behaviour of the CAR and CDR of NIL being NIL was from Interlisp, and it wasn&#x27;t until the designers of Maclisp and Interlisp met to exchange ideas that they decided to adopt that behaviour (it was also ostensibly one of the very few things they actually ended up agreeing on). The reason they chose it was because they figured operations like CADR and such would be more correct if they simply returned NIL if that part of the list didn&#x27;t exist rather than returning an error, otherwise you had to check each cons of the list every time. (If somebody can find the source for this, please link it!)</div><br/><div id="41864888" class="c"><input type="checkbox" id="c-41864888" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41863165">parent</a><span>|</span><a href="#41862379">next</a><span>|</span><label class="collapse" for="c-41864888">[-]</label><label class="expand" for="c-41864888">[2 more]</label></div><br/><div class="children"><div class="content">But of course cadr still has to check each access, to see if its of type (or cons null).  So I don&#x27;t see what was saved.</div><br/><div id="41865747" class="c"><input type="checkbox" id="c-41865747" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41864888">parent</a><span>|</span><a href="#41862379">next</a><span>|</span><label class="collapse" for="c-41865747">[-]</label><label class="expand" for="c-41865747">[1 more]</label></div><br/><div class="children"><div class="content">It would be considered &quot;the right thing&quot; to do something that&#x27;s so common you probably want it without asking. I don&#x27;t think CADR would check for NIL since it&#x27;s meant to be equivalent to (car (cdr x)), so if you wanted a safe list operation you would have to check it like this: (I&#x27;ll use CADADR because it makes the issue more apparent)<p><pre><code>  (and (car x)
       (cadr x)
       (cadar x)
       (cadadr x))
</code></pre>
You would have to write this every time you want to see if there&#x27;s a really CADADR, whereas if CAR and CDR can return NIL then you can just write (cadadr x) and CADADR can still be defined as (car (cdr (car (cdr x)))) and have the desired behaviour.</div><br/></div></div></div></div></div></div></div></div><div id="41862379" class="c"><input type="checkbox" id="c-41862379" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#41861244">parent</a><span>|</span><a href="#41861327">prev</a><span>|</span><a href="#41861751">next</a><span>|</span><label class="collapse" for="c-41862379">[-]</label><label class="expand" for="c-41862379">[2 more]</label></div><br/><div class="children"><div class="content">The use of car and cdr are such a surprisingly concrete implementation detail in the birth of a language that was designed to be mathematical. The most basic and famous operators of &quot;List Processor&quot; were created to operate not on lists but on conses, an element in a particular machine representation that Lisp uses to build data structures! Not only are conses not always interpreted as lists, but a very very important list, the base case for recursive functions on lists, is not represented by a cons.<p>Sixty years later, most Lisp programs are still full of operations on conses. A more accurate name for the language would be &quot;Cons Processor!&quot; It&#x27;s a reminder that Lisp was born in an era when a language and its implementation had to fit hand in glove. I think that makes the achievement of grounding a computer language in mathematical logic all the more remarkable.</div><br/><div id="41863799" class="c"><input type="checkbox" id="c-41863799" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41862379">parent</a><span>|</span><a href="#41861751">next</a><span>|</span><label class="collapse" for="c-41863799">[-]</label><label class="expand" for="c-41863799">[1 more]</label></div><br/><div class="children"><div class="content">maybe related to the need to <i>cons</i>erve CPU registers in 
machines of the time?<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;CAR_and_CDR" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;CAR_and_CDR</a><p>In any case, <i>AST</i>ute <i>observation</i><p>er, ASTute <i>;</i>)</div><br/></div></div></div></div><div id="41861751" class="c"><input type="checkbox" id="c-41861751" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41861244">parent</a><span>|</span><a href="#41862379">prev</a><span>|</span><a href="#41862873">next</a><span>|</span><label class="collapse" for="c-41861751">[-]</label><label class="expand" for="c-41861751">[10 more]</label></div><br/><div class="children"><div class="content">Sadly this is not the case with Scheme and it makes for very unergonomic code, especially for a newbie like me.<p>Which is a shame, because I prefer (Guile) Scheme to Common Lisp.</div><br/><div id="41863892" class="c"><input type="checkbox" id="c-41863892" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41861751">parent</a><span>|</span><a href="#41862075">next</a><span>|</span><label class="collapse" for="c-41863892">[-]</label><label class="expand" for="c-41863892">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Sadly this is not the case with Scheme and it makes for very unergonomic code,<p>How so? If car of nil returns nil, then how does a caller distinguish between a value of nil and a container&#x2F;list containing nil?<p>The only way is they can check to see if it&#x27;s a cons pair or not?  So if you have to check if it&#x27;s a cons pair then you&#x27;re doing the same thing as in scheme right?<p>I may be missing something, but isn&#x27;t it effectively the same amount of work just potentially? Need to check for nil and need to check if it&#x27;s a pair?</div><br/><div id="41864352" class="c"><input type="checkbox" id="c-41864352" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41863892">parent</a><span>|</span><a href="#41862075">next</a><span>|</span><label class="collapse" for="c-41864352">[-]</label><label class="expand" for="c-41864352">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How so? If car of nil returns nil, then how does a caller distinguish between a value of nil and a container&#x2F;list containing nil?<p>How about this?<p><pre><code>  CL-USER&gt; (null nil)
  T
  CL-USER&gt; (null &#x27;(nil))
  NIL
  CL-USER&gt;</code></pre></div><br/><div id="41865006" class="c"><input type="checkbox" id="c-41865006" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41864352">parent</a><span>|</span><a href="#41862075">next</a><span>|</span><label class="collapse" for="c-41865006">[-]</label><label class="expand" for="c-41865006">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s my point. You still need a separate call to distinguish the nil rom the list of nil case.<p>At that point, if you&#x27;re making the two calls how is LISP&#x27;s behavior any more ergonomic than Scheme. I&#x27;m not saying it&#x27;s not possible, I just don&#x27;t see it.<p>Can you show code between the two and how one is much worse than the other?</div><br/></div></div></div></div></div></div><div id="41862075" class="c"><input type="checkbox" id="c-41862075" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41861751">parent</a><span>|</span><a href="#41863892">prev</a><span>|</span><a href="#41862873">next</a><span>|</span><label class="collapse" for="c-41862075">[-]</label><label class="expand" for="c-41862075">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very tied to Common Lisp, but I&#x27;m perfectly fine with the idea of a lisp in which car and cdr would be undefined on nil.  Also, I&#x27;d be fine with a lisp in which () is not a symbol.  I don&#x27;t think these features of Common Lisp are essential or all that valuable.</div><br/><div id="41862909" class="c"><input type="checkbox" id="c-41862909" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41862075">parent</a><span>|</span><a href="#41862873">next</a><span>|</span><label class="collapse" for="c-41862909">[-]</label><label class="expand" for="c-41862909">[5 more]</label></div><br/><div class="children"><div class="content">They are not essential, but they make code that operates in lisp more compact and pleasant to write.<p>In Scheme my code is littered with<p><pre><code>  (if (null? lst)
      ;; handle empty case here
      ...)
</code></pre>
Simply because otherwise car throws an error. This whole section is often unnecessary in CL.</div><br/><div id="41867459" class="c"><input type="checkbox" id="c-41867459" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41862909">parent</a><span>|</span><a href="#41863303">next</a><span>|</span><label class="collapse" for="c-41867459">[-]</label><label class="expand" for="c-41867459">[1 more]</label></div><br/><div class="children"><div class="content">Now, which is more pleasant to read (arguably the more important question for all, but the most primitive of applications)?</div><br/></div></div><div id="41863303" class="c"><input type="checkbox" id="c-41863303" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41862909">parent</a><span>|</span><a href="#41867459">prev</a><span>|</span><a href="#41862873">next</a><span>|</span><label class="collapse" for="c-41863303">[-]</label><label class="expand" for="c-41863303">[3 more]</label></div><br/><div class="children"><div class="content">But you need to handle the empty case anyway otherwise you process nils ad infinitum.</div><br/><div id="41865061" class="c"><input type="checkbox" id="c-41865061" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41863303">parent</a><span>|</span><a href="#41862873">next</a><span>|</span><label class="collapse" for="c-41865061">[-]</label><label class="expand" for="c-41865061">[2 more]</label></div><br/><div class="children"><div class="content">You can say<p><pre><code>  (if lst
    ...)
</code></pre>
if the empty list is falsy, but Scheme eventually chose to add #t and #f. Oddly #f is the only false value but #t is not the only true value.</div><br/><div id="41867448" class="c"><input type="checkbox" id="c-41867448" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41865061">parent</a><span>|</span><a href="#41862873">next</a><span>|</span><label class="collapse" for="c-41867448">[-]</label><label class="expand" for="c-41867448">[1 more]</label></div><br/><div class="children"><div class="content">I do prefer nil being the false value as well as the empty list, even if it makes it more awkward to distinguish between &#x27;there is a result, but the result is an empty list&#x27; and &#x27;there are no results&#x27;. But that has nothing to do with car and cdr in Common Lisp treating nil as though it were `<i>(cons nil nil)</i>&#x27;. The only value in that I can see is would be if <i>rplaca</i> and <i>rplacd</i> can do some useful things with that (so `<i>(setf (car symbol-that-currently-points-at-nil) foo)</i>&#x27; and `<i>(setf (cdr stcpat) bar)</i>&#x27; do those useful things).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41862873" class="c"><input type="checkbox" id="c-41862873" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41861244">parent</a><span>|</span><a href="#41861751">prev</a><span>|</span><a href="#41862933">next</a><span>|</span><label class="collapse" for="c-41862873">[-]</label><label class="expand" for="c-41862873">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Modern Lisps now evaluate (car nil) and (cdr nil) to nil.<p>Scheme doesn&#x27;t.  Taking the CAR or CDR of nil is an error.</div><br/><div id="41863233" class="c"><input type="checkbox" id="c-41863233" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41862873">parent</a><span>|</span><a href="#41863007">next</a><span>|</span><label class="collapse" for="c-41863233">[-]</label><label class="expand" for="c-41863233">[3 more]</label></div><br/><div class="children"><div class="content">Does Scheme even have NIL in the sense that other Lisps like CL or Elisp have?  I mean in Common Lisp, we have:<p><pre><code>  CL-USER&gt; (symbolp nil)
  T
  CL-USER&gt; (atom nil)
  T
  CL-USER&gt; (listp nil)
  T
</code></pre>
Similar results in Emacs Lisp.  But in MIT Scheme, we get:<p><pre><code>  1 ]=&gt; nil

  ;Unbound variable: nil
</code></pre>
Of course, we can use () or (define nil ()) to illustrate your point.  For example:<p><pre><code>  1 ]=&gt; (car ())

  ;The object (), passed as the first argument to car, is not the correct type.
</code></pre>
But when I said NIL earlier, I really meant the symbol NIL that evaluates to NIL and is both a LIST and ATOM.  But otherwise, yes, I understand your point and agree with it.</div><br/><div id="41865146" class="c"><input type="checkbox" id="c-41865146" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41863233">parent</a><span>|</span><a href="#41863266">next</a><span>|</span><label class="collapse" for="c-41865146">[-]</label><label class="expand" for="c-41865146">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does Scheme even have NIL in the sense that other Lisps like CL or Elisp have?<p>No.  It has an empty list, which is a singleton atomic value whose type is not shared with any other object, and it has a boolean false value, which is distinct from the empty list.  A user can create a symbol named NIL, but that symbol has no characteristics that distinguish it from any other symbol.  You can, of course, bind NIL to either the empty list or boolean false (or any other value) but it can only have one value at a time (per thread).</div><br/></div></div><div id="41863266" class="c"><input type="checkbox" id="c-41863266" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41863233">parent</a><span>|</span><a href="#41865146">prev</a><span>|</span><a href="#41863007">next</a><span>|</span><label class="collapse" for="c-41863266">[-]</label><label class="expand" for="c-41863266">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe so, standardly. Guile scheme added the value `#nil&#x27; which is equivalent to NIL and distinct from #f and the empty list, but this was done in order to support Emacs Lisp.</div><br/></div></div></div></div><div id="41863007" class="c"><input type="checkbox" id="c-41863007" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41861244">root</a><span>|</span><a href="#41862873">parent</a><span>|</span><a href="#41863233">prev</a><span>|</span><a href="#41862933">next</a><span>|</span><label class="collapse" for="c-41863007">[-]</label><label class="expand" for="c-41863007">[1 more]</label></div><br/><div class="children"><div class="content">Elisp and CL do.</div><br/></div></div></div></div><div id="41862933" class="c"><input type="checkbox" id="c-41862933" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41861244">parent</a><span>|</span><a href="#41862873">prev</a><span>|</span><a href="#41863435">next</a><span>|</span><label class="collapse" for="c-41862933">[-]</label><label class="expand" for="c-41862933">[1 more]</label></div><br/><div class="children"><div class="content">There really should be two different kinds of cons cells, one for &quot;proper&quot; linked lists and another for general purpose consing. The difference is that the cdr of the first kind of cons cell (I&#x27;ll call it a PL-cons) can only be NIL or another PL-cons, not anything else. This would eliminate vast categories of bugs. It would also make the predicate for determining is something was a proper list run in constant time rather than O(n). (There would still be edge cases with circular lists, but those are much less common than non-proper lists.)</div><br/></div></div></div></div><div id="41863435" class="c"><input type="checkbox" id="c-41863435" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#41861244">prev</a><span>|</span><a href="#41860340">next</a><span>|</span><label class="collapse" for="c-41863435">[-]</label><label class="expand" for="c-41863435">[2 more]</label></div><br/><div class="children"><div class="content">This article, and the two companion articles it mentions, can be found in the book &quot;Metamagical Themas&quot; [0] in chapters 17-19, as well as all of his other articles that appeared in this series of Scientific American.<p>[0]: <a href="https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;181239.Metamagical_Themas" rel="nofollow">https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;181239.Metamagical_Thema...</a><p>(the book&#x27;s title is the article series, which originated as an anagram of the article series that Martin Gardner authored, &quot;Mathematical Games,&quot; also published in Scientific American and which Hofstadter then took over)</div><br/><div id="41865009" class="c"><input type="checkbox" id="c-41865009" checked=""/><div class="controls bullet"><span class="by">antitoi</span><span>|</span><a href="#41863435">parent</a><span>|</span><a href="#41860340">next</a><span>|</span><label class="collapse" for="c-41865009">[-]</label><label class="expand" for="c-41865009">[1 more]</label></div><br/><div class="children"><div class="content">I love this book. Highly recommended for all lovers of Godel Escher Bach (his classic).</div><br/></div></div></div></div><div id="41860340" class="c"><input type="checkbox" id="c-41860340" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41863435">prev</a><span>|</span><a href="#41862928">next</a><span>|</span><label class="collapse" for="c-41860340">[-]</label><label class="expand" for="c-41860340">[25 more]</label></div><br/><div class="children"><div class="content">I do think LISP remains the major language that can encompass the strange loop idea he explored in his work.  I know LISP is not the only homoiconic language, but it is the biggest that people know how to use where the &quot;eval&quot; function doesn&#x27;t take in a string that has to be parsed.<p>I hate that people are convinced LISP == functional programming, writ large.  Not that I dislike functional programming, but the symbolic nature of it is far more interesting to me.  And it amuses me to no end that I can easily make a section of code that is driven by (go tag) sections, such that I can get GOTO programming in it very easily.</div><br/><div id="41860620" class="c"><input type="checkbox" id="c-41860620" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41860340">parent</a><span>|</span><a href="#41860888">next</a><span>|</span><label class="collapse" for="c-41860620">[-]</label><label class="expand" for="c-41860620">[10 more]</label></div><br/><div class="children"><div class="content">Another (properly functional) homoiconic language that enjoyed mainstream adoption briefly in &#x27;00s is XSLT. Its metaprogramming features were rather widely used, that is, producing an XSLT from XSLT and maybe some more XML, instead of hand-coding something repetitive,  was rather normal.<p>The syntax was a bigger problem than Lisp&#x27;s syntax, though.<p>It&#x27;s not easy to produce a language with a syntax that&#x27;s good as daily use syntax, but is also not unwieldy as an AST. Lisp is one of the few relatively successful examples.</div><br/><div id="41863504" class="c"><input type="checkbox" id="c-41863504" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860620">parent</a><span>|</span><a href="#41861081">next</a><span>|</span><label class="collapse" for="c-41863504">[-]</label><label class="expand" for="c-41863504">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how many other languages use it but I&#x27;ve long admired Elixir&#x27;s approach to giving devs access to the AST using its basic types in order to write macros:<p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;macros.html" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;macros.html</a><p>It is certainly possible to implement this sort of thing in other languages, I think, depending on the compilation or preprocessing setup</div><br/><div id="41867355" class="c"><input type="checkbox" id="c-41867355" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41863504">parent</a><span>|</span><a href="#41861081">next</a><span>|</span><label class="collapse" for="c-41867355">[-]</label><label class="expand" for="c-41867355">[1 more]</label></div><br/><div class="children"><div class="content">Possible doesnt mean &quot;requires same ammount of effort&quot;</div><br/></div></div></div></div><div id="41861081" class="c"><input type="checkbox" id="c-41861081" checked=""/><div class="controls bullet"><span class="by">apex_sloth</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860620">parent</a><span>|</span><a href="#41863504">prev</a><span>|</span><a href="#41860924">next</a><span>|</span><label class="collapse" for="c-41861081">[-]</label><label class="expand" for="c-41861081">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this little flashback to when I had to write XSLT for apache cocoon as my student job</div><br/></div></div><div id="41860924" class="c"><input type="checkbox" id="c-41860924" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860620">parent</a><span>|</span><a href="#41861081">prev</a><span>|</span><a href="#41860888">next</a><span>|</span><label class="collapse" for="c-41860924">[-]</label><label class="expand" for="c-41860924">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The syntax was a bigger problem than Lisp&#x27;s syntax, though.<p>Yeah.  XML and S expressions are pretty close to functionally equivalent.  But once you&#x27;ve seen S expressions, XML is <i>disgustingly</i> clumsy.</div><br/><div id="41862128" class="c"><input type="checkbox" id="c-41862128" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860924">parent</a><span>|</span><a href="#41861884">next</a><span>|</span><label class="collapse" for="c-41862128">[-]</label><label class="expand" for="c-41862128">[1 more]</label></div><br/><div class="children"><div class="content">They have a different model -- one is better for documents, and one is better for programs&#x2F;data<p>XML and HTML are attributed text, while S-expressions are more like a homogeneous tree<p>If you have more text than metadata, then they are more natural than S-expressions<p>e.g. The closing &lt;&#x2F;p&gt; may seem redundant, until you have big paragraphs of free form text, which you generally don&#x27;t in programs</div><br/></div></div><div id="41861884" class="c"><input type="checkbox" id="c-41861884" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860924">parent</a><span>|</span><a href="#41862128">prev</a><span>|</span><a href="#41862032">next</a><span>|</span><label class="collapse" for="c-41861884">[-]</label><label class="expand" for="c-41861884">[2 more]</label></div><br/><div class="children"><div class="content">SGML was intended for sparse markup in mostly plaintext files. From it grew HTML that is markup-heavy, and XML which is often 100% markup. What made sense for rare markup nodes became... suboptimal when applied in a very different role.</div><br/><div id="41862620" class="c"><input type="checkbox" id="c-41862620" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41861884">parent</a><span>|</span><a href="#41862032">next</a><span>|</span><label class="collapse" for="c-41862620">[-]</label><label class="expand" for="c-41862620">[1 more]</label></div><br/><div class="children"><div class="content">1. GML =&gt; SGML =&gt; XML<p>2. rm *<p>3. JSON<p>4. rm -rf &#x2F;</div><br/></div></div></div></div><div id="41862032" class="c"><input type="checkbox" id="c-41862032" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860924">parent</a><span>|</span><a href="#41861884">prev</a><span>|</span><a href="#41860888">next</a><span>|</span><label class="collapse" for="c-41862032">[-]</label><label class="expand" for="c-41862032">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Any data can be turned into Big Data by encoding it in XML.&quot;</div><br/><div id="41867011" class="c"><input type="checkbox" id="c-41867011" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41862032">parent</a><span>|</span><a href="#41860888">next</a><span>|</span><label class="collapse" for="c-41867011">[-]</label><label class="expand" for="c-41867011">[1 more]</label></div><br/><div class="children"><div class="content">Wow.<p>Also:<p>XML: eXtremely Murky Language<p>or Mindblowing</div><br/></div></div></div></div></div></div></div></div><div id="41860888" class="c"><input type="checkbox" id="c-41860888" checked=""/><div class="controls bullet"><span class="by">throwaway19972</span><span>|</span><a href="#41860340">parent</a><span>|</span><a href="#41860620">prev</a><span>|</span><a href="#41861136">next</a><span>|</span><label class="collapse" for="c-41860888">[-]</label><label class="expand" for="c-41860888">[4 more]</label></div><br/><div class="children"><div class="content">Not to mention specifically with Scheme and continuation-oriented programming, the line between functional and non-functional programming becomes so blurry as to become nearly meaningless.</div><br/><div id="41867036" class="c"><input type="checkbox" id="c-41867036" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860888">parent</a><span>|</span><a href="#41867362">next</a><span>|</span><label class="collapse" for="c-41867036">[-]</label><label class="expand" for="c-41867036">[1 more]</label></div><br/><div class="children"><div class="content">The definition of functional programming is itself quite blurry, says Chris Lattner (of Swift, LLVM, Mojo), in this talk I posted here recently:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41822811">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41822811</a></div><br/></div></div><div id="41867362" class="c"><input type="checkbox" id="c-41867362" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860888">parent</a><span>|</span><a href="#41867036">prev</a><span>|</span><a href="#41865848">next</a><span>|</span><label class="collapse" for="c-41867362">[-]</label><label class="expand" for="c-41867362">[1 more]</label></div><br/><div class="children"><div class="content">Even the definition of a lisp is blurry when we zoom in to find the seperation boundry</div><br/></div></div><div id="41865848" class="c"><input type="checkbox" id="c-41865848" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41860888">parent</a><span>|</span><a href="#41867362">prev</a><span>|</span><a href="#41861136">next</a><span>|</span><label class="collapse" for="c-41865848">[-]</label><label class="expand" for="c-41865848">[1 more]</label></div><br/><div class="children"><div class="content">Lambda: the ultimate GOTO</div><br/></div></div></div></div><div id="41862219" class="c"><input type="checkbox" id="c-41862219" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#41860340">parent</a><span>|</span><a href="#41861136">prev</a><span>|</span><a href="#41861546">next</a><span>|</span><label class="collapse" for="c-41862219">[-]</label><label class="expand" for="c-41862219">[8 more]</label></div><br/><div class="children"><div class="content">I love and relate to any impassioned plea on SWE esoterica, so this seems like as good of a place as any to ask: What, in practice, is this deep level of &quot;homoiconic&quot; or &quot;symbolic&quot; support used for that Python&#x27;s functools (<a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functools.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functools.html</a>) doesn&#x27;t do well? As someone building a completely LISPless symbolic AGI (sacrilege, I know), I&#x27;ve always struggled with this and would love any pointers the experts here have. Is it something to do with Monads? I never did understand Monads...<p>To make this comment more actionable, my understanding of Python&#x27;s homoiconic functionality comes down to these methods, more-or-less:<p>1. Functions that apply other functions to iterables, e.g. filter(), map(), and reduce(). AKA the bread-n-butter of modern day JavaScript.<p>2. Functions that wrap a group of functions and routes calls accordingly, e.g. @singledispatch.<p>3. Functions that provide more general control flow or performance conveniences for other functions, e.g. @cache and and partial().<p>3. Functions that arbitrarily wrap other functions, namely wraps().<p>Certainly not every language has all these defined in a standard library, but none of them seem that challenging to implement by hand when necessary -- in other words, they basically come down to conviences for calling functions in weird ways. Certainly none of these live up to the glorious descriptions of homoiconic languages in essays like this one, where &quot;self-introspection&quot; is treated as a first class concern.<p>What would a programmer in 2024 get from LISP that isn&#x27;t implemented above?</div><br/><div id="41862431" class="c"><input type="checkbox" id="c-41862431" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41862219">parent</a><span>|</span><a href="#41865845">next</a><span>|</span><label class="collapse" for="c-41862431">[-]</label><label class="expand" for="c-41862431">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m basically a shill for my one decent blog post from a while back.  :D<p><a href="https:&#x2F;&#x2F;taeric.github.io&#x2F;CodeAsData.html" rel="nofollow">https:&#x2F;&#x2F;taeric.github.io&#x2F;CodeAsData.html</a><p>The key for me really is in the signature for &quot;eval.&quot;  In python, as an example, eval takes in a string.  So, to work with the expression, it has to fully parse it with all of the danger that takes in.  For lisp, eval takes in a form.  Still dangerous to evaluate random code, mind.  But you can walk the code without evaluating it.</div><br/><div id="41864257" class="c"><input type="checkbox" id="c-41864257" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41862431">parent</a><span>|</span><a href="#41865845">next</a><span>|</span><label class="collapse" for="c-41864257">[-]</label><label class="expand" for="c-41864257">[5 more]</label></div><br/><div class="children"><div class="content">HackerNews sadly never fails to disappoint. Thanks for taking the time to share, that was <i>exactly</i> what I was looking for! Would endorse this link for any lurkers.<p>The LISP (elisp?) syntax itself gives me a headache to parse so I think I&#x27;ll stay away for now, but I&#x27;ll definitely be thinking about how to build similar functionality into my high level application code -- self modification is naturally a big part of any decent AGI project. At the risk of speaking the obvious, the last sentence was what drove it home for me:<p><pre><code>    It is not just some opaque string that gets to enjoy all of the benefits of your language. It is a first class list of elements that you can inspect and have fun with. 
</code></pre>
I&#x27;m already working with LLM-centric &quot;grammars&quot; representing sets of standpoint-specific functions (&quot;pipelines&quot;), but so far I&#x27;ve only been thinking about how to construct, modify, and employ them. Intelligently <i>composing</i> them feels like quite an interesting rabbit hole... Especially since they mostly consist of prose in minimally-symbolic wrappers, which are probably a lot easier for an engineer to mentally model--human or otherwise. Reminds me of the words of wonderful diehard LISP-a-holic Marvin Minsky:<p><pre><code>  The future work of mind design will not be much like what we do today. ...what we know as programming will change its character entirely-to an activity that I envision to be more like sculpturing.
  To program today, we must describe things very carefully because nowhere is there any margin for error. But once we have modules that know how to learn, we won’t have to specify nearly so much-and we’ll program on a grander scale, relying on learning to fill in details.
</code></pre>
In other words: What if the problem with Lisp this whole time really <i>was</i> the parentheses? ;)<p>source is <i>Logical Versus Analogical or Symbolic Versus Connectionist or Neat Versus Scruffy</i>: <a href="https:&#x2F;&#x2F;onlinelibrary.wiley.com&#x2F;doi&#x2F;full&#x2F;10.1609&#x2F;aimag.v12i2.894" rel="nofollow">https:&#x2F;&#x2F;onlinelibrary.wiley.com&#x2F;doi&#x2F;full&#x2F;10.1609&#x2F;aimag.v12i2...</a></div><br/><div id="41864594" class="c"><input type="checkbox" id="c-41864594" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41864257">parent</a><span>|</span><a href="#41867392">next</a><span>|</span><label class="collapse" for="c-41864594">[-]</label><label class="expand" for="c-41864594">[1 more]</label></div><br/><div class="children"><div class="content">Glad you liked the post.  I didn&#x27;t do any effort to make the elisp readable, so please don&#x27;t let that fully put you off the topic! :D<p>I keep meaning to expand on the idea.  I keep not doing so.  I have higher hopes that I can get back to the rubik&#x27;s cube code.  Even there, I have a hard time getting going.</div><br/></div></div><div id="41867392" class="c"><input type="checkbox" id="c-41867392" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41864257">parent</a><span>|</span><a href="#41864594">prev</a><span>|</span><a href="#41866098">next</a><span>|</span><label class="collapse" for="c-41867392">[-]</label><label class="expand" for="c-41867392">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In other words: What if the problem with Lisp this whole time really was the parentheses? ;)<p>I am yet to find a syntax style more ergonomic than s-expressions. Once you appreciate the power of structural code editing your view of s-expressions is likely to change</div><br/></div></div><div id="41866098" class="c"><input type="checkbox" id="c-41866098" checked=""/><div class="controls bullet"><span class="by">BoiledCabbage</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41864257">parent</a><span>|</span><a href="#41867392">prev</a><span>|</span><a href="#41865845">next</a><span>|</span><label class="collapse" for="c-41866098">[-]</label><label class="expand" for="c-41866098">[2 more]</label></div><br/><div class="children"><div class="content">&gt; HackerNews sadly never fails to disappoint.<p>FYI, that means the opposite of how you used it.<p>&quot;Never fails to disappoint&quot; is an idiom that means a person or thing consistently disappoints.</div><br/><div id="41867588" class="c"><input type="checkbox" id="c-41867588" checked=""/><div class="controls bullet"><span class="by">lproven</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41866098">parent</a><span>|</span><a href="#41865845">next</a><span>|</span><label class="collapse" for="c-41867588">[-]</label><label class="expand" for="c-41867588">[1 more]</label></div><br/><div class="children"><div class="content">I was grappling -- and failing -- to parse that comment. Thank you for explaining.<p>To unpack the explanation, because I was wondering how the very negative statement could be misinterpreted:<p>&quot;Never&quot; is a negative; &quot;fails&quot; is a negative; in English, two negatives cancel out.<p>&quot;Never fails to disappoint&quot; means &quot;always disappoints&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="41865845" class="c"><input type="checkbox" id="c-41865845" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#41860340">root</a><span>|</span><a href="#41862219">parent</a><span>|</span><a href="#41862431">prev</a><span>|</span><a href="#41861546">next</a><span>|</span><label class="collapse" for="c-41865845">[-]</label><label class="expand" for="c-41865845">[1 more]</label></div><br/><div class="children"><div class="content">The <i>syntax</i> of Lisp is made up of the same fundamental data types as you use when writing Lisp programs. `(+ 1 2 3)` is <i>both</i> a Lisp expression that evaluates to 6 and also a list containing four items, the symbol `+` and the numbers 1, 2, and 3.<p>In general, we can say that the Lisp language is very good at manipulating the same data types that the syntax of Lisp programs is made from. This makes it very easy to write Lisp programs that swallow up Lisp programs <i>as raw syntax</i>, analyze Lisp programs syntactically, and&#x2F;or spit out new Lisp programs <i>as raw syntax</i>.</div><br/></div></div></div></div></div></div><div id="41865389" class="c"><input type="checkbox" id="c-41865389" checked=""/><div class="controls bullet"><span class="by">timonoko</span><span>|</span><a href="#41862928">prev</a><span>|</span><a href="#41862178">next</a><span>|</span><label class="collapse" for="c-41865389">[-]</label><label class="expand" for="c-41865389">[4 more]</label></div><br/><div class="children"><div class="content">Maclisp goodness:<p><pre><code>  (compress (reverse (explode x)))
</code></pre>
Elisp much improved:<p><pre><code>  (defun explode (x)
    (if (symbolp x) (setq x (symbol-name x)))
    (string-to-list x))
  (defun compress (x) (concat x))</code></pre></div><br/><div id="41865873" class="c"><input type="checkbox" id="c-41865873" checked=""/><div class="controls bullet"><span class="by">timonoko</span><span>|</span><a href="#41865389">parent</a><span>|</span><a href="#41865620">next</a><span>|</span><label class="collapse" for="c-41865873">[-]</label><label class="expand" for="c-41865873">[1 more]</label></div><br/><div class="children"><div class="content">I was wrong: It was &quot;implode&quot; in Maclisp.<p><pre><code>  (compress (reverse (explode &#x27;ABC)))
  ;COMPRESS UNDEFINED FUNCTION OBJECT

  (implode (reverse (explode &#x27;ABC)))
  CBA
</code></pre>
The point being that I never learn any fancy string-processing commands. I just implement explode and compress.</div><br/></div></div><div id="41865620" class="c"><input type="checkbox" id="c-41865620" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#41865389">parent</a><span>|</span><a href="#41865873">prev</a><span>|</span><a href="#41862178">next</a><span>|</span><label class="collapse" for="c-41865620">[-]</label><label class="expand" for="c-41865620">[2 more]</label></div><br/><div class="children"><div class="content">(upgrade (mail (change (trash (fix (break (use (buy it))))))))</div><br/><div id="41866887" class="c"><input type="checkbox" id="c-41866887" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41865389">root</a><span>|</span><a href="#41865620">parent</a><span>|</span><a href="#41862178">next</a><span>|</span><label class="collapse" for="c-41866887">[-]</label><label class="expand" for="c-41866887">[1 more]</label></div><br/><div class="children"><div class="content">(learn (lisp) with fixnum parentheses)<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Teach_Yourself_Scheme_in_Fixnum_Days" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Teach_Yourself_Scheme_in_Fix...</a></div><br/></div></div></div></div></div></div><div id="41862178" class="c"><input type="checkbox" id="c-41862178" checked=""/><div class="controls bullet"><span class="by">eigenhombre</span><span>|</span><a href="#41865389">prev</a><span>|</span><a href="#41864347">next</a><span>|</span><label class="collapse" for="c-41862178">[-]</label><label class="expand" for="c-41862178">[3 more]</label></div><br/><div class="children"><div class="content">I loved Hofstadter&#x27;s writing on Lisp in Metamagical Themas and adapted the code in the last article of the series to Clojure for a study group at work, written up here[1].<p>[1] <a href="http:&#x2F;&#x2F;johnj.com&#x2F;posts&#x2F;oodles&#x2F;" rel="nofollow">http:&#x2F;&#x2F;johnj.com&#x2F;posts&#x2F;oodles&#x2F;</a><p>edit: clarification</div><br/><div id="41864151" class="c"><input type="checkbox" id="c-41864151" checked=""/><div class="controls bullet"><span class="by">silcoon</span><span>|</span><a href="#41862178">parent</a><span>|</span><a href="#41864347">next</a><span>|</span><label class="collapse" for="c-41864151">[-]</label><label class="expand" for="c-41864151">[2 more]</label></div><br/><div class="children"><div class="content">Nice, I wonder if there was a translation on a modern Lisp.</div><br/><div id="41864899" class="c"><input type="checkbox" id="c-41864899" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#41862178">root</a><span>|</span><a href="#41864151">parent</a><span>|</span><a href="#41864347">next</a><span>|</span><label class="collapse" for="c-41864899">[-]</label><label class="expand" for="c-41864899">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;cant&#x2F;blob&#x2F;master&#x2F;examples&#x2F;text&#x2F;oodles.cant">https:&#x2F;&#x2F;github.com&#x2F;darius&#x2F;cant&#x2F;blob&#x2F;master&#x2F;examples&#x2F;text&#x2F;ood...</a> though modern is a matter of fashion.</div><br/></div></div></div></div></div></div><div id="41864347" class="c"><input type="checkbox" id="c-41864347" checked=""/><div class="controls bullet"><span class="by">analog31</span><span>|</span><a href="#41862178">prev</a><span>|</span><a href="#41861148">next</a><span>|</span><label class="collapse" for="c-41864347">[-]</label><label class="expand" for="c-41864347">[2 more]</label></div><br/><div class="children"><div class="content">I read that article when it came out, as my parents subscribed to Scientific American. Even though I had learned BASIC and Pascal, the concepts in the article were just way over my head. Also, I had no access (that I was aware of at least) to a machine where I could try my hand at Lisp programming. Alas, I wish I had taken it more seriously.<p>At least Hofstadter was successful at getting me interested in math beyond high school.</div><br/><div id="41867602" class="c"><input type="checkbox" id="c-41867602" checked=""/><div class="controls bullet"><span class="by">lproven</span><span>|</span><a href="#41864347">parent</a><span>|</span><a href="#41861148">next</a><span>|</span><label class="collapse" for="c-41867602">[-]</label><label class="expand" for="c-41867602">[1 more]</label></div><br/><div class="children"><div class="content">Me too. I admire the <i>theory</i> of Lisp, but man, all the Lisp folks going &quot;but don&#x27;t you get it, the absence of syntax IS the syntax!&quot; don&#x27;t half get tiring.<p>For some of us, we can just about handle the simple algebraic infix stuff, and we&#x27;ll never make that leap to &quot;my god, it&#x27;s full of CARs&quot;.<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;224&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;224&#x2F;</a></div><br/></div></div></div></div><div id="41861148" class="c"><input type="checkbox" id="c-41861148" checked=""/><div class="controls bullet"><span class="by">lopatin</span><span>|</span><a href="#41864347">prev</a><span>|</span><a href="#41862357">next</a><span>|</span><label class="collapse" for="c-41861148">[-]</label><label class="expand" for="c-41861148">[4 more]</label></div><br/><div class="children"><div class="content">Any Shen people in the house?</div><br/><div id="41861197" class="c"><input type="checkbox" id="c-41861197" checked=""/><div class="controls bullet"><span class="by">corinroyal</span><span>|</span><a href="#41861148">parent</a><span>|</span><a href="#41862357">next</a><span>|</span><label class="collapse" for="c-41861197">[-]</label><label class="expand" for="c-41861197">[3 more]</label></div><br/><div class="children"><div class="content">Admirer, not user. So ambitious and gorgeous. Hosted on Common Lisp with full integration, so useful now. I hope more people check it out. The new Shen book is awesome.</div><br/><div id="41862629" class="c"><input type="checkbox" id="c-41862629" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#41861148">root</a><span>|</span><a href="#41861197">parent</a><span>|</span><a href="#41862357">next</a><span>|</span><label class="collapse" for="c-41862629">[-]</label><label class="expand" for="c-41862629">[2 more]</label></div><br/><div class="children"><div class="content">links?</div><br/><div id="41863697" class="c"><input type="checkbox" id="c-41863697" checked=""/><div class="controls bullet"><span class="by">corinroyal</span><span>|</span><a href="#41861148">root</a><span>|</span><a href="#41862629">parent</a><span>|</span><a href="#41862357">next</a><span>|</span><label class="collapse" for="c-41863697">[-]</label><label class="expand" for="c-41863697">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a link to their website with the book: <a href="https:&#x2F;&#x2F;shenlanguage.org&#x2F;TBoS&#x2F;tbos.html" rel="nofollow">https:&#x2F;&#x2F;shenlanguage.org&#x2F;TBoS&#x2F;tbos.html</a></div><br/></div></div></div></div></div></div></div></div><div id="41862357" class="c"><input type="checkbox" id="c-41862357" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#41861148">prev</a><span>|</span><a href="#41864348">next</a><span>|</span><label class="collapse" for="c-41862357">[-]</label><label class="expand" for="c-41862357">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; In a testament to the timelessness of Lisp, you can still run all the examples below in emacs if you install these aliases:</i><p><i>&gt; (defalias &#x27;plus #&#x27;+)</i><p><i>&gt; (defalias &#x27;quotient #&#x27;&#x2F;)</i><p><i>&gt; (defalias &#x27;times #&#x27;*)*<p></i>&gt; (defalias &#x27;difference #&#x27;-)*<p>Looks like we also need a defmacro for def that is used much further in the article:<p><i>&gt; &gt; (def rac (lambda (lyst) (car (reverse lyst))))</i><p>I mean the above example fails in Emacs:<p><pre><code>  ELISP&gt; (def rac (lambda (lyst) (car (reverse lyst))))
  *** Eval error ***  Symbol’s function definition is void: def
</code></pre>
If we want the above example to work, we need to define def like this:<p><pre><code>  ELISP&gt; (defmacro def (name lambda-def) `(defalias &#x27;,name ,lambda-def))
  def
</code></pre>
Now the previous example, as presented in the article, works fine:<p><pre><code>  ELISP&gt; (def rac (lambda (lyst) (car (reverse lyst))))
  rac
  ELISP&gt; (rac &#x27;(your brains)) 
  brains</code></pre></div><br/></div></div><div id="41864348" class="c"><input type="checkbox" id="c-41864348" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41862357">prev</a><span>|</span><a href="#41860593">next</a><span>|</span><label class="collapse" for="c-41864348">[-]</label><label class="expand" for="c-41864348">[8 more]</label></div><br/><div class="children"><div class="content">This article simply reinforces that the primary problem with the popularity of Lisp was people <i>explaining Lisp</i>.<p>This article, like every other Lisp article, tells pre-teen me <i>nothing that he could use</i>.  Nobody ever demonstrated how much easier task X is in Lisp over asm&#x2F;C&#x2F;Pascal&#x2F;etc.<p>By contrast, current me could have told pre-teen me &quot;Hey, that spell checker that took you 7 months to write in assembly?  Yeah, it&#x27;s damn near trivial in Lisp on a microcomputer with bank switched memory that nobody every knew how to utilize (it makes garbage collection completely deterministic even on a woefully underpowered CPU).  Watch.&quot;<p>I want to weep over the time I wasted doing programming with the equivalent of tweezers, rice grains and glue because every Lisp article and textbook repeated the same worn out lists, recursion and AI crap without ever demonstrating how to do anything <i>useful</i>.</div><br/><div id="41864986" class="c"><input type="checkbox" id="c-41864986" checked=""/><div class="controls bullet"><span class="by">troupe</span><span>|</span><a href="#41864348">parent</a><span>|</span><a href="#41864831">next</a><span>|</span><label class="collapse" for="c-41864986">[-]</label><label class="expand" for="c-41864986">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp: A Gentle Introduction to Symbolic Computation might be useful for the context you are describing. <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~dst&#x2F;LispBook&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~dst&#x2F;LispBook&#x2F;</a></div><br/></div></div><div id="41864831" class="c"><input type="checkbox" id="c-41864831" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41864348">parent</a><span>|</span><a href="#41864986">prev</a><span>|</span><a href="#41864993">next</a><span>|</span><label class="collapse" for="c-41864831">[-]</label><label class="expand" for="c-41864831">[5 more]</label></div><br/><div class="children"><div class="content">Practical Common Lisp
<a href="https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;</a></div><br/><div id="41865087" class="c"><input type="checkbox" id="c-41865087" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41864348">root</a><span>|</span><a href="#41864831">parent</a><span>|</span><a href="#41864993">next</a><span>|</span><label class="collapse" for="c-41865087">[-]</label><label class="expand" for="c-41865087">[4 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t exist back then.  Likewise SICP first edition was 1996.<p>I did have a copy of &quot;LISP: A Gentle Introduction to Symbolic Computation&quot; by Touretzky in 1986.  It wasn&#x27;t really that much better than any of the articles.  It never explained <i>why</i> using Lisp would be so much easier than anything else even for simple programming tasks.<p>Had some of the Lisp hackers deigned to do stuff on the piddly little micros and <i>write it up</i>, things would look a whole lot different today.<p>Maybe there was a magazine somewhere doing cool stuff with Lisp on micros in the 1980-1988 time frame, but I never found it.</div><br/><div id="41867225" class="c"><input type="checkbox" id="c-41867225" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#41864348">root</a><span>|</span><a href="#41865087">parent</a><span>|</span><a href="#41865509">next</a><span>|</span><label class="collapse" for="c-41867225">[-]</label><label class="expand" for="c-41867225">[1 more]</label></div><br/><div class="children"><div class="content">Generally I agree with what you are saying. I live outside the US and so this stuff from the end 70s &#x2F; early 80s was very remote. Gladly we had then a well connected university where I got in contact with some of the more interesting stuff mid 80s.<p>The book I found most useful in the early times as an introduction to Lisp and programming with it was LISP from Winston &amp; Horn. The first edition was from 1981 and the second edition from 1984. I especially liked the third edition.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lisp_(book)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lisp_(book)</a><p>Lisp on microcomputers in the early 80s was mostly not useful - that was my impression. I saw a Lisp for the Apple II, but that was very barebones. Next was Cambridge Lisp (a version of Standard Lisp) on the Atari ST. That was more complete but programming with it was a pain. Still, I found the idea of a very dynamic&amp;expressive programming language and its interactive development style very interesting. The first useful implementations on smaller computers I saw were MacScheme and Coral Lisp, both for the Macintosh, Mid 80s...<p>There were articles about Lisp in the Byte magazine early on, but having access to the software mentioned was difficult.<p>The early use cases one heard of were: computer science education, functional programming, generally experimenting with new ideas of writing software, natural language processing, symbolic mathematics, ... This was nothing which would be more attractive to a wider audience. David Betz Xlisp later made Lisp more accessible. Which was then used in AutoCAD as an extension language: AutoLisp.<p>Luckily I had starting mid 80s access at the university to the incoming stream of new research reports and there were reports about various Lisp related projects, theses, etc.</div><br/></div></div><div id="41865509" class="c"><input type="checkbox" id="c-41865509" checked=""/><div class="controls bullet"><span class="by">keithwinstein</span><span>|</span><a href="#41864348">root</a><span>|</span><a href="#41865087">parent</a><span>|</span><a href="#41867225">prev</a><span>|</span><a href="#41864993">next</a><span>|</span><label class="collapse" for="c-41865509">[-]</label><label class="expand" for="c-41865509">[2 more]</label></div><br/><div class="children"><div class="content">The first edition of SICP came out in the fall of 1984 (a year after these Hofstadter columns). This fall is the 40th anniversary!</div><br/><div id="41865520" class="c"><input type="checkbox" id="c-41865520" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41864348">root</a><span>|</span><a href="#41865509">parent</a><span>|</span><a href="#41864993">next</a><span>|</span><label class="collapse" for="c-41865520">[-]</label><label class="expand" for="c-41865520">[1 more]</label></div><br/><div class="children"><div class="content">I stand corrected on that.  Thanks.</div><br/></div></div></div></div></div></div></div></div><div id="41864993" class="c"><input type="checkbox" id="c-41864993" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#41864348">parent</a><span>|</span><a href="#41864831">prev</a><span>|</span><a href="#41860593">next</a><span>|</span><label class="collapse" for="c-41864993">[-]</label><label class="expand" for="c-41864993">[1 more]</label></div><br/><div class="children"><div class="content">Hofstadter&#x27;s followup article had a more interesting example.<p>When I first got a Byte magazine as a pre-teen, one of the articles was Lisp code for symbolic differentiation and algebraic simplification. I <i>really</i> couldn&#x27;t follow it but felt there was something intriguing there. Certainly it wouldn&#x27;t have been easier in Basic.<p>(Byte September 1981, AI theme issue. Later I was able to tell the code was not so hot...)<p>I didn&#x27;t really get into Lisp until the late 80s with XLisp on a PC, and SICP. Worth the wait!</div><br/></div></div></div></div><div id="41860593" class="c"><input type="checkbox" id="c-41860593" checked=""/><div class="controls bullet"><span class="by">waffletower</span><span>|</span><a href="#41864348">prev</a><span>|</span><a href="#41861035">next</a><span>|</span><label class="collapse" for="c-41860593">[-]</label><label class="expand" for="c-41860593">[6 more]</label></div><br/><div class="children"><div class="content">I find this article to be quaint -- remember reading it decades ago and feeling more receptive to its perspective.  Ironically, I prefer using Clojure (though some here challenge its status as a Lisp lol) to interface with Large Language Models rather than Python.  Clojure in particular is much better suited, for some reasons that Hofstadter details, and if you can interact with an LLM over a wire, you are not beholden to Python.  But what we use to interface to these massive digital minds we are building, including the Bayesian sampling mathematics we use to plumb them, may have their elegance, but they are orthogonal to the nearly ineffable chaos of these deeply interconnected neural networks -- and it is in this chaotic interconnectedness where artificial intelligence is actually engendered.</div><br/><div id="41861844" class="c"><input type="checkbox" id="c-41861844" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#41860593">parent</a><span>|</span><a href="#41861555">next</a><span>|</span><label class="collapse" for="c-41861844">[-]</label><label class="expand" for="c-41861844">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Clojure in particular is much better suited<p>Clojure in general is far better suited for manipulating data than anything else (in my personal experience). It is so lovely to send a request, get some data, and then interactively go through that data - sorting, grouping, dicing, slicing, partitioning, tranforming, etc.<p>The other way around is also true - for when you need to generate a massive amount of randomized data.</div><br/><div id="41867456" class="c"><input type="checkbox" id="c-41867456" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41860593">root</a><span>|</span><a href="#41861844">parent</a><span>|</span><a href="#41865001">next</a><span>|</span><label class="collapse" for="c-41867456">[-]</label><label class="expand" for="c-41867456">[1 more]</label></div><br/><div class="children"><div class="content">Clojure doesn&#x27;t have a standard, well-maintained dataframe library - so it is not suitable for any medium to large data science.</div><br/></div></div><div id="41865001" class="c"><input type="checkbox" id="c-41865001" checked=""/><div class="controls bullet"><span class="by">troupe</span><span>|</span><a href="#41860593">root</a><span>|</span><a href="#41861844">parent</a><span>|</span><a href="#41867456">prev</a><span>|</span><a href="#41861555">next</a><span>|</span><label class="collapse" for="c-41865001">[-]</label><label class="expand" for="c-41865001">[2 more]</label></div><br/><div class="children"><div class="content">&gt; when you need to generate a massive amount of randomized data.<p>Even faster than Clojure: Open VIM for a VS Code user and ask them to exit.</div><br/><div id="41865109" class="c"><input type="checkbox" id="c-41865109" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#41860593">root</a><span>|</span><a href="#41865001">parent</a><span>|</span><a href="#41861555">next</a><span>|</span><label class="collapse" for="c-41865109">[-]</label><label class="expand" for="c-41865109">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no such thing as a &quot;VS Code user&quot;, VS Code is the one that uses you, not the other way around.<p>btw. this isn&#x27;t some kind of an FP joke, there&#x27;s no &#x27;fun&#x27; in it, only sad truth.</div><br/></div></div></div></div></div></div></div></div><div id="41861035" class="c"><input type="checkbox" id="c-41861035" checked=""/><div class="controls bullet"><span class="by">dunefox</span><span>|</span><a href="#41860593">prev</a><span>|</span><a href="#41859847">next</a><span>|</span><label class="collapse" for="c-41861035">[-]</label><label class="expand" for="c-41861035">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I hope you enjoyed Hofstadter&#x27;s idiosyncratic tour of Lisp. You can find more like this re-printed in his book Metamagical Themas.<p>This seems like an interesting book.</div><br/><div id="41863243" class="c"><input type="checkbox" id="c-41863243" checked=""/><div class="controls bullet"><span class="by">ceautery</span><span>|</span><a href="#41861035">parent</a><span>|</span><a href="#41859847">next</a><span>|</span><label class="collapse" for="c-41863243">[-]</label><label class="expand" for="c-41863243">[1 more]</label></div><br/><div class="children"><div class="content">It was one of my favorites back in the 1980s. It was a followup to Gödel Escher Bach, written in much the same style.</div><br/></div></div></div></div><div id="41859847" class="c"><input type="checkbox" id="c-41859847" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41861035">prev</a><span>|</span><a href="#41860160">next</a><span>|</span><label class="collapse" for="c-41859847">[-]</label><label class="expand" for="c-41859847">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Emacs defalias<p>On Common Lisp too, by defining defalias as a macro:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;24252539&#x2F;defining-aliases-to-standard-common-lisp-functions" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;24252539&#x2F;defining-aliase...</a></div><br/></div></div><div id="41860160" class="c"><input type="checkbox" id="c-41860160" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41859847">prev</a><span>|</span><a href="#41860159">next</a><span>|</span><label class="collapse" for="c-41860160">[-]</label><label class="expand" for="c-41860160">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Every computer language has arbitrary features, and most languages are in fact overloaded with them. A few, however, such as Lisp and Algol, are built around a kernel that seems as natural as a branch of mathematics.<p><i>Algol?</i>  The kernel of Algol seems as natural as a branch of mathematics?  Can anyone who has <i>used</i> Algol give their opinion of this statement?</div><br/><div id="41861307" class="c"><input type="checkbox" id="c-41861307" checked=""/><div class="controls bullet"><span class="by">gavindean90</span><span>|</span><a href="#41860160">parent</a><span>|</span><a href="#41865751">next</a><span>|</span><label class="collapse" for="c-41861307">[-]</label><label class="expand" for="c-41861307">[1 more]</label></div><br/><div class="children"><div class="content">From what I’ve studied, Algol wasn’t designed for typical software development—its main purpose was to give computer scientists a way to describe algorithms with a level of rigor that mirrors mathematical notation.</div><br/></div></div><div id="41865751" class="c"><input type="checkbox" id="c-41865751" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41860160">parent</a><span>|</span><a href="#41861307">prev</a><span>|</span><a href="#41860537">next</a><span>|</span><label class="collapse" for="c-41865751">[-]</label><label class="expand" for="c-41865751">[1 more]</label></div><br/><div class="children"><div class="content">Hard to say without knowing which version of Algol he is referring to.  Algol 68 was very different from Algol 58.<p>Algol 60 was the first language with lexical scope, while Algol 68 was a kitchen-sink language that (positively) influenced Python and (negatively) influenced Pascal.</div><br/></div></div><div id="41860537" class="c"><input type="checkbox" id="c-41860537" checked=""/><div class="controls bullet"><span class="by">andyjohnson0</span><span>|</span><a href="#41860160">parent</a><span>|</span><a href="#41865751">prev</a><span>|</span><a href="#41865080">next</a><span>|</span><label class="collapse" for="c-41860537">[-]</label><label class="expand" for="c-41860537">[3 more]</label></div><br/><div class="children"><div class="content">I did some Algol programming back in the late 80s - when it had mostly been obsoleted by Pascal, Modula, and even C for what we called &quot;structured programming&quot; back then.<p>I remember it as a likeable, economical, expressive language, without significant warts, and which had clearly been influential by being ahead of its time.<p>So my guess is that Hofstadter was just referring to its practical elegance - rather than the more theoretical elegance of Lisp.</div><br/><div id="41863518" class="c"><input type="checkbox" id="c-41863518" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#41860160">root</a><span>|</span><a href="#41860537">parent</a><span>|</span><a href="#41865080">next</a><span>|</span><label class="collapse" for="c-41863518">[-]</label><label class="expand" for="c-41863518">[2 more]</label></div><br/><div class="children"><div class="content">Out of curiosity: which dialect on Algol, and on what platform?</div><br/><div id="41867202" class="c"><input type="checkbox" id="c-41867202" checked=""/><div class="controls bullet"><span class="by">andyjohnson0</span><span>|</span><a href="#41860160">root</a><span>|</span><a href="#41863518">parent</a><span>|</span><a href="#41865080">next</a><span>|</span><label class="collapse" for="c-41867202">[-]</label><label class="expand" for="c-41867202">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure, but possibly Algol 68. It was on an IBM mainframe running VM&#x2F;CMS - possibly a 3090.<p>Long time ago...</div><br/></div></div></div></div></div></div><div id="41865080" class="c"><input type="checkbox" id="c-41865080" checked=""/><div class="controls bullet"><span class="by">earthicus</span><span>|</span><a href="#41860160">parent</a><span>|</span><a href="#41860537">prev</a><span>|</span><a href="#41863999">next</a><span>|</span><label class="collapse" for="c-41865080">[-]</label><label class="expand" for="c-41865080">[1 more]</label></div><br/><div class="children"><div class="content">It was discovered that the procedure mechanism of Algol 60 was effectively equivalent to the lambda calulus. This insight was written out in a famous paper by Peter Landin, &quot;Correspondence between ALGOL 60 and Church&#x27;s Lambda-notation: part I&quot;<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;363744.363749" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;363744.363749</a></div><br/></div></div><div id="41863999" class="c"><input type="checkbox" id="c-41863999" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#41860160">parent</a><span>|</span><a href="#41865080">prev</a><span>|</span><a href="#41863968">next</a><span>|</span><label class="collapse" for="c-41863999">[-]</label><label class="expand" for="c-41863999">[2 more]</label></div><br/><div class="children"><div class="content">C is basically Algol with curly braces and pointers.  The sentiment expressed there is probably equally applicable to C, or maybe Pascal.  Those are often held up today as a minimal example in contrast to Lisp.  There is a sort of sparse, warty elegance to the family.  Blocks, arrays, if&#x2F;then, assignment, while loops.  What more could you need?</div><br/><div id="41865392" class="c"><input type="checkbox" id="c-41865392" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41860160">root</a><span>|</span><a href="#41863999">parent</a><span>|</span><a href="#41863968">next</a><span>|</span><label class="collapse" for="c-41865392">[-]</label><label class="expand" for="c-41865392">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used both C and Pascal.  The simplicity of C comes through to me (less so Pascal - the verbosity gets in the way).  I never thought of it as &quot;as natural as a branch of mathematics&quot;, though.<p>I mean... I guess you could think of it as having its own set of self-consistent axioms, and from them you can build things.  It&#x27;s a lot larger set of axioms than most branches of mathematics, though.<p>I guess, if Hofstadter meant the same level of naturalness, well, yes, C did feel pretty natural to me, so... maybe?</div><br/></div></div></div></div></div></div><div id="41860159" class="c"><input type="checkbox" id="c-41860159" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#41860160">prev</a><span>|</span><a href="#41860281">next</a><span>|</span><label class="collapse" for="c-41860159">[-]</label><label class="expand" for="c-41860159">[28 more]</label></div><br/><div class="children"><div class="content">&gt; Why is most AI work done in Lisp?<p>That’s changed, of course, but it remained true for at least another 15 or 20 years after this article was written and then changed rather quickly, perhaps cemented with deep neural networks and GPUs.<p>Other than running the emacs ecosystem, what else is Lisp being used for commonly these days?</div><br/><div id="41860409" class="c"><input type="checkbox" id="c-41860409" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41861146">next</a><span>|</span><label class="collapse" for="c-41860409">[-]</label><label class="expand" for="c-41860409">[3 more]</label></div><br/><div class="children"><div class="content">Some purist won&#x27;t consider Clojure a &quot;true&quot; Lisp, but it&#x27;s a Lisp dialect.<p>&gt; what else is Lisp being used for commonly these days?<p>Anything that runs on Clojure - Cisco has their cybersec platform and tooling running on it; Walmart their receipt system; Apple - their payments (or something, not sure); Nubank&#x27;s entire business runs on it; CircleCI; Embraer - I know uses Clojure for pipelines, not sure about CL, in general Common Lisp I think still quite used for aircraft design and CAD modeling; Grammarly - use both Common Lisp and Clojure; Many startups use Clojure and Clojurescript.<p>Fennel - Clojure-like language that compiles to Lua can handle anything Lua-based - people build games, use it to configure their Hammerspoon, AwesomeWM, MPV, Wez terminal and things-alike, even Neovim - it&#x27;s almost weird how we&#x27;re circling back - decades of arguing Emacs vs. Vim, and now getting Vim to embrace Lisp.</div><br/><div id="41861671" class="c"><input type="checkbox" id="c-41861671" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860409">parent</a><span>|</span><a href="#41862563">next</a><span>|</span><label class="collapse" for="c-41861671">[-]</label><label class="expand" for="c-41861671">[1 more]</label></div><br/><div class="children"><div class="content">When I was there, Apple used Clojure for a lot of stuff involving the indexing of iTunes&#x2F;Apple Music. I used it for some telemetry stuff on top of the indexer as well.  Not sure what other teams used it for.</div><br/></div></div><div id="41862563" class="c"><input type="checkbox" id="c-41862563" checked=""/><div class="controls bullet"><span class="by">SSLy</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860409">parent</a><span>|</span><a href="#41861671">prev</a><span>|</span><a href="#41861146">next</a><span>|</span><label class="collapse" for="c-41862563">[-]</label><label class="expand" for="c-41862563">[1 more]</label></div><br/><div class="children"><div class="content">Google Flights was built on CL, no?</div><br/></div></div></div></div><div id="41861146" class="c"><input type="checkbox" id="c-41861146" checked=""/><div class="controls bullet"><span class="by">sourcepluck</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41860409">prev</a><span>|</span><a href="#41860851">next</a><span>|</span><label class="collapse" for="c-41861146">[-]</label><label class="expand" for="c-41861146">[1 more]</label></div><br/><div class="children"><div class="content">I think personally that Coalton and the stuff its built on is crazy cool. Coalton is a little library you add to your Lisp, but, to quote the third link here: &quot;In terms of its type system, Coalton’s closest cousin is Haskell.&quot; So Lisp&#x27;s dynamism with all sorts of advanced typing.<p>QVM, a Quantum Virtual Machine <a href="https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;qvm">https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;qvm</a><p>Quilc, an &quot;advanced optimizing compiler&quot; for Quil <a href="https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;quilc">https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;quilc</a><p>Coalton, &quot;a statically typed functional programming language built with Common Lisp.&quot; <a href="https:&#x2F;&#x2F;coalton-lang.github.io&#x2F;20211010-introducing-coalton&#x2F;" rel="nofollow">https:&#x2F;&#x2F;coalton-lang.github.io&#x2F;20211010-introducing-coalton&#x2F;</a></div><br/></div></div><div id="41860851" class="c"><input type="checkbox" id="c-41860851" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41861146">prev</a><span>|</span><a href="#41860283">next</a><span>|</span><label class="collapse" for="c-41860851">[-]</label><label class="expand" for="c-41860851">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Why is most AI work done in Lisp?<p>Yann LeCun developed Lush, which is a Lisp for neural networks, during the early days of deep architectures. See <a href="https:&#x2F;&#x2F;yann.lecun.com&#x2F;ex&#x2F;downloads&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;yann.lecun.com&#x2F;ex&#x2F;downloads&#x2F;index.html</a> and <a href="https:&#x2F;&#x2F;lush.sourceforge.net" rel="nofollow">https:&#x2F;&#x2F;lush.sourceforge.net</a>. Things moved to Python after a brief period when Lua was also a serious contender. LeCun is not pleased with Python. I can&#x27;t find his comments now, but he thinks Python is not an ideal solution. Hard to argue with that, as its mostly a thin wrapper over C&#x2F;C++&#x2F;FORTRAN that poses an obvious two-language problem.</div><br/><div id="41861684" class="c"><input type="checkbox" id="c-41861684" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860851">parent</a><span>|</span><a href="#41862306">next</a><span>|</span><label class="collapse" for="c-41861684">[-]</label><label class="expand" for="c-41861684">[1 more]</label></div><br/><div class="children"><div class="content">A friend used lush as his “secret weapon” for a while.  I didn’t quite warm to it and now regret not paying attention.   It’s amazing how much is packed in “batteries included.”<p>Apparently it didn’t make the transition to 64-bit machines well?  But I haven’t really looked.</div><br/></div></div><div id="41862306" class="c"><input type="checkbox" id="c-41862306" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860851">parent</a><span>|</span><a href="#41861684">prev</a><span>|</span><a href="#41861189">next</a><span>|</span><label class="collapse" for="c-41862306">[-]</label><label class="expand" for="c-41862306">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just as easy to have thin wrappers over C&#x2F;etc. number crunching libraries in Common Lisp as it is Python. And pure CL code is typically faster than pure Python (though pypy might be a different story). There&#x27;s no technical reason it still couldn&#x27;t be dominant in AI.<p>It&#x27;s a shame things took the course they did with preferred languages.</div><br/><div id="41866513" class="c"><input type="checkbox" id="c-41866513" checked=""/><div class="controls bullet"><span class="by">mportela</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41862306">parent</a><span>|</span><a href="#41861189">next</a><span>|</span><label class="collapse" for="c-41866513">[-]</label><label class="expand" for="c-41866513">[1 more]</label></div><br/><div class="children"><div class="content">My take is that Python won by having a complete ecosystem centralizing many tools that were dispersed in different languages:
- Numpy&#x2F;Scipy&#x2F;Matplotlib enabled scientists to do data analysis with Panda similar to what was available in R
- PySpark enabled big data scripts in Python instead of Scala
- PyTorch made Torch available for non-Lua users<p>Bit by bit, more people got used to doing data analysis and AI research in Python. Some projects were even written for Python first (e.g. Tensorflow or Keras). Eventually, Python had so many high-quality packages that it became the de facto for modern AI.<p>Is it the _best_ language for AI, though? I doubt. However, it is good enough for most use cases.</div><br/></div></div></div></div><div id="41861189" class="c"><input type="checkbox" id="c-41861189" checked=""/><div class="controls bullet"><span class="by">sourcepluck</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860851">parent</a><span>|</span><a href="#41862306">prev</a><span>|</span><a href="#41860283">next</a><span>|</span><label class="collapse" for="c-41861189">[-]</label><label class="expand" for="c-41861189">[1 more]</label></div><br/><div class="children"><div class="content">Hadn&#x27;t seen that before, very interesting!</div><br/></div></div></div></div><div id="41860283" class="c"><input type="checkbox" id="c-41860283" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41860851">prev</a><span>|</span><a href="#41861256">next</a><span>|</span><label class="collapse" for="c-41860283">[-]</label><label class="expand" for="c-41860283">[7 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t speak for the entire industry obviously, but at a few jobs I&#x27;ve had [1] Clojure is used pretty liberally for network-heavy stuff, largely because it&#x27;s JVM and core.async is pretty handy for handling concurrency.<p>I know a lot of people classify &quot;Clojure&quot; and &quot;Lisp&quot; in different categories, but I&#x27;m not 100% sure why.<p>[1] Usual disclaimer: It&#x27;s not hard to find my job history, I don&#x27;t hide it, but I politely ask that you don&#x27;t post it here.</div><br/><div id="41860365" class="c"><input type="checkbox" id="c-41860365" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860283">parent</a><span>|</span><a href="#41861256">next</a><span>|</span><label class="collapse" for="c-41860365">[-]</label><label class="expand" for="c-41860365">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I know a lot of people classify &quot;Clojure&quot; and &quot;Lisp&quot; in different categories, but I&#x27;m not 100% sure why<p>It mostly boils down to Clojure not having CONS cells. I feel like this distinction is arbitrary because the interesting aspect of Lisps is <i>not</i> the fact that linked-lists are the core data-structure (linked-lists <i>mostly</i> suck on modern hardware), but rather that the code itself is a tree of lists that enables the code to be homoiconic.</div><br/><div id="41860430" class="c"><input type="checkbox" id="c-41860430" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860365">parent</a><span>|</span><a href="#41861256">next</a><span>|</span><label class="collapse" for="c-41860430">[-]</label><label class="expand" for="c-41860430">[5 more]</label></div><br/><div class="children"><div class="content">I mean, you can have a tree of vectors also, so I don&#x27;t see why lists are needed for homoiconicity.</div><br/><div id="41860605" class="c"><input type="checkbox" id="c-41860605" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860430">parent</a><span>|</span><a href="#41860737">next</a><span>|</span><label class="collapse" for="c-41860605">[-]</label><label class="expand" for="c-41860605">[3 more]</label></div><br/><div class="children"><div class="content">No, not needed. This argumentation can go both ways; some may even say, &quot;Well, Python is &#x27;Lispy,&#x27;&quot; which to me is obviously not. It boils down to what can you do in the REPL, right? <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41844611">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41844611</a></div><br/><div id="41861002" class="c"><input type="checkbox" id="c-41861002" checked=""/><div class="controls bullet"><span class="by">vnorilo</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860605">parent</a><span>|</span><a href="#41860737">next</a><span>|</span><label class="collapse" for="c-41861002">[-]</label><label class="expand" for="c-41861002">[2 more]</label></div><br/><div class="children"><div class="content">In my mind Clojure is Lispy, Python is not, nor is Javascript.<p>In addition to REPL and macros, I think two other Lispy features are essential:<p>nil is not just the sad path poison value that makes everything explode: lisp is written so that optionals compose well.<p>Speaking of composing, Lisps tend to be amazing with regard to composability. This is another line that cuts between CL, Scheme and Clojure on one side, with Python and Javascript firmly on the other side in my experience.<p>Lisps are as dynamic a languages ever go, unapologetically.</div><br/><div id="41861322" class="c"><input type="checkbox" id="c-41861322" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41861002">parent</a><span>|</span><a href="#41860737">next</a><span>|</span><label class="collapse" for="c-41861322">[-]</label><label class="expand" for="c-41861322">[1 more]</label></div><br/><div class="children"><div class="content">I just wanted to add that &quot;dynamic&quot; doesn&#x27;t mean untyped or weakly typed. Clojure is a strongly-typed dynamicly-typed PL. Clojurescript compiler for example, in many cases can produce safer JS code than even Typescript ever could.</div><br/></div></div></div></div></div></div><div id="41860737" class="c"><input type="checkbox" id="c-41860737" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41860430">parent</a><span>|</span><a href="#41860605">prev</a><span>|</span><a href="#41861256">next</a><span>|</span><label class="collapse" for="c-41860737">[-]</label><label class="expand" for="c-41860737">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s mostly my point. A linked-list structure is <i>not</i> the interesting part. I use the &quot;generic&quot; reading of list above and don&#x27;t mean to imply some particular implementation</div><br/></div></div></div></div></div></div></div></div><div id="41861256" class="c"><input type="checkbox" id="c-41861256" checked=""/><div class="controls bullet"><span class="by">ryukafalz</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41860283">prev</a><span>|</span><a href="#41861331">next</a><span>|</span><label class="collapse" for="c-41861256">[-]</label><label class="expand" for="c-41861256">[1 more]</label></div><br/><div class="children"><div class="content">Guix is a Nix-like package manager and distro that is almost entirely written in Guile Scheme: <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;</a><p>I would guess it&#x27;s by far the most active Guile project.</div><br/></div></div><div id="41861331" class="c"><input type="checkbox" id="c-41861331" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41861256">prev</a><span>|</span><a href="#41860590">next</a><span>|</span><label class="collapse" for="c-41861331">[-]</label><label class="expand" for="c-41861331">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>what [...] is Lisp being used for [...] these days?</i><p>I dunno, there&#x27;s Nyxt, Google Flights, MediKanren, there&#x27;s some German HPC guys doing stuff with SBCL, Kandria,... I believe there&#x27;s also a HFT guy using Lisp who&#x27;s here on HN. LispWorks and Franz are also still trucking, so they prolly have clientele.<p>There are fewer great big FLOSS Lisp projects than C or Rust, but that doesn&#x27;t really tell the whole story. Unfortunately proprietary and internal projects are less visible.</div><br/></div></div><div id="41860590" class="c"><input type="checkbox" id="c-41860590" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41861331">prev</a><span>|</span><a href="#41866917">next</a><span>|</span><label class="collapse" for="c-41860590">[-]</label><label class="expand" for="c-41860590">[1 more]</label></div><br/><div class="children"><div class="content">&gt;what else is Lisp being used for commonly these days?<p>It is being used for formal verification in the semiconductor industry by companies like AMD, Arm, Intel, and IBM: <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~moore&#x2F;acl2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~moore&#x2F;acl2&#x2F;</a></div><br/></div></div><div id="41866917" class="c"><input type="checkbox" id="c-41866917" checked=""/><div class="controls bullet"><span class="by">knbknb</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41860590">prev</a><span>|</span><a href="#41861317">next</a><span>|</span><label class="collapse" for="c-41866917">[-]</label><label class="expand" for="c-41866917">[1 more]</label></div><br/><div class="children"><div class="content">Some computer science departments (and their MOOCs) use Lisp Dialects &quot;Racket&quot; and &quot;Scheme&quot; as a Teaching Language . For example, IDE DrRacket has an innovative language preselection feature that allows students to start out with a &quot;Beginning Student Language&quot;.<p><a href="https:&#x2F;&#x2F;www.racket-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.racket-lang.org&#x2F;</a></div><br/></div></div><div id="41861317" class="c"><input type="checkbox" id="c-41861317" checked=""/><div class="controls bullet"><span class="by">vindarel</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41866917">prev</a><span>|</span><a href="#41861289">next</a><span>|</span><label class="collapse" for="c-41861317">[-]</label><label class="expand" for="c-41861317">[1 more]</label></div><br/><div class="children"><div class="content">Quantum computing and symbolic AI? But also web services, CAD and 3D software, trading, designing programmable chips, big data analytics…<p>present companies (that we know about): <a href="https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies&#x2F;</a></div><br/></div></div><div id="41861289" class="c"><input type="checkbox" id="c-41861289" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41861317">prev</a><span>|</span><a href="#41860450">next</a><span>|</span><label class="collapse" for="c-41861289">[-]</label><label class="expand" for="c-41861289">[1 more]</label></div><br/><div class="children"><div class="content">Grammarly was famously using it.<p><a href="https:&#x2F;&#x2F;www.grammarly.com&#x2F;blog&#x2F;engineering&#x2F;running-lisp-in-production&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.grammarly.com&#x2F;blog&#x2F;engineering&#x2F;running-lisp-in-p...</a></div><br/></div></div><div id="41860450" class="c"><input type="checkbox" id="c-41860450" checked=""/><div class="controls bullet"><span class="by">casta</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41861289">prev</a><span>|</span><a href="#41860189">next</a><span>|</span><label class="collapse" for="c-41860450">[-]</label><label class="expand" for="c-41860450">[1 more]</label></div><br/><div class="children"><div class="content">The pricing engine for Google Flights (and behind many big airline websites) is written in Lisp.</div><br/></div></div><div id="41860189" class="c"><input type="checkbox" id="c-41860189" checked=""/><div class="controls bullet"><span class="by">volltrottel</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41860450">prev</a><span>|</span><a href="#41861541">next</a><span>|</span><label class="collapse" for="c-41860189">[-]</label><label class="expand" for="c-41860189">[1 more]</label></div><br/><div class="children"><div class="content">Running hacker news</div><br/></div></div><div id="41861541" class="c"><input type="checkbox" id="c-41861541" checked=""/><div class="controls bullet"><span class="by">chromaton</span><span>|</span><a href="#41860159">parent</a><span>|</span><a href="#41860189">prev</a><span>|</span><a href="#41861549">next</a><span>|</span><label class="collapse" for="c-41861541">[-]</label><label class="expand" for="c-41861541">[2 more]</label></div><br/><div class="children"><div class="content">AutoCAD automation?</div><br/><div id="41862161" class="c"><input type="checkbox" id="c-41862161" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41860159">root</a><span>|</span><a href="#41861541">parent</a><span>|</span><a href="#41861549">next</a><span>|</span><label class="collapse" for="c-41862161">[-]</label><label class="expand" for="c-41862161">[1 more]</label></div><br/><div class="children"><div class="content">Yes. AutoLisp was available from the early days of AutoCAD. I didn&#x27;t use it much myself. I just helped some mechanical engineers with it in a company where I worked, in small ways, just tinkering, really. At that time I was quite junior, so I didn&#x27;t really grasp the power of it, so I didn&#x27;t play around with it much.</div><br/></div></div></div></div></div></div><div id="41860281" class="c"><input type="checkbox" id="c-41860281" checked=""/><div class="controls bullet"><span class="by">kjellsbells</span><span>|</span><a href="#41860159">prev</a><span>|</span><a href="#41862460">next</a><span>|</span><label class="collapse" for="c-41860281">[-]</label><label class="expand" for="c-41860281">[12 more]</label></div><br/><div class="children"><div class="content">Regardless of your opinion on the utility of Lisp, this is an exemplary piece of writing. Crisp, engaging, informative.<p>God I miss old Scientific American. Today&#x27;s SA isn&#x27;t especially terrible, but old SA, like old BYTE, was reliably enlightening.</div><br/><div id="41860442" class="c"><input type="checkbox" id="c-41860442" checked=""/><div class="controls bullet"><span class="by">sgustard</span><span>|</span><a href="#41860281">parent</a><span>|</span><a href="#41860505">next</a><span>|</span><label class="collapse" for="c-41860442">[-]</label><label class="expand" for="c-41860442">[5 more]</label></div><br/><div class="children"><div class="content">The title of his column and book &quot;Metamagical Themas&quot; is an anagram of Martin Gardner&#x27;s previous column &quot;Mathematical Games&quot;. It&#x27;s clever wordplay turtles all the way down.</div><br/><div id="41861022" class="c"><input type="checkbox" id="c-41861022" checked=""/><div class="controls bullet"><span class="by">madcaptenor</span><span>|</span><a href="#41860281">root</a><span>|</span><a href="#41860442">parent</a><span>|</span><a href="#41860505">next</a><span>|</span><label class="collapse" for="c-41861022">[-]</label><label class="expand" for="c-41861022">[4 more]</label></div><br/><div class="children"><div class="content">Other Hofstadter book titles with wordplay:<p>- Gödel, Escher, Bach: an Eternal Golden Braid (you have GEB&#x2F;EGB, and I guarantee you he noticed those notes form a musical triad)<p>- Metamagical Themas (anagram of Mathematical Games)<p>- Le Ton beau de Marot (I don&#x27;t have my copy at hand, but &quot;ton beau&quot; is surely a pun on &quot;tombeau&quot; meaning &quot;tomb&quot;)<p>- The Mind&#x27;s I (editor) (I = eye)<p>- That Mad Ache (translation of &quot;La chamade&quot; by Francoise Sagan; &quot;mad ache&quot; is an anagram of &quot;chamade&quot;)</div><br/><div id="41863941" class="c"><input type="checkbox" id="c-41863941" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#41860281">root</a><span>|</span><a href="#41861022">parent</a><span>|</span><a href="#41861528">next</a><span>|</span><label class="collapse" for="c-41863941">[-]</label><label class="expand" for="c-41863941">[1 more]</label></div><br/><div class="children"><div class="content">At least one of the covers of GEB specifically had artwork that shows GEB&#x2F;EGB : <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;G%C3%B6del,_Escher,_Bach" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;G%C3%B6del,_Escher,_Bach</a></div><br/></div></div><div id="41861528" class="c"><input type="checkbox" id="c-41861528" checked=""/><div class="controls bullet"><span class="by">gjm11</span><span>|</span><a href="#41860281">root</a><span>|</span><a href="#41861022">parent</a><span>|</span><a href="#41863941">prev</a><span>|</span><a href="#41860505">next</a><span>|</span><label class="collapse" for="c-41861528">[-]</label><label class="expand" for="c-41861528">[2 more]</label></div><br/><div class="children"><div class="content">&quot;tombeau&quot; <i>literally</i> means &quot;tomb&quot;, but the term also sometimes means &quot;piece written as a memorial&quot;, like Ravel&#x27;s piano suite &quot;Le Tombeau de Couperin&quot;. And yes, Hofstadter explicitly links &quot;ton beau&quot; with &quot;tombeau&quot; (he doesn&#x27;t explicitly mention the &quot;memorial&quot; meaning, though when he mentions the literal &quot;tombeau de Marot&quot; he is talking specifically about the epitaph on it) and also with &quot;tome beau&quot;, the great book of Marot&#x27;s life and work.<p>I&#x27;d find it a cleverer bit of wordplay if &quot;le ton beau de ...&quot; itself didn&#x27;t feel clumsy. Surely it would always be &quot;le beau ton de ...&quot;?</div><br/><div id="41861808" class="c"><input type="checkbox" id="c-41861808" checked=""/><div class="controls bullet"><span class="by">madcaptenor</span><span>|</span><a href="#41860281">root</a><span>|</span><a href="#41861528">parent</a><span>|</span><a href="#41860505">next</a><span>|</span><label class="collapse" for="c-41861808">[-]</label><label class="expand" for="c-41861808">[1 more]</label></div><br/><div class="children"><div class="content">This was all somewhere in the back of my head but my copy of this book is in my parents&#x27; basement somewhere.  I&#x27;ll have to rescue it so I can keep it in my basement.</div><br/></div></div></div></div></div></div></div></div><div id="41860505" class="c"><input type="checkbox" id="c-41860505" checked=""/><div class="controls bullet"><span class="by">goldfeld</span><span>|</span><a href="#41860281">parent</a><span>|</span><a href="#41860442">prev</a><span>|</span><a href="#41860358">next</a><span>|</span><label class="collapse" for="c-41860505">[-]</label><label class="expand" for="c-41860505">[1 more]</label></div><br/><div class="children"><div class="content">The author of GEB is a phenomenal writer, an old-style researcher who knew his greek, and the book for me is more interesting in its commentary on literature, and psychology, approaching themes of say, Foucault.<p>I don&#x27;t know about the work&#x27;s true impact on AI or tech languages, but it&#x27;s a masterpiece of criticism, analysis and penmanship.</div><br/></div></div><div id="41860358" class="c"><input type="checkbox" id="c-41860358" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41860281">parent</a><span>|</span><a href="#41860505">prev</a><span>|</span><a href="#41861805">next</a><span>|</span><label class="collapse" for="c-41860358">[-]</label><label class="expand" for="c-41860358">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.  It saddens me how I feel I completely slept through a golden age of magazines out there.  With no real clue how I could help support that coming back.<p>I was happy with the section in Wireframe magazines that would show how to code some game mechanics every issue.  Would love for more stuff like that.</div><br/></div></div><div id="41861805" class="c"><input type="checkbox" id="c-41861805" checked=""/><div class="controls bullet"><span class="by">jhbadger</span><span>|</span><a href="#41860281">parent</a><span>|</span><a href="#41860358">prev</a><span>|</span><a href="#41862180">next</a><span>|</span><label class="collapse" for="c-41861805">[-]</label><label class="expand" for="c-41861805">[1 more]</label></div><br/><div class="children"><div class="content">Old school SA was written assuming a basic level of scientific and mathematical background. Many people reading it were professional scientists and engineers who read it to learn about developments in other fields than their own. Current SA seems to be written at a level similar to the science coverage in newspapers, written for the hypothetical &quot;layman&quot; who is supposedly frightened of mathematics and anything technical. I couldn&#x27;t imagine someone like Martin Gardner or Hofstadter writing in SA today.</div><br/></div></div><div id="41862180" class="c"><input type="checkbox" id="c-41862180" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#41860281">parent</a><span>|</span><a href="#41861805">prev</a><span>|</span><a href="#41861551">next</a><span>|</span><label class="collapse" for="c-41862180">[-]</label><label class="expand" for="c-41862180">[1 more]</label></div><br/><div class="children"><div class="content">Same with the old National Geographic magazine, before it became slimmer and more ad-heavy, IIRC.</div><br/></div></div></div></div><div id="41862460" class="c"><input type="checkbox" id="c-41862460" checked=""/><div class="controls bullet"><span class="by">activitypea</span><span>|</span><a href="#41860281">prev</a><span>|</span><a href="#41860980">next</a><span>|</span><label class="collapse" for="c-41862460">[-]</label><label class="expand" for="c-41862460">[5 more]</label></div><br/><div class="children"><div class="content">I remember reading GEB and being shocked that he never mentions Lisp. He _does_ wade into CompSci topics, but it&#x27;s something half-hearted about how compilers are programs that read and generate programs. This really should&#x27;ve been integrated into a revised edition of the book.</div><br/><div id="41862849" class="c"><input type="checkbox" id="c-41862849" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41862460">parent</a><span>|</span><a href="#41864173">next</a><span>|</span><label class="collapse" for="c-41862849">[-]</label><label class="expand" for="c-41862849">[1 more]</label></div><br/><div class="children"><div class="content">Huh?  He mentions Lisp all over the place.  Check the index.</div><br/></div></div><div id="41864173" class="c"><input type="checkbox" id="c-41864173" checked=""/><div class="controls bullet"><span class="by">silcoon</span><span>|</span><a href="#41862460">parent</a><span>|</span><a href="#41862849">prev</a><span>|</span><a href="#41866438">next</a><span>|</span><label class="collapse" for="c-41864173">[-]</label><label class="expand" for="c-41864173">[1 more]</label></div><br/><div class="children"><div class="content">Give it another go! _The Anatomy of LISP_ is the first entry in the bibliography.</div><br/></div></div><div id="41866438" class="c"><input type="checkbox" id="c-41866438" checked=""/><div class="controls bullet"><span class="by">baruchthescribe</span><span>|</span><a href="#41862460">parent</a><span>|</span><a href="#41864173">prev</a><span>|</span><a href="#41862938">next</a><span>|</span><label class="collapse" for="c-41866438">[-]</label><label class="expand" for="c-41866438">[1 more]</label></div><br/><div class="children"><div class="content">Nonsense.<p>&quot;One of the most important and fascinating of all computer languages is LISP (standing for &quot;List Processing&quot;), which was invented by John McCarthy around the time Algol was invented. Subsequently, LISP has enjoyed great popularity with workers in Artificial Intelligence.&quot;</div><br/></div></div></div></div><div id="41860980" class="c"><input type="checkbox" id="c-41860980" checked=""/><div class="controls bullet"><span class="by">InDubioProRubio</span><span>|</span><a href="#41862460">prev</a><span>|</span><label class="collapse" for="c-41860980">[-]</label><label class="expand" for="c-41860980">[4 more]</label></div><br/><div class="children"><div class="content">Lisp aNeeds Braces</div><br/><div id="41863741" class="c"><input type="checkbox" id="c-41863741" checked=""/><div class="controls bullet"><span class="by">paddy_m</span><span>|</span><a href="#41860980">parent</a><span>|</span><a href="#41866496">next</a><span>|</span><label class="collapse" for="c-41863741">[-]</label><label class="expand" for="c-41863741">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Lisp needs braces<p>You&#x27;re a troll, but I&#x27;ll feed you.  I adapted Peter Norvig&#x27;s excellent lispy2.py [0] to read json.  I call it JLisp [1].<p>Lispy2 is a scheme implementation, complete with macros that executes on top of python.  I made it read json, really just replacing () with [].  and defining symbols as {&#x27;symbol&#x27;: &#x27;symbol_name&#x27;}.  I built it because it&#x27;s easier to get a webapp to emit JSON then paren lisp.  I also knew that building an interpreter on top of lisp meant that I wouldn&#x27;t back myself into a corner.  There is incredible power in the lisp, especially the ability to transform code.<p>[0] <a href="https:&#x2F;&#x2F;norvig.com&#x2F;lispy2.html" rel="nofollow">https:&#x2F;&#x2F;norvig.com&#x2F;lispy2.html</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;paddymul&#x2F;buckaroo&#x2F;blob&#x2F;main&#x2F;tests&#x2F;unit&#x2F;lispy_test.py#L42-L100">https:&#x2F;&#x2F;github.com&#x2F;paddymul&#x2F;buckaroo&#x2F;blob&#x2F;main&#x2F;tests&#x2F;unit&#x2F;li...</a> #tests for JLisp</div><br/></div></div><div id="41866496" class="c"><input type="checkbox" id="c-41866496" checked=""/><div class="controls bullet"><span class="by">NateEag</span><span>|</span><a href="#41860980">parent</a><span>|</span><a href="#41863741">prev</a><span>|</span><label class="collapse" for="c-41866496">[-]</label><label class="expand" for="c-41866496">[2 more]</label></div><br/><div class="children"><div class="content">Here, have another approach to Lisp formatting:<p><a href="https:&#x2F;&#x2F;readable.sourceforge.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;readable.sourceforge.io&#x2F;</a><p>I looked into porting it to elisp a while back, but the elisp reader was missing a feature or two sweet-expressions require. I should see if that&#x27;s still true...</div><br/><div id="41867386" class="c"><input type="checkbox" id="c-41867386" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41860980">root</a><span>|</span><a href="#41866496">parent</a><span>|</span><label class="collapse" for="c-41867386">[-]</label><label class="expand" for="c-41867386">[1 more]</label></div><br/><div class="children"><div class="content">Would be nice. But I think after hours&#x2F;days of working with lisp, the brain starts to see it at sweet expressions. That is why all tries to go away from s-exp don&#x27;t get traction: anytime anybody starts doing it, pretty fast discovers it is really not needed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>