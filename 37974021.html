<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698051664920" as="style"/><link rel="stylesheet" href="styles.css?v=1698051664920"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://c4model.com/">The C4 model for visualising software architecture (2017)</a> <span class="domain">(<a href="https://c4model.com">c4model.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>98 comments</span></div><br/><div><div id="37974499" class="c"><input type="checkbox" id="c-37974499" checked=""/><div class="controls bullet"><span class="by">ryan-duve</span><span>|</span><a href="#37975242">next</a><span>|</span><label class="collapse" for="c-37974499">[-]</label><label class="expand" for="c-37974499">[39 more]</label></div><br/><div class="children"><div class="content">&gt;  Ideally this diagram would be automatically generated using tooling...<p>The biggest problem I&#x27;ve seen with architecture diagrams is they fall out of sync with the code base.  In my opinion, automatic generation of these diagrams is necessary.  Otherwise, teams have no way to know whether the picture in front of them accurately represents the latest state of the system.</div><br/><div id="37974658" class="c"><input type="checkbox" id="c-37974658" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37982712">next</a><span>|</span><label class="collapse" for="c-37974658">[-]</label><label class="expand" for="c-37974658">[17 more]</label></div><br/><div class="children"><div class="content">Diagrams are similar to textual documentation: You generally can’t auto-generate useful ones from code, unless the code has extra markup that specifies what to generate. Diagrams often present a specific perspective that emphasizes certain features while omitting others. You might have several diagrams for the same entity, each illustrating a different aspect or scenario.<p>The upshot is that diagrams have to be maintained in conjunction with the code and application architecture, just like textual documentation. There’s just no alternative to simply putting the work in, and making it a regular part of change management.</div><br/><div id="37974886" class="c"><input type="checkbox" id="c-37974886" checked=""/><div class="controls bullet"><span class="by">simpaticoder</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974658">parent</a><span>|</span><a href="#37975769">next</a><span>|</span><label class="collapse" for="c-37974886">[-]</label><label class="expand" for="c-37974886">[7 more]</label></div><br/><div class="children"><div class="content">The correct solution is a synthesis: generate the boxes and arrows from code. Then let a human hide, move, and style those objects. When the code changes, the boxes and arrows will change, and perhaps the style will want to change, but at least the diagram will remain correct. This is precisely the distinction between semantic markup and css, btw. Implying that the html would be auto generated, the css would be hand crafted.</div><br/><div id="37975041" class="c"><input type="checkbox" id="c-37975041" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974886">parent</a><span>|</span><a href="#37976206">next</a><span>|</span><label class="collapse" for="c-37975041">[-]</label><label class="expand" for="c-37975041">[3 more]</label></div><br/><div class="children"><div class="content">I would actually be really interested in a bi-directional workflow, such that I would also be able to perform system redesign by changing the diagram&#x27;s connections - the tooling will then automatically update the interface and the tests such that I wouldn&#x27;t be able to commit my changes until the implementation matches the diagram.</div><br/><div id="37982290" class="c"><input type="checkbox" id="c-37982290" checked=""/><div class="controls bullet"><span class="by">jakewins</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37975041">parent</a><span>|</span><a href="#37981935">next</a><span>|</span><label class="collapse" for="c-37982290">[-]</label><label class="expand" for="c-37982290">[1 more]</label></div><br/><div class="children"><div class="content">I realize this isn’t what you’re arguing for, but as a cautionary anecdote on this topic:<p>Paul alludes to it in his post about Healthcare.gov from the other day, but this was apparently one of the major parts of the failure there - endless lines of code generated from UML diagrams, making reading the code hard and things like “can we add a trace statement here” difficult.<p>Optimising for diagrams-as-source-of-truth has drawbacks for debugging and maintainability of the running code<p><a href="https:&#x2F;&#x2F;www.pauladamsmith.com&#x2F;blog&#x2F;2023&#x2F;10&#x2F;the-10-year-anniversary-of-the-healthcare.gov-rescue.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pauladamsmith.com&#x2F;blog&#x2F;2023&#x2F;10&#x2F;the-10-year-anniv...</a></div><br/></div></div><div id="37981935" class="c"><input type="checkbox" id="c-37981935" checked=""/><div class="controls bullet"><span class="by">Sophistifunk</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37975041">parent</a><span>|</span><a href="#37982290">prev</a><span>|</span><a href="#37976206">next</a><span>|</span><label class="collapse" for="c-37981935">[-]</label><label class="expand" for="c-37981935">[1 more]</label></div><br/><div class="children"><div class="content">IMO the source code to aspects of the system that are best shown as graphs should <i>be</i> the graphs.</div><br/></div></div></div></div><div id="37976206" class="c"><input type="checkbox" id="c-37976206" checked=""/><div class="controls bullet"><span class="by">bdg</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974886">parent</a><span>|</span><a href="#37975041">prev</a><span>|</span><a href="#37980036">next</a><span>|</span><label class="collapse" for="c-37976206">[-]</label><label class="expand" for="c-37976206">[1 more]</label></div><br/><div class="children"><div class="content">This requires a preset architecture standard that explains specifically what boxes and arrows are, and how boxes&#x2F;arrows interact. Lots of software smears a logical box out over several folders in the code, sometimes even with entirely different names. I don&#x27;t just mean people write non-cohesive code, I mean frameworks tend to prefer organisation by layer (&quot;the views go in the view folder!&quot;) instead of organisation by module (&quot;These things work and change together with a defined boundary&quot;).<p>You can have what you&#x27;re asking for if you agree to a predefined architecture and everyone agrees to write code that way.</div><br/></div></div><div id="37980036" class="c"><input type="checkbox" id="c-37980036" checked=""/><div class="controls bullet"><span class="by">learn_more</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974886">parent</a><span>|</span><a href="#37976206">prev</a><span>|</span><a href="#37976364">next</a><span>|</span><label class="collapse" for="c-37980036">[-]</label><label class="expand" for="c-37980036">[1 more]</label></div><br/><div class="children"><div class="content">Check out <a href="https:&#x2F;&#x2F;schematix.com&#x2F;video&#x2F;?play=schematix-editing" rel="nofollow noreferrer">https:&#x2F;&#x2F;schematix.com&#x2F;video&#x2F;?play=schematix-editing</a><p>Schematix generates diagrams (models) from code which can be entered via the web interface, or from a remote command line or scripts.<p>Diagrams are rendered on-the-fly from queries called &quot;topological expressions&quot; run against the model.  The model must be updated as IT workers change the environment, but since diagrams are generated from code, they always reflect the most up to date information from the model.</div><br/></div></div><div id="37976364" class="c"><input type="checkbox" id="c-37976364" checked=""/><div class="controls bullet"><span class="by">windlep</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974886">parent</a><span>|</span><a href="#37980036">prev</a><span>|</span><a href="#37975769">next</a><span>|</span><label class="collapse" for="c-37976364">[-]</label><label class="expand" for="c-37976364">[1 more]</label></div><br/><div class="children"><div class="content">This is how I use the tool the author created, Structurizr. I auto-generate the initial diagrams, then manually fix it to make it more readable. We then check-in the JSON workspace export into our git repo. The first two levels of the C4 model don&#x27;t change regularly, so this isn&#x27;t a frequent process to repeat.</div><br/></div></div></div></div><div id="37975769" class="c"><input type="checkbox" id="c-37975769" checked=""/><div class="controls bullet"><span class="by">mumblemumble</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974658">parent</a><span>|</span><a href="#37974886">prev</a><span>|</span><a href="#37978446">next</a><span>|</span><label class="collapse" for="c-37975769">[-]</label><label class="expand" for="c-37975769">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. I experimented with autogenerating C4 diagrams from source a while back, but quickly abandoned the project when I realized that the output was inevitably the flowchart equivalent of<p><pre><code>  bool mystery_func(int i) { &#x2F;&#x2F; define a new function
    int x = (int)(i &#x2F; 2);    &#x2F;&#x2F; x is i divided by 2 and truncated
    int y = x * 2;           &#x2F;&#x2F; y is twice x
    return y == i;           &#x2F;&#x2F; return true if y == i
  }                          &#x2F;&#x2F; end of function</code></pre></div><br/><div id="37977788" class="c"><input type="checkbox" id="c-37977788" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37975769">parent</a><span>|</span><a href="#37978446">next</a><span>|</span><label class="collapse" for="c-37977788">[-]</label><label class="expand" for="c-37977788">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, the documentation (diagrams&#x2F;text with particular layout and formatting) should abstract a lot of what the code does. Otherwise, what&#x27;s the point since the code is there for you to read.<p>In my experience, auto-generated documentation in general does a poor job.<p>That said, such automation is improving by virtue of better AI, that understands and cross translates people&#x27;s languages and computer languages.</div><br/></div></div></div></div><div id="37978446" class="c"><input type="checkbox" id="c-37978446" checked=""/><div class="controls bullet"><span class="by">rafaelmn</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974658">parent</a><span>|</span><a href="#37975769">prev</a><span>|</span><a href="#37977812">next</a><span>|</span><label class="collapse" for="c-37978446">[-]</label><label class="expand" for="c-37978446">[1 more]</label></div><br/><div class="children"><div class="content">I use diagrams for two distinct use cases :<p>- planning&#x2F;outlining a solution<p>- documenting&#x2F;insight into the system<p>I disagree that second can&#x27;t be autogenerated - I&#x27;ve used class diagrams, database schema diagrams etc. to visualize projects, a lot of the time over the documentation - precisely because I can trust the generated diagrams to reflect current state.<p>Documentation is nice for context but I&#x27;d take good visualisation tools over most documentation I&#x27;ve seen on projects I&#x27;ve worked on.<p>Tooling to connect&#x2F;validate documentation against code is non-existent, in my world at least. Maybe LLMs can change that down the line - have PR review against docs run as a part of CI&#x2F;CD pipeline.</div><br/></div></div><div id="37977812" class="c"><input type="checkbox" id="c-37977812" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974658">parent</a><span>|</span><a href="#37978446">prev</a><span>|</span><a href="#37981927">next</a><span>|</span><label class="collapse" for="c-37977812">[-]</label><label class="expand" for="c-37977812">[5 more]</label></div><br/><div class="children"><div class="content">&gt; You generally can’t auto-generate useful [architecture diagrams] from code,<p>The question is:  why is this the case?<p>IMNSHO, the reason is that we don&#x27;t have a way to express architecture in or as code.  Instead, we have to compile the actual architecture of the system into one that is expressible using the call&#x2F;return architectural style that our programming languages support.<p>That&#x27;s a lossy process.<p>When we can program with actual architectural connectors, auto-generating useful architectural diagrams becomes trivial.<p><a href="https:&#x2F;&#x2F;objective.st" rel="nofollow noreferrer">https:&#x2F;&#x2F;objective.st</a></div><br/><div id="37978214" class="c"><input type="checkbox" id="c-37978214" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37977812">parent</a><span>|</span><a href="#37978812">next</a><span>|</span><label class="collapse" for="c-37978214">[-]</label><label class="expand" for="c-37978214">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think that’s the problem. There are so many different ways to look at a system. An architectural diagram shows you how components connect. A procedural diagram shows you what steps a program takes. An entity diagram shows you the major high level entities you’ve selected into your system. I just don’t see how a single language can express all the detail. Maybe a new one can be invented but I don’t see how S expressions solve this (the link you posted don’t have any indication that any diagram generation is part of the language). Also, diagrams can be useful even if they have birotted because discrepancies are a good teaching tool - “why does this diagram say x but the code seems to do y” is a tracing opportunity, an opportunity to update the diagram, and highlights which engineers are paying attention.<p>Maybe if LLMs get sufficiently advanced they can generate this stuff more automatically with some minor prompting with the code as context, but I doubt it. Not until AI can actually start understanding sentiment from code.</div><br/><div id="37978461" class="c"><input type="checkbox" id="c-37978461" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37978214">parent</a><span>|</span><a href="#37978812">next</a><span>|</span><label class="collapse" for="c-37978461">[-]</label><label class="expand" for="c-37978461">[1 more]</label></div><br/><div class="children"><div class="content">&gt; An architectural diagram shows you how components connect.<p>That&#x27;s the one we&#x27;re talking about here.<p>&gt; A procedural diagram shows you what steps a program takes<p>Which is useful if the program is procedural.<p>&gt; An entity diagram shows you the major high level entities you’ve selected into your system.<p>That&#x27;s the top-level of your architectural diagram.<p>&gt; I just don’t see how a single language can express all the detail.<p>When the program&#x27;s architectural style is call&#x2F;return, we can do this just fine.  Using stepwise refinement we move up and down the abstraction ladder of our system and thus add&#x2F;remove detail.  No problem.<p>The problem is that most systems these days are not primarily call&#x2F;return, but have to be programmed in call&#x2F;return languages.<p>&gt; I don’t see how S expressions solve this<p>I don&#x27;t either, and have no idea what S expressions have to do with this.<p>&gt; .... diagram generation is part of the language<p>It&#x27;s not part of the language.  But it&#x27;s part of the frameworks, and when the abstractions of your language are architectural in nature, there is a very close correspondence between the code and the diagrams.<p>&gt; ... discrepancies are a good teaching tool...<p>Yes, since the diagrams are generated, it&#x27;s easy to keep older version around and generate new ones on-demand.  Then you can check the differences visually, in code, or as the difference between code and diagram.  Take your pick.<p>&gt; Not until AI can actually start understanding sentiment from code.<p>Again, the point is that architecture is not actually &quot;sentiment&quot;.  It is structural.  The fact that it looks like sentiment in practice is purely a side effect of our programming languages being incapable of encoding architecture in the general case.</div><br/></div></div></div></div><div id="37978812" class="c"><input type="checkbox" id="c-37978812" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37977812">parent</a><span>|</span><a href="#37978214">prev</a><span>|</span><a href="#37981927">next</a><span>|</span><label class="collapse" for="c-37978812">[-]</label><label class="expand" for="c-37978812">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The question is: why is this the case?<p>Diagrams capture and represent abstract and&#x2F;or high level concepts. Their goal is to provide a kind of mental map of how specific aspects of a project are organized in order to help developers form their mental models. This means placing the focus on key constructs and downplaying the importance or relevance of other components. There isn&#x27;t an objective way to provide a one-to-one mapping between what bits of a software project are of critical importance to form mental models, and what bits are irrelevant.<p>&gt; IMNSHO, the reason is that we don&#x27;t have a way to express architecture in or as code.<p>Not true. We have more than plenty of ways to represent software architectures. That is trivial and a solved problem. So is mapping representations of software architectures to (some) source code, at least in the form of skeleton code. The problem lies in mapping software projects to a software architecture, even when the software project is clean and a textbook example of a very specific software architecture.</div><br/><div id="37982118" class="c"><input type="checkbox" id="c-37982118" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37978812">parent</a><span>|</span><a href="#37981927">next</a><span>|</span><label class="collapse" for="c-37982118">[-]</label><label class="expand" for="c-37982118">[1 more]</label></div><br/><div class="children"><div class="content">You are confusing “implement” and “express”<p>If the architecture were directly expressed in the code, mapping back would be trivial.  It is not because we effectively compile the actual architecture in order to express it in code.  Mapping back then becomes decompiling, with the added complications of architectural mismatch and manual compilation.</div><br/></div></div></div></div></div></div><div id="37981927" class="c"><input type="checkbox" id="c-37981927" checked=""/><div class="controls bullet"><span class="by">barrysteve</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974658">parent</a><span>|</span><a href="#37977812">prev</a><span>|</span><a href="#37982712">next</a><span>|</span><label class="collapse" for="c-37981927">[-]</label><label class="expand" for="c-37981927">[1 more]</label></div><br/><div class="children"><div class="content">You can generate it from code.<p>Diagrams are a flat map of someone&#x27;s subjective and structured, interpretation of the code architecture.<p>Words displayed on a computer screen must be developed into supporting subjective knowledge structures.. free from the usual objective mindset of engineering.<p>You have to go up to first order concepts to get it. The vast majority of (popular) programming culture generates more of the same. Everybody tries to paper over this truth with metadata and it metaphysically does not work.<p>Computers are capable of much more, they are politically limited down to a small subset of what&#x27;s possible.</div><br/></div></div></div></div><div id="37982712" class="c"><input type="checkbox" id="c-37982712" checked=""/><div class="controls bullet"><span class="by">BerislavLopac</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37974658">prev</a><span>|</span><a href="#37974571">next</a><span>|</span><label class="collapse" for="c-37982712">[-]</label><label class="expand" for="c-37982712">[1 more]</label></div><br/><div class="children"><div class="content">The idea of C4 is to document the higher-level elements of the system - applications, components and the like. The first three Cs stand for &quot;context&quot;, &quot;container&quot; and &quot;component&quot;, while the fourth level, &quot;code&quot; is deemed optional.<p>IcePanel [0], a great tool for building C4 documentation, renames &quot;containers&quot; to &quot;applications&quot; for clarity, and instead of code diagrams simply links to the corresponding repos.<p>[0] <a href="https:&#x2F;&#x2F;icepanel.io&#x2F;">https:&#x2F;&#x2F;icepanel.io&#x2F;</a></div><br/></div></div><div id="37974571" class="c"><input type="checkbox" id="c-37974571" checked=""/><div class="controls bullet"><span class="by">hcks</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37982712">prev</a><span>|</span><a href="#37974863">next</a><span>|</span><label class="collapse" for="c-37974571">[-]</label><label class="expand" for="c-37974571">[2 more]</label></div><br/><div class="children"><div class="content">In my experience diagrams that are pedestrian enough to be automatically generated from the codebase don’t add much value</div><br/></div></div><div id="37974863" class="c"><input type="checkbox" id="c-37974863" checked=""/><div class="controls bullet"><span class="by">bdg</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37974571">prev</a><span>|</span><a href="#37976586">next</a><span>|</span><label class="collapse" for="c-37974863">[-]</label><label class="expand" for="c-37974863">[2 more]</label></div><br/><div class="children"><div class="content">The code-model gap is why we don&#x27;t have this.<p>You don&#x27;t organize code the way you mentally model it in many projects, and nearly all languages lack a way to solve this. Annotating code is prone to the same issue as keeping a diagram up to date, and the same issue as keeping comments or documentation up to date.</div><br/><div id="37975030" class="c"><input type="checkbox" id="c-37975030" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974863">parent</a><span>|</span><a href="#37976586">next</a><span>|</span><label class="collapse" for="c-37975030">[-]</label><label class="expand" for="c-37975030">[1 more]</label></div><br/><div class="children"><div class="content">&gt; nearly all languages lack a way to solve this<p>The only thing I’ve seen that goes in this direction is Knuth’s literate programming. I’ve tried it. In its current form it’s still clumsy, lacks tool support and IMO doesn’t fully solve the problem of how to deal with documenting a <i>changing</i> piece of software yet. Knuth got his requirements correct on the first try; the rest of us aren’t so lucky.</div><br/></div></div></div></div><div id="37976586" class="c"><input type="checkbox" id="c-37976586" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37974863">prev</a><span>|</span><a href="#37977137">next</a><span>|</span><label class="collapse" for="c-37976586">[-]</label><label class="expand" for="c-37976586">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, I think auto docs are robbing the team of the ability to think in terms of the higher level of abstraction.<p>High level diagrams should be disposable and rapid to generate.  They are as important for what they omit as for what they show.</div><br/></div></div><div id="37977137" class="c"><input type="checkbox" id="c-37977137" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37976586">prev</a><span>|</span><a href="#37976861">next</a><span>|</span><label class="collapse" for="c-37977137">[-]</label><label class="expand" for="c-37977137">[3 more]</label></div><br/><div class="children"><div class="content">Some problems are people or process problems and can’t always be waved away with tools. Sometimes the answer is to enforce growth of the professional discipline to update documentation alongside code changes.<p>A way I addressed this was to add a checklist item automatically to PRs, “did you review and update the docs?” And put the docs in the same repo so that a code change will have documentation updates in the same PR. It’s mostly worked but still relies on discipline.<p>It’s kind of interesting how hard this is for some. The code change is 5 mins. Testing is 20. Documentation is another 10. I’ve seen lots of people not want to do the testing and <i>really</i> not want to do the documentation.</div><br/><div id="37977167" class="c"><input type="checkbox" id="c-37977167" checked=""/><div class="controls bullet"><span class="by">photonbeam</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37977137">parent</a><span>|</span><a href="#37976861">next</a><span>|</span><label class="collapse" for="c-37977167">[-]</label><label class="expand" for="c-37977167">[2 more]</label></div><br/><div class="children"><div class="content">Ive seen testing reluctantly tied to “they’ll make me change everything in code review, so why waste the effort yet”</div><br/><div id="37977222" class="c"><input type="checkbox" id="c-37977222" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37977167">parent</a><span>|</span><a href="#37976861">next</a><span>|</span><label class="collapse" for="c-37977222">[-]</label><label class="expand" for="c-37977222">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. And it’s possible the process is defective if code review can result in that much change. Oftentimes people skip most of the design process. I’ve been guilty of this.<p>Reminds me of the army mantra, “slow is smooth. Smooth is fast.” Skipping or rushing design has never actually saved time in my experience. And I see veterans repeating this mistake over and over.</div><br/></div></div></div></div></div></div><div id="37976861" class="c"><input type="checkbox" id="c-37976861" checked=""/><div class="controls bullet"><span class="by">abhishekjha</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37977137">prev</a><span>|</span><a href="#37980164">next</a><span>|</span><label class="collapse" for="c-37976861">[-]</label><label class="expand" for="c-37976861">[1 more]</label></div><br/><div class="children"><div class="content">Why is it that compilers don&#x27;t do this? They have a parse tree for how the sysmbols connect.<p>Would it not be appropriate to extend the compiler for visualising relationships between software components with zoom-in and zoom-out facilities. Zoom-in takes you to Assembly and zoom-out to the CTO.</div><br/></div></div><div id="37980164" class="c"><input type="checkbox" id="c-37980164" checked=""/><div class="controls bullet"><span class="by">donutshop</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37976861">prev</a><span>|</span><a href="#37974969">next</a><span>|</span><label class="collapse" for="c-37980164">[-]</label><label class="expand" for="c-37980164">[1 more]</label></div><br/><div class="children"><div class="content">I think what Adam Jacob is doing with system initiative addresses this, right off the get go.</div><br/></div></div><div id="37974969" class="c"><input type="checkbox" id="c-37974969" checked=""/><div class="controls bullet"><span class="by">nonameiguess</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37980164">prev</a><span>|</span><a href="#37974710">next</a><span>|</span><label class="collapse" for="c-37974969">[-]</label><label class="expand" for="c-37974969">[1 more]</label></div><br/><div class="children"><div class="content">I think comments like these are too parochial in scope. Note the first actual example here, which is the system context. In this example, it describes the relationships between a banking customer, an Internet banking system, a backend backend banking mainframe, and an e-mail server.<p>Yes, your software may explicitly model all of these system components and potentially you can generate a system model from the code, but that would an entirely wrong approach. As a sibling comment says, this system context view describes the real world, not your software. The code is supposed to conform to the model, not the other way around. If the implementation has drifted to not be in-sync with the model, there are a few reasons this may happen:<p>- The legal or regulatory landscape actually changed. <i>In this case</i>, yes, the code may be more up-to-date and you need to change the model.<p>- External components your organization doesn&#x27;t directly control changed. In this case, also, it may be the model that is wrong.<p>- The model is right and your code needs to change. Maybe you are not correctly handling an external third-party API. Maybe you&#x27;re not correctly meeting your customer&#x27;s needs. In the worst case, maybe you&#x27;re breaking a law.<p>I would also think the reality at something as expansive as a bank, there is no such thing as <i>the</i> codebase. You don&#x27;t have a single product. You have the backend data store and transaction processing system. You have kiosk software for your ATMs. You have workstation software for your tellers. You have a public-facing website for your customers. You have a mobile app. You may have an entirely separate set of insurance products, investment products, and so on. You have internal management and accounting system for generating reports. Most likely all of these need to be separate system, at least because one temporally predates others. In part because a bank is formed by mergers, acquisitions, and divestments, so some products may have originally been part of a totally separate organization and some may be destined to be their own totally separate organizations. Strategically as a company, you can&#x27;t afford to give up that level of financial agility by creating hard software-level couplings between your entire product suite.<p>So sure, at the level of any single component, you may be able to autogenerate a high-level architecture diagram. But at the level of the entire system, you can&#x27;t. This is probably most clear and obvious with something like the DODAF: <a href="https:&#x2F;&#x2F;dodcio.defense.gov&#x2F;Library&#x2F;DoD-Architecture-Framework&#x2F;dodaf20_viewpoints&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;dodcio.defense.gov&#x2F;Library&#x2F;DoD-Architecture-Framewor...</a><p>These are much-maligned and for good reason. They&#x27;re often incomprehensible. But to the extent you&#x27;re trying to model something like the operation of a war campaign, you&#x27;re now involving:<p>- C2 systems for multiple branches of the military<p>- ISR systems for those same branches<p>- Communications systems<p>- Operational capabilities of all of the various intelligence agencies and foreign allies you interoperate with<p>- Weapons systems<p>- Tablet terminal, man-pack, and in-vehicle devices for your forward tactical elements<p>All of these are software systems, but they&#x27;re developed on different cadences, by separate contractors on separate contracts, with separate fiscal appropriations bills and lines of accounting. Nonetheless, there is still a need at the strategic level to model the entire system. In order for this system to have any hope of working, it needs to be based on specifications with the expectation being that implementations will conform to the spec, not the other way around. It&#x27;s more like developing the Internet than developing a web app. You can&#x27;t autogenerate a diagram of the Internet, at least not one with any authority, by pointing it at the code for a server, a browser, an endpoint networking stack, and the networking stacks for various appliances like core routers, and figuring out some way to link those together, especially given you&#x27;d have to cut across arbitrarily many programming languages and code styles.</div><br/></div></div><div id="37974710" class="c"><input type="checkbox" id="c-37974710" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37974969">prev</a><span>|</span><a href="#37975961">next</a><span>|</span><label class="collapse" for="c-37974710">[-]</label><label class="expand" for="c-37974710">[8 more]</label></div><br/><div class="children"><div class="content">&gt; The biggest problem I&#x27;ve seen with architecture diagrams is they fall out of sync with the code base. In my opinion, automatic generation of these diagrams is necessary.<p>Architecture diagrams document how the software is expected to be organized. They represent the goal, not the current state. The code needs to comply with the diagram, and not the other way around.<p>The only scenario where it makes sense to generate diagrams from code is when we have people trying to onboard to a project that&#x27;s not documented, and even then these diagrams are only generated once, polished to remove noise, and from that point onward serve as the reference.</div><br/><div id="37974769" class="c"><input type="checkbox" id="c-37974769" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974710">parent</a><span>|</span><a href="#37975961">next</a><span>|</span><label class="collapse" for="c-37974769">[-]</label><label class="expand" for="c-37974769">[7 more]</label></div><br/><div class="children"><div class="content">So how would you expect to insight on whether the current code differs from the planned design documents? By always applying a lot of manual human labor?</div><br/><div id="37975106" class="c"><input type="checkbox" id="c-37975106" checked=""/><div class="controls bullet"><span class="by">growse</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974769">parent</a><span>|</span><a href="#37975201">next</a><span>|</span><label class="collapse" for="c-37975106">[-]</label><label class="expand" for="c-37975106">[3 more]</label></div><br/><div class="children"><div class="content">This is not a trivial problem to solve. Some would say that one of the entire points of software engineering is to assure that the code meets the design spec. A more rigorous approach would be to encode your design as a bunch of linting rules that you could run against your codebase (IaC and all).<p>I&#x27;m pretty sure that auto generating a diagram from some code and then trying to work out if it&#x27;s semantically equivalent to something that was hand drawn is not the answer though. For one thing, the code doesn&#x27;t contain or implement every single important aspect of the design.</div><br/><div id="37977152" class="c"><input type="checkbox" id="c-37977152" checked=""/><div class="controls bullet"><span class="by">mnahkies</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37975106">parent</a><span>|</span><a href="#37975201">next</a><span>|</span><label class="collapse" for="c-37977152">[-]</label><label class="expand" for="c-37977152">[2 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s hard.<p>For http API design I like to start with an openapi spec then generate as much of the server and client library implementation from this as possible.<p>The spec gives a language&#x2F;implementation agnostic way to describe what you&#x27;re intending to build that&#x27;s nicely diff-able over time, and you can generate a lot of the boilerplate that&#x27;s easy to screw up in a way that&#x27;s both compile time (static types) and runtime (parsing&#x2F;validation of inputs &amp; outputs) safe.<p>I can imagine a world where a similar approach could work for higher level architecture. It&#x27;s pretty common to have a shared helm chart that (largely) defines each individual logical service in k8s environments.<p>Taken to the extreme you could provision your data stores, and network policies etc using this approach such that an individual services chart defines exactly what it depends on. Throw in some metadata fields for descriptions and you&#x27;re well on the way to having something that could generate some useful diagrams &#x2F; documentation.<p>Of course the issue with such helm charts is that if you make them flexible enough to suit everybody eventually you&#x27;ll just reimplement the underlying APIs they are calling - perhaps some approach using direct introspection of k8s resources and cloud resources with a standardized set of metadata to group and describe relationships might be more feasible.<p>For the moment I&#x27;ll probably stick to excalidraw</div><br/><div id="37978039" class="c"><input type="checkbox" id="c-37978039" checked=""/><div class="controls bullet"><span class="by">growse</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37977152">parent</a><span>|</span><a href="#37975201">next</a><span>|</span><label class="collapse" for="c-37978039">[-]</label><label class="expand" for="c-37978039">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but there’s a whole dimension missing here.<p>Architecture is more than simply “what&quot;, it’s also &quot;why&quot;. It binds the context to the requirements and the desired components&lt; their relationships and interactions. Some other comment described architecture to code as a lossy process, and that’s exactly right.<p>A diagram is not &quot;the architecture&quot;, it’s simply a view on it, or a &quot;projection of the model&quot; as the c4 folk like to express it as.<p>I just find the idea that we should automate diagram production because diagrams are hard to keep up to date a little quaint, because you hardly ever need to update <i>just</i> a diagram when changing the architecture. So your actual problem is that your design documentation is hard to keep up to date, and that’s a process problem. Generating diagrams from code won’t save you there.</div><br/></div></div></div></div></div></div><div id="37975201" class="c"><input type="checkbox" id="c-37975201" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37974769">parent</a><span>|</span><a href="#37975106">prev</a><span>|</span><a href="#37975961">next</a><span>|</span><label class="collapse" for="c-37975201">[-]</label><label class="expand" for="c-37975201">[3 more]</label></div><br/><div class="children"><div class="content">&gt; So how would you expect to insight on whether the current code differs from the planned design documents?<p>Developers are expected to know what they are doing and how their software project is organized.<p>&gt; By always applying a lot of manual human labor?<p>That &quot;manual labor&quot; has a name: software development.<p>Software only changes if developers submit changes. Changes are reviewed as part of code reviews.</div><br/><div id="37976559" class="c"><input type="checkbox" id="c-37976559" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37975201">parent</a><span>|</span><a href="#37975961">next</a><span>|</span><label class="collapse" for="c-37976559">[-]</label><label class="expand" for="c-37976559">[2 more]</label></div><br/><div class="children"><div class="content">In all projects that I’ve worked on the code was much too complex for a single developer to have even a surface level understanding of all of it, yet one is regularly required to change unfamiliar pieces.</div><br/><div id="37979358" class="c"><input type="checkbox" id="c-37979358" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37974499">root</a><span>|</span><a href="#37976559">parent</a><span>|</span><a href="#37975961">next</a><span>|</span><label class="collapse" for="c-37979358">[-]</label><label class="expand" for="c-37979358">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In all projects that I’ve worked on the code was much too complex for a single developer to have even a surface level understanding of all of it, yet one is regularly required to change unfamiliar pieces.<p>That sounds like a self-inflicted problem, caused by a team failing to develop and maintain their system following basic software engineering principles. I&#x27;m not sure how diagrams are relevant.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37975961" class="c"><input type="checkbox" id="c-37975961" checked=""/><div class="controls bullet"><span class="by">gonzo41</span><span>|</span><a href="#37974499">parent</a><span>|</span><a href="#37974710">prev</a><span>|</span><a href="#37975242">next</a><span>|</span><label class="collapse" for="c-37975961">[-]</label><label class="expand" for="c-37975961">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t really make complexity go away. It just get&#x27;s moved about. Auto creating diagrams will either mean specifying a new code artifact that will need to be kept up to date, and or create dependencies that will themselves fall out of sink with the code base. Or they&#x27;ll be really simplistic and useless.<p>I think the best way to document a system is to write doco and just specifyc the intent of the system. What was this thing meant to do. That context is really useful for contrasting with the use of the system in a prod environment.</div><br/></div></div></div></div><div id="37975242" class="c"><input type="checkbox" id="c-37975242" checked=""/><div class="controls bullet"><span class="by">mikehollinger</span><span>|</span><a href="#37974499">prev</a><span>|</span><a href="#37974677">next</a><span>|</span><label class="collapse" for="c-37975242">[-]</label><label class="expand" for="c-37975242">[1 more]</label></div><br/><div class="children"><div class="content">I like C4. I&#x27;d previously discounted the &quot;context&quot; diagrams that inevitably show &quot;User -{do their job}-&gt; System-of-Record&quot; as useless. Now I see the point.<p>I&#x27;m working through a new piece of system design for a complex system using C4 with our extended teams.<p>In drawing the top level this time around though I realized that b&#x2F;c we have a semi-disconnected mobile app (aside from a web UI) we need to degrade certain behaviors gracefully if we don&#x27;t have certain results yet, either b&#x2F;c we&#x27;re offline, or the backend is just slow for some reason.<p>That rippled down into the next layer of the system as a job queue, which then rippled into the UX, because we can now say definitively which parts of the system may take an unbounded amount of time to complete a request.<p>I&#x27;m sure we&#x27;d have gotten to this conclusion eventually but the analysis put the issue front and center.<p>All because I had to draw a picture with &quot;Remote-User --{Mobile Stuff}--&gt; Backend.&quot;<p>Also whichever tool you use is up to you. I just use draw.io for example with different tabs for each layer. As we elaborate on this at some point we&#x27;ll break the lower layers out to their own files.</div><br/></div></div><div id="37974677" class="c"><input type="checkbox" id="c-37974677" checked=""/><div class="controls bullet"><span class="by">discodachshund</span><span>|</span><a href="#37975242">prev</a><span>|</span><a href="#37975813">next</a><span>|</span><label class="collapse" for="c-37974677">[-]</label><label class="expand" for="c-37974677">[6 more]</label></div><br/><div class="children"><div class="content">I get the points about not needing a formalised system for diagrams, even if C4 is quite light touch in my opinion (I never go down to the code level).<p>However, I do have to credit structurizr, which outputs C4 diagrams, as a great productivity boost. One model producing multiple views at all specificities is fantastic compared to mermaid, plantuml, etc, where every diagram needs to be self contained and define and redefine the same components over and over. Branching off, editing the model, presenting ideas, has been a very successful workflow for me.</div><br/><div id="37977147" class="c"><input type="checkbox" id="c-37977147" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#37974677">parent</a><span>|</span><a href="#37976497">next</a><span>|</span><label class="collapse" for="c-37977147">[-]</label><label class="expand" for="c-37977147">[2 more]</label></div><br/><div class="children"><div class="content">I’ve only tried structirizr briefly, but I found it too inflexible. No way to draw concepts that aren’t strictly part of C4. For example I wanted to encapsulate 2 components in a box to represent that they’re currently deployed as one service (not necessarily a good thing to do in absolute but would have helped my team to grok it better): impossible.<p>I do like the idea of describing architecture formally, but the lack of customizability of diagram output was too painful</div><br/><div id="37982821" class="c"><input type="checkbox" id="c-37982821" checked=""/><div class="controls bullet"><span class="by">simon_brown</span><span>|</span><a href="#37974677">root</a><span>|</span><a href="#37977147">parent</a><span>|</span><a href="#37976497">next</a><span>|</span><label class="collapse" for="c-37982821">[-]</label><label class="expand" for="c-37982821">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have the full context of what you&#x27;re trying to model, but &quot;two components deployed as one service&quot; might be better represented as a container. If that&#x27;s not the case, you can use the &quot;group&quot; concept to group components together -&gt; <a href="https:&#x2F;&#x2F;docs.structurizr.com&#x2F;dsl&#x2F;cookbook&#x2F;groups&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.structurizr.com&#x2F;dsl&#x2F;cookbook&#x2F;groups&#x2F;</a><p>Alternatively, <a href="https:&#x2F;&#x2F;likec4.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;likec4.dev</a> provides a way to create an arbitrary number of abstraction levels (although I wouldn&#x27;t recommend such an approach).</div><br/></div></div></div></div><div id="37976497" class="c"><input type="checkbox" id="c-37976497" checked=""/><div class="controls bullet"><span class="by">phlakaton</span><span>|</span><a href="#37974677">parent</a><span>|</span><a href="#37977147">prev</a><span>|</span><a href="#37975475">next</a><span>|</span><label class="collapse" for="c-37976497">[-]</label><label class="expand" for="c-37976497">[2 more]</label></div><br/><div class="children"><div class="content">Mermaid&#x27;s definitely not well-suited for the amount of text and text formatting that C4 requires. You can do it, but you will be jumping through hoops, and the autolayout breaks down pretty quickly when the arrows between boxes get chatty.</div><br/><div id="37981907" class="c"><input type="checkbox" id="c-37981907" checked=""/><div class="controls bullet"><span class="by">gengstrand</span><span>|</span><a href="#37974677">root</a><span>|</span><a href="#37976497">parent</a><span>|</span><a href="#37975475">next</a><span>|</span><label class="collapse" for="c-37981907">[-]</label><label class="expand" for="c-37981907">[1 more]</label></div><br/><div class="children"><div class="content">True but the big selling point for mermaid is the github integration and you can audit the changes to the diagrams via git log -p</div><br/></div></div></div></div><div id="37975475" class="c"><input type="checkbox" id="c-37975475" checked=""/><div class="controls bullet"><span class="by">jhund</span><span>|</span><a href="#37974677">parent</a><span>|</span><a href="#37976497">prev</a><span>|</span><a href="#37975813">next</a><span>|</span><label class="collapse" for="c-37975475">[-]</label><label class="expand" for="c-37975475">[1 more]</label></div><br/><div class="children"><div class="content">Plus one for structurizr. Its model driven approach makes it a lot easier to keep the diagrams consistent with the code: You describe the architecture, and structurizr renders the diagrams.</div><br/></div></div></div></div><div id="37975813" class="c"><input type="checkbox" id="c-37975813" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#37974677">prev</a><span>|</span><a href="#37982222">next</a><span>|</span><label class="collapse" for="c-37975813">[-]</label><label class="expand" for="c-37975813">[5 more]</label></div><br/><div class="children"><div class="content">I dunno, I kind of subscribe to software architecture being like, a set of design decisions that guide the implementation. That&#x27;s what (in my experience) most software architects do; lay down guidance and structure for the software engineers.<p>&gt; The C4 model was created as a way to help software development teams describe and communicate software architecture, both during up-front design sessions and when retrospectively documenting an existing codebase.<p>&gt; It&#x27;s a way to create maps of your code, at various levels of detail, in the same way you would use something like Google Maps to zoom in and out of an area you are interested in.<p>This seems different.<p>I have no idea why you would refer to the a <i>code</i> diagram as your software architecture. That&#x27;s literally the code level. How is that architectural?<p>It&#x27;s like saying the circuit diagram in the plug should go on the house blueprint. &quot;You should use automated tools for this&quot; ... so, it&#x27;s for documenting existing code bases at the per-function level?<p>How is that useful for architecting &#x2F; designing &#x2F; planning software?<p>That sounds like software <i>structure</i> to me, not software architecture.<p>Sure, a map of existing software that explains how it&#x27;s structured sounds cool... but I dunno. Like, if you&#x27;re talking about design patterns, you&#x27;re not gonna give someone a function-by-function map of how to implement a singleton. They&#x27;re not stupid. You&#x27;d tell them you think it should have a singleton (or repository, or whatever).<p>Software design is totally a thing, and this seems entirely reasonable for designing software.<p>...but software <i>design and implementation</i> and software <i>architecture</i> are not the same thing and they&#x27;re not done by the same people, in my experience.<p>This feels more like... systems design, which a software architect would contribute <i>advice to</i> in the way that the systems were <i>designed</i> so they aligned with good <i>software architecture</i> principals.<p>Maybe I&#x27;m just being pedantic. &#x2F;shrug</div><br/><div id="37976305" class="c"><input type="checkbox" id="c-37976305" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#37975813">parent</a><span>|</span><a href="#37976071">next</a><span>|</span><label class="collapse" for="c-37976305">[-]</label><label class="expand" for="c-37976305">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I dunno, I kind of subscribe to software architecture being like, a set of design decisions that guide the implementation.<p>I think this is the one mandatory part of software architecture which is giving developers information to help them make their own design decisions without constantly deferring to the authority.<p>But the exact place where architecture ends and development starts varies a lot.<p>I like to think that architecture itself decides what is important from the architecture standpoint. If architecture decides a certain low level application detail is important, then it becomes an architecture detail.<p>In fact, in most organisation architecture controls at the very least some top level design like components, communication patterns, APIs and technology in use.<p>In some organisation architecture goes as far as individual classes. Not all classes, but maybe classes modelling the domain of the problem especially, if that model is used as a language for multiple project or even implemented as a shared artifact.<p>I think C4 is suitable for those organisations where architecture is concerned with more low level structure than just listing applications and their integration interfaces.</div><br/></div></div><div id="37976071" class="c"><input type="checkbox" id="c-37976071" checked=""/><div class="controls bullet"><span class="by">dexterbt1</span><span>|</span><a href="#37975813">parent</a><span>|</span><a href="#37976305">prev</a><span>|</span><a href="#37975917">next</a><span>|</span><label class="collapse" for="c-37976071">[-]</label><label class="expand" for="c-37976071">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, as I kinda share also that there are lines to be drawn between software architecture, design and implementation (all three).<p>Much like in the real world building of real-estate for example, I see there are different roles between the architect vs the engineers vs. the foremen.<p>What do you draw the line? What concerns&#x2F;areas are to be covered in each of these [arch vs design vs implem]?</div><br/></div></div><div id="37975917" class="c"><input type="checkbox" id="c-37975917" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#37975813">parent</a><span>|</span><a href="#37976071">prev</a><span>|</span><a href="#37976079">next</a><span>|</span><label class="collapse" for="c-37975917">[-]</label><label class="expand" for="c-37975917">[1 more]</label></div><br/><div class="children"><div class="content">Excellent points.<p>(also, not too pedantic)<p>(also, principals -&gt; principles)</div><br/></div></div><div id="37976079" class="c"><input type="checkbox" id="c-37976079" checked=""/><div class="controls bullet"><span class="by">maximinus_thrax</span><span>|</span><a href="#37975813">parent</a><span>|</span><a href="#37975917">prev</a><span>|</span><a href="#37982222">next</a><span>|</span><label class="collapse" for="c-37976079">[-]</label><label class="expand" for="c-37976079">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I kind of subscribe to software architecture being like, a set of design decisions that guide the implementation<p>Do you mean software architecture is such as a set of design decisions? Or that software architecture is a set of design decisions?</div><br/></div></div></div></div><div id="37982222" class="c"><input type="checkbox" id="c-37982222" checked=""/><div class="controls bullet"><span class="by">capn_duck</span><span>|</span><a href="#37975813">prev</a><span>|</span><a href="#37982678">next</a><span>|</span><label class="collapse" for="c-37982222">[-]</label><label class="expand" for="c-37982222">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always been unsure where this stuff fits in. Do you make it before your system is built, when its unclear how where all the cards will fall? Or after your system is made and in production and all the warts of reality are present and your graph is not so nice and neat anymore. This seems like an architects picture of things. Close enough to give people the false confidence to think they understand things, but not close enough to be of use to anyone actually working in the salt mines.</div><br/></div></div><div id="37982678" class="c"><input type="checkbox" id="c-37982678" checked=""/><div class="controls bullet"><span class="by">BerislavLopac</span><span>|</span><a href="#37982222">prev</a><span>|</span><a href="#37982095">next</a><span>|</span><label class="collapse" for="c-37982678">[-]</label><label class="expand" for="c-37982678">[1 more]</label></div><br/><div class="children"><div class="content">The best tool for writing C4 documentation I have seen so far is <a href="https:&#x2F;&#x2F;icepanel.io&#x2F;">https:&#x2F;&#x2F;icepanel.io&#x2F;</a></div><br/></div></div><div id="37982095" class="c"><input type="checkbox" id="c-37982095" checked=""/><div class="controls bullet"><span class="by">zoom6628</span><span>|</span><a href="#37982678">prev</a><span>|</span><a href="#37977633">next</a><span>|</span><label class="collapse" for="c-37982095">[-]</label><label class="expand" for="c-37982095">[1 more]</label></div><br/><div class="children"><div class="content">In the 80s I learnt SSADM and it was great for making sure business logic and architecture were understood and viable before a line of code was run. Which was very important on old mainframes with several hour turnarounds on compiles.<p>For last few decades I have only used diagrams to design and to explain. Have found too hard to keep diagrams up to date when iterating on compiles multiple times per hour.<p>What I feel is needed is ways to keep code, infra and spec in sync throughout the lifecycle.</div><br/></div></div><div id="37977633" class="c"><input type="checkbox" id="c-37977633" checked=""/><div class="controls bullet"><span class="by">wholesomepotato</span><span>|</span><a href="#37982095">prev</a><span>|</span><a href="#37975036">next</a><span>|</span><label class="collapse" for="c-37977633">[-]</label><label class="expand" for="c-37977633">[2 more]</label></div><br/><div class="children"><div class="content">Even as a non civil engineer I can understand floor plans and alikes and find then immediately useful. Even as a professional SWE these example diagrams don&#x27;t seem useful or informative enough to justify bothering with them.<p>Code is too multidimensional to be approximated with 2d drawings. It just doesn&#x27;t work.<p>What could work are more conventional architectural code patterns. Things like structured concurrency, but also for higher level. Maybe.</div><br/><div id="37979035" class="c"><input type="checkbox" id="c-37979035" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#37977633">parent</a><span>|</span><a href="#37975036">next</a><span>|</span><label class="collapse" for="c-37979035">[-]</label><label class="expand" for="c-37979035">[1 more]</label></div><br/><div class="children"><div class="content">Mostly because software architecture diagrams need a lot of context or have to be in specific context and quite tight scope.<p>Floor plan has really fixed context and very limited scope. Like I don&#x27;t have to explain windows ... but in software most of the time you actually have to explain &quot;window&quot; because every &quot;window&quot; or element will be different, you cannot just say this is window and copy it 20x.</div><br/></div></div></div></div><div id="37975036" class="c"><input type="checkbox" id="c-37975036" checked=""/><div class="controls bullet"><span class="by">nickdothutton</span><span>|</span><a href="#37977633">prev</a><span>|</span><a href="#37977601">next</a><span>|</span><label class="collapse" for="c-37975036">[-]</label><label class="expand" for="c-37975036">[2 more]</label></div><br/><div class="children"><div class="content">This is how you know software engineering is still an immature discipline. It’s 25+ years (in my case) as still we are having largely the same discussions about “basic” things. I’m not saying this is bad, but progress is slow, and we can’t blame any particular company or consortia or commercial interest here.</div><br/><div id="37975136" class="c"><input type="checkbox" id="c-37975136" checked=""/><div class="controls bullet"><span class="by">bdg</span><span>|</span><a href="#37975036">parent</a><span>|</span><a href="#37977601">next</a><span>|</span><label class="collapse" for="c-37975136">[-]</label><label class="expand" for="c-37975136">[1 more]</label></div><br/><div class="children"><div class="content">Honestly we have the same problem outside of engineering. C4 is really just a way to focus conversations along one level of abstraction.<p>How many times have you talked to someone who bounces up and down from high detail high complexity to zoomed-out simplicity in the same thought, and not understood what they wanted to tell you? We have the same issue when devs think &quot;I will just yolo some boxes and arrows on this board, it makes sense in my head so it is a good diagram!&quot;</div><br/></div></div></div></div><div id="37977601" class="c"><input type="checkbox" id="c-37977601" checked=""/><div class="controls bullet"><span class="by">bane</span><span>|</span><a href="#37975036">prev</a><span>|</span><a href="#37977713">next</a><span>|</span><label class="collapse" for="c-37977601">[-]</label><label class="expand" for="c-37977601">[1 more]</label></div><br/><div class="children"><div class="content">C4 is very interesting and I think tackles certain problems related to <i>software</i> architecture really well. It sort of turns the lower levels of an architecture, which is mostly hardware and system software, into broad abstractions and focuses the effort on the stuff that sits above that in the stack. Which turns out to be surprisingly suitable for today&#x27;s cloud-based&#x2F;containerized scalable approaches.<p>Related, Archimate is also very good and there&#x27;s a lot of overlap, but grounds itself more into the <i>infrastructure</i> bits. I&#x27;ve used some version of diagram approaches similar to Archimate in the past to really great effect to deconflict systems and data sources and demonstrate how all the stuff we&#x27;re buying and gluing together supports specific business and user workflow needs.<p>Comments here about how this stuff all gets out of sync with the codebase are absolutely correct. But I&#x27;ve found that they can be excellent tools for use when you need to analyze a complex system or communicate systems and plans to a larger group.<p>It&#x27;s surprising how often there isn&#x27;t really <i>any</i> form of cohesive documentation and just sitting down for a couple weeks and drawing boxes with lines connecting them can unblock and simplify failing and frustrated efforts to move forward, especially when teams are working in the same playpen.<p>C4, Archimate, UML, whatever are really just good constrained diagramming languages you can use to capture specific things you wish to communicate, analyze, or memorialize. I think they aren&#x27;t very good as preplanning and design tools.<p>Many of us suffered from the big UML push days where every facet of a system down to class definitions were supposed to be laid out in excruciating detail by some chief architect&#x27;s office before a line of code was laid down. Madness like &quot;we&#x27;ll just generate the code from the diagrams&quot; caused millions to suffer. When coding actually did start, those thousands of hours of planning usually were just ignored and the developers just did what they wanted anyways.</div><br/></div></div><div id="37977713" class="c"><input type="checkbox" id="c-37977713" checked=""/><div class="controls bullet"><span class="by">GorsyGentle</span><span>|</span><a href="#37977601">prev</a><span>|</span><a href="#37979384">next</a><span>|</span><label class="collapse" for="c-37977713">[-]</label><label class="expand" for="c-37977713">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried creating diagrams of this nature (not realizing this is a thing) but I chose them for documenting the system to others that weren&#x27;t already familiar with the project so it felt necessary to layer it all together. Those diagrams shown looked more like team meetings hashing out the details. Seemed kind of an unfair comparison.<p>That being said, the biggest issue I ran into is in the diagram tooling. At the time we had Gliphy. One could not make it interactable, such that double-clicking on a node would explode the container and let someone drill-down. At best they had layers which were awfully crude to work with. And at the end of the day didn&#x27;t export in SVG so were useless for embedding. Overall, a waste of time. :(</div><br/></div></div><div id="37979384" class="c"><input type="checkbox" id="c-37979384" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#37977713">prev</a><span>|</span><a href="#37975129">next</a><span>|</span><label class="collapse" for="c-37979384">[-]</label><label class="expand" for="c-37979384">[1 more]</label></div><br/><div class="children"><div class="content">If you model software, both existing and future state, as a primary business and technology activity, modularize where needed, reduce high level abstractions, follow SOLID&#x2F;DRY for the most part, and use bounded context operational data stores, the architectural diagrams serve a greater purpose and are a primary artifact.<p>In other words, no one should change code without first validating those changes with the existing model(s).</div><br/></div></div><div id="37975129" class="c"><input type="checkbox" id="c-37975129" checked=""/><div class="controls bullet"><span class="by">motohagiography</span><span>|</span><a href="#37979384">prev</a><span>|</span><a href="#37974758">next</a><span>|</span><label class="collapse" for="c-37975129">[-]</label><label class="expand" for="c-37975129">[1 more]</label></div><br/><div class="children"><div class="content">I like the model, and have had to use UML in security architecture where the whole thing hinges on consistency from the top level context to the code. The simplicty of this C4 model is a forcing function, where if there is hidden context or components, they have to shake out in the model. I&#x27;d suggest resistance to something this simple chould indicate there may be hidden elements (which there are more often than not on large projects). Forcing people to clarify their thinking into something like this decentralizes them by having them commit to statements and ideas instead of just reserving a right to suggest and criticize, and you can get a lot of resistance to that as well. These aren&#x27;t model problems though, but they&#x27;re what happens when models meet people.<p>I&#x27;ll use something like this as a reference for security design as I really like its consistency.</div><br/></div></div><div id="37974758" class="c"><input type="checkbox" id="c-37974758" checked=""/><div class="controls bullet"><span class="by">Veuxdo</span><span>|</span><a href="#37975129">prev</a><span>|</span><a href="#37975233">next</a><span>|</span><label class="collapse" for="c-37974758">[-]</label><label class="expand" for="c-37974758">[1 more]</label></div><br/><div class="children"><div class="content">If you find the C4 model to be too arbitrary and over-specified, I wrote on an alternative practice earlier this year: <a href="https:&#x2F;&#x2F;www.ilograph.com&#x2F;blog&#x2F;posts&#x2F;concrete-diagramming-models&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ilograph.com&#x2F;blog&#x2F;posts&#x2F;concrete-diagramming-mod...</a></div><br/></div></div><div id="37975233" class="c"><input type="checkbox" id="c-37975233" checked=""/><div class="controls bullet"><span class="by">jackconsidine</span><span>|</span><a href="#37974758">prev</a><span>|</span><a href="#37979640">next</a><span>|</span><label class="collapse" for="c-37975233">[-]</label><label class="expand" for="c-37975233">[1 more]</label></div><br/><div class="children"><div class="content">Mermaid supports C4 now [0]; though still experimental, it works in Notion and Github renderers.<p>[0] <a href="https:&#x2F;&#x2F;mermaid.js.org&#x2F;syntax&#x2F;c4.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;mermaid.js.org&#x2F;syntax&#x2F;c4.html</a></div><br/></div></div><div id="37979640" class="c"><input type="checkbox" id="c-37979640" checked=""/><div class="controls bullet"><span class="by">wildermuthn</span><span>|</span><a href="#37975233">prev</a><span>|</span><a href="#37977463">next</a><span>|</span><label class="collapse" for="c-37979640">[-]</label><label class="expand" for="c-37979640">[1 more]</label></div><br/><div class="children"><div class="content">I think most visualizations suffer from identifying the wrong piece of complexity — the essential complexity is state management, not code management.<p>Ideally, we should be able to visualize state and how state changes. This isn’t a state machine, and it isn’t database modeling. It is an understanding of information flow. Sometimes this flow of information has real-world side-effects (moving a robot’s arm), but mostly this flow is about information being created, transformed, and delivered.<p>I use the word information because this decouples the visualization from concerns about data and modeling. The important thing is information, not necessarily the way we model that information — those kind of visualizations already exist and are helpful for writing code. But the kind of information flow visualization I’m imaging would help us to understand not how to write code, but what code that needs to be written in the first place.<p>The most complex pieces of code tend to be buggy when changes are made to them, because they are acting upon state in ways that are essentially complex and interdependent. Wouldn’t it be nice to know that when you update a person’s first name that is is actually affecting systems X, Y, and Z rather than merely systems A, B, and C? Maybe the credit card validation system utilizes the first name in some odd way that your profile page doesn’t, but how would you know that by looking at the code for the profile page? You wouldn’t.<p>An information flow visualization could potentially identify that. Or maybe not. People don’t usually reference visualizations or keep them updated. A visualization would have to be 10x more useful than they are today to become a routine part of the daily grind of software development, ideally built into the dev experience like IDE type errors are.<p>Imagine an analog to jumping to a function definition for a state usage — jumping to a visualization of the information you are about to put your dirty paws upon. I suppose this would require a many-to-many relationship between the information flow visualization and state (and anywhere that state was stored, accessed, or mutated).<p>Fun dream.</div><br/></div></div><div id="37977463" class="c"><input type="checkbox" id="c-37977463" checked=""/><div class="controls bullet"><span class="by">FourthProtocol</span><span>|</span><a href="#37979640">prev</a><span>|</span><a href="#37978326">next</a><span>|</span><label class="collapse" for="c-37977463">[-]</label><label class="expand" for="c-37977463">[2 more]</label></div><br/><div class="children"><div class="content">Admittedly I&#x27;m a greybeard. Wrote my first app in 1984. Moved through the ranks, from support to dev roles, application architecture, enterprise architecture and finially process optimisation.<p>And so wow, those diagrams in the links - how does one even manage all those boxes?!?<p>Architecture is easier than coding, if you stay away from more&#x2F;bigger&#x2F;but_my_app_is_a_special_little_snowflake mantras. Consider the age-old, tried, tested, proven architecture models of yore (other than their most excellent diagram notations, stay away from UML).<p>Architecture (design) is layered, not spaghetti thrown at a wall, hoping something sticks. Most (99.9%) software domains can be divided into three horizontal layers -<p>1. UI<p>2. Application&#x2F;business layer<p>3. Data layer<p>(note that both internal and external service layers sit at the same level as data layers, allowing them to be called from the application layer)<p>Finally, there are vertical layers (shared across the initial three layers) These typically include -<p>4. Communication<p>5. Exception management<p>6. Security<p>7. Logs<p>Start with that as an overview&#x2F;index of the entire solution, and when the beast needs to grow, just grow it. But grow it wisely. Use the standard 3-tiered architecture model. Re-use those cross-cutting concens in new applications.<p>Federate identities. Standardise access&#x2F;permissions management.<p>Finally, don&#x27;t feel compelled to use all the things - if the solution is services-based, don&#x27;t code a UI for it. Simply connect your client to the relevant, existing service. Yes, services can be tiered, assuming your management processes are mature.<p>As to the management issue. Governance is what keeps your estate from turning into a hairball. Make extensive and judicious use of<p>1. Risk management<p>2. Change management<p>3. Stakeholder management<p>4. Design reviews<p>5. Project review (where team members grade managers)<p>Establish a technical design authority. The TDA concerns itself with broadly technical matters that facilitate a system-wide perspective. This might include -<p>1. Systems and solutions<p>2. Data<p>3. Communications<p>4. Quality objectives, including security<p>5. Development and development operations (devops)<p>6. Infrastructure (including but not limited to directories; 
networks; servers, both on-site and remote&#x2F;in clouds; workstations and mobile devices).<p>7. Testing (Tools, techniques, platforms, languages and frameworks)<p>8. Locations</div><br/><div id="37979067" class="c"><input type="checkbox" id="c-37979067" checked=""/><div class="controls bullet"><span class="by">tudorw</span><span>|</span><a href="#37977463">parent</a><span>|</span><a href="#37978326">next</a><span>|</span><label class="collapse" for="c-37979067">[-]</label><label class="expand" for="c-37979067">[1 more]</label></div><br/><div class="children"><div class="content">Nice, thanks.</div><br/></div></div></div></div><div id="37978326" class="c"><input type="checkbox" id="c-37978326" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37977463">prev</a><span>|</span><a href="#37976215">next</a><span>|</span><label class="collapse" for="c-37978326">[-]</label><label class="expand" for="c-37978326">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>The C4 model for visualising software architecture</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21032805">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21032805</a> - Sept 2019 (59 comments)</div><br/></div></div><div id="37976215" class="c"><input type="checkbox" id="c-37976215" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#37978326">prev</a><span>|</span><a href="#37977175">next</a><span>|</span><label class="collapse" for="c-37976215">[-]</label><label class="expand" for="c-37976215">[1 more]</label></div><br/><div class="children"><div class="content">I watched the talk on the site, and I liked it. But I also immediately had the question: Where do my actual abstractions live? So, not the concrete instances of an abstraction that runs somewhere, maybe as a component, maybe as code, maybe even as a whole container; but the abstraction itself.</div><br/></div></div><div id="37977175" class="c"><input type="checkbox" id="c-37977175" checked=""/><div class="controls bullet"><span class="by">jackblemming</span><span>|</span><a href="#37976215">prev</a><span>|</span><a href="#37977619">next</a><span>|</span><label class="collapse" for="c-37977175">[-]</label><label class="expand" for="c-37977175">[4 more]</label></div><br/><div class="children"><div class="content">You can see a crappy house that’s falling apart pretty easily. Conversely management cannot see a crappy codebase that’s rife with technical debt. Maybe they would make more intelligent decisions if they could visualize the problem.</div><br/><div id="37977631" class="c"><input type="checkbox" id="c-37977631" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#37977175">parent</a><span>|</span><a href="#37977619">next</a><span>|</span><label class="collapse" for="c-37977631">[-]</label><label class="expand" for="c-37977631">[3 more]</label></div><br/><div class="children"><div class="content">Code quality does not seem to have any correlation with business success. Why should business care?</div><br/><div id="37982829" class="c"><input type="checkbox" id="c-37982829" checked=""/><div class="controls bullet"><span class="by">eitland</span><span>|</span><a href="#37977175">root</a><span>|</span><a href="#37977631">parent</a><span>|</span><a href="#37978232">next</a><span>|</span><label class="collapse" for="c-37982829">[-]</label><label class="expand" for="c-37982829">[1 more]</label></div><br/><div class="children"><div class="content">If you think about code quality in terms like line length, spelling errors, etc it might not matter.<p>If you think of it in terms of:<p>- how long does it take to get at new developer up to speed?  (everything from readability to build systems)<p>- can this be hacked any day of the week if someone puts their mind to it? (both own code and libraries)<p>- can we be resonably sure that new changes don&#x27;t introduce (large) defects? (testing, modularization)<p>it becomes impossible to argue that it cannot affect business success.<p>Yes:<p>- it might work as long as the old dev is happy and alive, but break down when he isn&#x27;t available anymore<p>- it might work as long as nobody targets this business specifically<p>- it might work as it exist <i>now</i> but at some point be impossible to update anymore and the day new tax rules or whatever are introduced, it breaks</div><br/></div></div><div id="37978232" class="c"><input type="checkbox" id="c-37978232" checked=""/><div class="controls bullet"><span class="by">jackblemming</span><span>|</span><a href="#37977175">root</a><span>|</span><a href="#37977631">parent</a><span>|</span><a href="#37982829">prev</a><span>|</span><a href="#37977619">next</a><span>|</span><label class="collapse" for="c-37978232">[-]</label><label class="expand" for="c-37978232">[1 more]</label></div><br/><div class="children"><div class="content">Well this is just wrong, so I don&#x27;t really know how to respond. You&#x27;re probably thinking about monopolies such as Facebook, Google, or the like, where not only does code quality not matter, but not much matters at all. Most businesses do not have this luxury.</div><br/></div></div></div></div></div></div><div id="37977619" class="c"><input type="checkbox" id="c-37977619" checked=""/><div class="controls bullet"><span class="by">d--b</span><span>|</span><a href="#37977175">prev</a><span>|</span><a href="#37977548">next</a><span>|</span><label class="collapse" for="c-37977619">[-]</label><label class="expand" for="c-37977619">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ask somebody in the building industry to visually communicate the architecture of a building and you&#x27;ll be presented with site plans, floor plans, elevation views, cross-section views and detail drawings.<p>Well ask an architect to visually communicate “how the building is going to work”, ie, where do pilots go, how security works, how long will the waiting line be. What happnes to people missing the plane after they go through security. Then we’ll talk about those software diagrams.</div><br/></div></div><div id="37977548" class="c"><input type="checkbox" id="c-37977548" checked=""/><div class="controls bullet"><span class="by">IAmGraydon</span><span>|</span><a href="#37977619">prev</a><span>|</span><a href="#37979564">next</a><span>|</span><label class="collapse" for="c-37977548">[-]</label><label class="expand" for="c-37977548">[2 more]</label></div><br/><div class="children"><div class="content">The talk about programmatically creating these diagrams is interesting, but it would be more interesting to use this in reverse with AI. Create a C4 diagram with a GUI, programmatically factor it down to some kind of text-based format and use that as an input for a code-generating AI. Imagine rewriting vast chunks of code by just editing the structure diagram.</div><br/><div id="37977611" class="c"><input type="checkbox" id="c-37977611" checked=""/><div class="controls bullet"><span class="by">dpflan</span><span>|</span><a href="#37977548">parent</a><span>|</span><a href="#37979564">next</a><span>|</span><label class="collapse" for="c-37977611">[-]</label><label class="expand" for="c-37977611">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen some cool results when asking GenAI (here it was ChatGPT) to create code based upon a sequence diagram and vice versa. The goal is to have an abstraction to generate code from. Or at least build the 80% of the text for something to be a seed for generating code.</div><br/></div></div></div></div><div id="37979564" class="c"><input type="checkbox" id="c-37979564" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#37977548">prev</a><span>|</span><a href="#37974488">next</a><span>|</span><label class="collapse" for="c-37979564">[-]</label><label class="expand" for="c-37979564">[1 more]</label></div><br/><div class="children"><div class="content">To quote Jamie Hyneman: &quot;When in doubt, C4&quot;.</div><br/></div></div><div id="37974488" class="c"><input type="checkbox" id="c-37974488" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37979564">prev</a><span>|</span><a href="#37978973">next</a><span>|</span><label class="collapse" for="c-37974488">[-]</label><label class="expand" for="c-37974488">[17 more]</label></div><br/><div class="children"><div class="content">Interesting but I don&#x27;t think this especially adds anything. The high level diagrams are great but then you can already make those without having to read any fancy visual model websites. The site even kind of admits this:<p>&gt; As an industry, we do have the Unified Modeling Language (UML), ArchiMate and SysML, but asking whether these provide an effective way to communicate software architecture is often irrelevant because many teams have already thrown them out in favour of much simpler &quot;boxes and lines&quot; diagrams.<p>This is very true, but then they seem to have ignored the reasons <i>why</i> UML class diagrams were a total failure. They somehow acknowledge that nobody likes them, but then the 4th C of their model (code) is... UML class diagrams!<p>You don&#x27;t need this. Just do ad-hoc diagrams and make them clear, with labelled arrows. Their first three diagrams are actually good examples of this.</div><br/><div id="37974503" class="c"><input type="checkbox" id="c-37974503" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#37974488">parent</a><span>|</span><a href="#37974568">next</a><span>|</span><label class="collapse" for="c-37974503">[-]</label><label class="expand" for="c-37974503">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I do. Boxes and lines between them. It helps a lot when thinking up new concepts and brainstorming too, so that the tool doesn&#x27;t slow you down.<p>I use Freeform now, which is super simple but works. Mark two objects and cmd-click&#x2F;right click, then click &quot;add connecting line&quot;.</div><br/><div id="37974784" class="c"><input type="checkbox" id="c-37974784" checked=""/><div class="controls bullet"><span class="by">almostnormal</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37974503">parent</a><span>|</span><a href="#37974770">next</a><span>|</span><label class="collapse" for="c-37974784">[-]</label><label class="expand" for="c-37974784">[3 more]</label></div><br/><div class="children"><div class="content">One step further: Powerpoint. Sooner or later the diagrams will usually be needed in a presentation. Having them in a presentable format saves another step, and is a constant reminder to produce something worth presenting.<p>Those diagrams that don&#x27;t end up in presentations will be write-only anyway, and could be in any random format. No-one is going to read them.</div><br/><div id="37976917" class="c"><input type="checkbox" id="c-37976917" checked=""/><div class="controls bullet"><span class="by">joegahona</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37974784">parent</a><span>|</span><a href="#37977313">next</a><span>|</span><label class="collapse" for="c-37976917">[-]</label><label class="expand" for="c-37976917">[1 more]</label></div><br/><div class="children"><div class="content">That’s a really good point, I’ve had to redo diagrams before to fit them into a presentation, and because they were sprawling all over the place in Figma or Miro, they required extra work to fit correctly and be readable. Powerpoint or Google Slides forces you to concision and the aspect ratio of the slide, for good or bad.</div><br/></div></div><div id="37977313" class="c"><input type="checkbox" id="c-37977313" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37974784">parent</a><span>|</span><a href="#37976917">prev</a><span>|</span><a href="#37974770">next</a><span>|</span><label class="collapse" for="c-37977313">[-]</label><label class="expand" for="c-37977313">[1 more]</label></div><br/><div class="children"><div class="content">Freeform is basically a simplified Keynote, which it is based on. I used Keynote before. Might actually return to it since Freeform is pretty basic right now (it&#x27;s pretty new).</div><br/></div></div></div></div><div id="37974770" class="c"><input type="checkbox" id="c-37974770" checked=""/><div class="controls bullet"><span class="by">wejick</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37974503">parent</a><span>|</span><a href="#37974784">prev</a><span>|</span><a href="#37974568">next</a><span>|</span><label class="collapse" for="c-37974770">[-]</label><label class="expand" for="c-37974770">[2 more]</label></div><br/><div class="children"><div class="content">Is it Freeform as the Apple Freeform?
I tried it last week to create high Level design, still not as smooth as I expected. Mainly the text editing flow feels not seamless yet, the deal breaker was I couldn&#x27;t get the file successfully shared thru any available options.<p>To be fair it&#x27;s still in its early of its time, I&#x27;ll wait bit longer.</div><br/><div id="37977306" class="c"><input type="checkbox" id="c-37977306" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37974770">parent</a><span>|</span><a href="#37974568">next</a><span>|</span><label class="collapse" for="c-37977306">[-]</label><label class="expand" for="c-37977306">[1 more]</label></div><br/><div class="children"><div class="content">Apple Freeform yes, comes with macOS. Before that I used Keynote.</div><br/></div></div></div></div></div></div><div id="37974568" class="c"><input type="checkbox" id="c-37974568" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37974488">parent</a><span>|</span><a href="#37974503">prev</a><span>|</span><a href="#37974909">next</a><span>|</span><label class="collapse" for="c-37974568">[-]</label><label class="expand" for="c-37974568">[6 more]</label></div><br/><div class="children"><div class="content">UML is still highly used at the architecture command deck, even if the dream to generate code from diagrams failed.<p>Just a couple of months ago I finalized yet another archictecture document, with enough class diagrams, sequence diagrams and use cases on it.</div><br/><div id="37976804" class="c"><input type="checkbox" id="c-37976804" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37974568">parent</a><span>|</span><a href="#37974909">next</a><span>|</span><label class="collapse" for="c-37976804">[-]</label><label class="expand" for="c-37976804">[5 more]</label></div><br/><div class="children"><div class="content">Try testing if people can comprehend the diagrams by asking a question after showing them a somewhat complicated one. You&#x27;ll likely be disappointed. We don&#x27;t seem to be using them because they work.</div><br/><div id="37977525" class="c"><input type="checkbox" id="c-37977525" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37976804">parent</a><span>|</span><a href="#37974909">next</a><span>|</span><label class="collapse" for="c-37977525">[-]</label><label class="expand" for="c-37977525">[4 more]</label></div><br/><div class="children"><div class="content">As it happens, most people understand easier a standard notation that can refer to, and get a book at the library, than NIH boxes and lines.<p>Now people straigth out of bootcamps calling themselves engineers, without having a Software Engineer degree, yeah maybe not.<p>Then again, they can get that book I just mentioned, and in the process maybe discover other goodies at the local library, or just ask ChatGPT.</div><br/><div id="37979802" class="c"><input type="checkbox" id="c-37979802" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37977525">parent</a><span>|</span><a href="#37978088">next</a><span>|</span><label class="collapse" for="c-37979802">[-]</label><label class="expand" for="c-37979802">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the standard matters, so much as the visual diagraming not seeming to work well at scale.<p>A drawing showing the relationships between database tables seems to be comprehendible to people, until you get to over 7 tables or so, and then they don&#x27;t appear to be able to make sense of it. Real databases often have magnitudes more tables than that.<p>You apparently have something you can do a trial with. Show it to people, give them time to digest, and politely quiz them a bit to see if it worked.</div><br/></div></div><div id="37978088" class="c"><input type="checkbox" id="c-37978088" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37977525">parent</a><span>|</span><a href="#37979802">prev</a><span>|</span><a href="#37974909">next</a><span>|</span><label class="collapse" for="c-37978088">[-]</label><label class="expand" for="c-37978088">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As it happens, most people understand easier a standard notation that can refer to, and get a book at the library, than NIH boxes and lines.<p>I do not believe this for a second. You&#x27;re possible arguing against a straw man.<p>The alternative to UML isn&#x27;t a &quot;NIH UML&quot; which uses a <i>different</i> array of arrows. It&#x27;s <i>labelled</i> boxes and lines. You don&#x27;t need to go to a library to understand the diagram because the diagram is self-explanatory.<p>Here&#x27;s a really good example:<p><a href="https:&#x2F;&#x2F;buck2.build&#x2F;docs&#x2F;concepts&#x2F;concept_map&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;buck2.build&#x2F;docs&#x2F;concepts&#x2F;concept_map&#x2F;</a><p>Every arrow is labelled. No tedious textbook needed.</div><br/><div id="37978201" class="c"><input type="checkbox" id="c-37978201" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37978088">parent</a><span>|</span><a href="#37974909">next</a><span>|</span><label class="collapse" for="c-37978201">[-]</label><label class="expand" for="c-37978201">[1 more]</label></div><br/><div class="children"><div class="content">You are free to believe in whatever makes you happy, I am not UML missionary.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37974909" class="c"><input type="checkbox" id="c-37974909" checked=""/><div class="controls bullet"><span class="by">bdg</span><span>|</span><a href="#37974488">parent</a><span>|</span><a href="#37974568">prev</a><span>|</span><a href="#37978973">next</a><span>|</span><label class="collapse" for="c-37974909">[-]</label><label class="expand" for="c-37974909">[4 more]</label></div><br/><div class="children"><div class="content">Having structured architecture conventions becomes more important when you have many architecture conversations across multiple people and would like to gain insights from the diagrams too.</div><br/><div id="37976165" class="c"><input type="checkbox" id="c-37976165" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37974909">parent</a><span>|</span><a href="#37978973">next</a><span>|</span><label class="collapse" for="c-37976165">[-]</label><label class="expand" for="c-37976165">[3 more]</label></div><br/><div class="children"><div class="content">But you don&#x27;t need and official standard that everyone learns. Just use words. If your box is a class, write &quot;class Foo&quot;. If your arrow means &quot;contains 1 or more&quot; just write that next to the arrow.</div><br/><div id="37977225" class="c"><input type="checkbox" id="c-37977225" checked=""/><div class="controls bullet"><span class="by">lfpeb8b45ez</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37976165">parent</a><span>|</span><a href="#37978973">next</a><span>|</span><label class="collapse" for="c-37977225">[-]</label><label class="expand" for="c-37977225">[2 more]</label></div><br/><div class="children"><div class="content">Yes, that’s exactly the convention that C4 specifies: add legends on every diagram and make sure things are labeled in a way that people can understand.</div><br/><div id="37978104" class="c"><input type="checkbox" id="c-37978104" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37974488">root</a><span>|</span><a href="#37977225">parent</a><span>|</span><a href="#37978973">next</a><span>|</span><label class="collapse" for="c-37978104">[-]</label><label class="expand" for="c-37978104">[1 more]</label></div><br/><div class="children"><div class="content">Well they don&#x27;t follow their own rules then because the &quot;Level 4&quot; diagram on that page is just standard awful UML with no legend or labels.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37978973" class="c"><input type="checkbox" id="c-37978973" checked=""/><div class="controls bullet"><span class="by">mickeypi</span><span>|</span><a href="#37974488">prev</a><span>|</span><label class="collapse" for="c-37978973">[-]</label><label class="expand" for="c-37978973">[3 more]</label></div><br/><div class="children"><div class="content">The same article posted for the 14th time since 2017. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=c4model.com">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;from?site=c4model.com</a></div><br/><div id="37979020" class="c"><input type="checkbox" id="c-37979020" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#37978973">parent</a><span>|</span><a href="#37978992">next</a><span>|</span><label class="collapse" for="c-37979020">[-]</label><label class="expand" for="c-37979020">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;query=by%3Adang%20%22reposts%20are%20ok%22%20attention&amp;sort=byDate&amp;type=comment" rel="nofollow noreferrer">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;que...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>