<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729501267894" as="style"/><link rel="stylesheet" href="styles.css?v=1729501267894"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dl.acm.org/doi/10.1145/3689746">The Ultimate Conditional Syntax</a> <span class="domain">(<a href="https://dl.acm.org">dl.acm.org</a>)</span></div><div class="subtext"><span>azhenley</span> | <span>25 comments</span></div><br/><div><div id="41901768" class="c"><input type="checkbox" id="c-41901768" checked=""/><div class="controls bullet"><span class="by">lou1306</span><span>|</span><a href="#41898835">next</a><span>|</span><label class="collapse" for="c-41901768">[-]</label><label class="expand" for="c-41901768">[1 more]</label></div><br/><div class="children"><div class="content">Kudos for publishing in OOPSLA, but alas I&#x27;m skeptical. This seems to add visual clutter&#x2F;mental overhead as one needs to parse a decision tree rather than having a &quot;flat&quot; sequence of patterns with the optional when-condition.<p>Also,<p>&gt; all the branches in the corresponding pattern matching expression would
need to destructure the pair, even when only one of its components is needed<p>Can&#x27;t one just bind the unneeded component to _ ? Isn&#x27;t that actually a good thing, as it clearly self-documents we won&#x27;t need that value on that branch?</div><br/></div></div><div id="41898835" class="c"><input type="checkbox" id="c-41898835" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41901768">prev</a><span>|</span><a href="#41901409">next</a><span>|</span><label class="collapse" for="c-41898835">[-]</label><label class="expand" for="c-41898835">[3 more]</label></div><br/><div class="children"><div class="content">I like that there is this left-to-right flow. I think it’s a bit nicer to read than if-let ordering where the pattern comes before the thing it will be matched against. I think it’s also good for ocaml-style constructor disambiguation, which tends to go in lexical order.<p>Another nice aspect of making guards a less special case is that it avoids complexities in deciding if a binding is unused. I believe this logic was a source of lots of compiler warning bugs in ocaml.<p>This syntax doesn’t seem to solve the following problem with matching where there are two paths to the same binding, (say you have an option in one branch but it isn’t optional in the other, and maybe you’d like to handle both cases with the same code. Currently you can do that with a match (match …) with … pattern.<p>I worry that the semantics around exhaustiveness and mutable values may be confusing, though I guess OCaml already has that problem:<p><pre><code>  type t = { mutable x : bool }

  let n = function true -&gt; 1 | false -&gt; 0

  let f t =
    match t with
    | { x = false } when ( t.x &lt;- true; false) -&gt; -1
    | { x } -&gt; n x * 2 + n t.x
</code></pre>
What does t { x = false } return? Similarly if you changed the second case to be two cases instead of binding x?</div><br/><div id="41900278" class="c"><input type="checkbox" id="c-41900278" checked=""/><div class="controls bullet"><span class="by">lptk</span><span>|</span><a href="#41898835">parent</a><span>|</span><a href="#41901409">next</a><span>|</span><label class="collapse" for="c-41900278">[-]</label><label class="expand" for="c-41900278">[2 more]</label></div><br/><div class="children"><div class="content">As mentioned in a response to a sibling comment, we plan to support `or`, which should address the problem you mention. (If not, would you have an example of what you mean?)<p>&gt; I worry that the semantics around exhaustiveness and mutable values may be confusing, though I guess OCaml already has that problem<p>Indeed, and it was until very recently a source of unsoundness: <a href="https:&#x2F;&#x2F;icfp24.sigplan.org&#x2F;details&#x2F;mlworkshop-2024-papers&#x2F;8&#x2F;Pattern-matching-on-mutable-values-danger-" rel="nofollow">https:&#x2F;&#x2F;icfp24.sigplan.org&#x2F;details&#x2F;mlworkshop-2024-papers&#x2F;8&#x2F;...</a></div><br/><div id="41900682" class="c"><input type="checkbox" id="c-41900682" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41898835">root</a><span>|</span><a href="#41900278">parent</a><span>|</span><a href="#41901409">next</a><span>|</span><label class="collapse" for="c-41900682">[-]</label><label class="expand" for="c-41900682">[1 more]</label></div><br/><div class="children"><div class="content">Oh, wow, that&#x27;s interesting.<p>We added pattern matching and exhaustiveness to Dart not that long ago, and dealing with exhaustiveness and mutability was a big concern since Dart (unlike more strictly functional languages) generally doesn&#x27;t avoid mutability.<p>Our solution was that whenever a pattern accesses a property, the language implicitly caches that value. Any future accesses to the same property in that switch statement&#x2F;expression use the previously cached value. That way, an entire set of switch cases is always operating on an immutable snapshot of data so that exhaustiveness can&#x27;t be violated by side effects. Spec:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dart-lang&#x2F;language&#x2F;blob&#x2F;main&#x2F;accepted&#x2F;3.0&#x2F;patterns&#x2F;feature-specification.md#side-effects-and-exhaustiveness">https:&#x2F;&#x2F;github.com&#x2F;dart-lang&#x2F;language&#x2F;blob&#x2F;main&#x2F;accepted&#x2F;3.0...</a></div><br/></div></div></div></div></div></div><div id="41901409" class="c"><input type="checkbox" id="c-41901409" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#41898835">prev</a><span>|</span><a href="#41901786">next</a><span>|</span><label class="collapse" for="c-41901409">[-]</label><label class="expand" for="c-41901409">[1 more]</label></div><br/><div class="children"><div class="content">Kudos to the authors.  It takes some fortitude to try to make a contribution to something as fundamental and ubiquitous as the &quot;if&quot; statement.  Appreciate providing the grammar and the thorough explanations, will save a lot of pain when trying to implement!</div><br/></div></div><div id="41901786" class="c"><input type="checkbox" id="c-41901786" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#41901409">prev</a><span>|</span><a href="#41900153">next</a><span>|</span><label class="collapse" for="c-41901786">[-]</label><label class="expand" for="c-41901786">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an online playground for MLscript at:<p><a href="https:&#x2F;&#x2F;hkust-taco.github.io&#x2F;mlscript&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hkust-taco.github.io&#x2F;mlscript&#x2F;</a></div><br/></div></div><div id="41900153" class="c"><input type="checkbox" id="c-41900153" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#41901786">prev</a><span>|</span><a href="#41898411">next</a><span>|</span><label class="collapse" for="c-41900153">[-]</label><label class="expand" for="c-41900153">[2 more]</label></div><br/><div class="children"><div class="content">The other one I want occassionally is &quot;or&quot;.<p>Imagine Left and Right contained data of compatible types, then I&#x27;d like to extract that data (regardless of tag) like so:<p><pre><code>    if x is Left(y) or x is Right(y) then ...
</code></pre>
That way I only need to write the `...` part once. (This could be combined with the rest of the pattern matching machinery in interesting ways, and would probably need to have eager matching &#x2F; short-circuiting semantics in case both cases match).</div><br/><div id="41900262" class="c"><input type="checkbox" id="c-41900262" checked=""/><div class="controls bullet"><span class="by">lptk</span><span>|</span><a href="#41900153">parent</a><span>|</span><a href="#41898411">next</a><span>|</span><label class="collapse" for="c-41900262">[-]</label><label class="expand" for="c-41900262">[1 more]</label></div><br/><div class="children"><div class="content">We definitely want to get into that! Unfortunately it&#x27;s not completely straightforward. A simple desugaring doesn&#x27;t work due to our support for intermediate bindings and computations, which we don&#x27;t want to recompute.</div><br/></div></div></div></div><div id="41898411" class="c"><input type="checkbox" id="c-41898411" checked=""/><div class="controls bullet"><span class="by">clark800</span><span>|</span><a href="#41900153">prev</a><span>|</span><a href="#41898156">next</a><span>|</span><label class="collapse" for="c-41898411">[-]</label><label class="expand" for="c-41898411">[1 more]</label></div><br/><div class="children"><div class="content">Looks very similar to lambda zero syntax (<a href="https:&#x2F;&#x2F;github.com&#x2F;clark800&#x2F;lambda-zero">https:&#x2F;&#x2F;github.com&#x2F;clark800&#x2F;lambda-zero</a>):<p><pre><code>    def getNaturalName(tag, globals)
        if globals.lookup(&quot;0&quot;) is Just(Global(_, _, term))
            if term is Numeral(_, type, _)
                return Just(Name(getTermTag(type)))
            error showSyntaxError(&quot;0 must be a numeral to use numerals&quot;, tag)
        return Void
</code></pre>
Though this ultimate conditional syntax is more general because lambda zero only allows one destructuring per conditional to simplify parsing.</div><br/></div></div><div id="41898156" class="c"><input type="checkbox" id="c-41898156" checked=""/><div class="controls bullet"><span class="by">huqedato</span><span>|</span><a href="#41898411">prev</a><span>|</span><a href="#41898786">next</a><span>|</span><label class="collapse" for="c-41898156">[-]</label><label class="expand" for="c-41898156">[5 more]</label></div><br/><div class="children"><div class="content">Elixir already has this - &quot;with&quot;. <a href="https:&#x2F;&#x2F;www.openmymind.net&#x2F;Elixirs-With-Statement&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.openmymind.net&#x2F;Elixirs-With-Statement&#x2F;</a>
E.g.:<p><pre><code>  with true &lt;- is_email_address?(email),
     true &lt;- String.length(code) === 6,
     %EmailConfirmation{} &lt;- EmailConfirmations.get_email_confirmation(email),
     nil &lt;- EmailAddresses.get_email_address(email),
     {:ok, user} &lt;- Users.create_user(data),
     {:ok, email_address} &lt;- EmailAddresses.create_email_address(user, email) do
     ...
  else
     ...
  end</code></pre></div><br/><div id="41900911" class="c"><input type="checkbox" id="c-41900911" checked=""/><div class="controls bullet"><span class="by">halostatue</span><span>|</span><a href="#41898156">parent</a><span>|</span><a href="#41899154">next</a><span>|</span><label class="collapse" for="c-41900911">[-]</label><label class="expand" for="c-41900911">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that this is `with` (which is really a series of nested `case` statements with exactly two paths per case).<p><pre><code>    case is_email_address?(email) do
      true -&gt;
        case String.length(code) == 6 do
          true -&gt;
            case EmailConfirmations.get_email_confirmation(email) do
              %EmailConfirmation{} -&gt;
                case EmailAddresses.get_email_address(email) do
                  nil -&gt;
                    case Users.create_user(data) do
                      {:ok, user} -&gt;
                        case EmailAddresses.create_email_address(user, email) do
                          {:ok, email_address} -&gt;
                             # success block
                          fail -&gt; fail
                        end
                      fail -&gt; fail
                    end
                  fail -&gt; fail
                end
              fail -&gt; fail
            end
          fail -&gt; fail
        end
      fail -&gt;
        case fail do
          # else conditions
        end
    end

</code></pre>
Elixir will be able to do something closer to `case` exhaustiveness checking with the gradual typing being built, and dialyzer can <i>sort of</i> perform exhaustiveness checking as long as your type specs are written well enough. (I’ve observed two things about `with` statements in Elixir: they should have more than one condition clause, or they should be written as `case` statements; they should <i>not</i> have an `else` clause, as that suggests that error path normalization isn&#x27;t happening at the right level.)<p>In many ways what&#x27;s described is much closer to `cond`, except that `cond` is <i>completely open ended</i> except for the required `true` clause, which means that there is absolutely no exhaustiveness checking.<p>I&#x27;ll admit that I mostly skimmed this and I don&#x27;t use ML or Haskell, but I couldn&#x27;t see what benefit this provides over Elixir&#x27;s `case` or Rust&#x27;s `match` (recognizing that the former can&#x27;t do exhaustiveness checking as yet, but `match` absolutely can).</div><br/><div id="41901573" class="c"><input type="checkbox" id="c-41901573" checked=""/><div class="controls bullet"><span class="by">lptk</span><span>|</span><a href="#41898156">root</a><span>|</span><a href="#41900911">parent</a><span>|</span><a href="#41899154">next</a><span>|</span><label class="collapse" for="c-41901573">[-]</label><label class="expand" for="c-41901573">[2 more]</label></div><br/><div class="children"><div class="content">Just check out the paper&#x27;s Motivaton section (2).<p>In ML you can&#x27;t write something like this:<p><pre><code>    if e is
      ...
      Lit(value)
        and Map.find_opt(value) is Some(result)
        then Some(result)
      ...
</code></pre>
where the `...` may include many cases and may contain other Lit cases, so that you would need to refactor the whole expression.<p>Haskell&#x27;s pattern guards can do this, but they can&#x27;t &quot;split&quot; control-flow in the middle of a case, as in:<p><pre><code>      Lit(value)
        and Map.find_opt(value) is Some(result)
        and computation(result) is
          Left(a)  then ...
          Right(b) then ...
</code></pre>
but these all fall out completely naturally in the UCS.<p>Also, exhaustiveness Just Works without the need of any type annotation. The system is actually type system agnostic.</div><br/><div id="41901614" class="c"><input type="checkbox" id="c-41901614" checked=""/><div class="controls bullet"><span class="by">lptk</span><span>|</span><a href="#41898156">root</a><span>|</span><a href="#41901573">parent</a><span>|</span><a href="#41899154">next</a><span>|</span><label class="collapse" for="c-41901614">[-]</label><label class="expand" for="c-41901614">[1 more]</label></div><br/><div class="children"><div class="content">PS: there&#x27;s another point being made on Reddit about cond&#x27;s right-shift problem: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;1g127oy&#x2F;the_ultimate_conditional_syntax&#x2F;lrg36qg&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;1g127...</a></div><br/></div></div></div></div></div></div><div id="41899154" class="c"><input type="checkbox" id="c-41899154" checked=""/><div class="controls bullet"><span class="by">ioasuncvinvaer</span><span>|</span><a href="#41898156">parent</a><span>|</span><a href="#41900911">prev</a><span>|</span><a href="#41898786">next</a><span>|</span><label class="collapse" for="c-41899154">[-]</label><label class="expand" for="c-41899154">[1 more]</label></div><br/><div class="children"><div class="content">How does this check exhaustiveness?</div><br/></div></div></div></div><div id="41898786" class="c"><input type="checkbox" id="c-41898786" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41898156">prev</a><span>|</span><a href="#41899915">next</a><span>|</span><label class="collapse" for="c-41898786">[-]</label><label class="expand" for="c-41898786">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand how it&#x27;s better than traditional pattern matching.</div><br/><div id="41898886" class="c"><input type="checkbox" id="c-41898886" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41898786">parent</a><span>|</span><a href="#41899208">next</a><span>|</span><label class="collapse" for="c-41898886">[-]</label><label class="expand" for="c-41898886">[7 more]</label></div><br/><div class="children"><div class="content">With traditional matching there are up to five different things:<p>- if x then y else z. This is roughly like a match with a true and false case but it depends on the language how much that is<p>- match e with { p -&gt; e }. This is the classic pattern match case<p>- if let p = e then x. This is roughly equivalent to (match e with p -&gt; x | _ -&gt; ())<p>- match e with { p when e -&gt; e }. This is matching with a guard but I’ve counted it as a special case because it doesn’t easily designate into a match because of the binding&#x2F;evaluation order, and the guard is special because it can only go at the top level of the match clause so it isn’t just a special kind of pattern (though maybe it could be)<p>- let p = e. This is one-case pattern matching used for binding variables or destructuring.<p>The paper proposes a way to make the first four cases obvious parts of one more unified thing, which makes the language potentially simpler and may reduce some weird warts like where guards can go.</div><br/><div id="41899050" class="c"><input type="checkbox" id="c-41899050" checked=""/><div class="controls bullet"><span class="by">EPWN3D</span><span>|</span><a href="#41898786">root</a><span>|</span><a href="#41898886">parent</a><span>|</span><a href="#41901602">next</a><span>|</span><label class="collapse" for="c-41899050">[-]</label><label class="expand" for="c-41899050">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s such a thing as too high an abstraction. Sometimes 4 different operations really are just 4 different operations and not cases of some mega-construct.</div><br/><div id="41899371" class="c"><input type="checkbox" id="c-41899371" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41898786">root</a><span>|</span><a href="#41899050">parent</a><span>|</span><a href="#41901602">next</a><span>|</span><label class="collapse" for="c-41899371">[-]</label><label class="expand" for="c-41899371">[1 more]</label></div><br/><div class="children"><div class="content">I totally agree that can be the case, but I’m not sure it applies that much to the OP.</div><br/></div></div></div></div><div id="41901602" class="c"><input type="checkbox" id="c-41901602" checked=""/><div class="controls bullet"><span class="by">lptk</span><span>|</span><a href="#41898786">root</a><span>|</span><a href="#41898886">parent</a><span>|</span><a href="#41899050">prev</a><span>|</span><a href="#41899066">next</a><span>|</span><label class="collapse" for="c-41901602">[-]</label><label class="expand" for="c-41901602">[1 more]</label></div><br/><div class="children"><div class="content">Also check out my other answer here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41901573">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41901573</a></div><br/></div></div><div id="41899066" class="c"><input type="checkbox" id="c-41899066" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41898786">root</a><span>|</span><a href="#41898886">parent</a><span>|</span><a href="#41901602">prev</a><span>|</span><a href="#41899208">next</a><span>|</span><label class="collapse" for="c-41899066">[-]</label><label class="expand" for="c-41899066">[3 more]</label></div><br/><div class="children"><div class="content">Inspired by duality, I&#x27;ve been trying to work out a language where there&#x27;s a more obvious correspondence&#x2F;symmetry between expressions (which evaluate in an environment of named bindings to produce an anonymous value) and patterns (which destructure an anonymous value to produce an environment of named bindings).</div><br/><div id="41899917" class="c"><input type="checkbox" id="c-41899917" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#41898786">root</a><span>|</span><a href="#41899066">parent</a><span>|</span><a href="#41899208">next</a><span>|</span><label class="collapse" for="c-41899917">[-]</label><label class="expand" for="c-41899917">[2 more]</label></div><br/><div class="children"><div class="content">Have you made any progress?</div><br/><div id="41901133" class="c"><input type="checkbox" id="c-41901133" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41898786">root</a><span>|</span><a href="#41899917">parent</a><span>|</span><a href="#41899208">next</a><span>|</span><label class="collapse" for="c-41901133">[-]</label><label class="expand" for="c-41901133">[1 more]</label></div><br/><div class="children"><div class="content">In theory, yes: I&#x27;ve used it to derive a (minor but accepted as published) patch to a Turing Award winner&#x27;s paper; in practice, no.<p>[the semantics haven&#x27;t changed much over the past years, but the syntax? even as a single person, who ought to be able to come up with a unified design, my different temporal instantiations <i>insist</i> on bike shedding]</div><br/></div></div></div></div></div></div></div></div><div id="41899208" class="c"><input type="checkbox" id="c-41899208" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#41898786">parent</a><span>|</span><a href="#41898886">prev</a><span>|</span><a href="#41899915">next</a><span>|</span><label class="collapse" for="c-41899208">[-]</label><label class="expand" for="c-41899208">[1 more]</label></div><br/><div class="children"><div class="content">It looks like it could be more concise sometimes. For instance, you could have this:<p><pre><code>  if f(x) is Some(a) and g(x, a) is Some(Right(b)) then h1(a, b) else h2(x)
</code></pre>
The equivalent pattern matching with a match expression in pseudo-ML:<p><pre><code>  match f(x) with
    None -&gt; h2(x)
    Some(a) -&gt;
      match g(x, a) with
        Some(Right(b)) -&gt; h1(a, b)
        _ -&gt; h2(x)</code></pre></div><br/></div></div></div></div><div id="41899915" class="c"><input type="checkbox" id="c-41899915" checked=""/><div class="controls bullet"><span class="by">breck</span><span>|</span><a href="#41898786">prev</a><span>|</span><label class="collapse" for="c-41899915">[-]</label><label class="expand" for="c-41899915">[1 more]</label></div><br/><div class="children"><div class="content">I love this.<p>Not the implementation, I think one could do better, but the fact that they identified an interesting opportunity: coming up with the Ultimate Conditional Syntax for pattern matching.<p>I would love to see them take one more crack at it, and this time try to think about how to reduce the syntax to the bare minimum.<p>Here&#x27;s my read&#x2F;adding of this language to PLDB: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UzsDaq0UdnM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UzsDaq0UdnM</a></div><br/></div></div></div></div></div></div></div></body></html>