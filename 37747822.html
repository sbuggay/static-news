<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696323664195" as="style"/><link rel="stylesheet" href="styles.css?v=1696323664195"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://viralinstruction.com/posts/hardware/">What scientists must know about hardware to write fast code (2020)</a>Â <span class="domain">(<a href="https://viralinstruction.com">viralinstruction.com</a>)</span></div><div class="subtext"><span>goerz</span> | <span>18 comments</span></div><br/><div><div id="37748394" class="c"><input type="checkbox" id="c-37748394" checked=""/><div class="controls bullet"><span class="by">havercosine</span><span>|</span><a href="#37749417">next</a><span>|</span><label class="collapse" for="c-37748394">[-]</label><label class="expand" for="c-37748394">[6 more]</label></div><br/><div class="children"><div class="content">Solid post. It also shows how powerful Julia is: allowing to operate at different levels of abstractions (down to seeing the assembly) using the same set of tools.</div><br/><div id="37749289" class="c"><input type="checkbox" id="c-37749289" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37748394">parent</a><span>|</span><a href="#37748835">next</a><span>|</span><label class="collapse" for="c-37749289">[-]</label><label class="expand" for="c-37749289">[1 more]</label></div><br/><div class="children"><div class="content">This was the premise of Lisp Machines, unfortunely the industry took another path.</div><br/></div></div><div id="37748835" class="c"><input type="checkbox" id="c-37748835" checked=""/><div class="controls bullet"><span class="by">th0ma5</span><span>|</span><a href="#37748394">parent</a><span>|</span><a href="#37749289">prev</a><span>|</span><a href="#37749417">next</a><span>|</span><label class="collapse" for="c-37748835">[-]</label><label class="expand" for="c-37748835">[4 more]</label></div><br/><div class="children"><div class="content">I feel the biggest misleading statements around Julia is that for true speed you can somehow ignore the lower abstractions, or that there is some kind of free lunch, but always what you gain in performance you&#x27;ll spend in development time. Julia has some neat tricks, but they are not generally and universally applicable at least not like other languages. I dunno. These arguments against Julia are many, but I&#x27;m still appalled they have so many handy wavy misleading statements in just their introductory text, I don&#x27;t think it be less than a decade before they recover.</div><br/><div id="37749000" class="c"><input type="checkbox" id="c-37749000" checked=""/><div class="controls bullet"><span class="by">jarvist</span><span>|</span><a href="#37748394">root</a><span>|</span><a href="#37748835">parent</a><span>|</span><a href="#37749417">next</a><span>|</span><label class="collapse" for="c-37749000">[-]</label><label class="expand" for="c-37749000">[3 more]</label></div><br/><div class="children"><div class="content">My experience is a first implementation &#x2F; novice programmer will write Julia code of a similar speed to python. But then an intermediate Julia programmer can adapt that same code to be of order C &#x2F; Fortran performance, without stopping the novice programmer from being able to work on the code base. So it&#x27;s this ability to iteratively improve and collaborate across very different skill sets that&#x27;s really important.<p>This is quite a different situation to traditional scientific computing.</div><br/><div id="37749252" class="c"><input type="checkbox" id="c-37749252" checked=""/><div class="controls bullet"><span class="by">reachtarunhere</span><span>|</span><a href="#37748394">root</a><span>|</span><a href="#37749000">parent</a><span>|</span><a href="#37749417">next</a><span>|</span><label class="collapse" for="c-37749252">[-]</label><label class="expand" for="c-37749252">[2 more]</label></div><br/><div class="children"><div class="content">&gt; My experience is a first implementation &#x2F; novice programmer will write Julia code of a similar speed to python.<p>No because of JIT compilation he would write code faster than Python by default. Now to truly rival optimized C++ code one has to do the tricks mentioned in this post like optimizing memory access, SIMD and maximizing instruction parallelism.<p>The key point is you are better off by default and can do some ugly stuff in the critical parts of the code while still using the same language.</div><br/><div id="37749290" class="c"><input type="checkbox" id="c-37749290" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#37748394">root</a><span>|</span><a href="#37749252">parent</a><span>|</span><a href="#37749417">next</a><span>|</span><label class="collapse" for="c-37749290">[-]</label><label class="expand" for="c-37749290">[1 more]</label></div><br/><div class="children"><div class="content">It really depends on what you end up doing. A lot of &quot;python&quot; code is really just thin wrappers around fairly optimized C routines (although there&#x27;s inefficiencies from the wrapper, and the optimization barriers), so if you&#x27;re doing something where the bulk of the work is happening inside those routines, beginner-written julia code will end up being roughly comparable to expert-written numpy code or whatever.<p>But yeah if you&#x27;re writing a loop or something else where the majority of work is actually being done by python itself, then it&#x27;s going to typically be much much slower than the equivalent julia code.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37749417" class="c"><input type="checkbox" id="c-37749417" checked=""/><div class="controls bullet"><span class="by">prhcbsc</span><span>|</span><a href="#37748394">prev</a><span>|</span><a href="#37748289">next</a><span>|</span><label class="collapse" for="c-37749417">[-]</label><label class="expand" for="c-37749417">[1 more]</label></div><br/><div class="children"><div class="content">adding onto multithreading, other parallelization models such as OpenMP or OMPSs take sequential code and parallelise it. They delegate onto a runtime system the efficient execution of the code to achieve a balance between programmers productivity and code performance.<p>But for large problems the article falls short. Scientific applications may need to use several computers at a time, COMP Superscalar (COMPSs) is a task-based programming model which aims to ease the development of applications for distributed infrastructures. COMPSs programmers do not need to deal with the typical duties of parallelization and distribution, such as thread creation and synchronization, data distribution, messaging or fault tolerance. Instead, the model is based on sequential programming, which makes it appealing to users that either lack parallel programming expertise or are looking for better programmability. Other popular frameworks such as LEGION offer a lower-level interface.</div><br/></div></div><div id="37748289" class="c"><input type="checkbox" id="c-37748289" checked=""/><div class="controls bullet"><span class="by">SinePost</span><span>|</span><a href="#37749417">prev</a><span>|</span><a href="#37748221">next</a><span>|</span><label class="collapse" for="c-37748289">[-]</label><label class="expand" for="c-37748289">[1 more]</label></div><br/><div class="children"><div class="content">It is quite refreshing to see software optimization be explained so simply and elegantly.</div><br/></div></div><div id="37748221" class="c"><input type="checkbox" id="c-37748221" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37748289">prev</a><span>|</span><a href="#37748188">next</a><span>|</span><label class="collapse" for="c-37748221">[-]</label><label class="expand" for="c-37748221">[3 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>What scientists must know about hardware to write fast code (2020)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29601342">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29601342</a> - Dec 2021 (29 comments)</div><br/><div id="37748404" class="c"><input type="checkbox" id="c-37748404" checked=""/><div class="controls bullet"><span class="by">kylepdm</span><span>|</span><a href="#37748221">parent</a><span>|</span><a href="#37748188">next</a><span>|</span><label class="collapse" for="c-37748404">[-]</label><label class="expand" for="c-37748404">[2 more]</label></div><br/><div class="children"><div class="content">FYI the underlying link in that previous discussion post seems to be defunct and kind of suspicious.</div><br/><div id="37749452" class="c"><input type="checkbox" id="c-37749452" checked=""/><div class="controls bullet"><span class="by">cpach</span><span>|</span><a href="#37748221">root</a><span>|</span><a href="#37748404">parent</a><span>|</span><a href="#37748188">next</a><span>|</span><label class="collapse" for="c-37749452">[-]</label><label class="expand" for="c-37749452">[1 more]</label></div><br/><div class="children"><div class="content">Looks like biojulia.net got taken over by spammers :(</div><br/></div></div></div></div></div></div><div id="37748188" class="c"><input type="checkbox" id="c-37748188" checked=""/><div class="controls bullet"><span class="by">jschveibinz</span><span>|</span><a href="#37748221">prev</a><span>|</span><label class="collapse" for="c-37748188">[-]</label><label class="expand" for="c-37748188">[6 more]</label></div><br/><div class="children"><div class="content">This subject is taught in undergrad computer architecture courses along with machine coding.  As an EE, I learned it in grad school.</div><br/><div id="37748238" class="c"><input type="checkbox" id="c-37748238" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#37748188">parent</a><span>|</span><a href="#37748225">next</a><span>|</span><label class="collapse" for="c-37748238">[-]</label><label class="expand" for="c-37748238">[4 more]</label></div><br/><div class="children"><div class="content">Congratulations. Studying one field means you know that field.<p>This link is not meant for you. It is meant for a scientist, and most scientists do not also have an EE degree or CS degree.<p>How much graduate level biology, oceanography, physics, geology, chemistry, meteorology, or other scientific field do you know?<p>All of those have subfields where computational performance is important. My experience is scientists are more likely to pick up the software skills than EEs are willing to pick up the science background. (In part because scientific software development generally pays less well than commercial software development.)</div><br/><div id="37748613" class="c"><input type="checkbox" id="c-37748613" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#37748188">root</a><span>|</span><a href="#37748238">parent</a><span>|</span><a href="#37748225">next</a><span>|</span><label class="collapse" for="c-37748613">[-]</label><label class="expand" for="c-37748613">[3 more]</label></div><br/><div class="children"><div class="content">Math was always a must for a scientist, todays computer science is also a must. The study programmes should reflect that.</div><br/><div id="37749113" class="c"><input type="checkbox" id="c-37749113" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#37748188">root</a><span>|</span><a href="#37748613">parent</a><span>|</span><a href="#37748874">next</a><span>|</span><label class="collapse" for="c-37749113">[-]</label><label class="expand" for="c-37749113">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Math&quot; is such a wide topic that you certainly must qualify your statement.<p>The standard entomologist curriculum  does not require calculus, while a physics curriculum does. Both produce scientists. (For example, <a href="https:&#x2F;&#x2F;cals.cornell.edu&#x2F;education&#x2F;degrees-programs&#x2F;entomology-major-minor" rel="nofollow noreferrer">https:&#x2F;&#x2F;cals.cornell.edu&#x2F;education&#x2F;degrees-programs&#x2F;entomolo...</a> under &quot;Major Requirements&quot; says &quot;One semester of college statistics or biometry&quot;, and the listed physics requirement doesn&#x27;t require calculus.)<p>On the other hand, an entomologist interested in population ecology may need to know differential equations.<p>Your use of &quot;study program&quot; suggests your experience is at the undergrad level, and not at the grad school level, which is how most scientists I know got their training.<p>At the undergrad level the study programs do reflect what&#x27;s needed for a solid education. If a student is interested in computational biology, that program will emphasize taking more CS courses than the program for a student interested in marine biology.<p>But at the grad level, the &quot;study program&quot; is much less formalized. You might take graduate level classes the first couple of years, but then you are expected to pick up the missing bits on your own.<p>Once you have your PhD and are a working scientist, you rarely have the luxury of following any study program.<p>And if you&#x27;ve been a scientist for 20 years, any CS training you had likely did not cover SIMD, and emphasized practices which are no longer relevant. (For example, the link points out &quot;That advice [about HDDs] is mostly outdated today [with SSDs]&quot;.)<p>Those latter categories are who the linked-to piece is for, not undergrads in a well-defined study program.</div><br/></div></div><div id="37748874" class="c"><input type="checkbox" id="c-37748874" checked=""/><div class="controls bullet"><span class="by">th0ma5</span><span>|</span><a href="#37748188">root</a><span>|</span><a href="#37748613">parent</a><span>|</span><a href="#37749113">prev</a><span>|</span><a href="#37748225">next</a><span>|</span><label class="collapse" for="c-37748874">[-]</label><label class="expand" for="c-37748874">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this sentiment, like the majority of CS people are telling statisticians that a lot of Julia remains a kind of snake oil or otherwise mystical thinking, it is very unfortunate. Even in the first page of the documentation &quot;No need to vectorize code for performance; devectorized code is fast&quot; is some kind of category error redefinition of how programming languages work in my opinion.</div><br/></div></div></div></div></div></div><div id="37748225" class="c"><input type="checkbox" id="c-37748225" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#37748188">parent</a><span>|</span><a href="#37748238">prev</a><span>|</span><label class="collapse" for="c-37748225">[-]</label><label class="expand" for="c-37748225">[1 more]</label></div><br/><div class="children"><div class="content">Not everyone does.</div><br/></div></div></div></div></div></div></div></div></div></body></html>