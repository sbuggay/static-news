<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721552453418" as="style"/><link rel="stylesheet" href="styles.css?v=1721552453418"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value">What to do if you don&#x27;t want a default constructor?</a> <span class="domain">(<a href="https://www.sandordargo.com">www.sandordargo.com</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>15 comments</span></div><br/><div><div id="41023484" class="c"><input type="checkbox" id="c-41023484" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41019413">next</a><span>|</span><label class="collapse" for="c-41023484">[-]</label><label class="expand" for="c-41023484">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never liked default constructors when it produces something that is not representable without executing code. D does not have default constructors. What one does is specify the statically initialized field values (or leave the fields to be set to their statically initialized value). I.e. it has a default initializer.<p>What this means in practice is one never is presented with an uninitialized or partially initialized struct. A non-default constructor gets handed a default initialized struct to start with. This makes for more reliable software. (Double initialization can be removed by the optimizer.)<p>Why D doesn&#x27;t have default constructors gets brought up now and then, as it is an unusual choice.</div><br/></div></div><div id="41019413" class="c"><input type="checkbox" id="c-41019413" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#41023484">prev</a><span>|</span><a href="#41021370">next</a><span>|</span><label class="collapse" for="c-41019413">[-]</label><label class="expand" for="c-41019413">[6 more]</label></div><br/><div class="children"><div class="content">It’s nice to make invalid states unrepresentable.  Unfortunately, you can’t do that in C++ if you have a move constructor.  C++ moves have to leave the source object in a valid state, since the object can still be accessed afterwards and will still have its destructor run.  But unless your move is really just a copy, that state has to be some kind of default, or at least semantically meaningless.  And if a valid but semantically meaningless state exists, arguably you might as well use it for the default constructor too.</div><br/><div id="41019592" class="c"><input type="checkbox" id="c-41019592" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41019413">parent</a><span>|</span><a href="#41019573">next</a><span>|</span><label class="collapse" for="c-41019592">[-]</label><label class="expand" for="c-41019592">[4 more]</label></div><br/><div class="children"><div class="content">I don’t think that argument holds much water.<p>A moved-from object needs to be in a valid state because the destructor will still run, and so that needs to succeed (and not UB).<p>Nobody ever says the moved-from state had to be useful or recoverable from.<p>Alternatively, you can remove support for moving. That way the moved-from issue disappears.</div><br/><div id="41019676" class="c"><input type="checkbox" id="c-41019676" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#41019413">root</a><span>|</span><a href="#41019592">parent</a><span>|</span><a href="#41019573">next</a><span>|</span><label class="collapse" for="c-41019676">[-]</label><label class="expand" for="c-41019676">[3 more]</label></div><br/><div class="children"><div class="content">The standard library types are guaranteed to be in a useful state after being moved from (the term &quot;valid state&quot; is used for this). Of course, that doesn&#x27;t mean that your own types have to, but the C++ Core Guidelines suggest doing so [1].<p>1: <a href="https:&#x2F;&#x2F;isocpp.github.io&#x2F;CppCoreGuidelines&#x2F;CppCoreGuidelines#Rc-move-semantic" rel="nofollow">https:&#x2F;&#x2F;isocpp.github.io&#x2F;CppCoreGuidelines&#x2F;CppCoreGuidelines...</a></div><br/><div id="41020109" class="c"><input type="checkbox" id="c-41020109" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41019413">root</a><span>|</span><a href="#41019676">parent</a><span>|</span><a href="#41019573">next</a><span>|</span><label class="collapse" for="c-41020109">[-]</label><label class="expand" for="c-41020109">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I would say that &quot;valid&quot; and &quot;useful&quot; are the same. Things that must be safe after moving: destructing, assigning. No other operation need make sense.<p>It sucks that C++ can&#x27;t enforce &quot;don&#x27;t use struct after moving&quot;. It&#x27;s definitely a wart, of which C++ has no shortage. But you can still get away with no default constructor and not having to sprinkle a kajillion &quot;isUseful&quot; checks around your codebase.<p>Code can assume the struct is useful. The case where it&#x27;s not is rare and <i>probably</i> won&#x27;t ever come up. Such is life when writing C++!</div><br/><div id="41020532" class="c"><input type="checkbox" id="c-41020532" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#41019413">root</a><span>|</span><a href="#41020109">parent</a><span>|</span><a href="#41019573">next</a><span>|</span><label class="collapse" for="c-41020532">[-]</label><label class="expand" for="c-41020532">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure I would say that &quot;valid&quot; and &quot;useful&quot; are the same.<p>In standardese, they are: an object in a &quot;valid but unspecified state&quot; requires &quot;that the object’s invariants are met and operations on the object behave as specified for its type&quot;[1]. In other words, any operation without preconditions may be performed.<p>&gt; Things that must be safe after moving: destructing, assigning. No other operation need make sense.<p>That&#x27;s not accurate <i>for standard library types</i>: moved-from objects must be in a &quot;valid but unspecified state&quot;[2].<p>1: C++23 working draft, 3.66 valid but unspecified state [defns.valid]<p>2: C++23 working draft, 16.4.6.15 Moved-from state of library types [lib.types.movedfrom]</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41021370" class="c"><input type="checkbox" id="c-41021370" checked=""/><div class="controls bullet"><span class="by">advael</span><span>|</span><a href="#41019413">prev</a><span>|</span><a href="#41019977">next</a><span>|</span><label class="collapse" for="c-41021370">[-]</label><label class="expand" for="c-41021370">[3 more]</label></div><br/><div class="children"><div class="content">A pattern I&#x27;ve seen some people do is to just make an operator bool for the type that checks for a contextually-sensical invalid state that is also the default constructed state. This is absolutely a hack, and has lots of other implications, and I wouldn&#x27;t recommend it, but I see why people do it, because it creates a low-overhead way of getting around the possibility of invalid stuff while not taking on the problems of lacking a default constructor<p>Personally, I like the simplicity of this kind of approach, but prefer to force consumers of the type to be more explicit. To that end, I really like having an constexpr bool operator! instead, so the same checks can be performed without making it easy to accidentally coerce your type into some shady arithmetic operations. You still can if you meant to, but it will be more obvious what you&#x27;re doing and won&#x27;t happen accidentally</div><br/><div id="41021567" class="c"><input type="checkbox" id="c-41021567" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#41021370">parent</a><span>|</span><a href="#41019977">next</a><span>|</span><label class="collapse" for="c-41021567">[-]</label><label class="expand" for="c-41021567">[2 more]</label></div><br/><div class="children"><div class="content">I’m not sure I follow entirely, but an explicit operator bool will only auto-convert in contexts where it makes sense, and not e.g. in arithemtic expressions.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;39995573&#x2F;when-can-i-use-explicit-operator-bool-without-a-cast" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;39995573&#x2F;when-can-i-use-...</a></div><br/><div id="41022011" class="c"><input type="checkbox" id="c-41022011" checked=""/><div class="controls bullet"><span class="by">advael</span><span>|</span><a href="#41021370">root</a><span>|</span><a href="#41021567">parent</a><span>|</span><a href="#41019977">next</a><span>|</span><label class="collapse" for="c-41022011">[-]</label><label class="expand" for="c-41022011">[1 more]</label></div><br/><div class="children"><div class="content">Explicit keyword seems reasonable too, I just like !! more than the verbosity of casting tbh. Totally aesthetic preference</div><br/></div></div></div></div></div></div><div id="41019977" class="c"><input type="checkbox" id="c-41019977" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#41021370">prev</a><span>|</span><a href="#41019671">next</a><span>|</span><label class="collapse" for="c-41019977">[-]</label><label class="expand" for="c-41019977">[2 more]</label></div><br/><div class="children"><div class="content">operator&lt;=&gt; was new to me.  It&#x27;s the three-way comparison operator.<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;operator_comparison#Three-way_comparison" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;operator_comparis...</a></div><br/><div id="41020180" class="c"><input type="checkbox" id="c-41020180" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#41019977">parent</a><span>|</span><a href="#41019671">next</a><span>|</span><label class="collapse" for="c-41020180">[-]</label><label class="expand" for="c-41020180">[1 more]</label></div><br/><div class="children"><div class="content">aka the spaceship operator. By defining just the spaceship operator for some types A and B, the compiler can synthesize overloads for the typical comparison operators like &lt; &lt;= == &gt;= &gt; for A vs B and B vs A.</div><br/></div></div></div></div><div id="41019847" class="c"><input type="checkbox" id="c-41019847" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#41019671">prev</a><span>|</span><label class="collapse" for="c-41019847">[-]</label><label class="expand" for="c-41019847">[1 more]</label></div><br/><div class="children"><div class="content">-O7 ?</div><br/></div></div></div></div></div></div></div></body></html>