<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715936463905" as="style"/><link rel="stylesheet" href="styles.css?v=1715936463905"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.tfeb.org/fragments/2024/05/15/an-iteration-construct-for-common-lisp/">Štar: an iteration construct for Common Lisp</a> <span class="domain">(<a href="https://www.tfeb.org">www.tfeb.org</a>)</span></div><div class="subtext"><span>Tomte</span> | <span>27 comments</span></div><br/><div><div id="40387763" class="c"><input type="checkbox" id="c-40387763" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#40383277">next</a><span>|</span><label class="collapse" for="c-40387763">[-]</label><label class="expand" for="c-40387763">[1 more]</label></div><br/><div class="children"><div class="content">A few remarks:<p>* Syntactic sugar for nested loops is welcome!<p>* I would have preferred a comparison with <a href="https:&#x2F;&#x2F;github.com&#x2F;Shinmera&#x2F;for&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;Shinmera&#x2F;for&#x2F;</a>, as it&#x27;s nearer in concept than loop&#x2F;iterate.<p>* Eschewing collection is a mistake in my opinion. Yes, you can do your own with (final), but it&#x27;ll be verbose.<p>As other said, it&#x27;s a very Scheme-y vision of looping, which has simplicity&#x2F;purity&#x2F;explicitness advantages but lacks in pragmatism. Personally, I firmly stay in the iterate team, even with its issues.</div><br/></div></div><div id="40383277" class="c"><input type="checkbox" id="c-40383277" checked=""/><div class="controls bullet"><span class="by">EdwardCoffin</span><span>|</span><a href="#40387763">prev</a><span>|</span><a href="#40382985">next</a><span>|</span><label class="collapse" for="c-40383277">[-]</label><label class="expand" for="c-40383277">[1 more]</label></div><br/><div class="children"><div class="content">A couple of years ago I finally started to understand the Waters series facility [1], which was offered as an alternative to Loop.  It&#x27;s a bit finicky, and the error messages are often mystifying, but I have come to quite like it for some more complicated looping situations.  The thing that finally made it accessible to me was a blog post by Joe Marshall, <i>Series tips and tricks</i> [2]<p>Ironically enough, once my use of it advanced enough, I found myself writing <i>producing</i> forms which are just a restricted form of Loop invocation - Series turns out to compile down to Loop.  It&#x27;s just that I (and others, apparently) find Series expressions more pleasant to deal with than Loop expressions.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node347.html#SECTION003400000000000000000" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node347.html#...</a><p>[2] <a href="http:&#x2F;&#x2F;funcall.blogspot.com&#x2F;2022&#x2F;07&#x2F;series-tips-and-tricks.html" rel="nofollow">http:&#x2F;&#x2F;funcall.blogspot.com&#x2F;2022&#x2F;07&#x2F;series-tips-and-tricks.h...</a></div><br/></div></div><div id="40382985" class="c"><input type="checkbox" id="c-40382985" checked=""/><div class="controls bullet"><span class="by">nescioquid</span><span>|</span><a href="#40383277">prev</a><span>|</span><a href="#40387463">next</a><span>|</span><label class="collapse" for="c-40382985">[-]</label><label class="expand" for="c-40382985">[5 more]</label></div><br/><div class="children"><div class="content">I shared the urge to avoid loop until I read Pascal Costanza&#x27;s Highly Opinionated Guide to Lisp[1]<p>&gt;&gt; Seemingly, the intended way to use the LOOP facility is to just &quot;guess&quot; a way to express an iteration and see if it works. If it doesn&#x27;t you can either look up the specifics ...<p>Since then, I do just guess at the syntax and it strangely does what I want most of the time.<p>It seems that a library like this has a lot to prove because a) it doesn&#x27;t provide a new capability, b) it adds a project dependency, and c) creates yet another way to do a standard task. If you really don&#x27;t like the loop macro, you probably don&#x27;t need much persuading, but I would have liked to have seen more discussion on the these trade-offs.<p>[1] <a href="http:&#x2F;&#x2F;www.p-cos.net&#x2F;lisp&#x2F;guide-v1.html" rel="nofollow">http:&#x2F;&#x2F;www.p-cos.net&#x2F;lisp&#x2F;guide-v1.html</a></div><br/><div id="40383903" class="c"><input type="checkbox" id="c-40383903" checked=""/><div class="controls bullet"><span class="by">azeirah</span><span>|</span><a href="#40382985">parent</a><span>|</span><a href="#40387463">next</a><span>|</span><label class="collapse" for="c-40383903">[-]</label><label class="expand" for="c-40383903">[4 more]</label></div><br/><div class="children"><div class="content">Huh, this is such an unusual design goal in programming languages &quot;just try something and it&#x27;ll probably work&quot;<p>Only css is done this way... but not even intentionally</div><br/><div id="40384137" class="c"><input type="checkbox" id="c-40384137" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40382985">root</a><span>|</span><a href="#40383903">parent</a><span>|</span><a href="#40386064">next</a><span>|</span><label class="collapse" for="c-40384137">[-]</label><label class="expand" for="c-40384137">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the design goal, it&#x27;s more a &quot;haha but kind a true&quot; thing.<p><a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node235.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;Groups&#x2F;AI&#x2F;html&#x2F;cltl&#x2F;clm&#x2F;node235.html</a><p>The grammar for what&#x27;s accepted by Loop is well specified, but the results also read very clearly. Once you learn a few of them, you start to understand how the rest would be written and can guess, but the design is not that you would guess.</div><br/></div></div><div id="40386064" class="c"><input type="checkbox" id="c-40386064" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40382985">root</a><span>|</span><a href="#40383903">parent</a><span>|</span><a href="#40384137">prev</a><span>|</span><a href="#40384553">next</a><span>|</span><label class="collapse" for="c-40386064">[-]</label><label class="expand" for="c-40386064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Huh, this is such an unusual design goal in programming languages &quot;just try something and it&#x27;ll probably work&quot;<p>Perl was famously that way. It&#x27;s great for the initial write but not so good for maintenance.</div><br/></div></div><div id="40384553" class="c"><input type="checkbox" id="c-40384553" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#40382985">root</a><span>|</span><a href="#40383903">parent</a><span>|</span><a href="#40386064">prev</a><span>|</span><a href="#40387463">next</a><span>|</span><label class="collapse" for="c-40384553">[-]</label><label class="expand" for="c-40384553">[1 more]</label></div><br/><div class="children"><div class="content">Haskell works like this: if you can manage to make it compile, it&#x27;ll work the first time.  Might leak gigs of space too, but it&#x27;ll work.</div><br/></div></div></div></div></div></div><div id="40387463" class="c"><input type="checkbox" id="c-40387463" checked=""/><div class="controls bullet"><span class="by">vindarel</span><span>|</span><a href="#40382985">prev</a><span>|</span><a href="#40384676">next</a><span>|</span><label class="collapse" for="c-40387463">[-]</label><label class="expand" for="c-40387463">[1 more]</label></div><br/><div class="children"><div class="content">Learn iteration here :] <a href="https:&#x2F;&#x2F;lispcookbook.github.io&#x2F;cl-cookbook&#x2F;iteration.html" rel="nofollow">https:&#x2F;&#x2F;lispcookbook.github.io&#x2F;cl-cookbook&#x2F;iteration.html</a> loop, transducers and friends.</div><br/></div></div><div id="40384676" class="c"><input type="checkbox" id="c-40384676" checked=""/><div class="controls bullet"><span class="by">metroholografix</span><span>|</span><a href="#40387463">prev</a><span>|</span><a href="#40386530">next</a><span>|</span><label class="collapse" for="c-40384676">[-]</label><label class="expand" for="c-40384676">[8 more]</label></div><br/><div class="children"><div class="content">Loop works well, is widely used, also available in Emacs Lisp and comes with zero dependencies. For these reasons, I don&#x27;t see this gaining much traction.<p>Anecdote: In almost 20 years of CL usage, I&#x27;ve never needed an extensible iteration construct. I also find &#x27;loop&#x27; a lot more readable than &#x27;iterate&#x27; [1], another fad that has come and gone.<p>[1] <a href="https:&#x2F;&#x2F;iterate.common-lisp.dev" rel="nofollow">https:&#x2F;&#x2F;iterate.common-lisp.dev</a></div><br/><div id="40387716" class="c"><input type="checkbox" id="c-40387716" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#40384676">parent</a><span>|</span><a href="#40385084">next</a><span>|</span><label class="collapse" for="c-40387716">[-]</label><label class="expand" for="c-40387716">[1 more]</label></div><br/><div class="children"><div class="content">I find iterate much better on the other hand. Especially the part where I don&#x27;t have to use :do to switch back to CL syntax and I can use the usual nested if else without having to remember the :end&#x2F;:then stuff.</div><br/></div></div><div id="40385084" class="c"><input type="checkbox" id="c-40385084" checked=""/><div class="controls bullet"><span class="by">phforms</span><span>|</span><a href="#40384676">parent</a><span>|</span><a href="#40387716">prev</a><span>|</span><a href="#40386402">next</a><span>|</span><label class="collapse" for="c-40385084">[-]</label><label class="expand" for="c-40385084">[3 more]</label></div><br/><div class="children"><div class="content">TIL that there is a whole package for “Common Lisp Emulation”[1] in Emacs that adds functions and control structures from CL “to make Emacs Lisp programming significantly more convenient”. Never developed a package for Emacs myself, but I feel like this can be of great help if I ever wanted to.<p>I know that there are projects like Lem[2] that try to build some kind of editor (Emacs-like, I guess) on top of CL, which made me wonder if we would have a CL-based Emacs today if it would have been standardized by the time and if this would have been a better choice than creating a custom dialect.<p>[1]: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;cl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs&#x2F;manual&#x2F;html_node&#x2F;cl&#x2F;</a> (C-h R &quot;cl&quot; in Emacs)<p>[2]: <a href="https:&#x2F;&#x2F;lem-project.github.io" rel="nofollow">https:&#x2F;&#x2F;lem-project.github.io</a></div><br/><div id="40385271" class="c"><input type="checkbox" id="c-40385271" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#40384676">root</a><span>|</span><a href="#40385084">parent</a><span>|</span><a href="#40386402">next</a><span>|</span><label class="collapse" for="c-40385271">[-]</label><label class="expand" for="c-40385271">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say that lem <i>is</i> an emacs. Emacs is a genus, not a species. Before GNU Emacs (&amp; XEmacs) there were others. And I&#x27;d classify lem as another.</div><br/><div id="40386800" class="c"><input type="checkbox" id="c-40386800" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40384676">root</a><span>|</span><a href="#40385271">parent</a><span>|</span><a href="#40386402">next</a><span>|</span><label class="collapse" for="c-40386800">[-]</label><label class="expand" for="c-40386800">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say that lem is an emacs. Emacs is a genus, not a species.<p>The question is what makes this species.<p>For example see <a href="https:&#x2F;&#x2F;www.finseth.com&#x2F;craft&#x2F;#c10.1" rel="nofollow">https:&#x2F;&#x2F;www.finseth.com&#x2F;craft&#x2F;#c10.1</a><p>It&#x27;s the command set (key bindings, extended commands, ...), buffers with modes and minor modes, the user interface for buffers, marks, the &quot;cursor&quot;, extensibility, ...<p>For example in a typical Emacs the &quot;cursor&quot; &#x2F; current mark is always visible, even in GUI versions. This is very different from other editors, where the current cursor can be non visible.<p>Basically there are a lot of similarities between the early Emacs editors (EMACS, EINE&#x2F;ZWEI&#x2F;ZMACS, Multics Emacs, ... and others).<p>Does LEM try to be similar to an EMACS editor or is it only emulating one on demand?<p>GNU Emacs use might also think of Emacs Lisp as an extension language, a GUI version, menubars with menus, self-documentation, ...</div><br/></div></div></div></div></div></div><div id="40386402" class="c"><input type="checkbox" id="c-40386402" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#40384676">parent</a><span>|</span><a href="#40385084">prev</a><span>|</span><a href="#40386530">next</a><span>|</span><label class="collapse" for="c-40386402">[-]</label><label class="expand" for="c-40386402">[3 more]</label></div><br/><div class="children"><div class="content">In what sense is iterate a fad that was gone? I see 1161 systems in Quicklisp (out of 5499 total) that transitively depend on iterate; so about a fifth of the open-source ecosystem.</div><br/><div id="40386541" class="c"><input type="checkbox" id="c-40386541" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40384676">root</a><span>|</span><a href="#40386402">parent</a><span>|</span><a href="#40386530">next</a><span>|</span><label class="collapse" for="c-40386541">[-]</label><label class="expand" for="c-40386541">[2 more]</label></div><br/><div class="children"><div class="content">Transitive dependencies are a poor indicator of actual utilization. How many direct dependencies are there?<p>For what it&#x27;s worth, I quit using it since it broke if you ever used the CL function `count` inside an iterate construct. Reportedly it was fixed, but it&#x27;s still failing to work correctly using the Quicklisp version (just installed CL on and setup QL since it&#x27;s a new laptop, so it shouldn&#x27;t be pulling an old version). It was fun for a while, but having to remember &quot;Oh yeah, don&#x27;t use count&quot; every time I reached for it for something natural was annoying and not worth bothering with.</div><br/><div id="40386819" class="c"><input type="checkbox" id="c-40386819" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#40384676">root</a><span>|</span><a href="#40386541">parent</a><span>|</span><a href="#40386530">next</a><span>|</span><label class="collapse" for="c-40386819">[-]</label><label class="expand" for="c-40386819">[1 more]</label></div><br/><div class="children"><div class="content">It has 201 direct dependencies, making it the 9th most directly-depended-on system in Quicklisp, one spot ahead of UIOP.<p>Methodology (yes, I could&#x27;ve stayed in Lisp, but I started by awking systems.txt...):<p><pre><code>    (with-open-file (*standard-output* #p&quot;deps.txt&quot; :direction :output)
      (iter
        (for system in (ql:provided-systems t))
        (for name = (ql::name system))
        (format t &quot;~a ~a~%&quot; (length (ql:who-depends-on name)) name)))

    $ sort -h deps.txt | tail
    200 uiop
    201 iterate
    206 split-sequence
    274 closer-mop
    344 cl-glfw-opengl-core
    350 bordeaux-threads
    387 fiveam
    391 cffi
    408 cl-ppcre
    1006 alexandria</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="40386530" class="c"><input type="checkbox" id="c-40386530" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40384676">prev</a><span>|</span><a href="#40384379">next</a><span>|</span><label class="collapse" for="c-40386530">[-]</label><label class="expand" for="c-40386530">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t lisp, but `in-iterators` is badly named unless there&#x27;s precedent elsewhere in the lisp community. I initially expected it to implement (Cartesian) `product` rather than what&#x27;s usually called `chain` (though admittedly the former is less useful in a language where `for*` is directly possible). Note that `product` really needs optimizations depending on whether its inner iterators can be trusted to be repeatable or not.<p>I also find it a bit fragile for iterator implementations to use 2 functions, rather than a single function returning `value | unique-end-of-iterator-sentinel` (there are at least 3 obvious ways to lay this out such that there are no values an iterator cannot produce).</div><br/><div id="40386654" class="c"><input type="checkbox" id="c-40386654" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#40386530">parent</a><span>|</span><a href="#40384379">next</a><span>|</span><label class="collapse" for="c-40386654">[-]</label><label class="expand" for="c-40386654">[1 more]</label></div><br/><div class="children"><div class="content">It looks to be heavily influenced by Racket&#x27;s for loops and sequences; what this calls `in-iterators` is `in-sequences` in Racket.</div><br/></div></div></div></div><div id="40384379" class="c"><input type="checkbox" id="c-40384379" checked=""/><div class="controls bullet"><span class="by">brandonbloom</span><span>|</span><a href="#40386530">prev</a><span>|</span><a href="#40386070">next</a><span>|</span><label class="collapse" for="c-40384379">[-]</label><label class="expand" for="c-40384379">[1 more]</label></div><br/><div class="children"><div class="content">Nice! Looks like most modern list-comprehension syntaxes.<p>&gt; iteration and value accumulation are orthogonal problems which should be solved by orthogonal constructs<p>This is also covered to an extent by &quot;Why Functional Programming Matters&quot; in the discussion of laziness: <a href="https:&#x2F;&#x2F;www.cs.kent.ac.uk&#x2F;people&#x2F;staff&#x2F;dat&#x2F;miranda&#x2F;whyfp90.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.kent.ac.uk&#x2F;people&#x2F;staff&#x2F;dat&#x2F;miranda&#x2F;whyfp90.p...</a><p>For a direct comparison of combining this syntax with &quot;accumulation&quot; into a lazy sequence, see Clojure&#x27;s `for` macro:<p><a href="https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;for" rel="nofollow">https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;for</a></div><br/></div></div><div id="40386070" class="c"><input type="checkbox" id="c-40386070" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#40384379">prev</a><span>|</span><a href="#40383653">next</a><span>|</span><label class="collapse" for="c-40386070">[-]</label><label class="expand" for="c-40386070">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Similarly, Štar doesn’t contain a mass of syntax letting you select only certain values, or allowing you to terminate iteration early: you don’t write<p>&gt; (loop for x in l while (numberp x) do ...)<p>&gt; Instead you write<p>&gt; (for ((x (in-list l)))<p>&gt;   (unless (numberp x) (final))<p>&gt;   ...)<p>While loop has arcane grammar and can be hard to <i>write</i> correctly, it will be <i>read</i> many more times and so I think is preferable to the latter.</div><br/><div id="40386853" class="c"><input type="checkbox" id="c-40386853" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40386070">parent</a><span>|</span><a href="#40383653">next</a><span>|</span><label class="collapse" for="c-40386853">[-]</label><label class="expand" for="c-40386853">[1 more]</label></div><br/><div class="children"><div class="content">For a Lisp user the s-expression variant would be more useful, because it is easier to write and read. It also helps that it is easier to indent &#x2F; pretty print, because the usual pretty printer algorithms can be used. For LOOP one would need an indent &#x2F; pretty printer with either some heuristics and&#x2F;or knowledge of LOOP grammar.<p>Personally I use LOOP because it is built in. But generally I prefer something like ITERATE, which is similar powerful but fits better into the host language (-&gt; Common Lisp).</div><br/></div></div></div></div><div id="40383653" class="c"><input type="checkbox" id="c-40383653" checked=""/><div class="controls bullet"><span class="by">drbig</span><span>|</span><a href="#40386070">prev</a><span>|</span><a href="#40383820">next</a><span>|</span><label class="collapse" for="c-40383653">[-]</label><label class="expand" for="c-40383653">[2 more]</label></div><br/><div class="children"><div class="content">```
It also has no inherent knowledge about how to iterate over any particular structure: it doesn’t know how to iterate over lists, or ranges of numbers. Rather it knows that iterating has to answer two questions:<p><pre><code>    is there more?
    what is the next thing?
</code></pre>
In addition it knows how to ask another question:<p><pre><code>    is there any information I can use to make asking the first two questions faster?</code></pre>
```<p>This approach sounds so good. Focus on what is needed to solve the main task. Don&#x27;t do less, but please don&#x27;t do more. And... Do Not Assume.</div><br/><div id="40384796" class="c"><input type="checkbox" id="c-40384796" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40383653">parent</a><span>|</span><a href="#40383820">next</a><span>|</span><label class="collapse" for="c-40384796">[-]</label><label class="expand" for="c-40384796">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and that&#x27;s why Java and C# use pretty much this exact approach (without the acceleration part, to be fair) for their Iterator&#x2F;IEnumerator that power their for-each loops.</div><br/></div></div></div></div><div id="40383820" class="c"><input type="checkbox" id="c-40383820" checked=""/><div class="controls bullet"><span class="by">swah</span><span>|</span><a href="#40383653">prev</a><span>|</span><a href="#40382884">next</a><span>|</span><label class="collapse" for="c-40383820">[-]</label><label class="expand" for="c-40383820">[1 more]</label></div><br/><div class="children"><div class="content">I tried to clean the dirt on top of the Š with my finger..</div><br/></div></div><div id="40382884" class="c"><input type="checkbox" id="c-40382884" checked=""/><div class="controls bullet"><span class="by">13415</span><span>|</span><a href="#40383820">prev</a><span>|</span><a href="#40382886">next</a><span>|</span><label class="collapse" for="c-40382884">[-]</label><label class="expand" for="c-40382884">[1 more]</label></div><br/><div class="children"><div class="content">Looks similar to the Racket for macros. I like it.</div><br/></div></div><div id="40382886" class="c"><input type="checkbox" id="c-40382886" checked=""/><div class="controls bullet"><span class="by">mtreis86</span><span>|</span><a href="#40382884">prev</a><span>|</span><label class="collapse" for="c-40382886">[-]</label><label class="expand" for="c-40382886">[1 more]</label></div><br/><div class="children"><div class="content">Which compiler was used for the benchmarks?</div><br/></div></div></div></div></div></div></div></body></html>