<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724230876544" as="style"/><link rel="stylesheet" href="styles.css?v=1724230876544"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.craigkerstiens.com/2013/11/18/best-postgres-feature-youre-not-using/">Postgres feature you&#x27;re not using – CTEs a.k.a. WITH clauses</a> <span class="domain">(<a href="https://www.craigkerstiens.com">www.craigkerstiens.com</a>)</span></div><div class="subtext"><span>plaur782</span> | <span>24 comments</span></div><br/><div><div id="41272598" class="c"><input type="checkbox" id="c-41272598" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#41307999">next</a><span>|</span><label class="collapse" for="c-41272598">[-]</label><label class="expand" for="c-41272598">[4 more]</label></div><br/><div class="children"><div class="content">&gt; CTEs won’t always be quite as performant as optimizing your SQL to be as concise as possible. In most cases I have seen performance differences smaller than a 2X difference, this tradeoff for readability is a nobrainer as far as I’m concerned. And with time the Postgres optimizer should continue to get better about such performance.<p>So, my knowledge here might be out of date, but this behavior isn&#x27;t &quot;the optimizer isn&#x27;t smart enough&quot;: using a CTE in PostgreSQL causes an explicit boundary in the optimizer which prevents some optimizations from being performed. In some cases you really need&#x2F;want this behavior, and it might increase the performance of your query; in other cases, this is the last thing you would want. People keep asking for optimizer hints, which PostgreSQL refuses to add, and yet they leave this quirk in explicitly as an escape hatch.</div><br/><div id="41272749" class="c"><input type="checkbox" id="c-41272749" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#41272598">parent</a><span>|</span><a href="#41307999">next</a><span>|</span><label class="collapse" for="c-41272749">[-]</label><label class="expand" for="c-41272749">[3 more]</label></div><br/><div class="children"><div class="content">This changed in pg 12.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;release&#x2F;12.0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;release&#x2F;12.0&#x2F;</a> : Automatic (but overridable) inlining of common table expressions (CTEs)</div><br/><div id="41273396" class="c"><input type="checkbox" id="c-41273396" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#41272598">root</a><span>|</span><a href="#41272749">parent</a><span>|</span><a href="#41307999">next</a><span>|</span><label class="collapse" for="c-41273396">[-]</label><label class="expand" for="c-41273396">[2 more]</label></div><br/><div class="children"><div class="content">Yep, it&#x27;s a huge improvement for complicated pipelines.<p>One thing to be aware of is &quot;NOT MATERIALIZED&quot;. Here&#x27;s what the docs say:<p>A useful property of WITH queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling WITH queries. Thus, expensive calculations that are needed in multiple places can be placed within a WITH query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced WITH query, since that might affect all uses of the WITH query&#x27;s output when it should affect only one. The multiply-referenced WITH query will be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)<p>However, if a WITH query is non-recursive and side-effect-free (that is, it is a SELECT containing no volatile functions) then it can be folded into the parent query, allowing joint optimization of the two query levels. By default, this happens if the parent query references the WITH query just once, but not if it references the WITH query more than once. You can override that decision by specifying MATERIALIZED to force separate calculation of the WITH query, or by specifying NOT MATERIALIZED to force it to be merged into the parent query. The latter choice risks duplicate computation of the WITH query, but it can still give a net savings if each usage of the WITH query needs only a small part of the WITH query&#x27;s full output.</div><br/><div id="41307905" class="c"><input type="checkbox" id="c-41307905" checked=""/><div class="controls bullet"><span class="by">silon42</span><span>|</span><a href="#41272598">root</a><span>|</span><a href="#41273396">parent</a><span>|</span><a href="#41307999">next</a><span>|</span><label class="collapse" for="c-41307905">[-]</label><label class="expand" for="c-41307905">[1 more]</label></div><br/><div class="children"><div class="content">Any issues with recursive and NOT MATERIALIZED? Recursive is pretty much the reason to use CTEs for me and NOT MATERIALIZED is essential there in most cases.</div><br/></div></div></div></div></div></div></div></div><div id="41307999" class="c"><input type="checkbox" id="c-41307999" checked=""/><div class="controls bullet"><span class="by">larodi</span><span>|</span><a href="#41272598">prev</a><span>|</span><a href="#41308161">next</a><span>|</span><label class="collapse" for="c-41307999">[-]</label><label class="expand" for="c-41307999">[1 more]</label></div><br/><div class="children"><div class="content">I sure do use them for many years now, my girlfriend now uses them and loves them, my topcoder friend eventually started using them 10 years ago.<p>So, no, we are using them , but y’all know what ? Unless recursive they are really nothing so special…</div><br/></div></div><div id="41308161" class="c"><input type="checkbox" id="c-41308161" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#41307999">prev</a><span>|</span><a href="#41272984">next</a><span>|</span><label class="collapse" for="c-41308161">[-]</label><label class="expand" for="c-41308161">[2 more]</label></div><br/><div class="children"><div class="content">&gt;The general idea is that it allows you to create something somewhat equivilant to a view that only exists during that transaction.<p>I can&#x27;t talk for Postgres but on MS SQL it&#x27;s definitely not like a view.<p>I had a CTE with a filter condition in the where close but got a conversion error in the later use for a value I already filtered out in the CTE.<p>So it may look like some kind of temporary view definition but the actual code the optimizer generates may behave unexpected.</div><br/><div id="41308253" class="c"><input type="checkbox" id="c-41308253" checked=""/><div class="controls bullet"><span class="by">ibejoeb</span><span>|</span><a href="#41308161">parent</a><span>|</span><a href="#41272984">next</a><span>|</span><label class="collapse" for="c-41308253">[-]</label><label class="expand" for="c-41308253">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m all but certain that a CTE and an unindexed view are treated identically in the planning phase.<p>You&#x27;re describing predicate pushdown, which can get hung up under certain conditions, like when using window functions or top. If I had to take a shot in the dark, you were dealing with something like that.</div><br/></div></div></div></div><div id="41272984" class="c"><input type="checkbox" id="c-41272984" checked=""/><div class="controls bullet"><span class="by">muhrizqiardi</span><span>|</span><a href="#41308161">prev</a><span>|</span><a href="#41307377">next</a><span>|</span><label class="collapse" for="c-41272984">[-]</label><label class="expand" for="c-41272984">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not using? I&#x27;m using that feature almost all the time!</div><br/><div id="41307825" class="c"><input type="checkbox" id="c-41307825" checked=""/><div class="controls bullet"><span class="by">mosselman</span><span>|</span><a href="#41272984">parent</a><span>|</span><a href="#41307562">next</a><span>|</span><label class="collapse" for="c-41307825">[-]</label><label class="expand" for="c-41307825">[1 more]</label></div><br/><div class="children"><div class="content">Postgres feature you aren’t using: SELECT</div><br/></div></div><div id="41307562" class="c"><input type="checkbox" id="c-41307562" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#41272984">parent</a><span>|</span><a href="#41307825">prev</a><span>|</span><a href="#41307377">next</a><span>|</span><label class="collapse" for="c-41307562">[-]</label><label class="expand" for="c-41307562">[1 more]</label></div><br/><div class="children"><div class="content">This post was written for juniors</div><br/></div></div></div></div><div id="41307377" class="c"><input type="checkbox" id="c-41307377" checked=""/><div class="controls bullet"><span class="by">dveeden2</span><span>|</span><a href="#41272984">prev</a><span>|</span><a href="#41274705">next</a><span>|</span><label class="collapse" for="c-41307377">[-]</label><label class="expand" for="c-41307377">[1 more]</label></div><br/><div class="children"><div class="content">The good thing here is that other databases like MySQL, TiDB, SQLite etc also support this. so this. And even recursive CTEs are well supported.<p><a href="https:&#x2F;&#x2F;modern-sql.com&#x2F;caniuse&#x2F;with_(non-recursive,_top_level)" rel="nofollow">https:&#x2F;&#x2F;modern-sql.com&#x2F;caniuse&#x2F;with_(non-recursive,_top_leve...</a></div><br/></div></div><div id="41274705" class="c"><input type="checkbox" id="c-41274705" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41307377">prev</a><span>|</span><a href="#41308018">next</a><span>|</span><label class="collapse" for="c-41274705">[-]</label><label class="expand" for="c-41274705">[2 more]</label></div><br/><div class="children"><div class="content">Used judiciously, a macro system in front of your SQL is often a good approach here. You gain the &quot;linguistically common subtable&quot; capabilities of a CTE, the ability to name constants, and the ability to name&#x2F;parameterize common sub-expressions, even in databases not supporting CTEs. With LSP support being what it is, you can even whip up editor integration for your new language in a day or less.<p>Compared to CTEs (assuming you&#x27;re not using recursion and don&#x27;t _want_ the materialization), that extra syntactic sugar helps with readability, and the &quot;macro&quot; nature of the thing ensures you don&#x27;t have any slowdowns from running the thing due to a different query plan.<p>Downsides include the ability for juniors to turn your SQL into an awful mess, the fact that you&#x27;ll still occasionally _want_ materialized CTEs for performance and have to write them anyway, plus if you implement it wrong you&#x27;ll have runtime overhead and very few introspection capabilities (the simplest version I&#x27;ve seen that&#x27;s decent to work with is creating SQL files as artifacts from the templates using the build system, obviously depending on how much of a rube goldberg your particular builds are).</div><br/><div id="41308061" class="c"><input type="checkbox" id="c-41308061" checked=""/><div class="controls bullet"><span class="by">felixyz</span><span>|</span><a href="#41274705">parent</a><span>|</span><a href="#41308018">next</a><span>|</span><label class="collapse" for="c-41308061">[-]</label><label class="expand" for="c-41308061">[1 more]</label></div><br/><div class="children"><div class="content">Any particular macro system you have used or created? If so, did you use an existing pre-processor, or just coded something up from scratch?</div><br/></div></div></div></div><div id="41308018" class="c"><input type="checkbox" id="c-41308018" checked=""/><div class="controls bullet"><span class="by">stareatgoats</span><span>|</span><a href="#41274705">prev</a><span>|</span><a href="#41308065">next</a><span>|</span><label class="collapse" for="c-41308018">[-]</label><label class="expand" for="c-41308018">[1 more]</label></div><br/><div class="children"><div class="content">(2013)<p>It was also discussed around that time, 78 comments: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7023907">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7023907</a></div><br/></div></div><div id="41308065" class="c"><input type="checkbox" id="c-41308065" checked=""/><div class="controls bullet"><span class="by">lovasoa</span><span>|</span><a href="#41308018">prev</a><span>|</span><a href="#41307437">next</a><span>|</span><label class="collapse" for="c-41308065">[-]</label><label class="expand" for="c-41308065">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s strange to call CTEs a &quot;postgres feature&quot;. It&#x27;s standard SQL, it&#x27;s in all databases.</div><br/></div></div><div id="41307437" class="c"><input type="checkbox" id="c-41307437" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#41308065">prev</a><span>|</span><a href="#41307611">next</a><span>|</span><label class="collapse" for="c-41307437">[-]</label><label class="expand" for="c-41307437">[1 more]</label></div><br/><div class="children"><div class="content">&gt; CTEs won’t always be quite as performant as optimizing your SQL to be as concise as possible. In most cases I have seen performance differences smaller than a 2X difference, this tradeoff for readability is a nobrainer as far as I’m concerned.<p>This is the key trade-off you need to keep in the back of your head. Pre-mature performance optimization is the root of all evil; prefer readability first. But the fact remains that you should be setting timeouts and other time budgets, tracing calls from API through to the database, seeing what&#x27;s taking the most time. If you get to the point where you need to optimize a CTE-based query, be prepared to rewrite it.</div><br/></div></div><div id="41307611" class="c"><input type="checkbox" id="c-41307611" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#41307437">prev</a><span>|</span><a href="#41307444">next</a><span>|</span><label class="collapse" for="c-41307611">[-]</label><label class="expand" for="c-41307611">[3 more]</label></div><br/><div class="children"><div class="content">WITH clauses are a somewhat recent feature, at least on PostgreSQL. If you learned SQL before they became commonly available, it&#x27;s unsurprising if you tend to think of other SQL techniques first.</div><br/><div id="41307821" class="c"><input type="checkbox" id="c-41307821" checked=""/><div class="controls bullet"><span class="by">zaxomi</span><span>|</span><a href="#41307611">parent</a><span>|</span><a href="#41307444">next</a><span>|</span><label class="collapse" for="c-41307821">[-]</label><label class="expand" for="c-41307821">[2 more]</label></div><br/><div class="children"><div class="content">A quick search shows it in the documentation for version 8.4, released July 1, 2009.<p>Maybe 15 years is &quot;somewhat recent feature&quot;. :)</div><br/><div id="41307965" class="c"><input type="checkbox" id="c-41307965" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#41307611">root</a><span>|</span><a href="#41307821">parent</a><span>|</span><a href="#41307444">next</a><span>|</span><label class="collapse" for="c-41307965">[-]</label><label class="expand" for="c-41307965">[1 more]</label></div><br/><div class="children"><div class="content">Well, it wasn&#x27;t there when I first learned SQL by reading the PostgreSQL manual. I recall that this was back when the size of TEXT columns was limited, so it was before version 7.1 (which introduced TOAST tables), released 13 April, 2001.<p>So yeah, if you first learned SQL around 25 years ago, something added only 15 years ago <i>is</i> &quot;somewhat recent&quot;. And according to a link posted in another comment, other databases introduced this feature (non-recursive WITH clauses) even later.</div><br/></div></div></div></div></div></div><div id="41307444" class="c"><input type="checkbox" id="c-41307444" checked=""/><div class="controls bullet"><span class="by">Dissori</span><span>|</span><a href="#41307611">prev</a><span>|</span><a href="#41307395">next</a><span>|</span><label class="collapse" for="c-41307444">[-]</label><label class="expand" for="c-41307444">[1 more]</label></div><br/><div class="children"><div class="content">This was posted 4 days ago but now says 7 hours ago, even the comments from back then now show as 30 minutes old?</div><br/></div></div><div id="41307395" class="c"><input type="checkbox" id="c-41307395" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#41307444">prev</a><span>|</span><a href="#41307544">next</a><span>|</span><label class="collapse" for="c-41307395">[-]</label><label class="expand" for="c-41307395">[1 more]</label></div><br/><div class="children"><div class="content">I use CTEs all the time, find them way more readable than subqueries. I&#x27;ve refactored a few complex queries to use them and had the reaction from the original author of &quot;wtf is this crap?&quot;. It does take some getting used to ;)</div><br/></div></div><div id="41307544" class="c"><input type="checkbox" id="c-41307544" checked=""/><div class="controls bullet"><span class="by">beAbU</span><span>|</span><a href="#41307395">prev</a><span>|</span><a href="#41307411">next</a><span>|</span><label class="collapse" for="c-41307544">[-]</label><label class="expand" for="c-41307544">[1 more]</label></div><br/><div class="children"><div class="content">(I&#x27;m not a dev)<p>This feels to me like a &quot;in other news, water is wet&quot; kind of story. Maybe it&#x27;s just me, but based on the other comments here CTEs seem to be common knowledge. I went on a SQL trial by fire this year after landing in a role that required massive amounts of weird querying for ad-hoc reporting purposes. Before this my experience and knowledge stopped at different join types.<p>I naturally discovered CTEs over time after seeking solutions to my problems on the usual online resources. For me the use is two-fold. 1&#x2F; I use it to create ad-hoc lookups on data, where the lookups are not available in the DB in the first place. And 2&#x2F; In complex queries with lots and lots of conditional joins, I can use a CTE to basically build up my temporary base table, getting all my data in one place, then my main `SELECT` becomes a lot cleaner and easier to read.<p>I&#x27;ve not looked at recursive CTEs yet, supposedly they can be quite handy. Not sure for what though.<p>We recently migrated from MySQL to Postgres, and the data reporting went from direct-db querying to Snowflake. And CTEs work on for me on all 3 platforms, so this does not even seem like a Postgres only thing.</div><br/></div></div></div></div></div></div></div></body></html>