<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725613277131" as="style"/><link rel="stylesheet" href="styles.css?v=1725613277131"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/tilyupo/qustar">Show HN: Node.js ORM to query SQL database through an array-like API</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>tilyupo</span> | <span>83 comments</span></div><br/><div><div id="41461438" class="c"><input type="checkbox" id="c-41461438" checked=""/><div class="controls bullet"><span class="by">xonix</span><span>|</span><a href="#41457415">next</a><span>|</span><label class="collapse" for="c-41461438">[-]</label><label class="expand" for="c-41461438">[6 more]</label></div><br/><div class="children"><div class="content">My take on this is that it&#x27;s not always the best idea to abstract-out SQL. You see, the SQL itself is too valuable abstraction, and also a very &quot;wide&quot; one. Any attempt to hide it behind another abstraction layer will face these problems:<p>- need to learn secondary API which still doesn&#x27;t cover the whole scope of SQL<p>- abstraction which is guaranteed to leak, because any time you&#x27;ll need to optimize - you&#x27;ll need to start reason in terms of SQL and try to force the ORM produce SQL you need.<p>- performance<p>- deceptive simplicity, when it&#x27;s super-easy to start on simple examples, but it&#x27;s getting increasingly hard as you go. But at the point you realize it doesn&#x27;t work (well) - you already produced tons of code which business will disallow you to simply rewrite<p>(knowledge based on my own hard experiences)</div><br/><div id="41464095" class="c"><input type="checkbox" id="c-41464095" checked=""/><div class="controls bullet"><span class="by">reacweb</span><span>|</span><a href="#41461438">parent</a><span>|</span><a href="#41461758">next</a><span>|</span><label class="collapse" for="c-41464095">[-]</label><label class="expand" for="c-41464095">[1 more]</label></div><br/><div class="children"><div class="content">Yes, yes and yes. ORM are marvelous when you do not know well SQL. With experience, you always end up needing to learn more about SQL. In the end, ORM is as much a hindrance as a help. So instead of spending energy learning the ORM of the day, it&#x27;s better to invest in longer lasting technologies like SQL.</div><br/></div></div><div id="41461758" class="c"><input type="checkbox" id="c-41461758" checked=""/><div class="controls bullet"><span class="by">DimmieMan</span><span>|</span><a href="#41461438">parent</a><span>|</span><a href="#41464095">prev</a><span>|</span><a href="#41461486">next</a><span>|</span><label class="collapse" for="c-41461758">[-]</label><label class="expand" for="c-41461758">[3 more]</label></div><br/><div class="children"><div class="content">I’ve taken more and more to thinking of them as a zero sum tool.<p>Super fast and easier to use force multiplier in the beginning, but eventually you break free of the siren song and run into some negative that eats away at your time until you reach that “if you had just sucked it up and written the damn sql you’d be done yesterday” stage.</div><br/><div id="41462735" class="c"><input type="checkbox" id="c-41462735" checked=""/><div class="controls bullet"><span class="by">tstrimple</span><span>|</span><a href="#41461438">root</a><span>|</span><a href="#41461758">parent</a><span>|</span><a href="#41461486">next</a><span>|</span><label class="collapse" for="c-41462735">[-]</label><label class="expand" for="c-41462735">[2 more]</label></div><br/><div class="children"><div class="content">This just seems like a normal part of the growth curve. You cannot simultaneously build an infinitely scalable solution and complete something in a reasonable timeframe with the features that users will pay for. If you get to the point where you have enough users to justify working on efficiency or scaling out your infrastructure that’s a sign that you are winning. Unsuccessful companies never have to clean up their tech debt. For successful companies, it is a constant balance. You’re lucky to ever be in a position to have to clean up your short sightedness from previous work. By the time Facebook needed to mature beyond their PHP codebase, they were already wildly successful by every metric and had the resources to tackle such a problem. Early stage CRUD APIs should absolutely be generated and use the shitty ORM generated queries. By the time you run into serious performance issues with the ORM generated queries, you should be successful enough and have enough runway to plan a better future.<p>The vast majority of companies like this don’t fail because their UI is too slow. It’s because they don’t have “essential” features that other platforms do. If you have good monitoring and metrics, you should be able to find the bottleneck in your ORM and resolve it before any users even notice. And that means you’re hand rolling a few queries instead of the entire data storage layer.</div><br/><div id="41464284" class="c"><input type="checkbox" id="c-41464284" checked=""/><div class="controls bullet"><span class="by">kaladin_1</span><span>|</span><a href="#41461438">root</a><span>|</span><a href="#41462735">parent</a><span>|</span><a href="#41461486">next</a><span>|</span><label class="collapse" for="c-41464284">[-]</label><label class="expand" for="c-41464284">[1 more]</label></div><br/><div class="children"><div class="content">+1<p>&quot;...premature optimization is the root of all evil.&quot;<p>Sometimes you just wanna get stuff out there, other times you&#x27;re winning and you wanna give users the best experience. Many people have had to do both. You start with an ORM, eventually your queries are slow and all, you gradually reap them out. Almost every Engineer I know has had to do that at some POINT. Nonetheless, I am not about writing SQL for a simple barbing saloon booking app that I am not sure anybody will eventually use.</div><br/></div></div></div></div></div></div><div id="41461486" class="c"><input type="checkbox" id="c-41461486" checked=""/><div class="controls bullet"><span class="by">samstave</span><span>|</span><a href="#41461438">parent</a><span>|</span><a href="#41461758">prev</a><span>|</span><a href="#41457415">next</a><span>|</span><label class="collapse" for="c-41461486">[-]</label><label class="expand" for="c-41461486">[1 more]</label></div><br/><div class="children"><div class="content">Have you use BI tools, such as Looker, Tableau, and the like?<p>LookerML is their abstracted version - but they always have an expander panel for seeing the sql.<p>---<p>What I would like is to use this in reverse - such that I can feed it a JSON output from my GPT bots Tribute - and use this to craft a sql schema dynamically into a more structured way where my table might be a mark-down version of the {Q} query - and it does SQL to create table if not exist, insert [these objects from this json for these things into this DB, now these json objects from this output into this other DB. Now I am pulling data into the DB that I can then RAG off as I fill it with Cauldrons of Knowledge I am scvraping for my rabbit-hole project thingamijiggers.</div><br/></div></div></div></div><div id="41457415" class="c"><input type="checkbox" id="c-41457415" checked=""/><div class="controls bullet"><span class="by">arnorhs</span><span>|</span><a href="#41461438">prev</a><span>|</span><a href="#41464178">next</a><span>|</span><label class="collapse" for="c-41457415">[-]</label><label class="expand" for="c-41457415">[4 more]</label></div><br/><div class="children"><div class="content">Nice, looks promising. How does this compare to drizzle?<p>Context:<p>We&#x27;ve had a lot of ORM frameworks come and go in node.js - sequelize, typeorm etc, but none of them have really caught on.<p>Things have been changing a lot lately after typescript took over, so we&#x27;ve seen a bunch of ORMs take off that give you a really good typescript experience.<p>So, the juggernaut in this space is of course prisma, which is super expressive and over all pretty decent - it comes with its own way to define schemas, migrations etc .. so that might not be everybody&#x27;s cup of tea. (and then there&#x27;s the larger runtime, that have lambda-users complaining - though that has mostly been addressed now where the binary is much smaller)<p>So despite it being a pretty opinionated framework really, what it gives you are really rich typescript integrated queries. And all in all it works pretty well - i&#x27;ve been using it at work for about 3 years and I&#x27;m just really pleased with it for the most part.<p>The newcomer in the space that&#x27;s gaining a lot of traction is Drizzle - where it&#x27;s mostly a way to define tables and queries - it also gives you really rich typed queries - and it happens all in TS&#x2F;JS land.<p>this project of yours reminds of drizzle - kind of similar in a lot of ways.<p>I&#x27;m super interested to understand how this compares to drizzle and which problems with drizzle this attempts to solve</div><br/><div id="41457499" class="c"><input type="checkbox" id="c-41457499" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#41457415">parent</a><span>|</span><a href="#41464178">next</a><span>|</span><label class="collapse" for="c-41457499">[-]</label><label class="expand" for="c-41457499">[3 more]</label></div><br/><div class="children"><div class="content">Hmm. I might be wrong as I haven&#x27;t used Drizzle, just read the docs, but isn&#x27;t Drizzle just like Prisma? That&#x27;s really not the same as this. I find Prisma at least one of the most terrible things I ever worked with <i>in my life</i>; the rigidity (which I guess is the arrogance of the devs which they call opinionated; their right but he), the weird querying dsl, the terrible tooling. Just checked &#x27;Drizzle queries&#x27; again and see it looks exactly like Prisma is it not? That&#x27;s really not anything like this imho?</div><br/><div id="41457886" class="c"><input type="checkbox" id="c-41457886" checked=""/><div class="controls bullet"><span class="by">onion90</span><span>|</span><a href="#41457415">root</a><span>|</span><a href="#41457499">parent</a><span>|</span><a href="#41457786">next</a><span>|</span><label class="collapse" for="c-41457886">[-]</label><label class="expand" for="c-41457886">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;Drizzle Queries&quot; section of the docs describes additional APIs for relations (referred to in the docs as db.query). There is also an API that looks&#x2F;works much more like SQL (see db.select(), db.insert(), db.update()) with good types.</div><br/></div></div></div></div></div></div><div id="41464178" class="c"><input type="checkbox" id="c-41464178" checked=""/><div class="controls bullet"><span class="by">jdthedisciple</span><span>|</span><a href="#41457415">prev</a><span>|</span><a href="#41456971">next</a><span>|</span><label class="collapse" for="c-41464178">[-]</label><label class="expand" for="c-41464178">[1 more]</label></div><br/><div class="children"><div class="content">So basically like entity framework &amp; LINQ in the C# world<p>but for nodejs</div><br/></div></div><div id="41456971" class="c"><input type="checkbox" id="c-41456971" checked=""/><div class="controls bullet"><span class="by">sigseg1v</span><span>|</span><a href="#41464178">prev</a><span>|</span><a href="#41457379">next</a><span>|</span><label class="collapse" for="c-41456971">[-]</label><label class="expand" for="c-41456971">[2 more]</label></div><br/><div class="children"><div class="content">Cool project!<p>Looking at the docs, for example the pg connector, I couldn&#x27;t easily find information about how it parameterizes the queries built through method chaining.<p>For example, if I run<p><pre><code>   .filter(user =&gt; user.name.eq(unsanitizedInput))
</code></pre>
I am presuming that the unsanitizedInput will be put into a parameter? For me, using ORMs on a team that may include juniors, that is one of the key things an ORM provides: the ability to know for sure that a query is immune to SQL injection.<p>If you had more examples on the connectors of queries like this, and also maybe some larger ones, with the resulting SQL output, I think that might increase adoption.</div><br/><div id="41457028" class="c"><input type="checkbox" id="c-41457028" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41456971">parent</a><span>|</span><a href="#41457379">next</a><span>|</span><label class="collapse" for="c-41457028">[-]</label><label class="expand" for="c-41457028">[1 more]</label></div><br/><div class="children"><div class="content">Qustar parametrizes all queries by default, so it&#x27;s immune to SQL injections. I&#x27;ll add info about that with examples to the docs, thank for the feedback!</div><br/></div></div></div></div><div id="41457379" class="c"><input type="checkbox" id="c-41457379" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#41456971">prev</a><span>|</span><a href="#41457323">next</a><span>|</span><label class="collapse" for="c-41457379">[-]</label><label class="expand" for="c-41457379">[4 more]</label></div><br/><div class="children"><div class="content">Now that we have about 15 years of ORMs, do they really make things easier?<p>SQL is not a difficult language to learn, and views and stored procedures provide a stable interface that decouples the underlying table schema, allowing for migrations and refactoring of the database structure without having to rewrite a lot of code.<p>ORMs seem to me to be mostly about syntactic sugar nowadays; I’m worried that the abstractions that they set up insulate the developer from the reality of the system they’re depending on - like any abstraction, they probably work fine right to the very point they don’t work at all.<p>I’m not complaining about this project; it looks cool and I can see the attraction of staying in a single language paradigm, but I am very wary of abstractions, especially those that hide complex systems behind them.</div><br/><div id="41464027" class="c"><input type="checkbox" id="c-41464027" checked=""/><div class="controls bullet"><span class="by">l5870uoo9y</span><span>|</span><a href="#41457379">parent</a><span>|</span><a href="#41461387">next</a><span>|</span><label class="collapse" for="c-41464027">[-]</label><label class="expand" for="c-41464027">[1 more]</label></div><br/><div class="children"><div class="content">What I find valuable is that many ORMs provide type support and manage migrations, not so much the day-to-day interaction with the database.</div><br/></div></div><div id="41461387" class="c"><input type="checkbox" id="c-41461387" checked=""/><div class="controls bullet"><span class="by">ARandomerDude</span><span>|</span><a href="#41457379">parent</a><span>|</span><a href="#41464027">prev</a><span>|</span><a href="#41463947">next</a><span>|</span><label class="collapse" for="c-41461387">[-]</label><label class="expand" for="c-41461387">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re being downvoted, but you&#x27;re not wrong.  Here&#x27;s another benefit to just using SQL: it&#x27;s cross-language, cross-framework, cross-decade.  So &quot;select firstName from users where id=?;&quot; works in 2024 with Go, JavaScript, etc., but it also worked in 2010 with Ruby and 1999 with PHP.<p>Every time you switch languages, or stay in the same language for 2 years, you have to learn another ORM.  SQL is about as close as timeless gets in this business.</div><br/></div></div></div></div><div id="41457323" class="c"><input type="checkbox" id="c-41457323" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#41457379">prev</a><span>|</span><a href="#41456524">next</a><span>|</span><label class="collapse" for="c-41457323">[-]</label><label class="expand" for="c-41457323">[2 more]</label></div><br/><div class="children"><div class="content">Very nice! Almost everyone I know misses Entityframework if they ever worked with it and similar ergonomic ways in other languages (clojure&#x2F;cl). Entityframework has it&#x27;s downsides, but it&#x27;s so nice to develop with. I don&#x27;t mind (and often use SQL), in fact, since no longer using C#, I find myself using SQL more often than ORMs as everything is so ... clumsy... compared to entityframework.<p>Continue doing the excellent work please!</div><br/><div id="41457434" class="c"><input type="checkbox" id="c-41457434" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41457323">parent</a><span>|</span><a href="#41456524">next</a><span>|</span><label class="collapse" for="c-41457434">[-]</label><label class="expand" for="c-41457434">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I miss Entity Framework too, one of the best ORMs out there.</div><br/></div></div></div></div><div id="41456524" class="c"><input type="checkbox" id="c-41456524" checked=""/><div class="controls bullet"><span class="by">EarthLaunch</span><span>|</span><a href="#41457323">prev</a><span>|</span><a href="#41456633">next</a><span>|</span><label class="collapse" for="c-41456524">[-]</label><label class="expand" for="c-41456524">[5 more]</label></div><br/><div class="children"><div class="content">An intriguing idea!  I like this approach for being an innovative interface to SQL.  I wonder if it would reduce cognitive load when interfacing with the DB.<p>I&#x27;m a game dev and often need to avoid situations where I&#x27;m using &#x27;.map&#x27; to iterate an entire array, for performance reasons.  It would feel odd to use the concept, knowing it wasn&#x27;t really iterating and&#x2F;or was using an index.  Is that how it works?</div><br/><div id="41456595" class="c"><input type="checkbox" id="c-41456595" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#41456524">parent</a><span>|</span><a href="#41456633">next</a><span>|</span><label class="collapse" for="c-41456595">[-]</label><label class="expand" for="c-41456595">[4 more]</label></div><br/><div class="children"><div class="content">It’s exactly what Entity Framework does in dotnet. It allows you to query the database like it’s an enumerable.<p>In fact, in EF, an IQueryable  (which is the interface you use to query a SQL dataset) implements IEnumerable. So you  can 100% manipulate your dataset like a normal array&#x2F;list.<p>Sure it comes with its own shenanigans but 90% of the time it’s easy to read and to manipulate.</div><br/><div id="41461366" class="c"><input type="checkbox" id="c-41461366" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41456524">root</a><span>|</span><a href="#41456595">parent</a><span>|</span><a href="#41462722">next</a><span>|</span><label class="collapse" for="c-41461366">[-]</label><label class="expand" for="c-41461366">[2 more]</label></div><br/><div class="children"><div class="content">Performing a query with EF is able to do stuff that can&#x27;t be done with `IEnumerable`.  So that a filter()&#x2F;.Where() can actually generate a WHERE clause instead of looping over every record.</div><br/><div id="41463117" class="c"><input type="checkbox" id="c-41463117" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#41456524">root</a><span>|</span><a href="#41461366">parent</a><span>|</span><a href="#41462722">next</a><span>|</span><label class="collapse" for="c-41463117">[-]</label><label class="expand" for="c-41463117">[1 more]</label></div><br/><div class="children"><div class="content">Yes of course it generates the corresponding SQL and don’t iterate over the table.<p>But in the framework’s code, IQueryable implements IEnumerable, it’s just a totally different implementation but for the developer it’s 100% the same API and so any IQueryable can be used where a IEnumerable is expected.</div><br/></div></div></div></div></div></div></div></div><div id="41456633" class="c"><input type="checkbox" id="c-41456633" checked=""/><div class="controls bullet"><span class="by">Eric_WVGG</span><span>|</span><a href="#41456524">prev</a><span>|</span><a href="#41456899">next</a><span>|</span><label class="collapse" for="c-41456633">[-]</label><label class="expand" for="c-41456633">[5 more]</label></div><br/><div class="children"><div class="content">I love your syntax for joins and unions!<p>A bit puzzled by why the connector slots into the query, instead of the query slotting into the connector, given that it’s the connector that’s actually doing the work. I.e.
‘connector.fetch(query)‘
… rather than…
‘query.fetch(connector)‘</div><br/><div id="41456700" class="c"><input type="checkbox" id="c-41456700" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41456633">parent</a><span>|</span><a href="#41456899">next</a><span>|</span><label class="collapse" for="c-41456700">[-]</label><label class="expand" for="c-41456700">[4 more]</label></div><br/><div class="children"><div class="content">It was more of an ergonomics choice. To me it seems like it&#x27;s more readable to write `await users.filter(user =&gt; user.id.eq(42).fetch(connector)` instead of `await connector.fetch(users.filter(user =&gt; user.id.eq(42))`.<p>But I might be wrong, your idea makes more sense from logical perspective.</div><br/><div id="41464282" class="c"><input type="checkbox" id="c-41464282" checked=""/><div class="controls bullet"><span class="by">williamdclt</span><span>|</span><a href="#41456633">root</a><span>|</span><a href="#41456700">parent</a><span>|</span><a href="#41457220">next</a><span>|</span><label class="collapse" for="c-41464282">[-]</label><label class="expand" for="c-41464282">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure I can say which is _objectively_ better, but I was also surprised, connector.fetch would be more consistent with common JS practices</div><br/></div></div><div id="41457220" class="c"><input type="checkbox" id="c-41457220" checked=""/><div class="controls bullet"><span class="by">jgoyvaerts</span><span>|</span><a href="#41456633">root</a><span>|</span><a href="#41456700">parent</a><span>|</span><a href="#41464282">prev</a><span>|</span><a href="#41457116">next</a><span>|</span><label class="collapse" for="c-41457220">[-]</label><label class="expand" for="c-41457220">[1 more]</label></div><br/><div class="children"><div class="content">What about moving the connector to the table declaration, similar to dbcontext in .net?<p>Something like Q.table(definition, connector), which would then allow you to just write users.filter(user =&gt; user.id.eq(42).fetch()</div><br/></div></div></div></div></div></div><div id="41456899" class="c"><input type="checkbox" id="c-41456899" checked=""/><div class="controls bullet"><span class="by">v_b</span><span>|</span><a href="#41456633">prev</a><span>|</span><a href="#41461620">next</a><span>|</span><label class="collapse" for="c-41456899">[-]</label><label class="expand" for="c-41456899">[2 more]</label></div><br/><div class="children"><div class="content">It is dope, please continue on this.<p>I used to work with TypeORM and really missed using EntityFramework. 
That actually led me to switch to Mongo (Mongoose).<p>I&#x27;m really looking forward to this project!</div><br/><div id="41457041" class="c"><input type="checkbox" id="c-41457041" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41456899">parent</a><span>|</span><a href="#41461620">next</a><span>|</span><label class="collapse" for="c-41457041">[-]</label><label class="expand" for="c-41457041">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve big plans for Qustar, thanks for kind words!</div><br/></div></div></div></div><div id="41461620" class="c"><input type="checkbox" id="c-41461620" checked=""/><div class="controls bullet"><span class="by">ericyd</span><span>|</span><a href="#41456899">prev</a><span>|</span><a href="#41456547">next</a><span>|</span><label class="collapse" for="c-41461620">[-]</label><label class="expand" for="c-41461620">[1 more]</label></div><br/><div class="children"><div class="content">I might have missed it but I would like to see what the return types look like, and how type safe they are. The query interface is interesting, I&#x27;m not sure I&#x27;m sold but if I don&#x27;t know how to use the result then I&#x27;m not going to adopt it.</div><br/></div></div><div id="41456547" class="c"><input type="checkbox" id="c-41456547" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#41461620">prev</a><span>|</span><a href="#41457340">next</a><span>|</span><label class="collapse" for="c-41456547">[-]</label><label class="expand" for="c-41456547">[2 more]</label></div><br/><div class="children"><div class="content">Oh, that’s Entity Framework but in typescript ?</div><br/><div id="41456565" class="c"><input type="checkbox" id="c-41456565" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41456547">parent</a><span>|</span><a href="#41457340">next</a><span>|</span><label class="collapse" for="c-41456565">[-]</label><label class="expand" for="c-41456565">[1 more]</label></div><br/><div class="children"><div class="content">Exactly! Qustar was heavily inspired by EF.</div><br/></div></div></div></div><div id="41457340" class="c"><input type="checkbox" id="c-41457340" checked=""/><div class="controls bullet"><span class="by">brap</span><span>|</span><a href="#41456547">prev</a><span>|</span><a href="#41456622">next</a><span>|</span><label class="collapse" for="c-41457340">[-]</label><label class="expand" for="c-41457340">[4 more]</label></div><br/><div class="children"><div class="content">Pretty cool! The only thing I didn&#x27;t like in the examples were things like .eq and .add, which are kind of a DSL, so it takes away from the &quot;just plain JS&quot; approach. But I assume it&#x27;s because JS doesn&#x27;t allow operator overloading?</div><br/><div id="41457363" class="c"><input type="checkbox" id="c-41457363" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41457340">parent</a><span>|</span><a href="#41456622">next</a><span>|</span><label class="collapse" for="c-41457363">[-]</label><label class="expand" for="c-41457363">[3 more]</label></div><br/><div class="children"><div class="content">Yep, I would love to use plain &quot;==&quot; and &quot;+&quot;, but JS doesn&#x27;t support it.</div><br/><div id="41459088" class="c"><input type="checkbox" id="c-41459088" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#41457340">root</a><span>|</span><a href="#41457363">parent</a><span>|</span><a href="#41458229">next</a><span>|</span><label class="collapse" for="c-41459088">[-]</label><label class="expand" for="c-41459088">[1 more]</label></div><br/><div class="children"><div class="content">You can achieve some hacky form of operator overloading by implementing the “well-known” Symbol.toPrimitive, and exploiting the fact that the addition operator coerces its operands to either a Number or String.<p>It won’t be perfect but maybe you can do something useful with it. Symbols in general are a really powerful tool that almost enable meta-programming in JS. I searched “Symbol” in your repository and didn’t see any results, so if you aren’t familiar with them, I recommend taking the time to read up on how you can use them.<p>See: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Symbol&#x2F;toPrimitive#modifying_primitive_values_converted_from_an_object" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>And this 2015 blog: <a href="https:&#x2F;&#x2F;www.keithcirkel.co.uk&#x2F;metaprogramming-in-es6-symbols&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.keithcirkel.co.uk&#x2F;metaprogramming-in-es6-symbols...</a></div><br/></div></div><div id="41458229" class="c"><input type="checkbox" id="c-41458229" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41457340">root</a><span>|</span><a href="#41457363">parent</a><span>|</span><a href="#41459088">prev</a><span>|</span><a href="#41456622">next</a><span>|</span><label class="collapse" for="c-41458229">[-]</label><label class="expand" for="c-41458229">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen (and implemented myself) operator overloading based systems for query builder type things ... and the way such facilities work in every language I&#x27;ve seen&#x2F;tried them in has had enough limitations that it wasn&#x27;t really a great idea in the end anyway.<p><a href="https:&#x2F;&#x2F;p3rl.org&#x2F;DBIx::Perlish" rel="nofollow">https:&#x2F;&#x2F;p3rl.org&#x2F;DBIx::Perlish</a> does it pretty nicely, but only because instead of using operator overloading the author lets the query code compile as a lambda and then pulls apart the perl5 VM opcodes and translates -those- into a query, which is ... awesome in its own way but not something you&#x27;d want to try and reproduce.<p>Interestingly, Scala actually turns &#x27;x + y&#x27; into &#x27;x.+(y)&#x27; and you could maybe get somewhere with that style.<p>For javascript, you&#x27;d probably need instead to provide a Babel transform and rely on the fact that like 90%+ of javascript projects are already &#x27;compile to javascript&#x27; code except that the source is also sort of javascript.<p>My plan instead is to have an API much like yours (... or possibly just (ab)use yours, see my other comment ...) and then a format string based DSL for nicer querying.<p>... now that I think about it, making the DSL I have in mind work with qustar might be a good &quot;dual implementations keep you honest&quot; thing, but I have a lot of yaks to shave before that becomes relevant, so please nobody hold your breath.</div><br/></div></div></div></div></div></div><div id="41456622" class="c"><input type="checkbox" id="c-41456622" checked=""/><div class="controls bullet"><span class="by">bearjaws</span><span>|</span><a href="#41457340">prev</a><span>|</span><a href="#41456735">next</a><span>|</span><label class="collapse" for="c-41456622">[-]</label><label class="expand" for="c-41456622">[3 more]</label></div><br/><div class="children"><div class="content">I am not sure I am understanding array-like in this context?<p>It seems to be more like knex or <a href="https:&#x2F;&#x2F;kysely.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;kysely.dev&#x2F;</a></div><br/><div id="41456927" class="c"><input type="checkbox" id="c-41456927" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41456622">parent</a><span>|</span><a href="#41456628">next</a><span>|</span><label class="collapse" for="c-41456927">[-]</label><label class="expand" for="c-41456927">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;array-like&quot; refers to the similar interface of the &quot;.map&quot; and &quot;.filter&quot; methods between Array and Q.table</div><br/></div></div></div></div><div id="41456735" class="c"><input type="checkbox" id="c-41456735" checked=""/><div class="controls bullet"><span class="by">todotask</span><span>|</span><a href="#41456622">prev</a><span>|</span><a href="#41456761">next</a><span>|</span><label class="collapse" for="c-41456735">[-]</label><label class="expand" for="c-41456735">[1 more]</label></div><br/><div class="children"><div class="content">Qustar sounds nice, I would think &quot;Exact&quot; is what it is.</div><br/></div></div><div id="41456761" class="c"><input type="checkbox" id="c-41456761" checked=""/><div class="controls bullet"><span class="by">arrty88</span><span>|</span><a href="#41456735">prev</a><span>|</span><a href="#41457215">next</a><span>|</span><label class="collapse" for="c-41456761">[-]</label><label class="expand" for="c-41456761">[3 more]</label></div><br/><div class="children"><div class="content">Very cool. Reminds me of linq to sql</div><br/><div id="41457086" class="c"><input type="checkbox" id="c-41457086" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#41456761">parent</a><span>|</span><a href="#41457215">next</a><span>|</span><label class="collapse" for="c-41457086">[-]</label><label class="expand" for="c-41457086">[2 more]</label></div><br/><div class="children"><div class="content">Yes, as an efcore fan, I often wish that we had better ORM in my company&#x27;s node projects. Sequelize seriously drives me insane</div><br/><div id="41458446" class="c"><input type="checkbox" id="c-41458446" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#41456761">root</a><span>|</span><a href="#41457086">parent</a><span>|</span><a href="#41457215">next</a><span>|</span><label class="collapse" for="c-41458446">[-]</label><label class="expand" for="c-41458446">[1 more]</label></div><br/><div class="children"><div class="content">A jooq-like for TypeScript (as vanilla JS would kind of defy jooq&#x27;s purpose) would be really nice.<p>I&#x27;m not sold on ORMs. They make the easy queries slightly easier, and have no solution more complex queries. Not worth the learning-curve (life times, caching, dirty state, associations, cascading, mapping, etc)</div><br/></div></div></div></div></div></div><div id="41457215" class="c"><input type="checkbox" id="c-41457215" checked=""/><div class="controls bullet"><span class="by">richwater</span><span>|</span><a href="#41456761">prev</a><span>|</span><a href="#41457057">next</a><span>|</span><label class="collapse" for="c-41457215">[-]</label><label class="expand" for="c-41457215">[1 more]</label></div><br/><div class="children"><div class="content">This is a really cool project, but I&#x27;m not sure I like some of the APIs.<p>`orderByDesc` seems like it could be better suited for an object constant indicating the sort direction.<p>```
orderBy(OrderBy.Desc, user =&gt; user.age)
```<p>Overall still very nice and looking forward to seeing more development!</div><br/></div></div><div id="41457057" class="c"><input type="checkbox" id="c-41457057" checked=""/><div class="controls bullet"><span class="by">gedy</span><span>|</span><a href="#41457215">prev</a><span>|</span><a href="#41457320">next</a><span>|</span><label class="collapse" for="c-41457057">[-]</label><label class="expand" for="c-41457057">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for this.  While I have no problem with SQL, I enjoy the type checking, autocomplete, and &#x27;compilation&#x27; this TS syntax gives you.  Please continue!</div><br/><div id="41457319" class="c"><input type="checkbox" id="c-41457319" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41457057">parent</a><span>|</span><a href="#41457320">next</a><span>|</span><label class="collapse" for="c-41457319">[-]</label><label class="expand" for="c-41457319">[1 more]</label></div><br/><div class="children"><div class="content">Same, I hope Qustar will provide better developer experience than raw SQL without sacrificing flexibility.</div><br/></div></div></div></div><div id="41457320" class="c"><input type="checkbox" id="c-41457320" checked=""/><div class="controls bullet"><span class="by">marcelr</span><span>|</span><a href="#41457057">prev</a><span>|</span><a href="#41459144">next</a><span>|</span><label class="collapse" for="c-41457320">[-]</label><label class="expand" for="c-41457320">[1 more]</label></div><br/><div class="children"><div class="content">can i suggest saying “iterator api” instead of array-like?</div><br/></div></div><div id="41459144" class="c"><input type="checkbox" id="c-41459144" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41457320">prev</a><span>|</span><a href="#41456607">next</a><span>|</span><label class="collapse" for="c-41459144">[-]</label><label class="expand" for="c-41459144">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Codegen free&quot;<p>why is codegen bad?</div><br/></div></div><div id="41456607" class="c"><input type="checkbox" id="c-41456607" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41459144">prev</a><span>|</span><a href="#41456718">next</a><span>|</span><label class="collapse" for="c-41456607">[-]</label><label class="expand" for="c-41456607">[4 more]</label></div><br/><div class="children"><div class="content">The API doesn’t really look “array-like”.</div><br/><div id="41456852" class="c"><input type="checkbox" id="c-41456852" checked=""/><div class="controls bullet"><span class="by">v_b</span><span>|</span><a href="#41456607">parent</a><span>|</span><a href="#41456625">next</a><span>|</span><label class="collapse" for="c-41456852">[-]</label><label class="expand" for="c-41456852">[2 more]</label></div><br/><div class="children"><div class="content">When I think of &quot;array-like,&quot; I envision using brackets [i].<p>But the OP isn&#x27;t wrong; all the methods used to construct the query also function as instance methods of arrays in both JavaScript and TypeScript.</div><br/></div></div></div></div><div id="41456718" class="c"><input type="checkbox" id="c-41456718" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41456607">prev</a><span>|</span><a href="#41456573">next</a><span>|</span><label class="collapse" for="c-41456718">[-]</label><label class="expand" for="c-41456718">[2 more]</label></div><br/><div class="children"><div class="content">&gt; array-like API<p>why is this arbitrary property desirable?</div><br/><div id="41457138" class="c"><input type="checkbox" id="c-41457138" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#41456718">parent</a><span>|</span><a href="#41456573">next</a><span>|</span><label class="collapse" for="c-41457138">[-]</label><label class="expand" for="c-41457138">[1 more]</label></div><br/><div class="children"><div class="content">I think they mean functional</div><br/></div></div></div></div><div id="41456573" class="c"><input type="checkbox" id="c-41456573" checked=""/><div class="controls bullet"><span class="by">fourseventy</span><span>|</span><a href="#41456718">prev</a><span>|</span><a href="#41456618">next</a><span>|</span><label class="collapse" for="c-41456573">[-]</label><label class="expand" for="c-41456573">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve come to the conclusion that ORMs are good for simple queries like User.find_by(email: &quot;john@snow.com&quot;), but once you get beyond that you are better off just writing sql.</div><br/><div id="41456795" class="c"><input type="checkbox" id="c-41456795" checked=""/><div class="controls bullet"><span class="by">notsylver</span><span>|</span><a href="#41456573">parent</a><span>|</span><a href="#41456640">next</a><span>|</span><label class="collapse" for="c-41456795">[-]</label><label class="expand" for="c-41456795">[4 more]</label></div><br/><div class="children"><div class="content">It might be because I&#x27;m not used to SQL, but I&#x27;ve found the opposite. Writing a large query with lots of conditions (eg, if the user is signed in, hiding content they&#x27;ve blocked) is miserable without an ORM that can build the query and map the results.<p>I don&#x27;t like ORMs for lots of reasons but I find them a necessary evil. How do you deal with that in plain SQL, when a query can look completely different depending on the variables?</div><br/><div id="41457108" class="c"><input type="checkbox" id="c-41457108" checked=""/><div class="controls bullet"><span class="by">evilduck</span><span>|</span><a href="#41456573">root</a><span>|</span><a href="#41456795">parent</a><span>|</span><a href="#41457004">next</a><span>|</span><label class="collapse" for="c-41457108">[-]</label><label class="expand" for="c-41457108">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like a bell curve for me personally. The things I do with databases between the 25th and 75th percentiles of query complexity fit into an ORM or query builder tool nicely. These also tend to be the bulk of what I need. But those tools add more overhead to the effort of writing simple &lt;25th percentile SQL (like small single-table queries), and then end up being wholly inadequate for the complexity above the 75th percentile, where the library often doesn&#x27;t have good representation or documentation for the complex things a database can actually do for you in advanced use cases (leading you to do a less efficient similar operation in your programming language), or they try to be too generic to many databases and then aren&#x27;t able to provide anything that might be specific to Postgres which leads you back to writing raw SQL again.</div><br/></div></div><div id="41457004" class="c"><input type="checkbox" id="c-41457004" checked=""/><div class="controls bullet"><span class="by">eglintondust</span><span>|</span><a href="#41456573">root</a><span>|</span><a href="#41456795">parent</a><span>|</span><a href="#41457108">prev</a><span>|</span><a href="#41457003">next</a><span>|</span><label class="collapse" for="c-41457004">[-]</label><label class="expand" for="c-41457004">[1 more]</label></div><br/><div class="children"><div class="content">A good query builder is more important than ORM imo. That&#x27;s what I like about sqlalchemy. The query builder pretty much maps 1:1 to SQL and you can use it with or without the ORM mapping.   
Most of my projects have a mix of both along with plain SQL for some of the meatier queries.</div><br/></div></div><div id="41457003" class="c"><input type="checkbox" id="c-41457003" checked=""/><div class="controls bullet"><span class="by">eglintondust</span><span>|</span><a href="#41456573">root</a><span>|</span><a href="#41456795">parent</a><span>|</span><a href="#41457004">prev</a><span>|</span><a href="#41456640">next</a><span>|</span><label class="collapse" for="c-41457003">[-]</label><label class="expand" for="c-41457003">[1 more]</label></div><br/><div class="children"><div class="content">A good query builder is more important than ORM imo. That&#x27;s what I like about sqlalchemy. The query builder pretty much maps 1:1 to SQL and you can use it with or without the ORM mapping.   
Most of my projects have a mix of both along with plain SQL for some of the meatier queries.</div><br/></div></div></div></div><div id="41456640" class="c"><input type="checkbox" id="c-41456640" checked=""/><div class="controls bullet"><span class="by">tilyupo</span><span>|</span><a href="#41456573">parent</a><span>|</span><a href="#41456795">prev</a><span>|</span><a href="#41456777">next</a><span>|</span><label class="collapse" for="c-41456640">[-]</label><label class="expand" for="c-41456640">[2 more]</label></div><br/><div class="children"><div class="content">I agree, classic ORMs usually don&#x27;t play well with complex queries.<p>I think Qustar is closer to a query builder than ORM tbh. You can compose arbitrary queries using it.</div><br/><div id="41458117" class="c"><input type="checkbox" id="c-41458117" checked=""/><div class="controls bullet"><span class="by">mst</span><span>|</span><a href="#41456573">root</a><span>|</span><a href="#41456640">parent</a><span>|</span><a href="#41456777">next</a><span>|</span><label class="collapse" for="c-41458117">[-]</label><label class="expand" for="c-41458117">[1 more]</label></div><br/><div class="children"><div class="content">People have often said of <a href="https:&#x2F;&#x2F;p3rl.org&#x2F;DBIx::Class" rel="nofollow">https:&#x2F;&#x2F;p3rl.org&#x2F;DBIx::Class</a> that&#x27;s it&#x27;s more a Relational to Object Mapper than an Object to Relational Mapper.<p>We&#x27;ve (I was the original author, bias alert) always had a policy of &quot;if you can&#x27;t convince it to produce the exact same query that you&#x27;d&#x27;ve written by hand, that&#x27;s either a bug or a missing feature.&quot;<p>Some of said features do still remain missing, because of course they do, but the attitude is hugely important nevertheless.<p>You&#x27;re doing an awesome thing here, and ... I&#x27;ve been considering trying to write a better ROM for JS on and off for a while, and though I may still do so anyway, assuming my sieve-like brain doesn&#x27;t forget about qustar first I think I should really talk to you about whether we can work together instead before I strike out on my own.</div><br/></div></div></div></div><div id="41456777" class="c"><input type="checkbox" id="c-41456777" checked=""/><div class="controls bullet"><span class="by">hk__2</span><span>|</span><a href="#41456573">parent</a><span>|</span><a href="#41456640">prev</a><span>|</span><a href="#41456604">next</a><span>|</span><label class="collapse" for="c-41456777">[-]</label><label class="expand" for="c-41456777">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve come to the conclusion that ORMs are good for simple queries like User.find_by(email: &quot;john@snow.com&quot;), but once you get beyond that you are better off just writing sql.<p>When your queries become very complex having a good ORM like SQLAlchemy in Python is a life-saver.</div><br/></div></div></div></div><div id="41456618" class="c"><input type="checkbox" id="c-41456618" checked=""/><div class="controls bullet"><span class="by">khy</span><span>|</span><a href="#41456573">prev</a><span>|</span><a href="#41456572">next</a><span>|</span><label class="collapse" for="c-41456618">[-]</label><label class="expand" for="c-41456618">[2 more]</label></div><br/><div class="children"><div class="content">Scala has a library called Slick which takes a similar approach: <a href="https:&#x2F;&#x2F;scala-slick.org" rel="nofollow">https:&#x2F;&#x2F;scala-slick.org</a><p>The DSL is nice for simple querying and for composing queries based upon user input. But, for anything slightly complex, I found it&#x27;s better to just use regular SQL.</div><br/></div></div></div></div></div></div></div></body></html>