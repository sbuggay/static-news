<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683040924099" as="style"/><link rel="stylesheet" href="styles.css?v=1683040924099"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.openmymind.net/SIMD-With-Zig/">SIMD with Zig</a>Â <span class="domain">(<a href="https://www.openmymind.net">www.openmymind.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>29 comments</span></div><br/><div><div id="35783863" class="c"><input type="checkbox" id="c-35783863" checked=""/><div class="controls bullet"><span class="by">Guzba</span><span>|</span><a href="#35783625">next</a><span>|</span><label class="collapse" for="c-35783863">[-]</label><label class="expand" for="c-35783863">[6 more]</label></div><br/><div class="children"><div class="content">Unless something has changed I really wish Zig was open to SIMD intrinsics. Imo, if you&#x27;re manually writing SIMD, you are doing complex performance-oriented programming and you really do end up needing to know what the instruction set you&#x27;re using gives you for tools. Eg arm64 has pretty cool interlacing&#x2F;deinterlacing which would be goofy to re-create on amd64 and there is subtlety to multiplication and lots of other things. SIMD instructions also sidestep lots of compiler-ey stuff like strict aliasing and types don&#x27;t matter, sizes and lane positions do. It is an interesting beast.</div><br/><div id="35783965" class="c"><input type="checkbox" id="c-35783965" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#35783863">parent</a><span>|</span><a href="#35785292">next</a><span>|</span><label class="collapse" for="c-35783965">[-]</label><label class="expand" for="c-35783965">[3 more]</label></div><br/><div class="children"><div class="content">This has been mentioned before:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;7702">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;7702</a><p>I don&#x27;t think anyone disagrees about the need for intrinsics. In fact, I have actually taken a crack at implementing the AVX512 intrinsics into the Zig compiler as builtin functions on my personal fork of the repo. But it is a non-trivial task - there are over 450 distinct instructions across the entire AVX512 feature set, and over 100 for AVX2. And I&#x27;m only focusing on support for the LLVM backend, which does the heavy lifting in the codegen phase. Getting the register allocation and instruction scheduling correct for all the intrinsics in the self hosted backend would involve a lot more work.</div><br/><div id="35785495" class="c"><input type="checkbox" id="c-35785495" checked=""/><div class="controls bullet"><span class="by">p0nce</span><span>|</span><a href="#35783863">root</a><span>|</span><a href="#35783965">parent</a><span>|</span><a href="#35784480">next</a><span>|</span><label class="collapse" for="c-35785495">[-]</label><label class="expand" for="c-35785495">[1 more]</label></div><br/><div class="children"><div class="content">What I do for D is implement the intrinsics following the semantics of the x86 instructions. Target x86, x86_64, arm32, arm64 with D compilers, that smoothes out the difference. It&#x27;s a lot of work, and very similar to the simd-everywhere library that does it for C++. There is not so much impendence mismatch between x86 and arm.
I wish more people would understand that you absolutely need such intrinsics for fast software, there is no way around that. You&#x27;re not going to write your 4x-at-once pow function for each arch, also you won&#x27;t find a better name for `_mm_madd_epi16`. (EDIT: I guess nowadays you could do that but with taking ARM semantics as source of truth).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;AuburnSounds&#x2F;intel-intrinsics">https:&#x2F;&#x2F;github.com&#x2F;AuburnSounds&#x2F;intel-intrinsics</a></div><br/></div></div><div id="35784480" class="c"><input type="checkbox" id="c-35784480" checked=""/><div class="controls bullet"><span class="by">Guzba</span><span>|</span><a href="#35783863">root</a><span>|</span><a href="#35783965">parent</a><span>|</span><a href="#35785495">prev</a><span>|</span><a href="#35785292">next</a><span>|</span><label class="collapse" for="c-35784480">[-]</label><label class="expand" for="c-35784480">[1 more]</label></div><br/><div class="children"><div class="content">I have not been monitoring the SIMD situation in Zig so it is nice to hear that there is some general support for intrinsics even if they are not yet added.<p>Thanks for your effort working on an implementation too. I am aware how large these instruction sets have gotten so I can at certainly imagine at least some of the effort of the undertaking.</div><br/></div></div></div></div><div id="35785292" class="c"><input type="checkbox" id="c-35785292" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#35783863">parent</a><span>|</span><a href="#35783965">prev</a><span>|</span><a href="#35786198">next</a><span>|</span><label class="collapse" for="c-35785292">[-]</label><label class="expand" for="c-35785292">[1 more]</label></div><br/><div class="children"><div class="content">For anybody interested in this, here is an article discussing a very similar problem using arm neon intrinsics, also using the interleaved loads: <a href="https:&#x2F;&#x2F;branchfree.org&#x2F;2019&#x2F;04&#x2F;01&#x2F;fitting-my-head-through-the-arm-holes-or-two-sequences-to-substitute-for-the-missing-pmovmskb-instruction-on-arm-neon&#x2F;" rel="nofollow">https:&#x2F;&#x2F;branchfree.org&#x2F;2019&#x2F;04&#x2F;01&#x2F;fitting-my-head-through-th...</a></div><br/></div></div><div id="35786198" class="c"><input type="checkbox" id="c-35786198" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#35783863">parent</a><span>|</span><a href="#35785292">prev</a><span>|</span><a href="#35783625">next</a><span>|</span><label class="collapse" for="c-35786198">[-]</label><label class="expand" for="c-35786198">[1 more]</label></div><br/><div class="children"><div class="content">Or even all target-specific intrinsics - not limited to SIMD ones.</div><br/></div></div></div></div><div id="35783625" class="c"><input type="checkbox" id="c-35783625" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#35783863">prev</a><span>|</span><a href="#35784073">next</a><span>|</span><label class="collapse" for="c-35783625">[-]</label><label class="expand" for="c-35783625">[13 more]</label></div><br/><div class="children"><div class="content">Nice. It would be even nicer, if Zig would support hot-dispatch for SIMD, i.e. the idea that the compiler can emit multiple versions of the same function&#x2F;code for a number of vector widths simultaneously and the runtime selects the best (widest) option available for the hardware running the code - this is something ISPC does and is incredibly useful for targeting a range of architectures.</div><br/><div id="35785581" class="c"><input type="checkbox" id="c-35785581" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35784146">next</a><span>|</span><label class="collapse" for="c-35785581">[-]</label><label class="expand" for="c-35785581">[2 more]</label></div><br/><div class="children"><div class="content">The issue with runtime instruction set detection and dynamic dispatch is that it needs to be at a rather coarse level to be beneficial.<p>Take a simple 4-wide dot product for example, on x86_64 you&#x27;d have 3-4 different implementations (SSE2, SSE3 w&#x2F; hadd, SSE4.2 w&#x2F; dpps). But the function itself is just a few clock cycles, and calling it via function pointer will eliminate any gains and you might as well compute it with a scalar loop at that point.<p>This is further compounded by inhibiting compiler optimizations. You can&#x27;t use the dot product function in higher level code expecting it to be inlined and further optimized (which is really the key to performance) if it&#x27;s behind a dynamic dispatch.<p>A sufficiently smart compiler could maybe propagate the dynamic dispatch above, so that all the dot products get inlined but all code using dot product would get emitted multiple times with different dot product implementations, with the dynamic dispatch only at the top level. This has a slight risk of combinatorial explosion, but there really aren&#x27;t that many combinations of supported ISAs in real hardware out there.<p>Another option you can use without any special compiler support is to take all your performance sensitive parts and pack them into a shared object&#x2F;dll, compile multiple versions with different compiler options and choose the correct dll at runtime. Or even build the entire executable a few times and have some kind of launcher pick the correct one.</div><br/><div id="35787326" class="c"><input type="checkbox" id="c-35787326" checked=""/><div class="controls bullet"><span class="by">kps</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35785581">parent</a><span>|</span><a href="#35784146">next</a><span>|</span><label class="collapse" for="c-35787326">[-]</label><label class="expand" for="c-35787326">[1 more]</label></div><br/><div class="children"><div class="content">What you say about dynamic dispatch also applies to regular function calls, which is why I&#x27;m disappointed that Zig provides no visible distinction at the call site between direct and indirect calls (as K&amp;R C did but ANSI C made optional).<p>I understand the desire for magic-indirection ergonomics; I just don&#x27;t think the tradeoffs work out the same for code vs data.</div><br/></div></div></div></div><div id="35784146" class="c"><input type="checkbox" id="c-35784146" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35785581">prev</a><span>|</span><a href="#35784115">next</a><span>|</span><label class="collapse" for="c-35784146">[-]</label><label class="expand" for="c-35784146">[1 more]</label></div><br/><div class="children"><div class="content">This is called [function multi-versioning](<a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018</a>).</div><br/></div></div><div id="35784115" class="c"><input type="checkbox" id="c-35784115" checked=""/><div class="controls bullet"><span class="by">Laremere</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35784146">prev</a><span>|</span><a href="#35784143">next</a><span>|</span><label class="collapse" for="c-35784115">[-]</label><label class="expand" for="c-35784115">[1 more]</label></div><br/><div class="children"><div class="content">While Zig doesn&#x27;t support this automatically, I think there&#x27;s a path towards this thanks to comptime support.  For example:<p><pre><code>    const std = @import(&quot;std&quot;);

    fn f(comptime width: comptime_int, value: i32) i32 {
        const v = @splat(width, @as(i32, value));
        return @reduce(.Add, v);
    }

    pub fn main() !void {
        std.debug.print(&quot;1={d}\n&quot;, .{f(1, 5)});
        std.debug.print(&quot;2={d}\n&quot;, .{f(2, 5)});
        std.debug.print(&quot;4={d}\n&quot;, .{f(4, 5)});
    }
</code></pre>
Here it creates 3 different versions of the function f at compile time, and then calls them each in succession.  Running it prints:<p><pre><code>  1=5
  2=10
  4=20
</code></pre>
In practice you&#x27;d need to set up a dispatch that chooses the function based on the hardware, and ensure that zig&#x2F;LLVM are actually using the full width of the vectors when compiling.</div><br/></div></div><div id="35784143" class="c"><input type="checkbox" id="c-35784143" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35784115">prev</a><span>|</span><a href="#35783727">next</a><span>|</span><label class="collapse" for="c-35784143">[-]</label><label class="expand" for="c-35784143">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s planned: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018</a></div><br/></div></div><div id="35783727" class="c"><input type="checkbox" id="c-35783727" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35784143">prev</a><span>|</span><a href="#35784073">next</a><span>|</span><label class="collapse" for="c-35783727">[-]</label><label class="expand" for="c-35783727">[7 more]</label></div><br/><div class="children"><div class="content">Zig the language doesn&#x27;t do this right away, but:<p>1. IMO it&#x27;d be a bit more ziggish to branch at compile time. Zig has cross-compilation as a first-class feature, and you generally know the architecture you&#x27;re targeting.<p>2. Whether you&#x27;re branching at runtime or compile time, it&#x27;d be easy to build a vectored app with that behavior. The first thing that comes to mind is having code that&#x27;s generic on the vector type (or bit width) and then just choosing which generic to instantiate in an inline for loop in your app&#x27;s entrypoint.<p>3. A lot of the time you don&#x27;t need that behavior. Select a vector width 8x too big, ensure your data is chunked into multiples of that, and rely on the compiler to break that down into a few instructions of the appropriate length. You can&#x27;t effectively target a GPU that way, and it&#x27;s not the same as hand-tuned assembly, but you get decent results on a vast array of problems.</div><br/><div id="35786488" class="c"><input type="checkbox" id="c-35786488" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35783727">parent</a><span>|</span><a href="#35785468">next</a><span>|</span><label class="collapse" for="c-35786488">[-]</label><label class="expand" for="c-35786488">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t branch at compile time. Well, you <i>can</i>, but that&#x27;s less useful than branching at runtime. If you branch at compile time, then you need to produce binaries that have a minimum supported ISA extension. But if you branch at runtime, then you can produce maximally portable binaries that only use ISA extensions when they&#x27;re available.</div><br/></div></div><div id="35785468" class="c"><input type="checkbox" id="c-35785468" checked=""/><div class="controls bullet"><span class="by">p0nce</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35783727">parent</a><span>|</span><a href="#35786488">prev</a><span>|</span><a href="#35784196">next</a><span>|</span><label class="collapse" for="c-35785468">[-]</label><label class="expand" for="c-35785468">[2 more]</label></div><br/><div class="children"><div class="content">Counterpoint: it&#x27;s not all positive to do multiversioning.<p>- You pay for it in build times, more IR, more optimizations.<p>- a lot of software is for servers, in that case you mostly know the arch before-hand. Multi-versioning is best for consumer software.<p>- The lowest spec computers, in consumer software, need the optimizations the most. And they don&#x27;t have latest instructions.<p>- SIMD has biggest gains from memory optimizations, and those do not necessarily require the latest and greatest instructions.</div><br/><div id="35786537" class="c"><input type="checkbox" id="c-35786537" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35785468">parent</a><span>|</span><a href="#35784196">next</a><span>|</span><label class="collapse" for="c-35786537">[-]</label><label class="expand" for="c-35786537">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. This is how ripgrep works. It&#x27;s compiled for just plain `x86_64`, but it looks for whether things like AVX2 are enabled. And if so, uses vector algorithms for substring and multi-substring search. The nice thing about dealing with strings is that the &quot;coarse&quot; requirement is already somewhat natural to the domain.<p>But, this functionality is absolutely critical. It doesn&#x27;t even have to be automatic. Just the ability to compile functions with certain ISA extensions enabled, and then only call them when the requisite CPU features are enabled is enough.<p>In a nutshell: <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;memchr&#x2F;blob&#x2F;8037d11b4357b0f07be2bb66dc2659d9cf28ad32&#x2F;src&#x2F;memchr&#x2F;x86&#x2F;mod.rs">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;memchr&#x2F;blob&#x2F;8037d11b4357b0f07b...</a></div><br/></div></div></div></div><div id="35784196" class="c"><input type="checkbox" id="c-35784196" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35783727">parent</a><span>|</span><a href="#35785468">prev</a><span>|</span><a href="#35785015">next</a><span>|</span><label class="collapse" for="c-35784196">[-]</label><label class="expand" for="c-35784196">[1 more]</label></div><br/><div class="children"><div class="content">Counterpoint for 1: packages on PyPI or NPM. When Iâm publishing an extension for another language. I really have no idea about their architecture.<p>Iâve seen people just compile for the lowest common denominator. E.g. faiss-cpu on PyPI doesnât even include AVX2 and is slow as heck.</div><br/></div></div><div id="35785015" class="c"><input type="checkbox" id="c-35785015" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35783727">parent</a><span>|</span><a href="#35784196">prev</a><span>|</span><a href="#35785454">next</a><span>|</span><label class="collapse" for="c-35785015">[-]</label><label class="expand" for="c-35785015">[1 more]</label></div><br/><div class="children"><div class="content">Architecture yes, but specific feature set, including exact support for each incremental revision of the SIMD instruction and register set, not so much. If you&#x27;re e.g. providing a docker image for a service, it&#x27;s fine to build per architecture, but you don&#x27;t want the hassle of producing a different one for SSE4, SSE4.1, SSE4.2, SSE4a and so on.</div><br/></div></div><div id="35785454" class="c"><input type="checkbox" id="c-35785454" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35783727">parent</a><span>|</span><a href="#35785015">prev</a><span>|</span><a href="#35784073">next</a><span>|</span><label class="collapse" for="c-35785454">[-]</label><label class="expand" for="c-35785454">[1 more]</label></div><br/><div class="children"><div class="content">regarding point 2, it&#x27;s not that simple. A lot of 256-bit-wide goodies are in AVX-512 and a lot of different sets of extensions exist.</div><br/></div></div></div></div></div></div><div id="35784073" class="c"><input type="checkbox" id="c-35784073" checked=""/><div class="controls bullet"><span class="by">ayende</span><span>|</span><a href="#35783625">prev</a><span>|</span><a href="#35784264">next</a><span>|</span><label class="collapse" for="c-35784073">[-]</label><label class="expand" for="c-35784073">[2 more]</label></div><br/><div class="children"><div class="content">A better option here would be to use `_mm_movemask_epi8`, for the vector:<p>```
{ false, false, false, false, true, false, false, true }
```<p>It will give an int with the bits: `0b0000_1001`<p>You can then do `@clz` to get the index of the first set bit.<p>That would save you the `@reduce` and `@splat`. I don&#x27;t see how to access move mask from Zig, however.<p>Note that the standard library has `std.zig.firstIndexOfValue`, which does what you have in the post, basically. And there is `std.zig.firstTrue`, which does the the same thing as `@clz` in this case, but I don&#x27;t know what kind of assembly it will generate.</div><br/><div id="35788862" class="c"><input type="checkbox" id="c-35788862" checked=""/><div class="controls bullet"><span class="by">e4m2</span><span>|</span><a href="#35784073">parent</a><span>|</span><a href="#35784264">next</a><span>|</span><label class="collapse" for="c-35788862">[-]</label><label class="expand" for="c-35788862">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t see how to access move mask from Zig, however.<p>Bools in a vector each only occupy one bit. You can @bitCast an N element bool vector directly to a uN integer and it will generate movemask on x86.</div><br/></div></div></div></div><div id="35784264" class="c"><input type="checkbox" id="c-35784264" checked=""/><div class="controls bullet"><span class="by">vincnetas</span><span>|</span><a href="#35784073">prev</a><span>|</span><a href="#35784371">next</a><span>|</span><label class="collapse" for="c-35784264">[-]</label><label class="expand" for="c-35784264">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m missing benchmark. Of course it might be obvious to experienced developers that this is faster. But it would be nice to see how much faster it is.</div><br/><div id="35785402" class="c"><input type="checkbox" id="c-35785402" checked=""/><div class="controls bullet"><span class="by">larsnystrom</span><span>|</span><a href="#35784264">parent</a><span>|</span><a href="#35784371">next</a><span>|</span><label class="collapse" for="c-35785402">[-]</label><label class="expand" for="c-35785402">[2 more]</label></div><br/><div class="children"><div class="content">The author mentions this at the end of the article:<p>&gt; You need to benchmark, test and tweak in order to figure out what works best. Benchmarking is particularly important because, unless you&#x27;re dealing with large data or very hot code, there&#x27;s a good chance that effort won&#x27;t yield measurable benefits.<p>How to benchmark something like this sounds like it could become a pretty good article in its own right.</div><br/><div id="35787315" class="c"><input type="checkbox" id="c-35787315" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#35784264">root</a><span>|</span><a href="#35785402">parent</a><span>|</span><a href="#35784371">next</a><span>|</span><label class="collapse" for="c-35787315">[-]</label><label class="expand" for="c-35787315">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How to benchmark something like this<p>Usually, you can run something like perf or callgrind, with instruction level profiling, and you will get a good idea. Its not benchmarking in the traditional sense, but it has a similar result.<p>SIMD can make your code faster, or slower - profiling is a great way to tell exactly how much faster or slower.</div><br/></div></div></div></div></div></div><div id="35784371" class="c"><input type="checkbox" id="c-35784371" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#35784264">prev</a><span>|</span><a href="#35783546">next</a><span>|</span><label class="collapse" for="c-35784371">[-]</label><label class="expand" for="c-35784371">[3 more]</label></div><br/><div class="children"><div class="content">Very nice write-up, as someone feeling somewhat left behind by the Zig train it&#x27;s always nice to get a refreshed feeling for the language.<p>I had to go look up &quot;std.mem.indexOfSclar&quot; in the source [1] since my, admittedly rather butt-hurt, feeling is that I can&#x27;t guess Zig naming. It&#x27;s supposed to be &quot;indexOfScalar&quot; which of course makes 100% sense.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;mem.zig#L969">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;mem.zig#L...</a></div><br/><div id="35784568" class="c"><input type="checkbox" id="c-35784568" checked=""/><div class="controls bullet"><span class="by">inexcf</span><span>|</span><a href="#35784371">parent</a><span>|</span><a href="#35783546">next</a><span>|</span><label class="collapse" for="c-35784568">[-]</label><label class="expand" for="c-35784568">[2 more]</label></div><br/><div class="children"><div class="content">A bit confused about what you are saying. Was &quot;std.mem.indexOfSclar&quot; a typo on the site that was fixed within 15 mins of you posting or did you just misread it? Is there something about Zig function naming that makes it weird?</div><br/><div id="35784641" class="c"><input type="checkbox" id="c-35784641" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#35784371">root</a><span>|</span><a href="#35784568">parent</a><span>|</span><a href="#35783546">next</a><span>|</span><label class="collapse" for="c-35784641">[-]</label><label class="expand" for="c-35784641">[1 more]</label></div><br/><div class="children"><div class="content">Yes, a typo. I fixed the post.</div><br/></div></div></div></div></div></div><div id="35783546" class="c"><input type="checkbox" id="c-35783546" checked=""/><div class="controls bullet"><span class="by">kamikaz1k</span><span>|</span><a href="#35784371">prev</a><span>|</span><label class="collapse" for="c-35783546">[-]</label><label class="expand" for="c-35783546">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the clear write up. This is very helpful for my understanding</div><br/></div></div></div></div></div></div></div></body></html>