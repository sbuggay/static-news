<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683018043545" as="style"/><link rel="stylesheet" href="styles.css?v=1683018043545"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.openmymind.net/SIMD-With-Zig/">SIMD with Zig</a> <span class="domain">(<a href="https://www.openmymind.net">www.openmymind.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>16 comments</span></div><br/><div><div id="35783625" class="c"><input type="checkbox" id="c-35783625" checked=""/><div class="controls bullet"><span class="by">kookamamie</span><span>|</span><a href="#35784073">next</a><span>|</span><label class="collapse" for="c-35783625">[-]</label><label class="expand" for="c-35783625">[6 more]</label></div><br/><div class="children"><div class="content">Nice. It would be even nicer, if Zig would support hot-dispatch for SIMD, i.e. the idea that the compiler can emit multiple versions of the same function&#x2F;code for a number of vector widths simultaneously and the runtime selects the best (widest) option available for the hardware running the code - this is something ISPC does and is incredibly useful for targeting a range of architectures.</div><br/><div id="35784146" class="c"><input type="checkbox" id="c-35784146" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35783727">next</a><span>|</span><label class="collapse" for="c-35784146">[-]</label><label class="expand" for="c-35784146">[1 more]</label></div><br/><div class="children"><div class="content">This is called [function multi-versioning](<a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018</a>).</div><br/></div></div><div id="35783727" class="c"><input type="checkbox" id="c-35783727" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35784146">prev</a><span>|</span><a href="#35784115">next</a><span>|</span><label class="collapse" for="c-35783727">[-]</label><label class="expand" for="c-35783727">[2 more]</label></div><br/><div class="children"><div class="content">Zig the language doesn&#x27;t do this right away, but:<p>1. IMO it&#x27;d be a bit more ziggish to branch at compile time. Zig has cross-compilation as a first-class feature, and you generally know the architecture you&#x27;re targeting.<p>2. Whether you&#x27;re branching at runtime or compile time, it&#x27;d be easy to build a vectored app with that behavior. The first thing that comes to mind is having code that&#x27;s generic on the vector type (or bit width) and then just choosing which generic to instantiate in an inline for loop in your app&#x27;s entrypoint.<p>3. A lot of the time you don&#x27;t need that behavior. Select a vector width 8x too big, ensure your data is chunked into multiples of that, and rely on the compiler to break that down into a few instructions of the appropriate length. You can&#x27;t effectively target a GPU that way, and it&#x27;s not the same as hand-tuned assembly, but you get decent results on a vast array of problems.</div><br/><div id="35784196" class="c"><input type="checkbox" id="c-35784196" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#35783625">root</a><span>|</span><a href="#35783727">parent</a><span>|</span><a href="#35784115">next</a><span>|</span><label class="collapse" for="c-35784196">[-]</label><label class="expand" for="c-35784196">[1 more]</label></div><br/><div class="children"><div class="content">Counterpoint for 1: packages on PyPI or NPM. When I’m publishing an extension for another language. I really have no idea about their architecture.<p>I’ve seen people just compile for the lowest common denominator. E.g. faiss-cpu on PyPI doesn’t even include AVX2 and is slow as heck.</div><br/></div></div></div></div><div id="35784115" class="c"><input type="checkbox" id="c-35784115" checked=""/><div class="controls bullet"><span class="by">Laremere</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35783727">prev</a><span>|</span><a href="#35784143">next</a><span>|</span><label class="collapse" for="c-35784115">[-]</label><label class="expand" for="c-35784115">[1 more]</label></div><br/><div class="children"><div class="content">While Zig doesn&#x27;t support this automatically, I think there&#x27;s a path towards this thanks to comptime support.  For example:<p><pre><code>    const std = @import(&quot;std&quot;);

    fn f(comptime width: comptime_int, value: i32) i32 {
        const v = @splat(width, @as(i32, value));
        return @reduce(.Add, v);
    }

    pub fn main() !void {
        std.debug.print(&quot;1={d}\n&quot;, .{f(1, 5)});
        std.debug.print(&quot;2={d}\n&quot;, .{f(2, 5)});
        std.debug.print(&quot;4={d}\n&quot;, .{f(4, 5)});
    }
</code></pre>
Here it creates 3 different versions of the function f at compile time, and then calls them each in succession.  Running it prints:<p><pre><code>  1=5
  2=10
  4=20
</code></pre>
In practice you&#x27;d need to set up a dispatch that chooses the function based on the hardware, and ensure that zig&#x2F;LLVM are actually using the full width of the vectors when compiling.</div><br/></div></div><div id="35784143" class="c"><input type="checkbox" id="c-35784143" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#35783625">parent</a><span>|</span><a href="#35784115">prev</a><span>|</span><a href="#35784073">next</a><span>|</span><label class="collapse" for="c-35784143">[-]</label><label class="expand" for="c-35784143">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s planned: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1018</a></div><br/></div></div></div></div><div id="35784073" class="c"><input type="checkbox" id="c-35784073" checked=""/><div class="controls bullet"><span class="by">ayende</span><span>|</span><a href="#35783625">prev</a><span>|</span><a href="#35784264">next</a><span>|</span><label class="collapse" for="c-35784073">[-]</label><label class="expand" for="c-35784073">[1 more]</label></div><br/><div class="children"><div class="content">A better option here would be to use `_mm_movemask_epi8`, for the vector:<p>```
{ false, false, false, false, true, false, false, true }
```<p>It will give an int with the bits: `0b0000_1001`<p>You can then do `@clz` to get the index of the first set bit.<p>That would save you the `@reduce` and `@splat`. I don&#x27;t see how to access move mask from Zig, however.<p>Note that the standard library has `std.zig.firstIndexOfValue`, which does what you have in the post, basically. And there is `std.zig.firstTrue`, which does the the same thing as `@clz` in this case, but I don&#x27;t know what kind of assembly it will generate.</div><br/></div></div><div id="35784264" class="c"><input type="checkbox" id="c-35784264" checked=""/><div class="controls bullet"><span class="by">vincnetas</span><span>|</span><a href="#35784073">prev</a><span>|</span><a href="#35783863">next</a><span>|</span><label class="collapse" for="c-35784264">[-]</label><label class="expand" for="c-35784264">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m missing benchmark. Of course it might be obvious to experienced developers that this is faster. But it would be nice to see how much faster it is.</div><br/></div></div><div id="35783863" class="c"><input type="checkbox" id="c-35783863" checked=""/><div class="controls bullet"><span class="by">Guzba</span><span>|</span><a href="#35784264">prev</a><span>|</span><a href="#35784371">next</a><span>|</span><label class="collapse" for="c-35783863">[-]</label><label class="expand" for="c-35783863">[3 more]</label></div><br/><div class="children"><div class="content">Unless something has changed I really wish Zig was open to SIMD intrinsics. Imo, if you&#x27;re manually writing SIMD, you are doing complex performance-oriented programming and you really do end up needing to know what the instruction set you&#x27;re using gives you for tools. Eg arm64 has pretty cool interlacing&#x2F;deinterlacing which would be goofy to re-create on amd64 and there is subtlety to multiplication and lots of other things. SIMD instructions also sidestep lots of compiler-ey stuff like strict aliasing and types don&#x27;t matter, sizes and lane positions do. It is an interesting beast.</div><br/><div id="35783965" class="c"><input type="checkbox" id="c-35783965" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#35783863">parent</a><span>|</span><a href="#35784371">next</a><span>|</span><label class="collapse" for="c-35783965">[-]</label><label class="expand" for="c-35783965">[2 more]</label></div><br/><div class="children"><div class="content">This has been mentioned before:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;7702">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;7702</a><p>I don&#x27;t think anyone disagrees about the need for intrinsics. In fact, I have actually taken a crack at implementing the AVX512 intrinsics into the Zig compiler as builtin functions on my personal fork of the repo. But it is a non-trivial task - there are over 450 distinct instructions across the entire AVX512 feature set, and over 100 for AVX2. And I&#x27;m only focusing on support for the LLVM backend, which does the heavy lifting in the codegen phase. Getting the register allocation and instruction scheduling correct for all the intrinsics in the self hosted backend would involve a lot more work.</div><br/><div id="35784480" class="c"><input type="checkbox" id="c-35784480" checked=""/><div class="controls bullet"><span class="by">Guzba</span><span>|</span><a href="#35783863">root</a><span>|</span><a href="#35783965">parent</a><span>|</span><a href="#35784371">next</a><span>|</span><label class="collapse" for="c-35784480">[-]</label><label class="expand" for="c-35784480">[1 more]</label></div><br/><div class="children"><div class="content">I have not been monitoring the SIMD situation in Zig so it is nice to hear that there is some general support for intrinsics even if they are not yet added.<p>Thanks for your effort working on an implementation too. I am aware how large these instruction sets have gotten so I can at certainly imagine at least some of the effort of the undertaking.</div><br/></div></div></div></div></div></div><div id="35784371" class="c"><input type="checkbox" id="c-35784371" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#35783863">prev</a><span>|</span><a href="#35783546">next</a><span>|</span><label class="collapse" for="c-35784371">[-]</label><label class="expand" for="c-35784371">[3 more]</label></div><br/><div class="children"><div class="content">Very nice write-up, as someone feeling somewhat left behind by the Zig train it&#x27;s always nice to get a refreshed feeling for the language.<p>I had to go look up &quot;std.mem.indexOfSclar&quot; in the source [1] since my, admittedly rather butt-hurt, feeling is that I can&#x27;t guess Zig naming. It&#x27;s supposed to be &quot;indexOfScalar&quot; which of course makes 100% sense.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;mem.zig#L969">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;master&#x2F;lib&#x2F;std&#x2F;mem.zig#L...</a></div><br/><div id="35784568" class="c"><input type="checkbox" id="c-35784568" checked=""/><div class="controls bullet"><span class="by">inexcf</span><span>|</span><a href="#35784371">parent</a><span>|</span><a href="#35783546">next</a><span>|</span><label class="collapse" for="c-35784568">[-]</label><label class="expand" for="c-35784568">[2 more]</label></div><br/><div class="children"><div class="content">A bit confused about what you are saying. Was &quot;std.mem.indexOfSclar&quot; a typo on the site that was fixed within 15 mins of you posting or did you just misread it? Is there something about Zig function naming that makes it weird?</div><br/><div id="35784641" class="c"><input type="checkbox" id="c-35784641" checked=""/><div class="controls bullet"><span class="by">latch</span><span>|</span><a href="#35784371">root</a><span>|</span><a href="#35784568">parent</a><span>|</span><a href="#35783546">next</a><span>|</span><label class="collapse" for="c-35784641">[-]</label><label class="expand" for="c-35784641">[1 more]</label></div><br/><div class="children"><div class="content">Yes, a typo. I fixed the post.</div><br/></div></div></div></div></div></div><div id="35783546" class="c"><input type="checkbox" id="c-35783546" checked=""/><div class="controls bullet"><span class="by">kamikaz1k</span><span>|</span><a href="#35784371">prev</a><span>|</span><label class="collapse" for="c-35783546">[-]</label><label class="expand" for="c-35783546">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the clear write up. This is very helpful for my understanding</div><br/></div></div></div></div></div></div></div></body></html>