<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724576472774" as="style"/><link rel="stylesheet" href="styles.css?v=1724576472774"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fasterthanli.me/articles/small-strings-in-rust">Small Strings in Rust: smolstr vs. smartstring</a>Â <span class="domain">(<a href="https://fasterthanli.me">fasterthanli.me</a>)</span></div><div class="subtext"><span>airstrike</span> | <span>71 comments</span></div><br/><div><div id="41339224" class="c"><input type="checkbox" id="c-41339224" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#41339392">next</a><span>|</span><label class="collapse" for="c-41339224">[-]</label><label class="expand" for="c-41339224">[41 more]</label></div><br/><div class="children"><div class="content">On the note of small strings, Compact String[1] was i believed released after this article and has a nifty trick. Where Smol and Smart can fit 22 and 23 bytes, CompactStr can fit 24! Which is kinda nutty imo, that&#x27;s the full size of the normal String on the stack.. but packed with actual string data.<p>There&#x27;s a nice explanation on their readme[2]. Love tricks like this.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ParkMyCar&#x2F;compact_str">https:&#x2F;&#x2F;github.com&#x2F;ParkMyCar&#x2F;compact_str</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ParkMyCar&#x2F;compact_str?tab=readme-ov-file#how-it-works">https:&#x2F;&#x2F;github.com&#x2F;ParkMyCar&#x2F;compact_str?tab=readme-ov-file#...</a></div><br/><div id="41341933" class="c"><input type="checkbox" id="c-41341933" checked=""/><div class="controls bullet"><span class="by">parkmycar</span><span>|</span><a href="#41339224">parent</a><span>|</span><a href="#41339357">next</a><span>|</span><label class="collapse" for="c-41341933">[-]</label><label class="expand" for="c-41341933">[12 more]</label></div><br/><div class="children"><div class="content">Hey I&#x27;m the author of compact_str, thanks for the kind words!<p>Fun fact, it was this fasterthanlime post that originally inspired me to play around with small strings and led to the creation of compact_str.</div><br/><div id="41345365" class="c"><input type="checkbox" id="c-41345365" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41341933">parent</a><span>|</span><a href="#41345288">next</a><span>|</span><label class="collapse" for="c-41345365">[-]</label><label class="expand" for="c-41345365">[1 more]</label></div><br/><div class="children"><div class="content">Do you think it is possible to integrate this with an existing string interner in the Rust ecosystem? Or one would need to roll their own?<p>The goal would be to compare two strings using only the 24-byte values, without touching the allocated part (if it points into a string larger than 24 bytes)<p>The first thing that makes me think this is impossible is that you only define an owned variant for your string type. But your can cleverly wrap a &amp;&#x27;static str rather than allocate on heap, so if the interner can give a &amp;&#x27;static str I think this could work, with some boilerplate. Namely: for strings smaller than 24 bytes don&#x27;t intern and build a CompactString inline, for larger strings, intern, get a &amp;&#x27;static str, then build a CompactString out of it. Then, two check if two strings are equal, you just compare its 24 bytes, and don&#x27;t need to touch the interner for this at all.<p>However this only works if the interner actually leaks memory. If it returns you a &amp;&#x27;a str that isn&#x27;t &#x27;static, then you can&#x27;t store it on CompactString, unless your lib also provided a borrowed variant.<p>Also, to think about it, since interned strings are immutable (they are not a &quot;string builder&quot; like String is), you don&#x27;t really need the capacity value for them, just the length. So it suggests a 16 bytes size, not 24. (but one could imagine an application where it&#x27;s optimal to store 24 bytes inline rather than 16 anyway)<p>I think that this could be achieved with an 16 bytes &amp;str wrapper, maybe something like &amp;CompactStr, that works just like your CompactString, but wraps a &amp;str instead (and offers no owned variant). Maybe such a thing <i>could</i> conceivably be included in the compact_string crate?<p>(Maybe make it 24 bytes even if it &quot;wastes&quot; some bytes, just to make it bitwise compatible with CompactString, so that borrowing CompactString into &amp;CompactStr is zero cost - and then just zero out the remaining 8 bytes when a &amp;CompactStr is stored on the heap)<p>[0] I was reading this post <a href="https:&#x2F;&#x2F;dev.to&#x2F;cad97&#x2F;string-interners-in-rust-797" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;cad97&#x2F;string-interners-in-rust-797</a> that was written in response to this fasterthanlime post, but it contrasts interner with small string optimization, when you actually could have both!</div><br/></div></div><div id="41345288" class="c"><input type="checkbox" id="c-41345288" checked=""/><div class="controls bullet"><span class="by">hvenev</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41341933">parent</a><span>|</span><a href="#41345365">prev</a><span>|</span><a href="#41342471">next</a><span>|</span><label class="collapse" for="c-41345288">[-]</label><label class="expand" for="c-41345288">[1 more]</label></div><br/><div class="children"><div class="content">Is 26 characters next? I think the number of bytestrings of length &lt;= 26 that are also valid UTF-8 is only 0.021 * 256^24.</div><br/></div></div><div id="41342471" class="c"><input type="checkbox" id="c-41342471" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41341933">parent</a><span>|</span><a href="#41345288">prev</a><span>|</span><a href="#41342310">next</a><span>|</span><label class="collapse" for="c-41342471">[-]</label><label class="expand" for="c-41342471">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been wondering something for ages. Where did you get the 24 byte number, and how does it compare in Unicode terms? That is, did you analyze a large corpus and determine that 24 bytes was right for the largest number of strings? And does it come out to, say, 10 Unicode characters? Whenever I think about designing a new language, this very issue pops up.</div><br/><div id="41344541" class="c"><input type="checkbox" id="c-41344541" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342471">parent</a><span>|</span><a href="#41342936">next</a><span>|</span><label class="collapse" for="c-41344541">[-]</label><label class="expand" for="c-41344541">[1 more]</label></div><br/><div class="children"><div class="content">To add some more detail to sibling&#x27;s answer:<p>The optimal size will depend on the application. It&#x27;s certainly reasonable that in some applications, many&#x2F;most strings would be under 24 bytes and thus the small string optimization in many of these implementations would be beneficial. Perhaps in some other application strings are closer to 32 bytes (or something else) and then a larger stack size would be warranted. And in yet other applications, strings are large and no small string optimizations will make any difference, and if anything will slow the application down with unnecessary bookkeeping.<p>I do find it surprising that none of the implementations in the various comments linked in this thread seem to provide user-tunable sizes; or at least I haven&#x27;t seen it. Because I can certainly imagine cases where the optimal size is &gt; 24.</div><br/></div></div><div id="41342936" class="c"><input type="checkbox" id="c-41342936" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342471">parent</a><span>|</span><a href="#41344541">prev</a><span>|</span><a href="#41344340">next</a><span>|</span><label class="collapse" for="c-41342936">[-]</label><label class="expand" for="c-41342936">[4 more]</label></div><br/><div class="children"><div class="content">This style of small string optimization tries to take up the same amount of space on the stack as a &quot;normal&quot; heap-allocated string. On 64-bit platforms that is 24 bytes: 8 bytes for the pointer to the heap allocation, 8 bytes for the number of characters&#x2F;bytes in the string, and 8 bytes for the allocation capacity.<p>It&#x27;s quite possible to make the small string buffer larger, but that comes at the cost of the large string representation taking up more space than necessary on the stack. IIRC libstdc++ does this, which makes its std::string take up 32 bytes on the stack.</div><br/><div id="41344348" class="c"><input type="checkbox" id="c-41344348" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342936">parent</a><span>|</span><a href="#41344340">next</a><span>|</span><label class="collapse" for="c-41344348">[-]</label><label class="expand" for="c-41344348">[3 more]</label></div><br/><div class="children"><div class="content">Oh! So the string itself is still on the heap? I assumed it was all on the stack.</div><br/><div id="41344467" class="c"><input type="checkbox" id="c-41344467" checked=""/><div class="controls bullet"><span class="by">super_flanker</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41344348">parent</a><span>|</span><a href="#41344340">next</a><span>|</span><label class="collapse" for="c-41344467">[-]</label><label class="expand" for="c-41344467">[2 more]</label></div><br/><div class="children"><div class="content">No, let me try to explain differently. If `compact_str` was not used, then your normal `String` would take 24 bytes of stack space (regardless of the string size) + heap space. What `compact_str` is trying to do is not use heap when string content is less than 24.</div><br/><div id="41344724" class="c"><input type="checkbox" id="c-41344724" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41344467">parent</a><span>|</span><a href="#41344340">next</a><span>|</span><label class="collapse" for="c-41344724">[-]</label><label class="expand" for="c-41344724">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. That aligns with what I originally thought.</div><br/></div></div></div></div></div></div></div></div><div id="41344340" class="c"><input type="checkbox" id="c-41344340" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342471">parent</a><span>|</span><a href="#41342936">prev</a><span>|</span><a href="#41342310">next</a><span>|</span><label class="collapse" for="c-41344340">[-]</label><label class="expand" for="c-41344340">[1 more]</label></div><br/><div class="children"><div class="content">Not sure why the downvotes? This is a sincere question.</div><br/></div></div></div></div><div id="41342310" class="c"><input type="checkbox" id="c-41342310" checked=""/><div class="controls bullet"><span class="by">conaclos</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41341933">parent</a><span>|</span><a href="#41342471">prev</a><span>|</span><a href="#41339357">next</a><span>|</span><label class="collapse" for="c-41342310">[-]</label><label class="expand" for="c-41342310">[2 more]</label></div><br/><div class="children"><div class="content">compact_str is a fantastic crate, used by many projects. Do you know the byteyarn crate [0]? This could be nice to add this to the `Similar Crates` section if it makes sense.<p>[0] <a href="https:&#x2F;&#x2F;docs.rs&#x2F;byteyarn&#x2F;latest&#x2F;byteyarn&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;byteyarn&#x2F;latest&#x2F;byteyarn&#x2F;</a></div><br/><div id="41342441" class="c"><input type="checkbox" id="c-41342441" checked=""/><div class="controls bullet"><span class="by">parkmycar</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342310">parent</a><span>|</span><a href="#41339357">next</a><span>|</span><label class="collapse" for="c-41342441">[-]</label><label class="expand" for="c-41342441">[1 more]</label></div><br/><div class="children"><div class="content">I do, mcyoung wrote a great blogpost[1] about it! Good idea, Iâm AFK at the moment but will add it to the âSimilar Cratesâ section once Iâm back<p>[1] <a href="https:&#x2F;&#x2F;mcyoung.xyz&#x2F;2023&#x2F;08&#x2F;09&#x2F;yarns&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mcyoung.xyz&#x2F;2023&#x2F;08&#x2F;09&#x2F;yarns&#x2F;</a></div><br/></div></div></div></div></div></div><div id="41339357" class="c"><input type="checkbox" id="c-41339357" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41339224">parent</a><span>|</span><a href="#41341933">prev</a><span>|</span><a href="#41340448">next</a><span>|</span><label class="collapse" for="c-41339357">[-]</label><label class="expand" for="c-41339357">[21 more]</label></div><br/><div class="children"><div class="content">Note for C++ developers: Their trick is only possible because the strings are UTF-8 and not null-terminated. It wouldn&#x27;t work as a drop-in for standard strings in C++.</div><br/><div id="41339599" class="c"><input type="checkbox" id="c-41339599" checked=""/><div class="controls bullet"><span class="by">kloop</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339357">parent</a><span>|</span><a href="#41339706">next</a><span>|</span><label class="collapse" for="c-41339599">[-]</label><label class="expand" for="c-41339599">[12 more]</label></div><br/><div class="children"><div class="content">std::string isn&#x27;t null terminated (or at least it isn&#x27;t guaranteed to be, I don&#x27;t think it&#x27;s forbidden for an implementation to do that).<p>That&#x27;s why the c_str method exists, so you can get a pointer to a null terminated character array</div><br/><div id="41339702" class="c"><input type="checkbox" id="c-41339702" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339599">parent</a><span>|</span><a href="#41339688">next</a><span>|</span><label class="collapse" for="c-41339702">[-]</label><label class="expand" for="c-41339702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; std::string isn&#x27;t null terminated<p>It is as of C++11. The constness of c_str() threw a wrench into that as soon as C++ got a threading model.</div><br/></div></div><div id="41339688" class="c"><input type="checkbox" id="c-41339688" checked=""/><div class="controls bullet"><span class="by">unclad5968</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339599">parent</a><span>|</span><a href="#41339702">prev</a><span>|</span><a href="#41339622">next</a><span>|</span><label class="collapse" for="c-41339688">[-]</label><label class="expand" for="c-41339688">[8 more]</label></div><br/><div class="children"><div class="content">std::string is guaranteed to be null terminated since c++11.<p>std::string::c_str returns the same address as &amp;string[0]</div><br/><div id="41339728" class="c"><input type="checkbox" id="c-41339728" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339688">parent</a><span>|</span><a href="#41339622">next</a><span>|</span><label class="collapse" for="c-41339728">[-]</label><label class="expand" for="c-41339728">[7 more]</label></div><br/><div class="children"><div class="content">&gt; std::string::c_str returns the same address as &amp;string[0]<p>Note that this by itself doesn&#x27;t imply null-termination, though as you say strings are indeed null-terminated now.<p>Edit: This is not particularly obvious, but the reason this has nothing to do with allocation or the return value is that the implementation could still leave space for the null terminator, but avoid actually setting it to zero until c_str() is invoked. That would neither affect the returned pointer nor the constant-time guarantee.</div><br/><div id="41343606" class="c"><input type="checkbox" id="c-41343606" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339728">parent</a><span>|</span><a href="#41340037">next</a><span>|</span><label class="collapse" for="c-41343606">[-]</label><label class="expand" for="c-41343606">[3 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t c_str() be null terminated? Then if it must point to the actual backing store, then that must also be a valid null terminated C string as there&#x27;s no other way to use them.</div><br/><div id="41344210" class="c"><input type="checkbox" id="c-41344210" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41343606">parent</a><span>|</span><a href="#41340037">next</a><span>|</span><label class="collapse" for="c-41344210">[-]</label><label class="expand" for="c-41344210">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Shouldn&#x27;t c_str() be null terminated?<p>Yes, by definition.<p>&gt; Then if it must point to the actual backing store, then that must also be a valid null terminated C string as there&#x27;s no other way to use them.<p>No, this doesn&#x27;t follow. The buffer could leave room for the terminator but not actually write the terminator until c_str() is called. That&#x27;s why the C++11 standard had to explicitly require that the string always be null-terminated regardless of whether c_str() is called.</div><br/><div id="41345614" class="c"><input type="checkbox" id="c-41345614" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41344210">parent</a><span>|</span><a href="#41340037">next</a><span>|</span><label class="collapse" for="c-41345614">[-]</label><label class="expand" for="c-41345614">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I didn&#x27;t expect `c_str()` to write at all. I knew that C++ was wild before C++57, but before C++ is insane.<p>Thanks for the explanation!</div><br/></div></div></div></div></div></div><div id="41340037" class="c"><input type="checkbox" id="c-41340037" checked=""/><div class="controls bullet"><span class="by">masspro</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339728">parent</a><span>|</span><a href="#41343606">prev</a><span>|</span><a href="#41339622">next</a><span>|</span><label class="collapse" for="c-41340037">[-]</label><label class="expand" for="c-41340037">[3 more]</label></div><br/><div class="children"><div class="content">Why downvotes? Ignoring C++11 changes for a minute, c_str is absolutely able to cause a reallocation if it needs to, such that after it returns, its return value and the value of data() are the same. Ergo no, the GP statement alone doesnât imply anything.</div><br/><div id="41340289" class="c"><input type="checkbox" id="c-41340289" checked=""/><div class="controls bullet"><span class="by">dpassens</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41340037">parent</a><span>|</span><a href="#41339622">next</a><span>|</span><label class="collapse" for="c-41340289">[-]</label><label class="expand" for="c-41340289">[2 more]</label></div><br/><div class="children"><div class="content">But the return value guarantee is, as far as I can see, a C++11 change, so you can&#x27;t ignore those. And as of C++11, c_str is noexcept, so it cannot allocate anything.</div><br/><div id="41340616" class="c"><input type="checkbox" id="c-41340616" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41340289">parent</a><span>|</span><a href="#41339622">next</a><span>|</span><label class="collapse" for="c-41340616">[-]</label><label class="expand" for="c-41340616">[1 more]</label></div><br/><div class="children"><div class="content">Please see my edit.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41339622" class="c"><input type="checkbox" id="c-41339622" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339599">parent</a><span>|</span><a href="#41339688">prev</a><span>|</span><a href="#41339706">next</a><span>|</span><label class="collapse" for="c-41339622">[-]</label><label class="expand" for="c-41339622">[2 more]</label></div><br/><div class="children"><div class="content">I think std::string is actually required to be null terminated now in the latest standards. But even before it was basically required as that was the only way to make c_str() constant time.</div><br/><div id="41339760" class="c"><input type="checkbox" id="c-41339760" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339622">parent</a><span>|</span><a href="#41339706">next</a><span>|</span><label class="collapse" for="c-41339760">[-]</label><label class="expand" for="c-41339760">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But even before it was basically required as that was the only way to make c_str() constant time.<p>Note that c_str() could&#x27;ve inserted the terminator in constant time, as long as the string kept space reserved for that. So this wouldn&#x27;t have violated constant-time-ness, and it&#x27;s not an insane thing to do considering it would save some instructions elsewhere. But yeah, the flexibility wasn&#x27;t all that useful even in the beginning, and became even more useless as soon as C++ incorporated threading, due to the constness of the function.</div><br/></div></div></div></div></div></div><div id="41339706" class="c"><input type="checkbox" id="c-41339706" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339357">parent</a><span>|</span><a href="#41339599">prev</a><span>|</span><a href="#41340251">next</a><span>|</span><label class="collapse" for="c-41339706">[-]</label><label class="expand" for="c-41339706">[3 more]</label></div><br/><div class="children"><div class="content">Null-terminated strings really are a mistake. Make vectorized algorithms problematic by forcing them to account for page size and paged memory in general as well as always scan for NUL, cannot be easily sliced without re-allocation, are opposite to how languages with better string primitives define them and in general don&#x27;t save much by passing a single pointer over ptr + length.</div><br/><div id="41343702" class="c"><input type="checkbox" id="c-41343702" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339706">parent</a><span>|</span><a href="#41340251">next</a><span>|</span><label class="collapse" for="c-41343702">[-]</label><label class="expand" for="c-41343702">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really possible to get rid of them in C++ however, given a staggering amount of legacy APIs that require them. Constantly converting every time you have to call a system API with your string is even worse.</div><br/><div id="41344009" class="c"><input type="checkbox" id="c-41344009" checked=""/><div class="controls bullet"><span class="by">anp</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41343702">parent</a><span>|</span><a href="#41340251">next</a><span>|</span><label class="collapse" for="c-41344009">[-]</label><label class="expand" for="c-41344009">[1 more]</label></div><br/><div class="children"><div class="content">FWIW Rust also has null-terminated strings available under its std::ffi module. Iâm not sure it would be feasible to migrate C++ to the approach of multiple string types now, and Iâm not sure it would have been the right approach for C++11 given C++âs approach to interop, but itâs definitely possible to support interoperability with those legacy APIs without constraining a default string type to null-termination.</div><br/></div></div></div></div></div></div><div id="41340251" class="c"><input type="checkbox" id="c-41340251" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41339357">parent</a><span>|</span><a href="#41339706">prev</a><span>|</span><a href="#41340448">next</a><span>|</span><label class="collapse" for="c-41340251">[-]</label><label class="expand" for="c-41340251">[5 more]</label></div><br/><div class="children"><div class="content">More of a knock against C than C++, seeing as todayâs C++ tends to prefer `string_view`s or at worst iterator pairs, neither of which use null-termination. (Saying that as someone who prefers C to C++ and avoids Rust exactly because of âbetter C++â vibesâI donât <i>want</i> a better version of C++, if anything I want a much much simpler one thatâs worse at some things.)<p>That said, I donât see why it wouldnât be possible to cram in 24 bytes of null-terminated payload (so 23 useful ones, the best you could hope for with null termination) into the same structure the same way by storing the compact version with null termination and ensuring the last byte is also always zero. For extra style points, define the last byte to be 24 minus payload length instead so you donât need to recompute the length in the inline case.<p>To be clear: none of this makes null termination not dumb.</div><br/><div id="41340484" class="c"><input type="checkbox" id="c-41340484" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41340251">parent</a><span>|</span><a href="#41340417">next</a><span>|</span><label class="collapse" for="c-41340484">[-]</label><label class="expand" for="c-41340484">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That said, I donât see why it wouldnât be possible to cram in 24 bytes of null-terminated payload (so 23 useful ones, the best you could hope for with null termination) into the same structure the same way by storing the compact version with null termination and ensuring the last byte is also always zero.<p>I want to say libc++ and maybe MSVC do something along those lines in their std::string implementations.<p>&gt; For extra style points, define the last byte to be 24 minus payload length instead so you donât need to recompute the length in the inline case.<p>IIRC Facebook&#x27;s FBString from Folly does (did?) that?</div><br/><div id="41341231" class="c"><input type="checkbox" id="c-41341231" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41340484">parent</a><span>|</span><a href="#41340417">next</a><span>|</span><label class="collapse" for="c-41341231">[-]</label><label class="expand" for="c-41341231">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I want to say libc++ and maybe MSVC do something along those lines in their std::string implementations.<p>Here&#x27;s Raymond Chen on this topic earlier this same year. As a bonus since you&#x27;re looking at this in August it&#x27;s more or less correct now, whereas when it was published it had numerous serious errors. Whether the standard library implementation of such an important type should be so complicated that an expert makes numerous errors is another question...<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20240510-00&#x2F;?p=109742" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20240510-00&#x2F;?p=10...</a><p>So, libc++ gets closest, 1 flag byte + 22 bytes of text + 1 byte of ASCII NUL = 24 bytes<p>The others are much worse, larger (32 bytes on modern computers) yet with lower SSO capacity (15 bytes of text).</div><br/><div id="41342962" class="c"><input type="checkbox" id="c-41342962" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41341231">parent</a><span>|</span><a href="#41340417">next</a><span>|</span><label class="collapse" for="c-41342962">[-]</label><label class="expand" for="c-41342962">[1 more]</label></div><br/><div class="children"><div class="content">Huh, I thought MSVC had a libc++-style SSO implementation. Now I have to wonder where I got that mistaken impression :(</div><br/></div></div></div></div></div></div><div id="41340417" class="c"><input type="checkbox" id="c-41340417" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41340251">parent</a><span>|</span><a href="#41340484">prev</a><span>|</span><a href="#41340448">next</a><span>|</span><label class="collapse" for="c-41340417">[-]</label><label class="expand" for="c-41340417">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That said, I donât see why it wouldnât be possible to cram in 24 bytes of null-terminated payload<p>Note that I didn&#x27;t say this is impossible, just that the given trick wouldn&#x27;t work.<p>However, this <i>is</i> impossible for general strings. The only way could possibly make this work is if you constrain the inline string somehow (e.g., to UTF-8), so that some shorter strings failing that constraint are forced to go on the heap too. Otherwise you have 1 fixed zero byte at the end, and 23 fully flexible bytes, leaving you no way to represent an out-of-line string.<p>(Well, you could do it if you use the address as a key into some static map or such where you shove the real data, but that&#x27;s cheating and beside the point here.)</div><br/></div></div></div></div></div></div><div id="41340448" class="c"><input type="checkbox" id="c-41340448" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#41339224">parent</a><span>|</span><a href="#41339357">prev</a><span>|</span><a href="#41339392">next</a><span>|</span><label class="collapse" for="c-41340448">[-]</label><label class="expand" for="c-41340448">[7 more]</label></div><br/><div class="children"><div class="content">This is interesting, thanks.<p>&gt; 0b11111110 - All 1s with a trailing 0, indicates heap allocated<p>&gt; 0b11XXXXXX - Two leading 1s, indicates inline, with the trailing 6 bits used to store the length<p>I stared at this for too long, as it allows collision.  Then I realized you&#x27;d never set the third bit, it should probably have been written 0b110XXXXX and recorded that 5 bits are used for length.  Right or did I understand it wrong?</div><br/><div id="41341502" class="c"><input type="checkbox" id="c-41341502" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41340448">parent</a><span>|</span><a href="#41341601">next</a><span>|</span><label class="collapse" for="c-41341502">[-]</label><label class="expand" for="c-41341502">[5 more]</label></div><br/><div class="children"><div class="content">Probably this isn&#x27;t helpful anyway - what&#x27;s actually going on is more complicated and is explained later at a high level or I&#x27;ll try now:<p>Rust has &quot;niches&quot; - bit patterns which are never used by that type and thus can be occupied by something else in a sum type (Rust&#x27;s enum) which adds to that type. But stable Rust doesn&#x27;t allow third parties to promise arbitrary niches exist for a type they made.<p>However, if you make a simple enumeration of N possibilities that <i>automatically</i> has a niche of all the M-N bit patterns which weren&#x27;t needed by your enumeration in the M value machine integer that was chosen to store this enumerated type (M will typically be 256 or 65536 depending on how many things you enumerated)<p>So, CompactString has a custom enum type LastUtf8Char which it uses for the last byte in its data structure - this has values V0 through V191 corresponding to the 192 possible last bytes of a UTF-8 string. That leaves 64 bit patterns unused. Then L0 through L23 represent lengths - inline strings of length 0 to 23 inclusive which didn&#x27;t need this last byte (if it was 24 then that&#x27;s V0 through V191). Now we&#x27;ve got 40 bit patterns left.<p>Then one bit pattern (the pattern equivalent to the unsigned integer 216) signifies that this string data lives on the heap, the rest should be interpreted accordingly, and another (217) signifies that it&#x27;s a weird static allocation (I do not know why you&#x27;d do this)<p>That leaves 38 bit patterns unused when the type is finished using any it wanted so there&#x27;s still a niche for Option&lt;CompactString&gt; or MyCustomType&lt;CompactString&gt;</div><br/><div id="41342033" class="c"><input type="checkbox" id="c-41342033" checked=""/><div class="controls bullet"><span class="by">parkmycar</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41341502">parent</a><span>|</span><a href="#41341601">next</a><span>|</span><label class="collapse" for="c-41342033">[-]</label><label class="expand" for="c-41342033">[4 more]</label></div><br/><div class="children"><div class="content">Author of compact_str here, you hit the nail on the head, great explanation!<p>&gt; ... and another (217) signifies that it&#x27;s a weird static allocation (I do not know why you&#x27;d do this)<p>In addition to String Rust also has str[1], which is an entirely different type. It&#x27;s common to represent string literals known at compile time as `&amp;&#x27;static str`, but they can&#x27;t be used in all of the same places that a String can. For example, you can&#x27;t put a &amp;&#x27;static str into a Vec&lt;String&gt; unless you first heap allocate and create a String. We added the additional variant of 217 so users of CompactString could abstract over both string literals and strings created at runtime to solve cases like the example.<p>[1]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.str.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.str.html</a></div><br/><div id="41342338" class="c"><input type="checkbox" id="c-41342338" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342033">parent</a><span>|</span><a href="#41341601">next</a><span>|</span><label class="collapse" for="c-41342338">[-]</label><label class="expand" for="c-41342338">[3 more]</label></div><br/><div class="children"><div class="content">Thanks! And the explanation of 217 makes sense too.<p>Since I have you here, wouldn&#x27;t it be better to name that type &quot;LastByte&quot; or something? It&#x27;s not a (Rust) char, and it&#x27;s not necessarily UTF-8 whereas it is definitely the last byte.</div><br/><div id="41342507" class="c"><input type="checkbox" id="c-41342507" checked=""/><div class="controls bullet"><span class="by">parkmycar</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342338">parent</a><span>|</span><a href="#41341601">next</a><span>|</span><label class="collapse" for="c-41342507">[-]</label><label class="expand" for="c-41342507">[2 more]</label></div><br/><div class="children"><div class="content">Ha, naming is hard! Youâre totally right, it used to be just the values of the last byte of a UTF-8 char (and before that it was NonMaxU8) but now represents more. Iâll update it once Iâm back at my computer, thanks!</div><br/><div id="41342823" class="c"><input type="checkbox" id="c-41342823" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41342507">parent</a><span>|</span><a href="#41341601">next</a><span>|</span><label class="collapse" for="c-41342823">[-]</label><label class="expand" for="c-41342823">[1 more]</label></div><br/><div class="children"><div class="content">Ah, while you&#x27;re in there, IIRC you mention NonMaxU8 in the code still and probably that&#x27;s worth updating at the same time.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41341601" class="c"><input type="checkbox" id="c-41341601" checked=""/><div class="controls bullet"><span class="by">shikon7</span><span>|</span><a href="#41339224">root</a><span>|</span><a href="#41340448">parent</a><span>|</span><a href="#41341502">prev</a><span>|</span><a href="#41339392">next</a><span>|</span><label class="collapse" for="c-41341601">[-]</label><label class="expand" for="c-41341601">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you need it if pointers are 16 bytes?</div><br/></div></div></div></div></div></div><div id="41339392" class="c"><input type="checkbox" id="c-41339392" checked=""/><div class="controls bullet"><span class="by">mastax</span><span>|</span><a href="#41339224">prev</a><span>|</span><a href="#41342217">next</a><span>|</span><label class="collapse" for="c-41339392">[-]</label><label class="expand" for="c-41339392">[1 more]</label></div><br/><div class="children"><div class="content">Itâs nice that rustcâs niche optimization lets smolstr be implemented with a simple enum, rather than having to do some unsafe union bit packing[0]. The only concession that had to be made to the compiler is using an enum for the InlineSize value to show that the last 3 bits of that arenât used.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-analyzer&#x2F;smol_str&#x2F;blob&#x2F;fde86a5c0cb8f397c8a59e3bb156a39fbeb754d5&#x2F;src&#x2F;lib.rs#L475">https:&#x2F;&#x2F;github.com&#x2F;rust-analyzer&#x2F;smol_str&#x2F;blob&#x2F;fde86a5c0cb8f...</a></div><br/></div></div><div id="41342217" class="c"><input type="checkbox" id="c-41342217" checked=""/><div class="controls bullet"><span class="by">conaclos</span><span>|</span><a href="#41339392">prev</a><span>|</span><a href="#41338961">next</a><span>|</span><label class="collapse" for="c-41342217">[-]</label><label class="expand" for="c-41342217">[1 more]</label></div><br/><div class="children"><div class="content">Readers who like this article may also like a more recent one [0]. It designs a compact string with extra capabilities. The crate was released under the name byteyarn [1]<p>[0] <a href="https:&#x2F;&#x2F;mcyoung.xyz&#x2F;2023&#x2F;08&#x2F;09&#x2F;yarns&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mcyoung.xyz&#x2F;2023&#x2F;08&#x2F;09&#x2F;yarns&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;docs.rs&#x2F;byteyarn&#x2F;latest&#x2F;byteyarn&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;byteyarn&#x2F;latest&#x2F;byteyarn&#x2F;</a></div><br/></div></div><div id="41338961" class="c"><input type="checkbox" id="c-41338961" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41342217">prev</a><span>|</span><a href="#41338971">next</a><span>|</span><label class="collapse" for="c-41338961">[-]</label><label class="expand" for="c-41338961">[9 more]</label></div><br/><div class="children"><div class="content">[2020]. I wouldn&#x27;t be surprised if the field had changed a fair bit since.</div><br/><div id="41339058" class="c"><input type="checkbox" id="c-41339058" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#41338961">parent</a><span>|</span><a href="#41338971">next</a><span>|</span><label class="collapse" for="c-41339058">[-]</label><label class="expand" for="c-41339058">[8 more]</label></div><br/><div class="children"><div class="content">Ok, I dived into the rabbit hole a bit and found this:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rosetta-rs&#x2F;string-rosetta-rs?tab=readme-ov-file">https:&#x2F;&#x2F;github.com&#x2F;rosetta-rs&#x2F;string-rosetta-rs?tab=readme-o...</a><p>Click the charts for actually readable data.<p>From a quick scan, it seems like hipstr is the current fastest string implementation and is actively maintained.</div><br/><div id="41341211" class="c"><input type="checkbox" id="c-41341211" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#41338961">root</a><span>|</span><a href="#41339058">parent</a><span>|</span><a href="#41340643">next</a><span>|</span><label class="collapse" for="c-41341211">[-]</label><label class="expand" for="c-41341211">[1 more]</label></div><br/><div class="children"><div class="content">Also, smol_str was removed from the comparison because matklad, the author of smol_str, suggests ecow<p>&gt; Iâd rather say the opposite: users of those crates should switch to ecow. It is exactly what smol_str would have been, if it were a proper crate with a stable API, rather than an implementation detail of rust-analyzer.
&gt;
&gt; Itâs a drop-in replacement for String, with O(1) clone and SSO, and I believe this is all you need. Other crates either have needlessly restricted API (no mutation), questionable implementation choices, or a bunch of ad hoc traits in the API.<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;117ksvr&#x2F;ecow_compact_cloneonwrite_vector_and_string&#x2F;j9eh35d&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;117ksvr&#x2F;ecow_compact_...</a></div><br/></div></div><div id="41340643" class="c"><input type="checkbox" id="c-41340643" checked=""/><div class="controls bullet"><span class="by">skavi</span><span>|</span><a href="#41338961">root</a><span>|</span><a href="#41339058">parent</a><span>|</span><a href="#41341211">prev</a><span>|</span><a href="#41339179">next</a><span>|</span><label class="collapse" for="c-41340643">[-]</label><label class="expand" for="c-41340643">[5 more]</label></div><br/><div class="children"><div class="content">Those benchmarks arenât great.<p>A real world-ish workload made generic over all these types would provide much more interesting results. Especially if heap usage was also tracked.</div><br/><div id="41341221" class="c"><input type="checkbox" id="c-41341221" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#41338961">root</a><span>|</span><a href="#41340643">parent</a><span>|</span><a href="#41341136">next</a><span>|</span><label class="collapse" for="c-41341221">[-]</label><label class="expand" for="c-41341221">[1 more]</label></div><br/><div class="children"><div class="content">Real world benchmarks also wouldn&#x27;t be great because they would be showing how well it works in someone else&#x27;s program, rather than yours.<p>This at least gives you an idea of what the relative cost of different operations are so you can consider what are frequent operations in your program and then benchmark a couple from there, rather than everything.</div><br/></div></div><div id="41341136" class="c"><input type="checkbox" id="c-41341136" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41338961">root</a><span>|</span><a href="#41340643">parent</a><span>|</span><a href="#41341221">prev</a><span>|</span><a href="#41339179">next</a><span>|</span><label class="collapse" for="c-41341136">[-]</label><label class="expand" for="c-41341136">[3 more]</label></div><br/><div class="children"><div class="content">the author has some recommendations, to quote formatting):<p>&gt; Suggestions:<p>&gt;<p>&gt;    Generally, String<p>&gt;    If you deal mostly with string literals but want some flexibility (like clap), generally you&#x27;ll want Cow&lt;&#x27;static, str&gt;<p>&gt;    If a profiler says your strings are a problem:<p>&gt;       Try different crates and settings for that crate out with a profiler<p>&gt;       O(1) clones are important when doing a lot of clones.<p>&gt;         For one-off allocations, they are slower.<p>&gt;       For short-lived programs, look into string interning<p>i.e. author thinks you should profile with your own use case<p>EDIT: Not sure why HN removes indention between a leading &gt; and the start of the text, makes quoting unnecessary hard</div><br/><div id="41344734" class="c"><input type="checkbox" id="c-41344734" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41338961">root</a><span>|</span><a href="#41341136">parent</a><span>|</span><a href="#41343241">next</a><span>|</span><label class="collapse" for="c-41344734">[-]</label><label class="expand" for="c-41344734">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure why HN removes indention between a leading &gt; and the start of the text, makes quoting unnecessary hard<p>Because HNâs markup is the most dreary, half-assed, and useless one in the history of lightweight markups.<p>HN will remove a bunch of characters it doesnât like because they might be used for fun, parse two+ newlines as a paragraph break, 4-indent as a literal block, and mis-parse * as emphasis.<p>Thatâs it. So you get all the drawbacks of HTML with almost none of the tools provided by even just the original markdown. No quoting, no line breaks, no lists, no inline code, â¦</div><br/></div></div><div id="41343241" class="c"><input type="checkbox" id="c-41343241" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41338961">root</a><span>|</span><a href="#41341136">parent</a><span>|</span><a href="#41344734">prev</a><span>|</span><a href="#41339179">next</a><span>|</span><label class="collapse" for="c-41343241">[-]</label><label class="expand" for="c-41343241">[1 more]</label></div><br/><div class="children"><div class="content">HTML    doesn&#x27;t    do    indentation.    I    typed    four    spaces    between    every    word    in    these    sentences.</div><br/></div></div></div></div></div></div><div id="41339179" class="c"><input type="checkbox" id="c-41339179" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41338961">root</a><span>|</span><a href="#41339058">parent</a><span>|</span><a href="#41340643">prev</a><span>|</span><a href="#41338971">next</a><span>|</span><label class="collapse" for="c-41339179">[-]</label><label class="expand" for="c-41339179">[1 more]</label></div><br/><div class="children"><div class="content">And has the best name!</div><br/></div></div></div></div></div></div><div id="41338971" class="c"><input type="checkbox" id="c-41338971" checked=""/><div class="controls bullet"><span class="by">abhorrence</span><span>|</span><a href="#41338961">prev</a><span>|</span><a href="#41339904">next</a><span>|</span><label class="collapse" for="c-41338971">[-]</label><label class="expand" for="c-41338971">[5 more]</label></div><br/><div class="children"><div class="content">Sadly it seems like some of the images have broken since it was originally posted. :(</div><br/><div id="41339123" class="c"><input type="checkbox" id="c-41339123" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41338971">parent</a><span>|</span><a href="#41339494">next</a><span>|</span><label class="collapse" for="c-41339123">[-]</label><label class="expand" for="c-41339123">[2 more]</label></div><br/><div class="children"><div class="content">This capture looks a little better. Even the CSS looks off on the live site. Maybe someone should ping him? I think he&#x27;s on Mastodon <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20201002084042&#x2F;https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;small-strings-in-rust" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20201002084042&#x2F;https:&#x2F;&#x2F;fastertha...</a></div><br/><div id="41339400" class="c"><input type="checkbox" id="c-41339400" checked=""/><div class="controls bullet"><span class="by">cute_boi</span><span>|</span><a href="#41338971">root</a><span>|</span><a href="#41339123">parent</a><span>|</span><a href="#41339494">next</a><span>|</span><label class="collapse" for="c-41339400">[-]</label><label class="expand" for="c-41339400">[1 more]</label></div><br/><div class="children"><div class="content">Actually previous design was better to my eyes.</div><br/></div></div></div></div><div id="41339494" class="c"><input type="checkbox" id="c-41339494" checked=""/><div class="controls bullet"><span class="by">pronoiac</span><span>|</span><a href="#41338971">parent</a><span>|</span><a href="#41339123">prev</a><span>|</span><a href="#41339904">next</a><span>|</span><label class="collapse" for="c-41339494">[-]</label><label class="expand" for="c-41339494">[2 more]</label></div><br/><div class="children"><div class="content">I emailed him.</div><br/><div id="41340177" class="c"><input type="checkbox" id="c-41340177" checked=""/><div class="controls bullet"><span class="by">fasterthanlime</span><span>|</span><a href="#41338971">root</a><span>|</span><a href="#41339494">parent</a><span>|</span><a href="#41339904">next</a><span>|</span><label class="collapse" for="c-41340177">[-]</label><label class="expand" for="c-41340177">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the heads up!<p>I fixed the SVG graphs and made a couple layout updates based on the feedback here and some earlier feedback from my subreddit, see the before-after here.[1]<p>I&#x27;ve been mostly focused on function lately, the redesign is, let&#x27;s say, a work in progress.<p>(Oh also, I use they&#x2F;them pronouns these days [2])<p>[1] <a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;before-after-2024-08-24-PAmeHFX" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;before-after-2024-08-24-PAmeHFX</a>
[2] <a href="https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;state-of-the-fasterthanlime-2024" rel="nofollow">https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;state-of-the-fasterthanlime...</a></div><br/></div></div></div></div></div></div><div id="41339904" class="c"><input type="checkbox" id="c-41339904" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41338971">prev</a><span>|</span><a href="#41344143">next</a><span>|</span><label class="collapse" for="c-41339904">[-]</label><label class="expand" for="c-41339904">[1 more]</label></div><br/><div class="children"><div class="content">Here [1] is a nice talk that discusses various options and trade-offs for small string and small vector optimization in Rust.<p>[1] <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?time_continue=2658&amp;v=tLX_nvWD738&amp;embeds_referring_euri=https%3A%2F%2Frustlab.it%2F&amp;embeds_referring_origin=https%3A%2F%2Frustlab.it&amp;source_ve_path=MTM5MTE3LDM2ODQyLDEzOTExNywzNjg0MiwxMzkxMTcsMjg2NjY" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?time_continue=2658&amp;v=tLX_nvWD738...</a></div><br/></div></div><div id="41344143" class="c"><input type="checkbox" id="c-41344143" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#41339904">prev</a><span>|</span><a href="#41339852">next</a><span>|</span><label class="collapse" for="c-41344143">[-]</label><label class="expand" for="c-41344143">[4 more]</label></div><br/><div class="children"><div class="content">I wonder, is there a &quot;string-like interface&quot; in Rust or one has to rewrite all the code when changing string implementation? Also if you want to change implementation in half of the code, is there automatic convertion between implementations?</div><br/><div id="41344518" class="c"><input type="checkbox" id="c-41344518" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41344143">parent</a><span>|</span><a href="#41345295">next</a><span>|</span><label class="collapse" for="c-41344518">[-]</label><label class="expand" for="c-41344518">[2 more]</label></div><br/><div class="children"><div class="content">This is what the `AsRef` trait is great for<p><pre><code>    impl AsRef&lt;str&gt; for MyCoolString {
        fn as_ref(&amp;self) -&gt; &amp;str {
            ...
        }
    }
</code></pre>
To be totally defensive, other library authors can write their APIs like<p><pre><code>    fn my_cool_function(s: impl AsRef&lt;str&gt;) {
        let s: &amp;str = s.as_ref();
    }
</code></pre>
and now `s` is treated like any other &amp;str. But even if library authors don&#x27;t program defensively and use `s: &amp;str` in the argument type, callers can always do this:<p><pre><code>    my_cool_function(my_cool_string.as_ref());</code></pre></div><br/><div id="41344929" class="c"><input type="checkbox" id="c-41344929" checked=""/><div class="controls bullet"><span class="by">dubi_steinkek</span><span>|</span><a href="#41344143">root</a><span>|</span><a href="#41344518">parent</a><span>|</span><a href="#41345295">next</a><span>|</span><label class="collapse" for="c-41344929">[-]</label><label class="expand" for="c-41344929">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible but I would prefer to just pass &amp;str at that point, leading to less monomorphizations and a simpler API</div><br/></div></div></div></div><div id="41345295" class="c"><input type="checkbox" id="c-41345295" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41344143">parent</a><span>|</span><a href="#41344518">prev</a><span>|</span><a href="#41339852">next</a><span>|</span><label class="collapse" for="c-41345295">[-]</label><label class="expand" for="c-41345295">[1 more]</label></div><br/><div class="children"><div class="content">For read-only strings you pass around &amp;str usually if you can borrow at all, and all UTF-8 string types should be compatible with it. AsRef is just a trait for &quot;all types that can be converted into &amp;str as needed&quot; so if you use AsRef you need to have immutable strings too<p>But the thing about String is that it allows you to push data at the end (like Java&#x27;s StringBuilder). I think there is no commonly used trait for that, no.<p>Note that not all owned string types can be appended at the end. Box&lt;str&gt; for example is just like String but without a .push_str() method. (This saves some bytes because it doesn&#x27;t need a spare capacity)<p>If your string is not UTF-8 then usually you convert it at API boundaries, to deal with UTF-8 stuff internally (or at least WTF-8)</div><br/></div></div></div></div><div id="41339852" class="c"><input type="checkbox" id="c-41339852" checked=""/><div class="controls bullet"><span class="by">jtrueb</span><span>|</span><a href="#41344143">prev</a><span>|</span><a href="#41341062">next</a><span>|</span><label class="collapse" for="c-41339852">[-]</label><label class="expand" for="c-41339852">[1 more]</label></div><br/><div class="children"><div class="content">I made humanize-bytes[1] for that formatting reason (1000 vs 1024). Coincidentally, it uses smartstring to avoid allocations.<p>[1] <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;humanize-bytes" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;humanize-bytes</a></div><br/></div></div><div id="41341062" class="c"><input type="checkbox" id="c-41341062" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41339852">prev</a><span>|</span><a href="#41345269">next</a><span>|</span><label class="collapse" for="c-41341062">[-]</label><label class="expand" for="c-41341062">[1 more]</label></div><br/><div class="children"><div class="content">on interesting thing to realize is that some small string types go beyond just the basic small len storage optimization<p>- compact_str e.g. depends on the string being valid utf-8, and in turn has larger short strings<p>- smol_str e.g. is a a enum over `[u8; CAP] | &amp;&#x27;static str | Arc&lt;str&gt;` this means it avoids any allocations for static strings and has very fast clones, leading to similar perf. characteristics as string internalization in some use cases (like the use-cases it was designed for). But at the cost of it being immutable only and the heap allocation being slightly larger for the Rc.<p>Other interesting differences can be the handling of shrinking mutable Strings, do you re-inline it or not? What is better here is highly use-case dependent.<p>In the end there are many design decisions where there is no clear winner but it&#x27;s a question of trade off with use-case specific preferences.</div><br/></div></div><div id="41345269" class="c"><input type="checkbox" id="c-41345269" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41341062">prev</a><span>|</span><a href="#41340955">next</a><span>|</span><label class="collapse" for="c-41345269">[-]</label><label class="expand" for="c-41345269">[1 more]</label></div><br/><div class="children"><div class="content">(2020)</div><br/></div></div><div id="41340955" class="c"><input type="checkbox" id="c-41340955" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#41345269">prev</a><span>|</span><a href="#41342485">next</a><span>|</span><label class="collapse" for="c-41340955">[-]</label><label class="expand" for="c-41340955">[4 more]</label></div><br/><div class="children"><div class="content">slightly related: earlier I was experimenting with Rust string allocations, even though my code did almost same as standard library, the heap allocations were taking 10x of time. Relevant code:<p><pre><code>  fn alloc_string(s: &amp;str) -&gt; NonNull&lt;u8&gt; {
      let boxed_slice = s.as_bytes().to_owned().into_boxed_slice();
      NonNull::new(Box::into_raw(boxed_slice) as *mut u8).unwrap()
  }

</code></pre>
Approximately, if stdlib was taking 1Âµs, but my code was about 14-15Âµs for large strings. Profiling also did not help. Anyone have any guesses? Here is the full code: <a href="https:&#x2F;&#x2F;github.com&#x2F;avinassh&#x2F;string-alloc">https:&#x2F;&#x2F;github.com&#x2F;avinassh&#x2F;string-alloc</a></div><br/><div id="41342005" class="c"><input type="checkbox" id="c-41342005" checked=""/><div class="controls bullet"><span class="by">hummingly</span><span>|</span><a href="#41340955">parent</a><span>|</span><a href="#41340979">next</a><span>|</span><label class="collapse" for="c-41342005">[-]</label><label class="expand" for="c-41342005">[2 more]</label></div><br/><div class="children"><div class="content">When you call to_owned, it creates a Vec&lt;u8&gt;. This must then be truncated due to the call to into_boxed_slice. The documentation says this could potentially mean a re-allocation depending on the allocator. When this happens the old allocation needs to be dropped too. You could try using a different allocator but before this I would recommend to replace those two calls with Box::from(s.as_bytes()).</div><br/><div id="41343144" class="c"><input type="checkbox" id="c-41343144" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#41340955">root</a><span>|</span><a href="#41342005">parent</a><span>|</span><a href="#41340979">next</a><span>|</span><label class="collapse" for="c-41343144">[-]</label><label class="expand" for="c-41343144">[1 more]</label></div><br/><div class="children"><div class="content">The vec already gets allocated with capacity == length<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;src&#x2F;alloc&#x2F;slice.rs.html#161" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;src&#x2F;alloc&#x2F;slice.rs.html#16...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>