<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724403664680" as="style"/><link rel="stylesheet" href="styles.css?v=1724403664680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lostintransit.se/2024/08/21/ethernet-history-deepdive-why-do-we-have-different-frame-types/">Ethernet History Deepdive – Why Do We Have Different Frame Types?</a> <span class="domain">(<a href="https://lostintransit.se">lostintransit.se</a>)</span></div><div class="subtext"><span>un_ess</span> | <span>66 comments</span></div><br/><div><div id="41320342" class="c"><input type="checkbox" id="c-41320342" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41324133">next</a><span>|</span><label class="collapse" for="c-41320342">[-]</label><label class="expand" for="c-41320342">[20 more]</label></div><br/><div class="children"><div class="content"><i>Ironically, this version of the header published in 1980 is what we still use to this day.</i><p>IMHO Ethernet is one of the of great examples of backwards compatibility in the computing world. Even the wireless standards present frames to the upper layers like they&#x27;re Ethernet. It&#x27;s also a counterexample to the bureaucracy of standards bodies --- the standard that actually became widely used was the one that got released first. The other example that comes to mind is OSI vs DoD(TCP&#x2F;IP).</div><br/><div id="41321585" class="c"><input type="checkbox" id="c-41321585" checked=""/><div class="controls bullet"><span class="by">rjsw</span><span>|</span><a href="#41320342">parent</a><span>|</span><a href="#41320542">next</a><span>|</span><label class="collapse" for="c-41321585">[-]</label><label class="expand" for="c-41321585">[5 more]</label></div><br/><div class="children"><div class="content">OSI was usable as a wide area network before TCP&#x2F;IP was.</div><br/><div id="41323634" class="c"><input type="checkbox" id="c-41323634" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41321585">parent</a><span>|</span><a href="#41320542">next</a><span>|</span><label class="collapse" for="c-41323634">[-]</label><label class="expand" for="c-41323634">[4 more]</label></div><br/><div class="children"><div class="content">[citation needed]</div><br/><div id="41325377" class="c"><input type="checkbox" id="c-41325377" checked=""/><div class="controls bullet"><span class="by">rjsw</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41323634">parent</a><span>|</span><a href="#41320542">next</a><span>|</span><label class="collapse" for="c-41325377">[-]</label><label class="expand" for="c-41325377">[3 more]</label></div><br/><div class="children"><div class="content">Personal experience.<p>Was developing OSI applications in 1989, you could order an X.25 circuit from your PTT and run OSI over that using the ISODE [1] toolkit.<p>The earliest ISP in my country didn&#x27;t start until 1992.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO_Development_Environment" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO_Development_Environment</a></div><br/><div id="41326349" class="c"><input type="checkbox" id="c-41326349" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41325377">parent</a><span>|</span><a href="#41320542">next</a><span>|</span><label class="collapse" for="c-41326349">[-]</label><label class="expand" for="c-41326349">[2 more]</label></div><br/><div class="children"><div class="content">TCP&#x2F;IP was developed in the 1970s and adopted as the protocol standard for ARPANET (the predecessor to the Internet) in 1983.</div><br/><div id="41326466" class="c"><input type="checkbox" id="c-41326466" checked=""/><div class="controls bullet"><span class="by">yusyusyus</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41326349">parent</a><span>|</span><a href="#41320542">next</a><span>|</span><label class="collapse" for="c-41326466">[-]</label><label class="expand" for="c-41326466">[1 more]</label></div><br/><div class="children"><div class="content">and commercialization wasnt done until the like 1994. OSI as a successor was still proposed when the first BGP4 rfc came out.<p>before commercialization happened, IP was mostly the realm of government and education.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41320542" class="c"><input type="checkbox" id="c-41320542" checked=""/><div class="controls bullet"><span class="by">betaby</span><span>|</span><a href="#41320342">parent</a><span>|</span><a href="#41321585">prev</a><span>|</span><a href="#41324133">next</a><span>|</span><label class="collapse" for="c-41320542">[-]</label><label class="expand" for="c-41320542">[14 more]</label></div><br/><div class="children"><div class="content">OSI is very widely used, most of the large ISPs use it. End consumers are just unaware of that fact. See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IS-IS" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IS-IS</a></div><br/><div id="41321142" class="c"><input type="checkbox" id="c-41321142" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41320542">parent</a><span>|</span><a href="#41322773">next</a><span>|</span><label class="collapse" for="c-41321142">[-]</label><label class="expand" for="c-41321142">[6 more]</label></div><br/><div class="children"><div class="content">I think this is a stretch, like saying the X.500 Directory System is widely used based on the fact that PKIX is technically adapting X.509 and thus your TLS certificates depend on the X.500 directory system. End users aren&#x27;t just &quot;unaware&quot; that it&#x27;s actually the X.500 system, it functionally isn&#x27;t the X.500 system, PKIX mandates an &quot;alternate&quot; scheme for the Internet and the directory called for by X.500 has never actually existed.<p>Likewise then, IS-IS is the protocol that OSI standardized, but we&#x27;re not using as part of an OSI system.</div><br/><div id="41321311" class="c"><input type="checkbox" id="c-41321311" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41321142">parent</a><span>|</span><a href="#41322773">next</a><span>|</span><label class="collapse" for="c-41321311">[-]</label><label class="expand" for="c-41321311">[5 more]</label></div><br/><div class="children"><div class="content">X.500 is widely used in the form of LDAP and Active Directory, however.</div><br/><div id="41321709" class="c"><input type="checkbox" id="c-41321709" checked=""/><div class="controls bullet"><span class="by">tristor</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41321311">parent</a><span>|</span><a href="#41322773">next</a><span>|</span><label class="collapse" for="c-41321709">[-]</label><label class="expand" for="c-41321709">[4 more]</label></div><br/><div class="children"><div class="content">Active Directory is not based on X.500 and LDAP was directly created as an alternative to the DAP standard that is part of X.500.<p>While X.500 is a precursor to both of these things, and influenced both of these things, and both of these things interoperated with X.500, they are not X.500.  X.500 is for all intents and purposes pretty much dead in 2024, although I did deploy an X.500 based directory service in 2012 and it&#x27;s probably still alive and running.</div><br/><div id="41322666" class="c"><input type="checkbox" id="c-41322666" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41321709">parent</a><span>|</span><a href="#41322773">next</a><span>|</span><label class="collapse" for="c-41322666">[-]</label><label class="expand" for="c-41322666">[3 more]</label></div><br/><div class="children"><div class="content">LDAP is just &quot;lightweight&quot; protocol for accessing an X.500 directory service.<p>The semantics are the same for the accessed store, IIRC. The protocol definition explicitly talks about being used to access X.500 data stores as complementary interface to DAP (which requires lower layers of OSI stack vs LDAP&#x27;s raw stream of bytes)</div><br/><div id="41322769" class="c"><input type="checkbox" id="c-41322769" checked=""/><div class="controls bullet"><span class="by">tristor</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41322666">parent</a><span>|</span><a href="#41322773">next</a><span>|</span><label class="collapse" for="c-41322769">[-]</label><label class="expand" for="c-41322769">[2 more]</label></div><br/><div class="children"><div class="content">Yes, that is why it was invented, as I alluded to.  LDAP was an alternative to DAP.  DAP is part of the X.500 standard, LDAP is not.  LDAP when it was first invented was built to access an X.500 directory.  That is no longer a base requirement and most directories in the wild are not built on X.500.  Standards mean things, just because LDAP was originally built to access X.500 doesn&#x27;t mean it&#x27;s part of X.500, and X.500 is a very detailed and specific standard which most directory services no longer follow.</div><br/><div id="41323440" class="c"><input type="checkbox" id="c-41323440" checked=""/><div class="controls bullet"><span class="by">GauntletWizard</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41322769">parent</a><span>|</span><a href="#41322773">next</a><span>|</span><label class="collapse" for="c-41323440">[-]</label><label class="expand" for="c-41323440">[1 more]</label></div><br/><div class="children"><div class="content">To reiterate in a slightly different form: Ldap is an inheritor of, and successor to, DAP&#x2F;X.500, but not backwards compatible and only superficially resembling it at this point.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41322773" class="c"><input type="checkbox" id="c-41322773" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41320542">parent</a><span>|</span><a href="#41321142">prev</a><span>|</span><a href="#41324133">next</a><span>|</span><label class="collapse" for="c-41322773">[-]</label><label class="expand" for="c-41322773">[7 more]</label></div><br/><div class="children"><div class="content">Would call it stretch to say it was widely used by ISPs. Some old ones may still be using integrated IS-IS as their IGP (early OSPF had scaling issues and complicated solutions for that), but that&#x27;s nothing like widely using the ISO stack. But they might have used IS-IS it to route NSAP in their network at some point in time to manage ATM-era equipment, the ISP I worked still had some ctunnels for that purpose, I doubt they still have them.</div><br/><div id="41323998" class="c"><input type="checkbox" id="c-41323998" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41322773">parent</a><span>|</span><a href="#41326264">next</a><span>|</span><label class="collapse" for="c-41323998">[-]</label><label class="expand" for="c-41323998">[4 more]</label></div><br/><div class="children"><div class="content">It was still widely used for IPv4 and v6 in 2000s. ex telco engineer told us that two major reasons was that IS-IS was simply more efficient, and that they didn&#x27;t require IP communication between routers - meaning troubleshooting and management was easier than providing p2p routes for IP-based protocols.</div><br/><div id="41324653" class="c"><input type="checkbox" id="c-41324653" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41323998">parent</a><span>|</span><a href="#41326264">next</a><span>|</span><label class="collapse" for="c-41324653">[-]</label><label class="expand" for="c-41324653">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still widely used, among old ISPs because why switch when it&#x27;s just as good or better than the alternative and your engineers know it best. But it&#x27;s not the whole stack as implied in the first reply.<p>It was popular primarily because OSPF didn&#x27;t scale well with hundreds to thousands of routers with the minimal CPU power even large core routers had.</div><br/><div id="41325275" class="c"><input type="checkbox" id="c-41325275" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41324653">parent</a><span>|</span><a href="#41326264">next</a><span>|</span><label class="collapse" for="c-41325275">[-]</label><label class="expand" for="c-41325275">[2 more]</label></div><br/><div class="children"><div class="content">Scalability was one part. Later the fact that you didn&#x27;t need separate routing setup for v6 also was part of it.<p>But for a telco, the fact that you didn&#x27;t have to setup IP connectivity in order for routers to see each other, was also a crucial ability.</div><br/><div id="41327084" class="c"><input type="checkbox" id="c-41327084" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41325275">parent</a><span>|</span><a href="#41326264">next</a><span>|</span><label class="collapse" for="c-41327084">[-]</label><label class="expand" for="c-41327084">[1 more]</label></div><br/><div class="children"><div class="content">OSPF has supported unnumbered links for a long time, don&#x27;t need IP on the link with point to point and multicast.</div><br/></div></div></div></div></div></div></div></div><div id="41326264" class="c"><input type="checkbox" id="c-41326264" checked=""/><div class="controls bullet"><span class="by">yusyusyus</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41322773">parent</a><span>|</span><a href="#41323998">prev</a><span>|</span><a href="#41324133">next</a><span>|</span><label class="collapse" for="c-41326264">[-]</label><label class="expand" for="c-41326264">[2 more]</label></div><br/><div class="children"><div class="content">still good reasons to choose IS-IS for greenfield :) hell, they took IS-IS and did TRILL with it for DC (rip TRILL).<p>but yeah, I saw one piece of SONET crap hanging off a ctunnel that spoke CLNP back in maybe 2012 or 2013? haven&#x27;t seen much of it, but still learned the ctunnel stuff back in &#x27;09 because it still could occasionally rear its head.</div><br/><div id="41327072" class="c"><input type="checkbox" id="c-41327072" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41320342">root</a><span>|</span><a href="#41326264">parent</a><span>|</span><a href="#41324133">next</a><span>|</span><label class="collapse" for="c-41327072">[-]</label><label class="expand" for="c-41327072">[1 more]</label></div><br/><div class="children"><div class="content">Worked for an old ISP in 2012 (it started when the state owned telco was privatized). Also had the ctunnel to manage old SONET crap, still had modem pools running, racks full of purple Sun machines still running, vax, hpux, as400, etc. Even the old smsc that was 5 racks of dec servers was still there, was never removed as they didn&#x27;t need the space because modern equipment was using all the available power anyway (was also in a mountain so a bit of a hassle to remove).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41324133" class="c"><input type="checkbox" id="c-41324133" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#41320342">prev</a><span>|</span><a href="#41323142">next</a><span>|</span><label class="collapse" for="c-41324133">[-]</label><label class="expand" for="c-41324133">[11 more]</label></div><br/><div class="children"><div class="content">I wish layer 2 and layer 3 were &#x27;refactored&#x27; to force all links to be point to point, which they effectively are in the modern world.    When was the last time you saw ethernet frame collisions because you used a hub not a switch?<p>We&#x27;d get rid of the idea of a broadcast domain.  We&#x27;d get rid of Mac address and ARP.  Switches and routers would become the same device.  We&#x27;d just use ip addresses for routing, and the &#x27;next hop&#x27; would always be the opposite end of the link you sent a packet over.<p>The world would be a simpler place, and no functionality would have been lost.</div><br/><div id="41324441" class="c"><input type="checkbox" id="c-41324441" checked=""/><div class="controls bullet"><span class="by">FuriouslyAdrift</span><span>|</span><a href="#41324133">parent</a><span>|</span><a href="#41324495">next</a><span>|</span><label class="collapse" for="c-41324441">[-]</label><label class="expand" for="c-41324441">[3 more]</label></div><br/><div class="children"><div class="content">All wifi is a giant collision domain. Also, each segment of a wired network is a collision domain.<p>What you are describing is more in line with MPLS or Infiniband.<p>I agree with you frustration. I prefer to design networks that start routing right at the access port or even using an agent, virtual network port, or VPN endpoint at the client or application (like QUIC), but that is very expensive from a resource standpoint.<p>IPv6 is also another way to get closer to what you are describing.<p>In my perfect world, we&#x27;d move to something like a mashup of MPLS and HIP (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Host_Identity_Protocol" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Host_Identity_Protocol</a>)<p>If want to study something more &quot;routed&quot; and more point to point, look at private mobile networks (5G).<p>What we don&#x27;t want is more layers of abstraction... that&#x27;s making every slow, brittle and impossible to troubleshoot.</div><br/><div id="41326134" class="c"><input type="checkbox" id="c-41326134" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41324133">root</a><span>|</span><a href="#41324441">parent</a><span>|</span><a href="#41325609">next</a><span>|</span><label class="collapse" for="c-41326134">[-]</label><label class="expand" for="c-41326134">[1 more]</label></div><br/><div class="children"><div class="content">WiFi uses a different protocol than classic Ethernet, with &quot;Collision Avoidance&quot; instead of &quot;Collision Detection&quot;. The reason is that one WiFi station cannot know what sources of radio interference exist at the other stations of a network, because it may hear only a part of them at its location.<p>So all remnants of the original Ethernet could be removed from wired Ethernet, which does not need layer 2 protocols, while keeping adequate layer 2 protocols for wireless communications. Besides WiFi, there are also long-range point-to-point wireless links, where directive antennas are used at both ends. For these, there is no difference from wired links, so they do not need layer 2 protocols.</div><br/></div></div><div id="41325609" class="c"><input type="checkbox" id="c-41325609" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#41324133">root</a><span>|</span><a href="#41324441">parent</a><span>|</span><a href="#41326134">prev</a><span>|</span><a href="#41324495">next</a><span>|</span><label class="collapse" for="c-41325609">[-]</label><label class="expand" for="c-41325609">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Also, each segment of a wired network is a collision domain</i><p>huh? where &quot;segment&quot; means where you are using a hub not a switch? cuz that was a long time ago</div><br/></div></div></div></div><div id="41324495" class="c"><input type="checkbox" id="c-41324495" checked=""/><div class="controls bullet"><span class="by">addaon</span><span>|</span><a href="#41324133">parent</a><span>|</span><a href="#41324441">prev</a><span>|</span><a href="#41324702">next</a><span>|</span><label class="collapse" for="c-41324495">[-]</label><label class="expand" for="c-41324495">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When was the last time you saw ethernet frame collisions because you used a hub not a switch?<p>10base-T1S is just beginning to ramp up in the automotive industry, which modifies the super-successful 100base-T1 to be cheaper by (a) allowing cheaper PHYs; (b) allowing cheaper endpoints due to the lower data rate to handle; (c) allowing lower-spec single twisted pair wiring; and ... (d) allowing multi-drop. This is intended to allow Ethernet to push down into the space that CAN-FD is currently occupying, and looks likely to succeed, at least in some niches.</div><br/></div></div><div id="41324702" class="c"><input type="checkbox" id="c-41324702" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#41324133">parent</a><span>|</span><a href="#41324495">prev</a><span>|</span><a href="#41324768">next</a><span>|</span><label class="collapse" for="c-41324702">[-]</label><label class="expand" for="c-41324702">[3 more]</label></div><br/><div class="children"><div class="content">A really interesting article covering this: “The world in which IPv6 was a good design”   <a href="https:&#x2F;&#x2F;apenwarr.ca&#x2F;log&#x2F;20170810" rel="nofollow">https:&#x2F;&#x2F;apenwarr.ca&#x2F;log&#x2F;20170810</a><p>It talks about how when IPv6 was being designed, they wanted to do exactly that: drop most of the layer 2 stuff, abandon the idea of a bus network, make everything point-to-point, all switches would be L3 routers, etc.<p>Search for “What if instead the world worked like this?” for the relevant part.<p>My question though, is how would IP assignment work for each of the intermediary devices between me and (say) my ISP’s gateway? My computer is plugged into a switch right now, which is plugged into another switch, which is plugged into my router, which has a point-to-point link to the ISP gateway. Would my router get a &#x2F;64, then delegate a &#x2F;68 to the next “router” (ie. The physical thing I currently call a switch), which would delegate a &#x2F;72 to the next one, etc? How would it determine the optimal IP allocation? What if there’s a cycle? Aren’t we sorta reinventing spanning tree at this point? (I’m genuinely curious about this, because I don’t really grok all of the implications of an “everything is L3” world like this.)</div><br/><div id="41325301" class="c"><input type="checkbox" id="c-41325301" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41324133">root</a><span>|</span><a href="#41324702">parent</a><span>|</span><a href="#41324768">next</a><span>|</span><label class="collapse" for="c-41325301">[-]</label><label class="expand" for="c-41325301">[2 more]</label></div><br/><div class="children"><div class="content">For v6-specific world, scoped addresses and scoped multicast are explicitly for that purpose. You do not need to hierarchically subnet each following router, you just need to be able to express &quot;next hop&quot; for the subnets you need to route towards.<p>You use link-local autoconfiguration, and use appropriately-scoped multicast addresses to ask &quot;all-nodes&quot; or &quot;all-routers&quot;, making autoconfiguration a breeze compared to v4 world. In v4 world a similar setup is also possible, though specific details of the setup differ, and you have to setup addresses manually for each p2p link.</div><br/><div id="41325466" class="c"><input type="checkbox" id="c-41325466" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#41324133">root</a><span>|</span><a href="#41325301">parent</a><span>|</span><a href="#41324768">next</a><span>|</span><label class="collapse" for="c-41325466">[-]</label><label class="expand" for="c-41325466">[1 more]</label></div><br/><div class="children"><div class="content">I mean sure, you’d definitely use a scoped address to talk to the next hop, but it still doesn’t solve how the router&#x2F;switch knows which port to send the packet to for its next destination.<p>Say I have a global unicast address on my desktop, 2 hops from my router, and I want to allow traffic to it. My router gets a packet sent to it over its link-local address, with a destination header of my desktop’s IP. Say it has 4 ports (each going to another router&#x2F;switch, each with its own link-local address.)<p>How would it know which port to use as the next hop? It would need a routing table, and that would need to be configured automatically if we want to work as well as switches do today. What would be the protocol for this auto configuration? BGP or something like it? How do the routers know the available address space? Or are we just stipulating that we’d invent a protocol for this, if it had ever happened?<p>In ethernet we have the Spanning Tree Protocol for this, to discover the topology of an Ethernet network and know which links to use for which MAC addresses (including the ability to detect cycles.) I feel like <i>something</i> like spanning tree would still need to exist in an all-unicast, no-ethernet, L3-only world. Does such a thing exist already, or would we need to invent it in this counterfactual universe?</div><br/></div></div></div></div></div></div><div id="41324768" class="c"><input type="checkbox" id="c-41324768" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41324133">parent</a><span>|</span><a href="#41324702">prev</a><span>|</span><a href="#41325711">next</a><span>|</span><label class="collapse" for="c-41324768">[-]</label><label class="expand" for="c-41324768">[2 more]</label></div><br/><div class="children"><div class="content">If you force all links to be conceptually point to point, you probably make it harder to do some things. Already 1G and higher force full duplex, and 100base-TX full duplex is very common. I&#x27;ve still got a couple 10baseT half duplex devices though.<p>I have redundant internet&#x2F;nat routers at home (overkill!), and they communicate amongst each other to decide which is active and which isn&#x27;t, but either way, the active one ARPs for the router address with 00-00-5E-00-01-01 as the mac address. The rest of the network just sends off-network packets to  00-00-5E-00-01-01, and failover happens because switches figure out what port is currently using that address.<p>I share a different mac address for the upstream connection, which is PPPoE (sadly), but same deal --- when failover happens, the new computer starts using the address and everything figures it out, because stations are allowed to move to different ports by design.</div><br/><div id="41325045" class="c"><input type="checkbox" id="c-41325045" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41324133">root</a><span>|</span><a href="#41324768">parent</a><span>|</span><a href="#41325711">next</a><span>|</span><label class="collapse" for="c-41325045">[-]</label><label class="expand" for="c-41325045">[1 more]</label></div><br/><div class="children"><div class="content">You can pretty much 1:1 what you describe in the redundancy case with IP, just replace the &quot;relearn which port the MAC address associated with that IP is on&quot; with &quot;relearn which port the next hop for that IP is on&quot;.<p>Things tend to get a little messier than people expect in figuring out the &quot;what values do I use for the point to point links and how do they get assigned&quot; step of things, though there are some clever answers there too.</div><br/></div></div></div></div><div id="41325711" class="c"><input type="checkbox" id="c-41325711" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41324133">parent</a><span>|</span><a href="#41324768">prev</a><span>|</span><a href="#41323142">next</a><span>|</span><label class="collapse" for="c-41325711">[-]</label><label class="expand" for="c-41325711">[1 more]</label></div><br/><div class="children"><div class="content">Actually, I know of one large system that heavily relies on having racks and racks of servers all located in the same broadcast domain. It makes the networking a bit more complicated, but in turn the software is a lot less complicated. It’s a decent trade–off.</div><br/></div></div></div></div><div id="41323142" class="c"><input type="checkbox" id="c-41323142" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#41324133">prev</a><span>|</span><a href="#41320832">next</a><span>|</span><label class="collapse" for="c-41323142">[-]</label><label class="expand" for="c-41323142">[4 more]</label></div><br/><div class="children"><div class="content">One thing that isn&#x27;t mentioned is that the physical layer at the time was &#x27;flat&#x27; ie: a network had a shared wire. That means bus arbitration (to prevent collisions) was a big deal. Token ring solved that by passing tokens, which presumably guarantees latency. I believe Ethernet just raised a line high, and it was up to everyone to respect that.<p>Of course that changed when switches came out. I have a 10&#x2F;100 hub in a closet somewhere for debugging, since it&#x27;s nice to not have to remember how to get into a switch and set the monitor port.<p>Token ring equivalents are still used in lots of places. From what I remember cable modem data is basically token ring off of channel 0 (though that may not be accurate anymore).</div><br/><div id="41323725" class="c"><input type="checkbox" id="c-41323725" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41323142">parent</a><span>|</span><a href="#41320832">next</a><span>|</span><label class="collapse" for="c-41323725">[-]</label><label class="expand" for="c-41323725">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I believe Ethernet just raised a line high, and it was up to everyone to respect that.<p>It&#x27;s actually much simpler than that.  When you transmit you also listen.  If what you hear is not what you sent,  there is a collision,  and you backoff.</div><br/><div id="41324317" class="c"><input type="checkbox" id="c-41324317" checked=""/><div class="controls bullet"><span class="by">jhayward</span><span>|</span><a href="#41323142">root</a><span>|</span><a href="#41323725">parent</a><span>|</span><a href="#41324486">next</a><span>|</span><label class="collapse" for="c-41324317">[-]</label><label class="expand" for="c-41324317">[1 more]</label></div><br/><div class="children"><div class="content">To be specific, it&#x27;s even more basic than that.  For 10Base-5 and all the coax ethernets, it was &quot;if there&#x27;s more energy on the wire than you are transmitting, a collision is present&quot;.</div><br/></div></div><div id="41324486" class="c"><input type="checkbox" id="c-41324486" checked=""/><div class="controls bullet"><span class="by">FuriouslyAdrift</span><span>|</span><a href="#41323142">root</a><span>|</span><a href="#41323725">parent</a><span>|</span><a href="#41324317">prev</a><span>|</span><a href="#41320832">next</a><span>|</span><label class="collapse" for="c-41324486">[-]</label><label class="expand" for="c-41324486">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. CSMA&#x2F;CD (carrier sense multiple access with collision detection)</div><br/></div></div></div></div></div></div><div id="41320832" class="c"><input type="checkbox" id="c-41320832" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#41323142">prev</a><span>|</span><label class="collapse" for="c-41320832">[-]</label><label class="expand" for="c-41320832">[30 more]</label></div><br/><div class="children"><div class="content">I wish we could have another and bump the packet size.<p>We&#x27;re at the point where we can have millions of packets per second going through a network interface, and it starts to get very silly.<p>It&#x27;s at the point where even a 10G connection requires some thought to actually perform properly. I&#x27;ve managed to get bottlenecked on high end hardware requiring a whole detour into SR-IOV just to get back to decent speeds.</div><br/><div id="41321161" class="c"><input type="checkbox" id="c-41321161" checked=""/><div class="controls bullet"><span class="by">supahfly_remix</span><span>|</span><a href="#41320832">parent</a><span>|</span><a href="#41321383">next</a><span>|</span><label class="collapse" for="c-41321161">[-]</label><label class="expand" for="c-41321161">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I wish we could have another and bump the packet size.<p>The clock precision (100s of ppm) of the NIC oscillators on either side of a network connection gives a physical upper limit on the Ethernet packet size. The space between the packets lets the slower side &quot;catch up&quot;. See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Interpacket_gap" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Interpacket_gap</a> for more info.<p>We could use more precise oscillators to have longer packets but at a more expensive cost.</div><br/><div id="41321521" class="c"><input type="checkbox" id="c-41321521" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321161">parent</a><span>|</span><a href="#41325228">next</a><span>|</span><label class="collapse" for="c-41321521">[-]</label><label class="expand" for="c-41321521">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need that as much on modern protocols.  The point of 8b&#x2F;10b or 64b&#x2F;66b is that it guarantees enough edges to allow receivers to be self clocking from the incoming bits being more or less thrown directly into a PLL.</div><br/><div id="41321751" class="c"><input type="checkbox" id="c-41321751" checked=""/><div class="controls bullet"><span class="by">namibj</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321521">parent</a><span>|</span><a href="#41325228">next</a><span>|</span><label class="collapse" for="c-41321751">[-]</label><label class="expand" for="c-41321751">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a separate concern.<p>The previously mentioned issue is that to never buffer packets in a reclocking repeater on a link, you _need_ the incoming packet rate to never be higher than the rate at which you can send them back out, or else you&#x27;d fill up&#x2F;buffer.<p>If your repeaters are actually switches, this manifests as whether you occasionally drop packets on a full link with uncongested switching fabric. Think two switches with a 10G port and 8 1G ports each used to compress 8 long cables into one (say, via vlan-tagging based on which of the 8 ports).</div><br/></div></div></div></div><div id="41325228" class="c"><input type="checkbox" id="c-41325228" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321161">parent</a><span>|</span><a href="#41321521">prev</a><span>|</span><a href="#41321383">next</a><span>|</span><label class="collapse" for="c-41325228">[-]</label><label class="expand" for="c-41325228">[1 more]</label></div><br/><div class="children"><div class="content">Realistically I think we would be fine to make packet size significantly larger than Ethernet would currently allow if we really wanted. E.g. Infiniband already has 1x lane speeds of 200 Gbps without relying on any interpacket gap for clock sync at all. Ethernet, on the other hand, has been consistently increasing speed while decreasing the number of bits used for the interpacket gap since it&#x27;s less and less relevant for clocking. Put a few bytes back and you could probably do enormous sizes.</div><br/></div></div></div></div><div id="41321383" class="c"><input type="checkbox" id="c-41321383" checked=""/><div class="controls bullet"><span class="by">leoc</span><span>|</span><a href="#41320832">parent</a><span>|</span><a href="#41321161">prev</a><span>|</span><a href="#41324044">next</a><span>|</span><label class="collapse" for="c-41321383">[-]</label><label class="expand" for="c-41321383">[8 more]</label></div><br/><div class="children"><div class="content">(Intentional) jumbo frames at layer 2 and expanded MTUs at layer 3 are certainly available (as you may know). In fact it seems (I am, it should be obvious, not an expert) that using jumbo frames is more or less the common practice by now. There does in fact seem to have been some standards drama about this, too: I can&#x27;t find it now, but IIRC in the &#x27;00s someone&#x27;s proposal to extend the header protocols to allow the header to indicate a frame size of over 1500 bytes was rejected, and nothing seems to have been done since. At the moment it seems that the best way to indicate max. Ethernet frame sizes of over 1500 is an optional field in LLDP(!) <a href="https:&#x2F;&#x2F;www.juniper.net&#x2F;documentation&#x2F;us&#x2F;en&#x2F;software&#x2F;junos&#x2F;user-access&#x2F;topics&#x2F;topic-map&#x2F;device-discovery-using-lldp-lldp-med.html" rel="nofollow">https:&#x2F;&#x2F;www.juniper.net&#x2F;documentation&#x2F;us&#x2F;en&#x2F;software&#x2F;junos&#x2F;u...</a> and the fall-back is sending successively larger pings and seeing when the network breaks(!) <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E36784_01&#x2F;html&#x2F;E36815&#x2F;gmzds.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E36784_01&#x2F;html&#x2F;E36815&#x2F;gmzds.html</a> .</div><br/><div id="41323476" class="c"><input type="checkbox" id="c-41323476" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321383">parent</a><span>|</span><a href="#41321510">next</a><span>|</span><label class="collapse" for="c-41323476">[-]</label><label class="expand" for="c-41323476">[4 more]</label></div><br/><div class="children"><div class="content">The common advice I&#x27;ve heard for jumbo frames is not to enable them unless you can do it for every devices on your LAN, and even then it&#x27;s probably not worthwhile outside specific situations like a separate iSCSI network or such.<p>I just now ran iperf3 from my Mac to my Synology without jumbo frames:<p><pre><code>  [ ID] Interval           Transfer     Bitrate         Retr
  [  7]   0.00-10.00  sec  10.0 GBytes  8.61 Gbits&#x2F;sec    0             sender
  [  7]   0.00-10.00  sec  10.0 GBytes  8.60 Gbits&#x2F;sec                  receiver
</code></pre>
Given how rarely I actually care to saturate the 10Gbit link, I&#x27;d rather use the slightly hypothetically slower default settings that are highly likely to work in all scenarios.</div><br/><div id="41323756" class="c"><input type="checkbox" id="c-41323756" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41323476">parent</a><span>|</span><a href="#41321510">next</a><span>|</span><label class="collapse" for="c-41323756">[-]</label><label class="expand" for="c-41323756">[3 more]</label></div><br/><div class="children"><div class="content">It seems much more effective on plain 1000Base.  It&#x27;s the difference between 850Mb&#x2F;s and 975Mb&#x2F;s for me.</div><br/><div id="41325276" class="c"><input type="checkbox" id="c-41325276" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41323756">parent</a><span>|</span><a href="#41323914">next</a><span>|</span><label class="collapse" for="c-41325276">[-]</label><label class="expand" for="c-41325276">[1 more]</label></div><br/><div class="children"><div class="content">That difference is due to your devices relatively poor at handling high pps workloads and not really related to the particular speed it&#x27;s running at. You can certainly get more than 850 mbps on a 1000BASE-T link with standard MTU, on the order of ~100 mbps more.</div><br/></div></div><div id="41323914" class="c"><input type="checkbox" id="c-41323914" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41323756">parent</a><span>|</span><a href="#41325276">prev</a><span>|</span><a href="#41321510">next</a><span>|</span><label class="collapse" for="c-41323914">[-]</label><label class="expand" for="c-41323914">[1 more]</label></div><br/><div class="children"><div class="content">That surprises me a little. From the Wikipedia article[0] I&#x27;d expected jumbo frames to be only about 5% more efficient.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Jumbo_frame" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Jumbo_frame</a></div><br/></div></div></div></div></div></div><div id="41321510" class="c"><input type="checkbox" id="c-41321510" checked=""/><div class="controls bullet"><span class="by">scifi</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321383">parent</a><span>|</span><a href="#41323476">prev</a><span>|</span><a href="#41324044">next</a><span>|</span><label class="collapse" for="c-41321510">[-]</label><label class="expand" for="c-41321510">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not certain what my point is, but I wanted to mention that jumbo frames don&#x27;t work over the Internet. More of a LAN thing.</div><br/><div id="41321779" class="c"><input type="checkbox" id="c-41321779" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321510">parent</a><span>|</span><a href="#41324044">next</a><span>|</span><label class="collapse" for="c-41321779">[-]</label><label class="expand" for="c-41321779">[2 more]</label></div><br/><div class="children"><div class="content">My local internet exchange has a 1500 vlan and a 9000 vlan. My understanding is there are many fewer peers on the 9000 vlan, but it&#x27;s not zero.<p>If you want to use jumbo packets on the internet at large, you need to have working path MTU detection, which realistically means at least probing, but you really should have that at 1500 too, because there&#x27;s still plenty of broken networks out there. My guess is you won&#x27;t have many connections with an effective mtu above 1500, but you might have some.</div><br/><div id="41325307" class="c"><input type="checkbox" id="c-41325307" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321779">parent</a><span>|</span><a href="#41324044">next</a><span>|</span><label class="collapse" for="c-41325307">[-]</label><label class="expand" for="c-41325307">[1 more]</label></div><br/><div class="children"><div class="content">Separate peering VLANs for those using 1500 byte peering and 9000 byte peering about sums up how much of a PITA it is to mix things and expect PMTUD to work.<p>I&#x27;d be willing to bet my lunch more 10x more places have been moving down to assuming 1280 byte connections (since IPv6 guarantees it) than have been peering on the internet at &gt;1500 (not counting 1504 for VLAN tags and whathaveyou).</div><br/></div></div></div></div></div></div></div></div><div id="41321197" class="c"><input type="checkbox" id="c-41321197" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#41320832">parent</a><span>|</span><a href="#41324044">prev</a><span>|</span><a href="#41321970">next</a><span>|</span><label class="collapse" for="c-41321197">[-]</label><label class="expand" for="c-41321197">[2 more]</label></div><br/><div class="children"><div class="content">MTUs are one of the eternal gremlins of networking, and any choice of MTU will almost certainly be either too large for the present day or too small for the future. 1500 was chosen back when computers ran at dozens of <i>megahertz</i> and it was actually kind of large at the time.<p>Changing the MTU is awful because parameters like MTU get baked into hardware in the form of buffer sizes limited by actual RAM limits. Like everything else on a network once the network is deployed changing it is very hard because you have to change everything along the path. Networks are limited by the lowest common denominator.<p>This kind of thing is one of the downsides of packet switching networks like IP. The OSI folks envisioned a network that presented a higher level interface where you&#x27;d open channels or send messages and the underlying network would handle <i>all</i> the details for you. This would be more like the classic analog phone network where you make a phone call and a channel is opened and all details are invisible.<p>It&#x27;s very loosely analogous to CISC vs RISC where the OSI approach is more akin to CISC. In networking RISC won out for numerous reasons, but its simplicity causes a lot of deep platform details to leak into upper application layers. High-level applications should arguably not even have to think about things like MTU, but they do.<p>When higher level applications have to think about things like NAT and stateful firewall traversal, IPv4 vs IPv6, port remapping, etc. is where it gets <i>very</i> ugly.<p>The downside of the OSI approach is that innovation would require the cooperation of telecoms. Every type of connection, etc., would be a product offered by the underlying network. It would also give telecoms a ton of power to nickel and dime, censor, conduct surveillance, etc. and would make anonymity and privacy very hard. It would be a much more managed Internet as opposed to the packet switching Wild West that we got.</div><br/><div id="41322389" class="c"><input type="checkbox" id="c-41322389" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321197">parent</a><span>|</span><a href="#41321970">next</a><span>|</span><label class="collapse" for="c-41322389">[-]</label><label class="expand" for="c-41322389">[1 more]</label></div><br/><div class="children"><div class="content">Most high level applications do not deal with any of the low level details. They open a channel by specifying a hostname and a port number, and are given a reliable bidirectional byte stream from the network layer.<p>As far as most applications are concerned, the hostname is just a string that is interperated by the network layer. Be that through a DNS lookup, or parsing as an address native to the underlying network protocol.<p>A minority of applications get fancy and request a datagram oriented link, which the network layer also provides (with an admittadly small limit of 65KB that leaks over from that.<p>Few applications ever go deeper than that.</div><br/></div></div></div></div><div id="41321970" class="c"><input type="checkbox" id="c-41321970" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#41320832">parent</a><span>|</span><a href="#41321197">prev</a><span>|</span><a href="#41321517">next</a><span>|</span><label class="collapse" for="c-41321970">[-]</label><label class="expand" for="c-41321970">[7 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I wish we could have another and bump the packet size.</i><p>That&#x27;s why I&#x27;m in full support of a world ending apocalypse that allows society to restart from scratch. We&#x27;ve made so many bad decisions this time around, with packet sizes being some of the worst.</div><br/><div id="41322089" class="c"><input type="checkbox" id="c-41322089" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321970">parent</a><span>|</span><a href="#41322505">next</a><span>|</span><label class="collapse" for="c-41322089">[-]</label><label class="expand" for="c-41322089">[3 more]</label></div><br/><div class="children"><div class="content">Maybe we can then also redefine pi as 2*pi, while we&#x27;re at it.</div><br/><div id="41323324" class="c"><input type="checkbox" id="c-41323324" checked=""/><div class="controls bullet"><span class="by">HappMacDonald</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41322089">parent</a><span>|</span><a href="#41322505">next</a><span>|</span><label class="collapse" for="c-41323324">[-]</label><label class="expand" for="c-41323324">[2 more]</label></div><br/><div class="children"><div class="content">Or just use tau and call it &quot;tau&quot;</div><br/><div id="41324335" class="c"><input type="checkbox" id="c-41324335" checked=""/><div class="controls bullet"><span class="by">mportela</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41323324">parent</a><span>|</span><a href="#41322505">next</a><span>|</span><label class="collapse" for="c-41324335">[-]</label><label class="expand" for="c-41324335">[1 more]</label></div><br/><div class="children"><div class="content">What a throwback! I remember when the Tau Manifesto came out: <a href="https:&#x2F;&#x2F;tauday.com&#x2F;tau-manifesto" rel="nofollow">https:&#x2F;&#x2F;tauday.com&#x2F;tau-manifesto</a></div><br/></div></div></div></div></div></div><div id="41322505" class="c"><input type="checkbox" id="c-41322505" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321970">parent</a><span>|</span><a href="#41322089">prev</a><span>|</span><a href="#41321517">next</a><span>|</span><label class="collapse" for="c-41322505">[-]</label><label class="expand" for="c-41322505">[3 more]</label></div><br/><div class="children"><div class="content">As long as we also make sure electrons are positively charged this time.</div><br/><div id="41324687" class="c"><input type="checkbox" id="c-41324687" checked=""/><div class="controls bullet"><span class="by">kridsdale3</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41322505">parent</a><span>|</span><a href="#41321517">next</a><span>|</span><label class="collapse" for="c-41324687">[-]</label><label class="expand" for="c-41324687">[2 more]</label></div><br/><div class="children"><div class="content">Then I&#x27;m going to be really confused about positrons!</div><br/><div id="41324931" class="c"><input type="checkbox" id="c-41324931" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41324687">parent</a><span>|</span><a href="#41321517">next</a><span>|</span><label class="collapse" for="c-41324931">[-]</label><label class="expand" for="c-41324931">[1 more]</label></div><br/><div class="children"><div class="content">Oh, but have you heard the news about negatrons?</div><br/></div></div></div></div></div></div></div></div><div id="41321517" class="c"><input type="checkbox" id="c-41321517" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41320832">parent</a><span>|</span><a href="#41321970">prev</a><span>|</span><a href="#41321682">next</a><span>|</span><label class="collapse" for="c-41321517">[-]</label><label class="expand" for="c-41321517">[4 more]</label></div><br/><div class="children"><div class="content">I mean, larger packets (and working path MTU detection) could be useful, but with large (1500) byte packets and reasonable hardware, I never had trouble pushing 10G from the network side. Add TLS and some other processing, and older hardware wouldn&#x27;t keep up, but not because of packetization. Small packets is also a different story.<p>All my hardware at the time was xeon 2690, v1-4. Nics were Intel x520&#x2F;x540 or similar (whatever SuperMicro was using back then). IIRC, v1 could do 10G easy without TLS, 8-9G with TLS, v3 improved AES acceleration and we could push 2x10G. When I turned off NIC packetization acceleration, I didn&#x27;t notice much change in CPU or throughput, but if packetization was a bottleneck it should have been significant.<p>At home, with similar age desktop processors with @ dual core pentium g3470 (haswell, same gen as a 2690v3), I can&#x27;t quite hit 10g in iperf, but it&#x27;s closeish, another two cores would probably do it.<p>In some cases, you can get some big gains in efficiency by lining up the user space cpu with the kernel cpu that handles the rx&#x2F;tx queues that the NIC hashes the connection to, though.</div><br/><div id="41324074" class="c"><input type="checkbox" id="c-41324074" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321517">parent</a><span>|</span><a href="#41321682">next</a><span>|</span><label class="collapse" for="c-41324074">[-]</label><label class="expand" for="c-41324074">[3 more]</label></div><br/><div class="children"><div class="content">I discovered that putting a 10G interface into a bridge implies a very significant slowdown. Linux has to do stuff on the CPU to do the bridging, so that turns off a large part of the card&#x27;s acceleration.<p>That&#x27;s not a good thing for a server that runs a bunch of VMs.<p>Fortunately SR-IOV exists, but it seems a tad silly to me that I have to do all this weird PCIe passthrough stuff just for this. It&#x27;s nice, don&#x27;t get me wrong, but a bit too exotic for what should be a simple setup.</div><br/><div id="41324861" class="c"><input type="checkbox" id="c-41324861" checked=""/><div class="controls bullet"><span class="by">kjellsbells</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41324074">parent</a><span>|</span><a href="#41324386">next</a><span>|</span><label class="collapse" for="c-41324861">[-]</label><label class="expand" for="c-41324861">[1 more]</label></div><br/><div class="children"><div class="content">I always found it ironic that virtualization made me have to care about the hardware more than I ever had to before.<p>2013 me: slap the app on a Dell. It&#x27;ll be fine.<p>2017 me: aw crap, the nic doesnt support SR-IOV. What do you mean, I need a special driver? Oh lordy, I&#x27;m pinning a whole damn CPU just so DPDK can pull packets off the wire?</div><br/></div></div><div id="41324386" class="c"><input type="checkbox" id="c-41324386" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41324074">parent</a><span>|</span><a href="#41324861">prev</a><span>|</span><a href="#41321682">next</a><span>|</span><label class="collapse" for="c-41324386">[-]</label><label class="expand" for="c-41324386">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah, bridged mode on my little pentium system brings perf <i>way</i> down. It was fine on 1G, but when I upgraded to 10G and wanted to hit numbers, I needed to stop doing software bridging. For me, I have slots and NICs, so I moved away from virtual ethernet on a bridge to actual ports; main host gets the 10G, and everything else gets to use 1G ports.<p>No SR-IOV on my board, but that&#x27;s ok.</div><br/></div></div></div></div></div></div><div id="41321682" class="c"><input type="checkbox" id="c-41321682" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41320832">parent</a><span>|</span><a href="#41321517">prev</a><span>|</span><label class="collapse" for="c-41321682">[-]</label><label class="expand" for="c-41321682">[2 more]</label></div><br/><div class="children"><div class="content">Maximum packet size is already configurable on most NICs. 9000 is a typical non-default limit. If you increase the limit, you must do so on all devices on the network. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Jumbo_frame" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Jumbo_frame</a></div><br/><div id="41324174" class="c"><input type="checkbox" id="c-41324174" checked=""/><div class="controls bullet"><span class="by">imoverclocked</span><span>|</span><a href="#41320832">root</a><span>|</span><a href="#41321682">parent</a><span>|</span><label class="collapse" for="c-41324174">[-]</label><label class="expand" for="c-41324174">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen Cisco gear that supports 8192… that was fun to figure out with a separate network team :) “yup, we’ve enabled jumbo frames!”</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>