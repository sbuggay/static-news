<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732179670512" as="style"/><link rel="stylesheet" href="styles.css?v=1732179670512"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.philipzucker.com/sql_graph_csp/">SQL, Homomorphisms and Constraint Satisfaction Problems</a> <span class="domain">(<a href="https://www.philipzucker.com">www.philipzucker.com</a>)</span></div><div class="subtext"><span>xlinux</span> | <span>14 comments</span></div><br/><div><div id="42197125" class="c"><input type="checkbox" id="c-42197125" checked=""/><div class="controls bullet"><span class="by">mbid</span><span>|</span><a href="#42196844">next</a><span>|</span><label class="collapse" for="c-42197125">[-]</label><label class="expand" for="c-42197125">[3 more]</label></div><br/><div class="children"><div class="content">The post mentions the idea that querying a database D can be understood algebraically as enumerating all morphisms Q -&gt; D, where Q is the &quot;classifying&quot; database of the query, i.e. a minimal database instance that admits a single &quot;generic&quot; result of the query. You can use this to give a neat formulation of Datalog evaluation. A Datalog rule then corresponds a morphism P -&gt; H, where P is the classifying database instance of the rule body and H is the classifying database instance for matches of both body and head. For example, for the the transitivity rule<p><pre><code>  edge(x, z) :- edge(x, y), edge(y, z).
</code></pre>
you&#x27;d take for P the database instance containing two rows (a_1, a_2) and (a_2, a_3), and the database instance H contains additionally (a_1, a_3). Now saying that a Database D satisfies this rule means that every morphism P -&gt; D (i.e., every match of the premise of the rule) can be completed to a commuting diagram<p><pre><code>  P --&gt; D
  |    ^
  |   &#x2F;
  ⌄  &#x2F;
  Q 
</code></pre>
where the additional map is the arrow Q -&gt; D, which corresponds to a match of both body and head.<p>This kind of phenomenon is known in category theory as a &quot;lifting property&quot;, and there&#x27;s rich theory around it. For example, you can show in great generality that there&#x27;s always a &quot;free&quot; way to add data to a database D so that it satisfies the lifting property (the orthogonal reflection construction&#x2F;the small object argument). Those are the theoretical underpinnings of the Datalog engine I&#x27;m sometimes working on [1], and there they allow you to prove that Datalog evaluation is also well-defined if you allow adjoining new elements during evaluation in a controlled way. I believe the author of this post is involved in the egglog project [2], which might have similar features as well.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;eqlog&#x2F;eqlog">https:&#x2F;&#x2F;github.com&#x2F;eqlog&#x2F;eqlog</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;egraphs-good&#x2F;egglog">https:&#x2F;&#x2F;github.com&#x2F;egraphs-good&#x2F;egglog</a></div><br/><div id="42201342" class="c"><input type="checkbox" id="c-42201342" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#42197125">parent</a><span>|</span><a href="#42201448">next</a><span>|</span><label class="collapse" for="c-42201342">[-]</label><label class="expand" for="c-42201342">[1 more]</label></div><br/><div class="children"><div class="content">Thank you @xlinux and @mbid. Very interesting and not something I knew much about before.<p>I had a look at eglog and egglog and if I&#x27;m understanding things correctly then one possible use case is type inference and optimization. I&#x27;m particular I looked at the example in [1].<p>I&#x27;m thinking that this could be useful in the PRQL [2] compiler, in particular for: 
a) inference of type restrictions on input relations and resultant output relation types, 
b) optimization of resultant SQL queries.<p>Would you be able to comment on whether that&#x27;s correct?<p>Any links to related examples, papers, or work would be appreciated. Thanks!<p>1: <a href="https:&#x2F;&#x2F;egglog-python.readthedocs.io&#x2F;latest&#x2F;tutorials&#x2F;sklearn.html" rel="nofollow">https:&#x2F;&#x2F;egglog-python.readthedocs.io&#x2F;latest&#x2F;tutorials&#x2F;sklear...</a><p>2: <a href="https:&#x2F;&#x2F;www.prql-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.prql-lang.org&#x2F;</a></div><br/></div></div><div id="42201448" class="c"><input type="checkbox" id="c-42201448" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#42197125">parent</a><span>|</span><a href="#42201342">prev</a><span>|</span><a href="#42196844">next</a><span>|</span><label class="collapse" for="c-42201448">[-]</label><label class="expand" for="c-42201448">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting perspective I hadn&#x27;t heard before on datalog, thanks. How far does it go - can you interpret extensions of datalog (say negation or constrained existentials) in a nice categorical way, for instance? I&#x27;ve given this very little thought but I imagine you&#x27;d have issues with uniqueness of these &quot;minimal&quot; database instances, and I&#x27;m not sure what that means for these lifting properties.<p>(if my question even makes sense, pardon the ignorance)</div><br/></div></div></div></div><div id="42196844" class="c"><input type="checkbox" id="c-42196844" checked=""/><div class="controls bullet"><span class="by">babel_</span><span>|</span><a href="#42197125">prev</a><span>|</span><a href="#42201960">next</a><span>|</span><label class="collapse" for="c-42196844">[-]</label><label class="expand" for="c-42196844">[1 more]</label></div><br/><div class="children"><div class="content">For anyone curious: the performance difference between Clang and GCC on the example C solution for verbal arithmetic comes down to Clang&#x27;s auto-vectorisation (deducing SIMD) whilst GCC here sticks with scalar, which is why the counter brings Clang closer in line to GCC (<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;xfdxGvMYP" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;xfdxGvMYP</a>), and it&#x27;s actually a pretty nice example of auto-vectorisation (and its limitations) in action, which is a fun tangent from this article (given its relevance to high-performance SMT&#x2F;SAT solving for CSP)</div><br/></div></div><div id="42201960" class="c"><input type="checkbox" id="c-42201960" checked=""/><div class="controls bullet"><span class="by">pcblues</span><span>|</span><a href="#42196844">prev</a><span>|</span><a href="#42197498">next</a><span>|</span><label class="collapse" for="c-42201960">[-]</label><label class="expand" for="c-42201960">[1 more]</label></div><br/><div class="children"><div class="content">When SQL can&#x27;t internally optimise a query into a more efficient constraint problem, unrolling joins is the key. This once MSSQL hacker got to the point of optimising queries with large amounts of joins or CTEs to just populating a single table&#x27;s columns with one query per one to a few columns at a time (two minute locking queries down to about two seconds.) After that, I started using SQL to generate SQL and run that for really curly requirements. That gives you the ability to write queries that can search for a particular value in any column in any table, or find changes in the past 5 minutes in any column in any table within a fairly quick timeframe. And that&#x27;s great for debugging applications that interface with the database or identifying rogue table changes. Without needing a transaction log. Programmer&#x27;s paradise :)</div><br/></div></div><div id="42197498" class="c"><input type="checkbox" id="c-42197498" checked=""/><div class="controls bullet"><span class="by">lovasoa</span><span>|</span><a href="#42201960">prev</a><span>|</span><label class="collapse" for="c-42197498">[-]</label><label class="expand" for="c-42197498">[8 more]</label></div><br/><div class="children"><div class="content">The topic of huge queries on tiny databases makes me think of this recent discussion on the SQLite forum: <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;forum&#x2F;forumpost&#x2F;0d18320369" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;forum&#x2F;forumpost&#x2F;0d18320369</a><p>Someone had an issue because SQLite failed to optimize the following query<p><pre><code>    select * from t where x = &#x27;x&#x27; or &#x27;&#x27; = &#x27;x&#x27;
</code></pre>
Someone said that SQLite could not optimize out the &quot;or &#x27;&#x27; = &#x27;x&#x27;&quot; because it would be too expensive to compute. Which is obviously true only for huge queries on tiny datasets.</div><br/><div id="42197614" class="c"><input type="checkbox" id="c-42197614" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#42197498">parent</a><span>|</span><a href="#42197594">next</a><span>|</span><label class="collapse" for="c-42197614">[-]</label><label class="expand" for="c-42197614">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not obviously true at all.  Optimizing out `&#x27;&#x27; = &#x27;x&#x27;` can be done for a fixed cost regardless of record count.</div><br/><div id="42198538" class="c"><input type="checkbox" id="c-42198538" checked=""/><div class="controls bullet"><span class="by">lovasoa</span><span>|</span><a href="#42197498">root</a><span>|</span><a href="#42197614">parent</a><span>|</span><a href="#42197594">next</a><span>|</span><label class="collapse" for="c-42198538">[-]</label><label class="expand" for="c-42198538">[2 more]</label></div><br/><div class="children"><div class="content">Optimizing out static expressions can be done in linear time at best. So if the number of clauses in WHERE is huge and the size of the underlying table is tiny (such as in the examples shown in the article we are commenting on), it will be better not to run the optimization.<p>But of course, in normal life, outside of the world of people having fun with Homomorphisms, queries are much smaller than databases.</div><br/><div id="42198550" class="c"><input type="checkbox" id="c-42198550" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#42197498">root</a><span>|</span><a href="#42198538">parent</a><span>|</span><a href="#42197594">next</a><span>|</span><label class="collapse" for="c-42198550">[-]</label><label class="expand" for="c-42198550">[1 more]</label></div><br/><div class="children"><div class="content">Parsing the expression in the first place is already linear time.</div><br/></div></div></div></div></div></div><div id="42197594" class="c"><input type="checkbox" id="c-42197594" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42197498">parent</a><span>|</span><a href="#42197614">prev</a><span>|</span><a href="#42198312">next</a><span>|</span><label class="collapse" for="c-42197594">[-]</label><label class="expand" for="c-42197594">[2 more]</label></div><br/><div class="children"><div class="content">Why would it be too expensive to optimize out static subexpressions?</div><br/><div id="42198445" class="c"><input type="checkbox" id="c-42198445" checked=""/><div class="controls bullet"><span class="by">jjice</span><span>|</span><a href="#42197498">root</a><span>|</span><a href="#42197594">parent</a><span>|</span><a href="#42198312">next</a><span>|</span><label class="collapse" for="c-42198445">[-]</label><label class="expand" for="c-42198445">[1 more]</label></div><br/><div class="children"><div class="content">My guess is that the expense can be tricky to calculate since the additional optimization prior to executing the query may take longer than if the query was just able to run (depending on the dataset, of course). I wonder if it&#x27;s too expensive to calculate a heuristic as well, so it just allows it to execute.<p>Just a guess.</div><br/></div></div></div></div><div id="42198312" class="c"><input type="checkbox" id="c-42198312" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42197498">parent</a><span>|</span><a href="#42197594">prev</a><span>|</span><label class="collapse" for="c-42198312">[-]</label><label class="expand" for="c-42198312">[2 more]</label></div><br/><div class="children"><div class="content">&gt; SQLite<p>Well... there&#x27;s your problem. SQLite is <i>not</i> a general-purpose RDBMS, it is marketed as a replacement for &quot;fopen()&quot;, a purpose for which it excels.<p>A similar product is the Microsoft Jet database engine, used in products such as Microsoft Exchange and Active Directory. Queries have to be more-or-less manually optimised by the developer, but they run faster and more consistently than they would with a general-purpose query engine designed for ad-hoc queries.</div><br/><div id="42199975" class="c"><input type="checkbox" id="c-42199975" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#42197498">root</a><span>|</span><a href="#42198312">parent</a><span>|</span><label class="collapse" for="c-42199975">[-]</label><label class="expand" for="c-42199975">[1 more]</label></div><br/><div class="children"><div class="content">I hate Jet with a vengeance</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>