<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699693265330" as="style"/><link rel="stylesheet" href="styles.css?v=1699693265330"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://alan.norbauer.com/articles/browser-debugging-tricks">Debugging tricks in the browser</a> <span class="domain">(<a href="https://alan.norbauer.com">alan.norbauer.com</a>)</span></div><div class="subtext"><span>bkudria</span> | <span>45 comments</span></div><br/><div><div id="38227367" class="c"><input type="checkbox" id="c-38227367" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#38227477">next</a><span>|</span><label class="collapse" for="c-38227367">[-]</label><label class="expand" for="c-38227367">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;setTimeout(function() { debugger; }, 5000);<p>This is clever; after all, the only way to beat the recursive turtle stack of chrome debuggers debugging themselves is with the debugger statement.<p>sam.pl, of the infamous myspace Sammy worm, used debugging gotcha&#x27;s to prevent visitors from de-mystifying his obfuscated html homepage.</div><br/><div id="38228227" class="c"><input type="checkbox" id="c-38228227" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#38227367">parent</a><span>|</span><a href="#38227477">next</a><span>|</span><label class="collapse" for="c-38228227">[-]</label><label class="expand" for="c-38228227">[1 more]</label></div><br/><div class="children"><div class="content">Nice, I never knew this trick existed</div><br/></div></div></div></div><div id="38227477" class="c"><input type="checkbox" id="c-38227477" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38227367">prev</a><span>|</span><a href="#38228357">next</a><span>|</span><label class="collapse" for="c-38227477">[-]</label><label class="expand" for="c-38227477">[3 more]</label></div><br/><div class="children"><div class="content">I’d like to see a way to access local variables of an IIFE, without breaking into code in the IIFE’s scope. Is there some way to convince the debugger to do this?</div><br/><div id="38227562" class="c"><input type="checkbox" id="c-38227562" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#38227477">parent</a><span>|</span><a href="#38227635">next</a><span>|</span><label class="collapse" for="c-38227562">[-]</label><label class="expand" for="c-38227562">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re entering a breakpoint from a function called by the IIFE, you can just walk up the stack. If you&#x27;re outside the IIFE entirely, I don&#x27;t think it&#x27;s possible The variables you&#x27;re looking for may not even exist in memory, either before or after execution. Javascript doesn&#x27;t have static variables like other languages do, so each time the IIFE is called, the variables inside it are thrown out. Javascript is also very much single-threaded (unless you use web workers and such, which come with limited interactivity with their parent pages) so unless you&#x27;re trying to race-condition yourself with an async&#x2F;await call, I don&#x27;t think there&#x27;s even a way to conceptually have these variables around in memory outside the IIFE scope.<p>You could (ab)use `var` to initialize the variable outside the IIFE scope so you can see the values produced by the last IIFE call.</div><br/></div></div><div id="38227635" class="c"><input type="checkbox" id="c-38227635" checked=""/><div class="controls bullet"><span class="by">plugin-baby</span><span>|</span><a href="#38227477">parent</a><span>|</span><a href="#38227562">prev</a><span>|</span><a href="#38228357">next</a><span>|</span><label class="collapse" for="c-38227635">[-]</label><label class="expand" for="c-38227635">[1 more]</label></div><br/><div class="children"><div class="content">IIFE: immediately-invoked function expression<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Immediately_invoked_function_expression" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Immediately_invoked_function...</a></div><br/></div></div></div></div><div id="38228357" class="c"><input type="checkbox" id="c-38228357" checked=""/><div class="controls bullet"><span class="by">adr1an</span><span>|</span><a href="#38227477">prev</a><span>|</span><a href="#38227296">next</a><span>|</span><label class="collapse" for="c-38228357">[-]</label><label class="expand" for="c-38228357">[1 more]</label></div><br/><div class="children"><div class="content">For the sake of completeness, I can recommend Werkzeug. I use it for Django backend development and it&#x27;s incredibly useful. It allows me to have &quot;PDB&quot; shell right in the browser whenever and wherever an exception is met.</div><br/></div></div><div id="38227296" class="c"><input type="checkbox" id="c-38227296" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#38228357">prev</a><span>|</span><a href="#38227682">next</a><span>|</span><label class="collapse" for="c-38227296">[-]</label><label class="expand" for="c-38227296">[3 more]</label></div><br/><div class="children"><div class="content">`queryObjects` is notably missing. It is a crazy API which returns a list of all objects created by a particular constructor. One can for example get a list of all functions on the heap by doing `queryObjects(Function)`.<p>This will return even functions contained in some module that are “private”.</div><br/><div id="38227839" class="c"><input type="checkbox" id="c-38227839" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#38227296">parent</a><span>|</span><a href="#38227682">next</a><span>|</span><label class="collapse" for="c-38227839">[-]</label><label class="expand" for="c-38227839">[2 more]</label></div><br/><div class="children"><div class="content">To be honest, this might be one they’d be <i>justified</i> in not wanting you to know. Crazy indeed. Chromium-only, I presume.</div><br/><div id="38228500" class="c"><input type="checkbox" id="c-38228500" checked=""/><div class="controls bullet"><span class="by">adamnemecek</span><span>|</span><a href="#38227296">root</a><span>|</span><a href="#38227839">parent</a><span>|</span><a href="#38227682">next</a><span>|</span><label class="collapse" for="c-38228500">[-]</label><label class="expand" for="c-38228500">[1 more]</label></div><br/><div class="children"><div class="content">Haha, I agree.<p>They do seem to have some strange restrictions on this. E.g. When you evaluate it the function returns undefined but it also outputs the array underneath.
You can right click and save it to variable.<p>I think the point of this so that you cannot assign the output programmatically, there has to be a person who saves it to a variable by right clicking.</div><br/></div></div></div></div></div></div><div id="38227682" class="c"><input type="checkbox" id="c-38227682" checked=""/><div class="controls bullet"><span class="by">russellbeattie</span><span>|</span><a href="#38227296">prev</a><span>|</span><a href="#38227411">next</a><span>|</span><label class="collapse" for="c-38227682">[-]</label><label class="expand" for="c-38227682">[2 more]</label></div><br/><div class="children"><div class="content">I can never get watched variables to work. The scoping and updating rules for it are a mystery to me. I assume only global variables can be watched, but even then it never works as I expect, so I end up just flooding the log with values when testing.<p>I&#x27;ve thought for years the console should add Data.gui [1] style UI for viewing&#x2F;testing variable and settings values. You can see it action on this CodePen [2].<p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;dataarts&#x2F;dat.gui">https:&#x2F;&#x2F;github.com&#x2F;dataarts&#x2F;dat.gui</a><p>2. <a href="https:&#x2F;&#x2F;codepen.io&#x2F;russellbeattie&#x2F;full&#x2F;kGxaqM" rel="nofollow noreferrer">https:&#x2F;&#x2F;codepen.io&#x2F;russellbeattie&#x2F;full&#x2F;kGxaqM</a></div><br/><div id="38228201" class="c"><input type="checkbox" id="c-38228201" checked=""/><div class="controls bullet"><span class="by">20after4</span><span>|</span><a href="#38227682">parent</a><span>|</span><a href="#38227411">next</a><span>|</span><label class="collapse" for="c-38228201">[-]</label><label class="expand" for="c-38228201">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had the same frustration.  The browsers have such great debugging features, in theory, but they never seem to work reliably.  I can&#x27;t even get all of my breakpoints to reliably hit.<p>Everything seems to work ok when the code is unrolled but as soon as it gets bundled, even if not minified, it seems that a lot of debugger features get broken, at least that&#x27;s been my experience.<p>Note: I&#x27;m not a front-end engineer and I&#x27;m probably doing something wrong.</div><br/></div></div></div></div><div id="38227411" class="c"><input type="checkbox" id="c-38227411" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#38227682">prev</a><span>|</span><a href="#38227551">next</a><span>|</span><label class="collapse" for="c-38227411">[-]</label><label class="expand" for="c-38227411">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t any browsers support re-style reverse debugging yet?</div><br/></div></div><div id="38227551" class="c"><input type="checkbox" id="c-38227551" checked=""/><div class="controls bullet"><span class="by">rootsudo</span><span>|</span><a href="#38227411">prev</a><span>|</span><a href="#38227406">next</a><span>|</span><label class="collapse" for="c-38227551">[-]</label><label class="expand" for="c-38227551">[2 more]</label></div><br/><div class="children"><div class="content">This is something I really need to pick up &#x2F; is there a dedicated book or study for this or is it just web dev &#x2F; front end all the way down?</div><br/><div id="38228544" class="c"><input type="checkbox" id="c-38228544" checked=""/><div class="controls bullet"><span class="by">lancebeet</span><span>|</span><a href="#38227551">parent</a><span>|</span><a href="#38227406">next</a><span>|</span><label class="collapse" for="c-38228544">[-]</label><label class="expand" for="c-38228544">[1 more]</label></div><br/><div class="children"><div class="content">I can really recommend following the &quot;What&#x27;s new in DevTools&quot; series by the chrome team. Clicking a link to read release notes when you&#x27;re in the middle of something may not seem appealing, but spending 5 minutes to skim through it when a new version is released is well worth your time. There are also digestible videos that are just a few minutes long and will give you a brief overview. While their purpose is to show new features, in my experience you will often gain understanding of the current limitations of the tools as well.</div><br/></div></div></div></div><div id="38227406" class="c"><input type="checkbox" id="c-38227406" checked=""/><div class="controls bullet"><span class="by">Andrews54757</span><span>|</span><a href="#38227551">prev</a><span>|</span><a href="#38227274">next</a><span>|</span><label class="collapse" for="c-38227406">[-]</label><label class="expand" for="c-38227406">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed that a lot of websites will try to prevent you from using the debugger. They use various techniques ranging from calling `debugger` every second to entrapped sourcemaps to make debugger features work against you!<p>Take a look at disable-devtool [1], it surprises me just how many methods can be used to detect usage of an invaluable tool that should be a user&#x27;s right to use. These &quot;exploits&quot; should really be patched browser-side, but I don&#x27;t see any active efforts by browsers to fix this.<p>I&#x27;ve created a simple anti-anti-debug extension [2] that monkey-patches my way around these anti-debug scripts. It works fine for now, but I can&#x27;t imagine it working consistently in the long term once the inevitable arms race begins.<p>How can we get Google, Mozilla, etc... to care about dev tool accessibility?<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;theajack&#x2F;disable-devtool">https:&#x2F;&#x2F;github.com&#x2F;theajack&#x2F;disable-devtool</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;Andrews54757&#x2F;Anti-Anti-Debug">https:&#x2F;&#x2F;github.com&#x2F;Andrews54757&#x2F;Anti-Anti-Debug</a></div><br/><div id="38227475" class="c"><input type="checkbox" id="c-38227475" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#38227406">parent</a><span>|</span><a href="#38227606">next</a><span>|</span><label class="collapse" for="c-38227475">[-]</label><label class="expand" for="c-38227475">[3 more]</label></div><br/><div class="children"><div class="content">A simple way to solve this issue is to just deprecate the debugger statement and have people rely on setting up breakpoints manually, or request an explicit opt in into the debugger statement so that random websites don’t hijack it.</div><br/><div id="38228643" class="c"><input type="checkbox" id="c-38228643" checked=""/><div class="controls bullet"><span class="by">no_time</span><span>|</span><a href="#38227406">root</a><span>|</span><a href="#38227475">parent</a><span>|</span><a href="#38227528">next</a><span>|</span><label class="collapse" for="c-38228643">[-]</label><label class="expand" for="c-38228643">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t need to deprecate it. I remember reading a blogpost here that was about bypassing these kinds of checks. They recompiled SpiderMonkey with the debugger() method renamed to something else.</div><br/></div></div><div id="38227528" class="c"><input type="checkbox" id="c-38227528" checked=""/><div class="controls bullet"><span class="by">Andrews54757</span><span>|</span><a href="#38227406">root</a><span>|</span><a href="#38227475">parent</a><span>|</span><a href="#38228643">prev</a><span>|</span><a href="#38227606">next</a><span>|</span><label class="collapse" for="c-38227528">[-]</label><label class="expand" for="c-38227528">[1 more]</label></div><br/><div class="children"><div class="content">That would be helpful, but there are also other methods that don&#x27;t involve using the debugger. For example, one technique involves periodically printing a custom object to the console with a toString getter. This is programmatically called by the browser only when the devtools are opened. This allows the website to know when you&#x27;ve opened devtools and they will redirect&#x2F;block&#x2F;crash your browser in response.</div><br/></div></div></div></div><div id="38227606" class="c"><input type="checkbox" id="c-38227606" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#38227406">parent</a><span>|</span><a href="#38227475">prev</a><span>|</span><a href="#38227610">next</a><span>|</span><label class="collapse" for="c-38227606">[-]</label><label class="expand" for="c-38227606">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve pondered why websites who are that afraid of reverse engineering don&#x27;t simply feed the browser mock data or kill a user&#x27;s session (with a five minute IP block) when the browser requests a source map. Almost all browsers request them by default the moment you open the debugger and normal users very rarely hit the debugger.<p>Sure, it&#x27;d be trivial to circumvent such a block, but it&#x27;d easily inconvenience most of the low-hanging fruit enough that things like community maintained ad blockers could become ineffective. Surely simply never serving ads to people who open the dev tools would prevent the 99.9% of normal users from using effective ad blockers in their browsers.</div><br/><div id="38227617" class="c"><input type="checkbox" id="c-38227617" checked=""/><div class="controls bullet"><span class="by">Andrews54757</span><span>|</span><a href="#38227406">root</a><span>|</span><a href="#38227606">parent</a><span>|</span><a href="#38227610">next</a><span>|</span><label class="collapse" for="c-38227617">[-]</label><label class="expand" for="c-38227617">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen some websites do this in the wild, it&#x27;s why I recommend turning the sourcemaps off in the troubleshooting section of my anti-anti-debug tool.<p>It&#x27;s pretty easy to circumvent this method, but honestly the user shouldn&#x27;t have to configure their browsers to be resistant to anti-debugging. From the side of the website, it should be impossible to know if the debug tools are just open.</div><br/></div></div></div></div><div id="38227610" class="c"><input type="checkbox" id="c-38227610" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#38227406">parent</a><span>|</span><a href="#38227606">prev</a><span>|</span><a href="#38227680">next</a><span>|</span><label class="collapse" for="c-38227610">[-]</label><label class="expand" for="c-38227610">[1 more]</label></div><br/><div class="children"><div class="content">Imagine if browser developer tools were reasonably architected so e.g. opening the DOM inspector didn&#x27;t provide a vector for anti-tamper code targeting the JS debugger to DOS your attempts to poke at the CSS or read network requests.  Or get this: for non-hostile content—like something you yourself have written—maybe you could have the debugger and the inspector open in separate windows, or even have multiple object inspectors open on different objects at the same time.  Gee.  Fuckin&#x27; novel idea.  Maybe this is something we&#x27;ll be able to look forward to once the year 2000 rolls around.</div><br/></div></div><div id="38227680" class="c"><input type="checkbox" id="c-38227680" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38227406">parent</a><span>|</span><a href="#38227610">prev</a><span>|</span><a href="#38227408">next</a><span>|</span><label class="collapse" for="c-38227680">[-]</label><label class="expand" for="c-38227680">[2 more]</label></div><br/><div class="children"><div class="content">The ultimate way is process everything on the server with a sockets to webapi adaptor on the client. Then all you see is commands coming from the server to pull various strings.</div><br/><div id="38228467" class="c"><input type="checkbox" id="c-38228467" checked=""/><div class="controls bullet"><span class="by">youngtaff</span><span>|</span><a href="#38227406">root</a><span>|</span><a href="#38227680">parent</a><span>|</span><a href="#38227408">next</a><span>|</span><label class="collapse" for="c-38228467">[-]</label><label class="expand" for="c-38228467">[1 more]</label></div><br/><div class="children"><div class="content">Even then some sites detect the DevTools connection and prevent you from normal (on-site) actions</div><br/></div></div></div></div></div></div><div id="38227274" class="c"><input type="checkbox" id="c-38227274" checked=""/><div class="controls bullet"><span class="by">temporallobe</span><span>|</span><a href="#38227406">prev</a><span>|</span><a href="#38227791">next</a><span>|</span><label class="collapse" for="c-38227274">[-]</label><label class="expand" for="c-38227274">[10 more]</label></div><br/><div class="children"><div class="content">None of these are weird or something the browser is trying to hide from you, just things that an experienced front-end developer would probably know, although I was not aware of the monitor() command.<p>That being said, I am pleasantly surprised at the debugging and development tooling that is built right into most modern browsers. It really does make the UI development experience very powerful. I wish more back-end languages had this experience.</div><br/><div id="38227476" class="c"><input type="checkbox" id="c-38227476" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#38227274">parent</a><span>|</span><a href="#38227383">next</a><span>|</span><label class="collapse" for="c-38227476">[-]</label><label class="expand" for="c-38227476">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I wish more back-end languages had this experience.<p>I know what that feels like. I have that same feeling about a whole bunch of languages that has been available in .NET for at least 15 years now.<p>When I got into programming, I moved from VB6 to VB.NET to C#, the latter two using a cracked version of MS Visual Studio I downloaded at school. I only started seriously using the debugger somewhere around the time I taught myself C#.<p>Because of this, I got used to the idea that in a normal debugger, you could just click and drag back the point of execution, modify the code, and hit resume. The VS time traveling debugger will actually revert variable assignments, recompile the modified code, insert it in its place, and continue execution. This wouldn&#x27;t work with P&#x2F;Invoke calls, but it worked great for what I was trying to do. Debugging and fixing mistakes was absolutely trivial.<p>Imagine my betrayal when I found out that there was nothing like this in C++, or Java, or Javascript. Java has gotten a similar feature, but I&#x27;ve never worked with an IDE that integrated it even close to how well VS 2008 integrated it.<p>Even today, this seemingly basic feature that I took for granted just isn&#x27;t available in many modern IDEs. I understand natively compiled languages like C&#x2F;C++&#x2F;Rust&#x2F;Go not supporting the inline code replacement feature, but the hot reload in languages like Kotlin, Java, and Javascript just don&#x27;t work like it did for me back in 2008.<p>As for all these tricks: I think most of them are available in most IDEs. Anything involving conditional breakpoints will work regardless of the language you use (although languages like Rust can have some restrictions). Tracing callers should work in any decent debugger. Timing individual functions may require writing out long package names to get to the right methods, but they should be available. The monitor() trick can be replaced by a logging method breakpoint.<p>How well DOM-related debugging works, will depend on whether or not your GUI framework uses a DOM and how it&#x27;s constructed. If you&#x27;re composing a DOM from multiple individual functions (like in React&#x2F;Flutter&#x2F;Kotlin Compose) then you can add breakpoints to all the relevant state alterations. If your tooling uses a more C-inspired windowing mechanism, you&#x27;re probably going to have to get creative.<p>When you get down into the weeds of it, I think you&#x27;ll find that more of these features are available for backend languages than you might expect. I would recommend any developer to occasionally read the changelogs of their IDEs (or to grab an IDE if you normally don&#x27;t use any) and take a few moments to explore the possibilities of modern debuggers.</div><br/><div id="38227749" class="c"><input type="checkbox" id="c-38227749" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38227274">root</a><span>|</span><a href="#38227476">parent</a><span>|</span><a href="#38227383">next</a><span>|</span><label class="collapse" for="c-38227749">[-]</label><label class="expand" for="c-38227749">[1 more]</label></div><br/><div class="children"><div class="content">I love your description of undoing code execution, modifying the code and continuing. I think too often these days because of the UNIX philosophy of doing one thing well, the debugger and the compiler and even the linker are different projects, making it unnecessarily complicated to combine these tools other than passing blobs of output into another tool&#x27;s input. We should aim higher.</div><br/></div></div></div></div><div id="38227383" class="c"><input type="checkbox" id="c-38227383" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38227274">parent</a><span>|</span><a href="#38227476">prev</a><span>|</span><a href="#38227375">next</a><span>|</span><label class="collapse" for="c-38227383">[-]</label><label class="expand" for="c-38227383">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I wish more back-end languages had this experience.<p>the jvm debugging experience is pretty good imho.<p>It&#x27;s the compiled languages that have a poor experience with debugging - try injecting code to execute in a c debugger! It&#x27;s hard as hell to do!</div><br/><div id="38227515" class="c"><input type="checkbox" id="c-38227515" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#38227274">root</a><span>|</span><a href="#38227383">parent</a><span>|</span><a href="#38227396">next</a><span>|</span><label class="collapse" for="c-38227515">[-]</label><label class="expand" for="c-38227515">[1 more]</label></div><br/><div class="children"><div class="content">&gt; try injecting code to execute in a c debugger! It&#x27;s hard as hell to do!<p>I mean, theoretically, not really? Allocate a page RW, put in some compiled code, remap as R+X, redirect execution there, return code execution to where it was. Jumping through those hoops will be more expensive when you use the debugger like that (you&#x27;d need to hot patch some kind of jump statement to circumvent that) but it&#x27;s not exactly impossible.<p>Things become difficult when the compiler starts optimizing out code, because the debugger would need to keep track of everything, but I don&#x27;t see why it&#x27;d be technically impossible to do so.<p>Executing code in a C debugger is basically how modern reverse engineering works, it&#x27;s a lot harder than in other languages but it&#x27;s certainly possible.</div><br/></div></div><div id="38227396" class="c"><input type="checkbox" id="c-38227396" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#38227274">root</a><span>|</span><a href="#38227383">parent</a><span>|</span><a href="#38227515">prev</a><span>|</span><a href="#38227375">next</a><span>|</span><label class="collapse" for="c-38227396">[-]</label><label class="expand" for="c-38227396">[1 more]</label></div><br/><div class="children"><div class="content">You know the tooling leaves something to be desired when editing instruction bytes is the best option to NOP out an assert - for example.</div><br/></div></div></div></div><div id="38227375" class="c"><input type="checkbox" id="c-38227375" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#38227274">parent</a><span>|</span><a href="#38227383">prev</a><span>|</span><a href="#38228111">next</a><span>|</span><label class="collapse" for="c-38227375">[-]</label><label class="expand" for="c-38227375">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a joke title.</div><br/></div></div><div id="38228111" class="c"><input type="checkbox" id="c-38228111" checked=""/><div class="controls bullet"><span class="by">jmkni</span><span>|</span><a href="#38227274">parent</a><span>|</span><a href="#38227375">prev</a><span>|</span><a href="#38228628">next</a><span>|</span><label class="collapse" for="c-38228111">[-]</label><label class="expand" for="c-38228111">[1 more]</label></div><br/><div class="children"><div class="content">I think the author was just having a bit of fun with the title</div><br/></div></div></div></div><div id="38227791" class="c"><input type="checkbox" id="c-38227791" checked=""/><div class="controls bullet"><span class="by">acemarke</span><span>|</span><a href="#38227274">prev</a><span>|</span><label class="collapse" for="c-38227791">[-]</label><label class="expand" for="c-38227791">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m going to put in a very relevant self-plug for the tool that I work on.<p>I work at Replay.io, and we&#x27;re building a true &quot;time traveling debugger&quot; for JS.  Our app is meant to help simplify debugging scenarios by making it easy to record, reproduce and investigate your code.<p>The basic idea of Replay: Use our fork of Firefox or Chrome to make a recording of your app, load the recording in our debugger UI, and you can pause at _any_ point in the recording.  In fact, you can add print statements to any line of code, and it will show you what it _would_ have printed _every time that line of code ran_!<p>From there, you can jump to any of those print statement hits, and do typical step debugging and inspection of variables. So, it&#x27;s the best of both worlds - you can use print statements <i>and</i> step debugging, together, at any point in time in the recording.  It also lets you inspect the DOM and the React component tree at any point as well.<p>I honestly wish I&#x27;d had Replay available much earlier in my career. I can think of quite a few bugs that I spent hours on that would have been _much_ easier to solve with a Replay recording.  And as an OSS maintainer for Redux, there&#x27;s been a number of bugs that I was _only_ able to solve myself in the last year because I was able to make a recording of a repro and investigate it further (like a tough subscription timing issue in RTK Query, or a transpilation issue in the RTK listener middleware).<p>If anyone would like to try it out, see <a href="https:&#x2F;&#x2F;replay.io&#x2F;record-bugs" rel="nofollow noreferrer">https:&#x2F;&#x2F;replay.io&#x2F;record-bugs</a> for the getting started steps to use Replay (although FYI we&#x27;re in the middle of a transition from Firefox to Chromium as our primary recording browser fork).<p>I also did a &quot;Learn with Jason&quot; episode where we talked about debugging concepts in general, looked at browser devtools UI features specifically, and then did an example of recording and debugging with Replay: <a href="https:&#x2F;&#x2F;www.learnwithjason.dev&#x2F;travel-through-time-to-debug-javascript" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.learnwithjason.dev&#x2F;travel-through-time-to-debug-...</a><p>If you&#x27;ve got any questions, please come by our Discord and ask! <a href="https:&#x2F;&#x2F;replay.io&#x2F;discord" rel="nofollow noreferrer">https:&#x2F;&#x2F;replay.io&#x2F;discord</a></div><br/><div id="38227975" class="c"><input type="checkbox" id="c-38227975" checked=""/><div class="controls bullet"><span class="by">altano</span><span>|</span><a href="#38227791">parent</a><span>|</span><a href="#38228574">next</a><span>|</span><label class="collapse" for="c-38227975">[-]</label><label class="expand" for="c-38227975">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the author of the article and my advice is that you stop reading it and go learn about Replay.io instead. It&#x27;s the most slept on web tech and will up your debugging game immensely. Seriously, go check it out.</div><br/></div></div><div id="38228574" class="c"><input type="checkbox" id="c-38228574" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#38227791">parent</a><span>|</span><a href="#38227975">prev</a><span>|</span><a href="#38228503">next</a><span>|</span><label class="collapse" for="c-38228574">[-]</label><label class="expand" for="c-38228574">[1 more]</label></div><br/><div class="children"><div class="content">Once I can replicate an issue locally, I don’t normally find it too difficult to understand what’s happening.<p>Harder is reproducing a bug based on what I’ve got to go on in Sentry. Mostly it’s easy enough to figure out but the traces you get in JS are very light in information compared to what you get in Python for example.<p>Anyone have any tips on getting more information in the initial report?</div><br/></div></div><div id="38228503" class="c"><input type="checkbox" id="c-38228503" checked=""/><div class="controls bullet"><span class="by">dmitry-vsl</span><span>|</span><a href="#38227791">parent</a><span>|</span><a href="#38228574">prev</a><span>|</span><a href="#38228161">next</a><span>|</span><label class="collapse" for="c-38228503">[-]</label><label class="expand" for="c-38228503">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; you can use print statements and step debugging, together, at any point in time in the recording<p>I am working on something similar. I am building an IDE that allows to jump from the line printed by a console.log call to a corresponding code location, and observe variables and intermediate expressions.<p>It also displays a dynamic calltree of a program, allowing to navigate it in a time-travel manner.<p>Currently it only supports pure functional subset of JavaScript, but I am working on support for imperative programming (mutating data in place).<p><a href="https:&#x2F;&#x2F;leporello.tech&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;leporello.tech&#x2F;</a></div><br/></div></div><div id="38228161" class="c"><input type="checkbox" id="c-38228161" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#38227791">parent</a><span>|</span><a href="#38228503">prev</a><span>|</span><a href="#38227963">next</a><span>|</span><label class="collapse" for="c-38228161">[-]</label><label class="expand" for="c-38228161">[1 more]</label></div><br/><div class="children"><div class="content">Is replay.io able to deterministically replay multiple WebWorkers interacting with a SharedArrayBuffer?</div><br/></div></div><div id="38227963" class="c"><input type="checkbox" id="c-38227963" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#38227791">parent</a><span>|</span><a href="#38228161">prev</a><span>|</span><a href="#38228626">next</a><span>|</span><label class="collapse" for="c-38227963">[-]</label><label class="expand" for="c-38227963">[3 more]</label></div><br/><div class="children"><div class="content">&gt; (although FYI we&#x27;re in the middle of a transition from Firefox to Chromium as our primary recording browser fork)<p>What&#x27;s the goal of this transition?</div><br/><div id="38228004" class="c"><input type="checkbox" id="c-38228004" checked=""/><div class="controls bullet"><span class="by">acemarke</span><span>|</span><a href="#38227791">root</a><span>|</span><a href="#38227963">parent</a><span>|</span><a href="#38228626">next</a><span>|</span><label class="collapse" for="c-38228004">[-]</label><label class="expand" for="c-38228004">[2 more]</label></div><br/><div class="children"><div class="content">Replay&#x27;s founders originally worked as engineers on the Firefox DevTools (and in fact our debugger client UI started as a fork of the FF Devtools codebase, although at this point we&#x27;ve rewritten basically every single feature over the last year and a half).  So, the original Replay implementation started as a feature built into Firefox, and thus the current Replay recording browser you&#x27;d download has been our fork of Firefox with all the recording capabilities built in.<p>But, Chromium is the dominant browser today.  It&#x27;s what consumers use, it&#x27;s devs use for daily development, and it&#x27;s what testing tools like Cypress and Playwright default to running your tests in.  So, we&#x27;re in the process of getting our Chromium fork up to parity with Firefox.<p>Currently, our Chromium for Linux fork is fully stable in terms of actual recording capability, and we use it extensively for recording E2E tests for ourselves and for customers.  (in fact, if you want to, all the E2E recordings for our own PRs are public - you could pop open any of the recordings from this PR I merged yesterday [0] and debug how the tests ran in CI.)<p>But, our Chromium fork does not yet have the UI in place to let a user manually log in and hit &quot;Record&quot; themselves, the way the Firefox fork does.  It actually automatically records each tab you open, saves the recordings locally, and then you use our CLI tool to upload them to your account.  We&#x27;re actually working on this &quot;Record&quot; button _right now_ and hope to have that available in the next few weeks.<p>Meanwhile, our Chrome for Mac and Windows forks are in early alpha, and the runtime team is focusing on stability and performance.<p>Our goal is to get the manual recording capabilities in place ASAP so we can switch over and make Chromium the default browser you&#x27;d download to make recordings as an individual developer.  It&#x27;s already the default for configuring E2E test setups to record replays, since the interactive UI piece isn&#x27;t necessary there.<p>Also, many of the new time-travel-powered features that we&#x27;re building rely on capabilities exposed by our Chromium fork, which the Firefox fork doesn&#x27;t have.  That includes the improved React DevTools support I&#x27;ve built over the last year, which relies on our time-travel backend API to extract React component tree data, and then does post-processing to enable nifty things like sourcemapping original component names even if you recorded a production app.  I did a talk just a couple weeks ago at React Advanced about how I built that feature [1].  Meanwhile, my teammate Brian Vaughn, who was formerly on the React core team and built most of the current React DevTools browser extension UI, has just rebuilt our React DevTools UI components and started to integrate time-travel capabilities.  He just got a working example of highlighting which props&#x2F;hooks&#x2F;state changed for a selected component, and we&#x27;ve got some other neat features like jumping between each time a component rendered coming soon.  All that relies on data extracted from Chromium-based recordings.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;replayio&#x2F;devtools&#x2F;pull&#x2F;9885#issuecomment-1804384146">https:&#x2F;&#x2F;github.com&#x2F;replayio&#x2F;devtools&#x2F;pull&#x2F;9885#issuecomment-...</a><p>[1] <a href="https:&#x2F;&#x2F;blog.isquaredsoftware.com&#x2F;2023&#x2F;10&#x2F;presentations-react-devtools-replay&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.isquaredsoftware.com&#x2F;2023&#x2F;10&#x2F;presentations-reac...</a></div><br/><div id="38228102" class="c"><input type="checkbox" id="c-38228102" checked=""/><div class="controls bullet"><span class="by">Cannabat</span><span>|</span><a href="#38227791">root</a><span>|</span><a href="#38228004">parent</a><span>|</span><a href="#38228626">next</a><span>|</span><label class="collapse" for="c-38228102">[-]</label><label class="expand" for="c-38228102">[1 more]</label></div><br/><div class="children"><div class="content">Do you plan to maintain the FF Replay fork?<p>Great work Replay team! Awesome tech.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>