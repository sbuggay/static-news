<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689843663954" as="style"/><link rel="stylesheet" href="styles.css?v=1689843663954"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://interrupt.memfault.com/blog/embedded-async-rust">Asynchronous Rust on Cortex-M microcontrollers</a>Â <span class="domain">(<a href="https://interrupt.memfault.com">interrupt.memfault.com</a>)</span></div><div class="subtext"><span>picture</span> | <span>59 comments</span></div><br/><div><div id="36798134" class="c"><input type="checkbox" id="c-36798134" checked=""/><div class="controls bullet"><span class="by">scoutt</span><span>|</span><a href="#36792561">next</a><span>|</span><label class="collapse" for="c-36798134">[-]</label><label class="expand" for="c-36798134">[1 more]</label></div><br/><div class="children"><div class="content">I think the nature of microcontroller programming is already asynchronous. I mean, it&#x27;s not that the only alternative to &quot;async Rust&quot; is an RTOS; a classic loop program with interrupts <i>is</i> already asynchronous. The only difference is you have to decide how you want to waste time waiting for events, and the same &quot;energy saving&quot; effect can also be achieved with a simple state machine and __WFI(), resulting in cleaner code with no dependencies whatsoever.<p>Also, it seems to me that Embassy takes over interrupt handlers? If that&#x27;s the case, what if I want to deal with interrupts in a different way? Or what happens with interrupts that deal with many pins, like EXTI9_5_IRQHandler(), as if I want to use pin 9 with Async Rust, but the rest as a regular interrupt?<p>And Pin type is a poor name choice for embedded.<p>Also:<p><pre><code>    ExtiInputFuture::new(self.pin.pin.pin.pin(), self.pin.pin.pin.port(), true, false).await</code></pre></div><br/></div></div><div id="36792561" class="c"><input type="checkbox" id="c-36792561" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#36798134">prev</a><span>|</span><a href="#36793697">next</a><span>|</span><label class="collapse" for="c-36792561">[-]</label><label class="expand" for="c-36792561">[16 more]</label></div><br/><div class="children"><div class="content">Most of my programming these days is on Cortex-M, using Rust. The article is another prior in my suspicion that Async embedded Rust is designed with toy use cases in mind (blinky); I don&#x27;t know how it would work in practical firemware because I haven&#x27;t seen examples.<p>Another possibility is that my brain and learning patterns don&#x27;t work well with Async. I have a hard time understanding it, and it feels like a layer of obfuscation or misdirection. It&#x27;s an abstraction that may be more suitable for other learning styles, or different program structures or requirements than the ones I&#x27;ve worked on.<p>I&#x27;d love to see an RTOS for Rust, but am worried it will be Async.<p>(I am referring to the Async&#x2F;Await pattern; not asynchronous programming or concurrency)</div><br/><div id="36797610" class="c"><input type="checkbox" id="c-36797610" checked=""/><div class="controls bullet"><span class="by">dirbaio</span><span>|</span><a href="#36792561">parent</a><span>|</span><a href="#36792642">next</a><span>|</span><label class="collapse" for="c-36797610">[-]</label><label class="expand" for="c-36797610">[1 more]</label></div><br/><div class="children"><div class="content">Async Rust does definitely work for non-toy use cases. As a data point, we use Embassy for all production firmware at my startup (<a href="https:&#x2F;&#x2F;akiles.app&#x2F;en" rel="nofollow noreferrer">https:&#x2F;&#x2F;akiles.app&#x2F;en</a>), using async tasks for everything: Bluetooth, TCP&#x2F;IP networking, motor control, user interface (LEDs, keypad), a key-value database in flash, stats collection... Async helps with battery life too since it allows putting the core to sleep when no task has work to do, it allows us to build devices with 1-2 years of battery life.<p>There&#x27;s other companies using Embassy in production. Sadly firmwares are usually not open source. There&#x27;s a few non-toy open-source projects using Embassy though:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;nviennot&#x2F;turbo-resin">https:&#x2F;&#x2F;github.com&#x2F;nviennot&#x2F;turbo-resin</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&#x2F;ruwm">https:&#x2F;&#x2F;github.com&#x2F;ivmarkov&#x2F;ruwm</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;dkhayes117&#x2F;propane-monitor-embassy">https:&#x2F;&#x2F;github.com&#x2F;dkhayes117&#x2F;propane-monitor-embassy</a><p>(disclaimer: Embassy maintainer, Akiles CTO here)</div><br/></div></div><div id="36792642" class="c"><input type="checkbox" id="c-36792642" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#36792561">parent</a><span>|</span><a href="#36797610">prev</a><span>|</span><a href="#36795201">next</a><span>|</span><label class="collapse" for="c-36792642">[-]</label><label class="expand" for="c-36792642">[2 more]</label></div><br/><div class="children"><div class="content">At work, we have a non-async RTOS <a href="https:&#x2F;&#x2F;hubris.oxide.computer&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hubris.oxide.computer&#x2F;</a> though it is a bit harder to use than &quot;add a dependency in Cargo.toml&quot; like most projects.<p>The original designer of Hubris, Cliff, has his own async RTOS that he uses for personal projects. He recently has been writing some blog posts on this that may be of interest to you:<p>* <a href="http:&#x2F;&#x2F;cliffle.com&#x2F;blog&#x2F;async-inversion&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;cliffle.com&#x2F;blog&#x2F;async-inversion&#x2F;</a><p>* <a href="http:&#x2F;&#x2F;cliffle.com&#x2F;blog&#x2F;composed-concurrency-in-drivers&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;cliffle.com&#x2F;blog&#x2F;composed-concurrency-in-drivers&#x2F;</a><p>The former is a general introduction to async, and the second is about applying it to write an I2C driver.<p>There already are some general RTOSes for Rust, and they do tend to use async:<p>* <a href="https:&#x2F;&#x2F;rtic.rs&#x2F;2&#x2F;book&#x2F;en&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rtic.rs&#x2F;2&#x2F;book&#x2F;en&#x2F;</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy">https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy</a> (this one is used in the article)<p>* <a href="https:&#x2F;&#x2F;tockos.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tockos.org&#x2F;</a></div><br/><div id="36792923" class="c"><input type="checkbox" id="c-36792923" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36792642">parent</a><span>|</span><a href="#36795201">next</a><span>|</span><label class="collapse" for="c-36792923">[-]</label><label class="expand" for="c-36792923">[1 more]</label></div><br/><div class="children"><div class="content">Cliff&#x27;s articles are outstanding!<p>Re Rtic: I&#x27;m using the V1 of it, which is non-Async; it seems to offer smarter locking than using critical sections + Mutex, since it&#x27;s capable of interrupting a lower-priority task with a higher one, depending on which resources are locked.</div><br/></div></div></div></div><div id="36795201" class="c"><input type="checkbox" id="c-36795201" checked=""/><div class="controls bullet"><span class="by">davidhyde</span><span>|</span><a href="#36792561">parent</a><span>|</span><a href="#36792642">prev</a><span>|</span><a href="#36794362">next</a><span>|</span><label class="collapse" for="c-36795201">[-]</label><label class="expand" for="c-36795201">[1 more]</label></div><br/><div class="children"><div class="content">RTIC (Real Time Interrupt-driven Concurrency) is an RTOS written in Rust with specific hardware acceleration for Cortex-M devices. Well, depending on what your definition of an RTOS really is. If you don&#x27;t like async then its a pretty good bet to get concurrency working on an Arm Cortex-M microcontroller.<p><a href="https:&#x2F;&#x2F;rtic.rs&#x2F;1&#x2F;book&#x2F;en&#x2F;preface.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rtic.rs&#x2F;1&#x2F;book&#x2F;en&#x2F;preface.html</a></div><br/></div></div><div id="36794362" class="c"><input type="checkbox" id="c-36794362" checked=""/><div class="controls bullet"><span class="by">sebastiandb</span><span>|</span><a href="#36792561">parent</a><span>|</span><a href="#36795201">prev</a><span>|</span><a href="#36793535">next</a><span>|</span><label class="collapse" for="c-36794362">[-]</label><label class="expand" for="c-36794362">[10 more]</label></div><br/><div class="children"><div class="content">This article about async in Python helped me understand it pretty well, since it explains them in terms of coroutines, which are very intuitive for me: <a href="https:&#x2F;&#x2F;mleue.com&#x2F;posts&#x2F;yield-to-async-await&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mleue.com&#x2F;posts&#x2F;yield-to-async-await&#x2F;</a><p>Another thing that helps me get it is comparing it to the continuation passing style, where you never return from a function, you just take an argument that&#x27;s basically a function pointer bound to an environment, and at the end of the function, instead of returning, you call your input function, giving it another function and environment as input, repeating the cycle. It&#x27;s very similar to the transformation of callbacks within callbacks within callbacks pattern in JavaScript to the async&#x2F;await pattern.</div><br/><div id="36794739" class="c"><input type="checkbox" id="c-36794739" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36794362">parent</a><span>|</span><a href="#36794667">next</a><span>|</span><label class="collapse" for="c-36794739">[-]</label><label class="expand" for="c-36794739">[2 more]</label></div><br/><div class="children"><div class="content">The thing is, we tried coroutines in C (embedded) y-e-a-r-s ago. It was all the rave for a bit. There were a couple different macro&#x2F;libraries you could use with duff&#x27;s device and other trickery to get coroutine-ish things in C.<p>Maybe the implementation just wasn&#x27;t up to where it needs to be with these newer&#x2F;slicker&#x2F;more integrated versions, but mine (and others&#x27;) issues with them wasn&#x27;t the weakness&#x2F;caveats of the implementation, but rather with the mess of spaghetti it made as your coroutine use grew with any degree. In onesie twosies under nice demo cases (look ma, I get some data from the intertubes with this syncy thing), they&#x27;re great, but my experience was that they&#x27;re a mess when scaled.<p>I&#x27;m happy to be proven wrong. I get to use them a bunch in Kotlin, I&#x27;m trying not to be a victim of my experience. I&#x27;m still on the fence.</div><br/><div id="36795609" class="c"><input type="checkbox" id="c-36795609" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36794739">parent</a><span>|</span><a href="#36794667">next</a><span>|</span><label class="collapse" for="c-36795609">[-]</label><label class="expand" for="c-36795609">[1 more]</label></div><br/><div class="children"><div class="content">Those libraries were always somewhat of a hack. Async Rust is an official language-backed syntax.</div><br/></div></div></div></div><div id="36794667" class="c"><input type="checkbox" id="c-36794667" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36794362">parent</a><span>|</span><a href="#36794739">prev</a><span>|</span><a href="#36793535">next</a><span>|</span><label class="collapse" for="c-36794667">[-]</label><label class="expand" for="c-36794667">[7 more]</label></div><br/><div class="children"><div class="content">Once you realize async&#x2F;await is just sugar over the familiar callback hell, a lot of the mystery fades away and it&#x27;s easier to groc.</div><br/><div id="36797536" class="c"><input type="checkbox" id="c-36797536" checked=""/><div class="controls bullet"><span class="by">dirbaio</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36794667">parent</a><span>|</span><a href="#36795152">next</a><span>|</span><label class="collapse" for="c-36797536">[-]</label><label class="expand" for="c-36797536">[1 more]</label></div><br/><div class="children"><div class="content">Rust async is a bit different than in other languages. It&#x27;s more like sugar over state machines instead of sugar over callbacks.<p>This is what makes it work nicely on embedded. The compiler-generated state machines are structs with fixed size so they can be statically allocated. Callbacks would have to be heap-allocated and garbage-collected&#x2F;refcounted.<p>(disclaimer: Embassy maintainer here)</div><br/></div></div><div id="36795152" class="c"><input type="checkbox" id="c-36795152" checked=""/><div class="controls bullet"><span class="by">f_devd</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36794667">parent</a><span>|</span><a href="#36797536">prev</a><span>|</span><a href="#36795117">next</a><span>|</span><label class="collapse" for="c-36795152">[-]</label><label class="expand" for="c-36795152">[2 more]</label></div><br/><div class="children"><div class="content">This misses the actual async part, which is more like polling a task queue. Callback hell sugar is only a thing in langues that already have event loops built in (i.e. JavaScript, which I assume is also what you&#x27;re referring to)</div><br/><div id="36796011" class="c"><input type="checkbox" id="c-36796011" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36795152">parent</a><span>|</span><a href="#36795117">next</a><span>|</span><label class="collapse" for="c-36796011">[-]</label><label class="expand" for="c-36796011">[1 more]</label></div><br/><div class="children"><div class="content">The point is that it actually is insightful to think of it as callback sugar.  That will give you better understanding of how the threading is handled when the calling method yields to the callee and conversely how it must be different when the caller isn&#x27;t yielded.</div><br/></div></div></div></div><div id="36795117" class="c"><input type="checkbox" id="c-36795117" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36794667">parent</a><span>|</span><a href="#36795152">prev</a><span>|</span><a href="#36793535">next</a><span>|</span><label class="collapse" for="c-36795117">[-]</label><label class="expand" for="c-36795117">[3 more]</label></div><br/><div class="children"><div class="content">Thatâs true in JS but less so in a language like Rust where there are threading implications.</div><br/><div id="36795213" class="c"><input type="checkbox" id="c-36795213" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36795117">parent</a><span>|</span><a href="#36795661">next</a><span>|</span><label class="collapse" for="c-36795213">[-]</label><label class="expand" for="c-36795213">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not as familiar with Rusts&#x27;s implementation but even in C# it&#x27;s mostly true.  Threads are only hit when a callback is not directly awaited.  There&#x27;s more to it but it starts you down the right path, I think.</div><br/></div></div><div id="36795661" class="c"><input type="checkbox" id="c-36795661" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#36792561">root</a><span>|</span><a href="#36795117">parent</a><span>|</span><a href="#36795213">prev</a><span>|</span><a href="#36793535">next</a><span>|</span><label class="collapse" for="c-36795661">[-]</label><label class="expand" for="c-36795661">[1 more]</label></div><br/><div class="children"><div class="content">There are no threading implications to async in Rust. The executor you&#x27;re using may add some requirements on your futures because it wants to run them on multiple threads[1], but that&#x27;s not related to async itself, and you can always use a single threaded executor if you don&#x27;t want these limitations (and they doesn&#x27;t apply to embeded anyway).<p>[1] namely, your futures will need to be Send + &#x27;static.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36793697" class="c"><input type="checkbox" id="c-36793697" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#36792561">prev</a><span>|</span><a href="#36791350">next</a><span>|</span><label class="collapse" for="c-36793697">[-]</label><label class="expand" for="c-36793697">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    spawner.spawn(blinky(led)).unwrap();
</code></pre>
Has anyone seriously tried structured concurrency for single-threaded async Rust? The pattern where main effectively leaks a task seems kind of gross to me, and itâs exactly what structured concurrency tries to solve.<p>(I realize that Rustâs async is inherently semi-structured.)</div><br/><div id="36797520" class="c"><input type="checkbox" id="c-36797520" checked=""/><div class="controls bullet"><span class="by">dirbaio</span><span>|</span><a href="#36793697">parent</a><span>|</span><a href="#36793983">next</a><span>|</span><label class="collapse" for="c-36797520">[-]</label><label class="expand" for="c-36797520">[1 more]</label></div><br/><div class="children"><div class="content">You can use futures combinators like `join`, `select`, `with_timeout` with async Rust. (crates like `embassy-futures` or `futures` have implementations of these). They work nicely even in no-std embedded.<p>They&#x27;re different tools for different use cases. Structured concurrency is nice when doing related actions concurrently where one might need to cancel the other, while unstructured task spawning makes more sense if they&#x27;re truly unrelated tasks, that live for the entire duration of the program or where you don&#x27;t care for how long they live (for example concurrently handling requests in a server).<p>(disclaimer: Embassy maintainer here)</div><br/></div></div><div id="36793983" class="c"><input type="checkbox" id="c-36793983" checked=""/><div class="controls bullet"><span class="by">swsieber</span><span>|</span><a href="#36793697">parent</a><span>|</span><a href="#36797520">prev</a><span>|</span><a href="#36791350">next</a><span>|</span><label class="collapse" for="c-36793983">[-]</label><label class="expand" for="c-36793983">[1 more]</label></div><br/><div class="children"><div class="content">IIRC been some proposals floating around, but one major block is asncy drop. This is the article I&#x27;m thinking of specifically: <a href="https:&#x2F;&#x2F;blog.yoshuawuyts.com&#x2F;tree-structured-concurrency&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.yoshuawuyts.com&#x2F;tree-structured-concurrency&#x2F;</a></div><br/></div></div></div></div><div id="36791350" class="c"><input type="checkbox" id="c-36791350" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#36793697">prev</a><span>|</span><a href="#36792627">next</a><span>|</span><label class="collapse" for="c-36791350">[-]</label><label class="expand" for="c-36791350">[15 more]</label></div><br/><div class="children"><div class="content">I could be wrong, but isn&#x27;t every multi-task &#x2F; RTOS essentially supporting this? Wake up, check flags, do work if required.<p>Of course if you&#x27;re bare-metal programming, it might be nice to have a lightweight mechanism for this.</div><br/><div id="36791536" class="c"><input type="checkbox" id="c-36791536" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#36791350">parent</a><span>|</span><a href="#36791380">next</a><span>|</span><label class="collapse" for="c-36791536">[-]</label><label class="expand" for="c-36791536">[9 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the simplicity of bare embedded in Rust, because you can mostly[1] use Cargo, depend on the right embedded_hal crates for your target, and be up and running with a hardware-backed async runtime and everything. Zephyr, Tock, Mynewt, etc. all have bespoke build&#x2F;deployment systems and driver ecosystems. That said, RTOS makes actually deploying working products much more realizable, so pick your poison.<p>1: I think you still need xargo&#x2F;cargo-xbuild for no-std embedded sysroots, but there may have been some upstream development on that front since I last played in this sandbox.</div><br/><div id="36793139" class="c"><input type="checkbox" id="c-36793139" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36791536">parent</a><span>|</span><a href="#36792436">next</a><span>|</span><label class="collapse" for="c-36793139">[-]</label><label class="expand" for="c-36793139">[2 more]</label></div><br/><div class="children"><div class="content">Embedded-HAL is interesting to me - in principle it&#x27;s a great concept; writing hardware-agnostic, portable code.<p>I don&#x27;t use it in my firmwares because:<p><pre><code>  - All of the embedded-HAL libs I&#x27;ve found (eg drivers) have had notable limitations or ergonomics problems.
  - It appears unsuitable for use with DMA, which I use for all runtime IO
  - The APIs tend to be a mess due to heavy use of typestates</code></pre></div><br/><div id="36797500" class="c"><input type="checkbox" id="c-36797500" checked=""/><div class="controls bullet"><span class="by">dirbaio</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36793139">parent</a><span>|</span><a href="#36792436">next</a><span>|</span><label class="collapse" for="c-36797500">[-]</label><label class="expand" for="c-36797500">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It appears unsuitable for use with DMA, which I use for all runtime IO<p>The `embedded-hal-async` traits can be implemented with DMA, the Embassy HALs do so. This is a problem with the `nb` traits only.<p>&gt; The APIs tend to be a mess due to heavy use of typestates<p>This is an issue of some HAL crates implementing the traits, not with the `embedded-hal` traits themselves. I also dislike the heavy use of typestates&#x2F;generics, Embassy tries to implement the traits while keeping typestates at a minimum.<p>(disclaimer: Embassy maintainer here)</div><br/></div></div></div></div><div id="36792436" class="c"><input type="checkbox" id="c-36792436" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36791536">parent</a><span>|</span><a href="#36793139">prev</a><span>|</span><a href="#36791690">next</a><span>|</span><label class="collapse" for="c-36792436">[-]</label><label class="expand" for="c-36792436">[2 more]</label></div><br/><div class="children"><div class="content">Building core&#x2F;std&#x2F;whatever using unstable flags and --target works for me these days. I can do everything with cargo and make it even more ergonomic with a toolchain file.<p>Now if Cargo had a way of producing multiple variants of the same project (e.g. different --targets with pre-set features) just with `cargo build` then things would be a lot better.<p>As of now, a Makefile is still needed to bring it all together.</div><br/><div id="36792633" class="c"><input type="checkbox" id="c-36792633" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36792436">parent</a><span>|</span><a href="#36791690">next</a><span>|</span><label class="collapse" for="c-36792633">[-]</label><label class="expand" for="c-36792633">[1 more]</label></div><br/><div class="children"><div class="content">We were using cargo-make for something like this, though eventually we switched to using Cargo&#x27;s experimental support for artifact dependencies: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;cargo&#x2F;reference&#x2F;unstable.html#artifact-dependencies" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;cargo&#x2F;reference&#x2F;unstable.h...</a></div><br/></div></div></div></div><div id="36791690" class="c"><input type="checkbox" id="c-36791690" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36791536">parent</a><span>|</span><a href="#36792436">prev</a><span>|</span><a href="#36792063">next</a><span>|</span><label class="collapse" for="c-36791690">[-]</label><label class="expand" for="c-36791690">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think you still need xargo&#x2F;cargo-xbuild for no-std embedded sysroots, but there may have been some upstream development on that front since I last played in this sandbox.<p>Cargo&#x27;s build-std flag is the bespoke way now.  Unstable, but working it&#x27;s way to stable.  AFAIK cargo&#x2F;build aren&#x27;t getting any more development in lieu of build-std.</div><br/><div id="36791873" class="c"><input type="checkbox" id="c-36791873" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36791690">parent</a><span>|</span><a href="#36792063">next</a><span>|</span><label class="collapse" for="c-36791873">[-]</label><label class="expand" for="c-36791873">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s good to hear, I&#x27;ve used that in the past to drive down codesize even on non embedded targets by compiling for size and rebuilding the stdlib.</div><br/></div></div></div></div><div id="36792063" class="c"><input type="checkbox" id="c-36792063" checked=""/><div class="controls bullet"><span class="by">Archit3ch</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36791536">parent</a><span>|</span><a href="#36791690">prev</a><span>|</span><a href="#36791380">next</a><span>|</span><label class="collapse" for="c-36792063">[-]</label><label class="expand" for="c-36792063">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you can mostly[1] use Cargo, depend on the right embedded_hal crates for your target, and be up and running with a hardware-backed async runtime and everything<p>Can one use Rust&#x27;s embedded_hal from a different programming language?</div><br/><div id="36792515" class="c"><input type="checkbox" id="c-36792515" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36792063">parent</a><span>|</span><a href="#36791380">next</a><span>|</span><label class="collapse" for="c-36792515">[-]</label><label class="expand" for="c-36792515">[1 more]</label></div><br/><div class="children"><div class="content">IIUC you can make some api in rust that uses the HAL, which ties your code into board specific stuff.<p>That api you write can be exposed via C abi so you can link C or languages that have an FFI to C to the rust code. <a href="https:&#x2F;&#x2F;docs.rust-embedded.org&#x2F;book&#x2F;interoperability&#x2F;rust-with-c.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rust-embedded.org&#x2F;book&#x2F;interoperability&#x2F;rust-wi...</a></div><br/></div></div></div></div></div></div><div id="36791380" class="c"><input type="checkbox" id="c-36791380" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#36791350">parent</a><span>|</span><a href="#36791536">prev</a><span>|</span><a href="#36791798">next</a><span>|</span><label class="collapse" for="c-36791380">[-]</label><label class="expand" for="c-36791380">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re asking why do coroutines exist, it&#x27;s because context switching in kernel space and synchronization have very high overhead by comparison. You use those features when you want parallelism, not concurrency.<p>For parallelism, you also usually want a userspace task scheduler because simply spawning threads in kernelspace is much slower. Cilk and Go provide this built into their language runtime.</div><br/><div id="36792710" class="c"><input type="checkbox" id="c-36792710" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36791380">parent</a><span>|</span><a href="#36791798">next</a><span>|</span><label class="collapse" for="c-36792710">[-]</label><label class="expand" for="c-36792710">[3 more]</label></div><br/><div class="children"><div class="content">Context switches on Cortex-M are relatively cheap with optimizations to limit the amount of data that has to be stacked.</div><br/><div id="36794507" class="c"><input type="checkbox" id="c-36794507" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36792710">parent</a><span>|</span><a href="#36791798">next</a><span>|</span><label class="collapse" for="c-36794507">[-]</label><label class="expand" for="c-36794507">[2 more]</label></div><br/><div class="children"><div class="content">Relative to what? They might be cheaper than some architectures, but they&#x27;re still a hell of a lot more expensive than not doing them.</div><br/><div id="36797164" class="c"><input type="checkbox" id="c-36797164" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36791350">root</a><span>|</span><a href="#36794507">parent</a><span>|</span><a href="#36791798">next</a><span>|</span><label class="collapse" for="c-36797164">[-]</label><label class="expand" for="c-36797164">[1 more]</label></div><br/><div class="children"><div class="content">we seem to be talking about cooperative multitasking here<p>correct me if i&#x27;m wrong, but i think that even with an almost standard abi it&#x27;s five instructions and 27 cortex-m3 clock cycles; here we reserve r10 for the current task pointer (with the bonus that you can use it for a tls base register) and round-robin among the tasks in a circularly linked list:<p><pre><code>    yield:  push {r4-r9, r11, lr}   @ save all callee-saved regs except r10
            str sp, [r10], #4       @ save stack pointer in current task
            ldr r10, [r10]          @ load pointer to next task
            ldr sp, [r10]           @ switch to next task&#x27;s stack
            pop {r4-r9, r11, pc}    @ return into yielded context there
</code></pre>
i think in gcc that&#x27;s more or less -mpic-register=r10 -msingle-pic-base, though that isn&#x27;t what those options are meant for<p>if you&#x27;re willing and able to deform the abi a little by having less callee-saved registers, something you might want to do anyway for efficiency, you can cut r4-r9 down to r4-r5 and shave that down to i think 19 clocks?  if you&#x27;re willing to eliminate callee-saved registers entirely you can get to 15, but that seems like a heavy price to pay<p>if you have to use the standard abi it&#x27;s i think 37 clocks on a cortex-m3 or better:<p><pre><code>    yield:  push {r4-r12, lr}
            ldr r9, =current_task_pointer
            ldr r10, [r9]
            str sp, [r10], #4
            ldr r10, [r10]
            str r10, [r9]
            ldr sp, [r10]
            pop {r4-r12, pc}
</code></pre>
i feel like something in the range of 20-40 clocks is really not that expensive?  i mean an ldr or str is 3 or 4 clocks if it&#x27;s not accessing tcm, right?  and on cortex-m0 every taken branch is 3 clocks because you don&#x27;t have branch prediction?<p>i mean it&#x27;s not going to compete with barrel processors on context switch time, but if it&#x27;s really the cost of accessing seven fields of structs on the heap, it hardly seems like it&#x27;s &quot;a hell of a lot more expensive&quot; than even zero<p>if we&#x27;re talking about preemptive context switching, that&#x27;s a different ball of wax; you have to save all the registers that you use at all, not just callee-saved registers, and depending on your application maybe vfp registers as well as integer registers</div><br/></div></div></div></div></div></div></div></div><div id="36791798" class="c"><input type="checkbox" id="c-36791798" checked=""/><div class="controls bullet"><span class="by">azubinski</span><span>|</span><a href="#36791350">parent</a><span>|</span><a href="#36791380">prev</a><span>|</span><a href="#36792627">next</a><span>|</span><label class="collapse" for="c-36791798">[-]</label><label class="expand" for="c-36791798">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s different and very old story.<p>Protothreads are classic now:
<a href="https:&#x2F;&#x2F;dunkels.com&#x2F;adam&#x2F;pt&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;dunkels.com&#x2F;adam&#x2F;pt&#x2F;index.html</a><p>Contiki OS is also a piece of embedded development classic:
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Contiki" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Contiki</a><p>In general, it&#x27;s more about syntax than semantics.
Semantics is generally difficult and rarely changes.</div><br/></div></div></div></div><div id="36792627" class="c"><input type="checkbox" id="c-36792627" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#36791350">prev</a><span>|</span><a href="#36792198">next</a><span>|</span><label class="collapse" for="c-36792627">[-]</label><label class="expand" for="c-36792627">[1 more]</label></div><br/><div class="children"><div class="content">I believe that Tock (tockos.org) and Theseus (<a href="https:&#x2F;&#x2F;github.com&#x2F;theseus-os&#x2F;Theseus">https:&#x2F;&#x2F;github.com&#x2F;theseus-os&#x2F;Theseus</a>) are in this area a bit as well, just from an actual OS perspective.<p>I don&#x27;t know much about this area, but it would be wonderful if these could work with the Libre compute boards, like the AM Logic S905X (Lepotato) or the Rock chip, since they&#x27;re so much cheaper than a Pi.
Would be great to get a dedicated simple system up to toy with Rust OS for only 30$.</div><br/></div></div><div id="36792198" class="c"><input type="checkbox" id="c-36792198" checked=""/><div class="controls bullet"><span class="by">strangattractor</span><span>|</span><a href="#36792627">prev</a><span>|</span><a href="#36792450">next</a><span>|</span><label class="collapse" for="c-36792198">[-]</label><label class="expand" for="c-36792198">[1 more]</label></div><br/><div class="children"><div class="content">I new all that time I spent programming the Mac back in 1987 would come in handy. Asnyc programming - cooperative multitasking never go out of style.</div><br/></div></div><div id="36792450" class="c"><input type="checkbox" id="c-36792450" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#36792198">prev</a><span>|</span><a href="#36792635">next</a><span>|</span><label class="collapse" for="c-36792450">[-]</label><label class="expand" for="c-36792450">[3 more]</label></div><br/><div class="children"><div class="content">Edit: commented on wrong post, meant for  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36791506">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36791506</a><p>Offtopic:<p>The cursive italics are apparently a feature of the Victor Mono [1] font used for the full page. While it&#x27;d be amusing in Tumblr context (where cursive is used for hyperbolic emphasis), I can&#x27;t fathom why one would consider it in a code context.<p>You can change it (at least on Safari) by going into developer tools, clicking any node, and removing &quot;Victor Mono&quot; from --font-family<p>[1] <a href="https:&#x2F;&#x2F;rubjo.github.io&#x2F;victor-mono&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rubjo.github.io&#x2F;victor-mono&#x2F;</a></div><br/><div id="36792562" class="c"><input type="checkbox" id="c-36792562" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#36792450">parent</a><span>|</span><a href="#36792635">next</a><span>|</span><label class="collapse" for="c-36792562">[-]</label><label class="expand" for="c-36792562">[2 more]</label></div><br/><div class="children"><div class="content">That may be specific to your machine, I don&#x27;t see any italics on mine, and the CSS just looks like `font-family: &#x27;Source Code Pro&#x27;, monospace;`.</div><br/></div></div></div></div><div id="36792635" class="c"><input type="checkbox" id="c-36792635" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#36792450">prev</a><span>|</span><a href="#36792213">next</a><span>|</span><label class="collapse" for="c-36792635">[-]</label><label class="expand" for="c-36792635">[2 more]</label></div><br/><div class="children"><div class="content">So, cooperative multitasking with no control of actual scheduling? Cute, but a real RTOS is the solution to most any &quot;i need to do more than one thing&quot; in the embedded world.</div><br/><div id="36795163" class="c"><input type="checkbox" id="c-36795163" checked=""/><div class="controls bullet"><span class="by">dhon_</span><span>|</span><a href="#36792635">parent</a><span>|</span><a href="#36792213">next</a><span>|</span><label class="collapse" for="c-36795163">[-]</label><label class="expand" for="c-36795163">[1 more]</label></div><br/><div class="children"><div class="content">You can run multiple executors at different interrupt priority levels (with multiple tasks per executor), which allows tasks on the higher priority executor to interrupt other tasks. Here&#x27;s an example <a href="https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy&#x2F;blob&#x2F;main&#x2F;examples&#x2F;nrf52840&#x2F;src&#x2F;bin&#x2F;multiprio.rs">https:&#x2F;&#x2F;github.com&#x2F;embassy-rs&#x2F;embassy&#x2F;blob&#x2F;main&#x2F;examples&#x2F;nrf...</a></div><br/></div></div></div></div><div id="36792213" class="c"><input type="checkbox" id="c-36792213" checked=""/><div class="controls bullet"><span class="by">0xfedbee</span><span>|</span><a href="#36792635">prev</a><span>|</span><label class="collapse" for="c-36792213">[-]</label><label class="expand" for="c-36792213">[16 more]</label></div><br/><div class="children"><div class="content">Cooperative multitasking in embedded has to be the worst idea ever. Anyone who has done any serious work in embedded systems will tell you how bad is it when a faulty task blocks everything. Please stop advertising async in embedded.</div><br/><div id="36792603" class="c"><input type="checkbox" id="c-36792603" checked=""/><div class="controls bullet"><span class="by">fleventynine</span><span>|</span><a href="#36792213">parent</a><span>|</span><a href="#36792451">next</a><span>|</span><label class="collapse" for="c-36792603">[-]</label><label class="expand" for="c-36792603">[1 more]</label></div><br/><div class="children"><div class="content">It really comes down to memory requirements. If you can afford to give every task it&#x27;s own stack and dispatch it directly from prioritized interrupts, that&#x27;s great. Even better if you can use memory protection hardware to isolate the tasks from each other.<p>But if you have many long running tasks that only need to keep a handful of bytes of state when they&#x27;re waiting, a mechanism like rust async can allow for huge memory savings while mostly retaining the same code style as stackful tasks.<p>And you can even use both approaches in the same program, with isolated stacks for realtime critical tasks and cooperative state machines for everything else.</div><br/></div></div><div id="36792451" class="c"><input type="checkbox" id="c-36792451" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36792213">parent</a><span>|</span><a href="#36792603">prev</a><span>|</span><a href="#36792758">next</a><span>|</span><label class="collapse" for="c-36792451">[-]</label><label class="expand" for="c-36792451">[7 more]</label></div><br/><div class="children"><div class="content">... anything faulty in an embedded world can block the chip.<p>This is why watchdog timers exist. Async does not shut off watchdog. Not sure what your point is.</div><br/><div id="36792593" class="c"><input type="checkbox" id="c-36792593" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36792451">parent</a><span>|</span><a href="#36793727">next</a><span>|</span><label class="collapse" for="c-36792593">[-]</label><label class="expand" for="c-36792593">[2 more]</label></div><br/><div class="children"><div class="content">Watchdogs shouldn&#x27;t be triggered in the normal course of events. They are a last line of defense for exceptional circumstances that will render a device inoperative, not a cure-all for poor system design.</div><br/><div id="36794623" class="c"><input type="checkbox" id="c-36794623" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36792593">parent</a><span>|</span><a href="#36793727">next</a><span>|</span><label class="collapse" for="c-36794623">[-]</label><label class="expand" for="c-36794623">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but a system where a task has ceased to execute is in pretty much all circumstances a system where the watchdog (or some other assert) should trigger. (the whole toyota case involved them getting raked over the coals because their system did not in fact detect a failed task and do this).</div><br/></div></div></div></div><div id="36793727" class="c"><input type="checkbox" id="c-36793727" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36792451">parent</a><span>|</span><a href="#36792593">prev</a><span>|</span><a href="#36796080">next</a><span>|</span><label class="collapse" for="c-36793727">[-]</label><label class="expand" for="c-36793727">[2 more]</label></div><br/><div class="children"><div class="content">Think of a watchdog timer in the same way you think about that big red handle on a train, &#x27;emergency use only, abuse will be punished&#x27;.</div><br/><div id="36794406" class="c"><input type="checkbox" id="c-36794406" checked=""/><div class="controls bullet"><span class="by">RealityVoid</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36793727">parent</a><span>|</span><a href="#36796080">next</a><span>|</span><label class="collapse" for="c-36794406">[-]</label><label class="expand" for="c-36794406">[1 more]</label></div><br/><div class="children"><div class="content">You have a task. You do an infinite loop in the task. The task is now blocking lower prio tasks in the RTOS. If the task is broken, it&#x27;s broken.</div><br/></div></div></div></div><div id="36796080" class="c"><input type="checkbox" id="c-36796080" checked=""/><div class="controls bullet"><span class="by">0xfedbee</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36792451">parent</a><span>|</span><a href="#36793727">prev</a><span>|</span><a href="#36792758">next</a><span>|</span><label class="collapse" for="c-36796080">[-]</label><label class="expand" for="c-36796080">[2 more]</label></div><br/><div class="children"><div class="content">As I said, anyone with serious  embedded experience will understand my point. People who think triggering watchdog is a normal thing wonât.</div><br/><div id="36797279" class="c"><input type="checkbox" id="c-36797279" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36796080">parent</a><span>|</span><a href="#36792758">next</a><span>|</span><label class="collapse" for="c-36797279">[-]</label><label class="expand" for="c-36797279">[1 more]</label></div><br/><div class="children"><div class="content">Yikes, no kidding. Triggering a watchdog is a âstop the dev cycle and everyone figure out what show-stopping bug is lurking in our codeâ time.<p>I have no desire to use embedded rust async, I use C++ with none of the allocating containers, and honestly itâs more of a C with classes style than modern C++, plus FreeRTOS in my production embedded code. I would happily trade out C++ for the memory safety of rust.<p>I would pick up a lightweight RTOS written in non-async rust if one existed and I could have faith in it, but other than personal projects I canât advocate for building a hardware project on something like this yet.</div><br/></div></div></div></div></div></div><div id="36792758" class="c"><input type="checkbox" id="c-36792758" checked=""/><div class="controls bullet"><span class="by">blackbeans</span><span>|</span><a href="#36792213">parent</a><span>|</span><a href="#36792451">prev</a><span>|</span><a href="#36797505">next</a><span>|</span><label class="collapse" for="c-36792758">[-]</label><label class="expand" for="c-36792758">[6 more]</label></div><br/><div class="children"><div class="content">Actually I never found cooperative multitasking a real issue. You don&#x27;t want faulty tasks in your embedded application anyway. With cooperative multitasking it at least is easy to spot which task is the culprit.<p>If I understand the article correctly, it seems that in this case the multitasking also isn&#x27;t controlled by calling yield in custom user code, but rather always from the implementation that makes async&#x2F;await work.</div><br/><div id="36793748" class="c"><input type="checkbox" id="c-36793748" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36792758">parent</a><span>|</span><a href="#36796050">next</a><span>|</span><label class="collapse" for="c-36793748">[-]</label><label class="expand" for="c-36793748">[4 more]</label></div><br/><div class="children"><div class="content">&gt; You don&#x27;t want faulty tasks in your embedded application anyway.<p>Faults are a way of life in software, they are unavoidable because each and every piece of software rests on a bunch of assumptions and if any one of those or a combination of them do not hold then you have a fault. Failure to envision that fault and a way to deal with it in embedded systems can cause damage to property, injury and loss of life.<p>None of this is simple, not in theory and definitely not in practice.</div><br/><div id="36794588" class="c"><input type="checkbox" id="c-36794588" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36793748">parent</a><span>|</span><a href="#36796050">next</a><span>|</span><label class="collapse" for="c-36794588">[-]</label><label class="expand" for="c-36794588">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but an RTOS doesn&#x27;t help you much with safety critical guarantees. When you&#x27;re worrying about that you&#x27;re also worrying about redundancy of the hardware your software is running on, for example. The only thing that an RTOS is really helpful for is making it a bit easier to argue that some realtime guarantees can be met even if other code running on the device may have worst-case runtimes longer than your deadline (this doesn&#x27;t really become a mitigation for a truly defective task, though, since at that point all bets are off unless you have some good task isolation). But this is not all embedded systems, not even all safety-critical ones, and there are other solutions available if you are not using an RTOS which can give you the same or better options in that case(like placing the critical code in a high-priority interrupt handler, for example).</div><br/><div id="36794854" class="c"><input type="checkbox" id="c-36794854" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36794588">parent</a><span>|</span><a href="#36796050">next</a><span>|</span><label class="collapse" for="c-36794854">[-]</label><label class="expand" for="c-36794854">[2 more]</label></div><br/><div class="children"><div class="content">If at all possible for such stuff I would use an FPGA and not software.</div><br/><div id="36797613" class="c"><input type="checkbox" id="c-36797613" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36794854">parent</a><span>|</span><a href="#36796050">next</a><span>|</span><label class="collapse" for="c-36797613">[-]</label><label class="expand" for="c-36797613">[1 more]</label></div><br/><div class="children"><div class="content">The WLCSP Lattice FPGAs are waiting for you! Only 2â¬ a pop for 1k LUTs!</div><br/></div></div></div></div></div></div></div></div><div id="36796050" class="c"><input type="checkbox" id="c-36796050" checked=""/><div class="controls bullet"><span class="by">0xfedbee</span><span>|</span><a href="#36792213">root</a><span>|</span><a href="#36792758">parent</a><span>|</span><a href="#36793748">prev</a><span>|</span><a href="#36797505">next</a><span>|</span><label class="collapse" for="c-36796050">[-]</label><label class="expand" for="c-36796050">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With cooperative multitasking it at least is easy to spot which task is the culprit.<p>Yeah I would love to spot that my carâs LED task is faulty while trying to brake on a 100mph highway.</div><br/></div></div></div></div><div id="36797505" class="c"><input type="checkbox" id="c-36797505" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#36792213">parent</a><span>|</span><a href="#36792758">prev</a><span>|</span><label class="collapse" for="c-36797505">[-]</label><label class="expand" for="c-36797505">[1 more]</label></div><br/><div class="children"><div class="content">There are many domains in embedded. You&#x27;re probably referring to safety-critical and hard real-time contexts?<p>Because cooperative multitasking is bog-standard in OS kernels.</div><br/></div></div></div></div></div></div></div></div></div></body></html>