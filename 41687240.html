<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727859676626" as="style"/><link rel="stylesheet" href="styles.css?v=1727859676626"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.zachdaniel.dev/p/serialization-is-the-secret">Serialization Is the Secret</a> <span class="domain">(<a href="https://www.zachdaniel.dev">www.zachdaniel.dev</a>)</span></div><div class="subtext"><span>borromakot</span> | <span>12 comments</span></div><br/><div><div id="41718129" class="c"><input type="checkbox" id="c-41718129" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#41717766">next</a><span>|</span><label class="collapse" for="c-41718129">[-]</label><label class="expand" for="c-41718129">[5 more]</label></div><br/><div class="children"><div class="content">&gt; One of the major elements that sets Elixir apart from most other programming languages is immutability.<p>It&#x27;s interesting to compare Elixir to that other immutable programming language: Haskell.<p>In Elixir, a binding<p><pre><code>    counter = counter + 1
</code></pre>
binds counter to the <i>old</i> value of counter, plus 1.
In Haskell it instead binds counter to the <i>new</i> value plus 1.<p>Of course that doesn&#x27;t make sense, and indeed this causes an infinite loop when Haskell tries to evaluate counter.<p>BUT it does make sense for certain recursive data structures, like an infinite list of 1s:<p><pre><code>    ones = 1 : ones
</code></pre>
We can check this by taking some finite prefix:<p><pre><code>    ghci&gt; take 5 ones
    [1,1,1,1,1]
</code></pre>
Another example is making a list of all primes, where you don&#x27;t need to decide in advance how many elements to limit yourself to.<p>Can you define such lazy infinite data structures in Elixir?</div><br/><div id="41718239" class="c"><input type="checkbox" id="c-41718239" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41718129">parent</a><span>|</span><a href="#41718163">next</a><span>|</span><label class="collapse" for="c-41718239">[-]</label><label class="expand" for="c-41718239">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit confused - isn&#x27;t this how all Static Single Assignment representations in compilers work? And those are used in things like LLVM IR to represent C and C++ code. Is C++ immutable now?</div><br/><div id="41718593" class="c"><input type="checkbox" id="c-41718593" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#41718129">root</a><span>|</span><a href="#41718239">parent</a><span>|</span><a href="#41718163">next</a><span>|</span><label class="collapse" for="c-41718593">[-]</label><label class="expand" for="c-41718593">[1 more]</label></div><br/><div class="children"><div class="content">The difference, at least in Haskell, is that assigning a variable creates a new scope. E.g. in C I would expect to be able to<p><pre><code>    int i = 0;
    while (i &lt; 5) {
        i = i+1;
        printf(&quot;i: %d\n&quot;, i);
    }
</code></pre>
whereas in Haskell I could hypothetically something like<p><pre><code>    let i = 0 in
        whileM (pure (i &lt; 5)) $ do
            let i = i + 1 in
                printf &quot;i: %d\n&quot; i
</code></pre>
but the inner assignment would not have any effect on the variable referenced by the condition in the while loop – it would only affect what&#x27;s inside the block it opens.<p>(And as GP points out, i=i+1 is an infinite loop in Haskell.)</div><br/></div></div></div></div><div id="41718163" class="c"><input type="checkbox" id="c-41718163" checked=""/><div class="controls bullet"><span class="by">finder83</span><span>|</span><a href="#41718129">parent</a><span>|</span><a href="#41718239">prev</a><span>|</span><a href="#41718150">next</a><span>|</span><label class="collapse" for="c-41718163">[-]</label><label class="expand" for="c-41718163">[1 more]</label></div><br/><div class="children"><div class="content">Infinite, yes, but I would say it&#x27;s not quite as core to the language as it is in Haskell where everything&#x27;s lazy. Infinite streams are quite simple though:<p><pre><code>  Stream.iterate(1, fn(x) -&gt; x end) 
  |&gt; Enum.take(5)
  [1, 1, 1, 1, 1]</code></pre></div><br/></div></div><div id="41718150" class="c"><input type="checkbox" id="c-41718150" checked=""/><div class="controls bullet"><span class="by">chucky_z</span><span>|</span><a href="#41718129">parent</a><span>|</span><a href="#41718163">prev</a><span>|</span><a href="#41717766">next</a><span>|</span><label class="collapse" for="c-41718150">[-]</label><label class="expand" for="c-41718150">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;Stream.html" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;Stream.html</a><p>Although I don’t think it’ll be quite as elegant as the Haskell code.</div><br/></div></div></div></div><div id="41717766" class="c"><input type="checkbox" id="c-41717766" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41718129">prev</a><span>|</span><a href="#41717832">next</a><span>|</span><label class="collapse" for="c-41717766">[-]</label><label class="expand" for="c-41717766">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I would argue that, from the perspective of our program, it is not more or less mutable than any other thing. The reason for this, is that in Elixir, all mutating state requires calling a function to observe it.<p>Are you never not inside a called function?<p>This just sounds like pervasive mutability with more steps.</div><br/><div id="41718061" class="c"><input type="checkbox" id="c-41718061" checked=""/><div class="controls bullet"><span class="by">bux93</span><span>|</span><a href="#41717766">parent</a><span>|</span><a href="#41717876">next</a><span>|</span><label class="collapse" for="c-41718061">[-]</label><label class="expand" for="c-41718061">[1 more]</label></div><br/><div class="children"><div class="content">I think the author means &quot;I said everything is immutable, and rebinding is obviously changing something, but the thing it changes doesn&#x27;t count!&quot;. The idea being, if you read a bunch of code, none of the variables in that piece of code can have the value of it changed unless there is some explicit line of code.</div><br/></div></div><div id="41717876" class="c"><input type="checkbox" id="c-41717876" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#41717766">parent</a><span>|</span><a href="#41718061">prev</a><span>|</span><a href="#41717899">next</a><span>|</span><label class="collapse" for="c-41717876">[-]</label><label class="expand" for="c-41717876">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like all old bindings to the value stay the same. So you have a &quot;cell&quot; inside which a reference is stored. You can replace the reference but not mutate the values being referred to.<p>If so, this sounds a lot like IORef in Haskell.</div><br/></div></div><div id="41717899" class="c"><input type="checkbox" id="c-41717899" checked=""/><div class="controls bullet"><span class="by">finder83</span><span>|</span><a href="#41717766">parent</a><span>|</span><a href="#41717876">prev</a><span>|</span><a href="#41717832">next</a><span>|</span><label class="collapse" for="c-41717899">[-]</label><label class="expand" for="c-41717899">[1 more]</label></div><br/><div class="children"><div class="content">The functions don&#x27;t return a mutable version of a variable or anything. You still get an immutable copy (it may not be an actual copy, I don&#x27;t know the internals) of the state, and the state he&#x27;s referencing in a Genserver is the current state of a running process that runs in a loop handling messages. For example in liveview, each connection (to an end-user) is a process that keeps state as part of the socket. And the editing is handled through events and lifecycle functions, not through directly mutating the state, so things tend to be more predictable in my experience. It&#x27;s kind of like mutation by contract. In reality, it&#x27;s more like for each mailbox message, you have another loop iteration, and that loop iteration can return the same value or a new value. The new values are always immutable. So it&#x27;s like going from generations of variables, abandoning the old references, and using the new one for each iteration of the loop. In practice though, it&#x27;s just message handling and internal state, which is what he means by &quot;from the perspective of our program&quot;.<p>You typically wouldn&#x27;t just write a Genserver to hold state just to make it mutable (though I&#x27;ve seen them used that way), unless it&#x27;s shared state across multiple processes. They&#x27;re not used as pervasively as say classes in OOP. Genservers usually have a purpose, like tracking users in a waiting room, chat messages, etc. Each message handler is also serial in that you handle one mailbox message at a time (which can spawn a new process, but then that new process state is also immutable), so the internal state of a Genserver is largely predictable and trackable. So the only way to mutate state is to send a message, and the only way to get the new state is to ask for it.<p>There&#x27;s a lot of benefits of that model, like knowing that two pieces of code will never hit a race condition to edit the same area of memory at the same time because memory is never shared. Along with the preemptive scheduler, micro-threads, and process supervisors, it makes for a really nice scalable (if well-designed) asynchronous solution.<p>I&#x27;m not sure I 100% agree that watching mutating state requires a function to observe it. After all, a genserver can send a message to other processes to let them know that the state&#x27;s changed along with the new state. Like in a pub-sub system. But maybe he&#x27;s presenting an over-simplification trying to explain the means of mutability in Elixir.</div><br/></div></div></div></div><div id="41717832" class="c"><input type="checkbox" id="c-41717832" checked=""/><div class="controls bullet"><span class="by">sailorganymede</span><span>|</span><a href="#41717766">prev</a><span>|</span><a href="#41717691">next</a><span>|</span><label class="collapse" for="c-41717832">[-]</label><label class="expand" for="c-41717832">[1 more]</label></div><br/><div class="children"><div class="content">I really enjoyed reading this because it explained the topic quite simply. It was well written !</div><br/></div></div><div id="41717691" class="c"><input type="checkbox" id="c-41717691" checked=""/><div class="controls bullet"><span class="by">fracus</span><span>|</span><a href="#41717832">prev</a><span>|</span><label class="collapse" for="c-41717691">[-]</label><label class="expand" for="c-41717691">[1 more]</label></div><br/><div class="children"><div class="content">This was very enlightening for me on the subject of immutability.</div><br/></div></div></div></div></div></div></div></body></html>