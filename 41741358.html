<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728118872792" as="style"/><link rel="stylesheet" href="styles.css?v=1728118872792"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/computer-scientists-combine-two-beautiful-proof-methods-20241004/">Computer scientists combine two &#x27;beautiful&#x27; proof methods</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>tambourine_man</span> | <span>25 comments</span></div><br/><div><div id="41744248" class="c"><input type="checkbox" id="c-41744248" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41747229">next</a><span>|</span><label class="collapse" for="c-41744248">[-]</label><label class="expand" for="c-41744248">[9 more]</label></div><br/><div class="children"><div class="content">I know cryptocurrencies have a lot of problems, but this is one place where it’s good they exist: they’ve funneled a ton of money into researching new cryptography. The article claims that this research was developed for StarkWare, which developed its own form of zero knowledge proofs they called Starks, developed a programming language in which cryptographic proofs can be generated showing that the output of the program was truly produced from the inputs[^1], and continued to do more research like this. While I’m not a cryptographer, I think this sort of thing is super cool and I’m glad there’s a lot of attention and effort going into it.<p>^[1] the cool thing about these proofs is that they can be verified in much less time than is required to run the program. IIRC, starks can be verified in log-polynomial time, and snarks can be verified in constant time. This allows cryptocurrency protocols to have one computer in the network generate a proof of the state of the chain given a new block, and all other are able to quickly check it. Without this, you have a ton of waste because every computer in the network must duplicate the work of computing the new chain state. (although some new waste is introduced by the fact that producing a proof is very slow, although this is another area that cryptocurrency-funded research has improved dramatically)<p>Another cool bit of cryptography research that I think was motivated by crypto was “verkle trees”, an improvement on merkle trees that uses vector commitments rather than your typical hash. A vector commitment is like a hash, but it hashes an array of items and you can check that the hash was produced from an array with a certain item at a certain index without knowing the other items in the array. If you use this to back a merkle tree, you can increase the branching factor a lot and end up with much smaller proofs that a particular item is in the tree. This is because the proof size for a merkle tree is b * log_b n (where b is the branching factor and n is the number of items in the tree). The proof size for a verkle tree is just log_b n, so you can increase b as much as you want without making the proofs bigger.<p>Full disclosure: I work for a blockchain company, but not one mentioned here. I have no equity or stake in crypto outside of the fact that if the price goes to 0 my company probably can no longer afford to employ me</div><br/><div id="41745584" class="c"><input type="checkbox" id="c-41745584" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#41744248">parent</a><span>|</span><a href="#41744366">next</a><span>|</span><label class="collapse" for="c-41745584">[-]</label><label class="expand" for="c-41745584">[5 more]</label></div><br/><div class="children"><div class="content">The other cool thing about verkle trees is that they were mostly figured out by a high schooler for a science fair (?) project.<p>They&#x27;re not actually that complicated in principle, just nobody thought of it before and that&#x27;s pretty cool.</div><br/><div id="41746014" class="c"><input type="checkbox" id="c-41746014" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41744248">root</a><span>|</span><a href="#41745584">parent</a><span>|</span><a href="#41744366">next</a><span>|</span><label class="collapse" for="c-41746014">[-]</label><label class="expand" for="c-41746014">[4 more]</label></div><br/><div class="children"><div class="content">Wow, that is cool. I&#x27;m actually annoyed that vitalik didn&#x27;t credit him in his article about them. I wonder how many people think that the v stands for vitalk</div><br/><div id="41746354" class="c"><input type="checkbox" id="c-41746354" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#41744248">root</a><span>|</span><a href="#41746014">parent</a><span>|</span><a href="#41744366">next</a><span>|</span><label class="collapse" for="c-41746354">[-]</label><label class="expand" for="c-41746354">[3 more]</label></div><br/><div class="children"><div class="content">&gt; vitalik didn&#x27;t credit him in his article<p>You mean this article?<p><a href="https:&#x2F;&#x2F;vitalik.eth.limo&#x2F;general&#x2F;2021&#x2F;06&#x2F;18&#x2F;verkle.html" rel="nofollow">https:&#x2F;&#x2F;vitalik.eth.limo&#x2F;general&#x2F;2021&#x2F;06&#x2F;18&#x2F;verkle.html</a><p>&gt; Verkle trees are still a new idea; they were first introduced by John Kuszmaul in this paper from 2018[link to [0]],<p>0: <a href="https:&#x2F;&#x2F;math.mit.edu&#x2F;research&#x2F;highschool&#x2F;primes&#x2F;materials&#x2F;2018&#x2F;Kuszmaul.pdf" rel="nofollow">https:&#x2F;&#x2F;math.mit.edu&#x2F;research&#x2F;highschool&#x2F;primes&#x2F;materials&#x2F;20...</a></div><br/><div id="41747968" class="c"><input type="checkbox" id="c-41747968" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41744248">root</a><span>|</span><a href="#41746354">parent</a><span>|</span><a href="#41747137">next</a><span>|</span><label class="collapse" for="c-41747968">[-]</label><label class="expand" for="c-41747968">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I wonder if he edited it, I googled it to find what the GP was talking about and saw this which claimed he didn&#x27;t: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27557503">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27557503</a></div><br/></div></div><div id="41747137" class="c"><input type="checkbox" id="c-41747137" checked=""/><div class="controls bullet"><span class="by">Zamiel_Snawley</span><span>|</span><a href="#41744248">root</a><span>|</span><a href="#41746354">parent</a><span>|</span><a href="#41747968">prev</a><span>|</span><a href="#41744366">next</a><span>|</span><label class="collapse" for="c-41747137">[-]</label><label class="expand" for="c-41747137">[1 more]</label></div><br/><div class="children"><div class="content">I want to highlight the fact that the quote from Vitalik’s article is the first sentence of the second paragraph. Credit is prominently given, not buried in any way.</div><br/></div></div></div></div></div></div></div></div><div id="41744366" class="c"><input type="checkbox" id="c-41744366" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#41744248">parent</a><span>|</span><a href="#41745584">prev</a><span>|</span><a href="#41744296">next</a><span>|</span><label class="collapse" for="c-41744366">[-]</label><label class="expand" for="c-41744366">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The article claims that this research was developed for StarkWare,<p>Does it? Starkware is mentioned only as the company run by some.guy who commented on how pivotal this work was.<p>It doesn&#x27;t say he was related, and I can&#x27;t find any affiliation between the researchers (all uk based at Cambridge and Warwick) and the US based StarkWare.</div><br/><div id="41745949" class="c"><input type="checkbox" id="c-41745949" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41744248">root</a><span>|</span><a href="#41744366">parent</a><span>|</span><a href="#41744296">next</a><span>|</span><label class="collapse" for="c-41745949">[-]</label><label class="expand" for="c-41745949">[1 more]</label></div><br/><div class="children"><div class="content">Oh, maybe it was unrelated, I think I misread the article</div><br/></div></div></div></div></div></div><div id="41747229" class="c"><input type="checkbox" id="c-41747229" checked=""/><div class="controls bullet"><span class="by">ziofill</span><span>|</span><a href="#41744248">prev</a><span>|</span><a href="#41744598">next</a><span>|</span><label class="collapse" for="c-41747229">[-]</label><label class="expand" for="c-41747229">[6 more]</label></div><br/><div class="children"><div class="content">A professor I know once gave me the most beautiful example of a zero knowledge proof: she said “Imagine I want to prove to you that I can count the leaves on a tree, but I don’t want to reveal how I do it. I start by telling you there are e.g. 756,912 of them. Then I close my eyes and I let you remove as many as you want. We can keep going until you are convinced, and you still won’t know how I did it.”</div><br/><div id="41747406" class="c"><input type="checkbox" id="c-41747406" checked=""/><div class="controls bullet"><span class="by">firejake308</span><span>|</span><a href="#41747229">parent</a><span>|</span><a href="#41748298">next</a><span>|</span><label class="collapse" for="c-41747406">[-]</label><label class="expand" for="c-41747406">[3 more]</label></div><br/><div class="children"><div class="content">Okay, but I wouldn&#x27;t be convinced until I&#x27;ve counted up to 756,912 myself and seen that there are no more leaves left after that. Isn&#x27;t it supposed to be less computationally intensive to verify the proof than to complete the original calculation?<p>I tried learning about zero knowledge proofs during the crypto craze, but I never understood the basic idea of how it was supposed to work, much less the math involved. I&#x27;d appreciate an ELI5 from anyone who has one.</div><br/><div id="41747531" class="c"><input type="checkbox" id="c-41747531" checked=""/><div class="controls bullet"><span class="by">jonjonsonjr</span><span>|</span><a href="#41747229">root</a><span>|</span><a href="#41747406">parent</a><span>|</span><a href="#41748298">next</a><span>|</span><label class="collapse" for="c-41747531">[-]</label><label class="expand" for="c-41747531">[2 more]</label></div><br/><div class="children"><div class="content">The proof is that they can tell you the number of leaves (again) after you have secretly removed some. Since only you know the number you removed, if the difference between their counts matches your number, it is likely that they can indeed count the leaves on the tree. It is possible they have correctly guessed, which is why you repeat the challenge until you are convinced.</div><br/><div id="41747960" class="c"><input type="checkbox" id="c-41747960" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#41747229">root</a><span>|</span><a href="#41747531">parent</a><span>|</span><a href="#41748298">next</a><span>|</span><label class="collapse" for="c-41747960">[-]</label><label class="expand" for="c-41747960">[1 more]</label></div><br/><div class="children"><div class="content">Or they have a way to measure your removal, eg, they don’t count leaves but branches without leaves (in the hypothetical tree example).</div><br/></div></div></div></div></div></div><div id="41748298" class="c"><input type="checkbox" id="c-41748298" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#41747229">parent</a><span>|</span><a href="#41747406">prev</a><span>|</span><a href="#41747985">next</a><span>|</span><label class="collapse" for="c-41748298">[-]</label><label class="expand" for="c-41748298">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, that doesn&#x27;t make any sense.<p>Edit: From another comment, it starts do make sense. So you let them remove a number of leaves secretly, and then you tell them the new number again, and they can check if your answer makes sense because of the difference between the two numbers.</div><br/></div></div><div id="41747985" class="c"><input type="checkbox" id="c-41747985" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41747229">parent</a><span>|</span><a href="#41748298">prev</a><span>|</span><a href="#41744598">next</a><span>|</span><label class="collapse" for="c-41747985">[-]</label><label class="expand" for="c-41747985">[1 more]</label></div><br/><div class="children"><div class="content">This is a nice example, but couldn&#x27;t he add a constant to his count as long as he adds the same constant each time? Regardless, it&#x27;s nice</div><br/></div></div></div></div><div id="41744598" class="c"><input type="checkbox" id="c-41744598" checked=""/><div class="controls bullet"><span class="by">ianandrich</span><span>|</span><a href="#41747229">prev</a><span>|</span><a href="#41745768">next</a><span>|</span><label class="collapse" for="c-41744598">[-]</label><label class="expand" for="c-41744598">[3 more]</label></div><br/><div class="children"><div class="content">I know this is useful for crypto, but I think think I&#x27;m actually more interested in what new modes of remote code running on untrusted platforms this enables.</div><br/><div id="41746024" class="c"><input type="checkbox" id="c-41746024" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41744598">parent</a><span>|</span><a href="#41745789">next</a><span>|</span><label class="collapse" for="c-41746024">[-]</label><label class="expand" for="c-41746024">[1 more]</label></div><br/><div class="children"><div class="content">That is exactly the reason it&#x27;s useful for crypto, nodes need to verify the output of code running on other nodes without trusting them.</div><br/></div></div><div id="41745789" class="c"><input type="checkbox" id="c-41745789" checked=""/><div class="controls bullet"><span class="by">drhodes</span><span>|</span><a href="#41744598">parent</a><span>|</span><a href="#41746024">prev</a><span>|</span><a href="#41745768">next</a><span>|</span><label class="collapse" for="c-41745789">[-]</label><label class="expand" for="c-41745789">[1 more]</label></div><br/><div class="children"><div class="content">It does seem like the article touches on concerns relevant to homomorphic encryption. Maybe someone knows if there is a connection.</div><br/></div></div></div></div><div id="41745768" class="c"><input type="checkbox" id="c-41745768" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41744598">prev</a><span>|</span><label class="collapse" for="c-41745768">[-]</label><label class="expand" for="c-41745768">[6 more]</label></div><br/><div class="children"><div class="content">&gt; If someone finds a valid solution, they can easily convince a skeptical “verifier” that it really is valid. The verifier, in turn, will always be able to spot if there’s a mistake. Problems with this property belong to a class that researchers call NP.<p>How do you quickly verify that traveling salesman path is indeed the shortest one?</div><br/><div id="41745856" class="c"><input type="checkbox" id="c-41745856" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#41745768">parent</a><span>|</span><label class="collapse" for="c-41745856">[-]</label><label class="expand" for="c-41745856">[5 more]</label></div><br/><div class="children"><div class="content">You have discovered that that problem indeed is not in NP, for the reason that it is not a decision problem. The decision problem is in NP, and there the problem is: given a graph and some value k, does there exist a TSP with cost at most k. You can see how that problem then becomes verifiable.</div><br/><div id="41747176" class="c"><input type="checkbox" id="c-41747176" checked=""/><div class="controls bullet"><span class="by">Zamiel_Snawley</span><span>|</span><a href="#41745768">root</a><span>|</span><a href="#41745856">parent</a><span>|</span><a href="#41745866">next</a><span>|</span><label class="collapse" for="c-41747176">[-]</label><label class="expand" for="c-41747176">[3 more]</label></div><br/><div class="children"><div class="content">I think this is a great distinction that deserves elaboration for those less familiar with the topic. Can you explain a bit further?</div><br/><div id="41748043" class="c"><input type="checkbox" id="c-41748043" checked=""/><div class="controls bullet"><span class="by">progval</span><span>|</span><a href="#41745768">root</a><span>|</span><a href="#41747176">parent</a><span>|</span><a href="#41747999">next</a><span>|</span><label class="collapse" for="c-41748043">[-]</label><label class="expand" for="c-41748043">[1 more]</label></div><br/><div class="children"><div class="content">In this context we can divide problems into two cases: optimization problems (&quot;find a solution that satisfies P, in a way that has the highest score&quot;) and decision problems (&quot;is there a solution that satisfies P, with score &gt;= X&quot; or &quot;find a solution that satisfies P, with score &gt;= X&quot;).<p>Complexity classes like NP are defined only for decision problems, not for optimization problems. NP can be defined either as<p>* the set of decision problems where, given a solution, you can check it in polynomial time with a deterministic Turing machine, or
* the set of decision problems solvable in polynomial type by a non-determistic Turing machine<p>these two definitions being equivalent.<p>When someone mentions an optimization problem being in P, NP, or NP-hard, they actually mean the associated decision problem being in P&#x2F;NP&#x2F;NP-hard.<p>While technically incorrect, this is fine when working informally, because you can &quot;translate&quot; between the two in polynomial time.<p>If I give you an oracle (ie. a magic box) that solves an optimization problem (ie. gives you a solution to P with the highest score) immediately, you can trivially write a polynomial time algorithm that solves the decision problem: call the oracle, check the score of its answer, then compare that with the X value you were given.
And vice versa: if I give you an oracle that solves a decision problem immediately (ie. given a value X, gives you a solution satisfying P with score &gt;= X), you can write a polynomial time algorithm that uses the oracle a few times with the right values of X (exponential search then bisection), to find the solution with the highest score.</div><br/></div></div><div id="41747999" class="c"><input type="checkbox" id="c-41747999" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41745768">root</a><span>|</span><a href="#41747176">parent</a><span>|</span><a href="#41748043">prev</a><span>|</span><a href="#41745866">next</a><span>|</span><label class="collapse" for="c-41747999">[-]</label><label class="expand" for="c-41747999">[1 more]</label></div><br/><div class="children"><div class="content">A decision problem is a problem with a yes or no answer. An NP problem is one where a &quot;yes&quot; answer can be verified quickly if they also give you some proof or &quot;witness&quot; of it. If I say &quot;is there a route that goes through all these cities that&#x27;s less than 500 miles long&quot;, and you answer yes, you can prove that such a route exists by showing me one of these and I can simply check how long the route is. So the problem is in NP because a &quot;yes&quot; answer can be proven or checked quickly.<p>However, if you say &quot;no, there is no such route&quot;, there&#x27;s not obviously any way to quickly show that. Despite that, the problem is still in NP because to be in NP there only needs to be a quickly-checkable proof of a &quot;yes&quot; answer. If you want a quickly checkable proof of a &quot;no&quot; answer, you need a separate class of problem called co-np.<p>A problem can also be in np and co-np at the same time, if both &quot;yes&quot; answers and &quot;no&quot; answers can have a proof that can be checked quickly.</div><br/></div></div></div></div><div id="41745866" class="c"><input type="checkbox" id="c-41745866" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#41745768">root</a><span>|</span><a href="#41745856">parent</a><span>|</span><a href="#41747176">prev</a><span>|</span><label class="collapse" for="c-41745866">[-]</label><label class="expand" for="c-41745866">[1 more]</label></div><br/><div class="children"><div class="content">Verifying that a path&#x2F;tour is shortest is in co-NP.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>