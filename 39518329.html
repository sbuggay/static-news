<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709110850068" as="style"/><link rel="stylesheet" href="styles.css?v=1709110850068"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html">Why Python&#x27;s Integer Division Floors (2010)</a> <span class="domain">(<a href="http://python-history.blogspot.com">python-history.blogspot.com</a>)</span></div><div class="subtext"><span>bshanks</span> | <span>8 comments</span></div><br/><div><div id="39535536" class="c"><input type="checkbox" id="c-39535536" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#39535628">next</a><span>|</span><label class="collapse" for="c-39535536">[-]</label><label class="expand" for="c-39535536">[1 more]</label></div><br/><div class="children"><div class="content">Note the top comment by “ark” - there’s really no perfect solution here. In the floating-point case, you have to choose between negative remainders or potentially inexact results.</div><br/></div></div><div id="39535375" class="c"><input type="checkbox" id="c-39535375" checked=""/><div class="controls bullet"><span class="by">z_open</span><span>|</span><a href="#39535628">prev</a><span>|</span><label class="collapse" for="c-39535375">[-]</label><label class="expand" for="c-39535375">[5 more]</label></div><br/><div class="children"><div class="content">Changing well known behavior for something no one is really going to need. The justification makes sense, but it breaks convention and the relationship with modulo doesn&#x27;t need to hold for negative numbers.</div><br/><div id="39535482" class="c"><input type="checkbox" id="c-39535482" checked=""/><div class="controls bullet"><span class="by">Skeime</span><span>|</span><a href="#39535375">parent</a><span>|</span><a href="#39535428">next</a><span>|</span><label class="collapse" for="c-39535482">[-]</label><label class="expand" for="c-39535482">[1 more]</label></div><br/><div class="children"><div class="content">I strongly disagree. I would estimate that in 90% of cases where I use modulo in languages that truncate (instead of flooring), I write (a % b + b) % b, or something similar, just to get the right behaviour. The exceptional cases are those where I can convince myself that negative numbers simply won&#x27;t come up. (It&#x27;s <i>never</i> because I actually want the other behaviour for negative numbers.)<p>- When using modulo to access an array cyclically. (You might get lucky that your language allows using negative numbers to index from the back. In that case, both conventions work.)
- When lowering the resolution of integers. If you round to zero, you get strange artifacts around zero, because -b+1, ..., -1, 0, 1, ..., b-1 all go to zero when dividing by b. That&#x27;s 2b-1 numbers. For every other integer k, there are only b numbers (namely bk, bk+1, ..., bk+b-1).<p>I have <i>never</i> seen a case where truncation was the right thing to do. (When dealing with integers. Floats are different, of course, but they are not what this is about.)</div><br/></div></div><div id="39535428" class="c"><input type="checkbox" id="c-39535428" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39535375">parent</a><span>|</span><a href="#39535482">prev</a><span>|</span><a href="#39535554">next</a><span>|</span><label class="collapse" for="c-39535428">[-]</label><label class="expand" for="c-39535428">[2 more]</label></div><br/><div class="children"><div class="content">Quantify &quot;well known&quot;. Historically enough variation existed in this area [1], and C only happened to copy FORTRAN&#x27;s behavior for the sake of compatibility.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Modulo#In_programming_languages" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Modulo#In_programming_language...</a></div><br/><div id="39535586" class="c"><input type="checkbox" id="c-39535586" checked=""/><div class="controls bullet"><span class="by">BlueTemplar</span><span>|</span><a href="#39535375">root</a><span>|</span><a href="#39535428">parent</a><span>|</span><a href="#39535554">next</a><span>|</span><label class="collapse" for="c-39535586">[-]</label><label class="expand" for="c-39535586">[1 more]</label></div><br/><div class="children"><div class="content">Python does follow the convention, but what I am wondering now is why did FORTRAN break it ?</div><br/></div></div></div></div><div id="39535554" class="c"><input type="checkbox" id="c-39535554" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39535375">parent</a><span>|</span><a href="#39535428">prev</a><span>|</span><label class="collapse" for="c-39535554">[-]</label><label class="expand" for="c-39535554">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Changing well known behavior for something no one is really going to need.<p>On the contrary I can&#x27;t imagine when and why anybody would want truncation. That&#x27;s just a side effect of the used algorithm and not something that actually makes much (any?) sense.</div><br/></div></div></div></div></div></div></div></div></div></body></html>