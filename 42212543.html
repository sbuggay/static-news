<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732438848763" as="style"/><link rel="stylesheet" href="styles.css?v=1732438848763"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.separateconcerns.com/2017-05-07-itc.html">A short introduction to Interval Tree Clocks</a> <span class="domain">(<a href="https://blog.separateconcerns.com">blog.separateconcerns.com</a>)</span></div><div class="subtext"><span>LAC-Tech</span> | <span>18 comments</span></div><br/><div><div id="42225729" class="c"><input type="checkbox" id="c-42225729" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#42225508">next</a><span>|</span><label class="collapse" for="c-42225729">[-]</label><label class="expand" for="c-42225729">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing. I liked the short video.<p>These have been around for a few years. Wonder what people built with them since. Anyone know of any popular distributed systems using them nowadays? (I noticed the company the author mentioned shut down <a href="https:&#x2F;&#x2F;medium.com&#x2F;@MeetLima&#x2F;this-time-its-goodbye-5573a97be7d4" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@MeetLima&#x2F;this-time-its-goodbye-5573a97be...</a>)<p>As an additional resource I liked the description of ITC by Fred Hebert: <a href="https:&#x2F;&#x2F;ferd.ca&#x2F;interval-tree-clocks.html" rel="nofollow">https:&#x2F;&#x2F;ferd.ca&#x2F;interval-tree-clocks.html</a>. He is the author of the wonderful Learn You Some Erlang book. There is an ITC library he maintains as well: <a href="https:&#x2F;&#x2F;github.com&#x2F;ferd&#x2F;interval-tree-clocks">https:&#x2F;&#x2F;github.com&#x2F;ferd&#x2F;interval-tree-clocks</a>, started by Paulo Sergio Almeida.</div><br/><div id="42226255" class="c"><input type="checkbox" id="c-42226255" checked=""/><div class="controls bullet"><span class="by">catwell</span><span>|</span><a href="#42225729">parent</a><span>|</span><a href="#42225508">next</a><span>|</span><label class="collapse" for="c-42226255">[-]</label><label class="expand" for="c-42226255">[3 more]</label></div><br/><div class="children"><div class="content">Lima did not use ITC in its product anyway, we used classic version vectors. We considered them for future evolutions but never implemented it. It&#x27;s funny that Fred Herbert&#x27;s use case was a &quot;peer-to-peer Dropbox&quot;, because it is basically what Lima was.<p>I don&#x27;t know many systems that use ITC. Version vectors are simpler and sufficient in most cases. One of the authors of the original paper mentioned in a later presentation (<a href="https:&#x2F;&#x2F;cbaquero.github.io&#x2F;web&#x2F;pdf&#x2F;SDLtime2021.pdf" rel="nofollow">https:&#x2F;&#x2F;cbaquero.github.io&#x2F;web&#x2F;pdf&#x2F;SDLtime2021.pdf</a>) that they were used for tracing, in particular in a 2015 system called Pivot Tracing.</div><br/><div id="42226259" class="c"><input type="checkbox" id="c-42226259" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#42225729">root</a><span>|</span><a href="#42226255">parent</a><span>|</span><a href="#42225508">next</a><span>|</span><label class="collapse" for="c-42226259">[-]</label><label class="expand" for="c-42226259">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for answering, That&#x27;s very interesting! Yeah, I recall being excited about ITCs, but it doesn&#x27;t seems like they made their way into too many practical distributed systems.</div><br/><div id="42226374" class="c"><input type="checkbox" id="c-42226374" checked=""/><div class="controls bullet"><span class="by">catwell</span><span>|</span><a href="#42225729">root</a><span>|</span><a href="#42226259">parent</a><span>|</span><a href="#42225508">next</a><span>|</span><label class="collapse" for="c-42226374">[-]</label><label class="expand" for="c-42226374">[1 more]</label></div><br/><div class="children"><div class="content">Also I had forgotten but here is a more recent follow-up to Fred Hebert&#x27;s post: <a href="https:&#x2F;&#x2F;ferd.ca&#x2F;a-bridge-over-a-river-never-crossed.html" rel="nofollow">https:&#x2F;&#x2F;ferd.ca&#x2F;a-bridge-over-a-river-never-crossed.html</a></div><br/></div></div></div></div></div></div></div></div><div id="42225508" class="c"><input type="checkbox" id="c-42225508" checked=""/><div class="controls bullet"><span class="by">quelltext</span><span>|</span><a href="#42225729">prev</a><span>|</span><a href="#42224968">next</a><span>|</span><label class="collapse" for="c-42225508">[-]</label><label class="expand" for="c-42225508">[4 more]</label></div><br/><div class="children"><div class="content">Several things remain unclear:<p>&quot;The beauty of this scheme is that a node only has to know about its share of the interval&quot;<p>The article doesn&#x27;t explain curve changes in much detail, but I assume it increases the portion of the curve &quot;owned&quot; by the node.<p>With unique identifiers all a node needs to know its identifier. So that can&#x27;t be what&#x27;s interesting about these interval portions.<p>Also:<p>- How that curve is initially drawn isn&#x27;t clear at all. Is it flat and becomes complex over time by forking (+ data modification)?<p>- Why are interval boundaries real-value in a system that cannot actually express real numbers?<p>- How are the intervals &#x2F; portions decided? Is that simpler than generating UUIDs?<p>- How does comparison work?<p>&quot;Comparison works similarly to Version Vectors: if the curve of a stamp is above the other one, it descends it, otherwise the curves intersect and the stamps are concurrent.&quot;<p>But now you have events with curves and intervals where one event might miss a portion. It&#x27;s not immediately clear what happens in that comparison. It&#x27;s maybe obvious to some readers but clearly not an audience that needed introduction for the other things initially explained by the article.<p>In terms of conclusions:<p>My understanding is that the main benefit is that the overall complexity of the &quot;vector&quot; becomes simpler in light of actor explosion due to the merging mechanism. Whereas UUIDs (or even monotonous index indexed vectors) would grow indefinitely, making tracking them on events a challenge.<p>This intro article fails to make this stuff clear.</div><br/><div id="42226308" class="c"><input type="checkbox" id="c-42226308" checked=""/><div class="controls bullet"><span class="by">catwell</span><span>|</span><a href="#42225508">parent</a><span>|</span><a href="#42225887">next</a><span>|</span><label class="collapse" for="c-42226308">[-]</label><label class="expand" for="c-42226308">[1 more]</label></div><br/><div class="children"><div class="content">Hello, author here. Sorry about the lack of clarity, this article is the transcript of a 5 min lightning talk and it was really hard fitting all the relevant content in that little time :) (In retrospect that was a poorly chosen topic. When I picked it I thought the talk would be 10 min, 5 min is too short to explain a subject like this.)<p>&gt; How that curve is initially drawn isn&#x27;t clear at all. Is it flat and becomes complex over time by forking (+ data modification)?<p>Yes, the initial curve is typically constant 0.<p>&gt; Why are interval boundaries real-value in a system that cannot actually express real numbers?<p>Like snthpy said &quot;real&quot; is a shortcut to say infinitely subdivisible. The numbers themselves are actually rationals.<p>&gt; How are the intervals &#x2F; portions decided? Is that simpler than generating UUIDs?<p>Nodes are forked from an existing node, that node decides which portion of its interval it gives to the new node. You pick the splitting point to keep complexity low.<p>Regarding comparison: you always know the values of the whole curve. When I say &quot;a node only has to know about its share of the interval&quot; I only mean the ID space. In a version vector there is a direct link between identifiers and counters, whereas here outside of your share of the interval you don&#x27;t know who owns what or how many devices there are at any given point.</div><br/></div></div><div id="42225887" class="c"><input type="checkbox" id="c-42225887" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#42225508">parent</a><span>|</span><a href="#42226308">prev</a><span>|</span><a href="#42224968">next</a><span>|</span><label class="collapse" for="c-42225887">[-]</label><label class="expand" for="c-42225887">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why are interval boundaries real-value in a system that cannot actually express real numbers?<p>They can be represented as a binary tree, that is a nested list or tuples, for instance. The whole interval (1) could be split into (1,0) and (0,1)). Then (1,0) split into ((1,0),0) and ((0,1),0). And (0,1) split into (0,(1,0)) and (0,(0,1) and so on.</div><br/><div id="42226130" class="c"><input type="checkbox" id="c-42226130" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#42225508">root</a><span>|</span><a href="#42225887">parent</a><span>|</span><a href="#42224968">next</a><span>|</span><label class="collapse" for="c-42226130">[-]</label><label class="expand" for="c-42226130">[1 more]</label></div><br/><div class="children"><div class="content">I guess his point remains though that if all you need is infinite divisibility then using the rational numbers between 0 and 1 would be sufficient. I take it as that was what was meant and &quot;real&quot; numbers was just shorthand for that.</div><br/></div></div></div></div></div></div><div id="42224968" class="c"><input type="checkbox" id="c-42224968" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42225508">prev</a><span>|</span><a href="#42225281">next</a><span>|</span><label class="collapse" for="c-42224968">[-]</label><label class="expand" for="c-42224968">[6 more]</label></div><br/><div class="children"><div class="content">Interval tree clocks seem really cool, and I’d love to use them for something. But unfortunately I can’t think of a way to reliably have a system automatically subdivide an interval to bring new servers up without getting pathological behaviour sometimes. Or, if an identifier (interval) goes offline indefinitely, I can’t think of any good way to clear it.<p>In practice, vector clocks &#x2F; version vectors built using uuid identifiers for machines seem easier to work with, and they’re very predictable. Slightly less efficient - but versions take up a tiny percentage of network traffic and disk space that I don’t think it matters.<p>I really want to use interval tree clocks for something. It’s such a cool algorithm. But I don’t know what I’d use them for - beyond maybe a set of manually provisioned servers syncing data or something.</div><br/><div id="42226347" class="c"><input type="checkbox" id="c-42226347" checked=""/><div class="controls bullet"><span class="by">catwell</span><span>|</span><a href="#42224968">parent</a><span>|</span><a href="#42225335">next</a><span>|</span><label class="collapse" for="c-42226347">[-]</label><label class="expand" for="c-42226347">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really know what you mean regarding pathological subdivisions, but the case where nodes go offline without merging first is a real issue. There are ways to work around it but if you have to do so you lose a lot of its advantage compared to other schemes.<p>When I did that talk I was at the point you are now, trying to find a real use case. I had considered them for Lima but we were actually find with version vectors.<p>I think the case where ITCs can really shine is when you have a lot of short-lived nodes. That could be containers or serverless functions, for instance. I didn&#x27;t think about the tracing use case but it makes a lot of sense, you can fork a new node per request.</div><br/><div id="42226779" class="c"><input type="checkbox" id="c-42226779" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42224968">root</a><span>|</span><a href="#42226347">parent</a><span>|</span><a href="#42225335">next</a><span>|</span><label class="collapse" for="c-42226779">[-]</label><label class="expand" for="c-42226779">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t really know what you mean regarding pathological subdivisions<p>I mean - lets say I&#x27;m making a collaborative text editor. If I use a CRDT, I need clients to be able to emit changes with unique IDs. The obvious way to do that with ITC is to have a server (or set of servers) hand out part of their interval to clients. And the normal way to hand out part of the server&#x27;s interval is to split it in two each time.<p>If you have N clients join the server, the server will end up with 1&#x2F;2^n of the keyspace - since it keeps halving each time a client joins. And some of those clients will just - go away, indefinitely, without &quot;giving the key back&quot;. So the server&#x27;s interval gets smaller and smaller, and the key (interval) that new clients are given will take more and more bits over time. Linearly more bits.<p>With random IDs, the client never needs to give the ID back. You still have problems that the version grows over time - but I can think of a bunch of ways to deal with that. I haven&#x27;t figured out how to solve that problem with interval tree clocks.</div><br/></div></div></div></div><div id="42225335" class="c"><input type="checkbox" id="c-42225335" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#42224968">parent</a><span>|</span><a href="#42226347">prev</a><span>|</span><a href="#42225281">next</a><span>|</span><label class="collapse" for="c-42225335">[-]</label><label class="expand" for="c-42225335">[3 more]</label></div><br/><div class="children"><div class="content">Merging actually seems quite simple given an external coordinator. All you need is some periodic process that can observe the state of the clock, find gaps, and communicate the merge with one of the adjacent nodes. It is something that can be eventually consistent. Splits could occur similarly. Sure you have to ensure single writes from the coordinating process, but that’s easier to solve bc of the relative infrequency that the coordinator needs to run, leaving lots of time for consistency in between updates.<p>The key assumption I’m making here is that nodes communicate much more frequently than nodes are added and removed from the system. We’re optimizing for the latency of the former at the cost of latency of the latter.</div><br/><div id="42226785" class="c"><input type="checkbox" id="c-42226785" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42224968">root</a><span>|</span><a href="#42225335">parent</a><span>|</span><a href="#42226283">next</a><span>|</span><label class="collapse" for="c-42226785">[-]</label><label class="expand" for="c-42226785">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m thinking about this in the context of an eventually consistent CRDT or something. In that case, you need to handle the use case of a client going offline (eg the person is on holiday) and they make changes but aren&#x27;t online for 2 weeks.<p>If a peer isn&#x27;t emitting changes, I don&#x27;t see how you can safely merge their keyspace - since they might still be using that keyspace, but be offline, and you can&#x27;t know.</div><br/></div></div><div id="42226283" class="c"><input type="checkbox" id="c-42226283" checked=""/><div class="controls bullet"><span class="by">hedgehog</span><span>|</span><a href="#42224968">root</a><span>|</span><a href="#42225335">parent</a><span>|</span><a href="#42226785">prev</a><span>|</span><a href="#42225281">next</a><span>|</span><label class="collapse" for="c-42226283">[-]</label><label class="expand" for="c-42226283">[1 more]</label></div><br/><div class="children"><div class="content">The special thing about ITC is you can do the splitting (to add a member) and joining (to remove one) without any external coordination. They otherwise are used in the same way as vector clocks. I find the linked post more confusing than I remember the original paper being (I wrote an implementation):<p><a href="http:&#x2F;&#x2F;hydra.azilian.net&#x2F;Papers&#x2F;Interval%20Tree%20Clocks.pdf" rel="nofollow">http:&#x2F;&#x2F;hydra.azilian.net&#x2F;Papers&#x2F;Interval%20Tree%20Clocks.pdf</a></div><br/></div></div></div></div></div></div><div id="42224756" class="c"><input type="checkbox" id="c-42224756" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#42225281">prev</a><span>|</span><label class="collapse" for="c-42224756">[-]</label><label class="expand" for="c-42224756">[2 more]</label></div><br/><div class="children"><div class="content">the link in the paper referenced goes to some auto-scrolling page with all kinds of content. I found a direct link here:<p><a href="http:&#x2F;&#x2F;hydra.azilian.net&#x2F;Papers&#x2F;Interval%20Tree%20Clocks.pdf" rel="nofollow">http:&#x2F;&#x2F;hydra.azilian.net&#x2F;Papers&#x2F;Interval%20Tree%20Clocks.pdf</a></div><br/><div id="42226321" class="c"><input type="checkbox" id="c-42226321" checked=""/><div class="controls bullet"><span class="by">catwell</span><span>|</span><a href="#42224756">parent</a><span>|</span><label class="collapse" for="c-42226321">[-]</label><label class="expand" for="c-42226321">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the original link is dead, and that one doesn&#x27;t work for me currently. I&#x27;ll edit the post if I find a working one.<p>EDIT: I found where the paper has moved, I have updated the article.</div><br/></div></div></div></div></div></div></div></div></div></body></html>