<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711875653635" as="style"/><link rel="stylesheet" href="styles.css?v=1711875653635"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lucasoshiro.github.io/posts-en/2023-02-13-git-debug/">Git as a debugging tool</a> <span class="domain">(<a href="https://lucasoshiro.github.io">lucasoshiro.github.io</a>)</span></div><div class="subtext"><span>lucasoshiro</span> | <span>40 comments</span></div><br/><div><div id="39881322" class="c"><input type="checkbox" id="c-39881322" checked=""/><div class="controls bullet"><span class="by">teeray</span><span>|</span><a href="#39878807">next</a><span>|</span><label class="collapse" for="c-39881322">[-]</label><label class="expand" for="c-39881322">[10 more]</label></div><br/><div class="children"><div class="content">Remember that the more you treat commit history as something to be read, the better these tools get. If you’re just jamming “-m” on `git commit` with nonsense like “fix bug”, “pr comments”, “ci”, then you’re going to have a bad time debugging with Git. Also, if you have mandatory squash and merge, congrats, you’re destroying history all the time that can help you debug things.</div><br/><div id="39881966" class="c"><input type="checkbox" id="c-39881966" checked=""/><div class="controls bullet"><span class="by">MichaelMug</span><span>|</span><a href="#39881322">parent</a><span>|</span><a href="#39882183">prev</a><span>|</span><a href="#39882419">next</a><span>|</span><label class="collapse" for="c-39881966">[-]</label><label class="expand" for="c-39881966">[6 more]</label></div><br/><div class="children"><div class="content">This is one of the biggest issues I face at work. I always see &quot;added X&quot;, which git can already tell me.<p>&gt; Also, if you have mandatory squash and merge, congrats, you’re destroying history all the time that can help you debug things.<p>Well the alternative is 100s of commits like this:<p>fix bug<p>added file<p>fix typo<p>fix typo<p>update test<p>test<p>test<p>test<p>fix typo<p>added file</div><br/><div id="39882068" class="c"><input type="checkbox" id="c-39882068" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#39881322">root</a><span>|</span><a href="#39881966">parent</a><span>|</span><a href="#39882386">next</a><span>|</span><label class="collapse" for="c-39882068">[-]</label><label class="expand" for="c-39882068">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one alternative.  Another alternative is cleaning that up in a rebase into a series of (hopefully) easy to follow individual commits that do one thing, and then a merge commit pulling in the branch with a description of the change as a whole (and a reference to the pr and any relevant tickets).  There are other alternatives as well that make various tradeoffs between effort for the author, effort for the reviewer, ease of reading the git history, applicability of various tools, etc.</div><br/><div id="39882177" class="c"><input type="checkbox" id="c-39882177" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#39881322">root</a><span>|</span><a href="#39882068">parent</a><span>|</span><a href="#39882386">next</a><span>|</span><label class="collapse" for="c-39882177">[-]</label><label class="expand" for="c-39882177">[3 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;ll never understand the &quot;fix typo&quot; commits when `git commit --amend` is so straightforward.</div><br/><div id="39882355" class="c"><input type="checkbox" id="c-39882355" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39881322">root</a><span>|</span><a href="#39882177">parent</a><span>|</span><a href="#39882386">next</a><span>|</span><label class="collapse" for="c-39882355">[-]</label><label class="expand" for="c-39882355">[2 more]</label></div><br/><div class="children"><div class="content">Better-still is `git commit --fixup {rev}` and `git rebase -i --autosquash`, since then the fix(up) can be placed into the most-appropriate commit, which isn&#x27;t necessarily the most-recent one.<p>Of course, that assumes a you&#x27;re already got a workforce that is able to do resolve minor conflicts when something else near the typo got tweaked in a separate commit, so I&#x27;ll grant that `--amend` is easier when starting out.</div><br/><div id="39882485" class="c"><input type="checkbox" id="c-39882485" checked=""/><div class="controls bullet"><span class="by">tux3</span><span>|</span><a href="#39881322">root</a><span>|</span><a href="#39882355">parent</a><span>|</span><a href="#39882386">next</a><span>|</span><label class="collapse" for="c-39882485">[-]</label><label class="expand" for="c-39882485">[1 more]</label></div><br/><div class="children"><div class="content">Better still, git-absorb figures out in which recent commit your fixups should go on its own (based on which file it touches)</div><br/></div></div></div></div></div></div></div></div><div id="39882386" class="c"><input type="checkbox" id="c-39882386" checked=""/><div class="controls bullet"><span class="by">manojlds</span><span>|</span><a href="#39881322">root</a><span>|</span><a href="#39881966">parent</a><span>|</span><a href="#39882068">prev</a><span>|</span><a href="#39882419">next</a><span>|</span><label class="collapse" for="c-39882386">[-]</label><label class="expand" for="c-39882386">[1 more]</label></div><br/><div class="children"><div class="content">We can do rebase and squash on our side while also developing with silly commits but not pushing them.</div><br/></div></div></div></div><div id="39882419" class="c"><input type="checkbox" id="c-39882419" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#39881322">parent</a><span>|</span><a href="#39881966">prev</a><span>|</span><a href="#39881696">next</a><span>|</span><label class="collapse" for="c-39882419">[-]</label><label class="expand" for="c-39882419">[1 more]</label></div><br/><div class="children"><div class="content">The point of squash is that the &quot;history&quot; <i>is</i> nonsense like &quot;fix&quot; etc. There are two types of commit: versions and checkpoints. The latter are just to help you develop and can include stuff like &quot;end of day&quot; that should never end up on master. Squashing is a way to turn those into versions. Blindly squashing every branch down into one commit is stupid, though.</div><br/></div></div><div id="39881696" class="c"><input type="checkbox" id="c-39881696" checked=""/><div class="controls bullet"><span class="by">whoitwas</span><span>|</span><a href="#39881322">parent</a><span>|</span><a href="#39882419">prev</a><span>|</span><a href="#39878807">next</a><span>|</span><label class="collapse" for="c-39881696">[-]</label><label class="expand" for="c-39881696">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. A good policy is to include ticket number and a short description.</div><br/></div></div></div></div><div id="39878807" class="c"><input type="checkbox" id="c-39878807" checked=""/><div class="controls bullet"><span class="by">ozay</span><span>|</span><a href="#39881322">prev</a><span>|</span><a href="#39880472">next</a><span>|</span><label class="collapse" for="c-39878807">[-]</label><label class="expand" for="c-39878807">[8 more]</label></div><br/><div class="children"><div class="content"><i>git blame shows only who made the last change. Maybe that person only changed the name of a variable, applied a codestyle change, moved a function declaration to another file or many other things that the change was almost irrelevant to the code behavior.</i><p>There are a few options that help you out with this:<p>-M Detect moved or copied lines within a file<p>-C In addition to -M, detect lines moved or copied from other files that were modified in the same commit.<p>--ignore-rev &lt;rev&gt; Ignore changes made by the revision when assigning blame, as if the change never happened<p>--ignore-revs-file &lt;file&gt; Ignore revisions listed in file<p><a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-blame" rel="nofollow">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-blame</a></div><br/><div id="39880829" class="c"><input type="checkbox" id="c-39880829" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39878807">parent</a><span>|</span><a href="#39879006">next</a><span>|</span><label class="collapse" for="c-39880829">[-]</label><label class="expand" for="c-39880829">[1 more]</label></div><br/><div class="children"><div class="content">I wish they would make long option names for everything, including -C and -M.  (Perhaps I should contribute that..)<p>I use short options interactively on the command line, but in scripts and when communicating with other people, I prefer longer options because they are self-documenting and can catch most typos.  (For a long option, typos are more likely to result in an invalid option, and thus an error message.  For one-letter options, a typo could result in anything..)</div><br/></div></div><div id="39879006" class="c"><input type="checkbox" id="c-39879006" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#39878807">parent</a><span>|</span><a href="#39880829">prev</a><span>|</span><a href="#39880472">next</a><span>|</span><label class="collapse" for="c-39879006">[-]</label><label class="expand" for="c-39879006">[6 more]</label></div><br/><div class="children"><div class="content">I recommend just skipping blame and going to git log -L to see the full evolution of a range of lines, I set up a little keybind in vim which does this for the current visual selection and it works much better than blame.</div><br/><div id="39879288" class="c"><input type="checkbox" id="c-39879288" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#39878807">root</a><span>|</span><a href="#39879006">parent</a><span>|</span><a href="#39879897">next</a><span>|</span><label class="collapse" for="c-39879288">[-]</label><label class="expand" for="c-39879288">[3 more]</label></div><br/><div class="children"><div class="content">And for those using Magit in Emacs, you can do this by selecting a region of lines and hitting `C-c M-g l`.<p><a href="https:&#x2F;&#x2F;magit.vc&#x2F;manual&#x2F;magit&#x2F;Commands-for-Buffers-Visiting-Files.html#index-C_002dc-M_002dg-l" rel="nofollow">https:&#x2F;&#x2F;magit.vc&#x2F;manual&#x2F;magit&#x2F;Commands-for-Buffers-Visiting-...</a></div><br/><div id="39882128" class="c"><input type="checkbox" id="c-39882128" checked=""/><div class="controls bullet"><span class="by">karthink</span><span>|</span><a href="#39878807">root</a><span>|</span><a href="#39879288">parent</a><span>|</span><a href="#39879632">next</a><span>|</span><label class="collapse" for="c-39882128">[-]</label><label class="expand" for="c-39882128">[1 more]</label></div><br/><div class="children"><div class="content">This feature is built into Emacs, no Magit needed.  It&#x27;s the vc-region-history command, bound to `C-x v h` by default.  It works across all version control systems Emacs supports, not just git.</div><br/></div></div><div id="39879632" class="c"><input type="checkbox" id="c-39879632" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#39878807">root</a><span>|</span><a href="#39879288">parent</a><span>|</span><a href="#39882128">prev</a><span>|</span><a href="#39879897">next</a><span>|</span><label class="collapse" for="c-39879632">[-]</label><label class="expand" for="c-39879632">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also git time machine to quickly rollback a buffer in place</div><br/></div></div></div></div><div id="39879897" class="c"><input type="checkbox" id="c-39879897" checked=""/><div class="controls bullet"><span class="by">jmholla</span><span>|</span><a href="#39878807">root</a><span>|</span><a href="#39879006">parent</a><span>|</span><a href="#39879288">prev</a><span>|</span><a href="#39880472">next</a><span>|</span><label class="collapse" for="c-39879897">[-]</label><label class="expand" for="c-39879897">[2 more]</label></div><br/><div class="children"><div class="content">Nice. Can you share your vim configuration for that?</div><br/><div id="39881954" class="c"><input type="checkbox" id="c-39881954" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#39878807">root</a><span>|</span><a href="#39879897">parent</a><span>|</span><a href="#39880472">next</a><span>|</span><label class="collapse" for="c-39881954">[-]</label><label class="expand" for="c-39881954">[1 more]</label></div><br/><div class="children"><div class="content">My config is kind of cluttered so this is a simplified version without dependencies. Glogr is for range history, GLogf for file history and &lt;leader&gt;gc for showing a commit based on hash:<p><pre><code>    nnoremap &lt;leader&gt;gc :Gshow &lt;C-R&gt;&lt;C-W&gt;&lt;cr&gt;
    command! -nargs=1 Gshow enew | set ft=diff buftype=nofile | 0r!git log -p -n 1 &quot;&lt;args&gt;&quot;
    command! -nargs=0 Glogf tabnew | set ft=diff buftype=nofile | 0r!git -C &quot;#:h&quot; log -p --follow &quot;#:t&quot;
    command! -nargs=0 -range Glogr tabnew | set ft=diff buftype=nofile | 0r!git -C &quot;#:h&quot; log -L &quot;&lt;line1&gt;,&lt;line2&gt;:#:t&quot;</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="39880472" class="c"><input type="checkbox" id="c-39880472" checked=""/><div class="controls bullet"><span class="by">izoow</span><span>|</span><a href="#39878807">prev</a><span>|</span><a href="#39878613">next</a><span>|</span><label class="collapse" for="c-39880472">[-]</label><label class="expand" for="c-39880472">[3 more]</label></div><br/><div class="children"><div class="content">I recently found out that git rebase has a --exec option that allows you to execute a shell command for each commit. If the command fails, the rebase pauses and allows you to make changes to make the command pass. I use this to make sure that there is no commit that leaves my project in an unbuildable state.</div><br/><div id="39880775" class="c"><input type="checkbox" id="c-39880775" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39880472">parent</a><span>|</span><a href="#39881562">prev</a><span>|</span><a href="#39878613">next</a><span>|</span><label class="collapse" for="c-39880775">[-]</label><label class="expand" for="c-39880775">[1 more]</label></div><br/><div class="children"><div class="content">You can also use `--interactive` to do a lot of complicated stuff.</div><br/></div></div></div></div><div id="39878613" class="c"><input type="checkbox" id="c-39878613" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39880472">prev</a><span>|</span><a href="#39879482">next</a><span>|</span><label class="collapse" for="c-39878613">[-]</label><label class="expand" for="c-39878613">[2 more]</label></div><br/><div class="children"><div class="content">Another thing you can do when you have two versions, one which fails and one which doesn&#x27;t, but where the commits are of the messy work in progress nature and not atomic changes, is gradually stage the changes from the bad version onto the good version until it starts failing<p>Basically git checkout -p until things fail</div><br/><div id="39878660" class="c"><input type="checkbox" id="c-39878660" checked=""/><div class="controls bullet"><span class="by">lucasoshiro</span><span>|</span><a href="#39878613">parent</a><span>|</span><a href="#39879482">next</a><span>|</span><label class="collapse" for="c-39878660">[-]</label><label class="expand" for="c-39878660">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the comment! It looks to be a very useful tip for doing after bisect on repositories where people insist to squash pull requests.</div><br/></div></div></div></div><div id="39879482" class="c"><input type="checkbox" id="c-39879482" checked=""/><div class="controls bullet"><span class="by">billllll</span><span>|</span><a href="#39878613">prev</a><span>|</span><a href="#39880554">next</a><span>|</span><label class="collapse" for="c-39879482">[-]</label><label class="expand" for="c-39879482">[2 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t know Git had a bisect feature. I&#x27;ll keep that in mind for later.<p>Other than bisect though, I do think a lot of the practices outlined in the article (checking the blame, logs, search, etc) is way easier to do in a web UI, at least for someone like me who hasn&#x27;t tailored their workflow for the command line. The tooling is so ubiquitous that it&#x27;s easily available. I personally think GitHub does okay in those regards.</div><br/><div id="39880121" class="c"><input type="checkbox" id="c-39880121" checked=""/><div class="controls bullet"><span class="by">lucasoshiro</span><span>|</span><a href="#39879482">parent</a><span>|</span><a href="#39880554">next</a><span>|</span><label class="collapse" for="c-39880121">[-]</label><label class="expand" for="c-39880121">[1 more]</label></div><br/><div class="children"><div class="content">Personally, I&#x27;ve tried some graphical tools (e.g. magit on Emacs and the git tools on JetBrains IDEs), but still prefer CLI as I think those UIs hide too much from the user, specially in more complex repositories (e.g. repos with submodules).<p>These features (except blame) are more advanced features, that may be hidden in those interfaces. Instead of remember where they are behind some menus or shortcuts, I prefer to remember their CLI as it is faster.</div><br/></div></div></div></div><div id="39880554" class="c"><input type="checkbox" id="c-39880554" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#39879482">prev</a><span>|</span><a href="#39881253">next</a><span>|</span><label class="collapse" for="c-39880554">[-]</label><label class="expand" for="c-39880554">[1 more]</label></div><br/><div class="children"><div class="content">Git Bisect has saved me multiple times. It&#x27;s such a simple concept, but being able to hone into the commit where something is broken is almost always useful.<p>I&#x27;ve never tried automating it.  That&#x27;ll be fun to try next time I&#x27;m in trouble.</div><br/></div></div><div id="39880879" class="c"><input type="checkbox" id="c-39880879" checked=""/><div class="controls bullet"><span class="by">interbased</span><span>|</span><a href="#39878686">prev</a><span>|</span><a href="#39878168">next</a><span>|</span><label class="collapse" for="c-39880879">[-]</label><label class="expand" for="c-39880879">[1 more]</label></div><br/><div class="children"><div class="content">I never knew about the -s flag with git log. That would be super helpful in many situations for me &#x2F; my team.</div><br/></div></div><div id="39878168" class="c"><input type="checkbox" id="c-39878168" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#39880879">prev</a><span>|</span><label class="collapse" for="c-39878168">[-]</label><label class="expand" for="c-39878168">[10 more]</label></div><br/><div class="children"><div class="content">Another way to use git to debug - albeit more tedious -  is to manually check out branches (using a binary search) until you find the exact change that caused an issue. This is helpful if you have no idea what part of the code is causing a problem, but you know the problem didn&#x27;t exist a month ago. Performance issues are a good example.</div><br/><div id="39878191" class="c"><input type="checkbox" id="c-39878191" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#39878168">parent</a><span>|</span><a href="#39879528">next</a><span>|</span><label class="collapse" for="c-39878191">[-]</label><label class="expand" for="c-39878191">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about branches, but if you&#x27;re just traversing history that&#x27;s a textbook use for git bisect, right?</div><br/><div id="39878257" class="c"><input type="checkbox" id="c-39878257" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#39878168">root</a><span>|</span><a href="#39878191">parent</a><span>|</span><a href="#39878246">next</a><span>|</span><label class="collapse" for="c-39878257">[-]</label><label class="expand" for="c-39878257">[1 more]</label></div><br/><div class="children"><div class="content">Yes, failure to rtfa on my part.</div><br/></div></div><div id="39878246" class="c"><input type="checkbox" id="c-39878246" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#39878168">root</a><span>|</span><a href="#39878191">parent</a><span>|</span><a href="#39878257">prev</a><span>|</span><a href="#39879528">next</a><span>|</span><label class="collapse" for="c-39878246">[-]</label><label class="expand" for="c-39878246">[4 more]</label></div><br/><div class="children"><div class="content">Yep. Git bisect automatically does a binary search to find the earliest breaking commit. You can either test each version manually or, if you have a script that will pass or fail, like a unit test, you can tell git and it will do everything automatically. I love it when I get to use git bisect.</div><br/><div id="39879097" class="c"><input type="checkbox" id="c-39879097" checked=""/><div class="controls bullet"><span class="by">amboar</span><span>|</span><a href="#39878168">root</a><span>|</span><a href="#39878246">parent</a><span>|</span><a href="#39879528">next</a><span>|</span><label class="collapse" for="c-39879097">[-]</label><label class="expand" for="c-39879097">[3 more]</label></div><br/><div class="children"><div class="content">A handy trick I&#x27;ve developed is using`git bisect` to solve otherwise intractable rebase conflicts:<p><a href="https:&#x2F;&#x2F;codeconstruct.com.au&#x2F;docs&#x2F;bisect-intractable-rebase-conflicts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;codeconstruct.com.au&#x2F;docs&#x2F;bisect-intractable-rebase-...</a></div><br/><div id="39880818" class="c"><input type="checkbox" id="c-39880818" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39878168">root</a><span>|</span><a href="#39879097">parent</a><span>|</span><a href="#39879528">next</a><span>|</span><label class="collapse" for="c-39880818">[-]</label><label class="expand" for="c-39880818">[2 more]</label></div><br/><div class="children"><div class="content">You might want to combine this with enabling rerere.</div><br/><div id="39881430" class="c"><input type="checkbox" id="c-39881430" checked=""/><div class="controls bullet"><span class="by">amboar</span><span>|</span><a href="#39878168">root</a><span>|</span><a href="#39880818">parent</a><span>|</span><a href="#39879528">next</a><span>|</span><label class="collapse" for="c-39881430">[-]</label><label class="expand" for="c-39881430">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I have rerere turned on  However, it&#x27;s not directly beneficial for the process outlined. With what I wrote about you only solve a given conflict at the end of a complete bisect run, not at each bisection point inside a run. The bisect&#x2F;cherry-pick process is only used to determine whether conflicts do or don&#x27;t happen at a given upstream commit. Usually you will solve a specific conflict only once, regardless of whether rerere is enabled.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39879528" class="c"><input type="checkbox" id="c-39879528" checked=""/><div class="controls bullet"><span class="by">shinycode</span><span>|</span><a href="#39878168">parent</a><span>|</span><a href="#39878191">prev</a><span>|</span><a href="#39879454">next</a><span>|</span><label class="collapse" for="c-39879528">[-]</label><label class="expand" for="c-39879528">[2 more]</label></div><br/><div class="children"><div class="content">In jetbrain products, you can select any bloc of code and show the git history for this particular bloc. 
I don’t know exactly which command is behind it but I always thought it would be tedious to do it manually like you described</div><br/><div id="39880051" class="c"><input type="checkbox" id="c-39880051" checked=""/><div class="controls bullet"><span class="by">lucasoshiro</span><span>|</span><a href="#39878168">root</a><span>|</span><a href="#39879528">parent</a><span>|</span><a href="#39879454">next</a><span>|</span><label class="collapse" for="c-39880051">[-]</label><label class="expand" for="c-39880051">[1 more]</label></div><br/><div class="children"><div class="content">Probably they use libgit2 instead of git. But you can use git log -L for that.</div><br/></div></div></div></div><div id="39879454" class="c"><input type="checkbox" id="c-39879454" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#39878168">parent</a><span>|</span><a href="#39879528">prev</a><span>|</span><label class="collapse" for="c-39879454">[-]</label><label class="expand" for="c-39879454">[1 more]</label></div><br/><div class="children"><div class="content">Thats called git bisect</div><br/></div></div></div></div></div></div></div></div></div></body></html>