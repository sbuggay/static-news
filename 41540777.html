<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726390867081" as="style"/><link rel="stylesheet" href="styles.css?v=1726390867081"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.yoshuawuyts.com/nesting-allocators/">Nesting Allocators (2023)</a>Â <span class="domain">(<a href="https://blog.yoshuawuyts.com">blog.yoshuawuyts.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>6 comments</span></div><br/><div><div id="41544673" class="c"><input type="checkbox" id="c-41544673" checked=""/><div class="controls bullet"><span class="by">nickysielicki</span><span>|</span><a href="#41545447">next</a><span>|</span><label class="collapse" for="c-41544673">[-]</label><label class="expand" for="c-41544673">[1 more]</label></div><br/><div class="children"><div class="content">For anyone skipping straight to the comments, just for context, this article is not about how to nest arena allocators in rust, it&#x27;s moreso about imagining how the syntax ought to look once someone decides to pick up the work.<p>Say what you will about C++, but allocators are something it gets incredibly right. Bloomberg lead the effort to standardize std::pmr (derived from a similar implementation in their internal codebase), and the work and thought that went into that strongly shows. If you do it right, you end up with code that largely reads as normal C++ without any sacrifice in performance -- the allocation details are capable of mostly being embedded into the type system itself. I don&#x27;t see that here in this article, and I think if Rust wants to beat C++ in this space it&#x27;s going to need to try to do something similar.<p>I wish that there were more projects happening atop std::pmr. NVIDIA&#x27;s cccl has an experimental memory_resource for CUDA memory (and their RMM library has a lot of nifty resource adapters), and it&#x27;s cool to see how they&#x27;re adopting this to heterogeneous compute, but there&#x27;s nothing interesting in the open source world that I&#x27;ve seen that tries to build atop the learnings of mimalloc&#x2F;glibc&#x2F;etc. in terms of beating the STL pool resources. Probably, they exist but are just kept proprietary.</div><br/></div></div><div id="41545447" class="c"><input type="checkbox" id="c-41545447" checked=""/><div class="controls bullet"><span class="by">thomasmg</span><span>|</span><a href="#41544673">prev</a><span>|</span><a href="#41544138">next</a><span>|</span><label class="collapse" for="c-41545447">[-]</label><label class="expand" for="c-41545447">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how to mix multiple allocators in a safe way. Say an arena allocator and the default one. How to prevent the non-arena object points to the arena one? (The problem is: the arena could get wiped, so this pointer would be invalid.) The post is about Rust, so I was hoping this is adressed...<p>I&#x27;m working on my own programming language and want to support multiple allocators. Usually languages just support one OR the other, safely.</div><br/><div id="41545701" class="c"><input type="checkbox" id="c-41545701" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41545447">parent</a><span>|</span><a href="#41544138">next</a><span>|</span><label class="collapse" for="c-41545701">[-]</label><label class="expand" for="c-41545701">[1 more]</label></div><br/><div class="children"><div class="content">I would imagine the normal lifetime arrangements in Rust would prevent this, the same way it prevents nesting a shorter lived pointer inside a longer lived struct when they&#x27;re all from the same allocator.</div><br/></div></div></div></div><div id="41544138" class="c"><input type="checkbox" id="c-41544138" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41545447">prev</a><span>|</span><label class="collapse" for="c-41544138">[-]</label><label class="expand" for="c-41544138">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s odd to me to call this a capability. We have a term for this already: dynamic bind, known as dynamic scope when it&#x27;s the main scoping mechanism of a language.<p>That said, the mechanism seems like the right way for Rust to solve this problem, since ambient allocation is deeply baked into the language, and taming implicit globals with dynamic bind has a long history, and works fairly well.</div><br/><div id="41544594" class="c"><input type="checkbox" id="c-41544594" checked=""/><div class="controls bullet"><span class="by">cwzwarich</span><span>|</span><a href="#41544138">parent</a><span>|</span><label class="collapse" for="c-41544594">[-]</label><label class="expand" for="c-41544594">[1 more]</label></div><br/><div class="children"><div class="content">According to the linked proposal, these implicit capability parameters are lexically bound, not dynamically bound.</div><br/></div></div></div></div></div></div></div></div></div></body></html>