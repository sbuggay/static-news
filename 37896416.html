<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697533267604" as="style"/><link rel="stylesheet" href="styles.css?v=1697533267604"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/mgarciaisaia/JavaScript-Is-Weird-as-a-compressor">JavaScript Is Weird as a Compressor</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mgarciaisaia</span> | <span>20 comments</span></div><br/><div><div id="37912209" class="c"><input type="checkbox" id="c-37912209" checked=""/><div class="controls bullet"><span class="by">urbandw311er</span><span>|</span><a href="#37910526">next</a><span>|</span><label class="collapse" for="c-37912209">[-]</label><label class="expand" for="c-37912209">[2 more]</label></div><br/><div class="children"><div class="content">My view of the author changed somewhat when I reached the section where he had to ask ChatGPT how to read command line parameters.</div><br/><div id="37912230" class="c"><input type="checkbox" id="c-37912230" checked=""/><div class="controls bullet"><span class="by">vorticalbox</span><span>|</span><a href="#37912209">parent</a><span>|</span><a href="#37910526">next</a><span>|</span><label class="collapse" for="c-37912230">[-]</label><label class="expand" for="c-37912230">[1 more]</label></div><br/><div class="children"><div class="content">I read that as satire given the current state of the LLMs like chatGPT</div><br/></div></div></div></div><div id="37910526" class="c"><input type="checkbox" id="c-37910526" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#37912209">prev</a><span>|</span><a href="#37910316">next</a><span>|</span><label class="collapse" for="c-37910526">[-]</label><label class="expand" for="c-37910526">[3 more]</label></div><br/><div class="children"><div class="content">Just for fun, I decided to pass the output.js file through Google Closure Compiler&#x27;s advanced optimizations. It does a surprisingly good job at reconstructing part of the strings.<p><pre><code>  % npx google-closure-compiler -O ADVANCED --js output.js

  (()=&gt;{})[&quot;co&quot;+(1&#x2F;0+[])[4]+&quot;structor&quot;](&quot;co&quot;+(1&#x2F;0+[])[4]+...
</code></pre>
Not pasting the full thing. But it reduces the output.js file from ~118 KiB to ~9.92 KiB, which is pretty good!<p>There is technically not much stopping the compiler from inferring that 1&#x2F;0 === Infinity, recognizing (1&#x2F;0+[])[4] is free of side-effects, and eventually concluding its safe to substitute the whole expression with &quot;n&quot;. Google Closure already has optimizations for string concatenation, so if it were able to perform an optimization pass with Infinity, then it would also be able to emit the string &quot;constructor&quot; instead of &quot;co&quot;+(1&#x2F;0+[])[4]+&quot;structor&quot;</div><br/><div id="37912002" class="c"><input type="checkbox" id="c-37912002" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#37910526">parent</a><span>|</span><a href="#37910747">next</a><span>|</span><label class="collapse" for="c-37912002">[-]</label><label class="expand" for="c-37912002">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. I wonder if an even more effective approach to unobfuscation would be an &quot;anti-jit&quot; compiler; since what we&#x27;re interested in is the actual execution flow, can we leverage all the browser&#x27;s optimization engine to pull that out for us?<p>Do the various JIT engines use an intermediate representation (IR) and what does it look like?</div><br/></div></div><div id="37910747" class="c"><input type="checkbox" id="c-37910747" checked=""/><div class="controls bullet"><span class="by">woneton</span><span>|</span><a href="#37910526">parent</a><span>|</span><a href="#37912002">prev</a><span>|</span><a href="#37910316">next</a><span>|</span><label class="collapse" for="c-37910747">[-]</label><label class="expand" for="c-37910747">[1 more]</label></div><br/><div class="children"><div class="content">$ wc -c output.js<p><pre><code>  117708 output.js
</code></pre>
$ uglify-js output.js -c unsafe | node<p>Hello world!<p>$ uglify-js output.js -c unsafe | wc -c<p><pre><code>    2740
</code></pre>
$ uglify-js output.js -c unsafe | cut -c 1-60<p>(()=&gt;{}).constructor(&quot;conso&quot;+&quot;&quot;.constructor[&quot;from&quot;+(()=&gt;{}).<p>$ uglify-js output.js -c unsafe | gzip | wc -c<p><pre><code>     192</code></pre></div><br/></div></div></div></div><div id="37910316" class="c"><input type="checkbox" id="c-37910316" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#37910526">prev</a><span>|</span><a href="#37910551">next</a><span>|</span><label class="collapse" for="c-37910316">[-]</label><label class="expand" for="c-37910316">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually surprised at how insanely terrible the &quot;compression&quot; is.<p>Looking at the table at the end, I&#x27;m not surprised at all that the &quot;weird&quot; obfuscated code is ~2000x the size of the original source.<p>But I <i>am</i> surprised that that the gzipped weird code is still ~25x the size of the original source, as opposed to ~0.25x for gzipping the original source.<p>After all, the amount information in the weird code should still ultimately be approximately the same as the original source code, right? Or maybe double or something like that. I&#x27;m very surprised it&#x27;s <i>twenty-five times as much</i>.<p>The only reason I can guess is that the &quot;weird&quot; process results in information structures that are represented in an extremely <i>hierarchical</i> way, and gzip is built for <i>stream</i> compression, and is unable to find&#x2F;represent&#x2F;compress hierarchical structures?<p>And if that&#x27;s the case, it makes me wonder if there <i>are</i> any compression algorithms which are able to handle that better? That might not be based on &quot;dictionary words&#x2F;sequences&quot; as much, but rather attempting to find &quot;nestable&#x2F;repeatable syntax patterns&quot;?</div><br/><div id="37910514" class="c"><input type="checkbox" id="c-37910514" checked=""/><div class="controls bullet"><span class="by">thristian</span><span>|</span><a href="#37910316">parent</a><span>|</span><a href="#37910551">next</a><span>|</span><label class="collapse" for="c-37910514">[-]</label><label class="expand" for="c-37910514">[2 more]</label></div><br/><div class="children"><div class="content">Compression is all about detecting patterns in the data, usually with some kind of sliding window of past data, used to predict future data. For gzip in particular, this sliding window has a fixed size of 32KB.<p>If the &quot;weird&quot; version is ~2000× the size of the original source, gzip would need a sliding window of ~2000× the size (about 64MB) to obtain equivalent compression.</div><br/><div id="37910572" class="c"><input type="checkbox" id="c-37910572" checked=""/><div class="controls bullet"><span class="by">wizzard0</span><span>|</span><a href="#37910316">root</a><span>|</span><a href="#37910514">parent</a><span>|</span><a href="#37910551">next</a><span>|</span><label class="collapse" for="c-37910572">[-]</label><label class="expand" for="c-37910572">[1 more]</label></div><br/><div class="children"><div class="content">Also, an encoder like these can inject any amount of entropy (eg replace &quot;0&quot; with &quot;100500999-100500999&quot;) which gzip can reduce to &quot;100500999-same&quot; but without knowledge of JS semantics has no chance to reduce to either &quot;0&quot; nor the nearby &quot;172913211-172913211&quot;)</div><br/></div></div></div></div></div></div><div id="37910551" class="c"><input type="checkbox" id="c-37910551" checked=""/><div class="controls bullet"><span class="by">wizzard0</span><span>|</span><a href="#37910316">prev</a><span>|</span><a href="#37909064">next</a><span>|</span><label class="collapse" for="c-37910551">[-]</label><label class="expand" for="c-37910551">[2 more]</label></div><br/><div class="children"><div class="content">1) The title is a clickbait, but<p>2) Thanks for leading with an example of a negative result! That&#x27;s what any researcher faces every day, unlike what gets published, after all</div><br/><div id="37912147" class="c"><input type="checkbox" id="c-37912147" checked=""/><div class="controls bullet"><span class="by">_the_inflator</span><span>|</span><a href="#37910551">parent</a><span>|</span><a href="#37909064">next</a><span>|</span><label class="collapse" for="c-37912147">[-]</label><label class="expand" for="c-37912147">[1 more]</label></div><br/><div class="children"><div class="content">I won’t quote Edison here, but I totally agree.</div><br/></div></div></div></div><div id="37909064" class="c"><input type="checkbox" id="c-37909064" checked=""/><div class="controls bullet"><span class="by">SquareWheel</span><span>|</span><a href="#37910551">prev</a><span>|</span><a href="#37910606">next</a><span>|</span><label class="collapse" for="c-37909064">[-]</label><label class="expand" for="c-37909064">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a huge surprise that gzip as a general compression algorithm didn&#x27;t compress this down any further.  I do wonder about a format that was specifically trained on these specific characters though, and the patterns that tend to emerge from the weird compiler.  Maybe the chunks at a certain scale would be predictable and thus compressible.<p>Of course at that point you&#x27;re probably more interested in a common binary format, and should start thinking about wasm instead.</div><br/><div id="37910021" class="c"><input type="checkbox" id="c-37910021" checked=""/><div class="controls bullet"><span class="by">hughw</span><span>|</span><a href="#37909064">parent</a><span>|</span><a href="#37910606">next</a><span>|</span><label class="collapse" for="c-37910021">[-]</label><label class="expand" for="c-37910021">[1 more]</label></div><br/><div class="children"><div class="content">The information content of the weird program is the same as that of the original  cleartext, so I wouldn&#x27;t expect zipping a transpiled program to compress better than compressing the original.</div><br/></div></div></div></div><div id="37910606" class="c"><input type="checkbox" id="c-37910606" checked=""/><div class="controls bullet"><span class="by">mgarciaisaia</span><span>|</span><a href="#37909064">prev</a><span>|</span><a href="#37909034">next</a><span>|</span><label class="collapse" for="c-37910606">[-]</label><label class="expand" for="c-37910606">[1 more]</label></div><br/><div class="children"><div class="content">Author here! I&#x27;ve just enabled Issues &amp; PRs in the repo if you want to chime in there.</div><br/></div></div><div id="37909068" class="c"><input type="checkbox" id="c-37909068" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#37909034">prev</a><span>|</span><a href="#37909419">next</a><span>|</span><label class="collapse" for="c-37909068">[-]</label><label class="expand" for="c-37909068">[2 more]</label></div><br/><div class="children"><div class="content">It might be that GZIP isn’t actually a good format with which to try to compress this data. I would think a compression algorithm that expects a rather large 8 byte character space wouldn’t be very suitable for a 4-bit space</div><br/><div id="37909762" class="c"><input type="checkbox" id="c-37909762" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37909068">parent</a><span>|</span><a href="#37909419">next</a><span>|</span><label class="collapse" for="c-37909762">[-]</label><label class="expand" for="c-37909762">[1 more]</label></div><br/><div class="children"><div class="content">I got a little nerd sniped by this.  I wrote a program that takes an input (&#x2F;usr&#x2F;share&#x2F;dict&#x2F;words on Debian 12, specifically), and compresses it with gzip and Zstandard, and also expands its binary representation (by replacing each 1 bit with A and each 0 bit with B) and compresses that.  The result is:<p><pre><code>    gzip    expgz   zstd    expzstd original
    263120  421278  252449  389004  985084
</code></pre>
So unlike in the article, expansion + compression is at least better than the original.  The ratios are (smaller # better; the opposite of how most compression algorithms advertise their performance, but what the original article used): 0.27, 0.42, 0.25, 0.39.  gzip and Zstandard aren&#x27;t a lot different in either case.  Whatever patterns that the Javascript weirdifier uses is less obvious to compression algorithms in general than just bitwise substitution.<p>Here&#x27;s the program if you want to look for bugs: <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;wwNXVzO2TO-" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;wwNXVzO2TO-</a></div><br/></div></div></div></div><div id="37909419" class="c"><input type="checkbox" id="c-37909419" checked=""/><div class="controls bullet"><span class="by">ShamelessC</span><span>|</span><a href="#37909068">prev</a><span>|</span><a href="#37910557">next</a><span>|</span><label class="collapse" for="c-37909419">[-]</label><label class="expand" for="c-37909419">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So, yeah - this isn&#x27;t a good idea. If the Weird transpiler only changes the encoding of each character with a really weird equivalent, it makes a lot of sense that it doesn&#x27;t compress better than the source one - the ideal scenario would be to compress the same.<p>If your results disagree with your premise in unsurprising and obvious ways - please start your article with that so I can stop reading it.</div><br/></div></div><div id="37909888" class="c"><input type="checkbox" id="c-37909888" checked=""/><div class="controls bullet"><span class="by">garba_dlm</span><span>|</span><a href="#37910557">prev</a><span>|</span><label class="collapse" for="c-37909888">[-]</label><label class="expand" for="c-37909888">[1 more]</label></div><br/><div class="children"><div class="content">and Golang is a clever way to build up an AI</div><br/></div></div></div></div></div></div></div></body></html>