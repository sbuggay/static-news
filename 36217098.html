<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686128463708" as="style"/><link rel="stylesheet" href="styles.css?v=1686128463708"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://felt.com/blog/svg-to-canvas-part-2-building-interactions">From SVG to Canvas – A new way of building interactions</a> <span class="domain">(<a href="https://felt.com">felt.com</a>)</span></div><div class="subtext"><span>kretaceous</span> | <span>47 comments</span></div><br/><div><div id="36221297" class="c"><input type="checkbox" id="c-36221297" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#36221890">next</a><span>|</span><label class="collapse" for="c-36221297">[-]</label><label class="expand" for="c-36221297">[5 more]</label></div><br/><div class="children"><div class="content">&gt; These InteractionHandlers are just objects satisfying a specific TypeScript interface. They’re not coupled to React or hooks or anything like that, which feels quite freeing, honestly. There’s no worrying about stale closures or dependencies or hooks rules - it really is just TypeScript.<p>This is a great example of &quot;fighting the framework&quot;. React + SVG got them from nothing to a working product. But then they had to rewrite completely to solve problems in the product because the framework no longer fit the product. I&#x27;ve seen this so many times.<p>But it&#x27;s hard for people to believe when they start out and choose the &quot;perfect&quot; framework for their product:<p>&quot;you will eventually have to rewrite your entire product because that&#x27;s easier than fighting the framework to make it do what you need&quot;<p>&quot;no, we won&#x27;t, <i>this</i> $framework is flexible enough to do whatever we need&quot;<p>&quot;OK, good luck&quot;<p>2 years later:<p>&quot;we&#x27;re rewriting the product completely because $framework wouldn&#x27;t let us do $thing&quot;<p>Not that I&#x27;m advocating for not using frameworks, just for people to realise that eventually (almost) everyone fights the framework and rewrites. And the more the framework does, the earlier the fight begins.</div><br/><div id="36224135" class="c"><input type="checkbox" id="c-36224135" checked=""/><div class="controls bullet"><span class="by">dirkc</span><span>|</span><a href="#36221297">parent</a><span>|</span><a href="#36223054">next</a><span>|</span><label class="collapse" for="c-36224135">[-]</label><label class="expand" for="c-36224135">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also seen the other side where the argument is:<p>&quot;we should be doing things correctly from the start&quot;<p>2 years later:<p>&quot;the maintenance of custom doesn&#x27;t deliver business value and makes recruitment and on-boarding increasingly difficult. We should rewrite in $framework since it&#x27;s well known, maintained and flexible enough to do whatever they need&quot;<p>...</div><br/><div id="36224343" class="c"><input type="checkbox" id="c-36224343" checked=""/><div class="controls bullet"><span class="by">sanitycheck</span><span>|</span><a href="#36221297">root</a><span>|</span><a href="#36224135">parent</a><span>|</span><a href="#36223054">next</a><span>|</span><label class="collapse" for="c-36224343">[-]</label><label class="expand" for="c-36224343">[1 more]</label></div><br/><div class="children"><div class="content">There have been a few occasions where this has led to (literally) years of extra maintenance work for me, as I patiently wait for a team of devs to replace my custom app with v2 using $wellKnownFramework. Sometimes that v2 is eventually abandoned and I&#x27;m contracted to build v3.</div><br/></div></div></div></div><div id="36223054" class="c"><input type="checkbox" id="c-36223054" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36221297">parent</a><span>|</span><a href="#36224135">prev</a><span>|</span><a href="#36221720">next</a><span>|</span><label class="collapse" for="c-36223054">[-]</label><label class="expand" for="c-36223054">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s unfortunate that coevolution like this usually lands in a very suboptimal start. If we tore it all down and started from what we knew we&#x27;d have much better things. Occasionally stuff like that happens, but it&#x27;s really hard to fight against the momentum of decades of shit</div><br/></div></div><div id="36221720" class="c"><input type="checkbox" id="c-36221720" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36221297">parent</a><span>|</span><a href="#36223054">prev</a><span>|</span><a href="#36221890">next</a><span>|</span><label class="collapse" for="c-36221720">[-]</label><label class="expand" for="c-36221720">[1 more]</label></div><br/><div class="children"><div class="content">Or, your stuck doing version upgrades of the framework before even getting to the fight.</div><br/></div></div></div></div><div id="36221890" class="c"><input type="checkbox" id="c-36221890" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#36221297">prev</a><span>|</span><a href="#36223602">next</a><span>|</span><label class="collapse" for="c-36221890">[-]</label><label class="expand" for="c-36221890">[9 more]</label></div><br/><div class="children"><div class="content">ctrl+f &quot;accessibility&quot; in part 2: zero results<p>ctrl+f &quot;accessibility&quot; in part 1: zero results<p>Does anyone care about digital access to content for disabled people ? Or about the ADA ?<p>Svg to canvas without any answer for accessibility is backwardness, plain and simple.<p>You are letting down anyone who&#x27;s deaf, blind or has trouble hearing or seeing, anyone who does not know how to read, has motor impairments, temporary or not and the older folks. Also screen translaters will not work on canvas.<p>Please follow the WCAG guidelines.</div><br/><div id="36224296" class="c"><input type="checkbox" id="c-36224296" checked=""/><div class="controls bullet"><span class="by">rikroots</span><span>|</span><a href="#36221890">parent</a><span>|</span><a href="#36223513">next</a><span>|</span><label class="collapse" for="c-36224296">[-]</label><label class="expand" for="c-36224296">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never used the product, but I did see this snippet in the article, which gives me a flicker of hope that the product does address some accessibility concerns:<p>&gt; One particularly nice aspect of this system is that key presses follow the same flow as pointer events, which is not how things work in the DOM. In the DOM, you usually bind key handlers globally, and pointer events per element. But here, we get all the benefits of stopping propagation centrally, which is a real help for adding keyboard shortcuts and modifier keys.</div><br/></div></div><div id="36223513" class="c"><input type="checkbox" id="c-36223513" checked=""/><div class="controls bullet"><span class="by">johncoltrane</span><span>|</span><a href="#36221890">parent</a><span>|</span><a href="#36224296">prev</a><span>|</span><a href="#36222392">next</a><span>|</span><label class="collapse" for="c-36223513">[-]</label><label class="expand" for="c-36223513">[1 more]</label></div><br/><div class="children"><div class="content">They are also letting down anyone who doesn&#x27;t speak English, anyone who doesn&#x27;t have a recent computer and decent internet, anyone who doesn&#x27;t want to execute JavaScript in their browser… and even anyone who has no interest in making maps.<p>Not everything is for everyone, get over it.</div><br/></div></div><div id="36222392" class="c"><input type="checkbox" id="c-36222392" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#36221890">parent</a><span>|</span><a href="#36223513">prev</a><span>|</span><a href="#36223787">next</a><span>|</span><label class="collapse" for="c-36222392">[-]</label><label class="expand" for="c-36222392">[1 more]</label></div><br/><div class="children"><div class="content">Genuinely asking, how do you make something like their map view accessible with so many objects and layers? I&#x27;d imagine you end up with a solution that exposes various content rectangles and ignores everything else, kind of how Google Maps does it.</div><br/></div></div><div id="36223787" class="c"><input type="checkbox" id="c-36223787" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#36221890">parent</a><span>|</span><a href="#36222392">prev</a><span>|</span><a href="#36223908">next</a><span>|</span><label class="collapse" for="c-36223787">[-]</label><label class="expand" for="c-36223787">[1 more]</label></div><br/><div class="children"><div class="content">Unless they have a legal requirement to provide product for disabled people, why would they care? It&#x27;s a huge investment for very little output, unless this product is specifically targeted.</div><br/></div></div><div id="36223908" class="c"><input type="checkbox" id="c-36223908" checked=""/><div class="controls bullet"><span class="by">azangru</span><span>|</span><a href="#36221890">parent</a><span>|</span><a href="#36223787">prev</a><span>|</span><a href="#36222369">next</a><span>|</span><label class="collapse" for="c-36223908">[-]</label><label class="expand" for="c-36223908">[3 more]</label></div><br/><div class="children"><div class="content">Tangential question: how does accessibility work in Google Docs after they&#x27;ve switched to canvas?<p>Or in Google Maps, which would be a much closer parallel?</div><br/><div id="36224003" class="c"><input type="checkbox" id="c-36224003" checked=""/><div class="controls bullet"><span class="by">TonyStr</span><span>|</span><a href="#36221890">root</a><span>|</span><a href="#36223908">parent</a><span>|</span><a href="#36222369">next</a><span>|</span><label class="collapse" for="c-36224003">[-]</label><label class="expand" for="c-36224003">[2 more]</label></div><br/><div class="children"><div class="content">While not directly related to your question, Google docs&#x27; switch to canvas broke my custom dark theme which I&#x27;d been maintaining for years, and several others were also using. This had been the main draw for me switching to Google docs in the first place and they took it away. I&#x27;d argue this is much less accessible as I can&#x27;t use the product at night. Ironically, I feel like I&#x27;ve experienced more bugs after the switch than before</div><br/><div id="36224160" class="c"><input type="checkbox" id="c-36224160" checked=""/><div class="controls bullet"><span class="by">rablackburn</span><span>|</span><a href="#36221890">root</a><span>|</span><a href="#36224003">parent</a><span>|</span><a href="#36222369">next</a><span>|</span><label class="collapse" for="c-36224160">[-]</label><label class="expand" for="c-36224160">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ironically, I feel like I&#x27;ve experienced more bugs after the switch than before<p>Not ironic, expected. When you do a refactor like this any good PM knows you’re creating a bunch of new bugs, and the ROI of the rewrite should consider this.<p>Unfortunately the way it goes most of the time is “ok, what if we’re really careful not to write any bugs? Then it’s all upside!”<p>…and now your dark theme is broken</div><br/></div></div></div></div></div></div><div id="36222369" class="c"><input type="checkbox" id="c-36222369" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#36221890">parent</a><span>|</span><a href="#36223908">prev</a><span>|</span><a href="#36223602">next</a><span>|</span><label class="collapse" for="c-36222369">[-]</label><label class="expand" for="c-36222369">[1 more]</label></div><br/><div class="children"><div class="content">A somewhat common approach is to maintain a parallel DOM structure for accessibility and keep it in sync with the data structures driving the canvas view.</div><br/></div></div></div></div><div id="36223164" class="c"><input type="checkbox" id="c-36223164" checked=""/><div class="controls bullet"><span class="by">_virtu</span><span>|</span><a href="#36223602">prev</a><span>|</span><a href="#36220976">next</a><span>|</span><label class="collapse" for="c-36223164">[-]</label><label class="expand" for="c-36223164">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been building a kinopio.club clone in Phoenix LiveView and the problems the author faces align with my experience from working with uis that require explicitly setting element position for the document. Having to manage all of the imperative handler logic was a huge pain on the JS side.
I had also given myself the limitation to not use React for more complex Phoenix Hooks. It’s all native document rendering with the only dependency being x-state.<p>Moving the mouse event handler logic out into a state machine was where I found myself going in comparison to this author’s approach. I was pretty tickled by how much more maintainable it had been than the first time I had implemented it. x-state was by no means a requirement but it had a handful of features I didn’t feel like building for the current project.<p>I can absolutely believe that this is worth the effort, especially considering the fact that the team works with maps so much. The mental model presented in the article would be far easier to grok when working in the codebase than having to deal with the somewhat tricky to remember Event api provided by browsers for these types of use cases.<p>Others are mentioning fighting the framework but this is still a pain without React. But of course adding in React on top of all of this would make it harder.</div><br/></div></div><div id="36220976" class="c"><input type="checkbox" id="c-36220976" checked=""/><div class="controls bullet"><span class="by">thomasfromcdnjs</span><span>|</span><a href="#36223164">prev</a><span>|</span><a href="#36221701">next</a><span>|</span><label class="collapse" for="c-36220976">[-]</label><label class="expand" for="c-36220976">[20 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve built diagram like tools several times, constantly umming and ahing between Canvas and SVG.<p>SVG seems to get you pretty far, but I always end up with Canvas in the long run.<p>Fun fact: Google docs is actually a canvas.</div><br/><div id="36221895" class="c"><input type="checkbox" id="c-36221895" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36220976">parent</a><span>|</span><a href="#36221260">next</a><span>|</span><label class="collapse" for="c-36221895">[-]</label><label class="expand" for="c-36221895">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Fun fact: Google docs is actually a canvas.</i><p>This is often said, and almost as often misunderstood as referring to what I call the “pure canvas” approach where you throw away almost everything the browser gives you and start from scratch. Some key points about Google Docs, just to clarify (I’m not <i>disagreeing</i>):<p>① Only its document area is rendered with canvas; its chrome is all still regular HTML.<p>② It still uses the browser for text shaping and painting, just not for macro-layout (breaking paragraph into lines, <i>&amp;c.</i>). (I expect that’s what this article’s subject would be doing too, but it’s part of common misunderstandings.)<p>③ Even things like scrolling are completely left to the browser: it’s not a single &lt;canvas&gt;, but a regular DOM scrolling area contains a bunch of &lt;canvas&gt; tiles.<p>④ The shunning of using HTML-with-contenteditable for the entire thing makes editing perform <i>very</i> badly (throughput, latency and jitter), and things like keyboard caret navigation behave non-natively in ways that will be very frustrating for people that actually use and care about this stuff (you get to relying on things behaving the same, like with touch typing, so things that get it wrong like Google Docs and LibreOffice (which gets it all <i>wildly</i> wrong) constantly grate).<p>⑤ They could just as easily use HTML or SVG rendering as &lt;canvas&gt; (while keeping their input and layout the same, so I mean still with all manual line breaks and that kind of thing). You’d get quite similar performance (though probably overall a little worse), and the same problems (since it’s the input layer that makes it slow and jittery—it just fundamentally can’t be as good in those ways as boring old contenteditable, given the current primitives). In fact, it’d mildly surprise me if they didn’t have an SVG or HTML renderer handy, or did in the past and could revive it to complete indistinguishable functionality within a day or two (even if hacky).<p>(I wrote a little more at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33863185" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33863185</a>.)</div><br/></div></div><div id="36221260" class="c"><input type="checkbox" id="c-36221260" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36220976">parent</a><span>|</span><a href="#36221895">prev</a><span>|</span><a href="#36222461">next</a><span>|</span><label class="collapse" for="c-36221260">[-]</label><label class="expand" for="c-36221260">[9 more]</label></div><br/><div class="children"><div class="content">Google Docs document canvas is a tool. Most of the chrome &amp; interface is html &amp; works great.<p>The switchover to canvas broke a ton of extensions. Chrome eventually went out &amp; built a custom api to help users deal with some of the massive loss of functionality that switching off high-level html to go use lowest level html caused. But that took a ton of effort from Google, &amp; the result is still a shadow of what was possible before.<p>IMO, do the right thing for user agency &amp; stick with higher level web stuff if you can, unless design truly compels it. Reinventing has many subtle pitfalls.</div><br/><div id="36221569" class="c"><input type="checkbox" id="c-36221569" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221260">parent</a><span>|</span><a href="#36222461">next</a><span>|</span><label class="collapse" for="c-36221569">[-]</label><label class="expand" for="c-36221569">[8 more]</label></div><br/><div class="children"><div class="content">&gt; IMO, do the right thing for user agency &amp; stick with higher level web stuff. Reinventing has many subtle pitfalls.<p>This is great advice 99% of the time. But the browser has two big pitfalls which hurt google docs:<p>1. Browser rich text editing events are famously awful and inconsistent on different browsers and platforms.<p>2. Google docs wants the same document to render exactly the same on all OS &#x2F; browser combinations. Thats not something that web browsers guarantee.<p>In this case, I understand google&#x27;s choice to build a custom renderer. I&#x27;m sure it was a massive effort for the team, but probably not quite as massive as working around all the browser quirks they were dealing with before. (From memory, before the canvas renderer, google docs ran their own rendering code then used CSS to absolutely position every single word in the document.)</div><br/><div id="36221735" class="c"><input type="checkbox" id="c-36221735" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221569">parent</a><span>|</span><a href="#36221965">next</a><span>|</span><label class="collapse" for="c-36221735">[-]</label><label class="expand" for="c-36221735">[4 more]</label></div><br/><div class="children"><div class="content">I spoke to the original creator of Google Docs (from before it was Google Docs, <a href="https:&#x2F;&#x2F;www.theverge.com&#x2F;2013&#x2F;7&#x2F;3&#x2F;4484000&#x2F;sam-schillace-interview-google-docs-creator-box" rel="nofollow">https:&#x2F;&#x2F;www.theverge.com&#x2F;2013&#x2F;7&#x2F;3&#x2F;4484000&#x2F;sam-schillace-inte...</a>) and he confirmed what you recall; they had to write their own text rendering code because the browser does not implement the behavior required by a word processor (one example: flowing text around an image)</div><br/><div id="36221935" class="c"><input type="checkbox" id="c-36221935" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221735">parent</a><span>|</span><a href="#36221965">next</a><span>|</span><label class="collapse" for="c-36221935">[-]</label><label class="expand" for="c-36221935">[3 more]</label></div><br/><div class="children"><div class="content">That was long before they switched to canvas rendering, too: they were still just using contenteditable, though potentially with mild layout augmentation with things like absolute positioning and sizing of things (I don’t know).<p>Flowing text around an image: the web has been able to do this for donkey’s years, it’s the float property. More recently, there’s the CSS shape-outside property that even lets you use non-rectangular crop: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;shape-outside" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;shape-outside</a>.</div><br/><div id="36222054" class="c"><input type="checkbox" id="c-36222054" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221935">parent</a><span>|</span><a href="#36221965">next</a><span>|</span><label class="collapse" for="c-36222054">[-]</label><label class="expand" for="c-36222054">[2 more]</label></div><br/><div class="children"><div class="content">IIRC float is just left or right, you can&#x27;t embed an image &quot;in the middle&quot; of text.  I&#x27;m no web expert and the conversation was a decade ago, so I&#x27;m sure something got warped in translation.</div><br/><div id="36222297" class="c"><input type="checkbox" id="c-36222297" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36222054">parent</a><span>|</span><a href="#36221965">next</a><span>|</span><label class="collapse" for="c-36222297">[-]</label><label class="expand" for="c-36222297">[1 more]</label></div><br/><div class="children"><div class="content">Ah, in the <i>middle</i>. Yeah, you still can’t do that. There was <a href="https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css3-exclusions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css3-exclusions&#x2F;</a> which let you do it, but it was only ever implemented in IE 10–Edge 18 (prefixed), and seems dead now.</div><br/></div></div></div></div></div></div></div></div><div id="36221965" class="c"><input type="checkbox" id="c-36221965" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221569">parent</a><span>|</span><a href="#36221735">prev</a><span>|</span><a href="#36222079">next</a><span>|</span><label class="collapse" for="c-36221965">[-]</label><label class="expand" for="c-36221965">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>2. Google docs wants the same document to render exactly the same on all OS &#x2F; browser combinations. Thats not something that web browsers guarantee.</i><p>Nor is it something Google Docs guarantees, since it still uses the browser for font shaping and rendering. The easiest way to demonstrate this is in Firefox, Settings → Fonts → Advanced → untick <i>Allow pages to choose their own fonts, instead of your selections above</i>, and Google Docs will layout and render the entire document using only your default font (most likely a serif). Not even doing a serif&#x2F;sans-serif&#x2F;monospace generic font fallback.<p>(I’ve had that unticked for almost a year and a half now: it makes the web <i>so</i> much better on average, with minimal damage, almost all on Google properties due to their Material Icons font’s stupid ligation technique.)</div><br/><div id="36223033" class="c"><input type="checkbox" id="c-36223033" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221965">parent</a><span>|</span><a href="#36222079">next</a><span>|</span><label class="collapse" for="c-36223033">[-]</label><label class="expand" for="c-36223033">[1 more]</label></div><br/><div class="children"><div class="content">Ok, sure - you got me. If you mess with obscure browser options, you will successfully change how google docs renders content. But I suspect all of the people who select that option would fit in one meeting room, with a sign out front from google which says &quot;WONTFIX&quot;.<p>One thing people <i>do</i> do all the time in word processors is mash enter until the next bit of content ends up at the top of the following page. If a user does that, then they print their document from a different computer, it should print correctly. The next content should appear exactly at the top of the next page. If the word processor does anything else, users will be frustrated and blame the software. Word and Docs both put in a ton of engineering effort to get this right.<p>(Educated users will insert a page break instead, but plenty of users don&#x27;t know about page breaks. They still expect their documents to render correctly.)</div><br/></div></div></div></div><div id="36222079" class="c"><input type="checkbox" id="c-36222079" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221569">parent</a><span>|</span><a href="#36221965">prev</a><span>|</span><a href="#36222461">next</a><span>|</span><label class="collapse" for="c-36222079">[-]</label><label class="expand" for="c-36222079">[1 more]</label></div><br/><div class="children"><div class="content">I have quite a lot of sympathy for Google, but I&#x27;d wager 90%+ of people heading down the Canvas path have really shoddy cases for why they&#x27;re doing it.<p>I&#x27;d also love to see more hybridization. With something like Figma, I both am sympathetic to their use of canvas. But I&#x27;d love it if they had a hybrid renderer that could also use HTML as well, with fixed position divs and HTML text. There used to be a slow but steady stream of blog posts on combining HTML and WebGL, some even with nice css3d transforms to make HTML act like a texture, but overall I don&#x27;t think we&#x27;ve seen much hardcore uptake or attempts.</div><br/></div></div></div></div></div></div><div id="36222461" class="c"><input type="checkbox" id="c-36222461" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36220976">parent</a><span>|</span><a href="#36221260">prev</a><span>|</span><a href="#36221049">next</a><span>|</span><label class="collapse" for="c-36222461">[-]</label><label class="expand" for="c-36222461">[2 more]</label></div><br/><div class="children"><div class="content">You start with SVG<p>Then you go to Canvas<p>Then you go to WebGL<p>Source: Early engineer at Lucidchart</div><br/><div id="36223361" class="c"><input type="checkbox" id="c-36223361" checked=""/><div class="controls bullet"><span class="by">thomasfromcdnjs</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36222461">parent</a><span>|</span><a href="#36221049">next</a><span>|</span><label class="collapse" for="c-36223361">[-]</label><label class="expand" for="c-36223361">[1 more]</label></div><br/><div class="children"><div class="content">aha love this</div><br/></div></div></div></div><div id="36221049" class="c"><input type="checkbox" id="c-36221049" checked=""/><div class="controls bullet"><span class="by">thrashh</span><span>|</span><a href="#36220976">parent</a><span>|</span><a href="#36222461">prev</a><span>|</span><a href="#36221198">next</a><span>|</span><label class="collapse" for="c-36221049">[-]</label><label class="expand" for="c-36221049">[1 more]</label></div><br/><div class="children"><div class="content">Same. Working around the issues with SVG sometimes takes as long as rewriting parts of SVG from scratch.<p>It’s not an SVG problem so much as Canvas and SVG are not reconciled into one bigger rendering system, so when you hit an edge case that requires breaking outside out of SVG, you have no path.</div><br/></div></div><div id="36221198" class="c"><input type="checkbox" id="c-36221198" checked=""/><div class="controls bullet"><span class="by">alixanderwang</span><span>|</span><a href="#36220976">parent</a><span>|</span><a href="#36221049">prev</a><span>|</span><a href="#36221701">next</a><span>|</span><label class="collapse" for="c-36221198">[-]</label><label class="expand" for="c-36221198">[6 more]</label></div><br/><div class="children"><div class="content">i&#x27;m building a diagramming tool (<a href="https:&#x2F;&#x2F;terrastruct.com" rel="nofollow">https:&#x2F;&#x2F;terrastruct.com</a>) and still umm and ah b&#x2F;t it.<p>I&#x27;m kind of waiting for webgpu to reach 95+% browser support before switching though.<p>If I do all the work of switching, SVG better not get gpu&#x2F;hardware-acceleration support the next day</div><br/><div id="36224163" class="c"><input type="checkbox" id="c-36224163" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221198">parent</a><span>|</span><a href="#36221588">next</a><span>|</span><label class="collapse" for="c-36224163">[-]</label><label class="expand" for="c-36224163">[1 more]</label></div><br/><div class="children"><div class="content">Nice! I found <a href="https:&#x2F;&#x2F;d2lang.com" rel="nofollow">https:&#x2F;&#x2F;d2lang.com</a> via your link, and thought it warranted a separate submission: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36224084" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36224084</a></div><br/></div></div><div id="36221588" class="c"><input type="checkbox" id="c-36221588" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221198">parent</a><span>|</span><a href="#36224163">prev</a><span>|</span><a href="#36221701">next</a><span>|</span><label class="collapse" for="c-36221588">[-]</label><label class="expand" for="c-36221588">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused... Figma can seemingly do all of this already, from a rendering perspective. And it&#x27;s outrageously performant. It&#x27;s one of the most performant web apps I&#x27;ve ever seen.<p>Why don&#x27;t you do exactly what Figma is doing?</div><br/><div id="36224383" class="c"><input type="checkbox" id="c-36224383" checked=""/><div class="controls bullet"><span class="by">rikroots</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221588">parent</a><span>|</span><a href="#36221669">next</a><span>|</span><label class="collapse" for="c-36224383">[-]</label><label class="expand" for="c-36224383">[1 more]</label></div><br/><div class="children"><div class="content">Figma is excellent at many things, but they struggle with accessibility. It&#x27;s been a year since they wrote a blog post about their accessibility efforts so I don&#x27;t know how far they&#x27;ve managed to solve the issues they identified - <a href="https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;a-step-forward-in-our-accessibility-efforts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;a-step-forward-in-our-accessibili...</a></div><br/></div></div><div id="36221669" class="c"><input type="checkbox" id="c-36221669" checked=""/><div class="controls bullet"><span class="by">avmich</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221588">parent</a><span>|</span><a href="#36224383">prev</a><span>|</span><a href="#36222293">next</a><span>|</span><label class="collapse" for="c-36221669">[-]</label><label class="expand" for="c-36221669">[1 more]</label></div><br/><div class="children"><div class="content">A long time ago a small startup used unusual tooling in the industry. The startup was small, but the tooling had some great qualities, which allowed the startup to compete with bigger teams feature for feature, spending less efforts to produce the same functionality as their industry peers. Eventually the startup had a successful exit, the founders become rich, and one of them even started sharing his experience in a rather systematic manner. Happy end.<p>Is it so that SVG requires to use all the features of it, or is it possible that you can mix and match, choosing what&#x27;s important now and what&#x27;s not, while benefiting from already existing SVG features? Is it possible that SVG followers don&#x27;t do something which SVG does for them? Aren&#x27;t there features, sufficiently aligned with SVG, which outperform directly working with other layers?</div><br/></div></div><div id="36222293" class="c"><input type="checkbox" id="c-36222293" checked=""/><div class="controls bullet"><span class="by">alixanderwang</span><span>|</span><a href="#36220976">root</a><span>|</span><a href="#36221588">parent</a><span>|</span><a href="#36221669">prev</a><span>|</span><a href="#36221701">next</a><span>|</span><label class="collapse" for="c-36222293">[-]</label><label class="expand" for="c-36222293">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to get as performant as Figma does, not as straightforward as a rendering medium switch. What if webgpu lets me get Figma performance with my little 6 person startup team without the massive engineering man-hours Figma has spent on performance?<p>Anyway, if it were high priority for us, we&#x27;d have done it already (switching to canvas&#x2F;webgl). But right now it feels like buying a Quest when the Vision Pro is coming soon.</div><br/></div></div></div></div></div></div></div></div><div id="36221701" class="c"><input type="checkbox" id="c-36221701" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#36220976">prev</a><span>|</span><a href="#36221757">next</a><span>|</span><label class="collapse" for="c-36221701">[-]</label><label class="expand" for="c-36221701">[1 more]</label></div><br/><div class="children"><div class="content">I gave up on interactive applications like this using web tech- Qt has the QGraphicsView framework which is far and away the best implementation I&#x27;ve seen so far in terms of programmability.  There is a (significant) learning curve, but basically you&#x27;re just learning how modern windowing systems work (and once you do, the browser model starts to seem awfully clumsy).<p>One of the crazy bits about QGraphicsView is that it provides not only simple primitives and the ability to make arbitrarily nested primitives, you can also render SVG, *and any Qt widget including a web browser) into the space.</div><br/></div></div><div id="36221757" class="c"><input type="checkbox" id="c-36221757" checked=""/><div class="controls bullet"><span class="by">talkingtab</span><span>|</span><a href="#36221701">prev</a><span>|</span><a href="#36221958">next</a><span>|</span><label class="collapse" for="c-36221757">[-]</label><label class="expand" for="c-36221757">[1 more]</label></div><br/><div class="children"><div class="content">React three fiber and React three drei? Not sure what you are trying to do, but I have been super impressed by what you can do with react-three-etc. Video textures, images, click through works well. And when you need web thingies - input boxes for example - adding in a html is simple. Built on top of the outstanding threejs library. Examples of what you can do:  <a href="https:&#x2F;&#x2F;docs.pmnd.rs&#x2F;react-three-fiber&#x2F;getting-started&#x2F;examples" rel="nofollow">https:&#x2F;&#x2F;docs.pmnd.rs&#x2F;react-three-fiber&#x2F;getting-started&#x2F;examp...</a> of what you can do. This one: <a href="https:&#x2F;&#x2F;codesandbox.io&#x2F;s&#x2F;drei-reflector-bfplr" rel="nofollow">https:&#x2F;&#x2F;codesandbox.io&#x2F;s&#x2F;drei-reflector-bfplr</a> is pretty cool and not much code.<p>After a few weeks with r3f I am trying to figure out whether I can just use a very small amount of css and react. I integrated webrtc video chat as a texture pretty easily. Surely there must be some gotcha, but I have not found it yet.</div><br/></div></div><div id="36221958" class="c"><input type="checkbox" id="c-36221958" checked=""/><div class="controls bullet"><span class="by">wly_cdgr</span><span>|</span><a href="#36221757">prev</a><span>|</span><a href="#36220961">next</a><span>|</span><label class="collapse" for="c-36221958">[-]</label><label class="expand" for="c-36221958">[1 more]</label></div><br/><div class="children"><div class="content">Canvas is a really nice vector API, very underappreciated precisely because of its elegant simplicity. Its problem is that, because it&#x27;s so straightforward and well-designed, people can&#x27;t easily use having had to work with it to pretend they are Big Brain.</div><br/></div></div><div id="36220961" class="c"><input type="checkbox" id="c-36220961" checked=""/><div class="controls bullet"><span class="by">nawgz</span><span>|</span><a href="#36221958">prev</a><span>|</span><a href="#36220663">next</a><span>|</span><label class="collapse" for="c-36220961">[-]</label><label class="expand" for="c-36220961">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested in Canvas - I write a lot of data viz in SVG. I find it to have lots of warts, but provide lots of value. I&#x27;m interested by this article and wish to challenge it too, here&#x27;s my thoughts.<p>Maybe I&#x27;m an idiot though - where is this library? I can&#x27;t find it on their GitHub or linked from the articles<p>&gt; In the SVG world, we use CSS z-index to place the DragBox at the back and the SelectionFrame at the front.<p>Not a great start IMO - SVGs don&#x27;t support z-index. The front-to-back ordering z-index influences in HTML is decided in SVG directly by the order in the HTML within the &lt;svg&gt; element (in reverse - later elements are &quot;on top&quot;). What they could mean to say, if this isn&#x27;t entirely inaccurate, is that &quot;we render multiple SVGs and arrange them with z-index&quot;, which... I also find strange. I don&#x27;t want to read their source code but I also don&#x27;t find this to be giving them huge credibility.<p>&gt; Performance<p>&gt; Having every element produce a whole load of DOM elements for React to manage becomes a problem for performance when every element attaches event handlers, has to manage their lifecycles, observe state, etc., etc.<p>My concerns are mounting. This is fundamentally the problem React solves, not one it creates.<p>The amount of layers they picture in their example is not huge. I had the target to get 60fps on a Graph with 1000 nodes + smart edge routing, and you can do lots of interactions in the graph - each node can be moved independently or in a group, selected, you can drag a background box to select objects geometrically intersecting, and you can create new connections with drag, you know - basics. Not sure how performance is impacting them at an order of magnitude less, unless they are struggling with React itself.<p>&gt; Interactivity Limitations<p>&gt; with the text taking up so much space it’s very easy to accidentally drag the text instead<p>&gt; This was a very longstanding bug<p>I interpret this as them saying &quot;the text background was not displayed to users, so while it appeared the mouse was over the polygon, it was actually over the text background, therefore the text was dragged&quot;. Seems to me hover state would give the user the hints they need here, but I look forward to the Canvas solution<p>&gt; Maintainability<p>Once again I really can&#x27;t help but interpret this as a weak handle on React.<p>Onto the solution.<p>&gt; The new system: per-state InteractionHandlers<p>Honestly, the fact they had to leave React to manage this once again speaks to bad React practices. Have they never heard of Context&#x2F;Provider?<p>&gt; The general idea is this: there are a lot of different things you can do in Felt, but at any given time, the number of things you can do is limited. If we can therefore define which interactions are active at any given time, and also manage the flow of events through the handlers we should be in a good place<p>Yes, this is good architecting. However, the only thing they describe here that piques my interest is this:<p>&gt; Here is the full sequence of events that an InteractionHandler can process, with the ability to break the chain at any point, and prevent other handlers in the stack from being called.<p>&gt; &lt;graph showing how mouse events are managed manually, enabling mouse movement to correlate to available mouse events&gt;<p>This is a big pain point in React - very difficult to manage onMouseDown separately from onClick. Usually I accomplished this by overloading onMouseDown and onMouseUp to call the actual dev-user-available action handlers, but their described result is more graceful.<p>&gt; Goal 1: Interactions should be decoupled from each other<p>&gt; Each interaction handler has no knowledge of any other. The knowledge about how to prevent “collisions” in interactions resides with the map of handlers and the manager.<p>Right, but why couldn&#x27;t this be done in React?<p>&gt; Goal 2: Interactions should be performant<p>&gt; Because there is only one handler per feature as opposed to a bunch of handlers per element, there is a lot less allocation of resources.<p>Sounds and looks cool, is the implication that there is only O(feature count) event listeners for the Canvas?<p>I&#x27;ll have to profile my library for this<p>&gt; Goal 3: Interactions should be decoupled from access control<p>&gt; Access control is now simply a case of writing a different list of interaction handlers for each access level. There’s no longer any isEditor code littered throughout<p>&gt; Goal 4: Interactions should be decoupled from rendering<p>Yikes. I think they really conflated bad architecture with React problems a lot in this article.<p>Alright though, I see some clear wins at the end:<p>&gt; Goal 5: Complex interactions should be achievable<p>&gt; &lt;video shows that text is interacted with not as a bounding rect but character polygons&gt;<p>This is a win, and one they obviously wanted. It&#x27;s probably true this isn&#x27;t possible with the DOM, unless you render each character individually as a polygon or something that would undoubtedly be insanely painful<p>&gt; Doing this with an element-centric approach is nigh-on impossible. There’s no way (as far as we know) to say to a DOM element: “receive clicks, but pass-through mousedowns and drags.”<p>I agree with this claim, but wish they would elaborate what these use cases look like.<p>&gt; OK, there are some hidden details there such as ...<p>&gt; we maintain a spatial index of our elements using rbush which we query for coarse intersections with the cursor before performing more accurate hit tests using Turf.js.<p>Right, this all sounds quite graceful, indeed it sounds a bit like implementing a graphics system. It sounds like it met some of their goals too, and enabled some long-desired features the DOM didn&#x27;t make possible.<p>But their criticisms of React &amp; SVG are really weak here, and it sounds to me like they never properly decided how the system should behave and what parts should interact in the DOM world, and their issues fell out of that.<p>I also think that you should really not talk so much about z-index with SVG unless you make it more clear how those things could even be related.<p>Overall, I think they had a great team that implemented a great solution that aligned with their end-goals, but the work they replaced doesn&#x27;t sound like it was even well-aligned with the framework it was implemented in, let alone their end goals. I would not agree with their recommendation to move to Canvas if SVG doesn&#x27;t &quot;feel right&quot; until you do more analysis of why your solution is failing and what options are available.</div><br/><div id="36221039" class="c"><input type="checkbox" id="c-36221039" checked=""/><div class="controls bullet"><span class="by">mch82</span><span>|</span><a href="#36220961">parent</a><span>|</span><a href="#36220663">next</a><span>|</span><label class="collapse" for="c-36221039">[-]</label><label class="expand" for="c-36221039">[1 more]</label></div><br/><div class="children"><div class="content">Nothing wrong with a long comment, but it might facilitate discussion to break your long comment up into a few top level comments.</div><br/></div></div></div></div><div id="36220663" class="c"><input type="checkbox" id="c-36220663" checked=""/><div class="controls bullet"><span class="by">zagrebian</span><span>|</span><a href="#36220961">prev</a><span>|</span><a href="#36222911">next</a><span>|</span><label class="collapse" for="c-36220663">[-]</label><label class="expand" for="c-36220663">[1 more]</label></div><br/><div class="children"><div class="content">What’s with all the &lt;p-inline&gt; tags in the text?</div><br/></div></div><div id="36222911" class="c"><input type="checkbox" id="c-36222911" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#36220663">prev</a><span>|</span><a href="#36221929">next</a><span>|</span><label class="collapse" for="c-36222911">[-]</label><label class="expand" for="c-36222911">[3 more]</label></div><br/><div class="children"><div class="content">It sounds like most of their problems were with using the browser SVG event handlers (or perhaps the framework).<p>They could have written their own event system for SVG (e.g. using event handlers on document), which would have fixed the gripes they blamed on SVG events. They wrote their own event system for canvas, so probably not much more difficulty in coding work?<p>Performance is the remaining issue that isn’t clear that SVG would meet. I assume SVG painting could be as fast as canvas painting. I am assuming if you attach no events to SVG elements, you remove the event performance issues (well, replace them with performance issues in your own custom event handlers, but no worse than canvas). Surely removing all the now unneeded SVG-grab-handle-elements (“DragBox”) that were only there to capture events would also improve performance (painting and event capture). Canvas is using imperative drawing primitives, and SVG can use composable primitives -  both can be rendered by GPU. Canvas updates (eg. during dragging) require heavier imperative updates, while SVG primitives can theoretically be offloaded to the GPU. I can’t guess performance differences and performance delta probably strongly depends on browser, driver, and GPU.<p>Assuming you write your own event handling stack:<p>&gt; the mouse only hits SVG elements inside their painted region<p>Fixed (as good as canvas)<p>&gt; we could use things like pointer-events to disable certain interactions at certain times<p>Unnecessary (plus lowers stress on rendering?)<p>&gt; Having every element produce a whole load of DOM elements for React to manage becomes a problem for performance when every element attaches event handlers, has to manage their lifecycles, observe state, etc., etc.<p>Fixed with document events<p>&gt; Interactivity limitations. With our SVG renderer, each element managed its own interactions, which made it impossible to drag elements that were underneath other elements. This is a surprisingly common when making complex maps.<p>Fixed with document events<p>&gt; Maintainability. However, with every element attaching its own interactions, there is a tendency for every interaction to know about every other, checking if it should be enabled or not.<p>Fixed with document events<p>&gt; Another maintainability issue is the proliferation of event.stopPropagation() calls in the code. These are to stop events bubbling up through the complex DOM structure and allowing other components to handle events.<p>Fixed with document events (equivalent difficulty to canvas).<p>When writing complex code you learn that stopPropagation() is evil. Writing code to avoid it requires skills. IMHO stopPropagation should never be in any complex codebase (or perhaps with rules to prevent errors).<p>&gt; We also have a few places where we have awkward setTimeout() calls<p>Oh my god, no! Terrible hack with terrible consequences, as they discovered. setTimeout() introduces very evil race-conditions, and testability issues. An alternative which isn’t much better is to use async to get microtasks, so at least you are not reordering events&#x2F;tasks. IMHO in any modern codebase setTimeout should be banned or extremely restricted when it is absolutely needed.<p>SUMMARY<p>Basically, it sounds like the team needs some more experienced GUI developers.<p>I would bet good money they are trading one set of problems for another, and ending up with a codebase that is less maintainable.<p>I can only hope the article is not written by the lead developer - heaven help them if it were.<p>Opinions are my 10c as a custom framework developer (admittedly only one product that was not as complex as a GUI editor - that is why the inexpert mistakes sound so painful to me - although I could also avoid and detect problems because it was my own framework: depending on a third party framework makes it a heap harder to fix systematic faults).</div><br/><div id="36223537" class="c"><input type="checkbox" id="c-36223537" checked=""/><div class="controls bullet"><span class="by">hicksyfern</span><span>|</span><a href="#36222911">parent</a><span>|</span><a href="#36221929">next</a><span>|</span><label class="collapse" for="c-36223537">[-]</label><label class="expand" for="c-36223537">[2 more]</label></div><br/><div class="children"><div class="content">Author here.<p>I know this is the orange site and we have to expect this type of comment, but still…<p>I’ve been building software for more than 20 years, and using React since it came out.<p>You’re right that this event handling system isn’t exclusive to canvas. But then I’m not sure if you read the first part of the article where we talk about the other big reason: performance.<p>Your assertions that setTimeouts should be banned show immaturity. There are some cases where certain browsers do things in a different order and you really are required to use a hack like that.<p>You also neglect the fact (and this also points to your immaturity) that products are built by a number of people over a long period of time, with different constraints on them as things change.<p>The SVG approach was done for good reasons and the code made sense for what it was for initially. Then things got more complex and people started making more complex maps.<p>What we also found is that the complexity of maps people made increases with our performance gains: the faster the app is, the more people do with it.<p>I haven’t got time to go into everything either in the articles or certainly this reply, but I’d ask you to have a look at yourself and decide if you really want to be That Guy on HN.</div><br/><div id="36224075" class="c"><input type="checkbox" id="c-36224075" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#36222911">root</a><span>|</span><a href="#36223537">parent</a><span>|</span><a href="#36221929">next</a><span>|</span><label class="collapse" for="c-36224075">[-]</label><label class="expand" for="c-36224075">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I should not have been so inflammatory and I should have limited my comments to where I have deep experience.<p>The comments on preventDefault() and setTimeout() in particular repeat my own hard-won experiences: it is unfortunate you had to experience the same pain.<p>In the previous article, maybe the first third is you fighting your framework, which is admittedly what happens to us all if we are on the bleeding edge with performance issues. Certainly you are not the first team to find that canvas is a better solution.<p>In the first article you say “whenever the element’s coordinates or the viewport changed, we would re-render the element”, and you go on to talk about SVG versus canvas. HOWEVER it is impossible to tell whether your underlying performance problems actually stem from SVG (or SVG+events, or SVG+React). I can believe that canvas is more performant and more predictable, but your first article lacks enough detail to actually <i>blame</i> SVG. DOM changes, React, JavaScript could and probably did have severe impact on overall performance. That was the point I tried to make (admittedly, very poorly, since it isn’t clear you could avoid DOM changes in particular).<p>My main gripe with your second article was that you were concentrating on problems to do with SVG events and React - a problem that you resolved with your own event stack on canvas. That solution could have worked for SVG, although as you wrote in your first article, would not resolve your performance problems when painting.<p>&gt; Your assertions that setTimeouts should be banned show immaturity. There are some cases where certain browsers do things in a different order and you really are required to use a hack like that.<p>I guess I had that coming, but I stand by the statement. I learnt about setTimeout(0) caused-problems when working with DHTML controls (pre-frameworks) and frameworks that had nasty heisenbugs: intermittent hard-to-reproduce bugs that would surface because of events racing timeouts. One reason for writing a custom framework was that it was more reliable for users than depending on code that was out of our control: just the same as you are writing about. The framework KendoUI had been chosen by another at one point, and it was particularly troublesome for me. I believe using setTimeout() to avoid browser bugs is diabolical (or framework bugs even worse), because all too often you end up with further troubles that can be extremely hard to reproduce or diagnose. I worked hard to avoid setTimeout(), replumbing code at times, but it virtually always could be avoided with enough work (especially with complete control over event handlers). I stand by “setTimeout should be banned or extremely restricted when it is absolutely needed” because setTimeout(0) is a plaster that too many developers use to paste over cracks. Yes, browsers sometimes force us to accept the ugliest of hack solutions, to achieve some usability goal or avoid some browser bug.<p>All the best. Without a doubt you are far more experienced than I in this area, and certainly you have had a ton of experience wrestling with canvas versus SVG, and I certainly appreciate your article about how you won using canvas. Fighting performance problems in browsers requires a certain intransigence and flexibility, and I feel your pain and your glory from my own past experiences doing the same.<p>(Edited to add extra depth and details). I think that I was so skeptical because the articles lack many technical details that compare SVG performance versus canvas. It compares a React+SVG codebase, with a rewritten canvas codebase. I can believe that SVG is worse than canvas, but neither article has much that is convincing on that point except that the rewrite was successful (which is admittedly a good prior that canvas is better). it is possible you are too quick to dismiss the experience of others. Background: I was nearly 100% focused on front end work, mostly heavy DOM&#x2F;JavaScript from 2006 for a bit over a decade; but I have worked in a variety of software dev roles for a few decades (embedded, DB, client-server, Windows apps, front-end, POS, plus other random bits). I can definitely say I am well above average at writing reliable, performant, usable code (maybe due to my embedded programming background?).</div><br/></div></div></div></div></div></div><div id="36221929" class="c"><input type="checkbox" id="c-36221929" checked=""/><div class="controls bullet"><span class="by">jgalt212</span><span>|</span><a href="#36222911">prev</a><span>|</span><label class="collapse" for="c-36221929">[-]</label><label class="expand" for="c-36221929">[1 more]</label></div><br/><div class="children"><div class="content">Has anyone tried using canvas to stymie scrapers?</div><br/></div></div></div></div></div></div></div></body></html>