<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696669263483" as="style"/><link rel="stylesheet" href="styles.css?v=1696669263483"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.bittacklr.be/the-workflow-pattern.html">The Workflow Pattern</a> <span class="domain">(<a href="https://blog.bittacklr.be">blog.bittacklr.be</a>)</span></div><div class="subtext"><span>kiyanwang</span> | <span>31 comments</span></div><br/><div><div id="37797475" class="c"><input type="checkbox" id="c-37797475" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37798029">next</a><span>|</span><label class="collapse" for="c-37797475">[-]</label><label class="expand" for="c-37797475">[12 more]</label></div><br/><div class="children"><div class="content">The existence of workflow DSLs seems like a symptom of a systemic weakness in common programming languages.<p>We use languages best suited to writing Windows GUIs or Linux kernels to implement business rules — and then we act surprised when we have to invent an entire language and runtime to solve simple business problems.<p>One missing feature in typical languages is the native ability to have a computation frozen in the middle of a function call and then defrosted and continue as if nothing had happened. The low-level mechanisms are often available already — such as object serialisation — but these primitives never support the serialisation of a call stack or an in-flight computation.<p>We even have compilers that can split up and restructure an async function into a heap object and an associated state machine!<p>What’s the difference between an async function that is <i>awaiting</i> a slow HTTP call and an async function <i>awaiting</i> a long-running workflow step? Only that the state machine of the latter is persisted to storage instead of the heap!<p>I always thought it was a bit silly that the async mechanism in modern languages is so myopic and single-purpose. These kinds of high level language transformations ought to be extensible and pluggable so that we could write workflows in a proper programming language and have it look like normal code except for the occasional “await” keyword.<p>PS: The same philosophy could be applied to Java Loom style async programming where threads could be marked as eligible for hibernation, in which case they would be restricted to using data types that can be safely round-tripped by the serialiser.</div><br/><div id="37798223" class="c"><input type="checkbox" id="c-37798223" checked=""/><div class="controls bullet"><span class="by">kodablah</span><span>|</span><a href="#37797475">parent</a><span>|</span><a href="#37797800">next</a><span>|</span><label class="collapse" for="c-37798223">[-]</label><label class="expand" for="c-37798223">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I always thought it was a bit silly that the async mechanism in modern languages is so myopic and single-purpose. These kinds of high level language transformations ought to be extensible and pluggable so that we could write workflows in a proper programming language and have it look like normal code except for the occasional “await” keyword.<p>This is how Temporal works. For example, in Python the async event loop is replaced by a durable event loop [0], the JS promises become durable promises, .NET tasks become durable via a custom scheduler, etc. Granted it doesn&#x27;t serialize the stack, it uses event sourcing almost exactly like the article describes, and therefore requires deterministic code for replaying. From the dev POV, it looks like any code can just be frozen in the middle of a function and magically resumed elsewhere.<p>0 - <a href="https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;durable-distributed-asyncio-event-loop" rel="nofollow noreferrer">https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;durable-distributed-asyncio-event-l...</a><p>(disclaimer, I work at Temporal and have written some of these distributed coroutine impls)</div><br/></div></div><div id="37797800" class="c"><input type="checkbox" id="c-37797800" checked=""/><div class="controls bullet"><span class="by">vb-8448</span><span>|</span><a href="#37797475">parent</a><span>|</span><a href="#37798223">prev</a><span>|</span><a href="#37797753">next</a><span>|</span><label class="collapse" for="c-37797800">[-]</label><label class="expand" for="c-37797800">[2 more]</label></div><br/><div class="children"><div class="content">Workflows engines are not just about deferring a http call or a specific language.<p>They are a generic way to run some background process that doesn&#x27;t need too much human interaction and can be coded in any language. If you need to orchestrate tens of thousands of tasks, you will beg for a DSL and some kind of interface to monitor things.</div><br/><div id="37798051" class="c"><input type="checkbox" id="c-37798051" checked=""/><div class="controls bullet"><span class="by">manvillej</span><span>|</span><a href="#37797475">root</a><span>|</span><a href="#37797800">parent</a><span>|</span><a href="#37797753">next</a><span>|</span><label class="collapse" for="c-37798051">[-]</label><label class="expand" for="c-37798051">[1 more]</label></div><br/><div class="children"><div class="content">I feel like awaiting some human interaction is one of my most common requests for workflows. await some approval or some manual task that can&#x27;t be automated, etc.<p>honestly, when working with some new archaic system, the ability to insert manual tasks is invaluable for an early deployment</div><br/></div></div></div></div><div id="37797753" class="c"><input type="checkbox" id="c-37797753" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#37797475">parent</a><span>|</span><a href="#37797800">prev</a><span>|</span><a href="#37798080">next</a><span>|</span><label class="collapse" for="c-37797753">[-]</label><label class="expand" for="c-37797753">[5 more]</label></div><br/><div class="children"><div class="content">The missing feature you&#x27;re describing is monads. They can essentially be a first-class abstraction for computation (among other things). They can represent synchronous computations, computations that can be suspended&#x2F;resumed, computations that might fail with a particular type of exception, or anything in between.</div><br/><div id="37798262" class="c"><input type="checkbox" id="c-37798262" checked=""/><div class="controls bullet"><span class="by">Karrot_Kream</span><span>|</span><a href="#37797475">root</a><span>|</span><a href="#37797753">parent</a><span>|</span><a href="#37798080">next</a><span>|</span><label class="collapse" for="c-37798262">[-]</label><label class="expand" for="c-37798262">[4 more]</label></div><br/><div class="children"><div class="content">This is one way to structure it but not the only. Scheme&#x27;s call-with-current-continuation comes to mind here.</div><br/><div id="37799871" class="c"><input type="checkbox" id="c-37799871" checked=""/><div class="controls bullet"><span class="by">alexisread</span><span>|</span><a href="#37797475">root</a><span>|</span><a href="#37798262">parent</a><span>|</span><a href="#37798788">next</a><span>|</span><label class="collapse" for="c-37799871">[-]</label><label class="expand" for="c-37799871">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t think callCC can do multiple resumptions?
DDBinding certainly can, and can do partial environment closures so you can migrate a process to a different machine as well:
<a href="https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;papers&#x2F;DDBinding.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;papers&#x2F;DDBinding.pdf</a><p>The above is succinctly implemented in wat: <a href="https:&#x2F;&#x2F;github.com&#x2F;manuel&#x2F;wat-js">https:&#x2F;&#x2F;github.com&#x2F;manuel&#x2F;wat-js</a> (also see forks for more documented versions).</div><br/></div></div><div id="37798788" class="c"><input type="checkbox" id="c-37798788" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#37797475">root</a><span>|</span><a href="#37798262">parent</a><span>|</span><a href="#37799871">prev</a><span>|</span><a href="#37798080">next</a><span>|</span><label class="collapse" for="c-37798788">[-]</label><label class="expand" for="c-37798788">[2 more]</label></div><br/><div class="children"><div class="content">One really nifty use case of continuations is the Seaside Smalltalk web framework [1]. It implements stateful request&#x2F;response conversations with Smalltalk&#x27;s ability to capture and serialize continuations.<p>Continuation-based web frameworks are really nifty, but have potential scaling bottlenecks. IIRC HN originally used some type of continuation web framework with Arc, but ran into scaling and caching headaches. Dunno how it works these days.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Seaside_(software)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Seaside_(software)</a></div><br/><div id="37798829" class="c"><input type="checkbox" id="c-37798829" checked=""/><div class="controls bullet"><span class="by">codesnik</span><span>|</span><a href="#37797475">root</a><span>|</span><a href="#37798788">parent</a><span>|</span><a href="#37798080">next</a><span>|</span><label class="collapse" for="c-37798829">[-]</label><label class="expand" for="c-37798829">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know it can serialize continuation! I always thought that with seaside you have to run a single server, and any reboot would just kill the state.</div><br/></div></div></div></div></div></div></div></div><div id="37798080" class="c"><input type="checkbox" id="c-37798080" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#37797475">parent</a><span>|</span><a href="#37797753">prev</a><span>|</span><a href="#37798029">next</a><span>|</span><label class="collapse" for="c-37798080">[-]</label><label class="expand" for="c-37798080">[3 more]</label></div><br/><div class="children"><div class="content">The async&#x2F;await stuff in JavaScript, at least, is supported by the “generators” feature, which does let you effectively “pause” execution of a function, retaining its state. You can then yield to that state to continue executing</div><br/><div id="37799458" class="c"><input type="checkbox" id="c-37799458" checked=""/><div class="controls bullet"><span class="by">vanviegen</span><span>|</span><a href="#37797475">root</a><span>|</span><a href="#37798080">parent</a><span>|</span><a href="#37798029">next</a><span>|</span><label class="collapse" for="c-37799458">[-]</label><label class="expand" for="c-37799458">[2 more]</label></div><br/><div class="children"><div class="content">Sure, but would you still be able to resume that function 2 weeks later, after 5 process restarts due to code deploys and on a different server?</div><br/><div id="37800049" class="c"><input type="checkbox" id="c-37800049" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#37797475">root</a><span>|</span><a href="#37799458">parent</a><span>|</span><a href="#37798029">next</a><span>|</span><label class="collapse" for="c-37800049">[-]</label><label class="expand" for="c-37800049">[1 more]</label></div><br/><div class="children"><div class="content">CRIU can apparently do that with whole processes: <a href="https:&#x2F;&#x2F;criu.org&#x2F;Main_Page" rel="nofollow noreferrer">https:&#x2F;&#x2F;criu.org&#x2F;Main_Page</a><p>Found a link to it from telefork:  <a href="https:&#x2F;&#x2F;thume.ca&#x2F;2020&#x2F;04&#x2F;18&#x2F;telefork-forking-a-process-onto-a-different-computer&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;thume.ca&#x2F;2020&#x2F;04&#x2F;18&#x2F;telefork-forking-a-process-onto-...</a></div><br/></div></div></div></div></div></div></div></div><div id="37798029" class="c"><input type="checkbox" id="c-37798029" checked=""/><div class="controls bullet"><span class="by">abrgr</span><span>|</span><a href="#37797475">prev</a><span>|</span><a href="#37795063">next</a><span>|</span><label class="collapse" for="c-37798029">[-]</label><label class="expand" for="c-37798029">[2 more]</label></div><br/><div class="children"><div class="content">Modeling workflows as state machines is incredibly powerful.<p>In addition to everything the author mentioned, the constraints of state machines allow a workflow platform to provide a ton of additional guarantees and capabilities around consistency, state propagation, reliable timers, inter-instance messaging, etc.<p>We built our workflow execution platform [1] around state machines and we&#x27;ve seen great results. We find our workflow code is incredibly simple and easy to understand.<p>[1] <a href="https:&#x2F;&#x2F;www.statebacked.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.statebacked.dev</a></div><br/><div id="37798201" class="c"><input type="checkbox" id="c-37798201" checked=""/><div class="controls bullet"><span class="by">manvillej</span><span>|</span><a href="#37798029">parent</a><span>|</span><a href="#37795063">next</a><span>|</span><label class="collapse" for="c-37798201">[-]</label><label class="expand" for="c-37798201">[1 more]</label></div><br/><div class="children"><div class="content">this is exactly how I go about re-architecting overgrown workflows. reduce the workflow to a state machine. It takes forever to untangle what they are wanting to do and what they are doing, but the result is always a more robust solution.<p>the other benefit of a statemachine is the ability to accurately determine what parts can be collapsed into subworkflows which allows for reuse, replacement, or general modification</div><br/></div></div></div></div><div id="37795063" class="c"><input type="checkbox" id="c-37795063" checked=""/><div class="controls bullet"><span class="by">jusonchan81</span><span>|</span><a href="#37798029">prev</a><span>|</span><a href="#37799969">next</a><span>|</span><label class="collapse" for="c-37795063">[-]</label><label class="expand" for="c-37795063">[3 more]</label></div><br/><div class="children"><div class="content">One of my favorite workflow engines that has a really simple way to do things was not listed here, so I&#x27;ll call it out - Netflix Conductor (<a href="https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;conductor">https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;conductor</a>).<p>Its capabilities comes to light when you model really complex workflows and one real value is how its all very visual not just during modeling but when running it. The history remains visible and you can even see how the whole flow evolved.</div><br/><div id="37795967" class="c"><input type="checkbox" id="c-37795967" checked=""/><div class="controls bullet"><span class="by">pid-1</span><span>|</span><a href="#37795063">parent</a><span>|</span><a href="#37797708">next</a><span>|</span><label class="collapse" for="c-37795967">[-]</label><label class="expand" for="c-37795967">[1 more]</label></div><br/><div class="children"><div class="content">My company has 200+ DAGs on Airflow, so that ship has sailed for me.<p>That said, Conductor looks really cool, thanks for sharing.</div><br/></div></div><div id="37797708" class="c"><input type="checkbox" id="c-37797708" checked=""/><div class="controls bullet"><span class="by">jonnycoder</span><span>|</span><a href="#37795063">parent</a><span>|</span><a href="#37795967">prev</a><span>|</span><a href="#37799969">next</a><span>|</span><label class="collapse" for="c-37797708">[-]</label><label class="expand" for="c-37797708">[1 more]</label></div><br/><div class="children"><div class="content">I recently created some Netflix Conductor workflows with Python workers and found it pretty good. Using a fork&#x2F;join to kick off sub workflows was pretty easy.
It definitely shows runtime variable data much better than Camunda.</div><br/></div></div></div></div><div id="37799969" class="c"><input type="checkbox" id="c-37799969" checked=""/><div class="controls bullet"><span class="by">alexisread</span><span>|</span><a href="#37795063">prev</a><span>|</span><a href="#37797487">next</a><span>|</span><label class="collapse" for="c-37799969">[-]</label><label class="expand" for="c-37799969">[1 more]</label></div><br/><div class="children"><div class="content">One of the things I never see, is workflow integration with logging&#x2F;tracing. For event-sourcing, surely the log is the best port of call? Does anyone have a pattern around this, esp wrt Clickhouse integration?</div><br/></div></div><div id="37797487" class="c"><input type="checkbox" id="c-37797487" checked=""/><div class="controls bullet"><span class="by">cgio</span><span>|</span><a href="#37799969">prev</a><span>|</span><a href="#37796379">next</a><span>|</span><label class="collapse" for="c-37797487">[-]</label><label class="expand" for="c-37797487">[1 more]</label></div><br/><div class="children"><div class="content">The article is quite thorough and I enjoyed it as it reminded me of my forays in the domain. One nook in this domain, I never managed to investigate in the depth I would like is the Kinetic Rules Language [0] which makes the connection to complex event processing more pronounced.<p>CEP is not trendy, which is probably because of history and traditional implementations but I think it deserves a good look.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Picolab&#x2F;pico-engine">https:&#x2F;&#x2F;github.com&#x2F;Picolab&#x2F;pico-engine</a> is an implementation of the KRL</div><br/></div></div><div id="37796379" class="c"><input type="checkbox" id="c-37796379" checked=""/><div class="controls bullet"><span class="by">jdeaton</span><span>|</span><a href="#37797487">prev</a><span>|</span><a href="#37796263">next</a><span>|</span><label class="collapse" for="c-37796379">[-]</label><label class="expand" for="c-37796379">[8 more]</label></div><br/><div class="children"><div class="content">One of the biggest issues I&#x27;ve observed with workflow systems is an inability to get return values from each subprocess and then decide based on those which subprocesses to instantiate next. It always seems like the workflow execution graph is static in my experience. Is that correct?</div><br/><div id="37798672" class="c"><input type="checkbox" id="c-37798672" checked=""/><div class="controls bullet"><span class="by">jrop</span><span>|</span><a href="#37796379">parent</a><span>|</span><a href="#37796538">next</a><span>|</span><label class="collapse" for="c-37798672">[-]</label><label class="expand" for="c-37798672">[1 more]</label></div><br/><div class="children"><div class="content">At a prior company we just wrote our own custom workflow engine which was basically a DAG processor where each node called some code.  Of course, the code called could modify the DAG in place and accomplish exactly what you&#x27;re describing.  It worked quite well but we didn&#x27;t polish it as much as we could have. I&#x27;ve been wanting to do a clean-room reimplementation as of late just because I miss certain things about it.</div><br/></div></div><div id="37796538" class="c"><input type="checkbox" id="c-37796538" checked=""/><div class="controls bullet"><span class="by">brad0</span><span>|</span><a href="#37796379">parent</a><span>|</span><a href="#37798672">prev</a><span>|</span><a href="#37797897">next</a><span>|</span><label class="collapse" for="c-37796538">[-]</label><label class="expand" for="c-37796538">[2 more]</label></div><br/><div class="children"><div class="content">That sounds very similar to AWS Step Functions to me. You define a workflow graph in JSON, then run the workflow and hand out subprocesses to lambdas etc.</div><br/><div id="37797908" class="c"><input type="checkbox" id="c-37797908" checked=""/><div class="controls bullet"><span class="by">8note</span><span>|</span><a href="#37796379">root</a><span>|</span><a href="#37796538">parent</a><span>|</span><a href="#37797897">next</a><span>|</span><label class="collapse" for="c-37797908">[-]</label><label class="expand" for="c-37797908">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve definitely seen workflows written as single step graphs, where the output is opening a new workflow with a different single step<p>It was hard to read and understand</div><br/></div></div></div></div><div id="37797897" class="c"><input type="checkbox" id="c-37797897" checked=""/><div class="controls bullet"><span class="by">8note</span><span>|</span><a href="#37796379">parent</a><span>|</span><a href="#37796538">prev</a><span>|</span><a href="#37796716">next</a><span>|</span><label class="collapse" for="c-37797897">[-]</label><label class="expand" for="c-37797897">[2 more]</label></div><br/><div class="children"><div class="content">Why would you want to rewrite the code of the workflow during execution, vs defining that logic upfront?</div><br/><div id="37798110" class="c"><input type="checkbox" id="c-37798110" checked=""/><div class="controls bullet"><span class="by">jdeaton</span><span>|</span><a href="#37796379">root</a><span>|</span><a href="#37797897">parent</a><span>|</span><a href="#37796716">next</a><span>|</span><label class="collapse" for="c-37798110">[-]</label><label class="expand" for="c-37798110">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like asking why anyone would want to use an if statement. &quot;Why would you want to change which instructions that get executed during the program? Just decide up front!&quot;. Because the decision cannot be made ahead of time.</div><br/></div></div></div></div><div id="37796716" class="c"><input type="checkbox" id="c-37796716" checked=""/><div class="controls bullet"><span class="by">sisve</span><span>|</span><a href="#37796379">parent</a><span>|</span><a href="#37797897">prev</a><span>|</span><a href="#37797155">next</a><span>|</span><label class="collapse" for="c-37796716">[-]</label><label class="expand" for="c-37796716">[1 more]</label></div><br/><div class="children"><div class="content">Maybe before, but i feel that is not a problem anymore. 
Windmill.dev solves this with easee. Very good UI on top of the workflow engine.</div><br/></div></div><div id="37797155" class="c"><input type="checkbox" id="c-37797155" checked=""/><div class="controls bullet"><span class="by">noselasd</span><span>|</span><a href="#37796379">parent</a><span>|</span><a href="#37796716">prev</a><span>|</span><a href="#37796263">next</a><span>|</span><label class="collapse" for="c-37797155">[-]</label><label class="expand" for="c-37797155">[1 more]</label></div><br/><div class="children"><div class="content">The couple workflow engines I&#x27;ve used supports that. It sounds crazy to not support something that obvious</div><br/></div></div></div></div><div id="37796263" class="c"><input type="checkbox" id="c-37796263" checked=""/><div class="controls bullet"><span class="by">cannonpalms</span><span>|</span><a href="#37796379">prev</a><span>|</span><label class="collapse" for="c-37796263">[-]</label><label class="expand" for="c-37796263">[3 more]</label></div><br/><div class="children"><div class="content">I built a feature of our platform on top of Apache NiFi[1] and had a great experience. I would have preferred a non-JVM language, as that&#x27;d have been easier for us in a containerized environment, but I have no complaints about NiFi otherwise.</div><br/><div id="37797365" class="c"><input type="checkbox" id="c-37797365" checked=""/><div class="controls bullet"><span class="by">claytonjy</span><span>|</span><a href="#37796263">parent</a><span>|</span><label class="collapse" for="c-37797365">[-]</label><label class="expand" for="c-37797365">[2 more]</label></div><br/><div class="children"><div class="content">Interesting; for me NiFi is tied with Airflow as my most-hated software I&#x27;ve had to use professionally.<p>This was a few years ago but NiFi only supported editing the DAG from a GUI; you could store the resulting XML in git, but no human could read or edit it. Python steps were stuck on Python 2.6 or 2.7. Hard to debug pileups. Is it better now?</div><br/><div id="37799934" class="c"><input type="checkbox" id="c-37799934" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#37796263">root</a><span>|</span><a href="#37797365">parent</a><span>|</span><label class="collapse" for="c-37799934">[-]</label><label class="expand" for="c-37799934">[1 more]</label></div><br/><div class="children"><div class="content">NiFi sounds a lot like Camunda, which is awful.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>