<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717405251202" as="style"/><link rel="stylesheet" href="styles.css?v=1717405251202"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/francisrstokes/githublog/blob/main/2024%2F5%2F29%2Ffast-inverse-sqrt.md">Everything I know about the fast inverse square root algorithm</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>atan2</span> | <span>63 comments</span></div><br/><div><div id="40556917" class="c"><input type="checkbox" id="c-40556917" checked=""/><div class="controls bullet"><span class="by">johndough</span><span>|</span><a href="#40558501">next</a><span>|</span><label class="collapse" for="c-40556917">[-]</label><label class="expand" for="c-40556917">[7 more]</label></div><br/><div class="children"><div class="content">If your computer was built after 1999, it probably supports the SSE instruction set. It contains the _mm_rsqrt_ps instruction, which is faster and will give you four reciprocal square roots at once: <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;docs&#x2F;intrinsics-guide&#x2F;index.html#text=_mm_rsqrt_ps&amp;ig_expand=5642&amp;ssetechs=SSE" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;docs&#x2F;intrinsics-guid...</a><p>That being said, the techniques discussed here are not totally irrelevant (yet). There still exists some hardware with fast instructions for float&#x2F;int conversion, but lacking rsqrt, sqrt, pow, log instructions, which can all be approximated with this nice trick.</div><br/><div id="40558934" class="c"><input type="checkbox" id="c-40558934" checked=""/><div class="controls bullet"><span class="by">khangaroo</span><span>|</span><a href="#40556917">parent</a><span>|</span><a href="#40558055">next</a><span>|</span><label class="collapse" for="c-40558934">[-]</label><label class="expand" for="c-40558934">[1 more]</label></div><br/><div class="children"><div class="content">The SSE float reciprocal instructions have slightly different results between Intel and AMD, which can be a source of headaches for those expecting deterministic results between PCs. (see <a href="https:&#x2F;&#x2F;robert.ocallahan.org&#x2F;2021&#x2F;09&#x2F;rr-trace-portability-diverging-behavior.html" rel="nofollow">https:&#x2F;&#x2F;robert.ocallahan.org&#x2F;2021&#x2F;09&#x2F;rr-trace-portability-di...</a>)</div><br/></div></div><div id="40558055" class="c"><input type="checkbox" id="c-40558055" checked=""/><div class="controls bullet"><span class="by">bnprks</span><span>|</span><a href="#40556917">parent</a><span>|</span><a href="#40558934">prev</a><span>|</span><a href="#40558830">next</a><span>|</span><label class="collapse" for="c-40558055">[-]</label><label class="expand" for="c-40558055">[4 more]</label></div><br/><div class="children"><div class="content">Amusingly, (to me at least) there&#x27;s also an SSE instruction for non-reciprocal square roots but it&#x27;s so much slower than reciprocal square root that calculating sqrt(x) as x * 1&#x2F;sqrt(x) is faster assuming you can tolerate the somewhat reduced precision.</div><br/><div id="40558223" class="c"><input type="checkbox" id="c-40558223" checked=""/><div class="controls bullet"><span class="by">mabster</span><span>|</span><a href="#40556917">root</a><span>|</span><a href="#40558055">parent</a><span>|</span><a href="#40558830">next</a><span>|</span><label class="collapse" for="c-40558223">[-]</label><label class="expand" for="c-40558223">[3 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t be surprised if _mm_rsqrt_ps is actually implemented using the same bit level trick.<p>Same as Carmack&#x27;s, we did a single step of Newton&#x27;s method and it was definitely good enough.</div><br/><div id="40558742" class="c"><input type="checkbox" id="c-40558742" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#40556917">root</a><span>|</span><a href="#40558223">parent</a><span>|</span><a href="#40559063">next</a><span>|</span><label class="collapse" for="c-40558742">[-]</label><label class="expand" for="c-40558742">[1 more]</label></div><br/><div class="children"><div class="content">I dunno about Intel and AMD, but ARM and RISC-V use lookup tables for rsqrt. Unlike AMD and Intel, those tables are precisely defined in their respective specs.</div><br/></div></div><div id="40559063" class="c"><input type="checkbox" id="c-40559063" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#40556917">root</a><span>|</span><a href="#40558223">parent</a><span>|</span><a href="#40558742">prev</a><span>|</span><a href="#40558830">next</a><span>|</span><label class="collapse" for="c-40559063">[-]</label><label class="expand" for="c-40559063">[1 more]</label></div><br/><div class="children"><div class="content">Intel provides bit-accurate code. In older chips it used a faithful bipartite ROM:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120124193536id_&#x2F;http:&#x2F;&#x2F;www.acsel-lab.com&#x2F;arithmetic&#x2F;papers&#x2F;ARITH12&#x2F;ARITH12_Das%20Sarma.pdf" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20120124193536id_&#x2F;http:&#x2F;&#x2F;www.acs...</a></div><br/></div></div></div></div></div></div><div id="40558830" class="c"><input type="checkbox" id="c-40558830" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40556917">parent</a><span>|</span><a href="#40558055">prev</a><span>|</span><a href="#40558501">next</a><span>|</span><label class="collapse" for="c-40558830">[-]</label><label class="expand" for="c-40558830">[1 more]</label></div><br/><div class="children"><div class="content">the vast, vast majority of computers do not support the sse instruction set or indeed any of the i386 and amd64 instruction set at all, and the fraction of computers that do support them (other than through emulation) is continually shrinking<p>gpu instruction sets, arm, risc-v, avr, pic, 8051, fpga... of course, in many cases, these do have a built-in approximate reciprocal square root operation, but probably implemented with this algorithm</div><br/></div></div></div></div><div id="40558501" class="c"><input type="checkbox" id="c-40558501" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40556917">prev</a><span>|</span><a href="#40559870">next</a><span>|</span><label class="collapse" for="c-40558501">[-]</label><label class="expand" for="c-40558501">[2 more]</label></div><br/><div class="children"><div class="content">To nitpick the article a bit:<p>&gt; It&#x27;s important to note that this algorithm is very much of its time. Back when Quake 3 was released in 1999, computing an inverse square root was a slow, expensive process. The game had to compute hundreds or thousands of them per second in order to solve lighting equations, and other 3D vector calculations that rely on normalization. These days, on modern hardware, not only would a calculation like this not take place on the CPU, even if it did, it would be fast due to much more advanced dedicated floating point hardware.<p>Calculations like this definitely take place on the CPU all the time. It&#x27;s a common misconception that games and other FLOP-heavy apps want to offload all floating-point operations to the GPU. In fact, it really only makes sense to offload large <i>uniform</i> workloads to the GPU. If you&#x27;re doing one-off vector normalization--say, as part of the rotation matrix construction needed to make one object face another--then you&#x27;re going to want to stay on the CPU, because the CPU is faster at that. In fact, the CPU would remain faster at <i>single</i> floating point operations even if you didn&#x27;t take the GPU transfer time into account--the GPU typically runs at a slower clock rate and relies on parallelism to achieve its high FLOP count.</div><br/><div id="40559293" class="c"><input type="checkbox" id="c-40559293" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#40558501">parent</a><span>|</span><a href="#40559870">next</a><span>|</span><label class="collapse" for="c-40559293">[-]</label><label class="expand" for="c-40559293">[1 more]</label></div><br/><div class="children"><div class="content">I think he refers to FPU, not GPU.<p>In the  old days, FPU do async computation.<p>FPU is now a considered an integrated part of CPU.</div><br/></div></div></div></div><div id="40559870" class="c"><input type="checkbox" id="c-40559870" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40558501">prev</a><span>|</span><a href="#40557268">next</a><span>|</span><label class="collapse" for="c-40559870">[-]</label><label class="expand" for="c-40559870">[2 more]</label></div><br/><div class="children"><div class="content">Time for nitpicks, sorry.<p>The formulas for the floats have typos. They should read (-1)^S, not -1^S (which always equals -1).<p>Interpreting the raw bit patterns isn&#x27;t a piecewise linear approximation of the logarithm. The lines between the data points on the blue graph don&#x27;t actually exist, it&#x27;s not possible for a bit to be half set to 1. It&#x27;s rather a discrete version of the logarithm: the only data points that exist - where the red and blue lines meet - are literally equal to the (scaled, shifted) logarithm.<p>Other than that, nice post!</div><br/><div id="40560236" class="c"><input type="checkbox" id="c-40560236" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#40559870">parent</a><span>|</span><a href="#40557268">next</a><span>|</span><label class="collapse" for="c-40560236">[-]</label><label class="expand" for="c-40560236">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand. Imagine a very small 6-bit float, with 1 bit sign, 2 bits exponent, and 3 bits mantissa. The interval [010000, 010111] contains the numbers 2, 2.25, 2.5, 2.75, 3, 3.25, 3.5, 3.75.<p>But! These numbers&#x27; base two logarithms imply mantissae of<p>- .0000000 (equal to the float 000)<p>- .0010101 (not equal to the float 001)<p>- .0101001 (not equal to the float 010)<p>- .0111010 (not equal to the float 011)<p>- .1001010 (not equal to the float 100)<p>- .1011001 (not equal to the float 101)<p>- .1100111 (not equal to the float 110)<p>- .1110100 (not equal to the float 111)<p>because the floats in the [2,4) interval are linearly spaced, whereas the corresponding logarithms are not. In other words, the floats are a piecewise linear approximation of the logarithm – just as the article says.</div><br/></div></div></div></div><div id="40557268" class="c"><input type="checkbox" id="c-40557268" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#40559870">prev</a><span>|</span><a href="#40557610">next</a><span>|</span><label class="collapse" for="c-40557268">[-]</label><label class="expand" for="c-40557268">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a implementation in MMIX:<p><pre><code>          % Constants
  FISRCON GREG #5FE6EB50C7B537A9
  THREHAF GREG #3FF8000000000000
          % Save half of the original number
          OR $2,$0,0
          INCH $2,#FFF0
          % Bit level hacking
          SRU $1,$0,1
          SUBU $0,FISRCON,$1
          % First iteration
          FMUL $1,$2,$0
          FMUL $1,$1,$0
          FSUB $1,THREHAF,$1
          FMUL $0,$0,$1
          % Second iteration
          FMUL $1,$2,$0
          FMUL $1,$1,$0
          FSUB $1,THREHAF,$1
          FMUL $0,$0,$1
</code></pre>
This implementation makes an assumption that the original number is greater than 2^-1021.</div><br/></div></div><div id="40557610" class="c"><input type="checkbox" id="c-40557610" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40557268">prev</a><span>|</span><a href="#40556794">next</a><span>|</span><label class="collapse" for="c-40557610">[-]</label><label class="expand" for="c-40557610">[4 more]</label></div><br/><div class="children"><div class="content">I collected a few of these here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;fastmath&#x2F;blob&#x2F;main&#x2F;fast.go">https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;fastmath&#x2F;blob&#x2F;main&#x2F;fast.go</a><p>Also see this StackOverflow:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;32042673&#x2F;optimized-low-accuracy-approximation-to-rootnx-n" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;32042673&#x2F;optimized-low-a...</a></div><br/><div id="40558348" class="c"><input type="checkbox" id="c-40558348" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#40557610">parent</a><span>|</span><a href="#40559778">next</a><span>|</span><label class="collapse" for="c-40558348">[-]</label><label class="expand" for="c-40558348">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great, thank you. I was just thinking about starting a collection of these to begin rewriting my old 3D engine from the late 80s.</div><br/></div></div><div id="40559778" class="c"><input type="checkbox" id="c-40559778" checked=""/><div class="controls bullet"><span class="by">koeng</span><span>|</span><a href="#40557610">parent</a><span>|</span><a href="#40558348">prev</a><span>|</span><a href="#40556794">next</a><span>|</span><label class="collapse" for="c-40559778">[-]</label><label class="expand" for="c-40559778">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to see some benchmarks on your fastmath package</div><br/><div id="40560467" class="c"><input type="checkbox" id="c-40560467" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40557610">root</a><span>|</span><a href="#40559778">parent</a><span>|</span><a href="#40556794">next</a><span>|</span><label class="collapse" for="c-40560467">[-]</label><label class="expand" for="c-40560467">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s… probably not worth it.<p>I just wrote this years ago (go.mod said 1.12) for the fun of it, thought I had it in a Gist&#x2F;GitHub, and uploaded it yesterday in response to this post.<p>One thing I remember trying was coding this up in ASM… which makes it worse, because it prevents inlining. But I learned the Go ASM syntax that way.</div><br/></div></div></div></div></div></div><div id="40556794" class="c"><input type="checkbox" id="c-40556794" checked=""/><div class="controls bullet"><span class="by">rogerallen</span><span>|</span><a href="#40557610">prev</a><span>|</span><a href="#40559944">next</a><span>|</span><label class="collapse" for="c-40556794">[-]</label><label class="expand" for="c-40556794">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested, Wikipedia also has a decent discussion of this function and it&#x27;s history.  <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fast_inverse_square_root</a></div><br/></div></div><div id="40559944" class="c"><input type="checkbox" id="c-40559944" checked=""/><div class="controls bullet"><span class="by">p0seidon</span><span>|</span><a href="#40556794">prev</a><span>|</span><a href="#40558344">next</a><span>|</span><label class="collapse" for="c-40559944">[-]</label><label class="expand" for="c-40559944">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for stealing hours of my productive time going down this rabbit hole.</div><br/></div></div><div id="40558344" class="c"><input type="checkbox" id="c-40558344" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#40559944">prev</a><span>|</span><a href="#40556885">next</a><span>|</span><label class="collapse" for="c-40558344">[-]</label><label class="expand" for="c-40558344">[1 more]</label></div><br/><div class="children"><div class="content">I was building 3D engines a few years before the days of Quake, and having recently watched videos about optimizing the trig code in Super Mario 64, and these other faster algorithms, it makes me wonder how much more can be squeezed out of old hardware.<p>I was optimizing my assembler to the nth degree, but optimizing the algorithm is always going to be the real winner.</div><br/></div></div><div id="40556885" class="c"><input type="checkbox" id="c-40556885" checked=""/><div class="controls bullet"><span class="by">schmorptron</span><span>|</span><a href="#40558344">prev</a><span>|</span><a href="#40558406">next</a><span>|</span><label class="collapse" for="c-40556885">[-]</label><label class="expand" for="c-40556885">[1 more]</label></div><br/><div class="children"><div class="content">I really liked this video about it when I saw it a while ago:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=p8u_k2LIZyo" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=p8u_k2LIZyo</a></div><br/></div></div><div id="40558406" class="c"><input type="checkbox" id="c-40558406" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40556885">prev</a><span>|</span><a href="#40557172">next</a><span>|</span><label class="collapse" for="c-40558406">[-]</label><label class="expand" for="c-40558406">[5 more]</label></div><br/><div class="children"><div class="content">Here’s something new that isn’t mentioned and might be worth adding to the repo. (Edit I’m wrong, it is there, I just didn’t recognize it.) The magic number in the famous code snippet is not the optimal constant. You can do maybe 0.5% better relative error using a different constant. Maybe at the time it was infeasible to search for the absolutely optimal number, but now it’s relatively easy. I also went down this rabbit hole at some point, so I have a Jupyter notebook for finding the optimal magic number for this (1&#x2F;x^2) and also for (1&#x2F;x). Anyone wanna know what the optimal magic number is?</div><br/><div id="40558424" class="c"><input type="checkbox" id="c-40558424" checked=""/><div class="controls bullet"><span class="by">bradleyjg</span><span>|</span><a href="#40558406">parent</a><span>|</span><a href="#40558428">next</a><span>|</span><label class="collapse" for="c-40558424">[-]</label><label class="expand" for="c-40558424">[2 more]</label></div><br/><div class="children"><div class="content">There’s a link at the bottom to a paper exploring that question.</div><br/><div id="40558493" class="c"><input type="checkbox" id="c-40558493" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40558406">root</a><span>|</span><a href="#40558424">parent</a><span>|</span><a href="#40558428">next</a><span>|</span><label class="collapse" for="c-40558493">[-]</label><label class="expand" for="c-40558493">[1 more]</label></div><br/><div class="children"><div class="content">Good point, I hadn’t read Lomont’s paper and should have. I read the section in the Wikipedia article talking about it, and did try the constant that it suggests, however it depends on doing extra Newton iterations and I looked at the relative error of the initial guess without Newton. I can see in the paper he found something within 1 bit of what I found. I’m not certain mine’s better, but my python script claims it is.</div><br/></div></div></div></div><div id="40558428" class="c"><input type="checkbox" id="c-40558428" checked=""/><div class="controls bullet"><span class="by">qaisjp</span><span>|</span><a href="#40558406">parent</a><span>|</span><a href="#40558424">prev</a><span>|</span><a href="#40557172">next</a><span>|</span><label class="collapse" for="c-40558428">[-]</label><label class="expand" for="c-40558428">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Anyone wanna know what the optimal magic number is?<p>Sure.</div><br/><div id="40558522" class="c"><input type="checkbox" id="c-40558522" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40558406">root</a><span>|</span><a href="#40558428">parent</a><span>|</span><a href="#40557172">next</a><span>|</span><label class="collapse" for="c-40558522">[-]</label><label class="expand" for="c-40558522">[1 more]</label></div><br/><div class="children"><div class="content">For no Newton iterations, I thought I found 0x5f37641f had the lowest relative error, and I measure it at 3.4211. Of course I’m not super certain, Lomont’s effort is way more complete than mine. Lomont’s paper mentions 0x5f37642f with a relative error of 3.42128 and Wikipedia and the paper both talk about 0x5f375a86 being best when using Newton iterations.</div><br/></div></div></div></div></div></div><div id="40557172" class="c"><input type="checkbox" id="c-40557172" checked=""/><div class="controls bullet"><span class="by">atleastoptimal</span><span>|</span><a href="#40558406">prev</a><span>|</span><a href="#40557481">next</a><span>|</span><label class="collapse" for="c-40557172">[-]</label><label class="expand" for="c-40557172">[11 more]</label></div><br/><div class="children"><div class="content">Something interesting is I&#x27;ve seen this mythologized as evidenced of the &quot;cracked engineer&quot; theory, wherein random engineers will accidentally stumble upon incredibly complex discoveries in the course of their day to day work and expect no fanfare for this, besting the scientists and researchers who take the traditional route but aren&#x27;t spurred by necessity. People, like xkcd, purported this was either Carmack or some random employee who figured it out in a few hours when stuck on a problem then waltzed onto the next one. In truth, as noted in the document, it has a history that goes back decades in academia, this was simply the most notable time it was implemented.<p>I think it speaks to an issue I see in the software engineering world where people assume that collaboration is for low-IQ people and all great innovation comes from some super-genius working on their own for long enough, and isn&#x27;t required to share how they arrived at their findings. I&#x27;m sure the mythology of this algorithm is propelled somewhat by the enigmatic character of writing &quot;what the fuck&quot; next to adding the constant, implying a mystical element to its utility that was arrived at without needing to clarify it in some long boring research paper.</div><br/><div id="40558019" class="c"><input type="checkbox" id="c-40558019" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#40557172">parent</a><span>|</span><a href="#40557633">next</a><span>|</span><label class="collapse" for="c-40558019">[-]</label><label class="expand" for="c-40558019">[1 more]</label></div><br/><div class="children"><div class="content">But that is what happened [1]. The article, which is probably the most definitive investigation to date, has Greg Walsh claim they invented the fast inverse square root while working at Ardent, which Wikipedia claims was founded in 1985 [2], to meet product performance benchmarks.<p>The Green Hills Software C compiler had a fast square root algorithm of similar form:<p><pre><code>  (x &gt;&gt; 1) + {magic constant} 
</code></pre>
dating between 1983-1985 if I recall correctly. Also implemented to maximize floating point performance benchmarks, and again not drawn from academia. If my recollection is correct, that is one of the earliest known examples of the general technique and predates even the official IEEE 754 floating point specification which was not formally ratified until 1985 (but the standard was in development since 1977 and already de facto adopted by the time it was formally ratified).<p>[1] <a href="https:&#x2F;&#x2F;www.beyond3d.com&#x2F;content&#x2F;articles&#x2F;15&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.beyond3d.com&#x2F;content&#x2F;articles&#x2F;15&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stardent_Inc.#Ardent_Computer_Corporation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stardent_Inc.#Ardent_Computer_...</a></div><br/></div></div><div id="40557633" class="c"><input type="checkbox" id="c-40557633" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#40557172">parent</a><span>|</span><a href="#40558019">prev</a><span>|</span><a href="#40557496">next</a><span>|</span><label class="collapse" for="c-40557633">[-]</label><label class="expand" for="c-40557633">[4 more]</label></div><br/><div class="children"><div class="content">&gt; where people assume that collaboration is for low-IQ people<p>I&#x27;ve also seen a phenomenon where developers believe their code is so valuable and amazing that they don&#x27;t share it; it&#x27;s really ordinary code but useful to novices nonetheless. Some communities I participated in when I was younger (e.g. PS3 jailbreak scene) were very protective of their code for no reason. Executables were obfuscated, nothing was open source, and developers were very hostile or intentionally trolled you when asking questions about their software.</div><br/><div id="40558928" class="c"><input type="checkbox" id="c-40558928" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#40557172">root</a><span>|</span><a href="#40557633">parent</a><span>|</span><a href="#40559313">next</a><span>|</span><label class="collapse" for="c-40558928">[-]</label><label class="expand" for="c-40558928">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve met some people like this before, and I think this phenomenon has a lot to do with having one&#x27;s identity closely bound to the code. Any criticism of the code is interpreted as a personal attack. Conversely, the attitude of &quot;I&#x27;m so awesome therefore my code must be super important and really important to protect&quot;.</div><br/><div id="40559617" class="c"><input type="checkbox" id="c-40559617" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40557172">root</a><span>|</span><a href="#40558928">parent</a><span>|</span><a href="#40559313">next</a><span>|</span><label class="collapse" for="c-40559617">[-]</label><label class="expand" for="c-40559617">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;ve seen this a lot too.<p>I&#x27;ve also seen the reverse - perhaps more. People need advice but don&#x27;t want to share their code because they are embarrassed by it. They wrote it thinking &quot;no one will ever see this&quot;.<p>By contrast I sell code, so I know it&#x27;ll be seen by lots of people, so I tend to spend time making sure style is consistent, things are well named, and so on. But equally, to me, it&#x27;s just code. Feel free to comment on it - there&#x27;s always room for improvement.</div><br/></div></div></div></div><div id="40559313" class="c"><input type="checkbox" id="c-40559313" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#40557172">root</a><span>|</span><a href="#40557633">parent</a><span>|</span><a href="#40558928">prev</a><span>|</span><a href="#40557496">next</a><span>|</span><label class="collapse" for="c-40559313">[-]</label><label class="expand" for="c-40559313">[1 more]</label></div><br/><div class="children"><div class="content">That was all the console modding scenes.<p>Toxic, necessarily so.</div><br/></div></div></div></div><div id="40557303" class="c"><input type="checkbox" id="c-40557303" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#40557172">parent</a><span>|</span><a href="#40557496">prev</a><span>|</span><a href="#40557481">next</a><span>|</span><label class="collapse" for="c-40557303">[-]</label><label class="expand" for="c-40557303">[4 more]</label></div><br/><div class="children"><div class="content">I think the xkcd comic was more about academia vs product engineering in for profit entities. If anything, it is the collaborative effort of many people working on a product with deadlines that ends up with some of them coming up with really interesting solutions just due to the number of people looking. The lack of sharing between companies does increase the incidence of the outsider effect, at the massive cost of reinventing basic knowledge over and over. The only reason breakthroughs still happen despite that is just the large number of people trying random stuff that probably won&#x27;t work motivated by unrealistic deadlines. They don&#x27;t know it probably won&#x27;t work though...</div><br/><div id="40557498" class="c"><input type="checkbox" id="c-40557498" checked=""/><div class="controls bullet"><span class="by">xeonmc</span><span>|</span><a href="#40557172">root</a><span>|</span><a href="#40557303">parent</a><span>|</span><a href="#40557488">next</a><span>|</span><label class="collapse" for="c-40557498">[-]</label><label class="expand" for="c-40557498">[1 more]</label></div><br/><div class="children"><div class="content">Relevant topic: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40485313">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40485313</a></div><br/></div></div><div id="40557488" class="c"><input type="checkbox" id="c-40557488" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40557172">root</a><span>|</span><a href="#40557303">parent</a><span>|</span><a href="#40557498">prev</a><span>|</span><a href="#40557481">next</a><span>|</span><label class="collapse" for="c-40557488">[-]</label><label class="expand" for="c-40557488">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;664&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;664&#x2F;</a> for the curious.</div><br/><div id="40558372" class="c"><input type="checkbox" id="c-40558372" checked=""/><div class="controls bullet"><span class="by">atleastoptimal</span><span>|</span><a href="#40557172">root</a><span>|</span><a href="#40557488">parent</a><span>|</span><a href="#40557481">next</a><span>|</span><label class="collapse" for="c-40558372">[-]</label><label class="expand" for="c-40558372">[1 more]</label></div><br/><div class="children"><div class="content">The point seems more to me that in engineering, breakthroughs worthy of academic repute aren&#x27;t given much fanfare, though probably a bit of an exaggeration. It&#x27;s hard to tell to what extent his comics reflect actual sentiments or rather an artifice of some abstraction taken to an absurd level.</div><br/></div></div></div></div></div></div></div></div><div id="40557481" class="c"><input type="checkbox" id="c-40557481" checked=""/><div class="controls bullet"><span class="by">DrNosferatu</span><span>|</span><a href="#40557172">prev</a><span>|</span><a href="#40558992">next</a><span>|</span><label class="collapse" for="c-40557481">[-]</label><label class="expand" for="c-40557481">[1 more]</label></div><br/><div class="children"><div class="content">Note that you’re actually using 3 distinct magic numbers - not only the single 0x5f3759df, but also 0.5 and 1.5;<p>So for further accuracy we can instead have:<p>conv.i = 0x5F1FFFF9 - ( conv.i &gt;&gt; 1 );
conv.f <i>= 0.703952253f </i> ( 2.38924456f - x * conv.f * conv.f );
return conv.f;<p>[from Wikipedia]</div><br/></div></div><div id="40558992" class="c"><input type="checkbox" id="c-40558992" checked=""/><div class="controls bullet"><span class="by">Exuma</span><span>|</span><a href="#40557481">prev</a><span>|</span><a href="#40558741">next</a><span>|</span><label class="collapse" for="c-40558992">[-]</label><label class="expand" for="c-40558992">[2 more]</label></div><br/><div class="children"><div class="content">I tried this in a raytracter today while learning rust and it made the scene render all white. Lol</div><br/><div id="40559294" class="c"><input type="checkbox" id="c-40559294" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#40558992">parent</a><span>|</span><a href="#40558741">next</a><span>|</span><label class="collapse" for="c-40559294">[-]</label><label class="expand" for="c-40559294">[1 more]</label></div><br/><div class="children"><div class="content">This actually made me chuckle, although it took an embarrassingly long second.</div><br/></div></div></div></div><div id="40558741" class="c"><input type="checkbox" id="c-40558741" checked=""/><div class="controls bullet"><span class="by">solarized</span><span>|</span><a href="#40558992">prev</a><span>|</span><a href="#40556914">next</a><span>|</span><label class="collapse" for="c-40558741">[-]</label><label class="expand" for="c-40558741">[2 more]</label></div><br/><div class="children"><div class="content">Noob here. Please ELI 5 what this algo used in quake 3 ?.<p>&gt; Solve lighting equations<p>Is it the light or laser effect when the gun is fired ?</div><br/><div id="40558855" class="c"><input type="checkbox" id="c-40558855" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40558741">parent</a><span>|</span><a href="#40556914">next</a><span>|</span><label class="collapse" for="c-40558855">[-]</label><label class="expand" for="c-40558855">[1 more]</label></div><br/><div class="children"><div class="content">When you render a pixel on screen (of a diffuse object), to determine how brightly it&#x27;s lit, you need to compute the angle between the normal at the point on the surface and the light source. Computing this angle requires normalizing one or more vectors, which is done by dividing by the magnitude, or the square root of the sum of the squares of the components.<p>So the lights in this case are any lights in the scene, typically represented as a point of origin and a brightness.</div><br/></div></div></div></div><div id="40556914" class="c"><input type="checkbox" id="c-40556914" checked=""/><div class="controls bullet"><span class="by">jxyxfinite</span><span>|</span><a href="#40558741">prev</a><span>|</span><a href="#40557262">next</a><span>|</span><label class="collapse" for="c-40556914">[-]</label><label class="expand" for="c-40556914">[9 more]</label></div><br/><div class="children"><div class="content">Did John not write the code? Or did he copy paste it from somewhere?</div><br/><div id="40557011" class="c"><input type="checkbox" id="c-40557011" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40556914">parent</a><span>|</span><a href="#40556924">next</a><span>|</span><label class="collapse" for="c-40557011">[-]</label><label class="expand" for="c-40557011">[1 more]</label></div><br/><div class="children"><div class="content">The origin is really unclear. It&#x27;s not certain which id employee added it to Quake 3 and where they got it from. John claims it wasn&#x27;t him. Gary Tarolli, one of the founders of 3dfx, claims to remember tweaking the value of the hex constant to the value known today. But he says he didn&#x27;t come up with the algorithm either. Maybe somebody else at 3dfx did, maybe he got it from somewhere else.</div><br/></div></div><div id="40556924" class="c"><input type="checkbox" id="c-40556924" checked=""/><div class="controls bullet"><span class="by">jb1991</span><span>|</span><a href="#40556914">parent</a><span>|</span><a href="#40557011">prev</a><span>|</span><a href="#40557262">next</a><span>|</span><label class="collapse" for="c-40556924">[-]</label><label class="expand" for="c-40556924">[7 more]</label></div><br/><div class="children"><div class="content">wikipedia says:<p>&gt; Brian Hook may have brought the algorithm from 3dfx to id Software.</div><br/><div id="40557097" class="c"><input type="checkbox" id="c-40557097" checked=""/><div class="controls bullet"><span class="by">Rinzler89</span><span>|</span><a href="#40556914">root</a><span>|</span><a href="#40556924">parent</a><span>|</span><a href="#40557262">next</a><span>|</span><label class="collapse" for="c-40557097">[-]</label><label class="expand" for="c-40557097">[6 more]</label></div><br/><div class="children"><div class="content">And at 3dfx he probably learned it from some ex-SGI guy, and that guy learned it doing his PhD at Stanford from someone who worked for ed Ed Catmull and so on. The lore goes deep with stuff like this. There&#x27;s rarely just one author but many who improve the formula over time.</div><br/><div id="40557135" class="c"><input type="checkbox" id="c-40557135" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40556914">root</a><span>|</span><a href="#40557097">parent</a><span>|</span><a href="#40557262">next</a><span>|</span><label class="collapse" for="c-40557135">[-]</label><label class="expand" for="c-40557135">[5 more]</label></div><br/><div class="children"><div class="content">there&#x27;s an unrecognized genius out there that realized you can just apply a bit flip to get that out there. That John Carmack hasn&#x27;t claimed it as his invention when he could have, speaks volumes about his character.</div><br/><div id="40557148" class="c"><input type="checkbox" id="c-40557148" checked=""/><div class="controls bullet"><span class="by">Rinzler89</span><span>|</span><a href="#40556914">root</a><span>|</span><a href="#40557135">parent</a><span>|</span><a href="#40557188">next</a><span>|</span><label class="collapse" for="c-40557148">[-]</label><label class="expand" for="c-40557148">[2 more]</label></div><br/><div class="children"><div class="content">Except he couldn&#x27;t have even if he wanted to. There&#x27;s always the risk some former 3dfx or SGI graybeard comes out with some paper binder with the original implementation, and calls you out on your bullshit if you do. When you&#x27;re such a famous public figure no way you ever risk lying in public. Even if he were to getaway with it there was nothing for him to gain: he already has all the fame and money from honest work, there&#x27;s no point risking it all to claim some piece of code.</div><br/><div id="40557305" class="c"><input type="checkbox" id="c-40557305" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#40556914">root</a><span>|</span><a href="#40557148">parent</a><span>|</span><a href="#40557188">next</a><span>|</span><label class="collapse" for="c-40557305">[-]</label><label class="expand" for="c-40557305">[1 more]</label></div><br/><div class="children"><div class="content">Then you call it a parallel discovery!</div><br/></div></div></div></div><div id="40557188" class="c"><input type="checkbox" id="c-40557188" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#40556914">root</a><span>|</span><a href="#40557135">parent</a><span>|</span><a href="#40557148">prev</a><span>|</span><a href="#40557262">next</a><span>|</span><label class="collapse" for="c-40557188">[-]</label><label class="expand" for="c-40557188">[2 more]</label></div><br/><div class="children"><div class="content">I’m not sure anyone should be impressed by someone not stealing even if they had a chance to. That’s just a basic human expectation.</div><br/><div id="40557490" class="c"><input type="checkbox" id="c-40557490" checked=""/><div class="controls bullet"><span class="by">tsuica</span><span>|</span><a href="#40556914">root</a><span>|</span><a href="#40557188">parent</a><span>|</span><a href="#40557262">next</a><span>|</span><label class="collapse" for="c-40557490">[-]</label><label class="expand" for="c-40557490">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d think so.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40557262" class="c"><input type="checkbox" id="c-40557262" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40556914">prev</a><span>|</span><a href="#40558870">next</a><span>|</span><label class="collapse" for="c-40557262">[-]</label><label class="expand" for="c-40557262">[1 more]</label></div><br/><div class="children"><div class="content">What’s up with the diagonal lines in the graph backgrounds?</div><br/></div></div><div id="40557125" class="c"><input type="checkbox" id="c-40557125" checked=""/><div class="controls bullet"><span class="by">casey2</span><span>|</span><a href="#40558856">prev</a><span>|</span><label class="collapse" for="c-40557125">[-]</label><label class="expand" for="c-40557125">[9 more]</label></div><br/><div class="children"><div class="content">He posts c code and says that it computes the inverse square root, but the code he posted is undefined c, so while it could compute the inverse square root of it&#x27;s input it could also do a long list of other stuff.<p>One of the many reasons you should stay away from real world languages when talking about algorithms unless you are an expert in the language.</div><br/><div id="40557184" class="c"><input type="checkbox" id="c-40557184" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40557125">parent</a><span>|</span><a href="#40558851">next</a><span>|</span><label class="collapse" for="c-40557184">[-]</label><label class="expand" for="c-40557184">[1 more]</label></div><br/><div class="children"><div class="content">The code he posted is straight from the Quake 3 source release, a program which has certainly been installed and used on hundreds on millions of real computers. UB pedantry makes no difference to the actual behavior of the program as demonstrated.</div><br/></div></div><div id="40558851" class="c"><input type="checkbox" id="c-40558851" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40557125">parent</a><span>|</span><a href="#40557184">prev</a><span>|</span><a href="#40557227">next</a><span>|</span><label class="collapse" for="c-40558851">[-]</label><label class="expand" for="c-40558851">[1 more]</label></div><br/><div class="children"><div class="content">It’s a historical artifact being presented in its original form. There’s no reason this code can’t be updated with a more modern bitwise int-float conversion. Do that if you want to use it.<p>Whether it is bad practice or not, people used to do this all the time, and so the compilers all tend to support type conversion via pointer and type punning via union. A lot of critical code in the real world would break if it suddenly didn’t work.<p>C++ bit-cast is brand new (C++20) and until now the suggestion in C++ was to use memcpy, and hope and pray it gets elided. That might be correct but boy is it ugly and gross.</div><br/></div></div><div id="40557227" class="c"><input type="checkbox" id="c-40557227" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#40557125">parent</a><span>|</span><a href="#40558851">prev</a><span>|</span><label class="collapse" for="c-40557227">[-]</label><label class="expand" for="c-40557227">[6 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re talking <i>real-world</i> languages, the code is perfectly well-defined. It&#x27;s undefined behaviour in Abstract C, the C of the Specification, which to my knowledge nobody has ever implemented, but Quake 3 was not written in Abstract C. It was written in Visual C++ 2003, gcc 2.95, and some other specific C implementation.<p>The code snippet that the article claims is C:<p><pre><code>  int32_t compute_magic(void) {
    double sigma = 0.0450465;
    double expression = 1.5 * pow(2.0, 23.0) * (127.0 - sigma);
    int32_t i = expression;
    return i;
  }
</code></pre>
which, as far as I can tell, is perfectly well-defined Abstract C.</div><br/><div id="40557632" class="c"><input type="checkbox" id="c-40557632" checked=""/><div class="controls bullet"><span class="by">cgrealy</span><span>|</span><a href="#40557125">root</a><span>|</span><a href="#40557227">parent</a><span>|</span><a href="#40557517">next</a><span>|</span><label class="collapse" for="c-40557632">[-]</label><label class="expand" for="c-40557632">[1 more]</label></div><br/><div class="children"><div class="content">Minor correction: Q3 came out in 99, so it was probably written in either VC++ 97 or VC6.<p>Otherwise, carry on.</div><br/></div></div><div id="40557517" class="c"><input type="checkbox" id="c-40557517" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#40557125">root</a><span>|</span><a href="#40557227">parent</a><span>|</span><a href="#40557632">prev</a><span>|</span><a href="#40557495">next</a><span>|</span><label class="collapse" for="c-40557517">[-]</label><label class="expand" for="c-40557517">[3 more]</label></div><br/><div class="children"><div class="content">Specifically, I think the original code will always do what you expect as long as sizeof(long) == sizeof(float), and the alignment is the same. In reality no compiler is gonna do weird stuff unless your hardware target is weird.</div><br/><div id="40559876" class="c"><input type="checkbox" id="c-40559876" checked=""/><div class="controls bullet"><span class="by">btdmaster</span><span>|</span><a href="#40557125">root</a><span>|</span><a href="#40557517">parent</a><span>|</span><a href="#40558848">next</a><span>|</span><label class="collapse" for="c-40559876">[-]</label><label class="expand" for="c-40559876">[1 more]</label></div><br/><div class="children"><div class="content">Examples of such a weird hardware target include Linux and MacOS, which use LP64: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;64-bit_computing#64-bit_data_models" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;64-bit_computing#64-bit_data_m...</a><p>If you use a union, your code won&#x27;t read or write out of bounds, since it will save space for the larger type. Ideally you would also specify _Float32_t and int32_t for some pseudoportability (at least before endianness gets involved), although I&#x27;m aware this was not available in 1999.</div><br/></div></div><div id="40558848" class="c"><input type="checkbox" id="c-40558848" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40557125">root</a><span>|</span><a href="#40557517">parent</a><span>|</span><a href="#40559876">prev</a><span>|</span><a href="#40557495">next</a><span>|</span><label class="collapse" for="c-40558848">[-]</label><label class="expand" for="c-40558848">[1 more]</label></div><br/><div class="children"><div class="content">compiler engineers have been disappointing our &#x27;surely no compiler would ever be so perverse as to do x&#x27; expectations for 25 years now, and it doesn&#x27;t seem that they&#x27;re likely to stop soon</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>