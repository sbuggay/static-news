<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700038872302" as="style"/><link rel="stylesheet" href="styles.css?v=1700038872302"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://inko-lang.org">Inko Programming Language</a> <span class="domain">(<a href="https://inko-lang.org">inko-lang.org</a>)</span></div><div class="subtext"><span>gautamcgoel</span> | <span>49 comments</span></div><br/><div><div id="38271412" class="c"><input type="checkbox" id="c-38271412" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#38274358">next</a><span>|</span><label class="collapse" for="c-38271412">[-]</label><label class="expand" for="c-38271412">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Inko uses lightweight processes for concurrency, and its concurrency model is inspired by Erlang and Pony. Processes are isolated from each other and communicate by sending messages. Processes and messages are defined as classes and methods, and the compiler type-checks these to ensure correctness.<p>&gt; The compiler ensures that data sent between processes is unique, meaning there are no outside references to the data. This removes the need for (deep) copying data, and makes data races impossible. Inko also supports multi-producer multi-consumer channels, allowing processes to communicate with each other without needing explicit references to each other.<p>Now I&#x27;m very interested. I was wondering why with &#x27;actors&#x27; we&#x27;d still mark functions as async. It seems that a class marked async is analogous to an actor.<p><pre><code>  class async Counter {
    let @value: Int
  
    fn async mut increment {
      @value += 1
    }
  
    fn async send_to(channel: Channel[Int]) {
      channel.send(@value)
    }
  }</code></pre></div><br/><div id="38271577" class="c"><input type="checkbox" id="c-38271577" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38271412">parent</a><span>|</span><a href="#38274358">next</a><span>|</span><label class="collapse" for="c-38271577">[-]</label><label class="expand" for="c-38271577">[4 more]</label></div><br/><div class="children"><div class="content">A class marked as &quot;async&quot; can still have regular methods, which are only
available to the inside of the class (i.e. the process itself, not other
processes sending messages to it). So you can do something like this:<p><pre><code>    class async SomeProcess {
      fn async some_message(...) {
        ...
        some_helper_method
      }

      fn some_helper_method {
        ...
      }
    }

    SomeProcess {}.some_message # This is fine
    SomeProcess {}.some_message # This is a compile-time error
</code></pre>
I toyed with the idea of _not_ allowing regular method and thus implicitly
making all of them async for an async class, but that might lead to a pattern of
async classes being &quot;mirrored&quot; by non-async &quot;helper&quot; classes just to reuse some
methods between the different messages of an async class, i.e. you end up with
this:<p><pre><code>    class async SomeProcess {
      fn some_message(...) {
        SomeProcessHelper {}.some_random_method
      }
    }

    class SomeProcessHelper {
      fn some_random_method {
        ...
      }
    }</code></pre></div><br/><div id="38273788" class="c"><input type="checkbox" id="c-38273788" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#38271412">root</a><span>|</span><a href="#38271577">parent</a><span>|</span><a href="#38272587">next</a><span>|</span><label class="collapse" for="c-38273788">[-]</label><label class="expand" for="c-38273788">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused by<p><pre><code>    SomeProcess {}.some_message # This is fine
    SomeProcess {}.some_message # This is a compile-time error
</code></pre>
Aren&#x27;t those the same call? Or is it calling it twice that&#x27;s the error? or did you mean the 2nd to call some_helper_method instead?</div><br/></div></div><div id="38272587" class="c"><input type="checkbox" id="c-38272587" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#38271412">root</a><span>|</span><a href="#38271577">parent</a><span>|</span><a href="#38273788">prev</a><span>|</span><a href="#38274358">next</a><span>|</span><label class="collapse" for="c-38272587">[-]</label><label class="expand" for="c-38272587">[1 more]</label></div><br/><div class="children"><div class="content">Glad to see you here. Thanks that all makes sense, as making the async class&#x27;s method async by default would then needs another keyword to make one non-async.<p>Is the mut marking also for consistency (and&#x2F;or non-message methods)? Presumably each actor&#x2F;object would only process one message at a time so could always have full access to all its data.<p>One more question, is memory allocated globally or from arenas&#x2F;slabs&#x2F;etc?</div><br/></div></div></div></div></div></div><div id="38274358" class="c"><input type="checkbox" id="c-38274358" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#38271412">prev</a><span>|</span><a href="#38271849">next</a><span>|</span><label class="collapse" for="c-38274358">[-]</label><label class="expand" for="c-38274358">[5 more]</label></div><br/><div class="children"><div class="content">&gt; To add a package, first create a GitHub repository for your package. While Inko&#x27;s package manager supports the use of any Git repository (e.g. one hosted on GitLab), the above list is populated using GitHub repositories only.<p>So another community that wants to lock itself into Microsoft products as well as Git in general. Why should a user’s choice for DVCS &amp; forge make them feel less supported or inferior?</div><br/><div id="38274420" class="c"><input type="checkbox" id="c-38274420" checked=""/><div class="controls bullet"><span class="by">fshr</span><span>|</span><a href="#38274358">parent</a><span>|</span><a href="#38274580">next</a><span>|</span><label class="collapse" for="c-38274420">[-]</label><label class="expand" for="c-38274420">[3 more]</label></div><br/><div class="children"><div class="content">Because PL devs and their communities, until very large, have limited resources; supporting niche use cases needs to be provided by people wanting that niche served, not by the primary contributors.</div><br/><div id="38274687" class="c"><input type="checkbox" id="c-38274687" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#38274358">root</a><span>|</span><a href="#38274420">parent</a><span>|</span><a href="#38274641">next</a><span>|</span><label class="collapse" for="c-38274687">[-]</label><label class="expand" for="c-38274687">[1 more]</label></div><br/><div class="children"><div class="content">When did the ability to clone a repo outside of GitHub become a niche use case? It&#x27;s not something you need to explicitly support, in fact you have to actively go out of your way to make sure only GitHub works.</div><br/></div></div><div id="38274641" class="c"><input type="checkbox" id="c-38274641" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#38274358">root</a><span>|</span><a href="#38274420">parent</a><span>|</span><a href="#38274687">prev</a><span>|</span><a href="#38274580">next</a><span>|</span><label class="collapse" for="c-38274641">[-]</label><label class="expand" for="c-38274641">[1 more]</label></div><br/><div class="children"><div class="content">…Or use something generic like a tarball? Almost all DVCS have the ability to export an archive. Don’t build on lock-in; build on the generic thing… and then provide an ‘enhanced’ experience for something specific like Git or a specific forge.</div><br/></div></div></div></div><div id="38274580" class="c"><input type="checkbox" id="c-38274580" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#38274358">parent</a><span>|</span><a href="#38274420">prev</a><span>|</span><a href="#38271849">next</a><span>|</span><label class="collapse" for="c-38274580">[-]</label><label class="expand" for="c-38274580">[1 more]</label></div><br/><div class="children"><div class="content">It is not even the worst I have seen. E.g. Kinesis and others sell keyboads with ZMK open source firmware, where official way to change key map is making github repository with a fork, editing it and using github to build it. I wish I was making this up.<p>So yes, seems like github has joined twitter and whatsapp as  another thing the world works on.</div><br/></div></div></div></div><div id="38271849" class="c"><input type="checkbox" id="c-38271849" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38274358">prev</a><span>|</span><a href="#38273953">next</a><span>|</span><label class="collapse" for="c-38271849">[-]</label><label class="expand" for="c-38271849">[11 more]</label></div><br/><div class="children"><div class="content">This looks enough like rust that I&#x27;m not sure why I&#x27;d pick it over rust. What would be some concrete programs that would be difficult or tedious to write in rust and easy in inko? Could really use a section on &quot;here&#x27;s rust code you&#x27;d like to write but compiler won&#x27;t let you&quot; and how inko works.</div><br/><div id="38274360" class="c"><input type="checkbox" id="c-38274360" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#38271849">parent</a><span>|</span><a href="#38271983">next</a><span>|</span><label class="collapse" for="c-38274360">[-]</label><label class="expand" for="c-38274360">[1 more]</label></div><br/><div class="children"><div class="content">From a quick glance, a &quot;simpler&quot; Rust with an Erlang like concurrency model seems like a very appealing language. It&#x27;s also a sentiment I&#x27;ve seen repeated quite often.</div><br/></div></div><div id="38271983" class="c"><input type="checkbox" id="c-38271983" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38271849">parent</a><span>|</span><a href="#38274360">prev</a><span>|</span><a href="#38271900">next</a><span>|</span><label class="collapse" for="c-38271983">[-]</label><label class="expand" for="c-38271983">[4 more]</label></div><br/><div class="children"><div class="content">Generally speaking: if you&#x27;re looking for a non-systems language that gives you similar guarantees as Rust, but with a lower mental cost, and you can stomach the drawbacks of a young language, then Inko might be worth looking into.<p>As for comparisons to actual Rust programs: I haven&#x27;t done any side-by-side comparisons, mainly because I worry they may come across as a bit disingenuous, as you&#x27;d never pick examples that make your language look worse than whatever language you&#x27;re comparing to.</div><br/><div id="38273414" class="c"><input type="checkbox" id="c-38273414" checked=""/><div class="controls bullet"><span class="by">Varriount</span><span>|</span><a href="#38271849">root</a><span>|</span><a href="#38271983">parent</a><span>|</span><a href="#38273468">next</a><span>|</span><label class="collapse" for="c-38273414">[-]</label><label class="expand" for="c-38273414">[1 more]</label></div><br/><div class="children"><div class="content">I know this is a purely subjective opinion, but I feel that Inko looks a lot nicer than Rust, from a syntactic perspective. I could never get over how many symbols and keywords Rust has, not to mention how it requires semicolons (despite them being unnecessary in all but a few cases).</div><br/></div></div><div id="38273468" class="c"><input type="checkbox" id="c-38273468" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#38271849">root</a><span>|</span><a href="#38271983">parent</a><span>|</span><a href="#38273414">prev</a><span>|</span><a href="#38271900">next</a><span>|</span><label class="collapse" for="c-38273468">[-]</label><label class="expand" for="c-38273468">[2 more]</label></div><br/><div class="children"><div class="content">This is a good selling point because my main issue with Rust is the mental overload that comes with handholding myself throughout the development process.<p>I&#x27;m sure a lot of people just roll out of bed and naturally dance with the borrow checker like it&#x27;s an old friend, but to me it&#x27;s an hindrance. Maybe because I don&#x27;t just only do Rust. I do plenty of other languages, or my brain is inferior, or both.</div><br/><div id="38274409" class="c"><input type="checkbox" id="c-38274409" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#38271849">root</a><span>|</span><a href="#38273468">parent</a><span>|</span><a href="#38271900">next</a><span>|</span><label class="collapse" for="c-38274409">[-]</label><label class="expand" for="c-38274409">[1 more]</label></div><br/><div class="children"><div class="content">I feel that using Rust for low level stuff, all the mental overhead is worth it compared to using C: dance with the borrow checker, or get bitten by subtle bugs -- you choose :)<p>Using Rust for non-pref-critical web apps is a nice exercise, and yields a super fast and efficient app. But in that case the mental overhead is not worth it compared to a language and developer experience like Kotlin.</div><br/></div></div></div></div></div></div><div id="38271900" class="c"><input type="checkbox" id="c-38271900" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38271849">parent</a><span>|</span><a href="#38271983">prev</a><span>|</span><a href="#38273953">next</a><span>|</span><label class="collapse" for="c-38271900">[-]</label><label class="expand" for="c-38271900">[5 more]</label></div><br/><div class="children"><div class="content">You’ll note lifetimes aren’t a thing here, which is enough for me to give it a shot.</div><br/><div id="38272081" class="c"><input type="checkbox" id="c-38272081" checked=""/><div class="controls bullet"><span class="by">singingboyo</span><span>|</span><a href="#38271849">root</a><span>|</span><a href="#38271900">parent</a><span>|</span><a href="#38273953">next</a><span>|</span><label class="collapse" for="c-38272081">[-]</label><label class="expand" for="c-38272081">[4 more]</label></div><br/><div class="children"><div class="content">Apparently it&#x27;s just moving that to runtime, which is kind of terrifying and misses the point. &quot;If the owned value is dropped but references to it still exist, a panic is produced and the program is aborted; protecting you against use-after-free errors.&quot; [1]<p>That &quot;protection&quot; seems pretty worthless to me, since a non-trivial number of the use-after-free bugs I&#x27;ve seen are triggered only in rare cases, which means you&#x27;re still crashing in prod.<p>Overall, Rust&#x27;s lifetimes are sometimes hard, but generally only when memory safety is also hard. Inko&#x27;s docs claim it makes it easier to implement self-referential data structures without unsafe&#x2F;raw pointers, but to be honest the references here don&#x27;t seem significantly safer than raw pointers.<p>[1] <a href="https:&#x2F;&#x2F;docs.inko-lang.org&#x2F;manual&#x2F;latest&#x2F;getting-started&#x2F;memory-management&#x2F;#references-and-borrowing" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.inko-lang.org&#x2F;manual&#x2F;latest&#x2F;getting-started&#x2F;mem...</a></div><br/><div id="38273812" class="c"><input type="checkbox" id="c-38273812" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#38271849">root</a><span>|</span><a href="#38272081">parent</a><span>|</span><a href="#38272111">next</a><span>|</span><label class="collapse" for="c-38273812">[-]</label><label class="expand" for="c-38273812">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like very useful protection to me: yes, you can have crashes in prod, but those are unexploitable at least. That&#x27;s a very big deal in some systems.</div><br/></div></div><div id="38272111" class="c"><input type="checkbox" id="c-38272111" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#38271849">root</a><span>|</span><a href="#38272081">parent</a><span>|</span><a href="#38273812">prev</a><span>|</span><a href="#38274355">next</a><span>|</span><label class="collapse" for="c-38272111">[-]</label><label class="expand" for="c-38272111">[1 more]</label></div><br/><div class="children"><div class="content">So use Rust. I’m not understanding these complaints.</div><br/></div></div></div></div></div></div></div></div><div id="38273953" class="c"><input type="checkbox" id="c-38273953" checked=""/><div class="controls bullet"><span class="by">sudarshnachakra</span><span>|</span><a href="#38271849">prev</a><span>|</span><a href="#38272529">next</a><span>|</span><label class="collapse" for="c-38273953">[-]</label><label class="expand" for="c-38273953">[1 more]</label></div><br/><div class="children"><div class="content">I had been only following this language with some interest, I guess this was born in gitlab not sure if the creator(s) still work there. This is what I&#x27;d have wanted golang to be (albeit with GC when you do not have clear lifetimes).<p>But how would you differentiate yourself from <a href="https:&#x2F;&#x2F;gleam.run" rel="nofollow noreferrer">https:&#x2F;&#x2F;gleam.run</a> which can leverage the OTP, I&#x27;d be more interested if we can adapt Gleam to graalvm isolates so we can leverage the JVM ecosystem.</div><br/></div></div><div id="38272529" class="c"><input type="checkbox" id="c-38272529" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38273953">prev</a><span>|</span><a href="#38273480">next</a><span>|</span><label class="collapse" for="c-38272529">[-]</label><label class="expand" for="c-38272529">[1 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>Show HN: Inko 0.10.0 – build concurrent software with confidence</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32811621">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32811621</a> - Sept 2022 (3 comments)<p><i>Inko 0.5.0 released, featuring the first steps towards a self-hosting compiler</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20988908">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20988908</a> - Sept 2019 (7 comments)<p><i>Inko (a gradually-typed object-oriented programming language) 0.4.0 released</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19893035">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19893035</a> - May 2019 (1 comment)<p><i>Show HN: Inko – A safe and concurrent object-oriented programming language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17702237">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17702237</a> - Aug 2018 (45 comments)</div><br/></div></div><div id="38273480" class="c"><input type="checkbox" id="c-38273480" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#38272529">prev</a><span>|</span><a href="#38272213">next</a><span>|</span><label class="collapse" for="c-38273480">[-]</label><label class="expand" for="c-38273480">[3 more]</label></div><br/><div class="children"><div class="content">An advantage over Erlang and Elixir is that this looks like any language from the C&#x2F;Java family including all the clutter as in<p><pre><code>  import std.fs.file.ReadOnlyFile
  import std.stdio.STDOUT
  
  class async Main {
    fn async main {
</code></pre>
We basically have a zero signal to noise ratio here but it&#x27;s a declarative pattern common to many successful languages so it will make many people feel at home. I think it&#x27;s a good design decision.<p>On the other side I feel like the naming decisions in the error handling section are weird. The expect method breaks my expectations:<p><pre><code>  let file = ReadOnlyFile
    .new(&#x27;README.md&#x27;)
    .expect(&quot;the file doesn&#x27;t exist&quot;)
  
  file
    .read_all(bytes)
    .expect(&#x27;failed to read the file&#x27;)

</code></pre>
Well, no: I expect the file to exist and to be able to read from it.<p>An expect method is common in test libraries and it behaves like an assertion. When I see an expect method I expect it to have a condition and stop the program if it evaluates to false, or propagate the error in any way appropriate to the language. So I expected<p><pre><code>  let file = ReadOnlyFile
    .new(&#x27;README.md&#x27;)
    .fail(&quot;no_ro&quot;, &quot;the file exists but it is not read only&quot;)
    .expect(&quot;created&quot;)
    .expect(&quot;open&quot;) 
</code></pre>
I intentionally changed the probable behavior of the class, that seems not to create a read only file but only to open it. I made it create the file to show a softer version of expect() than an assertion. At least one of them must be true. The implementation of how to chain those methods without failing at the first failed expect() is a detail.<p>And about .unwrap_or(0), what that even means? The linked post [1] hints about a<p><pre><code>  &quot;wrapper type,” like Maybe&lt;T&gt;
</code></pre>
so it&#x27;s an established naming convention in some language but if it works as I think, what about this?<p><pre><code>  .default(0)
</code></pre>
That because unwrap_or seems to ignore errors and return a default. If it doesn&#x27;t, it confirms that it&#x27;s a bad name.<p>[1] <a href="https:&#x2F;&#x2F;joeduffyblog.com&#x2F;2016&#x2F;02&#x2F;07&#x2F;the-error-model&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;joeduffyblog.com&#x2F;2016&#x2F;02&#x2F;07&#x2F;the-error-model&#x2F;</a></div><br/><div id="38273587" class="c"><input type="checkbox" id="c-38273587" checked=""/><div class="controls bullet"><span class="by">filmor</span><span>|</span><a href="#38273480">parent</a><span>|</span><a href="#38272213">next</a><span>|</span><label class="collapse" for="c-38273587">[-]</label><label class="expand" for="c-38273587">[2 more]</label></div><br/><div class="children"><div class="content">`unwrap_or` and `expect` work exactly like they do in Rust. The naming of `expect` works nicely if the argument is the precondition that failed (see <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;error&#x2F;index.html#common-message-styles" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;error&#x2F;index.html#common-messag...</a>), e.g.<p><pre><code>    .expect(&quot;should have opened file&quot;)</code></pre></div><br/><div id="38273938" class="c"><input type="checkbox" id="c-38273938" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#38273480">root</a><span>|</span><a href="#38273587">parent</a><span>|</span><a href="#38272213">next</a><span>|</span><label class="collapse" for="c-38273938">[-]</label><label class="expand" for="c-38273938">[1 more]</label></div><br/><div class="children"><div class="content">With all the respect for a language that succeeded and the evidence that its choices are at least good enough, I think that they got it backwards.<p><pre><code>  expect(&quot;the file is open&quot;)
</code></pre>
is a positive statement.<p><pre><code>  expect(&quot;should have opened file&quot;)
</code></pre>
is a kind of negative and less easy to understand. They should have hinted the developers to use the correct style with a different method<p><pre><code>  should(&quot;have opened file&quot;)
</code></pre>
That said, it did not hinder Rust, maybe it even contributed to its success so it&#x27;s OK even if it feels strange to me. But unwrap is really an awkward word to pick.</div><br/></div></div></div></div></div></div><div id="38272213" class="c"><input type="checkbox" id="c-38272213" checked=""/><div class="controls bullet"><span class="by">pvelagal</span><span>|</span><a href="#38273480">prev</a><span>|</span><a href="#38271225">next</a><span>|</span><label class="collapse" for="c-38272213">[-]</label><label class="expand" for="c-38272213">[2 more]</label></div><br/><div class="children"><div class="content">Inko means “one more” in Telugu, a language spoken in South India (Satya Nadella’s mother tongue). 
So its one more programming language!</div><br/><div id="38273273" class="c"><input type="checkbox" id="c-38273273" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#38272213">parent</a><span>|</span><a href="#38271225">next</a><span>|</span><label class="collapse" for="c-38273273">[-]</label><label class="expand" for="c-38273273">[1 more]</label></div><br/><div class="children"><div class="content">How is Saty even relevant here?</div><br/></div></div></div></div><div id="38271225" class="c"><input type="checkbox" id="c-38271225" checked=""/><div class="controls bullet"><span class="by">thatxliner</span><span>|</span><a href="#38272213">prev</a><span>|</span><a href="#38273019">next</a><span>|</span><label class="collapse" for="c-38271225">[-]</label><label class="expand" for="c-38271225">[14 more]</label></div><br/><div class="children"><div class="content">&gt; Inko allows...moving of the borrowed values while borrows exist<p>Yet<p>&gt; With Inko you never again have to worry about NULL pointers, use-after-free errors, unexpected runtime errors, data races, and other types of errors commonly found in other languages<p>I’m wondering how that can possibly work? Surely the memory safety guarantees are not as strong as Rust’s guarantees.</div><br/><div id="38271627" class="c"><input type="checkbox" id="c-38271627" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38271225">parent</a><span>|</span><a href="#38271593">next</a><span>|</span><label class="collapse" for="c-38271627">[-]</label><label class="expand" for="c-38271627">[9 more]</label></div><br/><div class="children"><div class="content">Inko defaults to heap allocating objects (except for Int, Float, Nil, and Bool), meaning the data pointers point to is in a stable place. Thus, moving them around is just moving a pointer around, not a memcpy of the underlying data. This in turn means it&#x27;s fine to keep references around.<p>To prevent you from _dropping_ a value while references still exist, Inko uses runtime reference counting. Owned values being moved around incurs no reference counting cost, but creating and dropping references does (just a regular increment for most objects, so pretty cheap). When a value is dropped, the reference count is checked, and if it&#x27;s _not_ zero a runtime panic is produced, terminating the program. Refer to <a href="https:&#x2F;&#x2F;docs.inko-lang.org&#x2F;manual&#x2F;latest&#x2F;getting-started&#x2F;memory-management&#x2F;#references-and-borrowing" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.inko-lang.org&#x2F;manual&#x2F;latest&#x2F;getting-started&#x2F;mem...</a> for some additional details.<p>This setup is perfectly memory safe and sound, though in its current form the debugging experience of such errors (although surprisingly rare, but that might just be me) is a bit painful; something I want to improve over time.<p>My long-term vision is to start adding more compile-time checks, such that maybe 80% of the cases where a reference outlives its owned value is detected at compile-time. For the remaining 20% or so, the runtime fallback would be used.<p>In theory this should provide a good balance and only require a fraction of the mental cost associated with Rust. Whether that will work out remains to be seen :)</div><br/><div id="38272009" class="c"><input type="checkbox" id="c-38272009" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38271627">parent</a><span>|</span><a href="#38272717">next</a><span>|</span><label class="collapse" for="c-38272009">[-]</label><label class="expand" for="c-38272009">[4 more]</label></div><br/><div class="children"><div class="content">&gt; To prevent you from _dropping_ a value while references still exist, Inko uses runtime reference counting.<p>&gt; Inko doesn&#x27;t rely on garbage collection to manage memory.<p>It sounds like Inko is in fact garbage collected? I have no problem with a refcounted language, it&#x27;s totally reasonable, but reference counting is garbage collection. Am I misunderstanding something here?</div><br/><div id="38272290" class="c"><input type="checkbox" id="c-38272290" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38272009">parent</a><span>|</span><a href="#38274036">next</a><span>|</span><label class="collapse" for="c-38272290">[-]</label><label class="expand" for="c-38272290">[1 more]</label></div><br/><div class="children"><div class="content">The reference counts are used to prevent dropping a value that still has references to it, but it doesn&#x27;t dictate _when_ that drop takes place. Instead, an owned value is dropped as soon as it goes out of scope, just like Rust.<p>So no, Inko isn&#x27;t garbage collected :)</div><br/></div></div><div id="38274036" class="c"><input type="checkbox" id="c-38274036" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38272009">parent</a><span>|</span><a href="#38272290">prev</a><span>|</span><a href="#38272233">next</a><span>|</span><label class="collapse" for="c-38274036">[-]</label><label class="expand" for="c-38274036">[1 more]</label></div><br/><div class="children"><div class="content">Colloquially, &quot;garbage collection&quot; typically refers to non-deterministic automatic memory management (and&#x2F;or stop-the-world), whereas ref-counting is typically considered deterministic<p>Not really correct in an academic sense, but this isn&#x27;t the only language I&#x27;ve seen talk about ref-counting as something other than garbage collection</div><br/></div></div><div id="38272233" class="c"><input type="checkbox" id="c-38272233" checked=""/><div class="controls bullet"><span class="by">orangea</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38272009">parent</a><span>|</span><a href="#38274036">prev</a><span>|</span><a href="#38272717">next</a><span>|</span><label class="collapse" for="c-38272233">[-]</label><label class="expand" for="c-38272233">[1 more]</label></div><br/><div class="children"><div class="content">In common usage of the terms, &quot;reference counting&quot; and &quot;garbage collection&quot; are completely different.</div><br/></div></div></div></div><div id="38272717" class="c"><input type="checkbox" id="c-38272717" checked=""/><div class="controls bullet"><span class="by">tubthumper8</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38271627">parent</a><span>|</span><a href="#38272009">prev</a><span>|</span><a href="#38271885">next</a><span>|</span><label class="collapse" for="c-38272717">[-]</label><label class="expand" for="c-38272717">[1 more]</label></div><br/><div class="children"><div class="content">How does this work for collection types (ex. dynamic array) that can reallocate after growing? If there&#x27;s multiple references, with at least one being mutable.<p>Is there an extra pointer hop as compared to, for example Rust&#x27;s Vec? i.e. the value on the stack is a pointer to some heap data that has a pointer to the actual array data.</div><br/></div></div><div id="38271885" class="c"><input type="checkbox" id="c-38271885" checked=""/><div class="controls bullet"><span class="by">tomp</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38271627">parent</a><span>|</span><a href="#38272717">prev</a><span>|</span><a href="#38271593">next</a><span>|</span><label class="collapse" for="c-38271885">[-]</label><label class="expand" for="c-38271885">[3 more]</label></div><br/><div class="children"><div class="content">The first bold claim I see on the page is:<p><i>Deterministic automatic memory management</i><p>but actually looks like it&#x27;s neither deterministic (refcounts!) nor actually memory management (deallocating memory can randomly crash the program?! this is even worse than C, where e.g. <i>use after free</i> can crash a program but then you&#x27;re doing the wrong thing!)</div><br/><div id="38272058" class="c"><input type="checkbox" id="c-38272058" checked=""/><div class="controls bullet"><span class="by">YorickPeterse</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38271885">parent</a><span>|</span><a href="#38274127">next</a><span>|</span><label class="collapse" for="c-38272058">[-]</label><label class="expand" for="c-38272058">[1 more]</label></div><br/><div class="children"><div class="content">The reference counts don&#x27;t dictate when memory is released, that happens when an owned value goes out of scope, just as is the case for Rust. The reference counts are merely used as a form of correctness checking. The result is that allocations, destructors, and deallocations are perfectly deterministic.<p>Deallocating memory itself doesn&#x27;t crash the program either, rather it&#x27;s a check performed _before_ doing so (though that&#x27;s mostly a case of pedantics). This strictly _is_ better than C, because if the program kept running then you&#x27;d trigger undefined behaviour and all sorts of nasty things can happen.<p>If you&#x27;re familiar with Rust, this idea is somewhat similar to Rust&#x27;s RefCell type, which lets you defer borrow checking to the runtime, at the cost of potentially triggering a panic if you try to mutably borrow the cell&#x27;s contents when another borrow already exists.<p>You can also find some backstory on the idea Inko uses from this 2006 paper (mirrored by Inko as the original source is no longer available): <a href="https:&#x2F;&#x2F;inko-lang.org&#x2F;papers&#x2F;ownership.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;inko-lang.org&#x2F;papers&#x2F;ownership.pdf</a></div><br/></div></div><div id="38274127" class="c"><input type="checkbox" id="c-38274127" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38271885">parent</a><span>|</span><a href="#38272058">prev</a><span>|</span><a href="#38271593">next</a><span>|</span><label class="collapse" for="c-38274127">[-]</label><label class="expand" for="c-38274127">[1 more]</label></div><br/><div class="children"><div class="content">How is this worse than C? In C the program.might bit even crash and instead have a remote code execution vulnerability.</div><br/></div></div></div></div></div></div><div id="38271593" class="c"><input type="checkbox" id="c-38271593" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#38271225">parent</a><span>|</span><a href="#38271627">prev</a><span>|</span><a href="#38271286">next</a><span>|</span><label class="collapse" for="c-38271593">[-]</label><label class="expand" for="c-38271593">[1 more]</label></div><br/><div class="children"><div class="content">It looks like there’s a little information here: <a href="https:&#x2F;&#x2F;docs.inko-lang.org&#x2F;manual&#x2F;latest&#x2F;internals&#x2F;compiler&#x2F;#ownership" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.inko-lang.org&#x2F;manual&#x2F;latest&#x2F;internals&#x2F;compiler&#x2F;...</a></div><br/></div></div><div id="38271286" class="c"><input type="checkbox" id="c-38271286" checked=""/><div class="controls bullet"><span class="by">ObscureScience</span><span>|</span><a href="#38271225">parent</a><span>|</span><a href="#38271593">prev</a><span>|</span><a href="#38271249">next</a><span>|</span><label class="collapse" for="c-38271286">[-]</label><label class="expand" for="c-38271286">[2 more]</label></div><br/><div class="children"><div class="content">If the moved value still is not allowed to be read or mutated while borrowed elsewere I don&#x27;t trivially see the issue.</div><br/><div id="38271928" class="c"><input type="checkbox" id="c-38271928" checked=""/><div class="controls bullet"><span class="by">thatxliner</span><span>|</span><a href="#38271225">root</a><span>|</span><a href="#38271286">parent</a><span>|</span><a href="#38271249">next</a><span>|</span><label class="collapse" for="c-38271928">[-]</label><label class="expand" for="c-38271928">[1 more]</label></div><br/><div class="children"><div class="content">But how could you statically check that?</div><br/></div></div></div></div><div id="38271249" class="c"><input type="checkbox" id="c-38271249" checked=""/><div class="controls bullet"><span class="by">skavi</span><span>|</span><a href="#38271225">parent</a><span>|</span><a href="#38271286">prev</a><span>|</span><a href="#38273019">next</a><span>|</span><label class="collapse" for="c-38271249">[-]</label><label class="expand" for="c-38271249">[1 more]</label></div><br/><div class="children"><div class="content">I assumed reference counting and locking would be employed transparently as needed.</div><br/></div></div></div></div><div id="38273019" class="c"><input type="checkbox" id="c-38273019" checked=""/><div class="controls bullet"><span class="by">alecthomas</span><span>|</span><a href="#38271225">prev</a><span>|</span><a href="#38272296">next</a><span>|</span><label class="collapse" for="c-38273019">[-]</label><label class="expand" for="c-38273019">[1 more]</label></div><br/><div class="children"><div class="content">Are there binaries for ivm? If ivm is intended to make it easier to manage inko versions, having to install it via another language&#x27;s toolchain (Rust) seems a bit onerous.<p>Edit: Oh I see, ivm itself relies on Cargo to build inko rather than downloading binaries.<p>Still, it would be nice if it didn&#x27;t need another language&#x27;s toolchain just to use Inko :(</div><br/></div></div><div id="38272296" class="c"><input type="checkbox" id="c-38272296" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#38273019">prev</a><span>|</span><a href="#38271677">next</a><span>|</span><label class="collapse" for="c-38272296">[-]</label><label class="expand" for="c-38272296">[1 more]</label></div><br/><div class="children"><div class="content">Related discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38261982">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38261982</a></div><br/></div></div><div id="38271678" class="c"><input type="checkbox" id="c-38271678" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#38271677">prev</a><span>|</span><label class="collapse" for="c-38271678">[-]</label><label class="expand" for="c-38271678">[3 more]</label></div><br/><div class="children"><div class="content">Seems like a very stripped down Rust.</div><br/><div id="38272752" class="c"><input type="checkbox" id="c-38272752" checked=""/><div class="controls bullet"><span class="by">segfaltnh</span><span>|</span><a href="#38271678">parent</a><span>|</span><a href="#38271792">next</a><span>|</span><label class="collapse" for="c-38272752">[-]</label><label class="expand" for="c-38272752">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that is my read as well, and for a ton of use cases that&#x27;s exactly what I want. Very exciting.</div><br/></div></div><div id="38271792" class="c"><input type="checkbox" id="c-38271792" checked=""/><div class="controls bullet"><span class="by">xyproto</span><span>|</span><a href="#38271678">parent</a><span>|</span><a href="#38272752">prev</a><span>|</span><label class="collapse" for="c-38271792">[-]</label><label class="expand" for="c-38271792">[1 more]</label></div><br/><div class="children"><div class="content">Excellent!</div><br/></div></div></div></div></div></div></div></div></div></body></html>