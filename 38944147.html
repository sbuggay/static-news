<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704963657360" as="style"/><link rel="stylesheet" href="styles.css?v=1704963657360"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://darkcoding.net/software/rust-systemd-memory-remains/">The memory remains: Permanent memory with systemd and a Rust allocator</a> <span class="domain">(<a href="https://darkcoding.net">darkcoding.net</a>)</span></div><div class="subtext"><span>petercooper</span> | <span>51 comments</span></div><br/><div><div id="38945900" class="c"><input type="checkbox" id="c-38945900" checked=""/><div class="controls bullet"><span class="by">boustrophedon</span><span>|</span><a href="#38946395">next</a><span>|</span><label class="collapse" for="c-38945900">[-]</label><label class="expand" for="c-38945900">[6 more]</label></div><br/><div class="children"><div class="content">Without specifying a particular representation[0] on the struct you want to put in &quot;permanent memory&quot;, this seems liable to break any time you recompile the code with different optimization flags, or with a newer or older compiler that may optimize differently, or even if you just change seemingly unrelated code that then triggers or de-triggers some optimization.<p>[0] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;type-layout.html#representations" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;type-layout.html#represe...</a></div><br/><div id="38946790" class="c"><input type="checkbox" id="c-38946790" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#38945900">parent</a><span>|</span><a href="#38946606">next</a><span>|</span><label class="collapse" for="c-38946790">[-]</label><label class="expand" for="c-38946790">[1 more]</label></div><br/><div class="children"><div class="content">The rkyv crate has stable in-memory representations for many types in the Rust standard library: <a href="https:&#x2F;&#x2F;rkyv.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rkyv.org&#x2F;</a><p>I feel like it is the missing piece here because you could do hash table lookups in shared memory, too!</div><br/></div></div><div id="38946606" class="c"><input type="checkbox" id="c-38946606" checked=""/><div class="controls bullet"><span class="by">WirelessGigabit</span><span>|</span><a href="#38945900">parent</a><span>|</span><a href="#38946790">prev</a><span>|</span><a href="#38946630">next</a><span>|</span><label class="collapse" for="c-38946606">[-]</label><label class="expand" for="c-38946606">[1 more]</label></div><br/><div class="children"><div class="content">Yup, at a minimum they should apply #[repr(C)] to avoid this optimization.</div><br/></div></div><div id="38946630" class="c"><input type="checkbox" id="c-38946630" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38945900">parent</a><span>|</span><a href="#38946606">prev</a><span>|</span><a href="#38946395">next</a><span>|</span><label class="collapse" for="c-38946630">[-]</label><label class="expand" for="c-38946630">[3 more]</label></div><br/><div class="children"><div class="content">Worse, it breaks all pointers since you can&#x27;t guarantee `mmap` can give you the same address.</div><br/><div id="38947779" class="c"><input type="checkbox" id="c-38947779" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#38945900">root</a><span>|</span><a href="#38946630">parent</a><span>|</span><a href="#38946395">next</a><span>|</span><label class="collapse" for="c-38947779">[-]</label><label class="expand" for="c-38947779">[2 more]</label></div><br/><div class="children"><div class="content">I think you could fixup the pointers if you tried. It&#x27;s more or less the same problem as compacting GC.</div><br/><div id="38948818" class="c"><input type="checkbox" id="c-38948818" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38945900">root</a><span>|</span><a href="#38947779">parent</a><span>|</span><a href="#38946395">next</a><span>|</span><label class="collapse" for="c-38948818">[-]</label><label class="expand" for="c-38948818">[1 more]</label></div><br/><div class="children"><div class="content">Certainly there are solutions, but they aren&#x27;t transparent, and at some point you have to ask &quot;would serialization be easier?&quot;</div><br/></div></div></div></div></div></div></div></div><div id="38946395" class="c"><input type="checkbox" id="c-38946395" checked=""/><div class="controls bullet"><span class="by">LelouBil</span><span>|</span><a href="#38945900">prev</a><span>|</span><a href="#38946623">next</a><span>|</span><label class="collapse" for="c-38946395">[-]</label><label class="expand" for="c-38946395">[2 more]</label></div><br/><div class="children"><div class="content">At the end, std::thread:: is rendered as std:&lt;thread emoji&gt;:<p>Cool article, I learnt about a new systemd and custom allocators in Rust !</div><br/><div id="38948856" class="c"><input type="checkbox" id="c-38948856" checked=""/><div class="controls bullet"><span class="by">taneliv</span><span>|</span><a href="#38946395">parent</a><span>|</span><a href="#38946623">next</a><span>|</span><label class="collapse" for="c-38948856">[-]</label><label class="expand" for="c-38948856">[1 more]</label></div><br/><div class="children"><div class="content">Ah, it&#x27;s &quot;thread&quot;, thanks! I probably need my morning coffee ... I don&#x27;t know rust to any detail and was wondering what is std::spool.</div><br/></div></div></div></div><div id="38946623" class="c"><input type="checkbox" id="c-38946623" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#38946395">prev</a><span>|</span><a href="#38949245">next</a><span>|</span><label class="collapse" for="c-38946623">[-]</label><label class="expand" for="c-38946623">[11 more]</label></div><br/><div class="children"><div class="content">I had no idea systemd can do that. It sounds kinda exploitable. Is the ability to do that even a good idea?</div><br/><div id="38946865" class="c"><input type="checkbox" id="c-38946865" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#38946623">parent</a><span>|</span><a href="#38946721">next</a><span>|</span><label class="collapse" for="c-38946865">[-]</label><label class="expand" for="c-38946865">[8 more]</label></div><br/><div class="children"><div class="content">The functionality is key for socket-activated daemons which is a Big Idea behind systemd: it can launch daemons on-demand instead of at boot, allowing for faster boot times</div><br/><div id="38947057" class="c"><input type="checkbox" id="c-38947057" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#38946623">root</a><span>|</span><a href="#38946865">parent</a><span>|</span><a href="#38946721">next</a><span>|</span><label class="collapse" for="c-38947057">[-]</label><label class="expand" for="c-38947057">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The functionality is key for socket-activated daemons which is a Big Idea behind systemd<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Launchd#Socket_activation_protocol" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Launchd#Socket_activation_prot...</a></div><br/><div id="38949552" class="c"><input type="checkbox" id="c-38949552" checked=""/><div class="controls bullet"><span class="by">fodkodrasz</span><span>|</span><a href="#38946623">root</a><span>|</span><a href="#38947057">parent</a><span>|</span><a href="#38947290">next</a><span>|</span><label class="collapse" for="c-38949552">[-]</label><label class="expand" for="c-38949552">[1 more]</label></div><br/><div class="children"><div class="content">It is not a launchd innovation, its from the late 1970s: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inetd" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inetd</a></div><br/></div></div><div id="38947290" class="c"><input type="checkbox" id="c-38947290" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#38946623">root</a><span>|</span><a href="#38947057">parent</a><span>|</span><a href="#38949552">prev</a><span>|</span><a href="#38946721">next</a><span>|</span><label class="collapse" for="c-38947290">[-]</label><label class="expand" for="c-38947290">[5 more]</label></div><br/><div class="children"><div class="content">I don’t fully understand the relevance of that paragraph, but launchd and systemd both work this way, both for similar reasons<p>I do believe that launchd came first: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2565780">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2565780</a></div><br/><div id="38947503" class="c"><input type="checkbox" id="c-38947503" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#38946623">root</a><span>|</span><a href="#38947290">parent</a><span>|</span><a href="#38946721">next</a><span>|</span><label class="collapse" for="c-38947503">[-]</label><label class="expand" for="c-38947503">[4 more]</label></div><br/><div class="children"><div class="content">I only linked it because launchd is the source of the &quot;Big Idea&quot;, predating systemd by ~5 years.<p>Perhaps I misunderstood your comment in interpreting it to say socket activation&#x27;s an original systemd concept.</div><br/><div id="38948142" class="c"><input type="checkbox" id="c-38948142" checked=""/><div class="controls bullet"><span class="by">agrover</span><span>|</span><a href="#38946623">root</a><span>|</span><a href="#38947503">parent</a><span>|</span><a href="#38948658">next</a><span>|</span><label class="collapse" for="c-38948142">[-]</label><label class="expand" for="c-38948142">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inetd" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Inetd</a> came out in 1978, if we&#x27;re keeping score.</div><br/><div id="38948222" class="c"><input type="checkbox" id="c-38948222" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#38946623">root</a><span>|</span><a href="#38948142">parent</a><span>|</span><a href="#38948658">next</a><span>|</span><label class="collapse" for="c-38948222">[-]</label><label class="expand" for="c-38948222">[1 more]</label></div><br/><div class="children"><div class="content">True!  But the launchd style of socket activation integrating into the dependency graph of service startup is what&#x27;s novel and alleviates some significant challenges to concurrent starting of interdependent services...</div><br/></div></div></div></div><div id="38948658" class="c"><input type="checkbox" id="c-38948658" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#38946623">root</a><span>|</span><a href="#38947503">parent</a><span>|</span><a href="#38948142">prev</a><span>|</span><a href="#38946721">next</a><span>|</span><label class="collapse" for="c-38948658">[-]</label><label class="expand" for="c-38948658">[1 more]</label></div><br/><div class="children"><div class="content">The person who raised it just said socket-activated daemon is &quot;a Big Idea&quot; behind systemd.  They didn&#x27;t say or imply that systemd invented it, just that systemd is based on that pattern.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38946721" class="c"><input type="checkbox" id="c-38946721" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#38946623">parent</a><span>|</span><a href="#38946865">prev</a><span>|</span><a href="#38948870">next</a><span>|</span><label class="collapse" for="c-38946721">[-]</label><label class="expand" for="c-38946721">[1 more]</label></div><br/><div class="children"><div class="content">Systemd is awesome, but at this point it has so much functionality, that it&#x27;s hard to know what it can do.<p>It needs to _seriously_ improve discoverability and documentation.</div><br/></div></div><div id="38948870" class="c"><input type="checkbox" id="c-38948870" checked=""/><div class="controls bullet"><span class="by">taneliv</span><span>|</span><a href="#38946623">parent</a><span>|</span><a href="#38946721">prev</a><span>|</span><a href="#38949245">next</a><span>|</span><label class="collapse" for="c-38948870">[-]</label><label class="expand" for="c-38948870">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking along the same lines---doesn&#x27;t it allow for &quot;permanent memory leaks&quot;? I mean, if someone has just bugs in their (possibly non-Rust) code, not necessarily trying to exploit anything.</div><br/></div></div></div></div><div id="38949245" class="c"><input type="checkbox" id="c-38949245" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#38946623">prev</a><span>|</span><a href="#38947104">next</a><span>|</span><label class="collapse" for="c-38949245">[-]</label><label class="expand" for="c-38949245">[1 more]</label></div><br/><div class="children"><div class="content">Just represent the data in Arrow memory format, then you can operate on it directly, no ser&#x2F;de required.</div><br/></div></div><div id="38947104" class="c"><input type="checkbox" id="c-38947104" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#38949245">prev</a><span>|</span><a href="#38948559">next</a><span>|</span><label class="collapse" for="c-38947104">[-]</label><label class="expand" for="c-38947104">[5 more]</label></div><br/><div class="children"><div class="content">Why jump through hoops with this special systemd fd when you can just create a regular file somewhere and mmap that?</div><br/><div id="38948679" class="c"><input type="checkbox" id="c-38948679" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#38947104">parent</a><span>|</span><a href="#38947463">next</a><span>|</span><label class="collapse" for="c-38948679">[-]</label><label class="expand" for="c-38948679">[1 more]</label></div><br/><div class="children"><div class="content">I guess they don&#x27;t want something that&#x27;s visible through the file system.  This method gives you anonymous storage that is presumably only accessible to something launched via the same systemd service unit.</div><br/></div></div><div id="38947463" class="c"><input type="checkbox" id="c-38947463" checked=""/><div class="controls bullet"><span class="by">MereInterest</span><span>|</span><a href="#38947104">parent</a><span>|</span><a href="#38948679">prev</a><span>|</span><a href="#38947772">next</a><span>|</span><label class="collapse" for="c-38947463">[-]</label><label class="expand" for="c-38947463">[1 more]</label></div><br/><div class="children"><div class="content">I can’t say I understand that, either.  If the goal is to prevent the mmap’ed file from persisting on disk, using tmpfs handles that.  If the goal is to prevent other processes from accessing the mmap’ed file, the systemd fd store would have the same issue.</div><br/></div></div><div id="38947772" class="c"><input type="checkbox" id="c-38947772" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#38947104">parent</a><span>|</span><a href="#38947463">prev</a><span>|</span><a href="#38949269">next</a><span>|</span><label class="collapse" for="c-38947772">[-]</label><label class="expand" for="c-38947772">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I really don&#x27;t see it. I think it&#x27;s just because systems don&#x27;t come with tmpfs.<p>Of course tmpfs storage does get written to disk via swap.</div><br/></div></div><div id="38949269" class="c"><input type="checkbox" id="c-38949269" checked=""/><div class="controls bullet"><span class="by">tomalbrc</span><span>|</span><a href="#38947104">parent</a><span>|</span><a href="#38947772">prev</a><span>|</span><a href="#38948559">next</a><span>|</span><label class="collapse" for="c-38949269">[-]</label><label class="expand" for="c-38949269">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the &quot;fancy new thing&quot; and rust people having to reinvent the wheel a few dozen times.</div><br/></div></div></div></div><div id="38948559" class="c"><input type="checkbox" id="c-38948559" checked=""/><div class="controls bullet"><span class="by">calamari4065</span><span>|</span><a href="#38947104">prev</a><span>|</span><a href="#38945625">next</a><span>|</span><label class="collapse" for="c-38948559">[-]</label><label class="expand" for="c-38948559">[1 more]</label></div><br/><div class="children"><div class="content">Ah, you simply create a file in memory and map it back to memory.</div><br/></div></div><div id="38945625" class="c"><input type="checkbox" id="c-38945625" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#38948559">prev</a><span>|</span><a href="#38946752">next</a><span>|</span><label class="collapse" for="c-38945625">[-]</label><label class="expand" for="c-38945625">[21 more]</label></div><br/><div class="children"><div class="content">This seems like a very convoluted way to avoid saving a string to a file?</div><br/><div id="38946068" class="c"><input type="checkbox" id="c-38946068" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#38945625">parent</a><span>|</span><a href="#38945746">next</a><span>|</span><label class="collapse" for="c-38946068">[-]</label><label class="expand" for="c-38946068">[1 more]</label></div><br/><div class="children"><div class="content">The article is more a &quot;see that crazy thing you can&quot; do then a &quot;thats a good idea&quot;.<p>It also introduces some neat little known tech.<p>Even if &quot;serializing&quot; state for carrying it over with a controlled restart the File Descriptor Store might still be an interesting case use (in some cases, in others it might a problem). Also you probably would dump bincode or similar for such a &quot;carry over state&quot; serialization, there is very little reason to go with strings.<p>Through there are some major differences:<p>- PRO: This approach works with types which do not implement any serialization mechanism or e.g. cyclic data structure. At least theoretically you could carry in-progress futures over a restart with that (practically it&#x27;s a horror story to try to do so which likely won&#x27;t work most times).<p>- CON: This approach has issues with types containing any form of pointers, references and similar. They all also need to use the special Allocator and then there are issues if after the restart the mem file isn&#x27;t mapped to the exact same address range. This makes it way harder to use, bugs can be subtle introduced and lead errors you normally can&#x27;t have in rust without unsafe code.<p>- PRO: You don&#x27;t have to move&#x2F;copy anything around, so if you e.g. have some huge splatted (i.e. flat in memory) structures this can safe quite a bit on upstart time. (idk. lets say some 1GiB bit mask for some kind of caching)<p>- CON: Debugging the carried over state, or e.g. copying it between systems is not possible or at least much more complex. Reboots might also be an issue (I have to check).<p>In generally for many use-cases this is pointles, and for the times where it&#x27;s not pointless it&#x27;s often either brittle or too limited and in turn better avoided. Through for a very few use-cases it can be a huge boon.</div><br/></div></div><div id="38945746" class="c"><input type="checkbox" id="c-38945746" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38945625">parent</a><span>|</span><a href="#38946068">prev</a><span>|</span><a href="#38946237">next</a><span>|</span><label class="collapse" for="c-38945746">[-]</label><label class="expand" for="c-38945746">[16 more]</label></div><br/><div class="children"><div class="content">Then you&#x27;d have to save and load the file. Here you can, at runtime just write code that works as usual. You can kill the process, and come back in a day, and start a new process that has the same objects saved &amp; ready for use. (Ed: ah, systemd limitation, it will only hold data while restarting, alas, but no concrete reason it has to be so short.)<p>This seems like <i>way</i> less work, seems way less convoluted than writing a whole intermediary layer to serialize objects out into some whatever format on disk, &amp; read them back. The objects are just there, primed, ready to go. It harkens back to single level store days, when disk-backing memory was done by the OS (multics). <a href="https:&#x2F;&#x2F;gunkies.org&#x2F;wiki&#x2F;Single-level_store" rel="nofollow">https:&#x2F;&#x2F;gunkies.org&#x2F;wiki&#x2F;Single-level_store</a><p>Another way of looking at this is as a return to the old days before we made everything convoluted.</div><br/><div id="38945769" class="c"><input type="checkbox" id="c-38945769" checked=""/><div class="controls bullet"><span class="by">Diggsey</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945746">parent</a><span>|</span><a href="#38946727">next</a><span>|</span><label class="collapse" for="c-38945769">[-]</label><label class="expand" for="c-38945769">[8 more]</label></div><br/><div class="children"><div class="content">Not really - you have to completely change your data model to avoid pointers which won&#x27;t save correctly (eg. using a byte array for name in the article) compared to just slapping `#[derive(Serialize, Deserialize)]` on your structs. Not to mention all the extra unsafe code.</div><br/><div id="38947693" class="c"><input type="checkbox" id="c-38947693" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945769">parent</a><span>|</span><a href="#38945994">next</a><span>|</span><label class="collapse" for="c-38947693">[-]</label><label class="expand" for="c-38947693">[1 more]</label></div><br/><div class="children"><div class="content">Except that a lot of use third party code who have structs that aren&#x27;t serializable.<p>I&#x27;m working on a project now where I&#x27;m maintaining half a dozen forks just to add a single line.</div><br/></div></div><div id="38945994" class="c"><input type="checkbox" id="c-38945994" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945769">parent</a><span>|</span><a href="#38947693">prev</a><span>|</span><a href="#38946000">next</a><span>|</span><label class="collapse" for="c-38945994">[-]</label><label class="expand" for="c-38945994">[5 more]</label></div><br/><div class="children"><div class="content">If you changed the global allocator to this... and put the stack on it... any reason you couldn&#x27;t use pointers mostly as normal. You&#x27;d run into issues as soon as a library used mmap, but other than that...</div><br/><div id="38946093" class="c"><input type="checkbox" id="c-38946093" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945994">parent</a><span>|</span><a href="#38946000">next</a><span>|</span><label class="collapse" for="c-38946093">[-]</label><label class="expand" for="c-38946093">[4 more]</label></div><br/><div class="children"><div class="content">If you put the global allocator on this there is a huge load of other issues you can have.<p>Like needing to allocate a fixed amount of memory for your whole program upfront or juggling multiple fds.<p>Or that there is some state you can not carry over even with that and if you try you can easily run into soundness issues.<p>Or that the state saved might be &quot;in between&quot; operations in a very unexpected way and in turn unsound.<p>etc.</div><br/><div id="38947674" class="c"><input type="checkbox" id="c-38947674" checked=""/><div class="controls bullet"><span class="by">throwaway09223</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38946093">parent</a><span>|</span><a href="#38946283">next</a><span>|</span><label class="collapse" for="c-38947674">[-]</label><label class="expand" for="c-38947674">[1 more]</label></div><br/><div class="children"><div class="content">The common place to use something like this would be to mmap an existing external data structure. There are a number of existing mmap-able 0copy k&#x2F;v library&#x2F;db formats that fit the bill here.</div><br/></div></div><div id="38946283" class="c"><input type="checkbox" id="c-38946283" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38946093">parent</a><span>|</span><a href="#38947674">prev</a><span>|</span><a href="#38946000">next</a><span>|</span><label class="collapse" for="c-38946283">[-]</label><label class="expand" for="c-38946283">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Like needing to allocate a fixed amount of memory for your whole program upfront<p>Can I not do the normal virtual memory thing and allocate far more memory than I actually have hardware for?<p>&gt; Or that there is some state you can not carry over even with that and if you try you can easily run into soundness issues.<p>I mean, fair... you&#x27;re going to have to be careful what you save either way but making saving things the default does seem like more of a footgun.<p>&gt; Or that the state saved might be &quot;in between&quot; operations in a very unexpected way and in turn unsound.<p>This applies even if you only use it for some structs? This whole mechanism seems like it would only be sound if it was only used after clean exits.</div><br/><div id="38946386" class="c"><input type="checkbox" id="c-38946386" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38946283">parent</a><span>|</span><a href="#38946000">next</a><span>|</span><label class="collapse" for="c-38946386">[-]</label><label class="expand" for="c-38946386">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sound if it was only used after clean exits.<p>yes, except maybe if a Drop constructor is run unexpectedly on the exit or similar<p>generally I think using it with anything which has pointers and&#x2F;or runs Drop in it is brittle and prone to bugs<p>in turn most things which do not have pointers should be fine with a clean exit<p>and anything which only consists of memory where any bit combination is always valid should always be sound even on a abort (e.g. a `[u8]` allocated directly in that memory region or a `[T]` where `T` only has primitive non-allocating types)</div><br/></div></div></div></div></div></div></div></div><div id="38946000" class="c"><input type="checkbox" id="c-38946000" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945769">parent</a><span>|</span><a href="#38945994">prev</a><span>|</span><a href="#38946727">next</a><span>|</span><label class="collapse" for="c-38946000">[-]</label><label class="expand" for="c-38946000">[1 more]</label></div><br/><div class="children"><div class="content">Easy to cast stones. (Unsafe code especially seems like a very low quality dig to me, for an allocator: theres going to be some low level base to a system. And not like glibc was authored in a memory safe language either.)<p>Sure there&#x27;s problems. Unix won and multics lost, and we have half a century of accrued complexity around that, and a couple weekends of hacking isn&#x27;t going to get us all the way back to a perfect Single Level Store.<p>Is this something we can and should all switch to? No. The costs are high, it&#x27;s not practical. But I think over time, especially with the rise of CXL and rdma resurgent, we&#x27;ll see zero-cooy zero-serialize techniques like this grow back &amp; be huge performance wins for us, be much simpler to handle, even with the adaption we&#x27;ll have to do.</div><br/></div></div></div></div><div id="38946727" class="c"><input type="checkbox" id="c-38946727" checked=""/><div class="controls bullet"><span class="by">throwaway914</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945746">parent</a><span>|</span><a href="#38945769">prev</a><span>|</span><a href="#38945889">next</a><span>|</span><label class="collapse" for="c-38946727">[-]</label><label class="expand" for="c-38946727">[2 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;m misunderstanding what this can be used for, but something I&#x27;d love to see become &quot;perfect&quot; is preserving a GUI application state across reboots&#x2F;logins&#x2F;etc.  Especially with flatpak GUI apps.</div><br/><div id="38947766" class="c"><input type="checkbox" id="c-38947766" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38946727">parent</a><span>|</span><a href="#38945889">next</a><span>|</span><label class="collapse" for="c-38947766">[-]</label><label class="expand" for="c-38947766">[1 more]</label></div><br/><div class="children"><div class="content">This is called image computing and Lisp&#x2F;Smalltalk did it. Emacs has a form of it called undump.<p>I dislike it because it violates the &quot;rule of least power&quot;. Basically, if you never have to validate your internal data, you can never tell it&#x27;s corrupt.</div><br/></div></div></div></div><div id="38945889" class="c"><input type="checkbox" id="c-38945889" checked=""/><div class="controls bullet"><span class="by">autoexecbat</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945746">parent</a><span>|</span><a href="#38946727">prev</a><span>|</span><a href="#38946237">next</a><span>|</span><label class="collapse" for="c-38945889">[-]</label><label class="expand" for="c-38945889">[5 more]</label></div><br/><div class="children"><div class="content">I imagine it would also be an interesting way to recover&#x2F;continue on from a panic&#x2F;segfault</div><br/><div id="38946149" class="c"><input type="checkbox" id="c-38946149" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945889">parent</a><span>|</span><a href="#38945947">next</a><span>|</span><label class="collapse" for="c-38946149">[-]</label><label class="expand" for="c-38946149">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that this can &quot;carry over&quot; structures which are in a unsound state. Especially if abort was done due to runtime sanity&#x2F;soundness checks failing. Or a segfault due to unsound structures etc.<p>As far as I can tell you should only use it for &quot;splatted&quot; data, maybe allowing gaps.<p>E.g. using it to not needing to load again some kind of multiple 1GiB bit mask which are just a 1GiB blob of bits each would probably work grate. Using it on structs which do not contain any pointer (i.e. no Strings, no Vecs, no &amp;str etc.) would work okay. But the moment any pointers are stored in data carried over that way things become a huge mess and are basically fundamentally unsafe as they can easily become unsound.</div><br/></div></div><div id="38945947" class="c"><input type="checkbox" id="c-38945947" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945889">parent</a><span>|</span><a href="#38946149">prev</a><span>|</span><a href="#38946237">next</a><span>|</span><label class="collapse" for="c-38945947">[-]</label><label class="expand" for="c-38945947">[3 more]</label></div><br/><div class="children"><div class="content">Sure..assuming the cause of your segfault was not somewhere in that data...as it surely was</div><br/><div id="38946766" class="c"><input type="checkbox" id="c-38946766" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38945947">parent</a><span>|</span><a href="#38946237">next</a><span>|</span><label class="collapse" for="c-38946766">[-]</label><label class="expand" for="c-38946766">[2 more]</label></div><br/><div class="children"><div class="content">Yes, you&#x27;d need a &quot;safe mode&quot; restart to avoid repeatedly failing and restarting in a tight loop.</div><br/><div id="38947952" class="c"><input type="checkbox" id="c-38947952" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38946766">parent</a><span>|</span><a href="#38946237">next</a><span>|</span><label class="collapse" for="c-38947952">[-]</label><label class="expand" for="c-38947952">[1 more]</label></div><br/><div class="children"><div class="content">So sort of like…copying a good safe state of .data from an ELF file to RAM, clearing .bss in RAM, and jumping to a good safe instruction address, like the entry point as specified by the ELF file?<p>&lt;&#x2F;sarc&gt;</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38946237" class="c"><input type="checkbox" id="c-38946237" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38945625">parent</a><span>|</span><a href="#38945746">prev</a><span>|</span><a href="#38946752">next</a><span>|</span><label class="collapse" for="c-38946237">[-]</label><label class="expand" for="c-38946237">[3 more]</label></div><br/><div class="children"><div class="content">It involves systemd. &#x27;nuff said.<p>Edit: systemd is a religion now, and it&#x27;s blasphemy to speak against it?</div><br/><div id="38948701" class="c"><input type="checkbox" id="c-38948701" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38946237">parent</a><span>|</span><a href="#38947033">next</a><span>|</span><label class="collapse" for="c-38948701">[-]</label><label class="expand" for="c-38948701">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>systemd is a religion now, and it&#x27;s blasphemy to speak against it?</i><p>No, yours is just a low-effort comment that doesn&#x27;t meaningfully add to the discussion.<p>I strongly disliked systemd (and its proponents) for a long time.  Until I realized it just doesn&#x27;t matter, and all the hate it gets is just boring and takes time away from useful things.</div><br/></div></div><div id="38947033" class="c"><input type="checkbox" id="c-38947033" checked=""/><div class="controls bullet"><span class="by">lessbergstein</span><span>|</span><a href="#38945625">root</a><span>|</span><a href="#38946237">parent</a><span>|</span><a href="#38948701">prev</a><span>|</span><a href="#38946752">next</a><span>|</span><label class="collapse" for="c-38947033">[-]</label><label class="expand" for="c-38947033">[1 more]</label></div><br/><div class="children"><div class="content">No, and yes. Systemd is needed to put linux under the thumbs of glowies. The people defending it are paid by your tax dollars</div><br/></div></div></div></div></div></div><div id="38946752" class="c"><input type="checkbox" id="c-38946752" checked=""/><div class="controls bullet"><span class="by">stuaxo</span><span>|</span><a href="#38945625">prev</a><span>|</span><a href="#38948631">next</a><span>|</span><label class="collapse" for="c-38946752">[-]</label><label class="expand" for="c-38946752">[1 more]</label></div><br/><div class="children"><div class="content">Wow, this very interesting - can imagine all sorts of caches etc.</div><br/></div></div><div id="38947062" class="c"><input type="checkbox" id="c-38947062" checked=""/><div class="controls bullet"><span class="by">lessbergstein</span><span>|</span><a href="#38948631">prev</a><span>|</span><label class="collapse" for="c-38947062">[-]</label><label class="expand" for="c-38947062">[1 more]</label></div><br/><div class="children"><div class="content">Just a few Gb of ram and the feds can audit your state when their zeroday crashes your machine, what a deel.</div><br/></div></div></div></div></div></div></div></body></html>