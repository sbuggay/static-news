<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719219674315" as="style"/><link rel="stylesheet" href="styles.css?v=1719219674315"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://brooker.co.za/blog/2024/04/17/formal.html">Formal methods: Just good engineering practice?</a> <span class="domain">(<a href="https://brooker.co.za">brooker.co.za</a>)</span></div><div class="subtext"><span>ot</span> | <span>76 comments</span></div><br/><div><div id="40773070" class="c"><input type="checkbox" id="c-40773070" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40772908">next</a><span>|</span><label class="collapse" for="c-40773070">[-]</label><label class="expand" for="c-40773070">[5 more]</label></div><br/><div class="children"><div class="content">The main issue is that most of these tools like TLA+, live in another dimension, proving something in TLA+, doesn&#x27;t mean when the algorithm gets actually implemented in C, it still maps to TLA+ as proven.<p>Formal methods need to be like SPARK 2014, or DbC, actually part of the programming language, or being able to generate code in the target language, interop with its libraries ecosystem, and have good quality good with performance, that won&#x27;t make people want to remove the generated code and rewrite it manually.</div><br/><div id="40773503" class="c"><input type="checkbox" id="c-40773503" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40773070">parent</a><span>|</span><a href="#40773313">next</a><span>|</span><label class="collapse" for="c-40773503">[-]</label><label class="expand" for="c-40773503">[1 more]</label></div><br/><div class="children"><div class="content">Proving that your algorithmic design is correct (to the degree the proof tool can assure) is already a big help - even if your implementation of the algorithm might still have bugs.<p>At least now you know it&#x27;s just bugs you need to fix, and not a faulty logic to begin with.</div><br/></div></div><div id="40773313" class="c"><input type="checkbox" id="c-40773313" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#40773070">parent</a><span>|</span><a href="#40773503">prev</a><span>|</span><a href="#40773158">next</a><span>|</span><label class="collapse" for="c-40773313">[-]</label><label class="expand" for="c-40773313">[1 more]</label></div><br/><div class="children"><div class="content">TLA+ helps to find errors in your algorithm. It&#x27;s a way easier than trying to model the algorithm in terms of end implementation. Too much complexity and state are introduced because of details.</div><br/></div></div><div id="40773158" class="c"><input type="checkbox" id="c-40773158" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#40773070">parent</a><span>|</span><a href="#40773313">prev</a><span>|</span><a href="#40773183">next</a><span>|</span><label class="collapse" for="c-40773158">[-]</label><label class="expand" for="c-40773158">[1 more]</label></div><br/><div class="children"><div class="content">For that you would need a proper, well-grounded type system and a language that doesn’t stray from it.<p>Some fp languages are close enough to fit that bill; Rust too is going down this path: its type system was built to make a proof, after all.</div><br/></div></div><div id="40773183" class="c"><input type="checkbox" id="c-40773183" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40773070">parent</a><span>|</span><a href="#40773158">prev</a><span>|</span><a href="#40772908">next</a><span>|</span><label class="collapse" for="c-40773183">[-]</label><label class="expand" for="c-40773183">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if that&#x27;s always the case. My understanding is that TLA+ is really designed to prove properties about <i>algorithms</i>. Knowing that complex algorithms are correct is very useful eventually if it doesn&#x27;t provide a correct implementation in a real world language.<p>But TLA+ is a bit of an unusual proof language. I think most of them <i>are</i> like you describe: SPARK, Dafny, F*, CBMC, all the Rust ones, etc. I&#x27;m not sure about the interactive proof languages (Coq et al), they are too complicated for my normal sized brain.</div><br/></div></div></div></div><div id="40772908" class="c"><input type="checkbox" id="c-40772908" checked=""/><div class="controls bullet"><span class="by">Almondsetat</span><span>|</span><a href="#40773070">prev</a><span>|</span><a href="#40771657">next</a><span>|</span><label class="collapse" for="c-40772908">[-]</label><label class="expand" for="c-40772908">[23 more]</label></div><br/><div class="children"><div class="content">In my opinion formal methods are what&#x27;s missing from software engineering to make it a serious engineering discipline. In all other engineering fields you have to produce calculations and &quot;proofs&quot; that your design ought to work. In software engineering everything is basically overcomplicated handwaving.</div><br/><div id="40773484" class="c"><input type="checkbox" id="c-40773484" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#40772908">parent</a><span>|</span><a href="#40773155">next</a><span>|</span><label class="collapse" for="c-40773484">[-]</label><label class="expand" for="c-40773484">[1 more]</label></div><br/><div class="children"><div class="content">My opinion is that too many people think software engineering is not a serious engineering discipline and romanticize other engineering too much.<p>For software that really matters you have standards like MISRA C you also have professional bodies like IEEE, ANSI, you have ISO standards for software development and infrastructure, there is a lot of standards and regulations that you can follow just like in all other fields. There is NIST for security and I could probably go on and on. So it is not &quot;overcomplicated hand-waving&quot;.<p>But no one is going to deal with &quot;implementing formal approach&quot; for &quot;yet another crud app&quot;, they will hire whizz kid who knows latest JS framework and be done with it paying him 1&#x2F;10th of cost of someone who knows more than that.</div><br/></div></div><div id="40773155" class="c"><input type="checkbox" id="c-40773155" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#40772908">parent</a><span>|</span><a href="#40773484">prev</a><span>|</span><a href="#40772987">next</a><span>|</span><label class="collapse" for="c-40773155">[-]</label><label class="expand" for="c-40773155">[1 more]</label></div><br/><div class="children"><div class="content">Software gets used for mission critical things all the time, with the same level of assuredness. What you are complaining about is that people making apps to show you the right advertisement or a website to watch pictures of cats sometimes is buggy and gets deployed without proper tests.<p>Meanwhile almost every medical device under the sun today has software, nuclear powerplants run on software, space missions use software, airplanes drive themselves and land through software, etc.</div><br/></div></div><div id="40772987" class="c"><input type="checkbox" id="c-40772987" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#40772908">parent</a><span>|</span><a href="#40773155">prev</a><span>|</span><a href="#40772983">next</a><span>|</span><label class="collapse" for="c-40772987">[-]</label><label class="expand" for="c-40772987">[15 more]</label></div><br/><div class="children"><div class="content">In theory, your software itself provides the proof that it does what it claims. The proof would directly link to unit tests or integration tests at the meta level.<p>Arguably, software engineering does this much more exhaustively then any other engineering field... To very varying quality output, from masterpieces like SQLite to your average B2B artifact which barely works  despite having 99% coverage.</div><br/><div id="40773649" class="c"><input type="checkbox" id="c-40773649" checked=""/><div class="controls bullet"><span class="by">impossiblefork</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40772987">parent</a><span>|</span><a href="#40773004">next</a><span>|</span><label class="collapse" for="c-40773649">[-]</label><label class="expand" for="c-40773649">[4 more]</label></div><br/><div class="children"><div class="content">No, the proof is the proof that you generate with formal methods.<p>Is exhaustive testing even possible in theory?</div><br/><div id="40773712" class="c"><input type="checkbox" id="c-40773712" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773649">parent</a><span>|</span><a href="#40773004">next</a><span>|</span><label class="collapse" for="c-40773712">[-]</label><label class="expand" for="c-40773712">[3 more]</label></div><br/><div class="children"><div class="content">Not just in theory but actually done:<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html</a></div><br/><div id="40773742" class="c"><input type="checkbox" id="c-40773742" checked=""/><div class="controls bullet"><span class="by">impossiblefork</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773712">parent</a><span>|</span><a href="#40773004">next</a><span>|</span><label class="collapse" for="c-40773742">[-]</label><label class="expand" for="c-40773742">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t agree that that&#x27;s exhaustive testing. Full branch test coverage etc., is normal and sensible and it&#x27;s great, but that&#x27;s very different from having a proof that given certain preconditions, you will have certain postconditions.</div><br/><div id="40773785" class="c"><input type="checkbox" id="c-40773785" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773742">parent</a><span>|</span><a href="#40773004">next</a><span>|</span><label class="collapse" for="c-40773785">[-]</label><label class="expand" for="c-40773785">[1 more]</label></div><br/><div class="children"><div class="content">100% branch coverage means that you&#x27;ve fundamentally covered all potential states your software can enter.<p>What you&#x27;re asking for is literally only possible in theory and entirely pointless in the context of reality, because you cannot guarantee that a device is available at runtime, invalidating any proof. The same applies to any engineering projects, software or otherwise</div><br/></div></div></div></div></div></div></div></div><div id="40773004" class="c"><input type="checkbox" id="c-40773004" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40772987">parent</a><span>|</span><a href="#40773649">prev</a><span>|</span><a href="#40772983">next</a><span>|</span><label class="collapse" for="c-40773004">[-]</label><label class="expand" for="c-40773004">[10 more]</label></div><br/><div class="children"><div class="content">&gt; In theory, your software itself provides the proof that it does what it claims.<p>If you manage to solve the halting problem first.</div><br/><div id="40773527" class="c"><input type="checkbox" id="c-40773527" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773004">parent</a><span>|</span><a href="#40773023">next</a><span>|</span><label class="collapse" for="c-40773527">[-]</label><label class="expand" for="c-40773527">[1 more]</label></div><br/><div class="children"><div class="content">No, you just need to require that somebody who writes the software, also knows why the software halts, and documents the reason properly.</div><br/></div></div><div id="40773023" class="c"><input type="checkbox" id="c-40773023" checked=""/><div class="controls bullet"><span class="by">seethedeaduu</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773004">parent</a><span>|</span><a href="#40773527">prev</a><span>|</span><a href="#40773130">next</a><span>|</span><label class="collapse" for="c-40773023">[-]</label><label class="expand" for="c-40773023">[5 more]</label></div><br/><div class="children"><div class="content">People keep summoning the halting problem in unrelated contexts to handwave things awayvas impossible.</div><br/><div id="40773507" class="c"><input type="checkbox" id="c-40773507" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773023">parent</a><span>|</span><a href="#40773130">next</a><span>|</span><label class="collapse" for="c-40773507">[-]</label><label class="expand" for="c-40773507">[4 more]</label></div><br/><div class="children"><div class="content">Except in this case, where it&#x27;s 100% fitting.</div><br/><div id="40773530" class="c"><input type="checkbox" id="c-40773530" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773507">parent</a><span>|</span><a href="#40773670">next</a><span>|</span><label class="collapse" for="c-40773530">[-]</label><label class="expand" for="c-40773530">[2 more]</label></div><br/><div class="children"><div class="content">It is only fitting if you think of providing the proof as a push button technology. That makes as much sense as thinking of providing the software itself as a push button technology.</div><br/><div id="40773747" class="c"><input type="checkbox" id="c-40773747" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773530">parent</a><span>|</span><a href="#40773670">next</a><span>|</span><label class="collapse" for="c-40773747">[-]</label><label class="expand" for="c-40773747">[1 more]</label></div><br/><div class="children"><div class="content">It has nothing to do with the proof as a push button technology.<p>Adding annotations to the code for example is not a workaround for the halting problem.<p>(Working with a subset that&#x27;s not-turing complete is, but that doesn&#x27;t cover the general case the parent calls for, and is not practical with current software development languages and practices).</div><br/></div></div></div></div><div id="40773670" class="c"><input type="checkbox" id="c-40773670" checked=""/><div class="controls bullet"><span class="by">ulbu</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773507">parent</a><span>|</span><a href="#40773530">prev</a><span>|</span><a href="#40773130">next</a><span>|</span><label class="collapse" for="c-40773670">[-]</label><label class="expand" for="c-40773670">[1 more]</label></div><br/><div class="children"><div class="content">how?</div><br/></div></div></div></div></div></div><div id="40773130" class="c"><input type="checkbox" id="c-40773130" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773004">parent</a><span>|</span><a href="#40773023">prev</a><span>|</span><a href="#40773123">next</a><span>|</span><label class="collapse" for="c-40773130">[-]</label><label class="expand" for="c-40773130">[1 more]</label></div><br/><div class="children"><div class="content">The calculations you do to make sure that the bridge doesn’t collapse also require that the steel matched whatever properties your formula assumes. That doesn’t make the calculations useless.</div><br/></div></div><div id="40773123" class="c"><input type="checkbox" id="c-40773123" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773004">parent</a><span>|</span><a href="#40773130">prev</a><span>|</span><a href="#40773179">next</a><span>|</span><label class="collapse" for="c-40773123">[-]</label><label class="expand" for="c-40773123">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t <i>need</i> to be solved.<p>Continuing the stream of inputs holds no meaning once you&#x27;ve tested every possible permutation (branch coverage) beyond checking for memory leaks. Every software has a finite amount of states it can hold, most developers just erroneously expect some states to be unlikely or impossible to reach.</div><br/></div></div><div id="40773179" class="c"><input type="checkbox" id="c-40773179" checked=""/><div class="controls bullet"><span class="by">pyrale</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773004">parent</a><span>|</span><a href="#40773123">prev</a><span>|</span><a href="#40772983">next</a><span>|</span><label class="collapse" for="c-40773179">[-]</label><label class="expand" for="c-40773179">[1 more]</label></div><br/><div class="children"><div class="content">The halting problem is not an actual issue. It’s a darling of computer science classes, but is you need to prove that your program halts, it’s not that hard to write it in a language subset that is not turing-complete.</div><br/></div></div></div></div></div></div><div id="40772983" class="c"><input type="checkbox" id="c-40772983" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#40772908">parent</a><span>|</span><a href="#40772987">prev</a><span>|</span><a href="#40773032">next</a><span>|</span><label class="collapse" for="c-40772983">[-]</label><label class="expand" for="c-40772983">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In software engineering everything is basically overcomplicated handwaving.<p>No, it is worse than that. There are people who claim the proof is the code itself. Just look at it. These are the same kind of people claiming good code needs no documentation.<p>That is like a bridge engineer saying they need no structural calculation because the stability of the bridge is obvious to a certain kind of bridge nerd if they look at it. Only that civil engineers figured out after a few high profile bridge collapses that &quot;trust me bro&quot; isn&#x27;t good enough and software engineering people are still in the: &quot;trust him, he is a genius&quot;-phase of the field.</div><br/><div id="40773076" class="c"><input type="checkbox" id="c-40773076" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40772983">parent</a><span>|</span><a href="#40773032">next</a><span>|</span><label class="collapse" for="c-40773076">[-]</label><label class="expand" for="c-40773076">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There are people who claim the proof is the code itself.<p>Yet this is what emerges when you write a sufficiently detailed proof.<p>The more detail you add to your TLA+ model, the more it looks like just another implementation (albeit untyped, so it&#x27;s pretty easy to slip errors into).</div><br/><div id="40773152" class="c"><input type="checkbox" id="c-40773152" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773076">parent</a><span>|</span><a href="#40773150">next</a><span>|</span><label class="collapse" for="c-40773152">[-]</label><label class="expand" for="c-40773152">[1 more]</label></div><br/><div class="children"><div class="content">In the end, if you want the map to represent the landscape 100% you end up with another landscape.<p>Granted. But engineering is about making sure we don&#x27;t make mistakes and just like in math class a good way to assure that is to take two different paths and arrive at the same place.</div><br/></div></div><div id="40773150" class="c"><input type="checkbox" id="c-40773150" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#40772908">root</a><span>|</span><a href="#40773076">parent</a><span>|</span><a href="#40773152">prev</a><span>|</span><a href="#40773032">next</a><span>|</span><label class="collapse" for="c-40773150">[-]</label><label class="expand" for="c-40773150">[1 more]</label></div><br/><div class="children"><div class="content">We should have a TLA+^2 then. 
Oh the complexity has to be expressed anyway? Uh
Oh and users mostly rather suffer from bugs than give up complex desires and features? Uh
We’re doomed haha</div><br/></div></div></div></div></div></div></div></div><div id="40771657" class="c"><input type="checkbox" id="c-40771657" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#40772908">prev</a><span>|</span><a href="#40773381">next</a><span>|</span><label class="collapse" for="c-40771657">[-]</label><label class="expand" for="c-40771657">[19 more]</label></div><br/><div class="children"><div class="content">I like the quote:<p><pre><code>  “It would be well if engineering were less generally thought of, and even defined, as the art of constructing. In a certain important sense it is rather the art of not constructing; or, to define it rudely but not inaptly, it is the art of doing that well with one dollar, which any bungler can do with two after a fashion.” Arthur Wellington
</code></pre>
Where is the boundary between finance and engineering? And Engineering is also about making optimal tradeoffs in other dimensions (he mentions time, performance, scalability, sustainability, and efficiency).</div><br/><div id="40771937" class="c"><input type="checkbox" id="c-40771937" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40771657">parent</a><span>|</span><a href="#40772297">next</a><span>|</span><label class="collapse" for="c-40771937">[-]</label><label class="expand" for="c-40771937">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen this stated &quot;Any idiot can build a bridge that stands, but it takes an engineer to build a bridge that <i>barely</i> stands.&quot;</div><br/><div id="40772473" class="c"><input type="checkbox" id="c-40772473" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40771937">parent</a><span>|</span><a href="#40772070">next</a><span>|</span><label class="collapse" for="c-40772473">[-]</label><label class="expand" for="c-40772473">[1 more]</label></div><br/><div class="children"><div class="content">In reality, it&#x27;s more like: any idiot can build a bridge that, in some places, is 5X as strong as it will ever need to be, in other places 2X as strong, and in a couple places only 0.8X as strong as it will ever need to be.<p>It takes the engineer to build it so that every part is 1.25X as strong as it will ever need to be, consistently everywhere.<p>To the idiot, that then looks like it is barely standing, because some parts are 4X weaker than he would have made them, based on bad intutition.</div><br/></div></div><div id="40772070" class="c"><input type="checkbox" id="c-40772070" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40771937">parent</a><span>|</span><a href="#40772473">prev</a><span>|</span><a href="#40772503">next</a><span>|</span><label class="collapse" for="c-40772070">[-]</label><label class="expand" for="c-40772070">[5 more]</label></div><br/><div class="children"><div class="content">In modern days we generally stand in awe of ancient structures that have stood for millennia.<p>But in some sense, many ancient engineers had to drastically overbuild their bridges and other structures because they didn&#x27;t have the tools to know what the &quot;barely stands&quot; threshold was, so they had to build for a big margin of error when they lacked the tools of precision.</div><br/><div id="40772419" class="c"><input type="checkbox" id="c-40772419" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40772070">parent</a><span>|</span><a href="#40772241">next</a><span>|</span><label class="collapse" for="c-40772419">[-]</label><label class="expand" for="c-40772419">[1 more]</label></div><br/><div class="children"><div class="content">Most of those old bridges are not suitable for modern needs. They are nice to look at, but cannot carry a truck, or can only at very low speeds. Or buildings without restrooms. Just adding light to old things often destroys the beauty people praise them for</div><br/></div></div><div id="40772241" class="c"><input type="checkbox" id="c-40772241" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40772070">parent</a><span>|</span><a href="#40772419">prev</a><span>|</span><a href="#40772503">next</a><span>|</span><label class="collapse" for="c-40772241">[-]</label><label class="expand" for="c-40772241">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, imagine digging up red clay, throwing it in a charcoal furnace, and then hammering it for a while. You can tell you&#x27;re getting wrought iron, but would you know from one batch to the next whether it&#x27;s good?</div><br/><div id="40772443" class="c"><input type="checkbox" id="c-40772443" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40772241">parent</a><span>|</span><a href="#40772503">next</a><span>|</span><label class="collapse" for="c-40772443">[-]</label><label class="expand" for="c-40772443">[2 more]</label></div><br/><div class="children"><div class="content">They did that with specification like &quot;use red clay from this village&quot; with &quot;charcoal from that city&quot; in this furnace.<p>It is not scalable, but the quality is quite stable across batches</div><br/><div id="40773114" class="c"><input type="checkbox" id="c-40773114" checked=""/><div class="controls bullet"><span class="by">fmajid</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40772443">parent</a><span>|</span><a href="#40772503">next</a><span>|</span><label class="collapse" for="c-40773114">[-]</label><label class="expand" for="c-40773114">[1 more]</label></div><br/><div class="children"><div class="content">And then you have the rebar-free Roman lime-pozzolan concrete used in the Pantheon, still standing after 2000 years.</div><br/></div></div></div></div></div></div></div></div><div id="40772503" class="c"><input type="checkbox" id="c-40772503" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40771937">parent</a><span>|</span><a href="#40772070">prev</a><span>|</span><a href="#40772297">next</a><span>|</span><label class="collapse" for="c-40772503">[-]</label><label class="expand" for="c-40772503">[2 more]</label></div><br/><div class="children"><div class="content">On the other hand, in many cases what&#x27;s defined as the &quot;bare minimum&quot; ends up being more than expected. The corner-cutting approach ends up pricier than the thorough approach in the long run, because it must be constantly adjusted if not entirely re-done.<p>e.g. building a bridge to support a city&#x27;s normal traffic density, but the city ends up growing, and the way the bridge was designed makes adding reinforcement difficult. Or building a bridge whose materials start to melt at a certain temperature that&#x27;s above what&#x27;s expected for the region, but climate change raises the temperature over the threshold, so it needs a completely different material.<p>Hence the article&#x27;s point that software companies should invest in formal methods, because while formally proving something is a long process without much reward in the short term, it eliminates an entire class of bugs which, in some long-term projects, makes it worth the effort.</div><br/><div id="40772690" class="c"><input type="checkbox" id="c-40772690" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40772503">parent</a><span>|</span><a href="#40772297">next</a><span>|</span><label class="collapse" for="c-40772690">[-]</label><label class="expand" for="c-40772690">[1 more]</label></div><br/><div class="children"><div class="content">Conversely, we also know that taking longer to build something scalable is more expensive than just building cheaper things that accomplish the job now and solving the bigger problems when they’re relevant to the point where it can be the tipping point of success in the first place. In other words, that super reliable bridge that can handle all the growth you throw at it can take longer and too much money and result in a city that fails to have a growth problem in the first place.<p>We know that’s true experientially in both CS (YAGNI) and in the physical spaces (eg Wright brothers constantly iterating with cheap prototypes until they figured out something that worked and SpaceX doing similar things with their prototypes). Iteration = learning. In theory formal methods let you iterate at a cheaper phase of the project. In practice, the methods themselves are very difficult to scale to large projects and these days require you to build the project twice - once for the formal language and then hand-translated to a production language.</div><br/></div></div></div></div></div></div><div id="40772297" class="c"><input type="checkbox" id="c-40772297" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#40771657">parent</a><span>|</span><a href="#40771937">prev</a><span>|</span><a href="#40771745">next</a><span>|</span><label class="collapse" for="c-40772297">[-]</label><label class="expand" for="c-40772297">[1 more]</label></div><br/><div class="children"><div class="content">Even with an unlimited budget and unlimited time, the difference between good and bad engineering is that a bad engineer won&#x27;t know where to apply their talents to ensure things won&#x27;t go wrong in the future. While every discipline in the world is bound by budget and time constraints (even an armchair philosopher has a limited lifespan), that doesn&#x27;t change the essence of the discipline itself.<p>I think of engineering not just as designing and building things, but also knowing where the limitations are of the thing you&#x27;re constructing, whether it&#x27;s purely on paper, in a computer&#x27;s memory, or from brick and mortar.</div><br/></div></div><div id="40771745" class="c"><input type="checkbox" id="c-40771745" checked=""/><div class="controls bullet"><span class="by">juancn</span><span>|</span><a href="#40771657">parent</a><span>|</span><a href="#40772297">prev</a><span>|</span><a href="#40771742">next</a><span>|</span><label class="collapse" for="c-40771745">[-]</label><label class="expand" for="c-40771745">[4 more]</label></div><br/><div class="children"><div class="content">I like that quote.<p>For me, engineering is applied science <i>for money</i>. That&#x27;s the main thing.
Someone is paying for everything you do.<p>We get into it because we care about the how more than the why, but we end up having to deal with the who is paying for this.<p>The boundary is fuzzy, engineering is heavily influenced by finance, otherwise it&#x27;s just a hobby.<p>Formal methods are great or an awful decision depending on wether or not they make economic sense for your product or service at your organization&#x27;s current stage.<p>Amazon EC2? A large, mature org, with products with extremely high fubar potential? Go wild.<p>Your startup where market-fit is not proven? WTF? Are you high? use that money on something else.<p>It&#x27;s like unit testing, it in general makes great sense if the cost of maintaining the tests is lower than the opportunity cost of slowing down. If you&#x27;re prototyping something that you&#x27;ll likely throw away, it may be a bad idea. Once it proves value, you better build a decent test harness.<p>Startups take technical debt because it&#x27;s cheap when the market fit is not demonstrated (you pay it back later once you have succeeded somewhat).<p>It&#x27;s a rational decision.<p>You don&#x27;t need perfection if you&#x27;re building the wrong thing, first you figure out if what you&#x27;re building makes sense, then you decide in what to invest.<p>On the other hand, if you&#x27;re building a deep space probe, a large scale distributed system for hire, or any other thing were a failure is BAD (with capital letters), the extra cost of ensuring correctness is well worth it.</div><br/><div id="40771952" class="c"><input type="checkbox" id="c-40771952" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40771745">parent</a><span>|</span><a href="#40772368">next</a><span>|</span><label class="collapse" for="c-40771952">[-]</label><label class="expand" for="c-40771952">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The boundary is fuzzy, engineering is heavily influenced by finance, otherwise it&#x27;s just a hobby.<p>This rings true for me. I&#x27;m interested in learning things, e.g. how processes work in Windows NT kernel, or how to write a custom memory allocator, instead of creating a product. I do have some passion for a certain product but it is highly personal and won&#x27;t be shared.<p>Quoting David Cutler, &quot;What I really wanted to do was work on computers, not apply them to problems&quot;. I wish I knew this when I was younger.</div><br/></div></div><div id="40772368" class="c"><input type="checkbox" id="c-40772368" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40771745">parent</a><span>|</span><a href="#40771952">prev</a><span>|</span><a href="#40772219">next</a><span>|</span><label class="collapse" for="c-40772368">[-]</label><label class="expand" for="c-40772368">[1 more]</label></div><br/><div class="children"><div class="content">I feel like money is too narrow here, but there does need to be some kind of budget involved.  For instance, getting the energy output of a nuclear fusion reactor to exceed the energy input is an engineering problem.  An energy budget, in that case.</div><br/></div></div><div id="40772219" class="c"><input type="checkbox" id="c-40772219" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40771745">parent</a><span>|</span><a href="#40772368">prev</a><span>|</span><a href="#40771742">next</a><span>|</span><label class="collapse" for="c-40772219">[-]</label><label class="expand" for="c-40772219">[1 more]</label></div><br/><div class="children"><div class="content">&gt; engineering is applied science for money<p>I thought that was science, not engineering! Money determines the subjects researched, how they&#x27;re researched, and the results, right?</div><br/></div></div></div></div><div id="40771742" class="c"><input type="checkbox" id="c-40771742" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40771657">parent</a><span>|</span><a href="#40771745">prev</a><span>|</span><a href="#40772449">next</a><span>|</span><label class="collapse" for="c-40771742">[-]</label><label class="expand" for="c-40771742">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely it is about trade offs, sometimes bugs are just an inconvenience and time-to-market is more important. But bugs can result in lost business and even lost lives, for example UK Post Office Horizon. Horizon was built (bungled) on the cheap, but the overall cost of that saving must be dwarfed by the financial cost of the resultant scandal.</div><br/><div id="40772212" class="c"><input type="checkbox" id="c-40772212" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40771657">root</a><span>|</span><a href="#40771742">parent</a><span>|</span><a href="#40772449">next</a><span>|</span><label class="collapse" for="c-40772212">[-]</label><label class="expand" for="c-40772212">[1 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t that system claimed &#x27;infalliable&#x27;? That outsourced sweatshop must know some CS secrets we don&#x27;t</div><br/></div></div></div></div><div id="40772449" class="c"><input type="checkbox" id="c-40772449" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40771657">parent</a><span>|</span><a href="#40771742">prev</a><span>|</span><a href="#40771923">next</a><span>|</span><label class="collapse" for="c-40772449">[-]</label><label class="expand" for="c-40772449">[1 more]</label></div><br/><div class="children"><div class="content">You can kill people with bad finance and go to jail; same as engineering.</div><br/></div></div><div id="40771923" class="c"><input type="checkbox" id="c-40771923" checked=""/><div class="controls bullet"><span class="by">photochemsyn</span><span>|</span><a href="#40771657">parent</a><span>|</span><a href="#40772449">prev</a><span>|</span><a href="#40773381">next</a><span>|</span><label class="collapse" for="c-40771923">[-]</label><label class="expand" for="c-40771923">[1 more]</label></div><br/><div class="children"><div class="content">Depends on whether the systems you&#x27;re working on have catastrophic failure modes, or not.  In terms of how the responsible parties behave in both realms, it comes down to whether the costs of catastrophic failure can be externalized or not (e.g. government bailouts for chaos in in subprime mortgages or natural gas futures markets, Price-Anderson indemnity for nuclear reactor meltdowns).  Miscalculation (see Boeing) can be disastrous.<p>Now if you can&#x27;t externalize the costs of catastrophic failure, that will be the fundamental constraint on your engineering &#x2F; finance strategy.  If you really don&#x27;t want your network to be breached, you&#x27;ll build it around security features, not try to hack them on after the fact.  I like to think SpaceX, as a private company without the kind of political heavyweight backers that ULA enjoyed, thus put a lot more effort into avoiding the kind of problems ULA is currently having, for just that reason.<p>Conclusion: take away the government safety nets, and both engineering and finance will perform better?  Now about Silicon Valley Bank...</div><br/></div></div></div></div><div id="40773381" class="c"><input type="checkbox" id="c-40773381" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#40771657">prev</a><span>|</span><a href="#40772632">next</a><span>|</span><label class="collapse" for="c-40773381">[-]</label><label class="expand" for="c-40773381">[1 more]</label></div><br/><div class="children"><div class="content">I think we might potentially be looking at this backwards. There is a great talk by Jack Rusher [1] on why having really slow iteration loops and being too disconnected from running programs creates a desire for theorem proving because it becomes the faster way to arrive at a correct solution.<p>I am of the belief that we need to return to modifying live environments instead of sending code through a lengthy build pipeline. Instead of trying to make live environments secure and durable we got scared and now we have modern CI&#x2F;CD.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8Ab3ArE8W3s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8Ab3ArE8W3s</a></div><br/></div></div><div id="40772632" class="c"><input type="checkbox" id="c-40772632" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#40773381">prev</a><span>|</span><a href="#40772458">next</a><span>|</span><label class="collapse" for="c-40772632">[-]</label><label class="expand" for="c-40772632">[3 more]</label></div><br/><div class="children"><div class="content">In my opinion, most developers should be using bounded model checking if available for their language &#x2F; platform. This is certainly true for C, Rust, Java, and others.<p>I consider bounded model checking to be &quot;formal methods lite&quot;. It provides most of the benefits at a lower cost of entry than using a proof assistant or building constructive proofs. Really, there&#x27;s little added overhead. Perhaps 30% to 40% more time to build out the function contracts and model checking. Given that this overhead more or less prevents errors that would likely be introduced without it, I think it&#x27;s a reasonable investment.<p>TLA+ is certainly related, since it uses an SMT solver at its base. I see it as useful for designing algorithms and protocols. A tool like CBMC or Kani provides similar guarantees at the source code level. It&#x27;s not perfect, as currently CProver does not have direct threading support, but with a reasonable application of method shadowing and function contracts, even things like threading can be anticipated. Using a bounded model checker effectively means changing the design of software to work best with it. This is little different than using concepts like TDD or continuous integration.</div><br/><div id="40772677" class="c"><input type="checkbox" id="c-40772677" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40772632">parent</a><span>|</span><a href="#40772458">next</a><span>|</span><label class="collapse" for="c-40772677">[-]</label><label class="expand" for="c-40772677">[2 more]</label></div><br/><div class="children"><div class="content">In my experience traditional property checks are pretty difficult to write already (30-40%). I get the sense that a bounded model check would be even more expensive than that, probably into the 2-3x range if not more. I’m talking about meaningfully complex logic, not very simple things.</div><br/><div id="40772894" class="c"><input type="checkbox" id="c-40772894" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#40772632">root</a><span>|</span><a href="#40772677">parent</a><span>|</span><a href="#40772458">next</a><span>|</span><label class="collapse" for="c-40772894">[-]</label><label class="expand" for="c-40772894">[1 more]</label></div><br/><div class="children"><div class="content">It would be interesting to have a workbook of what people consider valuable examples of issues we are trying to solve. Like property checks are sometimes easy to write, when your property aligns well with property checking models! But then time-based stuff like TLA+ ends up working way better, sometimes.<p>There are plenty of canonical examples out there for resolving some issues with types, and having a bunch of one-pagers on issues people hit that people might or might not want to tackle with some flavor of formal method.</div><br/></div></div></div></div></div></div><div id="40772458" class="c"><input type="checkbox" id="c-40772458" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40772632">prev</a><span>|</span><a href="#40773516">next</a><span>|</span><label class="collapse" for="c-40772458">[-]</label><label class="expand" for="c-40772458">[1 more]</label></div><br/><div class="children"><div class="content">Non-software engineering doesn&#x27;t excessively use formal methods. Only where required. (Like where a system is tightly optimized.)<p>For instance, in electronic engineering, you don&#x27;t use the most accurate model of a diode at all times. Sometimes it&#x27;s just a one-way valve. Sometimes, it&#x27;s just one-way valve with a 0.7V drop (if silicon).<p>In mass production, you will not get the accurate parts needed for the most formal model to be justifiable, and the cost of those parts would not be justified in most of the circuitry.</div><br/></div></div><div id="40773516" class="c"><input type="checkbox" id="c-40773516" checked=""/><div class="controls bullet"><span class="by">treprinum</span><span>|</span><a href="#40772458">prev</a><span>|</span><a href="#40772992">next</a><span>|</span><label class="collapse" for="c-40773516">[-]</label><label class="expand" for="c-40773516">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Beware of bugs in the above code; I have only proved it correct, not tried it. &quot; -- Donald Knuth</div><br/></div></div><div id="40772992" class="c"><input type="checkbox" id="c-40772992" checked=""/><div class="controls bullet"><span class="by">DoingIsLearning</span><span>|</span><a href="#40773516">prev</a><span>|</span><a href="#40772053">next</a><span>|</span><label class="collapse" for="c-40772992">[-]</label><label class="expand" for="c-40772992">[2 more]</label></div><br/><div class="children"><div class="content">Is there formal methods &#x27;tooling&#x27; similar to TLA+ that is more targeted to State Machine design and perhaps State Machine Replication?</div><br/><div id="40773368" class="c"><input type="checkbox" id="c-40773368" checked=""/><div class="controls bullet"><span class="by">nradclif</span><span>|</span><a href="#40772992">parent</a><span>|</span><a href="#40772053">next</a><span>|</span><label class="collapse" for="c-40773368">[-]</label><label class="expand" for="c-40773368">[1 more]</label></div><br/><div class="children"><div class="content">Model checking can be used to formally verify state machines. See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Model_checking" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Model_checking</a>.</div><br/></div></div></div></div><div id="40772053" class="c"><input type="checkbox" id="c-40772053" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#40772992">prev</a><span>|</span><a href="#40772113">next</a><span>|</span><label class="collapse" for="c-40772053">[-]</label><label class="expand" for="c-40772053">[6 more]</label></div><br/><div class="children"><div class="content">I worked for a [Japanese] corporation, that took “formal methods” into overdrive.<p>They made really, really good hardware, but it was <i>extremely</i> painful for us software schlubs.<p>That said, I don’t know if it’s really possible to do really big stuff, with a team, unless you have some degree of formality.<p>Best practices are usually a good place to start, and I would suggest that the degree of necessary formality, is inversely proportional to the experience of the team. If you have a lot of really experienced engineers, in a mature team that has been together a long time, the formality is still there, but doesn’t need to be written down.<p>I usually work alone, or as the sole technical person, in a diverse team. I’m really experienced, and don’t write much down.<p>But I’m also really, really formal. It just doesn’t look like it.</div><br/><div id="40772274" class="c"><input type="checkbox" id="c-40772274" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#40772053">parent</a><span>|</span><a href="#40772281">next</a><span>|</span><label class="collapse" for="c-40772274">[-]</label><label class="expand" for="c-40772274">[2 more]</label></div><br/><div class="children"><div class="content">Formal methods is much more specific than formality and writing things down. There&#x27;s a degree of proof that you achieve with formal methods that you don&#x27;t even with design documents, reviews, and the usual tests.</div><br/><div id="40772328" class="c"><input type="checkbox" id="c-40772328" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#40772053">root</a><span>|</span><a href="#40772274">parent</a><span>|</span><a href="#40772281">next</a><span>|</span><label class="collapse" for="c-40772328">[-]</label><label class="expand" for="c-40772328">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, but also, “writing things down,” was a bit of a euphemism for the many, <i>many</i> aspects of a formal approach.<p>The main issue is that we can get so wrapped up in the process, that we fail to get anything done.<p>It’s a question of balance.</div><br/></div></div></div></div><div id="40772281" class="c"><input type="checkbox" id="c-40772281" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#40772053">parent</a><span>|</span><a href="#40772274">prev</a><span>|</span><a href="#40772745">next</a><span>|</span><label class="collapse" for="c-40772281">[-]</label><label class="expand" for="c-40772281">[1 more]</label></div><br/><div class="children"><div class="content">There are relatively lightweight methods which can be less taxing. For some domains, where requirements are frozen, iterative refinement of specifications to code can be easy and enjoyable. See for instance: <a href="https:&#x2F;&#x2F;raisetools.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;raisetools.github.io&#x2F;</a><p>My hope is that code assistants can make all this much easier by facilitating synthesis, you write the specification, and ML gets you the code. I have a fairly good toy prototype doing such a thing for the subset of a common functional programming language. Obviously, the difficulty is to scale it and make it practical.</div><br/></div></div><div id="40772745" class="c"><input type="checkbox" id="c-40772745" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40772053">parent</a><span>|</span><a href="#40772281">prev</a><span>|</span><a href="#40772076">next</a><span>|</span><label class="collapse" for="c-40772745">[-]</label><label class="expand" for="c-40772745">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t seem like you are describing formal methods. You seem to be describing plain old bureaucracy.</div><br/></div></div><div id="40772076" class="c"><input type="checkbox" id="c-40772076" checked=""/><div class="controls bullet"><span class="by">jxramos</span><span>|</span><a href="#40772053">parent</a><span>|</span><a href="#40772745">prev</a><span>|</span><a href="#40772113">next</a><span>|</span><label class="collapse" for="c-40772076">[-]</label><label class="expand" for="c-40772076">[1 more]</label></div><br/><div class="children"><div class="content">Does it come out instead in PR reviews?</div><br/></div></div></div></div><div id="40772113" class="c"><input type="checkbox" id="c-40772113" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40772053">prev</a><span>|</span><a href="#40771774">next</a><span>|</span><label class="collapse" for="c-40772113">[-]</label><label class="expand" for="c-40772113">[7 more]</label></div><br/><div class="children"><div class="content">I learned some TLA+ and started reading about Coq, but I was pretty disappointed to learn of the &quot;verification gap&quot; between the the algorithm to be delivered in a normal programming language and the manually-restated algorithm that passed the checker. We need to make a checker&#x27;s input language ergonomic enough for daily use and then &quot;synthesize&quot; something that runs efficiently while still being known correct, or make a checker understand everyday programs (which, not being so minimalist, probably have a much larger space of reachable states to check).</div><br/><div id="40773118" class="c"><input type="checkbox" id="c-40773118" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40772113">parent</a><span>|</span><a href="#40772830">next</a><span>|</span><label class="collapse" for="c-40773118">[-]</label><label class="expand" for="c-40773118">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I have the same impression. Anything that proves something about stuff that&#x27;s not the actual running code is nearly useless to me. The code will be changed every single day by developers who may not be familiar with that code. The verification must work on that implementation code.<p>As I see it, the only way to do it properly is to embed the proof in the code like we embed types in the code. For example, we&#x27;ve been able to get rid of NullPointerException completely by using the checker framework, all we need to do is maunually annotate all values that may be null (everything else is assumed non-null, if you try to assign it to null the compiler won&#x27;t compile):<p><pre><code>    @Nullable String getSomething();
</code></pre>
The annotation is not a layer on top of the code, it <i>is</i> code. The compiler can check it (with appropriate extensions).<p>I even played with adding support for dependent types, I am convinced the compiler extension would allow me to do that, but unfortunately I have other things to do.</div><br/></div></div><div id="40772830" class="c"><input type="checkbox" id="c-40772830" checked=""/><div class="controls bullet"><span class="by">ukuina</span><span>|</span><a href="#40772113">parent</a><span>|</span><a href="#40773118">prev</a><span>|</span><a href="#40771774">next</a><span>|</span><label class="collapse" for="c-40772830">[-]</label><label class="expand" for="c-40772830">[5 more]</label></div><br/><div class="children"><div class="content">This is my biggest gripe with verification. I am hoping that LLMs help with inferring intent from a subroutine, then asking the programmer if the inferred intent is complete and correct, and then automatically writing&#x2F;updating a verification harness.</div><br/><div id="40773311" class="c"><input type="checkbox" id="c-40773311" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#40772113">root</a><span>|</span><a href="#40772830">parent</a><span>|</span><a href="#40772888">next</a><span>|</span><label class="collapse" for="c-40773311">[-]</label><label class="expand" for="c-40773311">[1 more]</label></div><br/><div class="children"><div class="content">Have a look at Eureka, they use a combo of LLMs and basic evolutionary methods to automate solving reinforcement learning problems. What&#x27;s interesting is that the only human input is the code for the environment of the RL problem and some fixed scaffolding prompts for the GA.<p>Sounds like it could be a good starting point for something like this.</div><br/></div></div><div id="40772888" class="c"><input type="checkbox" id="c-40772888" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#40772113">root</a><span>|</span><a href="#40772830">parent</a><span>|</span><a href="#40773311">prev</a><span>|</span><a href="#40771774">next</a><span>|</span><label class="collapse" for="c-40772888">[-]</label><label class="expand" for="c-40772888">[3 more]</label></div><br/><div class="children"><div class="content">What makes you think autocomplete on steroids with no internal reasoning capability or representation of knowledge would be at all useful for inferring intent? Or have you been fooled into thinking an LLM is something like Eurisko&#x2F;Cyc?</div><br/><div id="40773330" class="c"><input type="checkbox" id="c-40773330" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#40772113">root</a><span>|</span><a href="#40772888">parent</a><span>|</span><a href="#40772990">next</a><span>|</span><label class="collapse" for="c-40773330">[-]</label><label class="expand" for="c-40773330">[1 more]</label></div><br/><div class="children"><div class="content">Personally I&#x27;m with the parent poster - I use LLMs to help me with intent in new codebases I don&#x27;t understand yet all the time, and empirically they seem to understand it pretty well. Useful, especially when you don&#x27;t have good documentation on hand.</div><br/></div></div><div id="40772990" class="c"><input type="checkbox" id="c-40772990" checked=""/><div class="controls bullet"><span class="by">pxeger1</span><span>|</span><a href="#40772113">root</a><span>|</span><a href="#40772888">parent</a><span>|</span><a href="#40773330">prev</a><span>|</span><a href="#40771774">next</a><span>|</span><label class="collapse" for="c-40772990">[-]</label><label class="expand" for="c-40772990">[1 more]</label></div><br/><div class="children"><div class="content">Because ideally good code should make the intent obvious from the names and comments, so inferring a full description should really just be an autocomplete task.</div><br/></div></div></div></div></div></div></div></div><div id="40771774" class="c"><input type="checkbox" id="c-40771774" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#40772113">prev</a><span>|</span><a href="#40773324">next</a><span>|</span><label class="collapse" for="c-40771774">[-]</label><label class="expand" for="c-40771774">[6 more]</label></div><br/><div class="children"><div class="content">I do often employ the simple whiteboard methods described, but I&#x27;ve never found the energy to learn and use stuff like TLA+. What fields do people find them useful in?</div><br/><div id="40771834" class="c"><input type="checkbox" id="c-40771834" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40771774">parent</a><span>|</span><a href="#40771902">next</a><span>|</span><label class="collapse" for="c-40771834">[-]</label><label class="expand" for="c-40771834">[2 more]</label></div><br/><div class="children"><div class="content">My only time using TLA+ &quot;in anger&quot; was on an embedded system. There was a problem in the hardware portion and our boss wanted proof it was the hardware and not our software. He didn&#x27;t accept any of our evidence that it was a hardware flaw, partially because our tests weren&#x27;t failing 100% of the time. I used TLA+ and ended up with a handful of traces which we were able to recreate with the hardware and some small programs (remove everything our system actually did, just use the busted data bus) to demonstrate the failure, they always failed instead of failing only 90% of the time (shouldn&#x27;t have been needed, it was obvious the hardware was broken). The TLA+ model started off being a reasonable fidelity model of the specified hardware bus, and then I started messing with it (in a deliberate fashion, altering state transitions) until I got traces and invariant violations similar to the real-world hardware.<p>I&#x27;ve used Alloy for similar things, but only after the fact not during the investigation and as a way to learn Alloy.<p>I&#x27;d use them both again (TLA+ especially) if I could convince people it was worth the time, but it can be difficult to get the time to spend on it at work while also meeting other work obligations.<p>I&#x27;ve used TLA+ for some personal projects involving concurrent and distributed systems (toys, nothing notable just playing). I used TLA+ to demonstrate that my design worked as I intended, and then started writing code based on the model.</div><br/><div id="40772077" class="c"><input type="checkbox" id="c-40772077" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#40771774">root</a><span>|</span><a href="#40771834">parent</a><span>|</span><a href="#40771902">next</a><span>|</span><label class="collapse" for="c-40772077">[-]</label><label class="expand" for="c-40772077">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve done something similar twice for embedded systems. First one was modelling a BLE protocol between a mobile device and a piece of hardware to confirm that the protocol the vendor provided would definitively lose messages in specific circumstances. The second was to model the LoRaWAN protocol as a state machine and prove that the SM model I&#x27;d put together couldn&#x27;t deadlock; the C implementation of it modelled the TLA+ model very closely. I was honestly pretty shocked that after getting the first version of the implementation done there was exactly one bug in it and it was a typo (used the wrong variable somewhere) and not a logic error. Other than that the implementation basically worked perfectly first try and just kept running indefinitely.</div><br/></div></div></div></div><div id="40771902" class="c"><input type="checkbox" id="c-40771902" checked=""/><div class="controls bullet"><span class="by">chrsig</span><span>|</span><a href="#40771774">parent</a><span>|</span><a href="#40771834">prev</a><span>|</span><a href="#40771791">next</a><span>|</span><label class="collapse" for="c-40771902">[-]</label><label class="expand" for="c-40771902">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been learning Alloy[0], which I think is probably more practical for most software engineers.  I&#x27;m using it with the goal of documenting and decomposing a legacy system that I&#x27;ve been working with for a number of years.<p>It&#x27;s more geared towards the static elements of the system, and writing a spec feels quite like writing a relational database schema -- mostly because they&#x27;re both expressions of relationships.<p>It seems like a pretty natural path to write a spec in alloy before building out some crud interface.<p>I think there&#x27;s a huge tooling gap though.  Alloy, TLA+ and friends all seem to be very jvm&#x2F;UI centric, really targeting a user who is working in the editors the language ships with.<p>I&#x27;d really love to see more tooling to run model checkers in a CI pipeline, or generate stubs and test cases for various languages.  If that were in place, I think there would be more stickiness to formal methods.<p>I&#x27;ve started writing a Go parser for alloy, in part to learn it better, in part because I know go and want to write some tooling that I think go would be a good implementation language for.  I don&#x27;t know if anything will come of it, but at least having a parser would allow for things like a formatter or code generator.  If I were feeling ambitious, I might try to implement a model checker.<p>[0] <a href="https:&#x2F;&#x2F;alloytools.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;alloytools.org&#x2F;</a></div><br/><div id="40772759" class="c"><input type="checkbox" id="c-40772759" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#40771774">root</a><span>|</span><a href="#40771902">parent</a><span>|</span><a href="#40771791">next</a><span>|</span><label class="collapse" for="c-40772759">[-]</label><label class="expand" for="c-40772759">[1 more]</label></div><br/><div class="children"><div class="content">&gt; tooling to run model checkers in a ci pipeline<p>Helpful to escape the alloy UI:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;elo-enterprises&#x2F;docker-alloy-cli">https:&#x2F;&#x2F;github.com&#x2F;elo-enterprises&#x2F;docker-alloy-cli</a></div><br/></div></div></div></div><div id="40771791" class="c"><input type="checkbox" id="c-40771791" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40771774">parent</a><span>|</span><a href="#40771902">prev</a><span>|</span><a href="#40773324">next</a><span>|</span><label class="collapse" for="c-40771791">[-]</label><label class="expand" for="c-40771791">[1 more]</label></div><br/><div class="children"><div class="content">I find my biggest problem is interfacing with apis from complex dependencies I can&#x27;t control, usually OSes and gui libs. I assume there isn&#x27;t a ton formal methods can do for that unless I set up a VM I can tightly control?</div><br/></div></div></div></div><div id="40773324" class="c"><input type="checkbox" id="c-40773324" checked=""/><div class="controls bullet"><span class="by">verisimi</span><span>|</span><a href="#40771774">prev</a><span>|</span><label class="collapse" for="c-40773324">[-]</label><label class="expand" for="c-40773324">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What is TLA+?
&gt; 
&gt; TLA+ is a formal language for specifying systems used in industry and academia to verify complex distributed and concurrent systems. Among others, the TLA+ methodology is successfully applied at Amazon Web Services, Microsoft, and Oracle.<p><a href="https:&#x2F;&#x2F;conf.tlapl.us&#x2F;home&#x2F;" rel="nofollow">https:&#x2F;&#x2F;conf.tlapl.us&#x2F;home&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>