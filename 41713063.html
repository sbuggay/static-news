<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727859676626" as="style"/><link rel="stylesheet" href="styles.css?v=1727859676626"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wumpus-cave.net/post/2024/10/2024-10-01-death-of-cobol/index.html">COBOL has been “dead” for so long, my grandpa wrote about it</a> <span class="domain">(<a href="https://wumpus-cave.net">wumpus-cave.net</a>)</span></div><div class="subtext"><span>hardburn</span> | <span>255 comments</span></div><br/><div><div id="41714174" class="c"><input type="checkbox" id="c-41714174" checked=""/><div class="controls bullet"><span class="by">flatpepsi17</span><span>|</span><a href="#41713975">next</a><span>|</span><label class="collapse" for="c-41714174">[-]</label><label class="expand" for="c-41714174">[21 more]</label></div><br/><div class="children"><div class="content">Article starts mentioning 4GL&#x27;s - a term I have not heard in a long, long time.<p>COBOL&#x27;s promise was that it was human-like text, so we wouldn&#x27;t need programmers anymore.  A lot like &quot;low code&quot; platforms, and now LLM generated code.<p>The problem is that the average person doesn&#x27;t know how to explain &amp; solve a problem in sufficient detail to get a working solution.  When you get down to breaking down that problem... you become a programmer.<p>The main lesson of COBOL is that it isn&#x27;t the computer interface&#x2F;language that necessitates a programmer.</div><br/><div id="41717893" class="c"><input type="checkbox" id="c-41717893" checked=""/><div class="controls bullet"><span class="by">vishnugupta</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41717669">next</a><span>|</span><label class="collapse" for="c-41717893">[-]</label><label class="expand" for="c-41717893">[3 more]</label></div><br/><div class="children"><div class="content">I agree with you by and large except for this part.<p>&gt; COBOL&#x27;s promise was ... we wouldn&#x27;t need programmers anymore..average person doesn&#x27;t know how to explain &amp; solve a problem<p>COBOL wasn&#x27;t intended to be used by an &quot;average&quot; person but rather those with deep domain knowledge. They would know the business processes so well that they could transcribe it in COBOL with little or no need to learn how the computers worked. In some ways similar to analysts&#x2F;data folks using SQL to communicate with databases.<p>While at it let me share a few more aspects of the top of my head.<p>COBOL and 4GLs in general were primarily intended to be used to build business applications; payroll, banking, HRMS, inventory management and so on. Even within that emphasis was more towards batch processing operations to reduce the burden on people doing routine bulk operations like reconciliation.<p>COBOL harks back to the times when there was no dedicated DBMS software. Which is  why you see so much focus on how files are organised and the extensive verbs around files which somewhat resemble SQL today.</div><br/><div id="41718338" class="c"><input type="checkbox" id="c-41718338" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717893">parent</a><span>|</span><a href="#41718276">next</a><span>|</span><label class="collapse" for="c-41718338">[-]</label><label class="expand" for="c-41718338">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, often it’s hard to find that person with deep domain knowledge, and even when they do, it’s unstructured, they take things for granted they shouldn’t* and the have no appreciation of the demands of formalism.<p>Getting anything you can use to construct a work plan, never mind a detailed feature list, out of clients can be a dark art.<p>*To the point I have repeatedly experienced a point close to the end of the project where they go “What do you mean you don’t handle a case I have failed to mention for the entire duration of the project?”</div><br/></div></div><div id="41718276" class="c"><input type="checkbox" id="c-41718276" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717893">parent</a><span>|</span><a href="#41718338">prev</a><span>|</span><a href="#41717669">next</a><span>|</span><label class="collapse" for="c-41718276">[-]</label><label class="expand" for="c-41718276">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>COBOL and 4GLs in general</i><p>COBOL dates back to 1959, much earlier than 4GLs, and the cited 1992&#x2F;1999 articles make the point that 4GLs were poised to replace the likes of COBOL and FORTRAN when in fact those dinosaurs, or rather nautili since still living, turned out to outlive 4GLs except SQL (when counted as 4GL).</div><br/></div></div></div></div><div id="41717669" class="c"><input type="checkbox" id="c-41717669" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41717893">prev</a><span>|</span><a href="#41717150">next</a><span>|</span><label class="collapse" for="c-41717669">[-]</label><label class="expand" for="c-41717669">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is that the average person doesn&#x27;t know how to explain &amp; solve a problem in sufficient detail to get a working solution.<p>I intuit this also is an intrinsic limit to LLM based approaches to &quot;you don&#x27;t need them expensive programmers no more&quot;<p>with LLMs magically &quot;generating the solution&quot; you move the responsibility for concise expression of the problem up the ladder.<p>and then you &quot;program&quot; in prompts, reviewing the LLM-proposed formalization (&quot;code&quot;).<p>I  other words, the nature of &quot;programming&quot; changes to prompt engineering.  alas you still have to understand formal languages (code)...<p>so there&#x27;ll always be plenty to do for humans who can &quot;math&quot; :-)</div><br/><div id="41718378" class="c"><input type="checkbox" id="c-41718378" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717669">parent</a><span>|</span><a href="#41717859">next</a><span>|</span><label class="collapse" for="c-41718378">[-]</label><label class="expand" for="c-41718378">[1 more]</label></div><br/><div class="children"><div class="content">This is only true to an extend. We have a lot of digitally inclined workers who’re developing programs or scripts to handle a lot of things for them. It’s imperfect and often wildly insecure and inefficient, but unlike any previous no-code or “standard” solution it actually works. Often in conjunction with “standard” solutions.<p>On one hand you’re correct in that there will always be a need for programmers. I really doubt there will be a great need for generalist programmers though. The one area that may survive is the people who’re capable of transforming business needs and rules into code. Which requires a social and analytical skillset for cooperating with non tech people. You’ll also see a demand for skilled programmers at scale and for embedded programming, but the giant work force of generalist developers (and probably web developers once Figma and similar lets designers generate better code) is likely going to become much smaller in the coming decades.<p>Then is basically what the entire office workforce is facing. AI believers have been saying AI would do to the office what robots did to the assembly line for years, but now it actually seems like they’re going to be correct.</div><br/></div></div><div id="41717859" class="c"><input type="checkbox" id="c-41717859" checked=""/><div class="controls bullet"><span class="by">jasfi</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717669">parent</a><span>|</span><a href="#41718378">prev</a><span>|</span><a href="#41717150">next</a><span>|</span><label class="collapse" for="c-41717859">[-]</label><label class="expand" for="c-41717859">[1 more]</label></div><br/><div class="children"><div class="content">A lot of business people want to get something functional that they can sell, and hire a programmer if&#x2F;when they can afford one. That niche is seeing a lot of uptake with regards to LLM based approaches.<p>This works for them because an MVP typically isn&#x27;t a lot of code for what they need, and LLMs have a limited scope within which they can generate something that works.</div><br/></div></div></div></div><div id="41717150" class="c"><input type="checkbox" id="c-41717150" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41717669">prev</a><span>|</span><a href="#41715574">next</a><span>|</span><label class="collapse" for="c-41717150">[-]</label><label class="expand" for="c-41717150">[2 more]</label></div><br/><div class="children"><div class="content">4GL were supposed to be even more of that, with more &quot;human-language-like&quot; constructs added to the language to deal with things besides general logic, simple data structures and arithmetic.<p>The author mentions &quot;4GLs&quot; were all the rage in the early 1990s, but I doubt that that was true outside of the mainframe world. The 4GL movement, as a conscious movement, seems to have always been highly mainframe oriented (the Wikipedia article mentions reducing the amount of punched cards necessary for a program as initial goals). By the 1990s you could categorize many languages as 4GL, but I doubt this term was used with any enthusiasm outside of the mainframe world. It was the opposite of a buzzword.<p>1992 wasn&#x27;t too long ago. Linus Torvalds has already released Linux, and Guido van Rossum was already working on Python. Perl was already gaining popularity, and Haskell also saw it first versions released. The forefront of technology was already shifting from expensive workstations to consumer-grade PCs and language designers gave little thought to 4GL concepts, even when they happened to design something that could qualify as a 4GL for personal computers (e.g. dBase, HyperTalk, AppleScript).<p>I agree that human-like text is a bad idea for most use cases of programming, but I think this is not why the 4GL movement failed, and in fact most 4GLs weren&#x27;t more &quot;natural language-like&quot; than the 3GL COBOL. I think the main problem was that the 4GL movement has never really defined a new generation or anything useful at all. The previously defined generations of language introduced revolutionary changes: translation from friendlier assembly language to machine code (2GL) and compilation (3GL). The only change we can properly define from the loose definition of 4GL is &quot;put more features that used to be external routines or library directly into the language&quot;.<p>This approach worked out relatively well when the language was domain-specific. This is how we got some of the most successful 4GLs like SQL, R and MATLAB. These languages have syntax that deals directly with data tables, statistics and linear algebra directly into the language and became very useful in their own niche. The concept of a general-purpose 4GL, on the other hand, was always destined to boil down to an overly bloated language.</div><br/><div id="41718290" class="c"><input type="checkbox" id="c-41718290" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717150">parent</a><span>|</span><a href="#41715574">next</a><span>|</span><label class="collapse" for="c-41718290">[-]</label><label class="expand" for="c-41718290">[1 more]</label></div><br/><div class="children"><div class="content">dBase and its numerous descendants and competitors (FoxPro, Clipper etc) were <i>extremely</i> popular for line-of-business desktop applications in the 90s. And, yes, they are indeed traditionally categorized as 4GLs - and, given how nebulous the definition always has been anyway, I think that &quot;traditionally categorized&quot; is the most practical definition that you can use here.<p>But, yes, I agree that aside from the generally more verbose and sometimes unwieldy syntax, there wasn&#x27;t really that much to it in practice. I did work with FoxPro, and the reason why it was popular was not because you had to write things like &quot;ACTIVATE WINDOW&quot;, but because it had many things baked directly into the language that nicely covered all the common tasks a pre-SQL data-centric app would need - e.g. a loop that could iterate directly over a table.</div><br/></div></div></div></div><div id="41715574" class="c"><input type="checkbox" id="c-41715574" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41717150">prev</a><span>|</span><a href="#41717103">next</a><span>|</span><label class="collapse" for="c-41715574">[-]</label><label class="expand" for="c-41715574">[1 more]</label></div><br/><div class="children"><div class="content">&gt; COBOL&#x27;s promise was that it was human-like text, so we wouldn&#x27;t need programmers anymore. A lot like &quot;low code&quot; platforms, and now LLM generated code.<p>The more things change, the more they are the same.</div><br/></div></div><div id="41717103" class="c"><input type="checkbox" id="c-41717103" checked=""/><div class="controls bullet"><span class="by">bloppe</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41715574">prev</a><span>|</span><a href="#41714252">next</a><span>|</span><label class="collapse" for="c-41717103">[-]</label><label class="expand" for="c-41717103">[2 more]</label></div><br/><div class="children"><div class="content">Even LLMs have not realized the dream of a natural language computer interface. Everyone who uses them significantly has to read up on prompt engineering and add little things like &quot;explain your steps&quot; or &quot;describe it like I&#x27;m 5&quot; or other oddly specific sequences of characters to get the results they want. That&#x27;s not natural language. It&#x27;s a DSL.</div><br/><div id="41718158" class="c"><input type="checkbox" id="c-41718158" checked=""/><div class="controls bullet"><span class="by">rbanffy</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717103">parent</a><span>|</span><a href="#41714252">next</a><span>|</span><label class="collapse" for="c-41718158">[-]</label><label class="expand" for="c-41718158">[1 more]</label></div><br/><div class="children"><div class="content">Worse. It’s a DSL without a formal specification. You are writing prompts blindly in hopes they trigger the desired behaviour from the LLM.<p>A bit like writing enchantments to force demons to do your bidding.</div><br/></div></div></div></div><div id="41714252" class="c"><input type="checkbox" id="c-41714252" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41717103">prev</a><span>|</span><a href="#41716807">next</a><span>|</span><label class="collapse" for="c-41714252">[-]</label><label class="expand" for="c-41714252">[7 more]</label></div><br/><div class="children"><div class="content">&gt; we wouldn&#x27;t need programmers anymore<p>This blows my mind, since it seems like a fairly low level&#x2F;terse language compared to more modern domain specific languages.<p>But in some sense they were dead right... since (I assume) that what &quot;programming&quot; meant at the time was being able to write raw machine code by hand on paper, and have it work - something few people can or need to do nowadays</div><br/><div id="41715548" class="c"><input type="checkbox" id="c-41715548" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41714252">parent</a><span>|</span><a href="#41715913">next</a><span>|</span><label class="collapse" for="c-41715548">[-]</label><label class="expand" for="c-41715548">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This blows my mind, since it seems like a fairly low level&#x2F;terse language compared to more modern domain specific languages.<p>I have heard others and myself describe COBOL in many ways, most involving creative expletive phraseology which would make a sailor blush, but &quot;low level&#x2F;terse language&quot; is a new one to me.<p>&gt; But in some sense they were dead right... since (I assume) that what &quot;programming&quot; meant at the time was being able to write raw machine code by hand on paper ...<p>LISP and Fortran predate COBOL IIRC.</div><br/><div id="41717920" class="c"><input type="checkbox" id="c-41717920" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41715548">parent</a><span>|</span><a href="#41715913">next</a><span>|</span><label class="collapse" for="c-41717920">[-]</label><label class="expand" for="c-41717920">[3 more]</label></div><br/><div class="children"><div class="content">&gt; LISP and Fortran predate COBOL IIRC.<p>Correct. Fortran, LISP, and COBOL were invented in ‘57, ‘58, and ‘59, respectively.</div><br/><div id="41718395" class="c"><input type="checkbox" id="c-41718395" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717920">parent</a><span>|</span><a href="#41718351">next</a><span>|</span><label class="collapse" for="c-41718395">[-]</label><label class="expand" for="c-41718395">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, but the ideas behind COBOL were older still. Flowmatic, COBOL’s predecessor, dates back to 1955, so it really just depends how you count.<p>Yes. but the ideas behind LISP were older still: Church&#x27;s typed lambda calulus was conceived in 1936.</div><br/></div></div><div id="41718351" class="c"><input type="checkbox" id="c-41718351" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41717920">parent</a><span>|</span><a href="#41718395">prev</a><span>|</span><a href="#41715913">next</a><span>|</span><label class="collapse" for="c-41718351">[-]</label><label class="expand" for="c-41718351">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the ideas behind COBOL were older still. Flowmatic, COBOL’s predecessor, dates back to 1955, so it really just depends how you count.</div><br/></div></div></div></div></div></div><div id="41715913" class="c"><input type="checkbox" id="c-41715913" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41714252">parent</a><span>|</span><a href="#41715548">prev</a><span>|</span><a href="#41716807">next</a><span>|</span><label class="collapse" for="c-41715913">[-]</label><label class="expand" for="c-41715913">[2 more]</label></div><br/><div class="children"><div class="content">Do you mean something other than &quot;terse&quot; here? Or are you perhaps thinking of a different language? I cannot possibly imagine that adjective being used to describe COBOL. It is <i>the</i> #1 textbook example of a verbose language--the opposite of terse.</div><br/><div id="41716004" class="c"><input type="checkbox" id="c-41716004" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#41714174">root</a><span>|</span><a href="#41715913">parent</a><span>|</span><a href="#41716807">next</a><span>|</span><label class="collapse" for="c-41716004">[-]</label><label class="expand" for="c-41716004">[1 more]</label></div><br/><div class="children"><div class="content">What I mean is that it is an attempt to make a high level domain specific language, but is not my modern standards</div><br/></div></div></div></div></div></div><div id="41716807" class="c"><input type="checkbox" id="c-41716807" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41714252">prev</a><span>|</span><a href="#41715040">next</a><span>|</span><label class="collapse" for="c-41716807">[-]</label><label class="expand" for="c-41716807">[1 more]</label></div><br/><div class="children"><div class="content">My company is finally upgrading away from a product that is written in a 4GL language.  This product probably started out on a Unix but was ported to Windows decades ago.  It has both a web and classic VB front ends.<p>All the source code is available and theoretically I could make changes and compile it up.  The language itself is basically just plain procedural code but with SQL mixed right in -- somewhat like DBase or Foxpro but worse.  I think the compiler produces C code and is then compiled with C compiler but it&#x27;s been a while since I looked into it.  Requires a version of Kornshell for Windows as well.</div><br/></div></div><div id="41715040" class="c"><input type="checkbox" id="c-41715040" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41714174">parent</a><span>|</span><a href="#41716807">prev</a><span>|</span><a href="#41713975">next</a><span>|</span><label class="collapse" for="c-41715040">[-]</label><label class="expand" for="c-41715040">[1 more]</label></div><br/><div class="children"><div class="content">Vision 4GL. Like VB but cross platform and with a horribly unstable IDE which would corrupt the source code. (Which was in some kind of binary format not amenable to source control.)</div><br/></div></div></div></div><div id="41713975" class="c"><input type="checkbox" id="c-41713975" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#41714174">prev</a><span>|</span><a href="#41713868">next</a><span>|</span><label class="collapse" for="c-41713975">[-]</label><label class="expand" for="c-41713975">[33 more]</label></div><br/><div class="children"><div class="content">I think of scala in this context. I think that scala is basically dead at this point in the way that COBOL was framed in the article. Yes, there are still many businesses&#x2F;services that have critical components written in scala but current mindshare has cratered for new projects. I only single out scala because I have spent a lot of time with it and have seen it go through the hype cycle (in 2012-14 it seemed like I was constantly seeing doing $X in scala pieces on HN and I almost never see it referenced here anymore). It&#x27;s probably a natural and inevitable phenomenon (and a bit of a shame because scala did get some things right that other mainstream languages still have not).</div><br/><div id="41715449" class="c"><input type="checkbox" id="c-41715449" checked=""/><div class="controls bullet"><span class="by">guessmyname</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41716644">next</a><span>|</span><label class="collapse" for="c-41715449">[-]</label><label class="expand" for="c-41715449">[7 more]</label></div><br/><div class="children"><div class="content">I know a couple of engineering teams at Apple that are working on new projects in Scala, while also maintaining some legacy systems. Some of these projects are quite critical to the company’s ecosystem, e.g. test systems. I’ve spoken with several engineers who helped create these systems years ago; they’re all now in senior management positions. Some still stand by the technology choices made back then, while others are more open when given a chance to reflect. The general consensus is that if Kotlin had been available at the time, or if Swift had been a viable option for back-end services, they definitely wouldn’t have chosen Scala for those projects.</div><br/><div id="41717939" class="c"><input type="checkbox" id="c-41717939" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41715449">parent</a><span>|</span><a href="#41716313">next</a><span>|</span><label class="collapse" for="c-41717939">[-]</label><label class="expand" for="c-41717939">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The general consensus is that if Kotlin had been available at the time, or if Swift had been a viable option for back-end services, they definitely wouldn’t have chosen Scala for those projects.<p>But they were not.</div><br/></div></div><div id="41716313" class="c"><input type="checkbox" id="c-41716313" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41715449">parent</a><span>|</span><a href="#41717939">prev</a><span>|</span><a href="#41716644">next</a><span>|</span><label class="collapse" for="c-41716313">[-]</label><label class="expand" for="c-41716313">[5 more]</label></div><br/><div class="children"><div class="content">Surprised they don&#x27;t use Swift.  Or is that too unstable?  Or is there a on-JVM requirement?</div><br/><div id="41716831" class="c"><input type="checkbox" id="c-41716831" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716313">parent</a><span>|</span><a href="#41716644">next</a><span>|</span><label class="collapse" for="c-41716831">[-]</label><label class="expand" for="c-41716831">[4 more]</label></div><br/><div class="children"><div class="content">My money is that they started these projects before swift was available on linux.<p>I have no evidence to say that apple use Linux, but businesses gotta business so isnt a big bet to make.</div><br/><div id="41718410" class="c"><input type="checkbox" id="c-41718410" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716831">parent</a><span>|</span><a href="#41716863">next</a><span>|</span><label class="collapse" for="c-41718410">[-]</label><label class="expand" for="c-41718410">[1 more]</label></div><br/><div class="children"><div class="content">Even if the servers run MacOS, swift wasn&#x27;t really being aimed at backend usecases for the first few years of its existence....</div><br/></div></div><div id="41716863" class="c"><input type="checkbox" id="c-41716863" checked=""/><div class="controls bullet"><span class="by">mozman</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716831">parent</a><span>|</span><a href="#41718410">prev</a><span>|</span><a href="#41716644">next</a><span>|</span><label class="collapse" for="c-41716863">[-]</label><label class="expand" for="c-41716863">[2 more]</label></div><br/><div class="children"><div class="content">Apple is BSD based - not Linux.</div><br/><div id="41716928" class="c"><input type="checkbox" id="c-41716928" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716863">parent</a><span>|</span><a href="#41716644">next</a><span>|</span><label class="collapse" for="c-41716928">[-]</label><label class="expand" for="c-41716928">[1 more]</label></div><br/><div class="children"><div class="content">Apple is a company, not an operating system. The parent is almost certainly aware macOS is BSD-based and is suggesting Apple also uses Linux in e.g. cloud deployments. They are of course correct.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41716644" class="c"><input type="checkbox" id="c-41716644" checked=""/><div class="controls bullet"><span class="by">bad_user</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41715449">prev</a><span>|</span><a href="#41716326">next</a><span>|</span><label class="collapse" for="c-41716644">[-]</label><label class="expand" for="c-41716644">[4 more]</label></div><br/><div class="children"><div class="content">Scala is very much alive and kicking.<p><a href="https:&#x2F;&#x2F;redmonk.com&#x2F;sogrady&#x2F;2024&#x2F;09&#x2F;12&#x2F;language-rankings-6-24&#x2F;" rel="nofollow">https:&#x2F;&#x2F;redmonk.com&#x2F;sogrady&#x2F;2024&#x2F;09&#x2F;12&#x2F;language-rankings-6-2...</a><p>The initial hype has died off and that&#x27;s OK. The hype cycle is inevitable for all languages. Also, predictions rarely happen, mostly because the landscape has changed. Mainstream programming languages can no longer die like Cobol did.<p>E.g., Java has been dying ever since 2001, surviving the dotcom bubble, .NET, the P in LAMP, Ruby, JS, or Go. Python was supposed to die on its version 3 migration, with people supposedly moving to Ruby.<p>FWIW, Scala is the world&#x27;s most popular FP language, it has good tooling, and libraries, and Scala 3 is a wonderful upgrade.</div><br/><div id="41717323" class="c"><input type="checkbox" id="c-41717323" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716644">parent</a><span>|</span><a href="#41716326">next</a><span>|</span><label class="collapse" for="c-41717323">[-]</label><label class="expand" for="c-41717323">[3 more]</label></div><br/><div class="children"><div class="content">I spent 3 years working on scala tooling in my free time. One of my libraries is used by the vast majority of scala users (it is a dependency of other widely used tools). There was growth from 2018-2023 but it has flatlined over the last year. Right when theoretically it should be getting the boost from scala 3 having now been stable for a bit.<p>Personally I feel that scala has too much in the language and the compiler is too slow. The tooling is pretty good but it is finicky and ends up getting slow and&#x2F;or unreliable with larger projects. Even if I were to restrict myself to a small subset of scala, I would still be unsatisfied with the long compile times which was the primary reason I decided to move on.<p>I don&#x27;t know if I agree with your contention that languages can&#x27;t die like COBOL. I think you can relatively easily keep a legacy scala system up, put it in maintenance mode and write new features&#x2F;products in something else. That is what I expect is already happening with scala and that this trend is likely to accelerate. Keep in mind also that Martin Odersky is nearing retirement age and it&#x27;s really hard to imagine scala without him. He has much more power&#x2F;control than the head of most languages.</div><br/><div id="41717576" class="c"><input type="checkbox" id="c-41717576" checked=""/><div class="controls bullet"><span class="by">bad_user</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41717323">parent</a><span>|</span><a href="#41716326">next</a><span>|</span><label class="collapse" for="c-41717576">[-]</label><label class="expand" for="c-41717576">[2 more]</label></div><br/><div class="children"><div class="content">IMO, there&#x27;s rarely such a thing as maintenance mode. Projects constantly evolve, and in turn this drives more investment in tooling and the ecosystem needed to keep those projects up. And this investment is what eventually drives more new projects and fresh blood, keeping the language fresh and in demand.<p>Again, look at Java.<p>Ofc, there&#x27;s always the question of what happens with a market that isn&#x27;t constantly growing due to zero-interest rates phenomenon. I guess we&#x27;ll see, but IMO, that&#x27;s problematic for newer languages, not established ones.<p>I too am a contributor of very popular 
libraries and am very familiar with ecosystem. One thing to keep in mind is that the language&#x27;s culture has evolved. When I picked up Scala, back in 2010, the Future pattern and Future-driven libraries were all the rage. Whereas nowadays people prefer alternatives which now includes blocking I&#x2F;O (Loom), with Future-driven libs being a risk going forward.</div><br/><div id="41718317" class="c"><input type="checkbox" id="c-41718317" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41717576">parent</a><span>|</span><a href="#41716326">next</a><span>|</span><label class="collapse" for="c-41718317">[-]</label><label class="expand" for="c-41718317">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think many people would describe Java as &quot;fresh&quot; these days. In demand, sure, but this is overwhelmingly driven by existing large enterprise codebases. Also, for all the talk about nifty new features, how much stuff is still on v11 even?</div><br/></div></div></div></div></div></div></div></div><div id="41716326" class="c"><input type="checkbox" id="c-41716326" checked=""/><div class="controls bullet"><span class="by">bigger_cheese</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41716644">prev</a><span>|</span><a href="#41715445">next</a><span>|</span><label class="collapse" for="c-41716326">[-]</label><label class="expand" for="c-41716326">[5 more]</label></div><br/><div class="children"><div class="content">I think Perl today is probably closer to COBOL it was massive for a time, felt like it was everywhere.<p>Nowadays it is increasingly niche. Like COBOL there is still a lot of perl code out in the wild.</div><br/><div id="41717338" class="c"><input type="checkbox" id="c-41717338" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716326">parent</a><span>|</span><a href="#41717541">next</a><span>|</span><label class="collapse" for="c-41717338">[-]</label><label class="expand" for="c-41717338">[1 more]</label></div><br/><div class="children"><div class="content">Perl footgunned itself with the Perl5&#x2F;Perl6&#x2F;Raku and almost 2 decades between major releases debacle.<p>I wrote a _lot_ of Perl, starting with Perl4 cgi scripts in the mid 90s, then Perl5 and FastCGI and Apache ModPerl. I loved it as a language. But by the time I left that gig in 2008, nobody wanted Perl any more. I mostly drifted around PHP, Python, Ruby, and Javascript for a few years until moving away from full time coding and up (sideways?) into leadership and mentoring roles.<p>Interestingly I got _into_ the Perl gig when I bailed on a COBOL maintenance gig where it was clear nobody was at all interested in listening to how their 10+ year old custom COBOL warehouse management app (written by the company the boss&#x27;s sister used to own) running on EOLed Wang minicomputers - was completely incapable of dealing with 4 digit dates for Y2K. I jumped ship to make that somebody else&#x27;s problem.</div><br/></div></div><div id="41717541" class="c"><input type="checkbox" id="c-41717541" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716326">parent</a><span>|</span><a href="#41717338">prev</a><span>|</span><a href="#41716830">next</a><span>|</span><label class="collapse" for="c-41717541">[-]</label><label class="expand" for="c-41717541">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nowadays it is increasingly niche.<p>Still, if you buy a brand new mac today, most of the executable scripts in the system are written in perl.<p>You can check it yourself by running:<p><pre><code>    file -bL &#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;* | cut -d&#x27; &#x27; -f1 | sort | uniq -c | sort -n
</code></pre>
As of 2024, macOS is essentially a Perl operation.</div><br/></div></div><div id="41716830" class="c"><input type="checkbox" id="c-41716830" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716326">parent</a><span>|</span><a href="#41717541">prev</a><span>|</span><a href="#41715445">next</a><span>|</span><label class="collapse" for="c-41716830">[-]</label><label class="expand" for="c-41716830">[2 more]</label></div><br/><div class="children"><div class="content">time to brush up my perl.  Requires some zen&#x27;ess and flow time to grok the #@[]{} again...</div><br/><div id="41717184" class="c"><input type="checkbox" id="c-41717184" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716830">parent</a><span>|</span><a href="#41715445">next</a><span>|</span><label class="collapse" for="c-41717184">[-]</label><label class="expand" for="c-41717184">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been over a decade for me but I remember the # for tables and @ for arrays not being that hard to decipher, it was the &quot;where is this $_ referring to at this point?&quot; kind of puzzles that would stump me, especially when pattern matching application implicitly uses it too.</div><br/></div></div></div></div></div></div><div id="41715445" class="c"><input type="checkbox" id="c-41715445" checked=""/><div class="controls bullet"><span class="by">mcv</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41716326">prev</a><span>|</span><a href="#41715852">next</a><span>|</span><label class="collapse" for="c-41715445">[-]</label><label class="expand" for="c-41715445">[1 more]</label></div><br/><div class="children"><div class="content">Scala can never be dead like COBOL because it has never been alive like Google. I love it too, but Scala has always been fringe. COBOL was everywhere.</div><br/></div></div><div id="41715852" class="c"><input type="checkbox" id="c-41715852" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41715445">prev</a><span>|</span><a href="#41716189">next</a><span>|</span><label class="collapse" for="c-41715852">[-]</label><label class="expand" for="c-41715852">[3 more]</label></div><br/><div class="children"><div class="content">What about spark? Given the incredible adoption of spark across the industry I don&#x27;t see scala going away anytime soon.</div><br/><div id="41716727" class="c"><input type="checkbox" id="c-41716727" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41715852">parent</a><span>|</span><a href="#41716189">next</a><span>|</span><label class="collapse" for="c-41716727">[-]</label><label class="expand" for="c-41716727">[2 more]</label></div><br/><div class="children"><div class="content">Probably PySpark and similar connectors are robust enough now that they are not necessarily joined at the hip like they were 10 years ago. If you were working in Spark at the maximal of its hype cycle around then you basically had to use Scala in at least some extent - even if it was simply a core team exposing native API’s in other languages - since it was the most native approach that exposed all the apis you needed. Nowadays probably other languages and wrappers have caught up enough that using Scala is not such the absolute requirement it was before.</div><br/><div id="41717386" class="c"><input type="checkbox" id="c-41717386" checked=""/><div class="controls bullet"><span class="by">tdeck</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716727">parent</a><span>|</span><a href="#41716189">next</a><span>|</span><label class="collapse" for="c-41717386">[-]</label><label class="expand" for="c-41717386">[1 more]</label></div><br/><div class="children"><div class="content">This is very true in my experience. I worked in Spark for 3 years and never touched Scala code. I imagine there are many people using Spark who don&#x27;t even know it&#x27;s written in Scala, or whose only interaction with Scala is accidentally stumbling on Scala Spark documentation when you were meaning to Google for PySpark.</div><br/></div></div></div></div></div></div><div id="41716189" class="c"><input type="checkbox" id="c-41716189" checked=""/><div class="controls bullet"><span class="by">darksaints</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41715852">prev</a><span>|</span><a href="#41714937">next</a><span>|</span><label class="collapse" for="c-41716189">[-]</label><label class="expand" for="c-41716189">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame too. Scala3 is actually an amazing language, and has the best type system out of all of the common functional languages. Part of me wonders if Scala would still have died off if Scala3 came out first.</div><br/></div></div><div id="41714937" class="c"><input type="checkbox" id="c-41714937" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41716189">prev</a><span>|</span><a href="#41716138">next</a><span>|</span><label class="collapse" for="c-41714937">[-]</label><label class="expand" for="c-41714937">[3 more]</label></div><br/><div class="children"><div class="content">I assume it became less popular when Java became more bearable.</div><br/><div id="41715128" class="c"><input type="checkbox" id="c-41715128" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41714937">parent</a><span>|</span><a href="#41715154">next</a><span>|</span><label class="collapse" for="c-41715128">[-]</label><label class="expand" for="c-41715128">[1 more]</label></div><br/><div class="children"><div class="content">And kotlin came around with great IDE support, and with good features without the complexity of scals</div><br/></div></div><div id="41715154" class="c"><input type="checkbox" id="c-41715154" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41714937">parent</a><span>|</span><a href="#41715128">prev</a><span>|</span><a href="#41716138">next</a><span>|</span><label class="collapse" for="c-41715154">[-]</label><label class="expand" for="c-41715154">[1 more]</label></div><br/><div class="children"><div class="content">Kotlin made Java bearable.</div><br/></div></div></div></div><div id="41716138" class="c"><input type="checkbox" id="c-41716138" checked=""/><div class="controls bullet"><span class="by">Lance_ET_Compte</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41714937">prev</a><span>|</span><a href="#41714895">next</a><span>|</span><label class="collapse" for="c-41716138">[-]</label><label class="expand" for="c-41716138">[1 more]</label></div><br/><div class="children"><div class="content">Scala is the basis for Chisel HDL, which is widely used in the RISC-V design community.</div><br/></div></div><div id="41714895" class="c"><input type="checkbox" id="c-41714895" checked=""/><div class="controls bullet"><span class="by">empathy_m</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41716138">prev</a><span>|</span><a href="#41716226">next</a><span>|</span><label class="collapse" for="c-41714895">[-]</label><label class="expand" for="c-41714895">[2 more]</label></div><br/><div class="children"><div class="content">Does Twitter still have software in Scala?</div><br/><div id="41717018" class="c"><input type="checkbox" id="c-41717018" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41714895">parent</a><span>|</span><a href="#41716226">next</a><span>|</span><label class="collapse" for="c-41717018">[-]</label><label class="expand" for="c-41717018">[1 more]</label></div><br/><div class="children"><div class="content">Yes <a href="https:&#x2F;&#x2F;github.com&#x2F;twitter">https:&#x2F;&#x2F;github.com&#x2F;twitter</a></div><br/></div></div></div></div><div id="41716226" class="c"><input type="checkbox" id="c-41716226" checked=""/><div class="controls bullet"><span class="by">jackcviers3</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41714895">prev</a><span>|</span><a href="#41716448">next</a><span>|</span><label class="collapse" for="c-41716226">[-]</label><label class="expand" for="c-41716226">[4 more]</label></div><br/><div class="children"><div class="content">We use it for all new services at Writer. Jack Henry, SiriusXM, Starbucks, Disney streaming services, and Capitol One all have services (not data-science) divisions producing new projects in Scala ranging from the last five years to today.<p>There are many others, of course, bit those are the teams at places people have heard of off of the top of my head. It&#x27;s far from dead.<p>What does seem to be dying are the framework-centric Play Akka, and non Airflow raw Spark jobs out there. Now, a lot of that is because they were framework jobs that happened to originate in the scala ecosystem - scala was largely incidental and was chosen because of founding project members&#x27; preferences or due to the need to develop a commercial market, imho.</div><br/><div id="41716625" class="c"><input type="checkbox" id="c-41716625" checked=""/><div class="controls bullet"><span class="by">BirAdam</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716226">parent</a><span>|</span><a href="#41716892">next</a><span>|</span><label class="collapse" for="c-41716625">[-]</label><label class="expand" for="c-41716625">[1 more]</label></div><br/><div class="children"><div class="content">That’s precisely why people think it died. It became stable and therefore useful. It is therefore not talked about every 3 seconds by startup founders.</div><br/></div></div><div id="41716892" class="c"><input type="checkbox" id="c-41716892" checked=""/><div class="controls bullet"><span class="by">mozman</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716226">parent</a><span>|</span><a href="#41716625">prev</a><span>|</span><a href="#41716448">next</a><span>|</span><label class="collapse" for="c-41716892">[-]</label><label class="expand" for="c-41716892">[2 more]</label></div><br/><div class="children"><div class="content">As a fellow vendor for one of those names you dropped - I recommend you not to name any companies.</div><br/><div id="41716990" class="c"><input type="checkbox" id="c-41716990" checked=""/><div class="controls bullet"><span class="by">wholinator2</span><span>|</span><a href="#41713975">root</a><span>|</span><a href="#41716892">parent</a><span>|</span><a href="#41716448">next</a><span>|</span><label class="collapse" for="c-41716990">[-]</label><label class="expand" for="c-41716990">[1 more]</label></div><br/><div class="children"><div class="content">Why? Googling every name given returns public job postings for (senior) scala engineers. Presumably scala divisions at these companies are public knowledge?</div><br/></div></div></div></div></div></div><div id="41716448" class="c"><input type="checkbox" id="c-41716448" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41713975">parent</a><span>|</span><a href="#41716226">prev</a><span>|</span><a href="#41713868">next</a><span>|</span><label class="collapse" for="c-41716448">[-]</label><label class="expand" for="c-41716448">[1 more]</label></div><br/><div class="children"><div class="content">Scala3 looks fairly interesting.<p>The problem however is that I can&#x27;t be bothered to roll out a JDK, and secondly if I did it might encourage someone else to start writing Java again internally. Risky payoff...</div><br/></div></div></div></div><div id="41713868" class="c"><input type="checkbox" id="c-41713868" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41713975">prev</a><span>|</span><a href="#41716811">next</a><span>|</span><label class="collapse" for="c-41713868">[-]</label><label class="expand" for="c-41713868">[58 more]</label></div><br/><div class="children"><div class="content">You know, one of these days I really need to sit down and play with some of these &quot;legacy&quot; languages, like Fortran or COBOL or Ada or APL; languages that have certainly fallen out of popularity but are still used in some critical places.<p>It does make me wonder about millions and millions of lines of Java out there; Java has more or less eaten the enterprise space (for better or worse), but is there any reason to think that in 30-40 years the only people writing Java will be retirees maintaining old banking systems?</div><br/><div id="41714040" class="c"><input type="checkbox" id="c-41714040" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41714483">next</a><span>|</span><label class="collapse" for="c-41714040">[-]</label><label class="expand" for="c-41714040">[18 more]</label></div><br/><div class="children"><div class="content">Cobol is still there not because of cobol itself, but because of vendor and platform lock-in. And I guess having monolithic codebase&#x2F;platform.<p>it’s not even esoteric and difficult, just a lot of it without much structure visible to you.</div><br/><div id="41714117" class="c"><input type="checkbox" id="c-41714117" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714040">parent</a><span>|</span><a href="#41714483">next</a><span>|</span><label class="collapse" for="c-41714117">[-]</label><label class="expand" for="c-41714117">[17 more]</label></div><br/><div class="children"><div class="content">This is what people miss about COBOL. It&#x27;s not like people are compiling COBOL and running it on Linux on an x86 box. They are running it on legacy operating systems (and hardware) which provide a different set of underlying services. It&#x27;s a whole different planet.</div><br/><div id="41715047" class="c"><input type="checkbox" id="c-41715047" checked=""/><div class="controls bullet"><span class="by">crackez</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714117">parent</a><span>|</span><a href="#41714230">next</a><span>|</span><label class="collapse" for="c-41715047">[-]</label><label class="expand" for="c-41715047">[12 more]</label></div><br/><div class="children"><div class="content">Negativo friendo.<p>The mainframe is turning into a middleware layer running on Enterprise Linux. We&#x27;ve containerized the mainframe at this point, and I mean that directly - eg. Running jcl, multiple CICS regions, all in COBOL that originated on z&#x2F;OS is now running in k8s on amd64.</div><br/><div id="41715836" class="c"><input type="checkbox" id="c-41715836" checked=""/><div class="controls bullet"><span class="by">kjellsbells</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715047">parent</a><span>|</span><a href="#41716654">next</a><span>|</span><label class="collapse" for="c-41715836">[-]</label><label class="expand" for="c-41715836">[3 more]</label></div><br/><div class="children"><div class="content">I hope you&#x27;re right, but many comments here on HN suggest their experience with mainframes is very different. z&#x2F;OS and its predecessors provided so many services <i>completely transparently to the application</i> that a mainframe to modernity migration is doomed to fail unless it can completely emulate (or design around) the capabilities provided by the OS and other subsystems.<p>Even ignoring the needs of the super high end customers like banks (eg, cpus in lockstep for redundancy), being able to write your app and just know that inter-node message passing is guaranteed, storage I&#x2F;O calls are guaranteed, failover and transaction processing is guaranteed, just raises the bar for any contender.<p>K8s is wonderful. Can it make all the above happen? Well, yes, given effort. If I&#x27;m the CTO of an airline, do I want to shell out money to make it happen, risk it blowing up in my face, or should I just pay IBM to keep the lights on, kick the can down the road, and divert precious capital to something with a more obvious ROI? I think their &quot;no disasters on my watch&#x2F;self preservation&quot; instinct kicks in, and I can&#x27;t really blame them.<p>HN thread:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36846195">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36846195</a></div><br/><div id="41718053" class="c"><input type="checkbox" id="c-41718053" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715836">parent</a><span>|</span><a href="#41716959">next</a><span>|</span><label class="collapse" for="c-41718053">[-]</label><label class="expand" for="c-41718053">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If I&#x27;m the CTO of an airline, do I want to shell out money to make it happen, risk it blowing up in my face, or should I just pay IBM to keep the lights on<p>But that&#x27;s the thing, we are at the point when &quot;keep paying IBM&quot; isn&#x27;t the acceptable answer anymore.</div><br/></div></div><div id="41716959" class="c"><input type="checkbox" id="c-41716959" checked=""/><div class="controls bullet"><span class="by">Spooky23</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715836">parent</a><span>|</span><a href="#41718053">prev</a><span>|</span><a href="#41716654">next</a><span>|</span><label class="collapse" for="c-41716959">[-]</label><label class="expand" for="c-41716959">[1 more]</label></div><br/><div class="children"><div class="content">Like anything else, some places are awesome, some not. I’ve seen both. The worst ones are just like modern places with overcustomized PeopleSoft or SAP - except the blobs of off the shelf software were purchased 30 years ago by people long dead.<p>Other places stopped development 20 years ago and surrounded the mainframe with now legacy middleware. A lot of the “COBOL” problems with unemployment systems during COVID were actually legacy Java crap from the early 2000s that sat between the mainframe and users.</div><br/></div></div></div></div><div id="41716654" class="c"><input type="checkbox" id="c-41716654" checked=""/><div class="controls bullet"><span class="by">accra4rx</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715047">parent</a><span>|</span><a href="#41715836">prev</a><span>|</span><a href="#41715190">next</a><span>|</span><label class="collapse" for="c-41716654">[-]</label><label class="expand" for="c-41716654">[1 more]</label></div><br/><div class="children"><div class="content">[I work as a SA] . There are many companies that don&#x27;t have a original COBOL source code only compiled objects which has been running for more than few decades. How can you guarantee that it will run perfectly in k8s . Major companies can never take that risk unless you give them some insurance against failure</div><br/></div></div><div id="41715190" class="c"><input type="checkbox" id="c-41715190" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715047">parent</a><span>|</span><a href="#41716654">prev</a><span>|</span><a href="#41716235">next</a><span>|</span><label class="collapse" for="c-41715190">[-]</label><label class="expand" for="c-41715190">[4 more]</label></div><br/><div class="children"><div class="content">There is a major drawback to this approach -- you need to have somebody who knows what they are doing. Total deal breaker in most of the places that have this problem in the first place.</div><br/><div id="41715571" class="c"><input type="checkbox" id="c-41715571" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715190">parent</a><span>|</span><a href="#41716235">next</a><span>|</span><label class="collapse" for="c-41715571">[-]</label><label class="expand" for="c-41715571">[3 more]</label></div><br/><div class="children"><div class="content">&quot;you need to have somebody who knows what they are doing&quot;<p>That applies everywhere.<p>Your parent comment has managed to stuff a mainframe in a container and suddenly, hardware is no longer an issue.  COBOL is well documented too so all good and so too will be the OS they are emulating.  I used to look after a System 36 and I remember a creaking book shelf.<p>The code base may have some issues but it will be well battle tested due to age.  Its COBOL so it is legible and understandable, even by the cool kids.<p>If you lack the skills to engage with something then, yes, there will be snags.  If you are prepared to read specs, manuals and have some reasonable programing aptitude and so on then you will be golden.  No need for geniuses, just conscientious hard workers.<p>It&#x27;s not rocket science.</div><br/><div id="41718044" class="c"><input type="checkbox" id="c-41718044" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715571">parent</a><span>|</span><a href="#41718089">next</a><span>|</span><label class="collapse" for="c-41718044">[-]</label><label class="expand" for="c-41718044">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the point I&#x27;m trying to make. Yes you can do fancy stuff like that and de-mainframing COBOL is to run in on k8s is the path I would personally choose if I had to deal with it. It sounds like a lot of fun and the sense of accomplishment to finally have it running should be great.<p>The problem is -- it&#x27;s very smart and unique, while organizations that have this kind of a problem don&#x27;t want to depend on unique set of skills of a few highly capable individuals. Everything needs to be boring and people have to be replaceable.<p>In this paradigm, vendor java with aws lock-in is a cost, but in-house fancy stuff with cobol on k4s done by smart people in house is worse -- it&#x27;s a risk.</div><br/></div></div><div id="41718089" class="c"><input type="checkbox" id="c-41718089" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715571">parent</a><span>|</span><a href="#41718044">prev</a><span>|</span><a href="#41716235">next</a><span>|</span><label class="collapse" for="c-41718089">[-]</label><label class="expand" for="c-41718089">[1 more]</label></div><br/><div class="children"><div class="content">The need applies everywhere, the difficulty of fulfilling it tends to be an order of magnitude more in places that tend to run COBOL.<p>I&#x27;m working at one. You wouldn&#x27;t believe the stories.</div><br/></div></div></div></div></div></div><div id="41716235" class="c"><input type="checkbox" id="c-41716235" checked=""/><div class="controls bullet"><span class="by">mathgorges</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715047">parent</a><span>|</span><a href="#41715190">prev</a><span>|</span><a href="#41715083">next</a><span>|</span><label class="collapse" for="c-41716235">[-]</label><label class="expand" for="c-41716235">[2 more]</label></div><br/><div class="children"><div class="content">This is fascinating to me as an ex-mainframer that now works on a niche hyperscaler. I would love to learn more!<p>Will you let me know some of the names in the space so that I can research more? Some cursory searching only brings up some questionably relavent press releases from IBM.</div><br/><div id="41716482" class="c"><input type="checkbox" id="c-41716482" checked=""/><div class="controls bullet"><span class="by">yourapostasy</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716235">parent</a><span>|</span><a href="#41715083">next</a><span>|</span><label class="collapse" for="c-41716482">[-]</label><label class="expand" for="c-41716482">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like they’re talking about running IBM Wazi on Red Hat OpenShift Virtualization. As far as I know, there isn’t a System z-on-a-container offering, like you install from a Helm Chart or comes to you from an OCI registry. If it is the IBM I know, it’s completely out of reach of most homelab’ers and hobbyists.<p>IBM Wazi As A Service is supposed to be more affordable than the self hosted version and the Z Development and Test Environment (ZD&amp;T) offering. ZD&amp;T is around $5000 USD for the cheapest personal edition, so maybe around $2500-3500 USD per year?</div><br/></div></div></div></div><div id="41715083" class="c"><input type="checkbox" id="c-41715083" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715047">parent</a><span>|</span><a href="#41716235">prev</a><span>|</span><a href="#41714230">next</a><span>|</span><label class="collapse" for="c-41715083">[-]</label><label class="expand" for="c-41715083">[1 more]</label></div><br/><div class="children"><div class="content">Yup, but the COBOL application doesn&#x27;t know you&#x27;ve done that.</div><br/></div></div></div></div><div id="41714230" class="c"><input type="checkbox" id="c-41714230" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714117">parent</a><span>|</span><a href="#41715047">prev</a><span>|</span><a href="#41716384">next</a><span>|</span><label class="collapse" for="c-41714230">[-]</label><label class="expand" for="c-41714230">[3 more]</label></div><br/><div class="children"><div class="content">A different kind of cloud you can say.</div><br/><div id="41714308" class="c"><input type="checkbox" id="c-41714308" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714230">parent</a><span>|</span><a href="#41716384">next</a><span>|</span><label class="collapse" for="c-41714308">[-]</label><label class="expand" for="c-41714308">[2 more]</label></div><br/><div class="children"><div class="content">ha yes. There is actually a pretty cool product that is made by a division of Rocket Software named &quot;AMC&quot;, it takes a COBOL app running on an IBM system and deploys it to a whole set of services on AWS. There are some smart dudes at that shop.</div><br/><div id="41714339" class="c"><input type="checkbox" id="c-41714339" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714308">parent</a><span>|</span><a href="#41716384">next</a><span>|</span><label class="collapse" for="c-41714339">[-]</label><label class="expand" for="c-41714339">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t surprise me at all, somebody out there should be smart enough to make good money on that and not be very loud about it either.</div><br/></div></div></div></div></div></div><div id="41716384" class="c"><input type="checkbox" id="c-41716384" checked=""/><div class="controls bullet"><span class="by">WesleyJohnson</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714117">parent</a><span>|</span><a href="#41714230">prev</a><span>|</span><a href="#41714483">next</a><span>|</span><label class="collapse" for="c-41716384">[-]</label><label class="expand" for="c-41716384">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re running RM&#x2F;COBOL on RHEL8 VMs backed powered by VMware. I don&#x27;t work with it, I&#x27;m in a different IT area, but our COBOL codebase supports the lion&#x27;s share of our day-to-day operations.</div><br/></div></div></div></div></div></div><div id="41714483" class="c"><input type="checkbox" id="c-41714483" checked=""/><div class="controls bullet"><span class="by">9659</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41714040">prev</a><span>|</span><a href="#41716605">next</a><span>|</span><label class="collapse" for="c-41714483">[-]</label><label class="expand" for="c-41714483">[19 more]</label></div><br/><div class="children"><div class="content">Ada is an order of magnitude more modern and sophisticated than your other examples.<p>I expect Ada will capture 0.05% of the market for the next 100 years.</div><br/><div id="41714653" class="c"><input type="checkbox" id="c-41714653" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714483">parent</a><span>|</span><a href="#41716956">next</a><span>|</span><label class="collapse" for="c-41714653">[-]</label><label class="expand" for="c-41714653">[10 more]</label></div><br/><div class="children"><div class="content">Fair, I guess the list was “languages that I know were popular at one point but I don’t know anyone really using now”.<p>Ada definitely does seem pretty cool from the little bit I have read about it.  I’m not sure why it’s fallen by the wayside in favor of C and its derivatives.</div><br/><div id="41714796" class="c"><input type="checkbox" id="c-41714796" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714653">parent</a><span>|</span><a href="#41716956">next</a><span>|</span><label class="collapse" for="c-41714796">[-]</label><label class="expand" for="c-41714796">[9 more]</label></div><br/><div class="children"><div class="content">Ada was mandated by the DoD for a bit.  My understanding is that, in practice, this involved making a half-hearted effort in Ada, failing and then applying for a variance to not use Ada.</div><br/><div id="41715000" class="c"><input type="checkbox" id="c-41715000" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714796">parent</a><span>|</span><a href="#41715268">next</a><span>|</span><label class="collapse" for="c-41715000">[-]</label><label class="expand" for="c-41715000">[3 more]</label></div><br/><div class="children"><div class="content">Often, I&#x27;m sure, but there are large code bases in Ada still. It&#x27;s a shame, it looks like a really great language I would love. But it&#x27;s a chicken and egg problem. If only Mozilla had decided on Ada instead of Rust! :-)</div><br/><div id="41716587" class="c"><input type="checkbox" id="c-41716587" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715000">parent</a><span>|</span><a href="#41715268">next</a><span>|</span><label class="collapse" for="c-41716587">[-]</label><label class="expand" for="c-41716587">[2 more]</label></div><br/><div class="children"><div class="content">Ada doesn&#x27;t offer any safety for dynamic memory. In fact, Ada is now adopting Rust&#x27;s approach with the borrow checker.</div><br/><div id="41717946" class="c"><input type="checkbox" id="c-41717946" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716587">parent</a><span>|</span><a href="#41715268">next</a><span>|</span><label class="collapse" for="c-41717946">[-]</label><label class="expand" for="c-41717946">[1 more]</label></div><br/><div class="children"><div class="content">Great!  Time to jump on the Ada bandwagon then! ;)</div><br/></div></div></div></div></div></div><div id="41715268" class="c"><input type="checkbox" id="c-41715268" checked=""/><div class="controls bullet"><span class="by">hardburn</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714796">parent</a><span>|</span><a href="#41715000">prev</a><span>|</span><a href="#41716956">next</a><span>|</span><label class="collapse" for="c-41715268">[-]</label><label class="expand" for="c-41715268">[5 more]</label></div><br/><div class="children"><div class="content">I actually met a programmer who worked on military jets. According to her, Ada is only used anymore for the older jets that were already programmed in it, and she worked in C++.</div><br/><div id="41715939" class="c"><input type="checkbox" id="c-41715939" checked=""/><div class="controls bullet"><span class="by">greenavocado</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715268">parent</a><span>|</span><a href="#41716537">next</a><span>|</span><label class="collapse" for="c-41715939">[-]</label><label class="expand" for="c-41715939">[3 more]</label></div><br/><div class="children"><div class="content">Military jets coded in C++. God help us all.</div><br/><div id="41716050" class="c"><input type="checkbox" id="c-41716050" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715939">parent</a><span>|</span><a href="#41716537">next</a><span>|</span><label class="collapse" for="c-41716050">[-]</label><label class="expand" for="c-41716050">[2 more]</label></div><br/><div class="children"><div class="content">No need to be so dramatic. Shitheads will make software fail in any language. Memory &quot;safety&quot; will not help you correctly and in timely manner calculate position of flight controls for example.</div><br/><div id="41716419" class="c"><input type="checkbox" id="c-41716419" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716050">parent</a><span>|</span><a href="#41716537">next</a><span>|</span><label class="collapse" for="c-41716419">[-]</label><label class="expand" for="c-41716419">[1 more]</label></div><br/><div class="children"><div class="content">One can write reliable, and I mean airtight good enough for medical devices and nuclear deterrence, in basically any even vaguely modern language (think Algol-60 or later). It’s simply a matter of disciplined design and running on hardware that’s sufficiently predictable.</div><br/></div></div></div></div></div></div><div id="41716537" class="c"><input type="checkbox" id="c-41716537" checked=""/><div class="controls bullet"><span class="by">9659</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715268">parent</a><span>|</span><a href="#41715939">prev</a><span>|</span><a href="#41716956">next</a><span>|</span><label class="collapse" for="c-41716537">[-]</label><label class="expand" for="c-41716537">[1 more]</label></div><br/><div class="children"><div class="content">yes, this is true.  mainly due to a perceived lack of ada programmers on the market.</div><br/></div></div></div></div></div></div></div></div><div id="41716956" class="c"><input type="checkbox" id="c-41716956" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714483">parent</a><span>|</span><a href="#41714653">prev</a><span>|</span><a href="#41714957">next</a><span>|</span><label class="collapse" for="c-41716956">[-]</label><label class="expand" for="c-41716956">[1 more]</label></div><br/><div class="children"><div class="content">The one shop that really used it is now open to C++ and I expect Rust. But their projects tend to last a long time: 3 generations have flown in one of them, etc.</div><br/></div></div><div id="41714957" class="c"><input type="checkbox" id="c-41714957" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714483">parent</a><span>|</span><a href="#41716956">prev</a><span>|</span><a href="#41716123">next</a><span>|</span><label class="collapse" for="c-41714957">[-]</label><label class="expand" for="c-41714957">[3 more]</label></div><br/><div class="children"><div class="content">Ada is pretty cool, but not sure if any more modern than APL. Both are actively maintained and useful in different areas.</div><br/><div id="41718346" class="c"><input type="checkbox" id="c-41718346" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714957">parent</a><span>|</span><a href="#41716214">next</a><span>|</span><label class="collapse" for="c-41718346">[-]</label><label class="expand" for="c-41718346">[1 more]</label></div><br/><div class="children"><div class="content">Ada has seen quite a few major features added to it in the past couple of decades.</div><br/></div></div><div id="41716214" class="c"><input type="checkbox" id="c-41716214" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714957">parent</a><span>|</span><a href="#41718346">prev</a><span>|</span><a href="#41716123">next</a><span>|</span><label class="collapse" for="c-41716214">[-]</label><label class="expand" for="c-41716214">[1 more]</label></div><br/><div class="children"><div class="content">While we’re at it, modern Fortran exists and has its boosters. <a href="https:&#x2F;&#x2F;fortran-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fortran-lang.org&#x2F;</a></div><br/></div></div></div></div><div id="41716123" class="c"><input type="checkbox" id="c-41716123" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714483">parent</a><span>|</span><a href="#41714957">prev</a><span>|</span><a href="#41716605">next</a><span>|</span><label class="collapse" for="c-41716123">[-]</label><label class="expand" for="c-41716123">[4 more]</label></div><br/><div class="children"><div class="content">Modern fortran is actually fairly modern too. But most fortran codebases aren&#x27;t modern fortran, they&#x27;re Fortran 77. If you&#x27;re lucky.</div><br/><div id="41716367" class="c"><input type="checkbox" id="c-41716367" checked=""/><div class="controls bullet"><span class="by">atrettel</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716123">parent</a><span>|</span><a href="#41716605">next</a><span>|</span><label class="collapse" for="c-41716367">[-]</label><label class="expand" for="c-41716367">[3 more]</label></div><br/><div class="children"><div class="content">I agree that many modern Fortran codes aren&#x27;t truly &quot;modern&quot; Fortran, but in my experience most codes have at least been ported to Fortran 90, even if they largely keep a lot of Fortran 77 baggage (especially the type system and indentation!).  In all of my experience, I&#x27;ve really only encountered a single Fortran code being used currently that is actually Fortran 77 in the flesh.  That said, I still think many Fortran codes would benefit from using more modern features, since so many are stuck in the past and are difficult to maintain for that reason.</div><br/><div id="41717071" class="c"><input type="checkbox" id="c-41717071" checked=""/><div class="controls bullet"><span class="by">jsrcout</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716367">parent</a><span>|</span><a href="#41717223">next</a><span>|</span><label class="collapse" for="c-41717071">[-]</label><label class="expand" for="c-41717071">[1 more]</label></div><br/><div class="children"><div class="content">The codebase I&#x27;ve been working in lately is mostly pre-77 FORTRAN, maintained as such for all this time. &quot;Stuck in the past&quot; is an apt description.</div><br/></div></div><div id="41717223" class="c"><input type="checkbox" id="c-41717223" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716367">parent</a><span>|</span><a href="#41717071">prev</a><span>|</span><a href="#41716605">next</a><span>|</span><label class="collapse" for="c-41717223">[-]</label><label class="expand" for="c-41717223">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps I should have said &quot;originally written in f77&quot;, and still look like it.</div><br/></div></div></div></div></div></div></div></div><div id="41716605" class="c"><input type="checkbox" id="c-41716605" checked=""/><div class="controls bullet"><span class="by">ecshafer</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41714483">prev</a><span>|</span><a href="#41716360">next</a><span>|</span><label class="collapse" for="c-41716605">[-]</label><label class="expand" for="c-41716605">[1 more]</label></div><br/><div class="children"><div class="content">Fortran is pretty nice to write in if you are just writing numerical stuff. If I were just doing a pure numerical simulation, I would rather do it in fortran than c++ or python (without numpy which is just fortran and c++)</div><br/></div></div><div id="41716360" class="c"><input type="checkbox" id="c-41716360" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41716605">prev</a><span>|</span><a href="#41714063">next</a><span>|</span><label class="collapse" for="c-41716360">[-]</label><label class="expand" for="c-41716360">[2 more]</label></div><br/><div class="children"><div class="content">I wrote a small program in Algol 68 once. It was horrible because it didn&#x27;t even have heap allocation in the language, so things you&#x27;d think of doing in C (e.g., tree data structures) just didn&#x27;t work. That and all the compiler errors were pure numerical codes which you had to go look up in the manual (not provided). And forget about getting line numbers.<p>I am very much glad I wasn&#x27;t alive at the time this was the state of the art.</div><br/><div id="41716950" class="c"><input type="checkbox" id="c-41716950" checked=""/><div class="controls bullet"><span class="by">bigger_cheese</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716360">parent</a><span>|</span><a href="#41714063">next</a><span>|</span><label class="collapse" for="c-41716950">[-]</label><label class="expand" for="c-41716950">[1 more]</label></div><br/><div class="children"><div class="content">I ported some Algol code into C years ago, despite being completely unfamiliar with Algol I found code very easy to understand.<p>Found the paper with original code here, it&#x27;s for a Reinsch spline: <a href="https:&#x2F;&#x2F;tlakoba.w3.uvm.edu&#x2F;AppliedUGMath&#x2F;auxpaper_Reinsch_1967.pdf" rel="nofollow">https:&#x2F;&#x2F;tlakoba.w3.uvm.edu&#x2F;AppliedUGMath&#x2F;auxpaper_Reinsch_19...</a></div><br/></div></div></div></div><div id="41714063" class="c"><input type="checkbox" id="c-41714063" checked=""/><div class="controls bullet"><span class="by">Mc91</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41716360">prev</a><span>|</span><a href="#41715464">next</a><span>|</span><label class="collapse" for="c-41714063">[-]</label><label class="expand" for="c-41714063">[4 more]</label></div><br/><div class="children"><div class="content">I program an Android app for a Fortune 100 company.  Last commit where someone edited a Java file was last week.<p>Most of the new code from the past few years has been in Kotlin though.</div><br/><div id="41714151" class="c"><input type="checkbox" id="c-41714151" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714063">parent</a><span>|</span><a href="#41715464">next</a><span>|</span><label class="collapse" for="c-41714151">[-]</label><label class="expand" for="c-41714151">[3 more]</label></div><br/><div class="children"><div class="content">This. Nobody wants to have the COBOL problem again, so the developer hiring money follows the programming language popularity market (with a certain regulatory approved laf ofc)</div><br/><div id="41715217" class="c"><input type="checkbox" id="c-41715217" checked=""/><div class="controls bullet"><span class="by">psjs</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714151">parent</a><span>|</span><a href="#41715464">next</a><span>|</span><label class="collapse" for="c-41715217">[-]</label><label class="expand" for="c-41715217">[2 more]</label></div><br/><div class="children"><div class="content">“laf” or “lag”?</div><br/><div id="41718066" class="c"><input type="checkbox" id="c-41718066" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41715217">parent</a><span>|</span><a href="#41715464">next</a><span>|</span><label class="collapse" for="c-41718066">[-]</label><label class="expand" for="c-41718066">[1 more]</label></div><br/><div class="children"><div class="content">Lag of course. Math doors only open once in 25 years, you know the drill.</div><br/></div></div></div></div></div></div></div></div><div id="41715464" class="c"><input type="checkbox" id="c-41715464" checked=""/><div class="controls bullet"><span class="by">bear8642</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41714063">prev</a><span>|</span><a href="#41714100">next</a><span>|</span><label class="collapse" for="c-41715464">[-]</label><label class="expand" for="c-41715464">[1 more]</label></div><br/><div class="children"><div class="content">Tryapl.org exists if want to play with APL - John Scholes&#x27; Game of Life and other excellent videos (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=a9xAKttWgP4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=a9xAKttWgP4</a>) might spark your interest<p>Other newer array languages exist too - <a href="https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Running_APL" rel="nofollow">https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Running_APL</a> if want to explore the current space.</div><br/></div></div><div id="41714100" class="c"><input type="checkbox" id="c-41714100" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41715464">prev</a><span>|</span><a href="#41714027">next</a><span>|</span><label class="collapse" for="c-41714100">[-]</label><label class="expand" for="c-41714100">[1 more]</label></div><br/><div class="children"><div class="content">Fortran is not a legacy language.</div><br/></div></div><div id="41714027" class="c"><input type="checkbox" id="c-41714027" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41714100">prev</a><span>|</span><a href="#41716645">next</a><span>|</span><label class="collapse" for="c-41714027">[-]</label><label class="expand" for="c-41714027">[7 more]</label></div><br/><div class="children"><div class="content">&gt;but is there any reason to think that in 30-40 years the only people writing Java will be retirees maintaining old banking systems?<p>It feels like we&#x27;re getting into that space already.</div><br/><div id="41714126" class="c"><input type="checkbox" id="c-41714126" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714027">parent</a><span>|</span><a href="#41715782">next</a><span>|</span><label class="collapse" for="c-41714126">[-]</label><label class="expand" for="c-41714126">[5 more]</label></div><br/><div class="children"><div class="content">Nah not really. People just started replacing COBOL with java and employers are wise enough to hire people who are 30-40 years minimum from retirement.<p>It can also be upgraded in smaller chunks and finding enough developers for the tool is an important metric corporate is looking at.<p>If anything, banks are actively optimizing for developer experience to make sure 60% of new hires don’t run away in the first year. If anything, banks are better at navigating those kind of structural risks, they were just slow on undertaking such risks exist.<p>If you have an episode of existential anxiety because of dat AI eating mijn job, getting a union job in a bank is a way to hedge this particular risk.</div><br/><div id="41714243" class="c"><input type="checkbox" id="c-41714243" checked=""/><div class="controls bullet"><span class="by">gwd</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714126">parent</a><span>|</span><a href="#41716429">next</a><span>|</span><label class="collapse" for="c-41714243">[-]</label><label class="expand" for="c-41714243">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ...employers are wise enough to hire people who are 30-40 years minimum from retirement.<p>Um oh yeah, the reason we&#x27;re hiring 20-year-olds is because we want to ensure we have lifelong support for the new system we&#x27;re writing.  Not because they&#x27;re cheaper, they&#x27;re still idealistic and naive, they&#x27;ll work long hours for foosball tables and stacks, or anything like that...</div><br/><div id="41714321" class="c"><input type="checkbox" id="c-41714321" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714243">parent</a><span>|</span><a href="#41716429">next</a><span>|</span><label class="collapse" for="c-41714321">[-]</label><label class="expand" for="c-41714321">[1 more]</label></div><br/><div class="children"><div class="content">In a place where you can imagine having COBOL, working long hours is frown upon and being idealistic beyond personal integrity isn&#x27;t a good quality either. Not saying such places aren&#x27;t cheap, as of course they are. Being cheap is their exact point.</div><br/></div></div></div></div><div id="41716429" class="c"><input type="checkbox" id="c-41716429" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714126">parent</a><span>|</span><a href="#41714243">prev</a><span>|</span><a href="#41715782">next</a><span>|</span><label class="collapse" for="c-41716429">[-]</label><label class="expand" for="c-41716429">[2 more]</label></div><br/><div class="children"><div class="content">&gt; employers are wise enough to hire people who are 30-40 years minimum from retirement.<p>Well I hope they’re wise enough to not let any good employment attorneys catch wind because that’s blatantly illegal.</div><br/><div id="41718077" class="c"><input type="checkbox" id="c-41718077" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41716429">parent</a><span>|</span><a href="#41715782">next</a><span>|</span><label class="collapse" for="c-41718077">[-]</label><label class="expand" for="c-41718077">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a requirement, but the outcome of hiring results demographics wise is very visible.</div><br/></div></div></div></div></div></div><div id="41715782" class="c"><input type="checkbox" id="c-41715782" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41713868">root</a><span>|</span><a href="#41714027">parent</a><span>|</span><a href="#41714126">prev</a><span>|</span><a href="#41716645">next</a><span>|</span><label class="collapse" for="c-41715782">[-]</label><label class="expand" for="c-41715782">[1 more]</label></div><br/><div class="children"><div class="content">I think Android makes a difference here. Sure, a lot of people are on Kotlin, but a lot aren&#x27;t.</div><br/></div></div></div></div><div id="41716645" class="c"><input type="checkbox" id="c-41716645" checked=""/><div class="controls bullet"><span class="by">Yodel0914</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41714027">prev</a><span>|</span><a href="#41715983">next</a><span>|</span><label class="collapse" for="c-41716645">[-]</label><label class="expand" for="c-41716645">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure I’d choose to use Fortran, but at one point I had to maintain an app that had a Delphi UI and Fortran business logic. The Fortran, although spaghetti, was much less frustrating to work with.</div><br/></div></div><div id="41715983" class="c"><input type="checkbox" id="c-41715983" checked=""/><div class="controls bullet"><span class="by">karlgkk</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41716645">prev</a><span>|</span><a href="#41716606">next</a><span>|</span><label class="collapse" for="c-41715983">[-]</label><label class="expand" for="c-41715983">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in 30-40 years the only people writing Java will be retirees maintaining old banking systems?<p>I kinda suspect that if Java is still around in 30 years, what we call Java will be - at best - vaguely recognizable.</div><br/></div></div><div id="41716606" class="c"><input type="checkbox" id="c-41716606" checked=""/><div class="controls bullet"><span class="by">jtolmar</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41715983">prev</a><span>|</span><a href="#41714882">next</a><span>|</span><label class="collapse" for="c-41716606">[-]</label><label class="expand" for="c-41716606">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t say whether Java as a whole will ever become the next COBOL, but Java 8 already is well on the way there.</div><br/></div></div><div id="41714882" class="c"><input type="checkbox" id="c-41714882" checked=""/><div class="controls bullet"><span class="by">RickJWagner</span><span>|</span><a href="#41713868">parent</a><span>|</span><a href="#41716606">prev</a><span>|</span><a href="#41716811">next</a><span>|</span><label class="collapse" for="c-41714882">[-]</label><label class="expand" for="c-41714882">[1 more]</label></div><br/><div class="children"><div class="content">IBM offers a free COBOL plugin for VSCode and a nice tutorial with it.<p>I started programming in COBOL (circa 1990) and took the tutorial just for fun earlier this year.</div><br/></div></div></div></div><div id="41716811" class="c"><input type="checkbox" id="c-41716811" checked=""/><div class="controls bullet"><span class="by">kukkeliskuu</span><span>|</span><a href="#41713868">prev</a><span>|</span><a href="#41714111">next</a><span>|</span><label class="collapse" for="c-41716811">[-]</label><label class="expand" for="c-41716811">[1 more]</label></div><br/><div class="children"><div class="content">Cloud is the new mainframe, except worse. It has all the downsides, but does not have the biggest upside.<p>The grandpa could create (using CICS), a very reliable and performant service that would call other services inside the same transaction. The platform would handle all the complicated stuff, such as maintaining data integrity.<p>Try to write AWS Lambdas that call each other within the same transaction.</div><br/></div></div><div id="41714111" class="c"><input type="checkbox" id="c-41714111" checked=""/><div class="controls bullet"><span class="by">brightball</span><span>|</span><a href="#41716811">prev</a><span>|</span><a href="#41717823">next</a><span>|</span><label class="collapse" for="c-41714111">[-]</label><label class="expand" for="c-41714111">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, I&#x27;m still actively looking for a COBOL speaker for the 2025 Carolina Code Conference. Been wanting to get a COBOL talk for a while, especially with GnuCOBOL&#x27;s recent update.<p><a href="https:&#x2F;&#x2F;gnucobol.sourceforge.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gnucobol.sourceforge.io&#x2F;</a><p><a href="https:&#x2F;&#x2F;carolina.codes" rel="nofollow">https:&#x2F;&#x2F;carolina.codes</a></div><br/></div></div><div id="41717823" class="c"><input type="checkbox" id="c-41717823" checked=""/><div class="controls bullet"><span class="by">martinclayton</span><span>|</span><a href="#41714111">prev</a><span>|</span><a href="#41713561">next</a><span>|</span><label class="collapse" for="c-41717823">[-]</label><label class="expand" for="c-41717823">[3 more]</label></div><br/><div class="children"><div class="content">In case anyone is interested...<p>The SO Developer Surveys give some info on the job market for COBOL as it appears on the average salary versus years-of-experience graphs, which I like as there&#x27;s as many stories or reasons as you can think of to explain them.<p>In 2023 there were 222 respondents who averaged 19 years of experience, and an average salary of $75,500.  In 2024 the exact number of respondents is not shown, but likely similar based on the color code of the point, but the average experience had <i>dropped</i> to 17 years.<p>Elsewhere in the graph my favourite open question is: how come the over 2000 respondents mentioning Swift average over 11 years experience in a language that&#x27;s only been public for 10 years?<p>2024 <a href="https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2024&#x2F;work#salary-comp-total-years-code-pro-language" rel="nofollow">https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2024&#x2F;work#salary-comp-total-...</a><p>2023 <a href="https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2023&#x2F;?utm_source=so-owned&amp;utm_medium=blog&amp;utm_campaign=dev-survey-results-2023&amp;utm_content=survey-results#section-salary-salary-and-experience-by-language" rel="nofollow">https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2023&#x2F;?utm_source=so-owned&amp;ut...</a></div><br/><div id="41717856" class="c"><input type="checkbox" id="c-41717856" checked=""/><div class="controls bullet"><span class="by">clarle</span><span>|</span><a href="#41717823">parent</a><span>|</span><a href="#41713561">next</a><span>|</span><label class="collapse" for="c-41717856">[-]</label><label class="expand" for="c-41717856">[2 more]</label></div><br/><div class="children"><div class="content">iOS development has been around for quite some time now. Most senior iOS and Cocoa developers probably started with Objective-C before slowly migrating codebases over to Swift.</div><br/><div id="41717976" class="c"><input type="checkbox" id="c-41717976" checked=""/><div class="controls bullet"><span class="by">martinclayton</span><span>|</span><a href="#41717823">root</a><span>|</span><a href="#41717856">parent</a><span>|</span><a href="#41713561">next</a><span>|</span><label class="collapse" for="c-41717976">[-]</label><label class="expand" for="c-41717976">[1 more]</label></div><br/><div class="children"><div class="content">I think this must be it, or at least this is one story that fits.<p>Seems a shame that people report Objective-C experience as Swift experience to such a great extent.  These surveys are not resumes...<p>Perhaps it just &quot;proves&quot; that all data in these charts is questionable.</div><br/></div></div></div></div></div></div><div id="41713561" class="c"><input type="checkbox" id="c-41713561" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#41717823">prev</a><span>|</span><a href="#41714262">next</a><span>|</span><label class="collapse" for="c-41713561">[-]</label><label class="expand" for="c-41713561">[30 more]</label></div><br/><div class="children"><div class="content">&quot;I don&#x27;t know what the language of the year 2000 will look like, but I know it will be called Fortran.&quot; —Tony Hoare<p>COBOL is alive in that it keeps changing from era to era, to the point modern COBOL looks rather little like the 1950s COBOL everyone instinctively thinks about when they heard the term. It&#x27;s as if we were still programming in Algol because Java had been called Algol-94 or something.</div><br/><div id="41713676" class="c"><input type="checkbox" id="c-41713676" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41713561">parent</a><span>|</span><a href="#41714461">next</a><span>|</span><label class="collapse" for="c-41713676">[-]</label><label class="expand" for="c-41713676">[20 more]</label></div><br/><div class="children"><div class="content">Nobody writes<p><pre><code>    MULTIPLY A BY B GIVING C ON SIZE ERROR STOP RUN.
</code></pre>
any more.</div><br/><div id="41713773" class="c"><input type="checkbox" id="c-41713773" checked=""/><div class="controls bullet"><span class="by">graypegg</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713676">parent</a><span>|</span><a href="#41713831">next</a><span>|</span><label class="collapse" for="c-41713773">[-]</label><label class="expand" for="c-41713773">[13 more]</label></div><br/><div class="children"><div class="content">I mean, if you squint your eyes a bit, that could be SQL! So even if it&#x27;s not COBOL, there&#x27;s people out there writing in a vaguely english business programming language.</div><br/><div id="41714160" class="c"><input type="checkbox" id="c-41714160" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713773">parent</a><span>|</span><a href="#41714697">next</a><span>|</span><label class="collapse" for="c-41714160">[-]</label><label class="expand" for="c-41714160">[3 more]</label></div><br/><div class="children"><div class="content">So you spotted that? I have no proof or links to share, but I&#x27;ve always thought SQL was inspired by, or at least made to not look out of place next to COBOL. I recall COBOL coding card layout interpreted a flag on punch cards at the char column where top-level picture clauses needed to start specifically for designating a line as SQL for static embedded SQL preprocessing.</div><br/><div id="41714589" class="c"><input type="checkbox" id="c-41714589" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714160">parent</a><span>|</span><a href="#41714697">next</a><span>|</span><label class="collapse" for="c-41714589">[-]</label><label class="expand" for="c-41714589">[2 more]</label></div><br/><div class="children"><div class="content">I think it’s more that computers at the time didn’t <i>all</i> have lowercase characters. Consider that even C and C++ supported trigraph&#x2F;digraph compatibility chars until something like last year (and IBM still complained…):</div><br/><div id="41715218" class="c"><input type="checkbox" id="c-41715218" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714589">parent</a><span>|</span><a href="#41714697">next</a><span>|</span><label class="collapse" for="c-41715218">[-]</label><label class="expand" for="c-41715218">[1 more]</label></div><br/><div class="children"><div class="content">C is much older than Unicode, so it&#x27;s not that surprising that some systems are still using <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO&#x2F;IEC_646" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO&#x2F;IEC_646</a> and replacing some reserved punctuation (e.g., curly braces) with their country&#x27;s accented letters.</div><br/></div></div></div></div></div></div><div id="41714697" class="c"><input type="checkbox" id="c-41714697" checked=""/><div class="controls bullet"><span class="by">throw-the-towel</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713773">parent</a><span>|</span><a href="#41714160">prev</a><span>|</span><a href="#41714060">next</a><span>|</span><label class="collapse" for="c-41714697">[-]</label><label class="expand" for="c-41714697">[2 more]</label></div><br/><div class="children"><div class="content">And SQL kinda dates from the same era, I wonder if this type of language was in vogue 50 years ago?</div><br/><div id="41717437" class="c"><input type="checkbox" id="c-41717437" checked=""/><div class="controls bullet"><span class="by">tdeck</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714697">parent</a><span>|</span><a href="#41714060">next</a><span>|</span><label class="collapse" for="c-41717437">[-]</label><label class="expand" for="c-41717437">[1 more]</label></div><br/><div class="children"><div class="content">The only notable similarities I see are lack of special characters, all caps by default (most languages from this era are actually case insensitive), and using English words. Those characteristics were in vogue 50 years ago because many computers didn&#x27;t support lowercase characters, and the set of non-alphanumeric characters supported tended to vary a lot between machines. Here&#x27;s what the Jargon File had to say about EBCDIC, for example:<p>&gt; EBCDIC: &#x2F;eb´s@·dik&#x2F;, &#x2F;eb´see`dik&#x2F;, &#x2F;eb´k@·dik&#x2F;, n. [abbreviation, Extended Binary Coded Decimal Interchange Code] An alleged character set used on IBM dinosaurs. It exists in at least six mutually incompatible versions, all featuring such delights as non-contiguous letter sequences and the absence of several ASCII punctuation characters fairly important for modern computer languages (exactly which characters are absent varies according to which version of EBCDIC you&#x27;re looking at).</div><br/></div></div></div></div><div id="41714060" class="c"><input type="checkbox" id="c-41714060" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713773">parent</a><span>|</span><a href="#41714697">prev</a><span>|</span><a href="#41713950">next</a><span>|</span><label class="collapse" for="c-41714060">[-]</label><label class="expand" for="c-41714060">[4 more]</label></div><br/><div class="children"><div class="content">seriously sometimes writing SQL feels more like composing a google query than programming.</div><br/><div id="41714316" class="c"><input type="checkbox" id="c-41714316" checked=""/><div class="controls bullet"><span class="by">jl6</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714060">parent</a><span>|</span><a href="#41718038">next</a><span>|</span><label class="collapse" for="c-41714316">[-]</label><label class="expand" for="c-41714316">[2 more]</label></div><br/><div class="children"><div class="content">A great thing about being a programmer is getting to complain about the crappy requirements you have to work with. SQL, on the other hand, is not a program - it’s a precise specification of the result you want, in a format that lets the database engine write the “program” for you. Thus, writing SQL helps you appreciate the struggle to achieve good requirements, and there is a chance you will develop empathy for those cursed to write them.</div><br/><div id="41718371" class="c"><input type="checkbox" id="c-41718371" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714316">parent</a><span>|</span><a href="#41718038">next</a><span>|</span><label class="collapse" for="c-41718371">[-]</label><label class="expand" for="c-41718371">[1 more]</label></div><br/><div class="children"><div class="content">That can be said of any program written in a pure declarative language, but even so not all of them look like SQL. And, yes, they are still programs.</div><br/></div></div></div></div><div id="41718038" class="c"><input type="checkbox" id="c-41718038" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714060">parent</a><span>|</span><a href="#41714316">prev</a><span>|</span><a href="#41713950">next</a><span>|</span><label class="collapse" for="c-41718038">[-]</label><label class="expand" for="c-41718038">[1 more]</label></div><br/><div class="children"><div class="content">Well, it is in the name. Structured Query Language. And I would argue that it is very often right mind send. You are trying to query data, not process it. Thus actually making it query seems rather reasonable paradigm.</div><br/></div></div></div></div><div id="41713950" class="c"><input type="checkbox" id="c-41713950" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713773">parent</a><span>|</span><a href="#41714060">prev</a><span>|</span><a href="#41713831">next</a><span>|</span><label class="collapse" for="c-41713950">[-]</label><label class="expand" for="c-41713950">[3 more]</label></div><br/><div class="children"><div class="content">The nice thing about a vaguely English like language is that your average LLM is going to do a better job of making sense of it.  Because it can leverage its learnings from the entire training set, not just the code-specific portion of it.</div><br/><div id="41714031" class="c"><input type="checkbox" id="c-41714031" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713950">parent</a><span>|</span><a href="#41713831">next</a><span>|</span><label class="collapse" for="c-41714031">[-]</label><label class="expand" for="c-41714031">[2 more]</label></div><br/><div class="children"><div class="content">Not for generating it, because the more it looks like prose the more the LLM&#x27;s output will be influenced by all the prose it&#x27;s ingested.</div><br/><div id="41715153" class="c"><input type="checkbox" id="c-41715153" checked=""/><div class="controls bullet"><span class="by">crackez</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714031">parent</a><span>|</span><a href="#41713831">next</a><span>|</span><label class="collapse" for="c-41715153">[-]</label><label class="expand" for="c-41715153">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used o365 copilot to analyze a COBOL app I had source code to, and it was great at explaining how the code worked. Made writing an interface to it a breeze with some sample code and I swear I am not a COBOL person, I&#x27;m just the Linux guy trying to help a buddy out...<p>It also does a reasonable job of generating working COBOL. I had to fix up just a few errors in the data definitions as the llm generated badly sized data members, but it was pretty smooth. Much smoother than my experiences with llm&#x27;s and Python. What a crap shoot Python is with llm&#x27;s...</div><br/></div></div></div></div></div></div></div></div><div id="41713831" class="c"><input type="checkbox" id="c-41713831" checked=""/><div class="controls bullet"><span class="by">Smar</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713676">parent</a><span>|</span><a href="#41713773">prev</a><span>|</span><a href="#41715981">next</a><span>|</span><label class="collapse" for="c-41713831">[-]</label><label class="expand" for="c-41713831">[4 more]</label></div><br/><div class="children"><div class="content">&gt; print food if tasty?<p>Ruby is nice.</div><br/><div id="41715258" class="c"><input type="checkbox" id="c-41715258" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713831">parent</a><span>|</span><a href="#41715981">next</a><span>|</span><label class="collapse" for="c-41715258">[-]</label><label class="expand" for="c-41715258">[3 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m in a minority, but I genuinely dislike conditions placed afterwards.<p>They feel great to type out when you&#x27;re in the flow, but coming back and reading them grates on my nerves. Seeing the condition first means I load a logical branch into my mental context. Seeing the condition <i>after</i> means I have to rewrite the context of what I just read to become part of a logical branch, and now the flow of reading is broken.</div><br/><div id="41716479" class="c"><input type="checkbox" id="c-41716479" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41715258">parent</a><span>|</span><a href="#41716438">next</a><span>|</span><label class="collapse" for="c-41716479">[-]</label><label class="expand" for="c-41716479">[1 more]</label></div><br/><div class="children"><div class="content">Try thinking of it as prefix if and infix if?<p>And in any event it’s a very natural language pattern if you know what I mean.</div><br/></div></div></div></div></div></div><div id="41715981" class="c"><input type="checkbox" id="c-41715981" checked=""/><div class="controls bullet"><span class="by">analog31</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713676">parent</a><span>|</span><a href="#41713831">prev</a><span>|</span><a href="#41716905">next</a><span>|</span><label class="collapse" for="c-41715981">[-]</label><label class="expand" for="c-41715981">[1 more]</label></div><br/><div class="children"><div class="content">Man that&#x27;s almost like Hypercard.</div><br/></div></div><div id="41716905" class="c"><input type="checkbox" id="c-41716905" checked=""/><div class="controls bullet"><span class="by">kernal</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713676">parent</a><span>|</span><a href="#41715981">prev</a><span>|</span><a href="#41714461">next</a><span>|</span><label class="collapse" for="c-41716905">[-]</label><label class="expand" for="c-41716905">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Nobody writes MULTIPLY A BY B GIVING C ON SIZE ERROR STOP RUN.<p>You had me at MULTIPLY A BY B</div><br/></div></div></div></div><div id="41714461" class="c"><input type="checkbox" id="c-41714461" checked=""/><div class="controls bullet"><span class="by">9659</span><span>|</span><a href="#41713561">parent</a><span>|</span><a href="#41713676">prev</a><span>|</span><a href="#41713643">next</a><span>|</span><label class="collapse" for="c-41714461">[-]</label><label class="expand" for="c-41714461">[1 more]</label></div><br/><div class="children"><div class="content">This was almost true in 2000.  It is not true now.  Things change.  Slowly.</div><br/></div></div><div id="41713643" class="c"><input type="checkbox" id="c-41713643" checked=""/><div class="controls bullet"><span class="by">j0hnyl</span><span>|</span><a href="#41713561">parent</a><span>|</span><a href="#41714461">prev</a><span>|</span><a href="#41714917">next</a><span>|</span><label class="collapse" for="c-41713643">[-]</label><label class="expand" for="c-41713643">[6 more]</label></div><br/><div class="children"><div class="content">But are these legacy systems from the 70s, 80s, 90s using modern cobol?</div><br/><div id="41714708" class="c"><input type="checkbox" id="c-41714708" checked=""/><div class="controls bullet"><span class="by">NikolaNovak</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713643">parent</a><span>|</span><a href="#41714592">next</a><span>|</span><label class="collapse" for="c-41714708">[-]</label><label class="expand" for="c-41714708">[1 more]</label></div><br/><div class="children"><div class="content">Depends what you mean; but not necessarily.<p>I am managing an ERP system implemented &#x2F; went live in 2016. It&#x27;s working on modern P10 hardware, which was released in 2021. The ERP system is continually updated by the vendor and customized by the client.<p>Even for COBOL running on an actual mainframe, which I think most HNers would think of 1970s dinosaur, most of the actual machines in production would be pretty new. IBM z16 was launched in 2022.<p>So they are &quot;legacy systems&quot; in the sense they&#x27;re not written on a javascript framework which was launched last week, running on lambda instances in AWS :). But they are not &quot;OLD&quot; systems, as such.</div><br/></div></div><div id="41714592" class="c"><input type="checkbox" id="c-41714592" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713643">parent</a><span>|</span><a href="#41714708">prev</a><span>|</span><a href="#41713722">next</a><span>|</span><label class="collapse" for="c-41714592">[-]</label><label class="expand" for="c-41714592">[1 more]</label></div><br/><div class="children"><div class="content">Almost certainly yes. The &quot;legacy systems&quot; are likely running on versions of the mainframe with long-term support contracts, whose vendors are committed to providing newer compilers with support for newer versions of the specification as necessary.</div><br/></div></div><div id="41713722" class="c"><input type="checkbox" id="c-41713722" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713643">parent</a><span>|</span><a href="#41714592">prev</a><span>|</span><a href="#41714917">next</a><span>|</span><label class="collapse" for="c-41713722">[-]</label><label class="expand" for="c-41713722">[3 more]</label></div><br/><div class="children"><div class="content">When you hear about people being paid $X vs 10x$X to fix some cobol; is there a correlation between the age of the cobol system?</div><br/><div id="41714078" class="c"><input type="checkbox" id="c-41714078" checked=""/><div class="controls bullet"><span class="by">HeyLaughingBoy</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41713722">parent</a><span>|</span><a href="#41714917">next</a><span>|</span><label class="collapse" for="c-41714078">[-]</label><label class="expand" for="c-41714078">[2 more]</label></div><br/><div class="children"><div class="content">Probably not; just a matter of how desperate they are.</div><br/><div id="41718263" class="c"><input type="checkbox" id="c-41718263" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41713561">root</a><span>|</span><a href="#41714078">parent</a><span>|</span><a href="#41714917">next</a><span>|</span><label class="collapse" for="c-41718263">[-]</label><label class="expand" for="c-41718263">[1 more]</label></div><br/><div class="children"><div class="content">Which is also a function of how hard it is to find someone who has the required skills to address the problem</div><br/></div></div></div></div></div></div></div></div><div id="41714917" class="c"><input type="checkbox" id="c-41714917" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41713561">parent</a><span>|</span><a href="#41713643">prev</a><span>|</span><a href="#41715174">next</a><span>|</span><label class="collapse" for="c-41714917">[-]</label><label class="expand" for="c-41714917">[1 more]</label></div><br/><div class="children"><div class="content">More accurate might be &quot;I don&#x27;t know what the language of 2000 will be called, but I know it will look like Fortran.&quot;</div><br/></div></div><div id="41715174" class="c"><input type="checkbox" id="c-41715174" checked=""/><div class="controls bullet"><span class="by">TMWNN</span><span>|</span><a href="#41713561">parent</a><span>|</span><a href="#41714917">prev</a><span>|</span><a href="#41714262">next</a><span>|</span><label class="collapse" for="c-41715174">[-]</label><label class="expand" for="c-41715174">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;I don&#x27;t know what the language of the year 2000 will look like, but I know it will be called Fortran.&quot; —Tony Hoare<p>Kemeny and Kurtz described Fortran as &quot;old-fashioned&quot; in 1968! &lt;<a href="https:&#x2F;&#x2F;dtss.dartmouth.edu&#x2F;sciencearticle&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;dtss.dartmouth.edu&#x2F;sciencearticle&#x2F;index.html</a>&gt;</div><br/></div></div></div></div><div id="41714262" class="c"><input type="checkbox" id="c-41714262" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41713561">prev</a><span>|</span><a href="#41713999">next</a><span>|</span><label class="collapse" for="c-41714262">[-]</label><label class="expand" for="c-41714262">[26 more]</label></div><br/><div class="children"><div class="content">Note: I&#x27;m getting some hate from others who think I would pick or prefer COBOL over a modern language. I wouldn&#x27;t. I was making an outside-the-box &quot;devil&#x27;s advocate&quot; objective observation. I just wanted to preface that here. Okay, the rest of my original comment remains below:<p>The irony is that we already had a memory safe and stable language in Cobol that was easier to read and understand than Rust. But, no one wants to use it so it is &quot;dead&quot; but it runs everything that made the modern age possible.<p>RUST:<p>println!(&quot;Enter number: &quot;);<p>let mut input_string = String::new();<p>io::stdin().read_line(&amp;mut input_string).unwrap();<p>let number: i32 = input_string.trim().parse().expect(&quot;Please enter a valid number.&quot;);<p>let result = if number % 2 == 0 {<p><pre><code>    &quot;EVEN&quot;
</code></pre>
} else {<p><pre><code>    &quot;ODD&quot;
</code></pre>
};<p>println!(&quot;The number: {}&quot;, result);<p>COBOL:<p>display &#x27;Enter number: &#x27;<p>accept number<p>if function mod(number,2) = 0<p><pre><code>    move &#x27;even&#x27; to result
</code></pre>
else<p><pre><code>    move &#x27;odd&#x27; to result
</code></pre>
end-if<p>display &#x27;The number: &#x27;,result</div><br/><div id="41714337" class="c"><input type="checkbox" id="c-41714337" checked=""/><div class="controls bullet"><span class="by">sestep</span><span>|</span><a href="#41714262">parent</a><span>|</span><a href="#41715323">next</a><span>|</span><label class="collapse" for="c-41714337">[-]</label><label class="expand" for="c-41714337">[4 more]</label></div><br/><div class="children"><div class="content">This is a weird take. Sure, plenty of cool&#x2F;nice things from old languages (e.g. variable-sized stack frames in Ada) get lost, and some then get rediscovered by future languages, potentially wasting effort. And I don&#x27;t know COBOL, so maybe you&#x27;re actually making a good point.<p>But I find that hard to believe. Does COBOL really solve all the same problems Rust is intended to solve? Is it as performant? Can it interface with native code from other languages in the same way? Does it have a usable and sane package manager built on top of a module system that facilitates composability and backward compatibility? Does it have a way to describe the shape of data and errors as ergonomically as Rust&#x27;s algebraic data types?<p>Genuinely curious: as I said, I don&#x27;t know COBOL. I&#x27;d find it extremely surprising if the answers to all these questions are &quot;yes,&quot; though. Just as there are reasons COBOL is still used, there are also (good) reasons new languages have been created.</div><br/><div id="41714686" class="c"><input type="checkbox" id="c-41714686" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714337">parent</a><span>|</span><a href="#41714379">next</a><span>|</span><label class="collapse" for="c-41714686">[-]</label><label class="expand" for="c-41714686">[1 more]</label></div><br/><div class="children"><div class="content">A lot to unpack in this question.<p>Do they solve all the same problems? No, for example COBOL lacks a modern concept of concurrency within a single program. COBOL&#x27;s concurrency features are based on task-level parallelism, which involves dividing a program into multiple tasks that can be executed concurrently.<p>Is it performant? Yes. COBOL is highly efficient particularly in handling large datasets and complex business logic and its compilers are optimized for reliability and speed.<p>Can it interface with native code? Yes.<p>Does it have a package manager? No.<p>Does it describe shape of data? No. Data structures in COBOL are defined using fixed-length records.<p>Note: I&#x27;m not a COBOL expert. I did learn it in college, though.</div><br/></div></div><div id="41714379" class="c"><input type="checkbox" id="c-41714379" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714337">parent</a><span>|</span><a href="#41714686">prev</a><span>|</span><a href="#41715323">next</a><span>|</span><label class="collapse" for="c-41714379">[-]</label><label class="expand" for="c-41714379">[2 more]</label></div><br/><div class="children"><div class="content">Imagine having a shell script being called from a cron job that writes data in a bunch of tab separated memory mapped files (memory mapping happens when you configure the thing), but you have more files than memory. And all the shell scripts call and include each other and have global variables too.<p>And that underpins most of the critical infrastructure in your country.</div><br/><div id="41716508" class="c"><input type="checkbox" id="c-41716508" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714379">parent</a><span>|</span><a href="#41715323">next</a><span>|</span><label class="collapse" for="c-41716508">[-]</label><label class="expand" for="c-41716508">[1 more]</label></div><br/><div class="children"><div class="content">Except mainframe IO and interrupts actually work reliably. Unix on the other hand is a proud member of the worse is better club. It still doesn’t really handle interrupts correctly, but thanks to 40 years of kludges most people consider it close enough.</div><br/></div></div></div></div></div></div><div id="41715323" class="c"><input type="checkbox" id="c-41715323" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#41714262">parent</a><span>|</span><a href="#41714337">prev</a><span>|</span><a href="#41715404">next</a><span>|</span><label class="collapse" for="c-41715323">[-]</label><label class="expand" for="c-41715323">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit odd to say these programs are comparable when the Cobol version isn&#x27;t handling errors whereas the Rust program is (by panicking, but that&#x27;s better than the silently wrong behavior of the Cobol one). Here&#x27;s a runnable version of the above Cobol program (adding the necessary boilerplate); note that it prints &quot;even&quot; for an input of `abc` and &quot;odd&quot; for an input of `12`:<p><pre><code>    identification division.
        program-id.
            even-or-odd.
    data division.
        working-storage section.
            01 num pic 9.
            01 result pic x(4).
    procedure division.
        display &#x27;Enter number: &#x27;
    
        accept num
    
        if function mod(num, 2) = 0
            move &#x27;even&#x27; to result
        else
            move &#x27;odd&#x27; to result
        end-if
    
        display &#x27;The number: &#x27;, result
    stop run.
</code></pre>
It&#x27;s peculiar to call out Rust&#x27;s syntax specifically when, like most other languages these days, is mostly C-like (though with a sprinkling of OCaml). And syntax aside, Rust and Cobol have wildly different goals, so &quot;just use Cobol&quot; doesn&#x27;t suffice to obviate Rust&#x27;s purpose for existing.</div><br/><div id="41715383" class="c"><input type="checkbox" id="c-41715383" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41715323">parent</a><span>|</span><a href="#41715404">next</a><span>|</span><label class="collapse" for="c-41715383">[-]</label><label class="expand" for="c-41715383">[1 more]</label></div><br/><div class="children"><div class="content">Good catch! My cobol is rust-y. :D<p>I guess my post is getting misread as &quot;just use cobol&quot; when it was more of a XKCD-like reflection; e.g. why did we all do that &#x2F; keep doing that. We done did Cobol, and Rust. And, one is &quot;dead&quot; but not really and now here we are.<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;</a></div><br/></div></div></div></div><div id="41715404" class="c"><input type="checkbox" id="c-41715404" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41714262">parent</a><span>|</span><a href="#41715323">prev</a><span>|</span><a href="#41714356">next</a><span>|</span><label class="collapse" for="c-41715404">[-]</label><label class="expand" for="c-41715404">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, <a href="https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;cobol-zos&#x2F;6.2?topic=statement-example-allocate-free-storage-unbounded-tables" rel="nofollow">https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;en&#x2F;cobol-zos&#x2F;6.2?topic=statement-ex...</a> seems to be demonstrating a language that is not memory-safe (maybe it used to be, but how?)<p><pre><code>  COMPUTE SIZE-NEEDED = LENGTH OF OBJ + LENGTH OF VARTAB * NUM-ELEMENTS
  ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR
  SET ADDRESS OF VARGRP TO VPTR
  MOVE NUM-ELEMENTS TO OBJ
  MOVE BUFFER(1:SIZE-NEEDED) TO VARGRP
  SET VPTR TO ADDRESS OF BUFFER
  FREE VPTR</code></pre></div><br/><div id="41715670" class="c"><input type="checkbox" id="c-41715670" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41715404">parent</a><span>|</span><a href="#41714356">next</a><span>|</span><label class="collapse" for="c-41715670">[-]</label><label class="expand" for="c-41715670">[1 more]</label></div><br/><div class="children"><div class="content">The compiler would have rejected that, if I remember correctly. I&#x27;m not in the field of cobol myself, I learned it briefly in college ages ago.</div><br/></div></div></div></div><div id="41714356" class="c"><input type="checkbox" id="c-41714356" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41714262">parent</a><span>|</span><a href="#41715404">prev</a><span>|</span><a href="#41714818">next</a><span>|</span><label class="collapse" for="c-41714356">[-]</label><label class="expand" for="c-41714356">[12 more]</label></div><br/><div class="children"><div class="content">Shell script is memory safe too, but you don&#x27;t write anything longer than 100 lines in it for a reason.</div><br/><div id="41714391" class="c"><input type="checkbox" id="c-41714391" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714356">parent</a><span>|</span><a href="#41715428">next</a><span>|</span><label class="collapse" for="c-41714391">[-]</label><label class="expand" for="c-41714391">[10 more]</label></div><br/><div class="children"><div class="content">When you bank, COBOL (40% of online banks).
When you use the ATM, COBOL (95% of ATM transactions).
When you travel, COBOL (96% of airline ticket bookings).
Healthcare, COBOL.
Social Security, COBOL.
Point of Sale, COBOL.
IRS, COBOL.
Pension funds? COBOL. Hotel bookings? COBOL. Payroll programs? COBOL.<p>It is estimated that there is 800 billion lines of COBOL code in production systems in daily use. That is a bit more than 100 lines.<p>This was why Y2K genuinely scared everyone and was a very real problem. The only reason we can look back at it and laugh now is that an army of engineers sat down and rewrote it all in the nick of time.</div><br/><div id="41716024" class="c"><input type="checkbox" id="c-41716024" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714391">parent</a><span>|</span><a href="#41714591">next</a><span>|</span><label class="collapse" for="c-41716024">[-]</label><label class="expand" for="c-41716024">[1 more]</label></div><br/><div class="children"><div class="content">The Y2K effort was much more nuanced than this. I was there for it and it was more like highly targeted patching based on carefully crafted test sets and frameworks.<p>&gt; army of engineers sat down and rewrote it all in the nick of time.<p>No way did all get rewritten. Where source was available, fixes were applied and systems retested.<p>True drama ensued for programs for which the source was no longer obtainable.<p>The company I was at during that time had programs that had been in production since at least 1960.<p>The other effort that took place was attending to the systems during the midnight boundary with everybody either in the office or on call.<p>The other strong observation was that the risks were very much not understood, with exaggerations both extreme and dismissive.  Also not discussed in the popular press at the time was the extent that most of these systems were not truly totally automated.</div><br/></div></div><div id="41714591" class="c"><input type="checkbox" id="c-41714591" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714391">parent</a><span>|</span><a href="#41716024">prev</a><span>|</span><a href="#41714485">next</a><span>|</span><label class="collapse" for="c-41714591">[-]</label><label class="expand" for="c-41714591">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big enjoyer of arcain arts, but I happen to work in a place that actually has it and no -- nobody likes COBOL and it&#x27;s not cool in any sense.</div><br/><div id="41714761" class="c"><input type="checkbox" id="c-41714761" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714591">parent</a><span>|</span><a href="#41714485">next</a><span>|</span><label class="collapse" for="c-41714761">[-]</label><label class="expand" for="c-41714761">[2 more]</label></div><br/><div class="children"><div class="content">Well, there is a good reason no one likes it. It isn&#x27;t cool, I completely agree. Readable, simple, safe, performant and still relevant though? Ya.</div><br/><div id="41715050" class="c"><input type="checkbox" id="c-41715050" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714761">parent</a><span>|</span><a href="#41714485">next</a><span>|</span><label class="collapse" for="c-41715050">[-]</label><label class="expand" for="c-41715050">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Readable, simple, safe, performant and still relevant though?<p>It&#x27;s performant, you can&#x27;t take away that.</div><br/></div></div></div></div></div></div><div id="41714485" class="c"><input type="checkbox" id="c-41714485" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714391">parent</a><span>|</span><a href="#41714591">prev</a><span>|</span><a href="#41715428">next</a><span>|</span><label class="collapse" for="c-41714485">[-]</label><label class="expand" for="c-41714485">[5 more]</label></div><br/><div class="children"><div class="content">Legacy code yeah, nobody&#x27;s hitting File &gt; New Project in COBOL<p>It&#x27;s just that nobody understands how the systems work and they&#x27;re ossified. Those systems are going to be emulated until our grandchildren take over because nobody can understand them well enough to craft a replacement. Juuuust up until an LLM rewrites them for us.<p>[edit] I mean those airlines systems are so old that they don&#x27;t support special characters on names, passenger names are two fixed-length fields (first name, last name) and title and middle name just gets appended together.<p>So you get LASTNAME&#x2F;FIRSTNAMEMIDDLENAMENTITLE on your bookings. And each of those fields is truncated lol.<p><i>and</i> of course flight numbers are fixed at 4 digits, so we&#x27;re running out of those.<p>Not exactly a great ad.</div><br/><div id="41715025" class="c"><input type="checkbox" id="c-41715025" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714485">parent</a><span>|</span><a href="#41714529">next</a><span>|</span><label class="collapse" for="c-41715025">[-]</label><label class="expand" for="c-41715025">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Legacy code&quot; is also known as &quot;the important code that makes the business work&quot;<p>If these new fangled languages are so great, one day they can be legacy code too. :P</div><br/><div id="41715125" class="c"><input type="checkbox" id="c-41715125" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41715025">parent</a><span>|</span><a href="#41714529">next</a><span>|</span><label class="collapse" for="c-41715125">[-]</label><label class="expand" for="c-41715125">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what makes something legacy. Legacy is something highly not advisable to change because it&#x27;s both makes the business work and can&#x27;t be easily changed because of complexity, loss of context, high blast radius or whatever. It&#x27;s just there and you have to deal with it. If it wasn&#x27;t complex, opaque and scary to touch it would not have been just another piece of something to be replaced and updated like the copyright date in the footer.</div><br/></div></div></div></div><div id="41714529" class="c"><input type="checkbox" id="c-41714529" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714485">parent</a><span>|</span><a href="#41715025">prev</a><span>|</span><a href="#41715428">next</a><span>|</span><label class="collapse" for="c-41714529">[-]</label><label class="expand" for="c-41714529">[2 more]</label></div><br/><div class="children"><div class="content">Oof, I&#x27;ve got good news and bad news for you.... they still are creating new code in it.<p>Yeah, there are fewer engineers in COBOL which is why it pays BIG bucks now. They desperately need someone to maintain that massive infrastructure that has been built up over 75 years that cannot be replaced easily or quickly.</div><br/></div></div></div></div></div></div><div id="41715428" class="c"><input type="checkbox" id="c-41715428" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714356">parent</a><span>|</span><a href="#41714391">prev</a><span>|</span><a href="#41714818">next</a><span>|</span><label class="collapse" for="c-41715428">[-]</label><label class="expand" for="c-41715428">[1 more]</label></div><br/><div class="children"><div class="content">Besides - standard COBOL is only &quot;memory-safe&quot; by way of not supporting dynamic memory allocation. Like, at all. Even strings are stored in fixed-length arrays.<p>&quot;A ship in harbor is safe, but that is not what ships are built for.&quot;</div><br/></div></div></div></div><div id="41714818" class="c"><input type="checkbox" id="c-41714818" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#41714262">parent</a><span>|</span><a href="#41714356">prev</a><span>|</span><a href="#41713999">next</a><span>|</span><label class="collapse" for="c-41714818">[-]</label><label class="expand" for="c-41714818">[5 more]</label></div><br/><div class="children"><div class="content">Bizarre comment. No developer who should be allowed anywhere near a computer would ever consider choosing COBOL where Rust is appropriate or vice versa.</div><br/><div id="41715071" class="c"><input type="checkbox" id="c-41715071" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714818">parent</a><span>|</span><a href="#41714936">next</a><span>|</span><label class="collapse" for="c-41715071">[-]</label><label class="expand" for="c-41715071">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. It&#x27;s easy to have memory safety when you don&#x27;t even support heap allocation.  Now if OP had said &quot;Java&quot; or &quot;C#&quot; instead of &quot;COBOL&quot;, they would&#x27;ve had a solid point.  But the way Rust ensures memory safety without mandating GC while still allowing for complex allocation patterns can be said to be practically unfeasible for any of the usual &quot;legacy&quot; languages, with the notable exception of Ada.</div><br/></div></div><div id="41714936" class="c"><input type="checkbox" id="c-41714936" checked=""/><div class="controls bullet"><span class="by">palisade</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714818">parent</a><span>|</span><a href="#41715071">prev</a><span>|</span><a href="#41715010">next</a><span>|</span><label class="collapse" for="c-41714936">[-]</label><label class="expand" for="c-41714936">[2 more]</label></div><br/><div class="children"><div class="content">Well, I said it was ironic that we went out of our way to make a newer more complicated to read language that was memory safe when we already had a language that was simpler and readable that was safe.<p>I didn&#x27;t say I wanted to code in it, though. I&#x27;d prefer in no particular order Kotlin, Python, Go, C++, Rust, Perl, C#, Java, Zig, etc. Anything really over COBOL myself. I&#x27;m part of the problem.<p>But, if I was hard up for money and wasn&#x27;t getting nibbles for jobs? I could see getting into COBOL because there is a lot of money in it and always work available.<p>My statement stands though, we need to do better when designing the syntax of our languages. Cobol is disliked, yet simple and readable. What does that say about our new languages. How hated are our &quot;new&quot; language remnants going to be when few of us are longer around to maintain them 50 - 75 years from now? And, how easy are they going to be to pick up?<p>Addendum: I guess it won&#x27;t matter if the singularity comes and just writes it all for us, of course. Then it will all just be machine code and we won&#x27;t need these &quot;only human&quot; translation layers any longer.</div><br/><div id="41715996" class="c"><input type="checkbox" id="c-41715996" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714936">parent</a><span>|</span><a href="#41715010">next</a><span>|</span><label class="collapse" for="c-41715996">[-]</label><label class="expand" for="c-41715996">[1 more]</label></div><br/><div class="children"><div class="content">Is COBOL actually memory safe in the same way Rust is memory safe? I thought it was just &quot;we don&#x27;t allow dynamic allocation&quot;, and I&#x27;d assume programmers often implement their own half-baked dynamic allocation on top.</div><br/></div></div></div></div><div id="41715010" class="c"><input type="checkbox" id="c-41715010" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#41714262">root</a><span>|</span><a href="#41714818">parent</a><span>|</span><a href="#41714936">prev</a><span>|</span><a href="#41713999">next</a><span>|</span><label class="collapse" for="c-41715010">[-]</label><label class="expand" for="c-41715010">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the use cases for Cobol (bank software) typically overlap with those for Rust (operating systems...etc).<p>It&#x27;s like saying no gardener should be allowed near a garden that would choose a shovel over a pair of shears. Both have a place.</div><br/></div></div></div></div></div></div><div id="41713999" class="c"><input type="checkbox" id="c-41713999" checked=""/><div class="controls bullet"><span class="by">snovymgodym</span><span>|</span><a href="#41714262">prev</a><span>|</span><a href="#41714896">next</a><span>|</span><label class="collapse" for="c-41713999">[-]</label><label class="expand" for="c-41713999">[7 more]</label></div><br/><div class="children"><div class="content">As always, these discussions will depend on your definition of &quot;dead&quot; and &quot;alive&quot;.<p>If we can call a technology dead once no new business is built on it, then I think we can safely call COBOL dead (and the IBM 390x aka Z&#x2F;OS platform along with it, for which &quot;COBOL&quot; is usually a proxy).<p>But if we say that anything still being used in production is not dead, then of course COBOL is alive and significantly more alive than many other things which are younger than it.<p>But this shouldn&#x27;t really be taken as a positive point for COBOL or the mainframe ecosystem. It&#x27;s simply a fact of life that organizations tend to stick with the first thing that works, and for the types of entities involved in the first wave of digitalization (e.g. governments, banks, airlines) that was usually an IBM mainframe along with the software that runs on it.</div><br/><div id="41717825" class="c"><input type="checkbox" id="c-41717825" checked=""/><div class="controls bullet"><span class="by">8fingerlouie</span><span>|</span><a href="#41713999">parent</a><span>|</span><a href="#41714665">next</a><span>|</span><label class="collapse" for="c-41717825">[-]</label><label class="expand" for="c-41717825">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and the IBM 390x aka Z&#x2F;OS platform along with it<p>The problem with killing the mainframe is that no other platform really exists that can handle the amount of simultanous IO that you can get on a mainframe. Our mainframe easily processes 100m transactions per hour, with room to spare. And keep in mind that those transactions are for the most part synchronous, and will result in multiple SQL transactions per transaction.<p>Yes, eventual consistency is a thing, but it&#x27;s a very bad match with the financial world at least, and maybe also military, insurance or medical&#x2F;health. You can of course also partition the workload, but again, that creates consistency issues when going across shards.<p>Also, COBOL is far from dead, but it&#x27;s slowly getting there. I don&#x27;t know of a single bank that isn&#x27;t actively working on getting out of the mainframe, though all projections i&#x27;ve seen says that the mainframe and COBOL will be around until at least 2050.<p>Give that a thought. That&#x27;s 26 years of writing COBOL. Considering that COBOL programmers are also highly sought after, and usually well paid, one could literally still begin a career as a COBOL programmer today and almost get a full work life worth of it.</div><br/></div></div><div id="41714665" class="c"><input type="checkbox" id="c-41714665" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#41713999">parent</a><span>|</span><a href="#41717825">prev</a><span>|</span><a href="#41717144">next</a><span>|</span><label class="collapse" for="c-41714665">[-]</label><label class="expand" for="c-41714665">[4 more]</label></div><br/><div class="children"><div class="content">&gt; we can call a technology dead once no new business is built on it<p>You don’t suppose any bank - or other large financial institution - might have standardised on Cobol for their core business flows&#x2F;processes? In which case a new business-unit or “internal startup” team (e.g. a new category of insurance product) might very-well have some part written in Cobol so it integrates with the rest of the bank - or at very-least might be built-on-top of the org’s existing Cobol-running infrastructure (i.e. Not written in Cobol, but still runs on Z&#x2F;OS because there’s no budget for buying new commodity x86 racks and the people to manage and run them).</div><br/><div id="41715684" class="c"><input type="checkbox" id="c-41715684" checked=""/><div class="controls bullet"><span class="by">snovymgodym</span><span>|</span><a href="#41713999">root</a><span>|</span><a href="#41714665">parent</a><span>|</span><a href="#41716473">next</a><span>|</span><label class="collapse" for="c-41715684">[-]</label><label class="expand" for="c-41715684">[1 more]</label></div><br/><div class="children"><div class="content">Sure, I know for a fact that what you&#x27;re describing exists. That&#x27;s not really what I mean by new business being built on it. That&#x27;s a case of a very large and old business already being so locked into the mainframe ecosystem for their core systems that anything new they try to do ends up needing some kind of integration system with the legacy system.<p>What I mean is that nobody starts a business today and says &quot;Ok, we need an IBM mainframe running DB2 and we&#x27;ll have a bunch of COBOL, ReXX, and PL&#x2F;I programs for handling our business logic&quot;.</div><br/></div></div><div id="41716473" class="c"><input type="checkbox" id="c-41716473" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#41713999">root</a><span>|</span><a href="#41714665">parent</a><span>|</span><a href="#41715684">prev</a><span>|</span><a href="#41717144">next</a><span>|</span><label class="collapse" for="c-41716473">[-]</label><label class="expand" for="c-41716473">[2 more]</label></div><br/><div class="children"><div class="content">I was under the impression that banks with core COBOL processes all had an intermediate layer in Java&#x2F;C# to deal with these kind of integration.<p>We saw exactly the case of a new business unit being created, and like most other units it wouldn&#x27;t get direct access to the lowest layer, and interact instead with a saner level of API and modules in the language of their stack.</div><br/><div id="41717083" class="c"><input type="checkbox" id="c-41717083" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#41713999">root</a><span>|</span><a href="#41716473">parent</a><span>|</span><a href="#41717144">next</a><span>|</span><label class="collapse" for="c-41717083">[-]</label><label class="expand" for="c-41717083">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that my impression too - I haven&#x27;t worked in banking but I&#x27;ve worked at a few places with core functionality written in Fortran and then web-facing API layers on top of that (some was in Java in think).</div><br/></div></div></div></div></div></div><div id="41717144" class="c"><input type="checkbox" id="c-41717144" checked=""/><div class="controls bullet"><span class="by">calibas</span><span>|</span><a href="#41713999">parent</a><span>|</span><a href="#41714665">prev</a><span>|</span><a href="#41714896">next</a><span>|</span><label class="collapse" for="c-41717144">[-]</label><label class="expand" for="c-41717144">[1 more]</label></div><br/><div class="children"><div class="content">COBOL is undead.</div><br/></div></div></div></div><div id="41714896" class="c"><input type="checkbox" id="c-41714896" checked=""/><div class="controls bullet"><span class="by">gpraghu</span><span>|</span><a href="#41713999">prev</a><span>|</span><a href="#41713416">next</a><span>|</span><label class="collapse" for="c-41714896">[-]</label><label class="expand" for="c-41714896">[3 more]</label></div><br/><div class="children"><div class="content">A touching article! I have enjoyed similar times with my grandpa. On the topic of Cobol, I simply don&#x27;t understand why people hate it so much. It has a shallow learning curve like Python, is self-documenting enough that one doesn&#x27;t need to write a bunch of text, and is available on every conceivable architecture, with great performance. I personally wrote a payroll for an entire factory on a B1800 with 128K of memory and a 10MB hard disk! So what&#x27;s to complain? In my mind, Java is deader than Cobol!</div><br/><div id="41714913" class="c"><input type="checkbox" id="c-41714913" checked=""/><div class="controls bullet"><span class="by">ape4</span><span>|</span><a href="#41714896">parent</a><span>|</span><a href="#41713416">next</a><span>|</span><label class="collapse" for="c-41714913">[-]</label><label class="expand" for="c-41714913">[2 more]</label></div><br/><div class="children"><div class="content">Its the amount of boiler plate that people hate.</div><br/><div id="41714989" class="c"><input type="checkbox" id="c-41714989" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#41714896">root</a><span>|</span><a href="#41714913">parent</a><span>|</span><a href="#41713416">next</a><span>|</span><label class="collapse" for="c-41714989">[-]</label><label class="expand" for="c-41714989">[1 more]</label></div><br/><div class="children"><div class="content">I think there’s something to that but there’s also a lot of selectivity there. Many of the same people who complained about COBOL because it was verbose adopted things like enterprise Java, so there’s more than a suggestion that this might be a less than completely objective assessment.<p>The bigger problem: COBOL was an open standard but none of the implementations were open source for ages (I haven’t looked at GNU COBOL in years, but I think this is no longer the case) so nobody was building new things or experience when they had to pay to get started.</div><br/></div></div></div></div></div></div><div id="41713416" class="c"><input type="checkbox" id="c-41713416" checked=""/><div class="controls bullet"><span class="by">cwbriscoe</span><span>|</span><a href="#41714896">prev</a><span>|</span><a href="#41717991">next</a><span>|</span><label class="collapse" for="c-41713416">[-]</label><label class="expand" for="c-41713416">[17 more]</label></div><br/><div class="children"><div class="content">Started my career doing Y2K stuff in 1998 and I still touch COBOL here and there today.  I have a 10,000 line CICS program that runs every 30 seconds that I wrote in 2010.  It has never failed since.</div><br/><div id="41713934" class="c"><input type="checkbox" id="c-41713934" checked=""/><div class="controls bullet"><span class="by">supportengineer</span><span>|</span><a href="#41713416">parent</a><span>|</span><a href="#41713520">next</a><span>|</span><label class="collapse" for="c-41713934">[-]</label><label class="expand" for="c-41713934">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I liked about developing Oracle stored procedures activated by cron jobs.  Ran for 5 years, no maintenance needed.</div><br/><div id="41714170" class="c"><input type="checkbox" id="c-41714170" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713934">parent</a><span>|</span><a href="#41713520">next</a><span>|</span><label class="collapse" for="c-41714170">[-]</label><label class="expand" for="c-41714170">[1 more]</label></div><br/><div class="children"><div class="content">That seems like a low barrier of expectations. I can think of several DB&#x27;s that would run exactly like that.</div><br/></div></div></div></div><div id="41713520" class="c"><input type="checkbox" id="c-41713520" checked=""/><div class="controls bullet"><span class="by">bdjsiqoocwk</span><span>|</span><a href="#41713416">parent</a><span>|</span><a href="#41713934">prev</a><span>|</span><a href="#41717991">next</a><span>|</span><label class="collapse" for="c-41713520">[-]</label><label class="expand" for="c-41713520">[14 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand these &quot;never failed&quot; comments. Without further context, it&#x27;s meaningless. If I write a python script and never change anything in its environtment or inputs, it won&#x27;t fail either. That&#x27;s not specific to cobol.</div><br/><div id="41713653" class="c"><input type="checkbox" id="c-41713653" checked=""/><div class="controls bullet"><span class="by">_old_dude_</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713520">parent</a><span>|</span><a href="#41714630">next</a><span>|</span><label class="collapse" for="c-41713653">[-]</label><label class="expand" for="c-41713653">[6 more]</label></div><br/><div class="children"><div class="content">COBOL changes very slowly, once in a decade or two.
Python does not offer support of a release for more than 3 years and a half [1].<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;History_of_Python" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;History_of_Python</a></div><br/><div id="41713973" class="c"><input type="checkbox" id="c-41713973" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713653">parent</a><span>|</span><a href="#41713893">next</a><span>|</span><label class="collapse" for="c-41713973">[-]</label><label class="expand" for="c-41713973">[4 more]</label></div><br/><div class="children"><div class="content">I could believe there are legacy installations happily humming away on Python 2.7 without issue.</div><br/><div id="41714173" class="c"><input type="checkbox" id="c-41714173" checked=""/><div class="controls bullet"><span class="by">remlov</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713973">parent</a><span>|</span><a href="#41713893">next</a><span>|</span><label class="collapse" for="c-41714173">[-]</label><label class="expand" for="c-41714173">[3 more]</label></div><br/><div class="children"><div class="content">Several years ago I briefly worked at a major telecommunications provider with services across the southern United States that ran Python 2.4 on their production provisioning servers. Worked just fine.</div><br/><div id="41716864" class="c"><input type="checkbox" id="c-41716864" checked=""/><div class="controls bullet"><span class="by">gavindean90</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41714173">parent</a><span>|</span><a href="#41713893">next</a><span>|</span><label class="collapse" for="c-41716864">[-]</label><label class="expand" for="c-41716864">[2 more]</label></div><br/><div class="children"><div class="content">The difference being that the COBOL is still supported after a decade.</div><br/><div id="41718415" class="c"><input type="checkbox" id="c-41718415" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41716864">parent</a><span>|</span><a href="#41713893">next</a><span>|</span><label class="collapse" for="c-41718415">[-]</label><label class="expand" for="c-41718415">[1 more]</label></div><br/><div class="children"><div class="content">ActiveState still offers a supported Python 2.7 version across all major platforms for those who need it (<a href="https:&#x2F;&#x2F;www.activestate.com&#x2F;products&#x2F;python&#x2F;python-2-7&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.activestate.com&#x2F;products&#x2F;python&#x2F;python-2-7&#x2F;</a>), so that&#x27;s 14 years and counting.<p>If enough stuff needs it, people will keep it running. Java 8 will probably be in the same boat eventually if&#x2F;when Oracle finally drops support.</div><br/></div></div></div></div></div></div></div></div><div id="41713893" class="c"><input type="checkbox" id="c-41713893" checked=""/><div class="controls bullet"><span class="by">yieldcrv</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713653">parent</a><span>|</span><a href="#41713973">prev</a><span>|</span><a href="#41714630">next</a><span>|</span><label class="collapse" for="c-41713893">[-]</label><label class="expand" for="c-41713893">[1 more]</label></div><br/><div class="children"><div class="content">But a compute instance or bare metal computer that never needs a new release wont have to deal with that in python either<p>Its only new builds on someone else’s computer that have this modern issue</div><br/></div></div></div></div><div id="41714630" class="c"><input type="checkbox" id="c-41714630" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713520">parent</a><span>|</span><a href="#41713653">prev</a><span>|</span><a href="#41713574">next</a><span>|</span><label class="collapse" for="c-41714630">[-]</label><label class="expand" for="c-41714630">[1 more]</label></div><br/><div class="children"><div class="content">I understand the context to be that COBOL, as a DSL for batch processing, declares its .data and .bss segments, or the equivalents on host systems, statically in the DATA DIVISION and usually doesn&#x27;t dynamically allocate memory. This, coupled with CPU, memory, and I&#x2F;O bandwidth reservation from a job scheduler on an exclusive hot-swappable partition on a host (z&#x2F;OS aka MVS) plus USVs, redundant disks&#x2F;disk ports, and networks makes &quot;never fail&quot; much more a consequence and primary objective of mainframe architectures where COBOL workloads are usually run.</div><br/></div></div><div id="41713574" class="c"><input type="checkbox" id="c-41713574" checked=""/><div class="controls bullet"><span class="by">kibibu</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713520">parent</a><span>|</span><a href="#41714630">prev</a><span>|</span><a href="#41713870">next</a><span>|</span><label class="collapse" for="c-41713574">[-]</label><label class="expand" for="c-41713574">[1 more]</label></div><br/><div class="children"><div class="content">I imagine the backwards compatibility story of COBOL is a little better than Python&#x27;s</div><br/></div></div><div id="41713870" class="c"><input type="checkbox" id="c-41713870" checked=""/><div class="controls bullet"><span class="by">ang_cire</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713520">parent</a><span>|</span><a href="#41713574">prev</a><span>|</span><a href="#41717032">next</a><span>|</span><label class="collapse" for="c-41713870">[-]</label><label class="expand" for="c-41713870">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re actually patching your python installs, that is by no means certain.</div><br/><div id="41713930" class="c"><input type="checkbox" id="c-41713930" checked=""/><div class="controls bullet"><span class="by">andreasmetsala</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713870">parent</a><span>|</span><a href="#41717032">next</a><span>|</span><label class="collapse" for="c-41713930">[-]</label><label class="expand" for="c-41713930">[3 more]</label></div><br/><div class="children"><div class="content">I don’t think those mainframes running COBOL are getting patched either.</div><br/><div id="41714421" class="c"><input type="checkbox" id="c-41714421" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713930">parent</a><span>|</span><a href="#41714013">next</a><span>|</span><label class="collapse" for="c-41714421">[-]</label><label class="expand" for="c-41714421">[1 more]</label></div><br/><div class="children"><div class="content">They are patched up regularly. The COBOL code itself maybe not, but the runtimes?</div><br/></div></div><div id="41714013" class="c"><input type="checkbox" id="c-41714013" checked=""/><div class="controls bullet"><span class="by">ang_cire</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713930">parent</a><span>|</span><a href="#41714421">prev</a><span>|</span><a href="#41717032">next</a><span>|</span><label class="collapse" for="c-41714013">[-]</label><label class="expand" for="c-41714013">[1 more]</label></div><br/><div class="children"><div class="content">They absolutely are. Modern COBOL (even 25 year old COBOL) isn&#x27;t running on ancient System360&#x2F;370&#x2F;390s or something, it&#x27;s running on modern z&#x2F;OS mainframes.</div><br/></div></div></div></div></div></div><div id="41717032" class="c"><input type="checkbox" id="c-41717032" checked=""/><div class="controls bullet"><span class="by">Spooky23</span><span>|</span><a href="#41713416">root</a><span>|</span><a href="#41713520">parent</a><span>|</span><a href="#41713870">prev</a><span>|</span><a href="#41717991">next</a><span>|</span><label class="collapse" for="c-41717032">[-]</label><label class="expand" for="c-41717032">[1 more]</label></div><br/><div class="children"><div class="content">If the python script has external dependencies… lol.</div><br/></div></div></div></div></div></div><div id="41717991" class="c"><input type="checkbox" id="c-41717991" checked=""/><div class="controls bullet"><span class="by">FLT8</span><span>|</span><a href="#41713416">prev</a><span>|</span><a href="#41713720">next</a><span>|</span><label class="collapse" for="c-41717991">[-]</label><label class="expand" for="c-41717991">[1 more]</label></div><br/><div class="children"><div class="content">20 years ago I worked on a mainframe system that, at the time, was said to have &quot;18 months to live&quot;.  Fast forward to today, the system is more entrenched than it ever was, and still has &quot;18 months to live&quot;..  I&#x27;m convinced it will outlive me, and probably the next generation too.</div><br/></div></div><div id="41713720" class="c"><input type="checkbox" id="c-41713720" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#41717991">prev</a><span>|</span><a href="#41714978">next</a><span>|</span><label class="collapse" for="c-41713720">[-]</label><label class="expand" for="c-41713720">[1 more]</label></div><br/><div class="children"><div class="content">Technologies die very slowly once things of economic value depend on them. COBOL probably isn&#x27;t used from new projects very often, but the economics of ditching it aren&#x27;t very good either. It already works. Rewriting things that work is a great way to create new problems at great expense, so institutions are hesitant.</div><br/></div></div><div id="41714978" class="c"><input type="checkbox" id="c-41714978" checked=""/><div class="controls bullet"><span class="by">socketcluster</span><span>|</span><a href="#41713720">prev</a><span>|</span><a href="#41717431">next</a><span>|</span><label class="collapse" for="c-41714978">[-]</label><label class="expand" for="c-41714978">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting reading articles from previous generations how they make it sound like people seem to remember what everyone in the tech industry said as if everyone mattered. I guess there weren&#x27;t many people around in the industry back then.<p>Nowadays, even if someone is right about something and most people are doing it wrong, nobody will care to even discuss it unless the person making the statement is one of maybe 3 top influencers in that field.</div><br/></div></div><div id="41717431" class="c"><input type="checkbox" id="c-41717431" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#41714978">prev</a><span>|</span><a href="#41713506">next</a><span>|</span><label class="collapse" for="c-41717431">[-]</label><label class="expand" for="c-41717431">[2 more]</label></div><br/><div class="children"><div class="content">COBOL is endangered, even for banks and airlines. Just look at the executives who see decide to open new digital banks - they&#x27;re not building on top of COBOL or mainframes. The old banks will be outmaneuvered by the new ones, and eventually succeed them in the market.<p>The story of languages like COBOL isn&#x27;t that a language is too deeply embedded to become too expensive to replace. It just means the replacement will happen at a higher level - the business itself, and will take more time as a result.</div><br/><div id="41717556" class="c"><input type="checkbox" id="c-41717556" checked=""/><div class="controls bullet"><span class="by">nasmorn</span><span>|</span><a href="#41717431">parent</a><span>|</span><a href="#41713506">next</a><span>|</span><label class="collapse" for="c-41717556">[-]</label><label class="expand" for="c-41717556">[1 more]</label></div><br/><div class="children"><div class="content">A single cobol mainframe application is not a problem for a bank. Big banks are usually made by buying up dozens of other banks so they might have very many of these mainframes running and interoperating. That is where the real insanity lies</div><br/></div></div></div></div><div id="41713506" class="c"><input type="checkbox" id="c-41713506" checked=""/><div class="controls bullet"><span class="by">mbloom1915</span><span>|</span><a href="#41717431">prev</a><span>|</span><a href="#41714143">next</a><span>|</span><label class="collapse" for="c-41713506">[-]</label><label class="expand" for="c-41713506">[28 more]</label></div><br/><div class="children"><div class="content">almost all major financial institutions, utilities, gov&#x27;t agencies, etc still rely heavily on COBOL today. If it ain&#x27;t (extremely) broken, don&#x27;t fix it?<p>COBOL developers are literally dying out which has made for a competitive market for remaining talent. I&#x27;ve heard of some large consultants charging over $500&#x2F;hr to their clients for a COBOL developer!</div><br/><div id="41713625" class="c"><input type="checkbox" id="c-41713625" checked=""/><div class="controls bullet"><span class="by">akavi</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41713716">next</a><span>|</span><label class="collapse" for="c-41713625">[-]</label><label class="expand" for="c-41713625">[5 more]</label></div><br/><div class="children"><div class="content">I feel like every time COBOL is mentioned we get these stories about crazy high comp for COBOL developers, but anecdotally my aunt worked on COBOL projects in the mid 2010s and was paid a much more modest 45 $&#x2F;hr. Good money for small town middle America where she lives, but nowhere close to what a decent JS dev can get.</div><br/><div id="41716434" class="c"><input type="checkbox" id="c-41716434" checked=""/><div class="controls bullet"><span class="by">chucksmash</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713625">parent</a><span>|</span><a href="#41713935">next</a><span>|</span><label class="collapse" for="c-41716434">[-]</label><label class="expand" for="c-41716434">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the difference between what a consulting company bills for the COBOL developer and what they pay the developer. Not every consultant is the captain of their own ship.<p>My first job after college was a software shop organized in a &quot;services&quot; model, where clients would have to sponsor teams to do feature dev or support beyond initial onboarding. It&#x27;s been a long time and my memory is hazy, but as I recall I was expected to bill ~40 hours a week to clients and if I only worked 40 hours that week (being OT exempt, this was always the goal), my hourly pay came out to between 10-20% of what the company billed the client.<p>So $500&#x2F;hr on the bill and $45&#x2F;hr on the paycheck both manage to sound plausible, even at the same company.</div><br/></div></div><div id="41713935" class="c"><input type="checkbox" id="c-41713935" checked=""/><div class="controls bullet"><span class="by">ghosty141</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713625">parent</a><span>|</span><a href="#41716434">prev</a><span>|</span><a href="#41713716">next</a><span>|</span><label class="collapse" for="c-41713935">[-]</label><label class="expand" for="c-41713935">[3 more]</label></div><br/><div class="children"><div class="content">Similar experience with a friend of mine. I feel like these high salaries only apply to people who habe worked at one of these companies for a looong time.</div><br/><div id="41717988" class="c"><input type="checkbox" id="c-41717988" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713935">parent</a><span>|</span><a href="#41714163">next</a><span>|</span><label class="collapse" for="c-41717988">[-]</label><label class="expand" for="c-41717988">[1 more]</label></div><br/><div class="children"><div class="content">High salaries are when a grey beard consultant is bought in for a few months to fix something or implement some new regulation. And I don&#x27;t think it was that high was ever as high as financialised tech companies managed.</div><br/></div></div><div id="41714163" class="c"><input type="checkbox" id="c-41714163" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713935">parent</a><span>|</span><a href="#41717988">prev</a><span>|</span><a href="#41713716">next</a><span>|</span><label class="collapse" for="c-41714163">[-]</label><label class="expand" for="c-41714163">[1 more]</label></div><br/><div class="children"><div class="content">High salaries are relative. $90k is a high salary for most people in the world, even for tech workers outside of Silicon Valley.</div><br/></div></div></div></div></div></div><div id="41713716" class="c"><input type="checkbox" id="c-41713716" checked=""/><div class="controls bullet"><span class="by">psunavy03</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41713625">prev</a><span>|</span><a href="#41714394">next</a><span>|</span><label class="collapse" for="c-41713716">[-]</label><label class="expand" for="c-41713716">[1 more]</label></div><br/><div class="children"><div class="content">In COBOL implementations, it&#x27;s generally not just knowledge of the language that makes you valuable, it&#x27;s knowledge of the implementation at that particular organization.  I&#x27;m not a COBOL dev myself, but I work with them, and part of the challenge is that everything is so uber-customized, tightly coupled, and there&#x27;s 40+ years of undocumented business logic buried in the code.<p>It&#x27;s like the old joke about the engineer being asked for an itemized bill:
&quot;Chalk mark:  $1.  Knowing where to put it:  $4,999.&quot;</div><br/></div></div><div id="41714394" class="c"><input type="checkbox" id="c-41714394" checked=""/><div class="controls bullet"><span class="by">bespokedevelopr</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41713716">prev</a><span>|</span><a href="#41713582">next</a><span>|</span><label class="collapse" for="c-41714394">[-]</label><label class="expand" for="c-41714394">[1 more]</label></div><br/><div class="children"><div class="content">I work for a major utility and they used to run everything on mainframe and cobol but that went away long before I started programming. My coworker is nearing retirement, around 30 years here, and he started on cobol and worked on transitioning off. He has some really fun stories but my point being, the tales of cobol prevalence are very exaggerated. Maybe some parts of finance are still using it, not my area.</div><br/></div></div><div id="41713582" class="c"><input type="checkbox" id="c-41713582" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41714394">prev</a><span>|</span><a href="#41717061">next</a><span>|</span><label class="collapse" for="c-41713582">[-]</label><label class="expand" for="c-41713582">[6 more]</label></div><br/><div class="children"><div class="content">I think the moat that COBOL developers have is not just their knowledge of the language, but knowledge of the mainframe programming and operating environment. Its just so alien to developers familiar with Windows&#x2F;Linux, and there is really no way to get experience with the environment that I know of, other than to be employed doing it.<p>But yeah that stuff is never going away as far as I can tell. Its just too risky to rewrite those core systems and many a boondoggle has tried and failed.</div><br/><div id="41713739" class="c"><input type="checkbox" id="c-41713739" checked=""/><div class="controls bullet"><span class="by">rodgerd</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713582">parent</a><span>|</span><a href="#41714003">next</a><span>|</span><label class="collapse" for="c-41713739">[-]</label><label class="expand" for="c-41713739">[4 more]</label></div><br/><div class="children"><div class="content">About a decade ago I looked into moving some COBOL components off-mainframe (either as COBOL-on-Linux or a rewrite into Java, which itself is really COBOL Mk II at this point), and your point about the operating environment is one of the key elements, but not all of it; there&#x27;s also the fact that the first big shift to automation, via mainframe assembler and COBOL, is when companies sacked a lot of the folks who knew how and why the pre-automation processes worked - that knowledge exists in the mainframe code and the heads of the people who work(ed) on it, and nowhere else. A rewrite or a replatform is very, very hard and risky as a result; the system is now defined by how the mainframe runs the processes, to a very large degree.<p>The third is that COBOL is only the tip of the iceberg. As soon as I spent time learning about the code I was being asked to look at, you get into decades of evolving programming practises. Modern COBOL is multithreaded, probably uses DB2 and relational datamodels. COBOL from thirty years ago is probably single-threaded, only runs right on high-clocked single-execution models, cuts down to hand-written s390 assembler regularly, and uses VSAM files with non-relational data. Older code still will be sharing data simply by banging it into memory regions for other code to read out of, because that&#x27;s how you got performance back in the day.<p>Trying to identify how you&#x27;d pull a function out of that and move it off is somewhere between extremely difficult and impossible. It&#x27;s usually so complicated and expensive it&#x27;s easier to try and hire people who want to apprentice as mainframe programmers and keep the current codebase running.</div><br/><div id="41714224" class="c"><input type="checkbox" id="c-41714224" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713739">parent</a><span>|</span><a href="#41714003">next</a><span>|</span><label class="collapse" for="c-41714224">[-]</label><label class="expand" for="c-41714224">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A rewrite or a replatform is very, very hard and risky as a result; the system is now defined by how the mainframe runs the processes, to a very large degree.<p>And that&#x27;s why so many neo-banks&#x2F;fintechs are eating the lunch of the established banks left and right, same for insurance. The &quot;old guard&quot; is unwilling to pay the costs of not just upgrading off of mainframes (aka the rewrite work itself)... but of changing their processes. That is where the real cost is at:<p>When you have 213.000 employees like BoA has and everyone needs to have at least 10 hours of training and 2 weeks until they&#x27;re familiar with the new system enough to be fully productive, that&#x27;s like 2 million man-hours just for training and 16 million hours in lost productivity, so assuming $50&#x2F;h average salary it&#x27;s around 900 million dollars in cost. Unfortunately for the dinosaurs, the demands of both the customers and (at least in Europe) regulatory agencies especially for real-time financial transfers just push the old mainframe stuff to limits, while at the same time banks don&#x27;t want to cede more and more of that cake to Paypal and friends that charge quite the sum for (effectively) lending money to banks.<p>In contrast, all the newcomers start with greenfield IT, most likely some sort of more-or-less standard SAP. That one actually supports running unit and integration tests automatically, <i>drastically</i> reducing the chance of fuck-ups that might draw in unwanted regulatory attention.</div><br/><div id="41714470" class="c"><input type="checkbox" id="c-41714470" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41714224">parent</a><span>|</span><a href="#41716362">next</a><span>|</span><label class="collapse" for="c-41714470">[-]</label><label class="expand" for="c-41714470">[1 more]</label></div><br/><div class="children"><div class="content">BOA doesn&#x27;t train the vast, vast majority of its workforce on mainframe systems these days. No one working in a branch or call center is looking at green screens anymore. The mainframe systems are simply used as back-ends connected through web services (yes, even in CICS!) or MQ Series and the like to web GUIs.<p>Source: worked there for many years, and built some of those integration systems.</div><br/></div></div><div id="41716362" class="c"><input type="checkbox" id="c-41716362" checked=""/><div class="controls bullet"><span class="by">panopticon</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41714224">parent</a><span>|</span><a href="#41714470">prev</a><span>|</span><a href="#41714003">next</a><span>|</span><label class="collapse" for="c-41716362">[-]</label><label class="expand" for="c-41716362">[1 more]</label></div><br/><div class="children"><div class="content">Eh, I think the tech stack is less important than the legal and regulatory structure.<p>Most fintechs aren&#x27;t banks and partner with a Real Bank™ to provide the actual bank accounts. Fintechs are under much less regulatory scrutiny (for now—that may be changing with recent, high-profile screwups) and can move with much more freedom regardless of the tech stack they&#x27;ve chosen.</div><br/></div></div></div></div></div></div><div id="41714003" class="c"><input type="checkbox" id="c-41714003" checked=""/><div class="controls bullet"><span class="by">psunavy03</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713582">parent</a><span>|</span><a href="#41713739">prev</a><span>|</span><a href="#41717061">next</a><span>|</span><label class="collapse" for="c-41714003">[-]</label><label class="expand" for="c-41714003">[1 more]</label></div><br/><div class="children"><div class="content">Migrations are still a thing, with various approaches and success rates.</div><br/></div></div></div></div><div id="41717061" class="c"><input type="checkbox" id="c-41717061" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41713582">prev</a><span>|</span><a href="#41713615">next</a><span>|</span><label class="collapse" for="c-41717061">[-]</label><label class="expand" for="c-41717061">[2 more]</label></div><br/><div class="children"><div class="content">Not a bad gig to take if you can swallow your pride a bit.<p>I bet LLMs can make working with COBOL a lot easier and more fun than it ever was. I bet that&#x27;s true for a lot of legacy stuff.</div><br/><div id="41717365" class="c"><input type="checkbox" id="c-41717365" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41717061">parent</a><span>|</span><a href="#41713615">next</a><span>|</span><label class="collapse" for="c-41717365">[-]</label><label class="expand" for="c-41717365">[1 more]</label></div><br/><div class="children"><div class="content">Working with COBOL was never fun, so that&#x27;s a low bar.<p>Like others have said, what&#x27;s valuable is an understanding of the business and legacy cruft that comes with spending time working at this kind of companies&#x2F;banks&#x2F;etc rather than knowledge of COBOL.</div><br/></div></div></div></div><div id="41713615" class="c"><input type="checkbox" id="c-41713615" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41717061">prev</a><span>|</span><a href="#41717049">next</a><span>|</span><label class="collapse" for="c-41713615">[-]</label><label class="expand" for="c-41713615">[6 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t we just apply a bunch of correctness preserving translations towards a modern PL, perhaps aided by an LLM to keep the source as human readable as possible, while (I&#x27;m stressing this) preserving  correctness?</div><br/><div id="41713744" class="c"><input type="checkbox" id="c-41713744" checked=""/><div class="controls bullet"><span class="by">exhilaration</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713615">parent</a><span>|</span><a href="#41714206">next</a><span>|</span><label class="collapse" for="c-41713744">[-]</label><label class="expand" for="c-41713744">[4 more]</label></div><br/><div class="children"><div class="content">IBM offers just such a service under the WatsonX branding, it&#x27;s an LLM to convert COBOL to Java:
<a href="https:&#x2F;&#x2F;www.ibm.com&#x2F;products&#x2F;watsonx-code-assistant-z" rel="nofollow">https:&#x2F;&#x2F;www.ibm.com&#x2F;products&#x2F;watsonx-code-assistant-z</a><p>I work at a company with a large COBOL codebase and this has been mentioned in a few presentations about our modernization efforts.</div><br/><div id="41714533" class="c"><input type="checkbox" id="c-41714533" checked=""/><div class="controls bullet"><span class="by">grammie</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713744">parent</a><span>|</span><a href="#41714958">next</a><span>|</span><label class="collapse" for="c-41714533">[-]</label><label class="expand" for="c-41714533">[1 more]</label></div><br/><div class="children"><div class="content">You should take a look at my company. Heirloom Computing. Heirloom.cc We have migrated many mainframe application and millions of lines of cobol and pl1 into Java and deployed it into production on prem and into the cloud.</div><br/></div></div><div id="41714958" class="c"><input type="checkbox" id="c-41714958" checked=""/><div class="controls bullet"><span class="by">russfink</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713744">parent</a><span>|</span><a href="#41714533">prev</a><span>|</span><a href="#41713867">next</a><span>|</span><label class="collapse" for="c-41714958">[-]</label><label class="expand" for="c-41714958">[1 more]</label></div><br/><div class="children"><div class="content">But is the conversion maintainable by a human?  I’ve seen Fortran to C translators that end up encoding state transition machines that are impossible to read.</div><br/></div></div><div id="41713867" class="c"><input type="checkbox" id="c-41713867" checked=""/><div class="controls bullet"><span class="by">refneb</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713744">parent</a><span>|</span><a href="#41714958">prev</a><span>|</span><a href="#41714206">next</a><span>|</span><label class="collapse" for="c-41713867">[-]</label><label class="expand" for="c-41713867">[1 more]</label></div><br/><div class="children"><div class="content">How did that go?
My employer is going to try snd evaluate watsonx product. 
Have you had any luck converting large&#x2F;complex COBOL modules ?</div><br/></div></div></div></div><div id="41714206" class="c"><input type="checkbox" id="c-41714206" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713615">parent</a><span>|</span><a href="#41713744">prev</a><span>|</span><a href="#41717049">next</a><span>|</span><label class="collapse" for="c-41714206">[-]</label><label class="expand" for="c-41714206">[1 more]</label></div><br/><div class="children"><div class="content">You can’t, unless you transform cobol to cobol and run the emulator on aws. It will still manage to fail you in some way</div><br/></div></div></div></div><div id="41717049" class="c"><input type="checkbox" id="c-41717049" checked=""/><div class="controls bullet"><span class="by">Spooky23</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41713615">prev</a><span>|</span><a href="#41713660">next</a><span>|</span><label class="collapse" for="c-41717049">[-]</label><label class="expand" for="c-41717049">[1 more]</label></div><br/><div class="children"><div class="content">That’s for specialists for the mainframe or specific skill.<p>Generalists are usually offshored and are cheap.</div><br/></div></div><div id="41713660" class="c"><input type="checkbox" id="c-41713660" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41717049">prev</a><span>|</span><a href="#41714182">next</a><span>|</span><label class="collapse" for="c-41713660">[-]</label><label class="expand" for="c-41713660">[3 more]</label></div><br/><div class="children"><div class="content">That seems like a myth to me. I actually looked up COBOL salaries and they were a <i>bit</i> higher (like 20%) but definitely not enough to make them tempting.</div><br/><div id="41713797" class="c"><input type="checkbox" id="c-41713797" checked=""/><div class="controls bullet"><span class="by">francisofascii</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713660">parent</a><span>|</span><a href="#41714182">next</a><span>|</span><label class="collapse" for="c-41713797">[-]</label><label class="expand" for="c-41713797">[2 more]</label></div><br/><div class="children"><div class="content">There is typically a big difference between a consultant&#x27;s hourly rate and a full time salary hourly rate.</div><br/><div id="41718069" class="c"><input type="checkbox" id="c-41718069" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41713506">root</a><span>|</span><a href="#41713797">parent</a><span>|</span><a href="#41714182">next</a><span>|</span><label class="collapse" for="c-41718069">[-]</label><label class="expand" for="c-41718069">[1 more]</label></div><br/><div class="children"><div class="content">Yeah exactly. I was comparing like for like (contracts or full time). The difference due to the fact that it was COBOL was definitely not enough to make me want to learn COBOL.</div><br/></div></div></div></div></div></div><div id="41714182" class="c"><input type="checkbox" id="c-41714182" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41713660">prev</a><span>|</span><a href="#41713717">next</a><span>|</span><label class="collapse" for="c-41714182">[-]</label><label class="expand" for="c-41714182">[1 more]</label></div><br/><div class="children"><div class="content">It is very much broken and said institutions don’t like it</div><br/></div></div><div id="41713717" class="c"><input type="checkbox" id="c-41713717" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41713506">parent</a><span>|</span><a href="#41714182">prev</a><span>|</span><a href="#41714143">next</a><span>|</span><label class="collapse" for="c-41713717">[-]</label><label class="expand" for="c-41713717">[1 more]</label></div><br/><div class="children"><div class="content">COBOL jobs are not particularly well paid in my country.<p>In any case, they would have to pay well by a large margin to justify working on dead boring legacy systems, too.</div><br/></div></div></div></div><div id="41714143" class="c"><input type="checkbox" id="c-41714143" checked=""/><div class="controls bullet"><span class="by">deenadz</span><span>|</span><a href="#41713506">prev</a><span>|</span><a href="#41716678">next</a><span>|</span><label class="collapse" for="c-41714143">[-]</label><label class="expand" for="c-41714143">[2 more]</label></div><br/><div class="children"><div class="content">COBOL is dead, long live COBOL.<p>For any cobol devs here, we at <a href="https:&#x2F;&#x2F;cobolcopilot.com" rel="nofollow">https:&#x2F;&#x2F;cobolcopilot.com</a> would love to hear from you</div><br/><div id="41714411" class="c"><input type="checkbox" id="c-41714411" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41714143">parent</a><span>|</span><a href="#41716678">next</a><span>|</span><label class="collapse" for="c-41714411">[-]</label><label class="expand" for="c-41714411">[1 more]</label></div><br/><div class="children"><div class="content">You need to sell on-prem to those people. No way a single byte of that sweet sweet poison is going to ever leave the corporate network boundary.</div><br/></div></div></div></div><div id="41716678" class="c"><input type="checkbox" id="c-41716678" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#41714143">prev</a><span>|</span><a href="#41717395">next</a><span>|</span><label class="collapse" for="c-41716678">[-]</label><label class="expand" for="c-41716678">[1 more]</label></div><br/><div class="children"><div class="content">When I was in college, I knew a guy who got an internship at Wells Fargo writing COBOL. He hated it.<p>The punchline is that this was in 2018.</div><br/></div></div><div id="41717395" class="c"><input type="checkbox" id="c-41717395" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#41716678">prev</a><span>|</span><a href="#41713996">next</a><span>|</span><label class="collapse" for="c-41717395">[-]</label><label class="expand" for="c-41717395">[1 more]</label></div><br/><div class="children"><div class="content">This makes me feel old.<p>In &#x27;92 I was maintaining COBOL code for a custom written warehouse management system for a wholesale boat bits distributor. The company that wrote it had lost almost all their COBOL devs, and were all in on Windows NT application dev.<p>I hate to admit it to myself, but I am in fact _just_ old enough that I could have cs grad aged grandkids, if I&#x27;d had kids early and they&#x27;d also had kids early. :sigh:</div><br/></div></div><div id="41713996" class="c"><input type="checkbox" id="c-41713996" checked=""/><div class="controls bullet"><span class="by">WaitWaitWha</span><span>|</span><a href="#41717395">prev</a><span>|</span><a href="#41715958">next</a><span>|</span><label class="collapse" for="c-41713996">[-]</label><label class="expand" for="c-41713996">[1 more]</label></div><br/><div class="children"><div class="content">(Programming) languages take very long to &quot;die&quot;.  Most often you will get a long drawn out tail, and often parts of a language gets absorbed into other languages. Only the sages and etymologists will know where they have come from.<p>Old man reminiscence following, skip if you are not bored:<p>I worked with SNOBOL and I thought it will be a long term programming language.
I also want to think that I had some tiny, minuscule hand in dev of RIPscrip pre-Telegraphix, alas it went as the dodo bird.<p>I think I have forgotten more programming languages than I can count on my hands.  Yet, I see them in some part every day in newer languages, &quot;discovered&quot; by some expert.  &quot;What has been will be again, what has been done will be done again; there is nothing new under the sun.&quot;<p>One language has come to my aid for the last 30-ish years Perl has came to my aid many times.<p>(I tell you a secret - in the deep deep bowels of a a very, very large, jungle named company, servers still have tiny Perl scripts running some core functions. I discovered this, when there was a problem that I had to deep dive into. I a recommendation to change to a hard-coded variable. The answer was &quot;it will take two weeks&quot;. Why? Because no one knew what it will do or could read Perl. It was a 30 second job, including sdlc. Think xkcd <i>Dependency</i> <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;2347&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;2347&#x2F;</a> )</div><br/></div></div><div id="41715958" class="c"><input type="checkbox" id="c-41715958" checked=""/><div class="controls bullet"><span class="by">markm248</span><span>|</span><a href="#41713996">prev</a><span>|</span><a href="#41715472">next</a><span>|</span><label class="collapse" for="c-41715958">[-]</label><label class="expand" for="c-41715958">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lindy_effect" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lindy_effect</a></div><br/></div></div><div id="41715472" class="c"><input type="checkbox" id="c-41715472" checked=""/><div class="controls bullet"><span class="by">facorreia</span><span>|</span><a href="#41715958">prev</a><span>|</span><a href="#41715421">next</a><span>|</span><label class="collapse" for="c-41715472">[-]</label><label class="expand" for="c-41715472">[1 more]</label></div><br/><div class="children"><div class="content">I worked for a company in the late 1980s that started developing with a 4GL product (Dataflex) instead of COBOL. The article is right that COBOL has outlasted most (all?) of those 4GL solutions.<p>Looking back, COBOL would have been a better technical choice back then. Dataflex&#x27;s metadata-based dynamic UI and report generation saved some simple, repetitive work, but much more effort was wasted working around its limitations.</div><br/></div></div><div id="41715421" class="c"><input type="checkbox" id="c-41715421" checked=""/><div class="controls bullet"><span class="by">mcv</span><span>|</span><a href="#41715472">prev</a><span>|</span><a href="#41714303">next</a><span>|</span><label class="collapse" for="c-41715421">[-]</label><label class="expand" for="c-41715421">[1 more]</label></div><br/><div class="children"><div class="content">Just this week a colleague asked if someone knew Cobol. Apparently another team had a Cobol-related issue.<p>So despite its long death, it still seems to be kicking about. I doubt we&#x27;ll ever get rid of it.</div><br/></div></div><div id="41714303" class="c"><input type="checkbox" id="c-41714303" checked=""/><div class="controls bullet"><span class="by">happyjim</span><span>|</span><a href="#41715421">prev</a><span>|</span><a href="#41716484">next</a><span>|</span><label class="collapse" for="c-41714303">[-]</label><label class="expand" for="c-41714303">[1 more]</label></div><br/><div class="children"><div class="content">Key components of the U.S. Internal Revenue Service tax processing code (e.g., the &quot;Individual Master File&quot; or IMF) are written in COBOL and IBM Assembly Language.<p>There is an ongoing effort to refactor as Java. This will ultimately take years and cost $100s of millions of dollars. There is still a small but shrinking team of graybeards who can actually maintain the code, which has to be reprogrammed every year to accommodate changes to tax code.<p>See, e.g., IRS IT Strategic Plan documents, publicly available.</div><br/></div></div><div id="41716484" class="c"><input type="checkbox" id="c-41716484" checked=""/><div class="controls bullet"><span class="by">HackerQED</span><span>|</span><a href="#41714303">prev</a><span>|</span><a href="#41714667">next</a><span>|</span><label class="collapse" for="c-41716484">[-]</label><label class="expand" for="c-41716484">[1 more]</label></div><br/><div class="children"><div class="content">RIP. He is an old man with wisdom and a sense of humor.</div><br/></div></div><div id="41714667" class="c"><input type="checkbox" id="c-41714667" checked=""/><div class="controls bullet"><span class="by">kayo_20211030</span><span>|</span><a href="#41716484">prev</a><span>|</span><a href="#41715220">next</a><span>|</span><label class="collapse" for="c-41714667">[-]</label><label class="expand" for="c-41714667">[1 more]</label></div><br/><div class="children"><div class="content">Great story. There&#x27;s something wicked personal in it, and it&#x27;s very good. I reckon that this bloke&#x27;s grandfather was an interesting bloke - cobol or no.</div><br/></div></div><div id="41715220" class="c"><input type="checkbox" id="c-41715220" checked=""/><div class="controls bullet"><span class="by">LarsDu88</span><span>|</span><a href="#41714667">prev</a><span>|</span><a href="#41715397">next</a><span>|</span><label class="collapse" for="c-41715220">[-]</label><label class="expand" for="c-41715220">[3 more]</label></div><br/><div class="children"><div class="content">As long as there are tactical nukes that depend on COBOL, COBOL ain&#x27;t dead.<p>We might all die, but COBOL will sit happy in its steel reinforce nuclear bunker</div><br/><div id="41715264" class="c"><input type="checkbox" id="c-41715264" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#41715220">parent</a><span>|</span><a href="#41715397">next</a><span>|</span><label class="collapse" for="c-41715264">[-]</label><label class="expand" for="c-41715264">[2 more]</label></div><br/><div class="children"><div class="content">Still doesn&#x27;t beat Assembly, which will continue running on Voyager 1 even after the inevitable demise of our planet. Would survive the end of our solar system too.</div><br/><div id="41716741" class="c"><input type="checkbox" id="c-41716741" checked=""/><div class="controls bullet"><span class="by">LarsDu88</span><span>|</span><a href="#41715220">root</a><span>|</span><a href="#41715264">parent</a><span>|</span><a href="#41715397">next</a><span>|</span><label class="collapse" for="c-41716741">[-]</label><label class="expand" for="c-41716741">[1 more]</label></div><br/><div class="children"><div class="content">Assembly ain&#x27;t a language. Differs for every chip microarchitecture. Doubt there&#x27;s many folks who know voyager 1 assembly</div><br/></div></div></div></div></div></div><div id="41715397" class="c"><input type="checkbox" id="c-41715397" checked=""/><div class="controls bullet"><span class="by">yawnxyz</span><span>|</span><a href="#41715220">prev</a><span>|</span><a href="#41715875">next</a><span>|</span><label class="collapse" for="c-41715397">[-]</label><label class="expand" for="c-41715397">[5 more]</label></div><br/><div class="children"><div class="content">huh so are any languages actually dead? ChatGPT mentions FORTRAN, ALGOL, or Pascal... which I don&#x27;t think are dead at all.<p>Ada I&#x27;ve never heard of, so maybe that one&#x27;s dead?<p>If they&#x27;re able to write WebAssembly compilers for all these languages, then they&#x27;ll probably live forever!<p>The only reason punchcards are &quot;dead&quot; is bc the machines are gone or mostly unavailable...</div><br/><div id="41718460" class="c"><input type="checkbox" id="c-41718460" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41715397">parent</a><span>|</span><a href="#41716379">next</a><span>|</span><label class="collapse" for="c-41718460">[-]</label><label class="expand" for="c-41718460">[1 more]</label></div><br/><div class="children"><div class="content">It depends on how you define &quot;dead&quot;. ALGOL proper has been dead for many decades, but pretty much all mainstream general purpose PLs today are its direct descendants, and sometimes this ancestry is plain to see (e.g. every time you write &quot;struct&quot; or &quot;void&quot; in a C-like language, that&#x27;s straight from ALGOL 68). I once wrote a comment on HN summarizing all the various bits and pieces I know of that are still around: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18691821">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18691821</a></div><br/></div></div><div id="41716379" class="c"><input type="checkbox" id="c-41716379" checked=""/><div class="controls bullet"><span class="by">atrettel</span><span>|</span><a href="#41715397">parent</a><span>|</span><a href="#41718460">prev</a><span>|</span><a href="#41715442">next</a><span>|</span><label class="collapse" for="c-41716379">[-]</label><label class="expand" for="c-41716379">[2 more]</label></div><br/><div class="children"><div class="content">Fortran is very much not dead.<p><a href="https:&#x2F;&#x2F;fortran-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fortran-lang.org&#x2F;</a></div><br/><div id="41716613" class="c"><input type="checkbox" id="c-41716613" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#41715397">root</a><span>|</span><a href="#41716379">parent</a><span>|</span><a href="#41715442">next</a><span>|</span><label class="collapse" for="c-41716613">[-]</label><label class="expand" for="c-41716613">[1 more]</label></div><br/><div class="children"><div class="content">Fortran’s doing fine, but that discourse is not very useful.</div><br/></div></div></div></div><div id="41715442" class="c"><input type="checkbox" id="c-41715442" checked=""/><div class="controls bullet"><span class="by">marcolussetti</span><span>|</span><a href="#41715397">parent</a><span>|</span><a href="#41716379">prev</a><span>|</span><a href="#41715875">next</a><span>|</span><label class="collapse" for="c-41715442">[-]</label><label class="expand" for="c-41715442">[1 more]</label></div><br/><div class="children"><div class="content">Ada is still updated, last released in 2023. Given its original audience is the Department of Defense, it seems to me very likely it is far from dead.</div><br/></div></div></div></div><div id="41715875" class="c"><input type="checkbox" id="c-41715875" checked=""/><div class="controls bullet"><span class="by">Crontab</span><span>|</span><a href="#41715397">prev</a><span>|</span><a href="#41714728">next</a><span>|</span><label class="collapse" for="c-41715875">[-]</label><label class="expand" for="c-41715875">[1 more]</label></div><br/><div class="children"><div class="content">Do open source COBOL programs exist? Just wondering since I see it mentioned occasionally here.</div><br/></div></div><div id="41714728" class="c"><input type="checkbox" id="c-41714728" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#41715875">prev</a><span>|</span><label class="collapse" for="c-41714728">[-]</label><label class="expand" for="c-41714728">[1 more]</label></div><br/><div class="children"><div class="content">I know someone my age (mid-late 30s) who is a COBOL programmer for a bank.<p>He&#x27;s been that for ~5 years.<p>I don&#x27;t think it&#x27;s going away any time soon.</div><br/></div></div></div></div></div></div></div></body></html>