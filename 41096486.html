<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722243658788" as="style"/><link rel="stylesheet" href="styles.css?v=1722243658788"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://leandojo.org/">LeanDojo: Theorem Proving in Lean Using LLMs</a> <span class="domain">(<a href="https://leandojo.org">leandojo.org</a>)</span></div><div class="subtext"><span>aseg</span> | <span>25 comments</span></div><br/><div><div id="41097765" class="c"><input type="checkbox" id="c-41097765" checked=""/><div class="controls bullet"><span class="by">maxwells-daemon</span><span>|</span><a href="#41097521">next</a><span>|</span><label class="collapse" for="c-41097765">[-]</label><label class="expand" for="c-41097765">[1 more]</label></div><br/><div class="children"><div class="content">Second author here. Happy to answer any questions about the work!</div><br/></div></div><div id="41097521" class="c"><input type="checkbox" id="c-41097521" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#41097765">prev</a><span>|</span><a href="#41096685">next</a><span>|</span><label class="collapse" for="c-41097521">[-]</label><label class="expand" for="c-41097521">[1 more]</label></div><br/><div class="children"><div class="content">Victor Taelin is doing some semi-related stuff with Claude and their home built proof language Kind2:<p><a href="https:&#x2F;&#x2F;x.com&#x2F;VictorTaelin&#x2F;status&#x2F;1811167900780175423" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;VictorTaelin&#x2F;status&#x2F;1811167900780175423</a><p>Can recommend taking a look at their recorded Twitch stream to see it in action.</div><br/></div></div><div id="41096685" class="c"><input type="checkbox" id="c-41096685" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41097521">prev</a><span>|</span><a href="#41096718">next</a><span>|</span><label class="collapse" for="c-41096685">[-]</label><label class="expand" for="c-41096685">[1 more]</label></div><br/><div class="children"><div class="content">Useful context: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Lean_(proof_assistant)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Lean_(proof_assistant)</a> - &quot;Lean is a proof assistant and a functional programming language. It is based on the calculus of constructions with inductive types. &quot;</div><br/></div></div><div id="41096718" class="c"><input type="checkbox" id="c-41096718" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#41096685">prev</a><span>|</span><label class="collapse" for="c-41096718">[-]</label><label class="expand" for="c-41096718">[21 more]</label></div><br/><div class="children"><div class="content">I wonder if they could integrate with the reinforcement learning approach from AlphaProof (this week). Having an IMO silver level proof copilot would pretty neat!</div><br/><div id="41097337" class="c"><input type="checkbox" id="c-41097337" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41096718">parent</a><span>|</span><a href="#41096769">next</a><span>|</span><label class="collapse" for="c-41097337">[-]</label><label class="expand" for="c-41097337">[19 more]</label></div><br/><div class="children"><div class="content">This is precisely how Google built AlphaProof! Read the article, Lean&#x27;s role is quite critical to its success.<p>Privately, I think Lean could be incredibly powerful if baked deep into an ML&#x27;s kernel&#x2F;structure&#x2F;training process. I think an AI proof of something like the Riemann Hypothesis may well be possible if you get enough resources behind it.</div><br/><div id="41097853" class="c"><input type="checkbox" id="c-41097853" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097337">parent</a><span>|</span><a href="#41098147">next</a><span>|</span><label class="collapse" for="c-41097853">[-]</label><label class="expand" for="c-41097853">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is precisely how Google built AlphaProof! Read the article, Lean&#x27;s role is quite critical to its success.<p>I read the article. It doesn&#x27;t say anything about generating new proofs to train on. It only mentions scraping Github for lean theorems+proofs.</div><br/></div></div><div id="41098147" class="c"><input type="checkbox" id="c-41098147" checked=""/><div class="controls bullet"><span class="by">dkga</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097337">parent</a><span>|</span><a href="#41097853">prev</a><span>|</span><a href="#41097431">next</a><span>|</span><label class="collapse" for="c-41098147">[-]</label><label class="expand" for="c-41098147">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps a simpler and more reachable approach at this point would be to use the mathlib documentation to fuel a RAG on top of the fine-tuned&#x2F;specialised model.</div><br/></div></div><div id="41097431" class="c"><input type="checkbox" id="c-41097431" checked=""/><div class="controls bullet"><span class="by">sva_</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097337">parent</a><span>|</span><a href="#41098147">prev</a><span>|</span><a href="#41097425">next</a><span>|</span><label class="collapse" for="c-41097431">[-]</label><label class="expand" for="c-41097431">[6 more]</label></div><br/><div class="children"><div class="content">&gt; if baked deep into an ML&#x27;s kernel&#x2F;structure&#x2F;training process<p>Not sure of the feasibility of implementing lean as a GPU kernel, if you meant that. Also I&#x27;m not sure it makes sense to run Lean inside the (mostly matmul) training process. Now to use it to prepare some training data, it seems more realistic. But that seems to be what AlphaProof tries to do in the reinforcement step, if I&#x27;m not mistaken.</div><br/><div id="41097540" class="c"><input type="checkbox" id="c-41097540" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097431">parent</a><span>|</span><a href="#41097461">next</a><span>|</span><label class="collapse" for="c-41097540">[-]</label><label class="expand" for="c-41097540">[1 more]</label></div><br/><div class="children"><div class="content">I think that in order for it to truly find deep insights, it would need to do more than just generate training data. I&#x27;m also a believer that the current AI approaches are approaching their limits as the human feed dries up and we start using old models to train new ones.<p>Of course, what that really means and how you&#x27;d go about adapting your CUDA code &#x2F; hardware, would have to be researched.</div><br/></div></div><div id="41097461" class="c"><input type="checkbox" id="c-41097461" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097431">parent</a><span>|</span><a href="#41097540">prev</a><span>|</span><a href="#41097425">next</a><span>|</span><label class="collapse" for="c-41097461">[-]</label><label class="expand" for="c-41097461">[4 more]</label></div><br/><div class="children"><div class="content">It could perhaps also be used to guide the sampling step at the end, or? Similar to those syntax-constrained samplers to ensure the LLM spits out eg valid JSON.</div><br/><div id="41097527" class="c"><input type="checkbox" id="c-41097527" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097461">parent</a><span>|</span><a href="#41097425">next</a><span>|</span><label class="collapse" for="c-41097527">[-]</label><label class="expand" for="c-41097527">[3 more]</label></div><br/><div class="children"><div class="content">Syntax constraints are usually expressible as grammars, but the language of math is often very unique and domain specific, which makes this kind of approach tricky to get right</div><br/><div id="41098158" class="c"><input type="checkbox" id="c-41098158" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097527">parent</a><span>|</span><a href="#41097425">next</a><span>|</span><label class="collapse" for="c-41098158">[-]</label><label class="expand" for="c-41098158">[2 more]</label></div><br/><div class="children"><div class="content">Thankfully Lean exists, so the LLM can write that instead of the math syntax used in papers.</div><br/><div id="41098452" class="c"><input type="checkbox" id="c-41098452" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41098158">parent</a><span>|</span><a href="#41097425">next</a><span>|</span><label class="collapse" for="c-41098452">[-]</label><label class="expand" for="c-41098452">[1 more]</label></div><br/><div class="children"><div class="content">So yea that was my thought. Use it to spit out valid Lean syntax, and potentially also to backtrack if it outputs inconsistent or erroneous proofs.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41097425" class="c"><input type="checkbox" id="c-41097425" checked=""/><div class="controls bullet"><span class="by">mathinaly</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097337">parent</a><span>|</span><a href="#41097431">prev</a><span>|</span><a href="#41096769">next</a><span>|</span><label class="collapse" for="c-41097425">[-]</label><label class="expand" for="c-41097425">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible that the hypothesis is independent of the existing axiomatic systems for mathematics and a computer can&#x27;t discover that on its own. It will loop forever looking for a proof that will never show up in the search. Computers are useful for doing fast calculations but attributing intelligence to them beyond that is mostly a result of confused ontologies and metaphysics about what computers are capable of doing. Computation is a subset of mathematics and can never actually be a replacement for it. The incompleteness theorem for example is a meta-mathematical statement about the limits of axiomatic systems that can not be discovered with axiomatic systems alone.</div><br/><div id="41097609" class="c"><input type="checkbox" id="c-41097609" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097425">parent</a><span>|</span><a href="#41097549">next</a><span>|</span><label class="collapse" for="c-41097609">[-]</label><label class="expand" for="c-41097609">[8 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s possible that the hypothesis is independent of the existing axiomatic systems for mathematics and a computer can&#x27;t discover that on its own.<p>Humans have discovered independence proofs, e.g. Paul Cohen’s 1963 proof that the continuum hypothesis is independent of ZFC. I can’t see any reason in principle why a computer couldn’t do the same.<p>If the Riemann hypothesis is independent of ZFC, and there exists a proof of that independence which is of tractable length, then <i>in principle</i> if a human could discover it, why couldn’t a sufficiently advanced computer system?<p>Of course, it may turn out either that (a) Riemann hypothesis isn’t independent of ZFC (what most mathematicians think), or (b) it is independent but no proof exists, or (c) the shortest proof is so astronomically long nobody will ever be able to know it<p>&gt; The incompleteness theorem for example is a meta-mathematical statement about the limits of axiomatic systems that can not be discovered with axiomatic systems alone.<p>We have proofs of Gödel‘s theorems. I see no reason in principle why a (sufficiently powerful) automated theorem prover couldn’t discover those proofs for itself. And maybe even one day discover proofs of novel theorems in the same vein</div><br/><div id="41097898" class="c"><input type="checkbox" id="c-41097898" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097609">parent</a><span>|</span><a href="#41097710">next</a><span>|</span><label class="collapse" for="c-41097898">[-]</label><label class="expand" for="c-41097898">[2 more]</label></div><br/><div class="children"><div class="content">Bahaha it would be great if RH turned out to be a natural example of a theorem for which its independence is itself independent of ZFC. Do you know any examples of that?<p>I can probably cook some highly artificial ones up if I try, but maybe there&#x27;s an interesting one out there!</div><br/><div id="41097919" class="c"><input type="checkbox" id="c-41097919" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097898">parent</a><span>|</span><a href="#41097710">next</a><span>|</span><label class="collapse" for="c-41097919">[-]</label><label class="expand" for="c-41097919">[1 more]</label></div><br/><div class="children"><div class="content">&gt; turned out to be a natural example of a theorem for which it&#x27;s independence is itself independent of ZFC. Do you know any examples of that?<p>Not aware of any myself, no. (But I’m far from an expert on this topic.)<p>It just occurred to me as a logical possibility.</div><br/></div></div></div></div><div id="41097710" class="c"><input type="checkbox" id="c-41097710" checked=""/><div class="controls bullet"><span class="by">mathinaly</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097609">parent</a><span>|</span><a href="#41097898">prev</a><span>|</span><a href="#41097549">next</a><span>|</span><label class="collapse" for="c-41097710">[-]</label><label class="expand" for="c-41097710">[5 more]</label></div><br/><div class="children"><div class="content">No computer has ever discovered the concept of a Turing machine and the associated halting problem (incompleteness theorem). If you think a search in an axiomatic system can discover an incompleteness result it is because your ontology about what computers can do is confused. People are not computers.</div><br/><div id="41097875" class="c"><input type="checkbox" id="c-41097875" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097710">parent</a><span>|</span><a href="#41097549">next</a><span>|</span><label class="collapse" for="c-41097875">[-]</label><label class="expand" for="c-41097875">[4 more]</label></div><br/><div class="children"><div class="content">To be pedantic (mathematical?), computers can find any result that has a formalisation in a finitary logical systems like first-order logic, simply by searching all possible proofs. Undecidability of FOL inference isn&#x27;t relevant when you already know such a proof exists (it&#x27;s a &quot;semidecidable&quot; problem).<p>I imagine that would be the main use case for heuristic solvers like this one - helping mathematicians fill in the blanks in proofs for stuff that&#x27;s not too tricky but annoying to do by hand. Rather than for discovering novel, unknown concepts by itself (although I&#x27;m with the OP, don&#x27;t see why this is impossible a priori).</div><br/><div id="41098008" class="c"><input type="checkbox" id="c-41098008" checked=""/><div class="controls bullet"><span class="by">mathinaly</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097875">parent</a><span>|</span><a href="#41097549">next</a><span>|</span><label class="collapse" for="c-41098008">[-]</label><label class="expand" for="c-41098008">[3 more]</label></div><br/><div class="children"><div class="content">Because meta-mathematical proofs often use transcendental induction and associated &quot;non-constructive&quot; and &quot;non-finitistic&quot; arguments. The diagonilization argument itself is an instance of something that can not actually be implemented on a computer because constructing the relevant function in finite time is impossible. Computers are great but when people say things like &quot;The human mind is software running on the brain like a computer&quot; that indicates to me they are confused about what they&#x27;re trying to say about minds, brains, and computers. Collapsing all those different concepts into a Turing machine is what I mean by a confused ontology.<p>In any event, I&#x27;m dropping out of this thread since I don&#x27;t have much else to say on this and it often leads to unnecessary theorycrafting with people who haven&#x27;t done the prerequisite reading on the relevant matters.</div><br/><div id="41098066" class="c"><input type="checkbox" id="c-41098066" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41098008">parent</a><span>|</span><a href="#41098467">next</a><span>|</span><label class="collapse" for="c-41098066">[-]</label><label class="expand" for="c-41098066">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because meta-mathematical proofs often use transcendental induction and associated &quot;non-constructive&quot; and &quot;non-finitistic&quot; arguments. The diagonilization argument itself is an instance of something that can not actually be implemented on a computer because constructing the relevant function in finite time is impossible.<p>Humans reason about transcendental induction using finite time and finite resources-the human brain (as far as we know) is a finite entity. So if we can reason about the transfinite using the finite, why can’t computers? Of course they can’t do so by directly reasoning in an infinite way, but humans don’t do that, so why think computers must?</div><br/></div></div><div id="41098467" class="c"><input type="checkbox" id="c-41098467" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41098008">parent</a><span>|</span><a href="#41098066">prev</a><span>|</span><a href="#41097549">next</a><span>|</span><label class="collapse" for="c-41098467">[-]</label><label class="expand" for="c-41098467">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to implement a diagonalisation in order to prove results about it - this is true for computers as much as it is true for humans. There are formalisations of Godel&#x27;s theorems in Lean, for instance. Similarly for arguments involving excluded middle and other non-constructive axioms.<p>I hear your point that humans reason with heuristics that are &quot;outside&quot; of the underlying formal system, but I don&#x27;t know of a single case where the <i>resulting</i> theorem could not be formalised in some way (after all, this is why ZFC+ was such a big deal foundationally). Similarly, an AI will have its own set of learned heuristics that lead it to more rigorous results.<p>Also agree about minds and computers and such, but personally I don&#x27;t think it has much bearing on what computers are capable of mathematically.<p>Anyway, cheers. Doesn&#x27;t sound like we disagree about much.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41097549" class="c"><input type="checkbox" id="c-41097549" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41096718">root</a><span>|</span><a href="#41097425">parent</a><span>|</span><a href="#41097609">prev</a><span>|</span><a href="#41096769">next</a><span>|</span><label class="collapse" for="c-41097549">[-]</label><label class="expand" for="c-41097549">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps true of the class of problems that are undecidable in, say, the Peano axioms &#x2F; ZFC. However, there are many things these axioms <i>can</i> prove that are still useful! For example, the multiplicity of the totient function, applications of which power much of modern cryptography.<p>Riemann is so widely believed to be true that there are entire branches of mathematics dedicated to seeing what cool things you can learn about primes&#x2F;combinatorics etc by taking Riemann to be true as an assumption.</div><br/></div></div></div></div></div></div><div id="41096769" class="c"><input type="checkbox" id="c-41096769" checked=""/><div class="controls bullet"><span class="by">Davidzheng</span><span>|</span><a href="#41096718">parent</a><span>|</span><a href="#41097337">prev</a><span>|</span><label class="collapse" for="c-41096769">[-]</label><label class="expand" for="c-41096769">[1 more]</label></div><br/><div class="children"><div class="content">I wish someone could do a cost analysis of how much compute could replicate alphaproof. Alphazero was replicated in open source, hopefully this will be too!</div><br/></div></div></div></div></div></div></div></div></div></body></html>