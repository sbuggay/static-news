<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722762051907" as="style"/><link rel="stylesheet" href="styles.css?v=1722762051907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.cr.yp.to/20240803-clang.html">Clang vs. Clang</a> <span class="domain">(<a href="https://blog.cr.yp.to">blog.cr.yp.to</a>)</span></div><div class="subtext"><span>dchest</span> | <span>232 comments</span></div><br/><div><div id="41152080" class="c"><input type="checkbox" id="c-41152080" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#41147014">next</a><span>|</span><label class="collapse" for="c-41152080">[-]</label><label class="expand" for="c-41152080">[1 more]</label></div><br/><div class="children"><div class="content">As someone that knows C but isn&#x27;t familiar with compiler internals, I ask: would the disruptive optimizations discussed here kick in even when compiling with ootimizations tured off (-o0)?<p>C has also other issues related to undefined behavior and it being used for what I call &quot;extreme optimizations&quot; (e.g. not emitting code for an if branch that checks for a null pointer). Rust is emerging as an alternative to C that aims to fix many of its problems, but how does it fares in terms of writing constant-time code? Is it similar to C, easier or more complicated?</div><br/></div></div><div id="41147014" class="c"><input type="checkbox" id="c-41147014" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#41152080">prev</a><span>|</span><a href="#41148775">next</a><span>|</span><label class="collapse" for="c-41147014">[-]</label><label class="expand" for="c-41147014">[106 more]</label></div><br/><div class="children"><div class="content">&gt; compiler writers refuse to take responsibility for the bugs they introduced, even though the compiled code worked fine before the &quot;optimizations&quot;. The excuse for not taking responsibility is that there are &quot;language standards&quot; saying that these bugs should be blamed on millions of programmers writing code that bumps into &quot;undefined behavior&quot;<p>But that&#x27;s not an excuse for having a bug; it&#x27;s the exact evidence that it&#x27;s not a bug at all. Calling the compiler buggy for not doing what you want when you commit Undefined Behavior is like calling dd buggy for destroying your data when you call it with the wrong arguments.</div><br/><div id="41148792" class="c"><input type="checkbox" id="c-41148792" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41147014">parent</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41148792">[-]</label><label class="expand" for="c-41148792">[18 more]</label></div><br/><div class="children"><div class="content">I think this is actually a mistake by the author since the rant is mostly focused on implementation defined behavior, not undefined.<p>The examples they give are all perfectly valid code. The specific bugs they&#x27;re talking about seem to be compiler optimizations that replace bit twiddling arithmetic into branches, which isn&#x27;t a safe optimization if the bit twiddling happens in a cryptographic context because it opens the door for timing attacks.<p>I don&#x27;t think it&#x27;s correct to call either the source code or compiler buggy, it&#x27;s the C standard that is under specified to the author&#x27;s liking and it creates security bugs on some targets.<p>Ultimately though I can agree with the C standard authors that they cannot define the behavior of hardware, they can only define the semantics for the language itself. Crypto guys will have to suffer because the blame is on the hardware for these bugs, not the software.</div><br/><div id="41150228" class="c"><input type="checkbox" id="c-41150228" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148792">parent</a><span>|</span><a href="#41150799">next</a><span>|</span><label class="collapse" for="c-41150228">[-]</label><label class="expand" for="c-41150228">[1 more]</label></div><br/><div class="children"><div class="content">The blog post does, at the very end, mention the thing you should <i>actually do</i>.<p>You need a language where you can express what you actually meant, which in this case is &quot;Perform this constant time operation&quot;. Having expressed what you meant, now everybody between you and the hardware can co-operate to potentially deliver that.<p>So long as you write C (or C++) you&#x27;re ruined, you cannot express what you meant, you are second guessing the compiler authors instead.<p>I think a language related to WUFFS would be good for this in the crypto world. Crypto people know maths already, so the scariest bits of such a language (e.g. writing out why you believe it&#x27;s obvious that 0 &lt;= offset + k + n &lt; array_length so that the machine can see that you&#x27;re correct or explain why you&#x27;re wrong) wouldn&#x27;t be intimidating for them. WUFFS doesn&#x27;t care about constant time, but a similar language could focus on that.</div><br/></div></div><div id="41150799" class="c"><input type="checkbox" id="c-41150799" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148792">parent</a><span>|</span><a href="#41150228">prev</a><span>|</span><a href="#41150162">next</a><span>|</span><label class="collapse" for="c-41150799">[-]</label><label class="expand" for="c-41150799">[6 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s the C standard that is under specified to the author&#x27;s liking<p>Isn&#x27;t this unreasonable?  Here we are, 52, years down the road with C et al. and suddenly it&#x27;s expected that compiler developers must consider any change in the light of timing attacks?  At what point do such new expectations grind compiler development to a halt?  What standard would a compiler developer refer to to stay between the lines?  My instincts tell me that this would be a forever narrowing and forever moving target.<p>Does timing sensitivity ever end?  Asked differently: is there any code that deals in sensitive information that can&#x27;t, somehow, be compromised by timing analysis?  Never mind cryptographic algorithms.  Just measuring the time needed to compute the length of strings will leak <i>something</i> of use, given enough stimuli and data collection.<p>Is there some reason a cryptographic algorithm developer must track the latest release of a compiler?  Separate compilation and linking is still a thing, as far as I know.  Such work could be isolated to &quot;validated&quot; compilers, leaving the insensitive code (if that concept is even real...) to whatever compiler prevails.<p>Also, it&#x27;s not <i>just</i> compilers that can &quot;optimize&quot; code.  Processing elements do this as well.  Logically, therefore, must we not also expect CPU designers to also forego changes that could alter timing behavior?  Forever?<p>I&#x27;ve written a lot of question marks above.  That&#x27;s because this isn&#x27;t my field.  However, invoking my instincts again: what, short of regressing to in-order, non-speculative cores and freezing all compiler development, could possibly satisfy the expectation that no changes are permitted to reveal timing differences where it previously hadn&#x27;t?<p>This all looks like an engineering purity spiral.</div><br/><div id="41151451" class="c"><input type="checkbox" id="c-41151451" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150799">parent</a><span>|</span><a href="#41151846">next</a><span>|</span><label class="collapse" for="c-41151451">[-]</label><label class="expand" for="c-41151451">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Isn&#x27;t this unreasonable? Here we are, 52, years down the road with C et al. and suddenly it&#x27;s expected that compiler developers must consider any change in the light of timing attacks?<p>We already went through a similar case to this: when the C++11 multithreaded memory model was introduced, compiler authors were henceforth forced to consider all future optimizations in light of multithreading. Which actually forced them to go back and suppress some optimizations that otherwise appeared reasonable.<p>This isn&#x27;t to say the idea is good (or bad), but just that &quot;compiler development will grind to a halt&quot; is not a convincing against it.</div><br/><div id="41151874" class="c"><input type="checkbox" id="c-41151874" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151451">parent</a><span>|</span><a href="#41151925">next</a><span>|</span><label class="collapse" for="c-41151874">[-]</label><label class="expand" for="c-41151874">[1 more]</label></div><br/><div class="children"><div class="content">It is completely unreasonable though to assume that a compiler should now preserve some assumed (!) timing of source operations.<p>It would be reasonable to implement (and later standardize) a pragma or something that specifies timings constraint for a subset of the language.  But somebody would need to do the work.</div><br/></div></div><div id="41151925" class="c"><input type="checkbox" id="c-41151925" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151451">parent</a><span>|</span><a href="#41151874">prev</a><span>|</span><a href="#41151846">next</a><span>|</span><label class="collapse" for="c-41151925">[-]</label><label class="expand" for="c-41151925">[1 more]</label></div><br/><div class="children"><div class="content">The difference is that threads have enormously wider applicability than timing preservation does.</div><br/></div></div></div></div><div id="41151846" class="c"><input type="checkbox" id="c-41151846" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150799">parent</a><span>|</span><a href="#41151451">prev</a><span>|</span><a href="#41151715">next</a><span>|</span><label class="collapse" for="c-41151846">[-]</label><label class="expand" for="c-41151846">[1 more]</label></div><br/><div class="children"><div class="content">&gt; short of regressing to in-order, non-speculative cores<p>I guess you are referring to a GPU cores here.<p>It is a joke but can hint that in-order non-speculative cores are powerful computers nonetheless.</div><br/></div></div><div id="41151715" class="c"><input type="checkbox" id="c-41151715" checked=""/><div class="controls bullet"><span class="by">komon</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150799">parent</a><span>|</span><a href="#41151846">prev</a><span>|</span><a href="#41150162">next</a><span>|</span><label class="collapse" for="c-41151715">[-]</label><label class="expand" for="c-41151715">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there some reason a cryptographic algorithm developer must track the latest release of a compiler?<p>Tracking the latest release is important because:<p>1. Distributions build (most? all?) libraries from source, using compilers and flags the algorithm authors can&#x27;t control<p>2. Today&#x27;s latest release is the base of tomorrow&#x27;s LTS.<p>If the people who know most about these algorithms aren&#x27;t tracking the latest compiler releases, then who else would be qualified to detect these issues before a compiler version bearing a problematic optimization is used for the next release of Debian or RHEL?<p>&gt; Logically, therefore, must we not also expect CPU designers to 
also forego changes that could alter timing behavior?<p>Maybe? [1]<p>&gt; freezing all compiler development<p>There are many, many interesting areas of compiler development beyond incremental application of increasingly niche optimizations.<p>For instance, greater ability to demarcate code that is intended to be constant time. Or test suites that can detect when optimizations pose a threat to certain algorithms or implementations. Or optimizing the performance of the compiler itself.<p>Overall I agree with you somewhat. All engineers must constantly rail against entropy, and we are doomed to fail. But DJB is probably correct that a well-reasoned rant aimed at the community that both most desires and most produces the problematic optimizations has a better chance at changing the tide of opinion and shifting the rate at which all must diminish than yelling at chipmakers or the laws of thermodynamics.<p>[1]<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Spectre_(security_vulnerability)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Spectre_(security_vulnerabil...</a></div><br/></div></div></div></div><div id="41150162" class="c"><input type="checkbox" id="c-41150162" checked=""/><div class="controls bullet"><span class="by">gabrielhidasy</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148792">parent</a><span>|</span><a href="#41150799">prev</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41150162">[-]</label><label class="expand" for="c-41150162">[10 more]</label></div><br/><div class="children"><div class="content">Where suffer means &quot;not be lazy, implement the assembly for your primitives in a lib, optimize it as best as you can without compromising security, do not let the compiler &#x27;improve&#x27; it&quot;</div><br/><div id="41150191" class="c"><input type="checkbox" id="c-41150191" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150162">parent</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41150191">[-]</label><label class="expand" for="c-41150191">[9 more]</label></div><br/><div class="children"><div class="content">But then you&#x27;re not writing C, except maybe as some wrappers.  Wanting to use C isn&#x27;t laziness.  Making it nearly unfeasible to use C is the most suffering a C compiler can inflict.</div><br/><div id="41150224" class="c"><input type="checkbox" id="c-41150224" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150191">parent</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41150224">[-]</label><label class="expand" for="c-41150224">[8 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason that C should be suitable for every purpose under the sun.</div><br/><div id="41150264" class="c"><input type="checkbox" id="c-41150264" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150224">parent</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41150264">[-]</label><label class="expand" for="c-41150264">[7 more]</label></div><br/><div class="children"><div class="content">Fiddling some bits cross-platform is supposed to be one of them.</div><br/><div id="41150447" class="c"><input type="checkbox" id="c-41150447" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150264">parent</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41150447">[-]</label><label class="expand" for="c-41150447">[6 more]</label></div><br/><div class="children"><div class="content">As was pointed out elsewhere, fiddling bits with constant time guarantees isn&#x27;t part of the C specification. You need a dedicated implementation that offers those guarantees, which isn&#x27;t clang (or C, to be pedantic).</div><br/><div id="41150462" class="c"><input type="checkbox" id="c-41150462" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150447">parent</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41150462">[-]</label><label class="expand" for="c-41150462">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not in the spec right now but it still feels solidly in C&#x27;s wheelhouse to me.</div><br/><div id="41151934" class="c"><input type="checkbox" id="c-41151934" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150462">parent</a><span>|</span><a href="#41151890">next</a><span>|</span><label class="collapse" for="c-41151934">[-]</label><label class="expand" for="c-41151934">[2 more]</label></div><br/><div class="children"><div class="content">The problem doesn&#x27;t stop there, if you want to ensure constant time behaviour you must also be able to precisely control memory loads&#x2F;stores, otherwise cache timings can subvert even linear assembly code. If you have to verify the assembly, might as well write it in assembly.</div><br/><div id="41152044" class="c"><input type="checkbox" id="c-41152044" checked=""/><div class="controls bullet"><span class="by">NohatCoder</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151934">parent</a><span>|</span><a href="#41151890">next</a><span>|</span><label class="collapse" for="c-41152044">[-]</label><label class="expand" for="c-41152044">[1 more]</label></div><br/><div class="children"><div class="content">The cryptographic constant time requirement only concerns operations that are influenced by secret data. You can&#x27;t learn the contents of say a secret key by how long it took to load from memory. But say we use some secret data to determine what part of the key to load, then the timing might reveal some of that data.</div><br/></div></div></div></div><div id="41151890" class="c"><input type="checkbox" id="c-41151890" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150462">parent</a><span>|</span><a href="#41151934">prev</a><span>|</span><a href="#41150647">next</a><span>|</span><label class="collapse" for="c-41151890">[-]</label><label class="expand" for="c-41151890">[1 more]</label></div><br/><div class="children"><div class="content">I agree that an extension (e.g. a pragma or some high-level operations similar to ckd_{add,sub,mul}) that allows writing code with fixed timing would be very useful.<p>But we have generally the problem that there are far more people complaining that actually contributing usefully to the ecosystem.  For example, I have not seen anybody propose or work on such an extension for GCC.</div><br/></div></div><div id="41150647" class="c"><input type="checkbox" id="c-41150647" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150462">parent</a><span>|</span><a href="#41151890">prev</a><span>|</span><a href="#41148085">next</a><span>|</span><label class="collapse" for="c-41150647">[-]</label><label class="expand" for="c-41150647">[1 more]</label></div><br/><div class="children"><div class="content">Fortunately you don&#x27;t have to go 100% one way or the other. Write your code in C, compile and check it&#x27;s correct and constant time, then commit that assembly output to the repo. You can also clean it up yourself or add extra changes on top.<p>You don&#x27;t need to rely on C to guarantee some behaviour forever.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41148085" class="c"><input type="checkbox" id="c-41148085" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41147014">parent</a><span>|</span><a href="#41148792">prev</a><span>|</span><a href="#41150042">next</a><span>|</span><label class="collapse" for="c-41148085">[-]</label><label class="expand" for="c-41148085">[24 more]</label></div><br/><div class="children"><div class="content">The problem is that c and c++ have a ridiculous amount of undefined behavior, and it is extremely difficult to avoid all of it.<p>One of the advantages of rust is it confines any potential UB to unsafe blocks. But even in rust, which has defined behavior in a lot of places that are UB in c, if you venture into unsafe code, it is remarkable easy to accidentally run into subtle UB issues.</div><br/><div id="41148229" class="c"><input type="checkbox" id="c-41148229" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148085">parent</a><span>|</span><a href="#41150004">next</a><span>|</span><label class="collapse" for="c-41148229">[-]</label><label class="expand" for="c-41148229">[15 more]</label></div><br/><div class="children"><div class="content">It’s true that UB is not intuitive at first, but “ridiculous amount” and “difficult to avoid” is overstating it. You have to have a proof-writing mindset when coding, but you do get sensitized to the pitfalls once you read up on what the language constructs actually guarantee (and don’t guarantee), and it’s not that much more difficult than, say, avoiding panics in Rust.</div><br/><div id="41151915" class="c"><input type="checkbox" id="c-41151915" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148229">parent</a><span>|</span><a href="#41149455">next</a><span>|</span><label class="collapse" for="c-41151915">[-]</label><label class="expand" for="c-41151915">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I do not find UB very problematic in practice. It is still certainly a challenge when writing security sensitive code to fully make sure there is no issue left. (also of course, model checker, or run-time verified code such as eBPF etc. exist).<p>But the amount of actual problems I have with UB in typical projects is very low by just  some common sense and good use of tools: continuous integration with sanitizers, using pointers to arrays instead of raw pointers (where a sanitizer then does bounds checks),  avoiding open coded string and buffer operations, also abstracting away other complicated data structures behind safe interfaces, and following a clear policy about memory ownership.</div><br/></div></div><div id="41149455" class="c"><input type="checkbox" id="c-41149455" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148229">parent</a><span>|</span><a href="#41151915">prev</a><span>|</span><a href="#41149073">next</a><span>|</span><label class="collapse" for="c-41149455">[-]</label><label class="expand" for="c-41149455">[4 more]</label></div><br/><div class="children"><div class="content">In my experience it is very easy to accidentally introduce iterator invalidation: it starts with calling a callback while iterating, add some layers of indirection, and eventually somebody will add some innocent looking code deep down the call stack which ends up mutating the collection while it&#x27;s being iterated.</div><br/><div id="41149567" class="c"><input type="checkbox" id="c-41149567" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41149455">parent</a><span>|</span><a href="#41151003">next</a><span>|</span><label class="collapse" for="c-41149567">[-]</label><label class="expand" for="c-41149567">[1 more]</label></div><br/><div class="children"><div class="content">I can tell you that this happens in Java as well, which doesn’t have undefined behavior. That’s just the nature of mutable state in combination with algorithms that only work while the state remains unmodified.</div><br/></div></div><div id="41151003" class="c"><input type="checkbox" id="c-41151003" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41149455">parent</a><span>|</span><a href="#41149567">prev</a><span>|</span><a href="#41149073">next</a><span>|</span><label class="collapse" for="c-41151003">[-]</label><label class="expand" for="c-41151003">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m familiar with that very sort of bug, but I don&#x27;t see how it&#x27;s a failure of the language. To be convinced of that I think I&#x27;d at least need to be shown what a good solution to that problem would look like (at the level of the language and&#x2F;or standard library).</div><br/><div id="41151481" class="c"><input type="checkbox" id="c-41151481" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151003">parent</a><span>|</span><a href="#41149073">next</a><span>|</span><label class="collapse" for="c-41151481">[-]</label><label class="expand" for="c-41151481">[1 more]</label></div><br/><div class="children"><div class="content">Rust statically enforces that you have exclusive access to a collection to mutate it. This prevents also having an active iterator.<p>You also have languages using immutable or persistent data structures in their std lib to side-step the problem.</div><br/></div></div></div></div></div></div><div id="41149073" class="c"><input type="checkbox" id="c-41149073" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148229">parent</a><span>|</span><a href="#41149455">prev</a><span>|</span><a href="#41149910">next</a><span>|</span><label class="collapse" for="c-41149073">[-]</label><label class="expand" for="c-41149073">[1 more]</label></div><br/><div class="children"><div class="content">So surely you know by hear the circa 200 use cases documented in ISO C, and the even greater list documented in ISO C++ standard documents.<p>Because, me despite knowing both since the 1990&#x27;s, I rather leave that to static analysis tools.</div><br/></div></div><div id="41149910" class="c"><input type="checkbox" id="c-41149910" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148229">parent</a><span>|</span><a href="#41149073">prev</a><span>|</span><a href="#41150829">next</a><span>|</span><label class="collapse" for="c-41149910">[-]</label><label class="expand" for="c-41149910">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t so much that it is unintuitive, for the most part[1], but rather that there are a lot of things to keep track of, and a seemingly innocous change in one part of the program can potentially result in UB in somewhere far away. And usually such bugs are not code that is blatantly undefined behavior, but rather code that is well defined most of the time, but in some edge case can trigger undefined behavior.<p>It would help if there was better tooling for finding places that could result in UB.<p>[1]: although some of them can be a little surprising, like the fact that overflow is defined for unsigned types but not signed types</div><br/></div></div><div id="41150829" class="c"><input type="checkbox" id="c-41150829" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148229">parent</a><span>|</span><a href="#41149910">prev</a><span>|</span><a href="#41151766">next</a><span>|</span><label class="collapse" for="c-41150829">[-]</label><label class="expand" for="c-41150829">[3 more]</label></div><br/><div class="children"><div class="content">Would you mind sharing how you became sensitized to UB code? Did you just read the C spec, carefully digest it, and then read&#x2F;write lots of C? Or do you have other recommendations for someone else interested in intuiting UB as well?</div><br/><div id="41152028" class="c"><input type="checkbox" id="c-41152028" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150829">parent</a><span>|</span><a href="#41151836">next</a><span>|</span><label class="collapse" for="c-41152028">[-]</label><label class="expand" for="c-41152028">[1 more]</label></div><br/><div class="children"><div class="content">What helped me was to instrument older game engine version build with Clang&#x27;s UB sanitizer and attempt to run it for few weeks. Granted I had to approve the research with management to have that much time but I have learned some things I have never seen in twentyish years of using C++.</div><br/></div></div><div id="41151836" class="c"><input type="checkbox" id="c-41151836" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150829">parent</a><span>|</span><a href="#41152028">prev</a><span>|</span><a href="#41151766">next</a><span>|</span><label class="collapse" for="c-41151836">[-]</label><label class="expand" for="c-41151836">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry but OP seems to be vastly overestimating their abilities. Every study about bugs related to UB show that even the best programmers will make mistakes, and often mistakes that are nearly impossible to have prevented without static tools because of the action-at-a-distance nature of the harder ones (unless you had the whole code base in your head, and you paid enormous attention to the consequences of every single instruction you wrote, you just couldn&#x27;t have prevented UB).</div><br/></div></div></div></div><div id="41151766" class="c"><input type="checkbox" id="c-41151766" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148229">parent</a><span>|</span><a href="#41150829">prev</a><span>|</span><a href="#41151631">next</a><span>|</span><label class="collapse" for="c-41151766">[-]</label><label class="expand" for="c-41151766">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but “ridiculous amount” and “difficult to avoid” is overstating it<p>Maybe you can argue that C doesn&#x27;t have a “ridiculous amount” of UB (even though the number is large), but C++ is so much worse I don&#x27;t think saying it&#x27;s “ridiculous” is off the mark.<p>And not only the amount is already ridiculous but every new feature introduced in modern versions of C++ adds its own brand new UB!</div><br/><div id="41151950" class="c"><input type="checkbox" id="c-41151950" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151766">parent</a><span>|</span><a href="#41151631">next</a><span>|</span><label class="collapse" for="c-41151950">[-]</label><label class="expand" for="c-41151950">[1 more]</label></div><br/><div class="children"><div class="content">If you count the number of UB in the standard, then yes, 200 cases is high. There is some ongoing effort to eliminate many of them. But it should also be noted, that almost all of those cases are not really problematic in practice. The problematic ones are  signed overflow, out-of-bounds,  use-after-free, and aliasing issues. Signed overflow is IMHO not a problem anymore because of sanitizers. In fact, I believe that unsigned wraparound is much more problematic. Out-of-bounds and use-after-free can be dealt with by having good coding strategies and for out-of-bounds issues I expect that we will have full bounds safety  options in compilers soon. Aliasing issues can also mostly be avoided by not playing games with types. User-after-free is more problematic (and where the main innovation of Rust is). But  having a good ownership model and good abstractions also avoids most problems here in my experience.  I rarely have actual problems in my projects related to this.</div><br/></div></div></div></div><div id="41151631" class="c"><input type="checkbox" id="c-41151631" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148229">parent</a><span>|</span><a href="#41151766">prev</a><span>|</span><a href="#41150004">next</a><span>|</span><label class="collapse" for="c-41151631">[-]</label><label class="expand" for="c-41151631">[2 more]</label></div><br/><div class="children"><div class="content">You say this, and yet every single major project written in C has undefined behavior issues. The Linux kernel even demanded and uses a special flag in GCC to define some of this UB (especially the most brain dead one, signed integer overflow).</div><br/><div id="41151745" class="c"><input type="checkbox" id="c-41151745" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151631">parent</a><span>|</span><a href="#41150004">next</a><span>|</span><label class="collapse" for="c-41151745">[-]</label><label class="expand" for="c-41151745">[1 more]</label></div><br/><div class="children"><div class="content">The linux kernel nowadays uses the fact that signed overflow is UB to detect problems using sanitizers.  It turns out the defined unsigned wraparound is now the hard problem.</div><br/></div></div></div></div></div></div><div id="41150004" class="c"><input type="checkbox" id="c-41150004" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148085">parent</a><span>|</span><a href="#41148229">prev</a><span>|</span><a href="#41151484">next</a><span>|</span><label class="collapse" for="c-41150004">[-]</label><label class="expand" for="c-41150004">[7 more]</label></div><br/><div class="children"><div class="content">I think the biggest problem is people conflating &quot;undefined&quot; with &quot;unknowable&quot;. They act like because C doesn&#x27;t define the behavior you can&#x27;t expect certain compilers to behave a certain way. GCC handles signed overflows consistently, even though the concept is undefined at a language level; as goes many other UBs. And the big compilers are all pretty consistent with each other.<p>Is it annoying if you want to make sure your code compiles the same in different compiler sets? Sure, but that&#x27;s part of the the issue with the standards body and the compiler developers existing independent of each other. Especially considering plenty of times C&#x2F;C++ have tried to enforce certain niche behaviors and GCC&#x2F;ICC&#x2F;Clang&#x2F;etc have decided to go their own ways.</div><br/><div id="41151725" class="c"><input type="checkbox" id="c-41151725" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150004">parent</a><span>|</span><a href="#41151484">next</a><span>|</span><label class="collapse" for="c-41151725">[-]</label><label class="expand" for="c-41151725">[6 more]</label></div><br/><div class="children"><div class="content">This is dead wrong, and a very dangerous mindset.<p>All modern C and C++ compilers use the potential of UB as a signal in their optimization options. It is 100% unpredictable how a given piece of code where UB happens will actually be compiled, unless you are intimately familiar with every detail of the optimizer and the signals it uses. And even if you are, seemingly unrelated changes can change the logic of the optimizer just enough to entirely change the compilation of your UB segment (e.g. because a function is now too long to be inlined, so a certain piece of code can no longer be guaranteed to have some property, so [...]).<p>Your example of signed integer overflow is particularly glaring, as this has actually triggered real bugs in the Linux kernel (before they started using a compilation flag to force signed integer overflow to be considered defined behavior). Sure, the compiler compiles all signed integer operations to processor instructions that result in two&#x27;s complement operations, and thus overflow on addition. But, since signed integer overflow is UB, the compiler also assumes it never happens, and optimizes your program accordingly.<p>For example, the following program will never print &quot;overflow&quot; regardless of what value x has:<p><pre><code>  int foo(int num) {
    int x = num + 100;
    if (x &lt; num) {
      printf(&quot;overflow occured&quot;);
    }
    return x;
  }
</code></pre>
In fact, you won&#x27;t even find the string &quot;overflow&quot; in the compiled binary, as the whole `if` is optimized away [0], since per the standard signed integer overflow can&#x27;t occur, so x + 100 is always greater than x for any (valid) value of x.<p>[0] <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;zzdr4q1Gx" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;zzdr4q1Gx</a></div><br/><div id="41151859" class="c"><input type="checkbox" id="c-41151859" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151725">parent</a><span>|</span><a href="#41151484">next</a><span>|</span><label class="collapse" for="c-41151859">[-]</label><label class="expand" for="c-41151859">[5 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this a terrible failure of the compiler though? Why is it not just telling you that the `if` is a noop?? Damn, using IntelliJ and getting feedback on really difficult logic when a branch becomes unreachable and can be removed makes this sort of thing look like amateur hour.</div><br/><div id="41151945" class="c"><input type="checkbox" id="c-41151945" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151859">parent</a><span>|</span><a href="#41151875">next</a><span>|</span><label class="collapse" for="c-41151945">[-]</label><label class="expand" for="c-41151945">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    if(DEBUG) {
       log(&quot;xyz&quot;)
    }
</code></pre>
Should the compiler emit a warning for such code? Compilers don&#x27;t behave like a human brain, maybe a specific diagnostic could be added by pattern matching the AST but it will never catch every case.</div><br/><div id="41152004" class="c"><input type="checkbox" id="c-41152004" checked=""/><div class="controls bullet"><span class="by">robinsonb5</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151945">parent</a><span>|</span><a href="#41151875">next</a><span>|</span><label class="collapse" for="c-41152004">[-]</label><label class="expand" for="c-41152004">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a world of difference between code that&#x27;s dead because of a static define, and code that&#x27;s dead because of an inference the compiler made.<p>A dead code report would be a useful thing, though, especially if it could give the reason for removal. (Something like the list of removed registers in the Quartus analysis report when building for FPGAs.)</div><br/></div></div></div></div><div id="41151875" class="c"><input type="checkbox" id="c-41151875" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151859">parent</a><span>|</span><a href="#41151945">prev</a><span>|</span><a href="#41151484">next</a><span>|</span><label class="collapse" for="c-41151875">[-]</label><label class="expand" for="c-41151875">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the core of the complaints about how modern C and C++ compilers use UB.</div><br/><div id="41151973" class="c"><input type="checkbox" id="c-41151973" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151875">parent</a><span>|</span><a href="#41151484">next</a><span>|</span><label class="collapse" for="c-41151973">[-]</label><label class="expand" for="c-41151973">[1 more]</label></div><br/><div class="children"><div class="content">The focus was certainly much more on optimization instead of having good warnings (although any commercial products focus on that).   I would not blame compiler vendors exclusively, certainly paying customer also prioritized this.<p>This is shifting though, e.g. GCC now has -fanalyzer. I does not detect this specific coding error though, but for example  issues such as dereferencing a pointer before checking for null.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41151484" class="c"><input type="checkbox" id="c-41151484" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148085">parent</a><span>|</span><a href="#41150004">prev</a><span>|</span><a href="#41150042">next</a><span>|</span><label class="collapse" for="c-41151484">[-]</label><label class="expand" for="c-41151484">[1 more]</label></div><br/><div class="children"><div class="content">This is about asking the compiler for a constexpr and receiving a runtime evaluation, not ownership semantics.</div><br/></div></div></div></div><div id="41150042" class="c"><input type="checkbox" id="c-41150042" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41147014">parent</a><span>|</span><a href="#41148085">prev</a><span>|</span><a href="#41150877">next</a><span>|</span><label class="collapse" for="c-41150042">[-]</label><label class="expand" for="c-41150042">[23 more]</label></div><br/><div class="children"><div class="content">There are only two models of UB that are useful to compiler users:<p>1) This is a bad idea and refuse to compile.<p>2) Do something sensible and stable.<p>Silently fail and generate impossible to predict code is a third model that is only of use to compiler writers. Hiding behind the spec benefits no actual user.</div><br/><div id="41150080" class="c"><input type="checkbox" id="c-41150080" checked=""/><div class="controls bullet"><span class="by">opnitro</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150042">parent</a><span>|</span><a href="#41150461">next</a><span>|</span><label class="collapse" for="c-41150080">[-]</label><label class="expand" for="c-41150080">[15 more]</label></div><br/><div class="children"><div class="content">I think this is a point of view that seems sensible, but probably hasn&#x27;t really thought through how this works. For example<p><pre><code>  some_array[i]
</code></pre>
What should the compiler emit here? Should it emit a bounds check? In the event the bounds check fails, what should it do? It is only through the practice of undefined behavior that the compiler can consistently generate code that avoids the bounds check. (We don&#x27;t need it, because if `i` is out-of-bounds then it&#x27;s undefined behavior and illegal).<p>If you think this is bad, then you&#x27;re arguing against memory unsafe languages in general. A sane position is the one the Rust takes, which is by default, yes indeed you should always generate the bounds check (unless you can prove it always succeeds). But there will likely always be hot inner loops where we need to discharge the bounds checks statically. Ideally that would be done with some kind of formal reasoning support, but the industry is far that atm.<p>For a more in depth read: <a href="https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;213" rel="nofollow">https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;213</a></div><br/><div id="41150141" class="c"><input type="checkbox" id="c-41150141" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150080">parent</a><span>|</span><a href="#41150461">next</a><span>|</span><label class="collapse" for="c-41150141">[-]</label><label class="expand" for="c-41150141">[14 more]</label></div><br/><div class="children"><div class="content">&gt; What should the compiler emit here?<p>It should emit an instruction to access memory location some_array + i.<p>That&#x27;s all most people that complain about optimizations on undefined behavior want.  Sometimes there are questions that are hard to answer, but in a situation like this, the answer is &quot;Try it and hope it doesn&#x27;t corrupt memory.&quot;  The behavior that&#x27;s not wanted is for the compiler to wildly change behavior on purpose when something is undefined.  For example, the compiler could optimize<p><pre><code>  if(foo) {
      misbehaving_code();
      return puppies;
  } else {
      delete_data();
  }
</code></pre>
into<p><pre><code>  delete_data();</code></pre></div><br/><div id="41151189" class="c"><input type="checkbox" id="c-41151189" checked=""/><div class="controls bullet"><span class="by">opnitro</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150141">parent</a><span>|</span><a href="#41150830">next</a><span>|</span><label class="collapse" for="c-41151189">[-]</label><label class="expand" for="c-41151189">[2 more]</label></div><br/><div class="children"><div class="content">I think the &quot;do the normal&quot; thing is very easy to say and very hard to do in general. Should every case of `a &#x2F; b` inject a `(b != 0) &amp;&amp; ((a != INT_MAX &amp;&amp; b != -1))`? If that evaluates to `true` then what should the program do? Or: should the compiler assume this can&#x27;t happen. Languages with rich runtimes get around this by having an agreed upon way to signal errors, at the expense of runtime checking. An example directly stolen from the linked blog post:<p><pre><code>  int stupid (int a) {
    return (a+1) &gt; a;
  }
</code></pre>
What should the compiler emit for this? Should it check for overflow, or should it emit the asm equivalent of `return 1`? If your answer is check for overflow: then should the compiler be forced to check for overflow every time it increments an integer in a for loop? If your answer is don&#x27;t check: then how do you explain this function behaving completely weird in the overflow case? The point I&#x27;m trying to get at is that &quot;do the obvious thing&quot; is completely dependent on context.</div><br/><div id="41151782" class="c"><input type="checkbox" id="c-41151782" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151189">parent</a><span>|</span><a href="#41150830">next</a><span>|</span><label class="collapse" for="c-41151782">[-]</label><label class="expand" for="c-41151782">[1 more]</label></div><br/><div class="children"><div class="content">The compiler should emit the code to add one to a, and then code to check if the result is greater than a. This is completely evident, and is what all C and C++ compilers did for the first few decades of their existence. Maybe a particularly smart compiler could issue a `jo` instead of a `cmp ax, bx; jz `.<p>The for loop example is silly. There is no reason whatsoever to add an overflow check in a for loop. The code of a standard for loop, `for (int i  = 0; i &lt; n; i++)` doesn&#x27;t say to do any overflow check, so why would the compiler insert one? Not inserting overflow checks is completely different than omitting overflow checks explicitly added in the code. Not to mention, for this type of loop, the compiler doesn&#x27;t need any UB-based logic to prove that the loop terminates - for any possible value of n, including INT_MAX, this loop will terminate, assuming `i` is not modified elsewhere.<p>I&#x27;d also note that the &quot;most correct&quot; type to use for the iteration variable in a loop used to access an array, per the standard, would be `size_t`, which is an unsigned type, which does allow overflow to happen. The standard for loop should be `for (size_t i = 0; i &lt; n; ++i)`, which doesn&#x27;t allow the compiler to omit any overflow checks, even if any were present.</div><br/></div></div></div></div><div id="41150830" class="c"><input type="checkbox" id="c-41150830" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150141">parent</a><span>|</span><a href="#41151189">prev</a><span>|</span><a href="#41151760">next</a><span>|</span><label class="collapse" for="c-41150830">[-]</label><label class="expand" for="c-41150830">[2 more]</label></div><br/><div class="children"><div class="content">Ah, but what if it writes so far off the array that it messes with the contents of another variable on the stack that is currently cached in a register? Should the compiler reload that register because the out of bounds write might have updated it? Probably not, let&#x27;s just assume they didn&#x27;t mean to do that and use the in-register version. That&#x27;s taking advantage of undefined behavior to optimize a program.</div><br/><div id="41150852" class="c"><input type="checkbox" id="c-41150852" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150830">parent</a><span>|</span><a href="#41151760">next</a><span>|</span><label class="collapse" for="c-41150852">[-]</label><label class="expand" for="c-41150852">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ah, but what if it writes so far off the array that it messes with the contents of another variable on the stack that is currently cached in a register? Should the compiler reload that register because the out of bounds write might have updated it? Probably not, let&#x27;s just assume they didn&#x27;t mean to do that and use the in-register version.<p>Yes, go ahead and assume it won&#x27;t alias outside the rules of C and hope it works out.<p>&gt; That&#x27;s taking advantage of undefined behavior to optimize a program.<p>I don&#x27;t know if I really agree with that, but even taking that as true, that&#x27;s fine.  The objection isn&#x27;t to doing <i>any</i> optimizations.  Assuming memory didn&#x27;t get stomped is fine.  Optimizations that significantly change program flow in the face of misbehavior and greatly amplify it are painful.  And lots of things are in the middle.</div><br/></div></div></div></div><div id="41151760" class="c"><input type="checkbox" id="c-41151760" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150141">parent</a><span>|</span><a href="#41150830">prev</a><span>|</span><a href="#41150269">next</a><span>|</span><label class="collapse" for="c-41151760">[-]</label><label class="expand" for="c-41151760">[1 more]</label></div><br/><div class="children"><div class="content">Why not just turn off (or down) optimizations?  I mean, optimization is not even activated by default</div><br/></div></div><div id="41150269" class="c"><input type="checkbox" id="c-41150269" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150141">parent</a><span>|</span><a href="#41151760">prev</a><span>|</span><a href="#41150208">next</a><span>|</span><label class="collapse" for="c-41150269">[-]</label><label class="expand" for="c-41150269">[3 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s all most people that complain about optimizations on undefined behavior want<p>If this was true most of them could just adopt Rust where of course this isn&#x27;t a problem.<p>But in fact they&#x27;re often vehemently against Rust. They like C and C++ where they can write total nonsense which has no meaning but it compiles and then they can blame the compiler for not reading their mind and doing whatever it is they thought it &quot;obviously&quot; should do.</div><br/><div id="41150648" class="c"><input type="checkbox" id="c-41150648" checked=""/><div class="controls bullet"><span class="by">II2II</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150269">parent</a><span>|</span><a href="#41150208">next</a><span>|</span><label class="collapse" for="c-41150648">[-]</label><label class="expand" for="c-41150648">[2 more]</label></div><br/><div class="children"><div class="content">I could be wrong here since I don&#x27;t develop compilers, but from my understanding many of the undefined behaviours in C are the product of not knowing what the outcome will be for edge cases or due to variations in processor architecture. In these cases, undefined behaviour was intended as a red flag for application developers. Many application developers ended up treating the undefined behaviours as deterministic provided that certain conditions were met. On the other hand, compiler developers took undefined behaviour to mean they could do what they wanted, generating different results in different circumstance, thus violating the expectations of application developers.</div><br/><div id="41151780" class="c"><input type="checkbox" id="c-41151780" checked=""/><div class="controls bullet"><span class="by">robinsonb5</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150648">parent</a><span>|</span><a href="#41150208">next</a><span>|</span><label class="collapse" for="c-41151780">[-]</label><label class="expand" for="c-41151780">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem is that some behaviours are undefined where developers expect them to be implementation-defined (especially in C&#x27;s largest remaining stronghold, the embedded world) - i.e. do what makes sense on this particular CPU.<p>Signed overflow is the classic example - making that undefined rather than implementation-defined is a decision that makes less to those of us living in today&#x27;s exclusively two&#x27;s-complement world than it would have done when it was taken.<p>It&#x27;s become more of an issue in recent years as compilers started doing more advanced optimisations, which some people perceived as the compiler being &quot;lawful evil&quot;.<p>What it reminds me of is that episode of Red Dwarf with Kryten (with his behavioural chip disabled) explaining why he thought it was OK to serve roast human to the crew: &quot;If you eat chicken then obviously you&#x27;d eat your own species too, otherwise you&#x27;d just be picking on the chickens&quot;!</div><br/></div></div></div></div></div></div><div id="41150208" class="c"><input type="checkbox" id="c-41150208" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150141">parent</a><span>|</span><a href="#41150269">prev</a><span>|</span><a href="#41150461">next</a><span>|</span><label class="collapse" for="c-41150208">[-]</label><label class="expand" for="c-41150208">[5 more]</label></div><br/><div class="children"><div class="content">&gt; It should emit an instruction to access memory location some_array + i.<p>That&#x27;s definitely what compilers emit. The UB comes from the fact that the compiler cannot guarantee how the actual memory will respond to that. Will the OS kill you? Will your bare metal MCU silently return garbage? Will you corrupt your program state and jump into branches that should never be reached? Who knows. You&#x27;re advocating for wild behavior but you don&#x27;t even realize it.<p>As for your example. No, the compiler couldn&#x27;t optimize like that. You seem to have some misconceptions about UB. If foo is false in your code, then the behavior is completely defined.</div><br/><div id="41150222" class="c"><input type="checkbox" id="c-41150222" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150208">parent</a><span>|</span><a href="#41150461">next</a><span>|</span><label class="collapse" for="c-41150222">[-]</label><label class="expand" for="c-41150222">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If foo is false in your code, then the behavior is completely defined.<p>That&#x27;s the point.  If foo is false, both versions do the same thing.  If foo is true, then it&#x27;s undefined and it doesn&#x27;t matter.  Therefore, assume foo is false.  Remove the branch.</div><br/><div id="41151442" class="c"><input type="checkbox" id="c-41151442" checked=""/><div class="controls bullet"><span class="by">myrryr</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150222">parent</a><span>|</span><a href="#41150461">next</a><span>|</span><label class="collapse" for="c-41151442">[-]</label><label class="expand" for="c-41151442">[3 more]</label></div><br/><div class="children"><div class="content">Yes! This is exactly the point.
It is undefined, so given that, it could do what the other branch does, so you can safely remove that branch.<p>you get it, but a lot of other people don&#x27;t understand just how undefined, undefined code is.</div><br/><div id="41151635" class="c"><input type="checkbox" id="c-41151635" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151442">parent</a><span>|</span><a href="#41150461">next</a><span>|</span><label class="collapse" for="c-41151635">[-]</label><label class="expand" for="c-41151635">[2 more]</label></div><br/><div class="children"><div class="content">We do. We just wish undefined was defined to be a bit less undefined, and are willing to sacrifice a bit of performance for higher debuggability an. ability to reason.</div><br/><div id="41152009" class="c"><input type="checkbox" id="c-41152009" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151635">parent</a><span>|</span><a href="#41150461">next</a><span>|</span><label class="collapse" for="c-41152009">[-]</label><label class="expand" for="c-41152009">[1 more]</label></div><br/><div class="children"><div class="content">Why not use -fsanitize=signed-integer-overflow ?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41150461" class="c"><input type="checkbox" id="c-41150461" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150042">parent</a><span>|</span><a href="#41150080">prev</a><span>|</span><a href="#41151251">next</a><span>|</span><label class="collapse" for="c-41150461">[-]</label><label class="expand" for="c-41150461">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Silently fail and generate impossible to predict code is a third model that is only of use to compiler writers. Hiding behind the spec benefits no actual user.<p>A significant issue is that compiler &quot;optimizations&quot; aren&#x27;t gaining a lot of <i>general</i> benefit anymore, and yet they are imposing a very significant <i>cost</i> on many people.<p>Lots of people still are working on C&#x2F;C++ compiler optimizations, but nobody is asking if that is worthwhile to <i>end users</i> anymore.<p>Data suggests that it is not.</div><br/><div id="41151283" class="c"><input type="checkbox" id="c-41151283" checked=""/><div class="controls bullet"><span class="by">pertymcpert</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150461">parent</a><span>|</span><a href="#41151251">next</a><span>|</span><label class="collapse" for="c-41151283">[-]</label><label class="expand" for="c-41151283">[5 more]</label></div><br/><div class="children"><div class="content">What data?</div><br/><div id="41151402" class="c"><input type="checkbox" id="c-41151402" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151283">parent</a><span>|</span><a href="#41151251">next</a><span>|</span><label class="collapse" for="c-41151402">[-]</label><label class="expand" for="c-41151402">[4 more]</label></div><br/><div class="children"><div class="content">TFA?  Quoting:<p><pre><code>    Compiler writers measure an &quot;optimization&quot; as successful if they can find any example where the &quot;optimization&quot; saves time. Does this matter for the overall user experience? The typical debate runs as follows:

    In 2000, Todd A. Proebsting introduced &quot;Proebsting&#x27;s Law: Compiler Advances Double Computing Power Every 18 Years&quot; (emphasis in original) and concluded that &quot;compiler optimization work makes only marginal contributions&quot;. Proebsting commented later that &quot;The law probably would have gone unnoticed had it not been for the protests by those receiving funds to do compiler optimization research.&quot;

    Arseny Kapoulkine ran various benchmarks in 2022 and concluded that the gains were even smaller: &quot;LLVM 11 tends to take 2x longer to compile code with optimizations, and as a result produces code that runs 10-20% faster (with occasional outliers in either direction), compared to LLVM 2.7 which is more than 10 years old.&quot;

    Compiler writers typically respond with arguments like this: &quot;10-20% is gazillions of dollars of computer time saved! What a triumph from a decade of work!&quot;
</code></pre>
We are spinning the compilers much harder and imposing changes on end programmers for roughly 10-20% over a decade.  That&#x27;s not a lot of gain in return for the pain being caused.<p>I suspect most programmers would <i>happily</i> give up 10% performance on their final program if they could halve their compile times.</div><br/><div id="41151946" class="c"><input type="checkbox" id="c-41151946" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151402">parent</a><span>|</span><a href="#41151433">next</a><span>|</span><label class="collapse" for="c-41151946">[-]</label><label class="expand" for="c-41151946">[1 more]</label></div><br/><div class="children"><div class="content">Half of what? I&#x27;m not overly concerned about how long a prod build &amp; deploy takes if it&#x27;s automated. 10 minute build instead of 5 for 10% perf gain is probably worth it. Probably more and more worth it as you scale up because you only need to build it once then you can copy the binary to many machines where they all benefit.</div><br/></div></div><div id="41151433" class="c"><input type="checkbox" id="c-41151433" checked=""/><div class="controls bullet"><span class="by">pertymcpert</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151402">parent</a><span>|</span><a href="#41151946">prev</a><span>|</span><a href="#41151251">next</a><span>|</span><label class="collapse" for="c-41151433">[-]</label><label class="expand" for="c-41151433">[2 more]</label></div><br/><div class="children"><div class="content">You would be very wrong on that last point.</div><br/><div id="41152063" class="c"><input type="checkbox" id="c-41152063" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151433">parent</a><span>|</span><a href="#41151251">next</a><span>|</span><label class="collapse" for="c-41152063">[-]</label><label class="expand" for="c-41152063">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact you and GP both right. Goals of &#x27;local&#x27; build a programmer does to check what he wrote are at odds with goals of &#x27;build farm&#x27; build meant for end user. Former should be optimized to reduce build time and latter optimized to reduce run-time. In gamedev we separate them as different build configurations.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41151251" class="c"><input type="checkbox" id="c-41151251" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150042">parent</a><span>|</span><a href="#41150461">prev</a><span>|</span><a href="#41150877">next</a><span>|</span><label class="collapse" for="c-41151251">[-]</label><label class="expand" for="c-41151251">[1 more]</label></div><br/><div class="children"><div class="content">If something is good for compiler developers, it is good for compiler users, in the sense that it makes it easier for the compiler developers to make the compilers we need.</div><br/></div></div></div></div><div id="41150877" class="c"><input type="checkbox" id="c-41150877" checked=""/><div class="controls bullet"><span class="by">aleksi</span><span>|</span><a href="#41147014">parent</a><span>|</span><a href="#41150042">prev</a><span>|</span><a href="#41148648">next</a><span>|</span><label class="collapse" for="c-41150877">[-]</label><label class="expand" for="c-41150877">[1 more]</label></div><br/><div class="children"><div class="content">Russ Cox has a nice article about it: C and C++ Prioritize Performance over Correctness (<a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;ub" rel="nofollow">https:&#x2F;&#x2F;research.swtch.com&#x2F;ub</a>)</div><br/></div></div><div id="41148648" class="c"><input type="checkbox" id="c-41148648" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#41147014">parent</a><span>|</span><a href="#41150877">prev</a><span>|</span><a href="#41150801">next</a><span>|</span><label class="collapse" for="c-41148648">[-]</label><label class="expand" for="c-41148648">[3 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re replying to a strawman. Here&#x27;s the full quote:<p>&gt; The excuse for not taking responsibility is that there are &quot;language standards&quot; saying that these bugs should be blamed on millions of programmers writing code that bumps into &quot;undefined behavior&quot;, rather than being blamed on the much smaller group of compiler writers subsequently changing how this code behaves. These &quot;language standards&quot; are written by the compiler writers.<p>&gt; Evidently the compiler writers find it more important to continue developing &quot;optimizations&quot; than to have computer systems functioning as expected. Developing &quot;optimizations&quot; seems to be a very large part of what compiler writers are paid to do.<p>The argument is that the compiler writers are themselves the ones deciding what is and isn&#x27;t undefined, and they are defining those standards in such a way as to allow themselves latitude for further optimizations. Those optimizations then break previously working code.<p>The compiler writers could instead choose to prioritize backwards compatibility, but they don&#x27;t. Further, these optimizations don&#x27;t meaningfully improve the performance of real world code, so the trade-off of breaking code isn&#x27;t even worth it.<p>That&#x27;s the argument you need to rebut.</div><br/><div id="41148793" class="c"><input type="checkbox" id="c-41148793" checked=""/><div class="controls bullet"><span class="by">quohort</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148648">parent</a><span>|</span><a href="#41150801">next</a><span>|</span><label class="collapse" for="c-41148793">[-]</label><label class="expand" for="c-41148793">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps the solution is also to reign in the language standard to support stricter use cases. For example, what if there was a constant-time { ... }; block in the same way you have extern &quot;C&quot; { ... }; . Not only would it allow you to have optimizations outside of the block, it would also force the compiler to ensure that a given block of code is always constant-time (as a security check done by the compiler).</div><br/><div id="41149976" class="c"><input type="checkbox" id="c-41149976" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148793">parent</a><span>|</span><a href="#41150801">next</a><span>|</span><label class="collapse" for="c-41149976">[-]</label><label class="expand" for="c-41149976">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Perhaps the solution is also to reign in the language standard to support stricter use cases. </i><p>Here&#x27;s a nine-year-old comment from the author asking for exactly that:<p><a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;boring-crypto&#x2F;c&#x2F;48qa1kWignU&#x2F;m&#x2F;o8GGp2K1DAAJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;boring-crypto&#x2F;c&#x2F;48qa1kWignU&#x2F;m&#x2F;o8...</a></div><br/></div></div></div></div></div></div><div id="41150801" class="c"><input type="checkbox" id="c-41150801" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41147014">parent</a><span>|</span><a href="#41148648">prev</a><span>|</span><a href="#41147321">next</a><span>|</span><label class="collapse" for="c-41150801">[-]</label><label class="expand" for="c-41150801">[4 more]</label></div><br/><div class="children"><div class="content"><i>Calling the compiler buggy for not doing what you want when you commit Undefined Behavior is like calling dd buggy for destroying your data when you call it with the wrong arguments.</i><p>No, it&#x27;s like calling dd buggy for deliberately zeroing all your drives when you call it with no arguments.<p>How did we let pedantic brainless &quot;but muh holy standards!!!1&quot; religious brigading triumph over common sense?<p>The standards left things undefined in the hopes that the language would be more widely applicable and implementers would give those areas thought themselves and decide the right thing. Not so that compiler writers can become adversarial smartasses. It even suggests that &quot;behaving in a manner characteristic of the environment&quot; is a possible outcome of UB, which is what &quot;the spirit of C&quot; is all about.<p>In my observations this gross exploitation of UB started with the FOSS compilers, GCC and Clang being the notable examples. MSVC or ICC didn&#x27;t need to be so crazy, and yet they were very competitive, so I don&#x27;t believe claims that UB is necessary for optimisation.<p>The good thing about FOSS is that those in power can easily be changed. Perhaps it&#x27;s time to fork, fix, and fight back.</div><br/><div id="41151266" class="c"><input type="checkbox" id="c-41151266" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150801">parent</a><span>|</span><a href="#41150835">next</a><span>|</span><label class="collapse" for="c-41151266">[-]</label><label class="expand" for="c-41151266">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The good thing about FOSS is that those in power can easily be changed. Perhaps it&#x27;s time to fork, fix, and fight back.<p>Huzzah! Lead on, then.</div><br/><div id="41152022" class="c"><input type="checkbox" id="c-41152022" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41151266">parent</a><span>|</span><a href="#41150835">next</a><span>|</span><label class="collapse" for="c-41152022">[-]</label><label class="expand" for="c-41152022">[1 more]</label></div><br/><div class="children"><div class="content">I do not think there is a reason to fork. Just contribute. I found GCC community very welcoming. But maybe not  come in with an  &quot;I need to take back the compiler from evil compiler writers&quot; attitude.</div><br/></div></div></div></div><div id="41150835" class="c"><input type="checkbox" id="c-41150835" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150801">parent</a><span>|</span><a href="#41151266">prev</a><span>|</span><a href="#41147321">next</a><span>|</span><label class="collapse" for="c-41150835">[-]</label><label class="expand" for="c-41150835">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The standards left things undefined in the hopes that the language would be more widely applicable and implementers would give those areas thought themselves and decide the right thing.<p>That sounds like implementation-defined behavior, not undefined behavior.</div><br/></div></div></div></div><div id="41147321" class="c"><input type="checkbox" id="c-41147321" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#41147014">parent</a><span>|</span><a href="#41150801">prev</a><span>|</span><a href="#41148775">next</a><span>|</span><label class="collapse" for="c-41147321">[-]</label><label class="expand" for="c-41147321">[32 more]</label></div><br/><div class="children"><div class="content">Optimizing compilers that don&#x27;t allow disabling all optimizations makes it impossible to write secure code with them. Must do it with assembly.</div><br/><div id="41147714" class="c"><input type="checkbox" id="c-41147714" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147321">parent</a><span>|</span><a href="#41147525">next</a><span>|</span><label class="collapse" for="c-41147714">[-]</label><label class="expand" for="c-41147714">[7 more]</label></div><br/><div class="children"><div class="content">Disabling all optimizations isn&#x27;t even enough- fundamentally what you need is a much narrower specification for how the source language maps to its output. Even -O0 doesn&#x27;t give you that, and in fact will often be counterproductive (e.g. you&#x27;ll get branches in places that the optimizer would have removed them).<p>The problem with this is that no general purpose compiler wants to tie its own hands behind its back in this way, for the benefit of one narrow use case. It&#x27;s not just that it would cost performance for everyone else, but also that it requires a totally different approach to specification and backwards compatibility, not to mention deep changes to compiler architecture.<p>You almost may as well just design a new language, at that point.</div><br/><div id="41147953" class="c"><input type="checkbox" id="c-41147953" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147714">parent</a><span>|</span><a href="#41147525">next</a><span>|</span><label class="collapse" for="c-41147953">[-]</label><label class="expand" for="c-41147953">[6 more]</label></div><br/><div class="children"><div class="content">&gt; You almost may as well just design a new language, at that point.<p>Forget “almost”.<p>Go compile this C code:<p><pre><code>    void foo(int *ptr)
    {
        free(ptr);
        *ptr = 42;
    }
</code></pre>
This is UB. And it has nothing whatsoever to do with optimizations — any sensible translation to machine code is a use-after-free, and an attacker can probably find a way to exploit that machine code to run arbitrary code and format your disk.<p>If you don’t like this, use a language without UB.<p>But djb wants something different, I think: a way to tell the compiler not to introduce timing dependencies on certain values. This is a nice idea, but it needs hardware support!  Your CPU may well implement ALU instructions with data-dependent timing. Intel, for example, reserves the right to do this unless you set an MSR to tell it not to.  And you cannot set that MSR from user code, so what exactly is a compiler supposed to do?<p><a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;software-security-guidance&#x2F;best-practices&#x2F;data-operand-independent-timing-isa-guidance.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a></div><br/><div id="41150148" class="c"><input type="checkbox" id="c-41150148" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147953">parent</a><span>|</span><a href="#41148098">next</a><span>|</span><label class="collapse" for="c-41150148">[-]</label><label class="expand" for="c-41150148">[3 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t just UB to dereference `ptr` after `free(ptr)` – it is UB to do anything with its value whatsoever. For example, this is UB:<p><pre><code>    void foo(int *ptr)
    {
        assert(ptr != NULL);
        free(ptr);
        assert(ptr != NULL);
    }
</code></pre>
Why is that? Well, I think because the C standard authors wanted to support the language being used on platforms with &quot;fat pointers&quot;, in which a pointer is not just a memory address, but some kind of complex structure incorporating flags and capabilities (e.g. IBM System&#x2F;38 and AS&#x2F;400; Burroughs Large Systems; Intel iAPX 432, BiiN and i960 extended architecture; CHERI and ARM Morello). And, on such a system, they wanted to permit implementors to make `free()` a &quot;pass-by-reference&quot; function, so it would actually modify the value of its argument. (C natively doesn&#x27;t have pass-by-reference, unlike C++, but there is nothing stopping a compiler adding it as an extension, then using it to implement `free()`.)<p>See this discussion of the topic from 8 years back: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11235385">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11235385</a><p>&gt; And you cannot set that MSR from user code, so what exactly is a compiler supposed to do?<p>Set a flag in the executable which requires that MSR to be enabled. Then the OS will set the MSR when it loads the executable, or refuse to load it if it won&#x27;t.<p>Another option would be for the OS to expose a user space API to read that MSR. And then the compiler emits a check at the start of security-sensitive code to call that API and abort if the MSR doesn&#x27;t have the required value. Or maybe even, the OS could let you turn the MSR on&#x2F;off on a per-thread basis, and just set it during security-sensitive processing.<p>Obviously, all these approaches require cooperation with the OS vendor, but often the OS vendor and compiler vendor is the same vendor (e.g. Microsoft)–and even when that isn&#x27;t true, compiler and kernel teams often work closely together.</div><br/><div id="41150258" class="c"><input type="checkbox" id="c-41150258" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150148">parent</a><span>|</span><a href="#41148098">next</a><span>|</span><label class="collapse" for="c-41150258">[-]</label><label class="expand" for="c-41150258">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Set a flag in the executable which requires that MSR to be enabled. Then the OS will set the MSR when it loads the executable, or refuse to load it if it won&#x27;t.<p>gcc did approximately this for decades with -ffast-math. It was an unmitigated disaster. No thanks. (For flavor, consider what -lssl would do.  Or dlopen.)<p>&gt; Another option would be for the OS to expose a user space API to read that MSR. And then the compiler emits a check at the start of security-sensitive code to call that API and abort if the MSR doesn&#x27;t have the required value.<p>How does the compiler know where the sensitive code starts and ends?  Maybe it knows that certain basic blocks are sensitive, but it’s a whole extra control flow analysis to find beginning and ends.<p>And making this OS dependent means that compilers need to be more OS dependent for a feature that’s part of the ISA, not the OS.  Ick.<p>Or maybe even, the OS could let you turn the MSR on&#x2F;off on a per-thread basis, and just set it during security-sensitive processing.</div><br/><div id="41151618" class="c"><input type="checkbox" id="c-41151618" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150258">parent</a><span>|</span><a href="#41148098">next</a><span>|</span><label class="collapse" for="c-41151618">[-]</label><label class="expand" for="c-41151618">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How does the compiler know where the sensitive code starts and ends?<p>Put an attribute on the function. In C23, something like `[[no_data_dependent_timing]]` (or `__attribute__((no_data_dependent_timing))` using pre-C23 GNU extension)<p>&gt; And making this OS dependent means that compilers need to be more OS dependent for a feature that’s part of the ISA, not the OS. Ick.<p>There are lots of unused bits in RFLAGS, I don&#x27;t know why Intel didn&#x27;t use one of those, instead of an MSR. (The whole upper 32 bits of RFLAGS is unused – if Intel and AMD split it evenly between them, that would be 16 bits each.) Assuming the OS saves&#x2F;restores the whole of RFLAGS on context switch, it wouldn&#x27;t even need any change to the OS. CPUID could tell you whether this additional RFLAGS bit was supported or not. Maybe have an MSR which controls whether the feature is enabled or not, so the OS can turn it off if necessary. Maybe even default to having it off, so it isn&#x27;t visible in CPUID until it is enabled by the OS via MSR – to cover the risk that maybe the OS context switching code can&#x27;t handle a previously undefined bit in RFLAGS being non-zero.</div><br/></div></div></div></div></div></div><div id="41148098" class="c"><input type="checkbox" id="c-41148098" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147953">parent</a><span>|</span><a href="#41150148">prev</a><span>|</span><a href="#41147525">next</a><span>|</span><label class="collapse" for="c-41148098">[-]</label><label class="expand" for="c-41148098">[2 more]</label></div><br/><div class="children"><div class="content">I am not talking about UB at all. I am talking about the same constant-time stuff that djb&#x27;s post is talking about.</div><br/><div id="41149315" class="c"><input type="checkbox" id="c-41149315" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148098">parent</a><span>|</span><a href="#41147525">next</a><span>|</span><label class="collapse" for="c-41149315">[-]</label><label class="expand" for="c-41149315">[1 more]</label></div><br/><div class="children"><div class="content">Execution time is not considered Observable Behavior in the C standard. It&#x27;s entirely outside the semantics of the language. It is Undefined Behavior, though not UB that necessarily invalidates the program&#x27;s other semantics the way a use-after-free would.</div><br/></div></div></div></div></div></div></div></div><div id="41147525" class="c"><input type="checkbox" id="c-41147525" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147321">parent</a><span>|</span><a href="#41147714">prev</a><span>|</span><a href="#41147614">next</a><span>|</span><label class="collapse" for="c-41147525">[-]</label><label class="expand" for="c-41147525">[5 more]</label></div><br/><div class="children"><div class="content">clang::optnone</div><br/><div id="41147588" class="c"><input type="checkbox" id="c-41147588" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147525">parent</a><span>|</span><a href="#41147614">next</a><span>|</span><label class="collapse" for="c-41147588">[-]</label><label class="expand" for="c-41147588">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Optimizing compilers that don&#x27;t allow  disabling __all__ optimizations&quot;</div><br/><div id="41148250" class="c"><input type="checkbox" id="c-41148250" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147588">parent</a><span>|</span><a href="#41147775">next</a><span>|</span><label class="collapse" for="c-41148250">[-]</label><label class="expand" for="c-41148250">[2 more]</label></div><br/><div class="children"><div class="content">It’s not well-defined what counts as an optimization. For example, should every single source-level read access of a memory location go through all cache levels down to main memory, instead of, for example, caching values in registers? That would be awfully slow. But that question is one reason for UB.</div><br/><div id="41149054" class="c"><input type="checkbox" id="c-41149054" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148250">parent</a><span>|</span><a href="#41147775">next</a><span>|</span><label class="collapse" for="c-41149054">[-]</label><label class="expand" for="c-41149054">[1 more]</label></div><br/><div class="children"><div class="content">Or writing code that relies on inlining and&#x2F;or tail call optimization to successfully run at all without running out of stack... We&#x27;ve got some code that doesn&#x27;t run if compiled O0 due to that.</div><br/></div></div></div></div><div id="41147775" class="c"><input type="checkbox" id="c-41147775" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147588">parent</a><span>|</span><a href="#41148250">prev</a><span>|</span><a href="#41147614">next</a><span>|</span><label class="collapse" for="c-41147775">[-]</label><label class="expand" for="c-41147775">[1 more]</label></div><br/><div class="children"><div class="content">do these exist? who&#x27;s using them?</div><br/></div></div></div></div></div></div><div id="41147614" class="c"><input type="checkbox" id="c-41147614" checked=""/><div class="controls bullet"><span class="by">cmeacham98</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147321">parent</a><span>|</span><a href="#41147525">prev</a><span>|</span><a href="#41147675">next</a><span>|</span><label class="collapse" for="c-41147614">[-]</label><label class="expand" for="c-41147614">[8 more]</label></div><br/><div class="children"><div class="content">If your &quot;secure&quot; code is not secure because of a compiler optimization it is fundamentally incorrect and broken.</div><br/><div id="41147951" class="c"><input type="checkbox" id="c-41147951" checked=""/><div class="controls bullet"><span class="by">hedgehog</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147614">parent</a><span>|</span><a href="#41147983">next</a><span>|</span><label class="collapse" for="c-41147951">[-]</label><label class="expand" for="c-41147951">[1 more]</label></div><br/><div class="children"><div class="content">There is a fundamental difference of priorities between the two worlds. For most general application code any optimization is fine as long as the output is correct. In security critical code information leakage from execution time and resource usage on the chip matters but that essentially means you need to get away from data-dependent memory access patterns and flow control.</div><br/></div></div><div id="41147983" class="c"><input type="checkbox" id="c-41147983" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147614">parent</a><span>|</span><a href="#41147951">prev</a><span>|</span><a href="#41148916">next</a><span>|</span><label class="collapse" for="c-41147983">[-]</label><label class="expand" for="c-41147983">[2 more]</label></div><br/><div class="children"><div class="content">The problem is that preventing timing attacks often means you have to implement something in constant time. And most language specifications and implementations don&#x27;t give you any guarantees that any operations hapen in constant time and can&#x27;t be optimized.<p>So the only possible way to ensure things like string comparison don&#x27;t have data-dependent timing is often to implement it in assembly, which is not great.<p>What we really need is intrinsics that are guaranteed to have the desired timing properties , and&#x2F;or a way to disable optimization, or at least certain kinds of optimization for an area of code.</div><br/><div id="41148110" class="c"><input type="checkbox" id="c-41148110" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147983">parent</a><span>|</span><a href="#41148916">next</a><span>|</span><label class="collapse" for="c-41148110">[-]</label><label class="expand" for="c-41148110">[1 more]</label></div><br/><div class="children"><div class="content">Intrinsics which do the right thing seems like so obviously the correct answer to me that I&#x27;ve always been confused about why the discussion is always about disabling optimizations. Even in the absence of compiler optimizations (which is not even an entirely meaningful concept), writing C code which you hope the compiler will decide to translate into the exact assembly you had in mind is just a very brittle way to write software. If you need the program to have very specific behavior which the language doesn&#x27;t give you the tools to express, you should be asking for those tools to be added to the language, not complaining about how your attempts at tricking the compiler into the thing you want keep breaking.</div><br/></div></div></div></div><div id="41148916" class="c"><input type="checkbox" id="c-41148916" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147614">parent</a><span>|</span><a href="#41147983">prev</a><span>|</span><a href="#41147751">next</a><span>|</span><label class="collapse" for="c-41148916">[-]</label><label class="expand" for="c-41148916">[2 more]</label></div><br/><div class="children"><div class="content">The article explains why this is not as simple as that, especially in the case of timing attacks. Here it&#x27;s not just the end-result that matters, but <i>how</i> it&#x27;s done that matters. If any code can be change to anything else that gives the same results, then this becomes quite hard.<p>Absolutist statements such as this may give you a glowing sense of superiority and cleverness, but they contribute nothing and are not as clever as you think.</div><br/><div id="41149271" class="c"><input type="checkbox" id="c-41149271" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148916">parent</a><span>|</span><a href="#41147751">next</a><span>|</span><label class="collapse" for="c-41149271">[-]</label><label class="expand" for="c-41149271">[1 more]</label></div><br/><div class="children"><div class="content">The article describes why you can’t write code which is resistant to timing attacks in portable C, but then concludes that actually the code he wrote is correct and it’s the compiler’s fault it didn’t work. It’s <i>inconvenient</i> that anything which cares about timing attacks cannot be securely written in C, but that doesn’t make the code not fundamentally incorrect and broken.</div><br/></div></div></div></div><div id="41147751" class="c"><input type="checkbox" id="c-41147751" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147614">parent</a><span>|</span><a href="#41148916">prev</a><span>|</span><a href="#41147675">next</a><span>|</span><label class="collapse" for="c-41147751">[-]</label><label class="expand" for="c-41147751">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s secure code we use.<p>I&#x27;m sure you know who DJB is.</div><br/><div id="41148093" class="c"><input type="checkbox" id="c-41148093" checked=""/><div class="controls bullet"><span class="by">jjuhl</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147751">parent</a><span>|</span><a href="#41147675">next</a><span>|</span><label class="collapse" for="c-41148093">[-]</label><label class="expand" for="c-41148093">[1 more]</label></div><br/><div class="children"><div class="content">Why is knowing who the author is relevant? Either what he posts is correct or it is not, who the person is is irrelevant.</div><br/></div></div></div></div></div></div><div id="41147675" class="c"><input type="checkbox" id="c-41147675" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147321">parent</a><span>|</span><a href="#41147614">prev</a><span>|</span><a href="#41148775">next</a><span>|</span><label class="collapse" for="c-41147675">[-]</label><label class="expand" for="c-41147675">[11 more]</label></div><br/><div class="children"><div class="content">If you have ub then you have a bug and there is some system that will show it. It isn&#x27;t hard to write code without ub.</div><br/><div id="41147702" class="c"><input type="checkbox" id="c-41147702" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147675">parent</a><span>|</span><a href="#41149143">next</a><span>|</span><label class="collapse" for="c-41147702">[-]</label><label class="expand" for="c-41147702">[7 more]</label></div><br/><div class="children"><div class="content">It is, in fact, pretty hard as evidenced by how often programmers fail at it. The macho attitude of &quot;it&#x27;s not hard, just write good code&quot; is divorced from observable reality.</div><br/><div id="41148555" class="c"><input type="checkbox" id="c-41148555" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147702">parent</a><span>|</span><a href="#41147807">next</a><span>|</span><label class="collapse" for="c-41148555">[-]</label><label class="expand" for="c-41148555">[3 more]</label></div><br/><div class="children"><div class="content">Staying under the speed limit is, in fact, pretty hard as evidenced by how often drivers fail at it.</div><br/><div id="41149035" class="c"><input type="checkbox" id="c-41149035" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148555">parent</a><span>|</span><a href="#41147807">next</a><span>|</span><label class="collapse" for="c-41149035">[-]</label><label class="expand" for="c-41149035">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more complex than that for the example of car speed limits. Depending on where you live, the law also says that driving <i>too slow</i> is illegal because it creates an unsafe environment by forcing other drivers on i.e. the freeway to pass you.<p>But yeah, seeing how virtually everyone on every road is constantly speeding, that doesn&#x27;t give me a lot of faith in my fellow programmers&#x27; ability to avoid UB...</div><br/><div id="41150553" class="c"><input type="checkbox" id="c-41150553" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41149035">parent</a><span>|</span><a href="#41147807">next</a><span>|</span><label class="collapse" for="c-41150553">[-]</label><label class="expand" for="c-41150553">[1 more]</label></div><br/><div class="children"><div class="content">Some jurisdictions also set the speed limit at, e.g., the 85th percentile of drivers&#x27; speed (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Speed_limit#Method" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Speed_limit#Method</a>) so some drivers are <i>always</i> going to be speeding.<p>(I&#x27;m one of those speeders, too; I drive with a mentality of safety &gt; following the strict letter of the law; I&#x27;ll prefer speed of traffic if that&#x27;s safer than strict adherence to the limit. That said, I know not all of my peers have the same priorities on the road, too.)</div><br/></div></div></div></div></div></div><div id="41147807" class="c"><input type="checkbox" id="c-41147807" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147702">parent</a><span>|</span><a href="#41148555">prev</a><span>|</span><a href="#41149143">next</a><span>|</span><label class="collapse" for="c-41147807">[-]</label><label class="expand" for="c-41147807">[3 more]</label></div><br/><div class="children"><div class="content">People write buffer overflows because and memory leaks they are not coreful. The rest of ub are things I have never seen despite running sanitizers and a large codebase.</div><br/><div id="41148362" class="c"><input type="checkbox" id="c-41148362" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147807">parent</a><span>|</span><a href="#41149143">next</a><span>|</span><label class="collapse" for="c-41148362">[-]</label><label class="expand" for="c-41148362">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps you’re not looking all that hard.</div><br/><div id="41150051" class="c"><input type="checkbox" id="c-41150051" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41148362">parent</a><span>|</span><a href="#41149143">next</a><span>|</span><label class="collapse" for="c-41150051">[-]</label><label class="expand" for="c-41150051">[1 more]</label></div><br/><div class="children"><div class="content">Sanitizers are very good at finding ub.</div><br/></div></div></div></div></div></div></div></div><div id="41149143" class="c"><input type="checkbox" id="c-41149143" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147675">parent</a><span>|</span><a href="#41147702">prev</a><span>|</span><a href="#41150031">next</a><span>|</span><label class="collapse" for="c-41149143">[-]</label><label class="expand" for="c-41149143">[1 more]</label></div><br/><div class="children"><div class="content">Only if developers act as grown ups and use all static analysers they can get hold of, instead of acting as they know better.<p>The tone of my answer is a reflection of what most surveys state, related to the actual use of such tooling.</div><br/></div></div><div id="41150031" class="c"><input type="checkbox" id="c-41150031" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41147675">parent</a><span>|</span><a href="#41149143">prev</a><span>|</span><a href="#41148775">next</a><span>|</span><label class="collapse" for="c-41150031">[-]</label><label class="expand" for="c-41150031">[2 more]</label></div><br/><div class="children"><div class="content">Do you know what UBSAN is? Have you used it?</div><br/><div id="41150056" class="c"><input type="checkbox" id="c-41150056" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41147014">root</a><span>|</span><a href="#41150031">parent</a><span>|</span><a href="#41148775">next</a><span>|</span><label class="collapse" for="c-41150056">[-]</label><label class="expand" for="c-41150056">[1 more]</label></div><br/><div class="children"><div class="content">yes, my ci system runs it with a comprehensive test suite.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41148775" class="c"><input type="checkbox" id="c-41148775" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41147014">prev</a><span>|</span><a href="#41147711">next</a><span>|</span><label class="collapse" for="c-41148775">[-]</label><label class="expand" for="c-41148775">[8 more]</label></div><br/><div class="children"><div class="content">I like Bernstein but sometimes he flies off the handle in the wrong direction.  This is a good example, which he even half-heartedly acknowledges at the end!<p>A big chunk of the essay is about a side point — how good the gains of optimization might be, which, even with data, would be a use-case dependent decision.<p>But the bulk of his complaint is that C compilers fail to take into account semantics <i>that cannot be expressed in the language</i>.  Wow, shocker!<p>At the very end he says “use a language which can express the needed semantics”.  The entire essay could have been replaced with that sentence.</div><br/><div id="41148874" class="c"><input type="checkbox" id="c-41148874" checked=""/><div class="controls bullet"><span class="by">bhk</span><span>|</span><a href="#41148775">parent</a><span>|</span><a href="#41148799">next</a><span>|</span><label class="collapse" for="c-41148874">[-]</label><label class="expand" for="c-41148874">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an important point to be made here: those who define the semantics of C and C++ shovel an unreasonable amount of behavior into the bucket of &quot;undefined behavior&quot;.  Much of this has dubious justifications, while making it more difficult to write correct programs.</div><br/><div id="41148945" class="c"><input type="checkbox" id="c-41148945" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41148775">root</a><span>|</span><a href="#41148874">parent</a><span>|</span><a href="#41148799">next</a><span>|</span><label class="collapse" for="c-41148945">[-]</label><label class="expand" for="c-41148945">[3 more]</label></div><br/><div class="children"><div class="content">To be pedantic, I think you&#x27;re speaking about unspecified behavior and implementation defined behavior. Undefined behavior specifically refers to things that have no meaningful semantics, so the compiler assumes it never happens.<p>Unspecified behavior is anything outside the scope of observable behavior for which there are two or more ways the implementation can choose.<p>Since the timing of instructions on machines with speculative execution is not observable behavior in C, anything that impacts it is unspecified.<p>There&#x27;s really no way around this, and I disagree that there&#x27;s an &quot;unreasonable&quot; amount of it. Truly the problem is up to the judgement of the compiler developers what choice to make and for users to pick implementations based on those choices, or work around them as needed.</div><br/><div id="41149316" class="c"><input type="checkbox" id="c-41149316" checked=""/><div class="controls bullet"><span class="by">bhk</span><span>|</span><a href="#41148775">root</a><span>|</span><a href="#41148945">parent</a><span>|</span><a href="#41148799">next</a><span>|</span><label class="collapse" for="c-41149316">[-]</label><label class="expand" for="c-41149316">[2 more]</label></div><br/><div class="children"><div class="content">I am referring to <i>undefined</i> behavior.<p>For example, consider the case integer overflow when adding two signed numbers.  C considers this undefined behavior, making the program&#x27;s behavior is undefined.  <i>All</i> bets are off, even if the program never makes use of the resulting value.  C compilers are allowed to assume the overflow can never happen, which in some cases allows them to infer that numbers must fit within certain bounds, which allows them to do things like optimize away bounds checks written by the programmer.<p>A more reasonable language design choice would be to treat this as an operation that produces and unspecified integer result, or an implementation-defined result.<p>Edit:  The following article helps clear up some common confusion about undefined behavior:<p><a href="https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;213" rel="nofollow">https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;213</a><p>Unfortunately this article, like most on the subject,  perpetuates the notion that there are significant performance benefits to treating simple things like integer overflow as UB.  E.g.: &quot;I&#x27;ve heard that certain tight loops speed up by 30%-50% ...&quot;  Where that is true, the compiler could still emit the optimized form of the loop without UB-based inference, <i>but</i> it would simply have to be guarded by a run-time check (outside of the loop) that would fall back to the slower code in the rare occasions when the assumptions do not hold.</div><br/><div id="41150464" class="c"><input type="checkbox" id="c-41150464" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41148775">root</a><span>|</span><a href="#41149316">parent</a><span>|</span><a href="#41148799">next</a><span>|</span><label class="collapse" for="c-41150464">[-]</label><label class="expand" for="c-41150464">[1 more]</label></div><br/><div class="children"><div class="content">It would also be nice if hardware would trap on signed integer overflow.  Of course since the most popular architectures do not, new architectures also do not either.</div><br/></div></div></div></div></div></div></div></div><div id="41148799" class="c"><input type="checkbox" id="c-41148799" checked=""/><div class="controls bullet"><span class="by">quohort</span><span>|</span><a href="#41148775">parent</a><span>|</span><a href="#41148874">prev</a><span>|</span><a href="#41151209">next</a><span>|</span><label class="collapse" for="c-41148799">[-]</label><label class="expand" for="c-41148799">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A big chunk of the essay is about a side point — how good the gains of optimization might be, which, even with data, would be a use-case dependent decision.<p>I think this was useful context, and it was eye-opening to me.</div><br/><div id="41150146" class="c"><input type="checkbox" id="c-41150146" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41148775">root</a><span>|</span><a href="#41148799">parent</a><span>|</span><a href="#41151209">next</a><span>|</span><label class="collapse" for="c-41150146">[-]</label><label class="expand" for="c-41150146">[1 more]</label></div><br/><div class="children"><div class="content">If you were not aware of this then you might reflect on the part of my comment that he doesn’t bring up: how good&#x2F;bad are use-case dependent.  Every program optimizes for a use case, sometimes pessimizing for others (e.g. an n^2 algo that’s worthwhile because it is believed to only be called on tiny vectors).<p>IMHO he was overgenerous on the optimization improvement of compilers.  Often an optimization will make a difference in a tiny fraction of a percent.  The value comes from how often that optimization can be applied, and how lots of optimizations can in aggregate make a bigger improvement just as a sand dune is made of tiny grains of sand.</div><br/></div></div></div></div><div id="41151209" class="c"><input type="checkbox" id="c-41151209" checked=""/><div class="controls bullet"><span class="by">bankcust08385</span><span>|</span><a href="#41148775">parent</a><span>|</span><a href="#41148799">prev</a><span>|</span><a href="#41147711">next</a><span>|</span><label class="collapse" for="c-41151209">[-]</label><label class="expand" for="c-41151209">[1 more]</label></div><br/><div class="children"><div class="content">Yep. DJB fell flat here. There were a lot of elitist religious opinions espoused without evidence.</div><br/></div></div></div></div><div id="41147711" class="c"><input type="checkbox" id="c-41147711" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41148775">prev</a><span>|</span><a href="#41147978">next</a><span>|</span><label class="collapse" for="c-41147711">[-]</label><label class="expand" for="c-41147711">[5 more]</label></div><br/><div class="children"><div class="content">C and C++ are unsuitable for writing algorithms with constant-time guarantees. The standards have little to no notion of real time, and compilers don&#x27;t offer additional guarantees as extensions.<p>But blaming the compiler devs for this is just misguided.</div><br/><div id="41148445" class="c"><input type="checkbox" id="c-41148445" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#41147711">parent</a><span>|</span><a href="#41147978">next</a><span>|</span><label class="collapse" for="c-41148445">[-]</label><label class="expand" for="c-41148445">[4 more]</label></div><br/><div class="children"><div class="content">That was my thought reading this article. If you want to produce machine code that performs operations in constant time regardless of the branch taken, you need to use a language that supports expressing that, which C does not.</div><br/><div id="41148552" class="c"><input type="checkbox" id="c-41148552" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41147711">root</a><span>|</span><a href="#41148445">parent</a><span>|</span><a href="#41147978">next</a><span>|</span><label class="collapse" for="c-41148552">[-]</label><label class="expand" for="c-41148552">[3 more]</label></div><br/><div class="children"><div class="content">Heck, <i>CPUs</i> themselves aren&#x27;t suitable for constant time operations. At any time, some new CPU can be released which changes how quick some operations are.</div><br/><div id="41151623" class="c"><input type="checkbox" id="c-41151623" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41147711">root</a><span>|</span><a href="#41148552">parent</a><span>|</span><a href="#41149091">next</a><span>|</span><label class="collapse" for="c-41151623">[-]</label><label class="expand" for="c-41151623">[1 more]</label></div><br/><div class="children"><div class="content">Not always. At least for RISC-V there is the Zkt extension which guarantees data independent execution time for some instructions. I assume there&#x27;s something similar for ARM and x86.<p>It does pretty much require you to write assembly though. I think it would definitely make sense to have some kind of `[constant_time]` attribute for C++ that instructed the compiler to ensure the code is constant time.</div><br/></div></div><div id="41149091" class="c"><input type="checkbox" id="c-41149091" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#41147711">root</a><span>|</span><a href="#41148552">parent</a><span>|</span><a href="#41151623">prev</a><span>|</span><a href="#41147978">next</a><span>|</span><label class="collapse" for="c-41149091">[-]</label><label class="expand" for="c-41149091">[1 more]</label></div><br/><div class="children"><div class="content">Or microcode updates to existing CPUs!</div><br/></div></div></div></div></div></div></div></div><div id="41147978" class="c"><input type="checkbox" id="c-41147978" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41147711">prev</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41147978">[-]</label><label class="expand" for="c-41147978">[8 more]</label></div><br/><div class="children"><div class="content">It’s worth noting that, on Intel CPUs, neither clang nor anything else can possibly generate correct code, because correct code does not exist in user mode.<p><a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;software-security-guidance&#x2F;best-practices&#x2F;data-operand-independent-timing-isa-guidance.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a><p>Look at DOITM in that document — it is simply impossible for a userspace crypto library to set the required bit.</div><br/><div id="41148056" class="c"><input type="checkbox" id="c-41148056" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#41147978">parent</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41148056">[-]</label><label class="expand" for="c-41148056">[7 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you syscall into the kernel to set the flag, then return back into usermode with it set?</div><br/><div id="41148126" class="c"><input type="checkbox" id="c-41148126" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41147978">root</a><span>|</span><a href="#41148056">parent</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41148126">[-]</label><label class="expand" for="c-41148126">[6 more]</label></div><br/><div class="children"><div class="content">So your compiler is supposed to emit a pair of syscalls each function that does integer math?  Never mind that a pair of syscalls that do WRMSR may well take longer than whatever crypto operation is between them.<p>I have absolutely nothing good to say about Intel’s design here.</div><br/><div id="41149529" class="c"><input type="checkbox" id="c-41149529" checked=""/><div class="controls bullet"><span class="by">pvillano</span><span>|</span><a href="#41147978">root</a><span>|</span><a href="#41148126">parent</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41149529">[-]</label><label class="expand" for="c-41149529">[5 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the alternative?</div><br/><div id="41149695" class="c"><input type="checkbox" id="c-41149695" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41147978">root</a><span>|</span><a href="#41149529">parent</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41149695">[-]</label><label class="expand" for="c-41149695">[4 more]</label></div><br/><div class="children"><div class="content">An instruction prefix that makes instructions constant time. A code segment bit (ugly but would work).  Different instructions. Making constant time the default. A control register that’s a <i>user</i> register.</div><br/><div id="41150085" class="c"><input type="checkbox" id="c-41150085" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#41147978">root</a><span>|</span><a href="#41149695">parent</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41150085">[-]</label><label class="expand" for="c-41150085">[3 more]</label></div><br/><div class="children"><div class="content">since we already have some reasons to sign in an enclave, why not just design a cryptographic processor which is highly unoptimized and highly predictable. since the majority of codes benefit immensely from the optimizations, it doesn&#x27;t seem reasonable to cripple them.</div><br/><div id="41150246" class="c"><input type="checkbox" id="c-41150246" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41147978">root</a><span>|</span><a href="#41150085">parent</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41150246">[-]</label><label class="expand" for="c-41150246">[2 more]</label></div><br/><div class="children"><div class="content">So instead of just doing the rather fast elliptic curve math when getting a TLS connection request by using a standard crypto library, I’m supposed to call out to a cryptographic coprocessor that may or may not even support the operation I need?  Have you seen what an unbelievable mess your average coprocessor is to use, Intel or otherwise.<p>CPUs have done just fine doing constant time math for decades. It’s at best a minor optimization to add data dependence, and Intel already knows (a) how to turn it off and (b) that it’s sometimes necessary to let it be turned off. Why can’t they add a reasonable mechanism to turn them off?</div><br/><div id="41150950" class="c"><input type="checkbox" id="c-41150950" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41147978">root</a><span>|</span><a href="#41150246">parent</a><span>|</span><a href="#41147705">next</a><span>|</span><label class="collapse" for="c-41150950">[-]</label><label class="expand" for="c-41150950">[1 more]</label></div><br/><div class="children"><div class="content">The version of this that I want to see is a CPU that gives you a core that doesn&#x27;t have caches or branch prediction on which you can write custom code without having to worry about timing attacks.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41147705" class="c"><input type="checkbox" id="c-41147705" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41147978">prev</a><span>|</span><a href="#41147425">next</a><span>|</span><label class="collapse" for="c-41147705">[-]</label><label class="expand" for="c-41147705">[31 more]</label></div><br/><div class="children"><div class="content">&gt; [..] whenever possible, compiler writers refuse to take responsibility for the bugs they introduced<p>I have seldomly seen someone discredit their expertise that fast in a blog post. (Especially if you follow the link and realized it&#x27;s just basic fundamental C stuff of UB not meaning it produces an &quot;arbitrary&quot; value.)</div><br/><div id="41147923" class="c"><input type="checkbox" id="c-41147923" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41147705">parent</a><span>|</span><a href="#41148010">next</a><span>|</span><label class="collapse" for="c-41147923">[-]</label><label class="expand" for="c-41147923">[14 more]</label></div><br/><div class="children"><div class="content">No, I think you&#x27;re just speaking past each other here. You&#x27;re using &quot;bug&quot; in reference to the source code. They&#x27;re using &quot;bug&quot; in reference to the generated program. With UB it&#x27;s often the case that the source code is buggy but the generated program is still correct. Later the compiler authors introduce a new optimization that generates a buggy program based on UB in the source code, and the finger-pointing starts.<p>Edit: What nobody likes to admit is that <i>all</i> sides share responsibility to the users here, and that is <i>hard</i> to deal with. People just want a single entity to offload the responsibility to, but reality doesn&#x27;t care. To give an extreme analogy to get the point across: if your battery caught fire just because your CRUD app dereferenced NULL, nobody (well, nobody sane) would point the finger at the app author for forgetting to check for NULL. The compiler, OS, and hardware vendors would be held accountable for their irresponsibly-designed products, &quot;undefined behavior&quot; in the standard be damned. Everyone in the supply chain shares a responsibility to anticipate how their products can be misused and handle them in a reasonable manner. The apportionment of the responsibility depends on the situation and isn&#x27;t something you can just determine by just asking &quot;was this UB in the ISO standard?&quot;</div><br/><div id="41149345" class="c"><input type="checkbox" id="c-41149345" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41147923">parent</a><span>|</span><a href="#41148210">next</a><span>|</span><label class="collapse" for="c-41149345">[-]</label><label class="expand" for="c-41149345">[8 more]</label></div><br/><div class="children"><div class="content">&gt; just speaking past each other here<p>no I&#x27;m not<p>if your program has UB it&#x27;s broken and it doesn&#x27;t matter if it currently happen to work correct under a specific compiler version, it&#x27;s also fully your fault<p>sure there is shared responsibility through the stack, but _one of the most important aspects when you have something like a supply chain is to know who supplies what under which guarantees taking which responsibilities_<p>and for C&#x2F;C++ its clearly communicated that it&#x27;s soly your responsibility to avoid UB  (in the same way that for batteries it&#x27;s the batteries vendors responsibility to produce batteries which can&#x27;t randomly cough on fire and the firmware vendors responsibility for using the battery driver&#x2F;chagrin circuit correctly and your OS responsibility so that a randoms program faulting can&#x27;t affect the firmware etc.)<p>&gt;  be misused and handle them in a reasonable manner<p>For things provided B2B its in general only the case in context of it involving end user, likely accidents and similar.<p>Instead it&#x27;s the responsibility of the supplier to be clear about what can be done with the product and what not and if you do something outside of the spec it&#x27;s your responsibility to continuously make sure it&#x27;s safe (or in general ask the supply for clarifying guarantees wrt. your usage).<p>E.g. if you buy capacitors rate for up to 50C environmental temperature but happen to work for up to 80C then you still can&#x27;t use them for 80C because there is 0% guarantee that even other capacitors from the same batch will also work for 80C. In the same way compilers are only &quot;rate&quot;(1) to behave as expected for programs without UB.<p>If you find it unacceptable because it&#x27;s to easy to end up with accidental UB, then you should do what anyone in a supply chain with a too risky to use component would do:<p>Replace it with something less risky to use.<p>There is a reason the ONCD urged developers to stop using C&#x2F;C++ and similar where viable, because that is pretty much just following standard supply chain management best-practice.<p>(1: just for the sake of wording. Through there are certified, i.e. ~rated, compilers revisions)</div><br/><div id="41150759" class="c"><input type="checkbox" id="c-41150759" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41149345">parent</a><span>|</span><a href="#41148210">next</a><span>|</span><label class="collapse" for="c-41150759">[-]</label><label class="expand" for="c-41150759">[7 more]</label></div><br/><div class="children"><div class="content">&gt;  your program has UB it&#x27;s broken and it doesn&#x27;t matter if it currently happen to work correct under a specific compiler version, it&#x27;s also fully your fault<p>Except that compiler writers essentially decide what&#x27;s UB. Which is a conflict of interest.<p>And they <i>add</i> UB, making previously non-UB code fall under UB. Would you call such code buggy?</div><br/><div id="41150871" class="c"><input type="checkbox" id="c-41150871" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41150759">parent</a><span>|</span><a href="#41148210">next</a><span>|</span><label class="collapse" for="c-41150871">[-]</label><label class="expand" for="c-41150871">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Except that compiler writers essentially decide what&#x27;s UB.<p>No, the C&#x2F;C++ standards specify what is UB. So, as long as you don&#x27;t switch targeted standard versions, the brokenness of your code never changes.<p>Compilers may happen to previously have never made optimizations around some specific UB, but, unless you read in the compiler&#x27;s documentation that it won&#x27;t, code relying on it was always broken. It&#x27;s a bog standard &quot;buggy thing working once doesn&#x27;t mean it&#x27;ll work always&quot;.</div><br/><div id="41150962" class="c"><input type="checkbox" id="c-41150962" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41150871">parent</a><span>|</span><a href="#41148210">next</a><span>|</span><label class="collapse" for="c-41150962">[-]</label><label class="expand" for="c-41150962">[5 more]</label></div><br/><div class="children"><div class="content">&gt; No, the C&#x2F;C++ standards specify what is UB.<p>And the compiler writers have a stranglehold on the standards bodies. They hold more than 50% of the voting power last time I checked.<p>So yeah, compiler writers decide what&#x27;s UB.</div><br/><div id="41151082" class="c"><input type="checkbox" id="c-41151082" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41150962">parent</a><span>|</span><a href="#41148210">next</a><span>|</span><label class="collapse" for="c-41151082">[-]</label><label class="expand" for="c-41151082">[4 more]</label></div><br/><div class="children"><div class="content">The vast majority of UB usually considered problematic has been in the standards for decades, long before compilers took as much advantage of it as they do now (and the reasons for including said UB back then were actual hardware differences, not appeasing compiler developers).<p>Are there even that many UB additions? The only thing I can remember is realloc with size zero going from implementation-defined to undefined in C23.</div><br/><div id="41151095" class="c"><input type="checkbox" id="c-41151095" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41151082">parent</a><span>|</span><a href="#41148210">next</a><span>|</span><label class="collapse" for="c-41151095">[-]</label><label class="expand" for="c-41151095">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but that does not change the fact that compilers writers have control of the standard, have had that control since probably C99, and have introduced new UB along with pushing the 00UB worldview.</div><br/><div id="41151286" class="c"><input type="checkbox" id="c-41151286" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41151095">parent</a><span>|</span><a href="#41151308">next</a><span>|</span><label class="collapse" for="c-41151286">[-]</label><label class="expand" for="c-41151286">[1 more]</label></div><br/><div class="children"><div class="content">What introduced UB are you thinking of? I&#x27;ll admit I don&#x27;t know how much has changed, but the usually-complained-about things (signed overflow, null pointer dereferencing, strict aliasing) are clearly listed as UB in some C89 draft I found.<p>C23&#x27;s introduced stdc_trailing_zeros &amp; co don&#x27;t even UB on 0, even though baseline x86-64&#x27;s equivalent instructions are literally specified to leave their destination undefined on such!<p>00UB is something one can argue about, but I can&#x27;t think of a meaningful way to define UB that doesn&#x27;t impose significant restrictions on even basic compilers, without precisely defining how UB-result values are allowed to propagate.<p>e.g. one might expect that &#x27;someFloat == (float)(int8_t)someFloat&#x27; give false on an input of 1000, but guaranteeing that takes intentional effort - namely, on hardware whose int↔float conversions only operate on ≥32-bit integers (i.e. everything - x86, ARM, RISC-V), there&#x27;d need to be an explicit 8-to-32-bit sign-extend, and the most basic compiler just emitting the two f32→i32 &amp; i32→f32 instructions would fail (but is imo pretty clearly within &quot;ignoring the situation completely with unpredictable results&quot; that the C89 draft contains). Sure it doesn&#x27;t summon cthulhu, but it&#x27;ll quite likely break things very badly anyway. (whether it&#x27;d be useful to not have UB here in the first place is a separate question)<p>Even for &#x27;x+100 &lt; x&#x27; one can imagine a similar case where the native addition &amp; comparison instructions operate on inputs wider than int; using such for assuming-no-signed-wrap addition always works, but would mean that the comparison wouldn&#x27;t detect overflow. Though here x86-64, aarch64, and RISC-V all do provide instructions for 32-bit arith, matching their int. This would be a bigger thing if it were possible to have sub-int-sized arith.</div><br/></div></div><div id="41151308" class="c"><input type="checkbox" id="c-41151308" checked=""/><div class="controls bullet"><span class="by">pertymcpert</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41151095">parent</a><span>|</span><a href="#41151286">prev</a><span>|</span><a href="#41148210">next</a><span>|</span><label class="collapse" for="c-41151308">[-]</label><label class="expand" for="c-41151308">[1 more]</label></div><br/><div class="children"><div class="content">Which UB upsets you? Can you be specific so we can revert it?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41148210" class="c"><input type="checkbox" id="c-41148210" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41147923">parent</a><span>|</span><a href="#41149345">prev</a><span>|</span><a href="#41148010">next</a><span>|</span><label class="collapse" for="c-41148210">[-]</label><label class="expand" for="c-41148210">[5 more]</label></div><br/><div class="children"><div class="content">&gt; if your battery caught fire just because your CRUD app dereferenced NULL, nobody (well, nobody sane) would point the finger at the app author for forgetting to check for NULL.<p>I think pretty much anyone sane would and would be right to do so. Incorrect code is, well, incorrect and safety critical code shouldn’t use UB. Plus, it’s your duty as a software producer to use an appropriate toolchain and validate the application produced. You can’t offload the responsibility of your failure to do so to a third party (doesn’t stop people for trying all the time with either their toolchains or a library they use but that shouldn’t be tolerated and be pointed as the failure to properly test and validate it is).<p>I would be ashamed if fingers were pointed towards a compiler provider there unless said provider certified that its compiler wouldn’t do that and somehow lied (but even then, still a testing failure on the software producer part).</div><br/><div id="41148232" class="c"><input type="checkbox" id="c-41148232" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148210">parent</a><span>|</span><a href="#41148010">next</a><span>|</span><label class="collapse" for="c-41148232">[-]</label><label class="expand" for="c-41148232">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I think pretty much anyone sane would and would be right to do so. Incorrect code is, well, incorrect and safety critical code shouldn’t use UB<p>You missed the whole point of the example. I gave CRUD app as an example for a reason. We weren&#x27;t talking safety-critical code like battery firmware here.</div><br/><div id="41148296" class="c"><input type="checkbox" id="c-41148296" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148232">parent</a><span>|</span><a href="#41148010">next</a><span>|</span><label class="collapse" for="c-41148296">[-]</label><label class="expand" for="c-41148296">[3 more]</label></div><br/><div class="children"><div class="content">Because your exemple isn’t credible. But even then I don’t think I missed the point, no. You are responsible for what your application does (be it a CRUD app or any others). If it causes damage because you fail to test properly, it is <i>your</i> responsibility. The fact that so many programmers fail to grasp this - which is taken as evidence in pretty much any other domain - is why the current quality of the average piece of software is so low.<p>Anyway, I would like to know by which magic you think a CRUD app could burn a battery? There is a whole stack of systems to prevent that from ever happening.</div><br/><div id="41148497" class="c"><input type="checkbox" id="c-41148497" checked=""/><div class="controls bullet"><span class="by">pritambaral</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148296">parent</a><span>|</span><a href="#41148010">next</a><span>|</span><label class="collapse" for="c-41148497">[-]</label><label class="expand" for="c-41148497">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There is a whole stack of systems to prevent that from ever happening.<p>You&#x27;ve almost got the point your parent is trying to make. That the supply chain shares this responsibility, as they said.<p>&gt; I would like to know by which magic you think a CRUD app could burn a battery?<p>I don&#x27;t know about batteries, but there was a time when Dell refused to honour their warranty on their Inspiron series laptops if they found VLC to be installed. Their (utterly stupid) reasoning? That VLC allows the user to raise the (software) volume higher than 100%. It was their own damn fault for using poor quality speakers and not limiting allowable current through them in their (software or hardware) drivers.</div><br/><div id="41149238" class="c"><input type="checkbox" id="c-41149238" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148497">parent</a><span>|</span><a href="#41148010">next</a><span>|</span><label class="collapse" for="c-41149238">[-]</label><label class="expand" for="c-41149238">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;ve almost got the point your parent is trying to make. That the supply chain shares this responsibility, as they said.<p>Deeply disagree. Failsafe doesn’t magically remove your responsibility.<p>I’m so glad I started my career in a safety critical environment with other engineers working on the non software part. The amount of software people who think they can somehow absolve themselves of all responsibility for shipping garbage still shock me after 15 years in the field.<p>&gt; It was their own damn fault for using poor quality speakers<p>Yes, exactly, I’m glad to see we actually agree. It’s Dell’s fault - not the speaker manufacturer’s fault, not the subcontractor who designed the sound part’s fault - Dell’s fault because they are the one who actually shipped the final product.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41148010" class="c"><input type="checkbox" id="c-41148010" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#41147705">parent</a><span>|</span><a href="#41147923">prev</a><span>|</span><a href="#41148422">next</a><span>|</span><label class="collapse" for="c-41148010">[-]</label><label class="expand" for="c-41148010">[15 more]</label></div><br/><div class="children"><div class="content">I think the author knows very well what UB is and means. But he’s thinking critically about the whole system.<p>UB is meant to add value. It’s possible to write a language without it, so why do we have any UB at all? We do because of portability and because it gives flexibility to compilers writers.<p>The post is all about whether this flexibility is worth it when compared with the difficulty of writing programs without UB.<p>The author makes the case that (1) there seem to be more money lost on bugs than money saved on faster bytecode and (2) there’s an unwillingness to do something about it because compiler writers have a lot of weight when it comes to what goes into language standards.</div><br/><div id="41148205" class="c"><input type="checkbox" id="c-41148205" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148010">parent</a><span>|</span><a href="#41148154">next</a><span>|</span><label class="collapse" for="c-41148205">[-]</label><label class="expand" for="c-41148205">[11 more]</label></div><br/><div class="children"><div class="content">Even stipulating that part of the argument, the author then goes on a tear about optimizations breaking constant-time evaluation, which doesn’t have anything to do with UB.<p>The real argument seems to be that C compilers had it right when they really did embody C as portable assembly, and everything that’s made that mapping less predictable has been a regression.</div><br/><div id="41148558" class="c"><input type="checkbox" id="c-41148558" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148205">parent</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41148558">[-]</label><label class="expand" for="c-41148558">[9 more]</label></div><br/><div class="children"><div class="content">But C never had been portable assembly.<p>Which I think is somewhat the core of the problem. People treating things in C in ways they just are not. Weather that is C is portable assembly or C the &quot;it&#x27;s just bit&#x27;s in memory&quot; view of things (which often is double wrong ignoring stuff like hardware caching). Or stuff like writing const time code based on assuming that the compiler probably, hopefully can&#x27;t figure out that it can optimize something.<p>&gt; The real argument seems to be that C compilers had it right when they really did embody C as portable assembly<p>But why would you use such a C. Such a C would be slow compared to it&#x27;s competition while still prone to problematic bugs. At the same time often people seem to forgot that part of UB is rooted in different hardware doing different things including having behavior in some cases which isn&#x27;t just a register&#x2F;mem address having an &quot;arbitrary value&quot; but more similar to C UB (like e.g. when it involves CPU caches).</div><br/><div id="41148965" class="c"><input type="checkbox" id="c-41148965" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148558">parent</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41148965">[-]</label><label class="expand" for="c-41148965">[8 more]</label></div><br/><div class="children"><div class="content">&gt; But C never had been portable assembly.<p>The ANSI C standards committee disagrees with you.<p>&quot;Committee did not want to force programmers into writing portably, to preclude the use of C as a “high-level assembler:”<p><a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG14&#x2F;www&#x2F;docs&#x2F;n897.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG14&#x2F;www&#x2F;docs&#x2F;n897.pdf</a><p>p 2, line 39. (p10 of the PDF)<p>&quot;C code can be portable. &quot;<p>line 30</div><br/><div id="41150160" class="c"><input type="checkbox" id="c-41150160" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148965">parent</a><span>|</span><a href="#41149184">next</a><span>|</span><label class="collapse" for="c-41150160">[-]</label><label class="expand" for="c-41150160">[1 more]</label></div><br/><div class="children"><div class="content">The full quote is:<p>&gt; Although it strove to give programmers the opportunity to write truly portable programs, the C89 Committee did not want to force programmers into writing portably, to preclude the use of C as a “high-level assembler:” the ability to write machine-specific code is one of the strengths of C. It is this principle which largely motivates drawing the distinction between strictly conforming program and conforming program (§4).<p>This doesn&#x27;t say that C is a high-level assembly.<p>It just says that the committee doesn&#x27;t (at that point in time) wants to force the usage of &quot;portable&quot; C as a mean to prevent the usage of C as high-level assembler. But just because some people  use something as high level assembler doesn&#x27;t mean it is high level assembly (like I did use a spoon as a fork once, it&#x27;s still a spoon).<p>Furthermore the fact that they explicitly mention forcing portable C with the terms &quot;to preclude&quot; and not &quot;to break compatibility&quot; or similar I think says a lot about weather or not the committee thought of C as high level assembly.<p>Most importantly the quote is about the process of making the first C standard which had to make sure to ease the transition from various non standardized C dialects to &quot;standard C&quot; and I&#x27;m pretty sure that through the history there had been C dialects&#x2F;compiler implementations which approached C as high level assembly, but C as in &quot;standard C&quot; is not that.</div><br/></div></div><div id="41149184" class="c"><input type="checkbox" id="c-41149184" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148965">parent</a><span>|</span><a href="#41150160">prev</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41149184">[-]</label><label class="expand" for="c-41149184">[6 more]</label></div><br/><div class="children"><div class="content">Back in 1989, when C abstract machine semantics were closer to being a portable macro processor, and stuff like the <i>register</i> keyword was actually something compilers cared about.</div><br/><div id="41149346" class="c"><input type="checkbox" id="c-41149346" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41149184">parent</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41149346">[-]</label><label class="expand" for="c-41149346">[5 more]</label></div><br/><div class="children"><div class="content">And <i>even then</i> there was no notion of constant-time being observable behavior to the compiler. You cannot write reliably constant-time code in C because execution time is not a property the C language includes in its model of computation.</div><br/><div id="41149607" class="c"><input type="checkbox" id="c-41149607" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41149346">parent</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41149607">[-]</label><label class="expand" for="c-41149607">[4 more]</label></div><br/><div class="children"><div class="content">But having a straightforward&#x2F;predictable mapping to the underlying machine and <i>its</i> semantics is included in the C model of computation.<p>And that is actually not just compatible with the C &quot;model of computation&quot; being otherwise quite incomplete, these two properties are really just two sides of the same coin.<p>The whole idea of an &quot;abstract C machine&quot; that unambiguously and completely specifies behavior is a fiction.</div><br/><div id="41150236" class="c"><input type="checkbox" id="c-41150236" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41149607">parent</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41150236">[-]</label><label class="expand" for="c-41150236">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But having a straightforward&#x2F;predictable mapping to the underlying machine and its semantics is included in the C model of computation.<p>not rally, or at least not in a way which would count as &quot;high level assembler&quot;. If it would the majority of optimizations compilers do today would not be standard conform.<p>Like there is a mapping to behavior but not a mapping to assembly.<p>Which is where the abstract C machine as a hypothetical machine formed from the rules of the standard comes in. Kinda as a mind model which runs the behavior mappings instead of running any specific assembly. But then it not being ambiguous and complete doesn&#x27;t change anything about C not being high level assembly, actually it makes C even less high level assembly.</div><br/><div id="41151446" class="c"><input type="checkbox" id="c-41151446" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41150236">parent</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41151446">[-]</label><label class="expand" for="c-41151446">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  If it would the majority of optimizations compilers do today would not be standard conform.<p>They aren&#x27;t.</div><br/><div id="41151627" class="c"><input type="checkbox" id="c-41151627" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41151446">parent</a><span>|</span><a href="#41148467">next</a><span>|</span><label class="collapse" for="c-41151627">[-]</label><label class="expand" for="c-41151627">[1 more]</label></div><br/><div class="children"><div class="content">So you can easily tell, just by looking to the C source code, if plain Assembly instructions are being used from four books of ISA manual, if the compiler is able to automatically vectorize a code region including which flavour of vector instructions, or completely replace specific math code patterns for a single opcode.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41148154" class="c"><input type="checkbox" id="c-41148154" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148010">parent</a><span>|</span><a href="#41148205">prev</a><span>|</span><a href="#41149697">next</a><span>|</span><label class="collapse" for="c-41148154">[-]</label><label class="expand" for="c-41148154">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that you’d have to come up with and agree on an alternative language specification without (or with less) UB. Having the compiler implementation be the specification is not a solution. And such a newly agreed specification would invariably either turn some previously conforming programs nonconforming, or reduce performance in relevant scenarios, or both.<p>That’s not to say that it wouldn’t be worth it, but given the multitude of compiler implementations and vendors, and the huge amount of existing code, it’s a difficult proposition.<p>What traditionally has been done, is either to define some “safe” subset of C verified by linters, or since you probably want to break some compatibility anyway, design a separate new language.</div><br/></div></div><div id="41149697" class="c"><input type="checkbox" id="c-41149697" checked=""/><div class="controls bullet"><span class="by">zajio1am</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148010">parent</a><span>|</span><a href="#41148154">prev</a><span>|</span><a href="#41150515">next</a><span>|</span><label class="collapse" for="c-41149697">[-]</label><label class="expand" for="c-41149697">[1 more]</label></div><br/><div class="children"><div class="content">&gt; UB is meant to add value. It’s possible to write a language without it, so why do we have any UB at all? We do because of portability and because it gives flexibility to compilers writers.<p>Implementation-defined behavior is here for portability for valid code. Undefined behavior is here so that compilers have leeway with handling invalid conditions (like null pointer dereference, out-of-bounds access, integer overflows, division by zero ...).<p>What does it mean that a language does not have UBs? There are several cases how to handle invalid conditions:<p>1) eliminate them at compile time - this is optimal, but currently practical just for some classes of errors.<p>2) have consistent, well-defined behavior for them - platforms may have vastly different way how to handle invalid conditions<p>3) have consistent, implementation-defined behavior for them - usable for some classes of errors (integer overflow, division by zero), but for others it would add extensive runtime overhead.<p>4) have inconsistent behavior (UB) - C way</div><br/></div></div><div id="41150515" class="c"><input type="checkbox" id="c-41150515" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41147705">root</a><span>|</span><a href="#41148010">parent</a><span>|</span><a href="#41149697">prev</a><span>|</span><a href="#41148422">next</a><span>|</span><label class="collapse" for="c-41150515">[-]</label><label class="expand" for="c-41150515">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s possible to write a language without it<p>Whenever you do that, programmers deride the language for being &quot;excessively academic&quot; or something</div><br/></div></div></div></div></div></div><div id="41147425" class="c"><input type="checkbox" id="c-41147425" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#41147705">prev</a><span>|</span><a href="#41147542">next</a><span>|</span><label class="collapse" for="c-41147425">[-]</label><label class="expand" for="c-41147425">[7 more]</label></div><br/><div class="children"><div class="content">Fwiw clang has a `clang::optnone` attribute to disable all optimizations on a per-function basis, and GCC has the fantastic `gnu::optimize` attribute which allows you to add or remove optimizations by name, or set the optimization level regardless of compiler flags. `gnu::optimize(0)` is similar to that clang flag. Clang also has `clang::no_builtins` to disable specifically the memcpy and memset optimizations.</div><br/><div id="41147680" class="c"><input type="checkbox" id="c-41147680" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41147425">parent</a><span>|</span><a href="#41147542">next</a><span>|</span><label class="collapse" for="c-41147680">[-]</label><label class="expand" for="c-41147680">[6 more]</label></div><br/><div class="children"><div class="content">&quot;The optimize attribute should be used for debugging purposes only. It is not suitable in production code. &quot;<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Common-Function-Attributes.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Common-Function-Attribute...</a></div><br/><div id="41148246" class="c"><input type="checkbox" id="c-41148246" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#41147425">root</a><span>|</span><a href="#41147680">parent</a><span>|</span><a href="#41147542">next</a><span>|</span><label class="collapse" for="c-41148246">[-]</label><label class="expand" for="c-41148246">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting note. I wonder why they claim this. As far as I know, `[[gnu::optimize(&quot;-fno-tree-loop-distribute-patterns&quot;)]]` (or the equivalent #pragma) is required for implementing a memcpy function in C unless you do something funky with the build system.</div><br/><div id="41149349" class="c"><input type="checkbox" id="c-41149349" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41147425">root</a><span>|</span><a href="#41148246">parent</a><span>|</span><a href="#41151322">next</a><span>|</span><label class="collapse" for="c-41149349">[-]</label><label class="expand" for="c-41149349">[3 more]</label></div><br/><div class="children"><div class="content">Maybe that&#x27;s applied to the TU that defines it? I don&#x27;t see it in the glibc sources.</div><br/><div id="41150106" class="c"><input type="checkbox" id="c-41150106" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#41147425">root</a><span>|</span><a href="#41149349">parent</a><span>|</span><a href="#41151322">next</a><span>|</span><label class="collapse" for="c-41150106">[-]</label><label class="expand" for="c-41150106">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s indeed used:<p>Definition of macro:
<a href="https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=include&#x2F;libc-symbols.h;h=4367aa6740bff6fc6b42b562f5d9a95b6690bc50;hb=HEAD#l808" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=include&#x2F;lib...</a><p>Use:
<a href="https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=string&#x2F;memmove.c;h=3fad5f11acdf5d8a5ae1436c1e577f050c5d5193;hb=HEAD#l42" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p=glibc.git;a=blob;f=string&#x2F;memm...</a><p>For a bunch of other places -fno-builtin-* seems to be used.</div><br/><div id="41151827" class="c"><input type="checkbox" id="c-41151827" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41147425">root</a><span>|</span><a href="#41150106">parent</a><span>|</span><a href="#41151322">next</a><span>|</span><label class="collapse" for="c-41151827">[-]</label><label class="expand" for="c-41151827">[1 more]</label></div><br/><div class="children"><div class="content">My guess is that the attribute interacts weirdly with optimizations spanning function calls, like inlining. It might be safe for TUs that define a single function, like with memmove above. Having said that applying the option to the TU itself would be equivalent, and not discouraged by GCC docs.</div><br/></div></div></div></div></div></div><div id="41151322" class="c"><input type="checkbox" id="c-41151322" checked=""/><div class="controls bullet"><span class="by">pertymcpert</span><span>|</span><a href="#41147425">root</a><span>|</span><a href="#41148246">parent</a><span>|</span><a href="#41149349">prev</a><span>|</span><a href="#41147542">next</a><span>|</span><label class="collapse" for="c-41151322">[-]</label><label class="expand" for="c-41151322">[1 more]</label></div><br/><div class="children"><div class="content">Because these optimizations are not supposed to be a part of the user interface. They&#x27;re internal passes and may one day go away or be merged or subsumed etc.</div><br/></div></div></div></div></div></div></div></div><div id="41147542" class="c"><input type="checkbox" id="c-41147542" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41147425">prev</a><span>|</span><a href="#41147491">next</a><span>|</span><label class="collapse" for="c-41147542">[-]</label><label class="expand" for="c-41147542">[7 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help but feel we&#x27;re going to think of these as the bad old years, and that at some point we&#x27;ll have migrated off of C to a language with much less UB. It&#x27;s so easy to express things in C that compile but that the compiler couldn&#x27;t possibly guess the <i>intent</i> of because C doesn&#x27;t have a way to express it.<p>For instance, in Python you can write something like:<p><pre><code>  result = [something(value) for value in set_object]
</code></pre>
Because Python&#x27;s set objects are unordered, it&#x27;s clear that it doesn&#x27;t matter in which order the items are processed, and that the order of the results doesn&#x27;t matter. That opens a whole lot of optimizations at the language level that don&#x27;t rely on brilliant compilers implying what the author meant. Similar code in another language with immutable data can go one step further: since something(value1) can&#x27;t possibly affect something(value2), it can execute those in parallel with threads or processes or whatever else makes it go fast.<p>Much of the optimization of C compilers is looking at patterns in the code and trying to find faster ways to do what the author probably meant. Because C lacks the ability to express much intent compared to pretty much any newer language, they have the freedom to guess, but also <i>have</i> to make those kinds of inferences to get decent performance.<p>On the plus side, this might be a blessing in disguise like when the Hubble telescope needed glasses. We invented brilliant techniques to make it work despite its limitations. Once we fixed its problems, those same techniques made it perform way better than originally expected. All those C compiler optimizations, applied to a language that&#x27;s not C, may give us superpowers.</div><br/><div id="41148137" class="c"><input type="checkbox" id="c-41148137" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41147542">parent</a><span>|</span><a href="#41147693">next</a><span>|</span><label class="collapse" for="c-41148137">[-]</label><label class="expand" for="c-41148137">[1 more]</label></div><br/><div class="children"><div class="content">On the Python example, the downside is that, even though the order is unspecified, people may still rely on some properties, and have their code break when an optimizer changes the order. Basically the same as UB really, though potentially resulting in wrong results, not necessarily safety issues (at least not immediately; but wrong results can turn into safety issues later on). And, unlike with UB, having a &quot;sanitizer&quot; that verifies that your code works on all possible set orders is basically impossible.<p>gcc&#x2F;clang do have a variety of things for providing low-level hints to the compiler that are frequently absent in other languages - __builtin_expect&#x2F;__builtin_unpredictable, __builtin_unreachable&#x2F;__builtin_assume, &quot;#pragma clang loop vectorize(assume_safety)&quot;&#x2F;&quot;#pragma GCC ivdep&quot;, more pragmas for disabling loop unrolling&#x2F;vectorizing or choosing specific values. Biggest thing imo missing being some &quot;optimization fences&quot; to explicitly disallow the compiler to reason about a value from its source (__asm__ can, to an extent, do this, but has undesired side-effects, and needs platform-specific register kind names).<p>There&#x27;s certainly potential in higher-level intent-based optimization though. Things coming to mind being reserving space in an arraylist before a loop with n pushes, merging hashmap lookups in code doing contains→get→put with the same key, simplifying away objects&#x2F;allocations from ability to locally reason about global allocation behavior.</div><br/></div></div><div id="41147693" class="c"><input type="checkbox" id="c-41147693" checked=""/><div class="controls bullet"><span class="by">unclad5968</span><span>|</span><a href="#41147542">parent</a><span>|</span><a href="#41148137">prev</a><span>|</span><a href="#41147856">next</a><span>|</span><label class="collapse" for="c-41147693">[-]</label><label class="expand" for="c-41147693">[4 more]</label></div><br/><div class="children"><div class="content">While all that makes sense in theory none of it has actually demonstrated to be faster than C. The compiler doesn&#x27;t need to guess what the programmer is trying to do because C is close enough to the actual hardware that the programmer can just tell it what to do.</div><br/><div id="41147789" class="c"><input type="checkbox" id="c-41147789" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41147542">root</a><span>|</span><a href="#41147693">parent</a><span>|</span><a href="#41147889">next</a><span>|</span><label class="collapse" for="c-41147789">[-]</label><label class="expand" for="c-41147789">[1 more]</label></div><br/><div class="children"><div class="content">Note that C code has hardly fast outside big iron UNIX, during the 1980&#x27;s and up to the mid 1990&#x27;s, any half clever developer could easily outperform the generated machine code, with manually written Assembly code.<p>Hence why games for 8 and 16 bit home computers were mostly written in Assembly, and there were books like the Zen of Assembly Programming.<p>It was the way that optimizating compilers started  to exploit UB in C, that finally made it fast enough for modern times.<p>Modern hardware has nothing to do with C abstract machine.</div><br/></div></div><div id="41147889" class="c"><input type="checkbox" id="c-41147889" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41147542">root</a><span>|</span><a href="#41147693">parent</a><span>|</span><a href="#41147789">prev</a><span>|</span><a href="#41147866">next</a><span>|</span><label class="collapse" for="c-41147889">[-]</label><label class="expand" for="c-41147889">[1 more]</label></div><br/><div class="children"><div class="content">Funnily part of why Python is well, one of the slowest widely used languages is that any AOT compiler has a really hard time guessing what it does (&quot;slowest&quot; for pure python only, it&#x27;s still often more then fast enough).<p>Through then the &quot;cognitive&quot;&#x2F;&quot;risk&quot; overhead of large complicated C code bases in typical company use cases (*1) makes it so that you have to be very strict&#x2F;careful about doing any optimizations in C at all. In which case ironically your perf. can easily be below that of e.g. go, Rust, C#, Java etc. (depending on use case). I.e. in the typical code base the additional optimizations the compiler can do due to better understanding as well as less risky but limited&#x2F;simple ad-hoc human optimizations beat out C quite often.<p>In a certain way it&#x27;s the same story as back then with ASM, in theory in some use-cases it&#x27;s faster but in practice for a lot of real world code with real world constraints of dev-hours and dev-expertise writing C was the better business choice.<p>(1) I.e. hardly any resources for optimization for most code. Potentially in general a few to little devs for the tasks&#x2F;deadlines. Definitely no time to chase UB bugs.</div><br/></div></div><div id="41147866" class="c"><input type="checkbox" id="c-41147866" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#41147542">root</a><span>|</span><a href="#41147693">parent</a><span>|</span><a href="#41147889">prev</a><span>|</span><a href="#41147856">next</a><span>|</span><label class="collapse" for="c-41147866">[-]</label><label class="expand" for="c-41147866">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;research.microsoft.com&#x2F;en-us&#x2F;um&#x2F;people&#x2F;simonpj&#x2F;papers&#x2F;ndp&#x2F;haskell-beats-C.pdf" rel="nofollow">https:&#x2F;&#x2F;research.microsoft.com&#x2F;en-us&#x2F;um&#x2F;people&#x2F;simonpj&#x2F;paper...</a></div><br/></div></div></div></div><div id="41147856" class="c"><input type="checkbox" id="c-41147856" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41147542">parent</a><span>|</span><a href="#41147693">prev</a><span>|</span><a href="#41147491">next</a><span>|</span><label class="collapse" for="c-41147856">[-]</label><label class="expand" for="c-41147856">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s certainly true that there&#x27;s room for semantic optimization, but my observation is that such optimization is largely around memory allocation.<p>And AFAIK the only languages which tend to implement such memory optimizations are Java-like, and the only reason they bother is because of their up-front aggressive pessimization ... which the optimization can&#x27;t make up for.<p>Edit: my point is: yes C sucks, but everybody else is worse</div><br/></div></div></div></div><div id="41147491" class="c"><input type="checkbox" id="c-41147491" checked=""/><div class="controls bullet"><span class="by">TNorthover</span><span>|</span><a href="#41147542">prev</a><span>|</span><a href="#41148767">next</a><span>|</span><label class="collapse" for="c-41147491">[-]</label><label class="expand" for="c-41147491">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m vaguely sympathetic to these crypto people&#x27;s end goals (talking about things like constant time evaluation &amp; secret hiding), but it&#x27;s really not what general purpose compilers are even thinking about most of the time so I doubt it&#x27;ll ever be more than a hack that mostly works.<p>They&#x27;ll probably need some kind of specialized compiler of their own if they want to be serious about it. Or carry on with asm.</div><br/><div id="41147520" class="c"><input type="checkbox" id="c-41147520" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#41147491">parent</a><span>|</span><a href="#41148767">next</a><span>|</span><label class="collapse" for="c-41147520">[-]</label><label class="expand" for="c-41147520">[3 more]</label></div><br/><div class="children"><div class="content">The author has written such a compiler: <a href="https:&#x2F;&#x2F;cr.yp.to&#x2F;qhasm.html" rel="nofollow">https:&#x2F;&#x2F;cr.yp.to&#x2F;qhasm.html</a> (or at least, a prototype for one)</div><br/><div id="41147640" class="c"><input type="checkbox" id="c-41147640" checked=""/><div class="controls bullet"><span class="by">jedisct1</span><span>|</span><a href="#41147491">root</a><span>|</span><a href="#41147520">parent</a><span>|</span><a href="#41148767">next</a><span>|</span><label class="collapse" for="c-41147640">[-]</label><label class="expand" for="c-41147640">[2 more]</label></div><br/><div class="children"><div class="content">Jasmin has largely replaced qhasm.</div><br/><div id="41147802" class="c"><input type="checkbox" id="c-41147802" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41147491">root</a><span>|</span><a href="#41147640">parent</a><span>|</span><a href="#41148767">next</a><span>|</span><label class="collapse" for="c-41147802">[-]</label><label class="expand" for="c-41147802">[1 more]</label></div><br/><div class="children"><div class="content">Jasmin is also an assembler for JVM bytecode, love overloaded names.</div><br/></div></div></div></div></div></div></div></div><div id="41148767" class="c"><input type="checkbox" id="c-41148767" checked=""/><div class="controls bullet"><span class="by">quohort</span><span>|</span><a href="#41147491">prev</a><span>|</span><a href="#41148480">next</a><span>|</span><label class="collapse" for="c-41148767">[-]</label><label class="expand" for="c-41148767">[3 more]</label></div><br/><div class="children"><div class="content">Very interesting article and much-needed criticism of the current standard of heuristic optimization.<p>Before reading this, I thought that a simple compiler could never usefully compete against optimizing compilers (which require more manpower to produce), but perhaps there is a niche use-case for a compiler with better facilities for manual optimization. This article has inspired me to make a simple compiler myself.</div><br/><div id="41149186" class="c"><input type="checkbox" id="c-41149186" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#41148767">parent</a><span>|</span><a href="#41148480">next</a><span>|</span><label class="collapse" for="c-41149186">[-]</label><label class="expand" for="c-41149186">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to get rid of all optimizations though, just the &quot;unsafe&quot; ones. And you could always make them opt-in instead of opt-out.<p>Now I&#x27;m definitely closer to a noob, but compilers already have flags like no-strict-overflow and no-delete-null-pointer-checks. I don&#x27;t see why we can&#x27;t make these the default options. It&#x27;s already &quot;undefined behavior&quot; per the spec, so why not make it do something sensible. The only danger is that some pedant comes along and says that with these assumptions what you&#x27;re now writing isn&#x27;t &quot;portable C&quot; and relies on compiler-defined behavior, but in the real world if it does the correct thing I don&#x27;t think anyone would care: just call your dialect &quot;boringC&quot; instead of C99 or something (borrowing Gavin Howard&#x27;s term), and the issue disappears.</div><br/><div id="41149687" class="c"><input type="checkbox" id="c-41149687" checked=""/><div class="controls bullet"><span class="by">quohort</span><span>|</span><a href="#41148767">root</a><span>|</span><a href="#41149186">parent</a><span>|</span><a href="#41148480">next</a><span>|</span><label class="collapse" for="c-41149687">[-]</label><label class="expand" for="c-41149687">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And you could always make them opt-in instead of opt-out.<p>&gt; The only danger is that some pedant comes along and says that with these assumptions what you&#x27;re now writing isn&#x27;t &quot;portable C&quot; and relies on compiler-defined behavior, but in the real world if it does the correct thing I don&#x27;t think anyone would care: just call your dialect &quot;boringC&quot; instead of C99 or something (borrowing Gavin Howard&#x27;s term), and the issue disappears.<p>My idea is to make a new language with some simple syntax like S-expressions. Compilation would be (almost entirely) done with lisp-like macros, but unlike lisp it would be an imperative language rather than a functional language. The main data structure would have to be a hierarchy (analogous to CONS) to facilitate these macros.<p>Optimizations (and Specializations) would be opt-in and would depend on the intrinsics and macros you allow in compilation. For example, you could start writing code with this default data structure, and later swap it out for some more specific data structure like a linked list or a hashtable. The most daunting problem is the issue of how the compiler selects what optimization or specializations to use; Optimizing for something like code size is straightforward, but optimizing for code speed will depend on what branches are taken at runtime. Now I suppose that the language should simply allow the programmer to manually express their preferences (which could be discovered through benchmarks&#x2F;code studies).<p>I think that this could have a niche for manually-optimized code that requires strict static analysis and straight-forward compilation. It also could have a niche in decompilation&#x2F;recompilation&#x2F;reverse-engineering (I think that a similar process can run in reverse to disassemble even obfuscated code, because you could easily write a macro to reverse an ad-hoc obfuscation mechanism).<p>Here is another application of the language: By controlling the macros and intrinsics available at compilation, you could ensure compile-time security of userspace programs. For example, you could have a setup such that speculative execution vulnerabilities and the like are impossible to compile. I think you could safely enforce cooperative multitasking between programs.<p>I&#x27;ll probably start with a simple assembly language like WASM, then LLVM-IR. Eventually it would have JS&#x2F;C&#x2F;Rust bindings to interoperate with normal libraries.<p>Lastly, I would like to make it so you can write routines that are portable between CPUs, GPUs, and even FPGAs, but this would be very difficult and this functionality may better realized with a functional language (e.g. CLASP <a href="https:&#x2F;&#x2F;github.com&#x2F;clasp-developers&#x2F;clasp">https:&#x2F;&#x2F;github.com&#x2F;clasp-developers&#x2F;clasp</a>) or may require programmers to work at an uncomfortably high level of abstraction.</div><br/></div></div></div></div></div></div><div id="41148480" class="c"><input type="checkbox" id="c-41148480" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#41148767">prev</a><span>|</span><a href="#41151926">next</a><span>|</span><label class="collapse" for="c-41148480">[-]</label><label class="expand" for="c-41148480">[1 more]</label></div><br/><div class="children"><div class="content">Refreshing post that conveys a perspective I haven&#x27;t seen voiced often. See also: <a href="https:&#x2F;&#x2F;gavinhoward.com&#x2F;2023&#x2F;08&#x2F;the-scourge-of-00ub&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gavinhoward.com&#x2F;2023&#x2F;08&#x2F;the-scourge-of-00ub&#x2F;</a></div><br/></div></div><div id="41151926" class="c"><input type="checkbox" id="c-41151926" checked=""/><div class="controls bullet"><span class="by">red_admiral</span><span>|</span><a href="#41148480">prev</a><span>|</span><a href="#41147930">next</a><span>|</span><label class="collapse" for="c-41151926">[-]</label><label class="expand" for="c-41151926">[1 more]</label></div><br/><div class="children"><div class="content">So, should we be compiling security-critical code with `-O0` then?</div><br/></div></div><div id="41147930" class="c"><input type="checkbox" id="c-41147930" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#41151926">prev</a><span>|</span><a href="#41147467">next</a><span>|</span><label class="collapse" for="c-41147930">[-]</label><label class="expand" for="c-41147930">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s free software, they are completely free to fork it make it have whatever semantics they want if they don&#x27;t like the ISO C semantics. They can&#x27;t really expect someone else to do that for them for free, and especially this sort of post is not exactly the sort of thing that would any of the compiler people to come to djbs side</div><br/></div></div><div id="41147467" class="c"><input type="checkbox" id="c-41147467" checked=""/><div class="controls bullet"><span class="by">ziml77</span><span>|</span><a href="#41147930">prev</a><span>|</span><a href="#41148452">next</a><span>|</span><label class="collapse" for="c-41147467">[-]</label><label class="expand" for="c-41147467">[4 more]</label></div><br/><div class="children"><div class="content">Why does the code need to rely on hacks to get around optimizations? Can&#x27;t they be disabled per-unit by just compiling different files with different optimization flags?</div><br/><div id="41147744" class="c"><input type="checkbox" id="c-41147744" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41147467">parent</a><span>|</span><a href="#41147942">next</a><span>|</span><label class="collapse" for="c-41147744">[-]</label><label class="expand" for="c-41147744">[2 more]</label></div><br/><div class="children"><div class="content">You can’t realistically have a C compiler that doesn’t do any optimizations.<p>For one thing, CPU caches are wonders of technology, but a C compiler that only uses registers for computations but stores all results in memory and issues a load for every read will be unbearingly slow.<p>So, you need a register allocator and if you have that, you either need (A) an algorithm to spill data to memory if you run out of registers, or (B) have to refuse to compile such code.<p>If you make choice A, any change to the code for spilling back to memory can affect timings and that can introduce a timing bug in constant-time code that isn’t branch-free.<p>Also, there still is no guarantee that code that is constant-time on CPU X also will be on CPU Y. For example, one CPU has single-cycle 64-bit multiplication, but another doesn’t.<p>If you make choice B, you don’t have a portable language anymore. Different CPUs have different amounts of registers, and they can have different features, so code that runs fine in on one CPU may not do so on another one (even if it has the exact same amount of registers of the same size).<p>Phrased differently: C isn’t a language that supports writing constant-time functions. If you want that, you either have to try hard to beat a C compiler into submission, and you will fail in doing that, or choose a different language, and that likely will be one that is a lot like the assembly language of the target CPU. You could make it _look_ similar between CPUs, but there would be subtle or not so subtle differences in semantics or in what programs the language accepts for different CPUs.<p>Having said that: a seriously dumbed down C compiler (with a simple register allocator that programmers can mostly understand, no constant folding, no optimizations replacing multiplications by bit shifts or divisions by multiplications, 100% honors ‘inline’ phrases, etc.) probably could get close to what people want. It might even have a feature where code that requires register spilling triggers a compiler error. I am not aware of any compiler with that feature, though.<p>I wouldn’t call that C, though, as programs written in it would be a lot less portable.</div><br/><div id="41149231" class="c"><input type="checkbox" id="c-41149231" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41147467">root</a><span>|</span><a href="#41147744">parent</a><span>|</span><a href="#41147942">next</a><span>|</span><label class="collapse" for="c-41149231">[-]</label><label class="expand" for="c-41149231">[1 more]</label></div><br/><div class="children"><div class="content">That would bring us back to the days of 8 and 16 bit home computers, where the quality of C compilers outside UNIX, was hardly anything to be impressed about.</div><br/></div></div></div></div><div id="41147942" class="c"><input type="checkbox" id="c-41147942" checked=""/><div class="controls bullet"><span class="by">UncleMeat</span><span>|</span><a href="#41147467">parent</a><span>|</span><a href="#41147744">prev</a><span>|</span><a href="#41148452">next</a><span>|</span><label class="collapse" for="c-41147942">[-]</label><label class="expand" for="c-41147942">[1 more]</label></div><br/><div class="children"><div class="content">What is an optimization?<p>You wrote some code. It doesn&#x27;t refer to registers. Is register allocation that minimized spillage an optimization? How would you write a compiler that has &quot;non-optimizing&quot; register allocation?</div><br/></div></div></div></div><div id="41148452" class="c"><input type="checkbox" id="c-41148452" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#41147467">prev</a><span>|</span><a href="#41150616">next</a><span>|</span><label class="collapse" for="c-41148452">[-]</label><label class="expand" for="c-41148452">[3 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t like C&#x27;s semantics then how about using a different programming language instead of getting angry at compiler engineers.</div><br/><div id="41148492" class="c"><input type="checkbox" id="c-41148492" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#41148452">parent</a><span>|</span><a href="#41150616">next</a><span>|</span><label class="collapse" for="c-41148492">[-]</label><label class="expand" for="c-41148492">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m honestly unsure whether djb would actually find anything other than his qhasm tolerable (yes, even Zig). I find this particular commentary from him unsurprising.</div><br/><div id="41150926" class="c"><input type="checkbox" id="c-41150926" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41148452">root</a><span>|</span><a href="#41148492">parent</a><span>|</span><a href="#41150616">next</a><span>|</span><label class="collapse" for="c-41150926">[-]</label><label class="expand" for="c-41150926">[1 more]</label></div><br/><div class="children"><div class="content">Zig will remove many UB but it will add a new nasty one in case of pass by value parameter aliasing with a parameter passed by pointer..<p>*:  <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#toc-Pass-by-value-Parameters" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#toc-Pass-by-value-...</a></div><br/></div></div></div></div></div></div><div id="41150616" class="c"><input type="checkbox" id="c-41150616" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#41148452">prev</a><span>|</span><a href="#41147962">next</a><span>|</span><label class="collapse" for="c-41150616">[-]</label><label class="expand" for="c-41150616">[1 more]</label></div><br/><div class="children"><div class="content">Ok, as far as the efficacy&#x2F;importance&#x2F;tradeoff of optimizing compilers...<p>How do Firefox and Chrome perform if they are compiled at -O0?</div><br/></div></div><div id="41147962" class="c"><input type="checkbox" id="c-41147962" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#41150616">prev</a><span>|</span><a href="#41147622">next</a><span>|</span><label class="collapse" for="c-41147962">[-]</label><label class="expand" for="c-41147962">[1 more]</label></div><br/><div class="children"><div class="content">What I&#x27;d really like is a way to express code in a medium&#x2F;high level language, and provide hand-optimized assembly code alongside it (for as many target architectures as you need). For a first-pass, you could machine-generate that assembly, and then manually verify that it&#x27;s constant time (for example) and perform additional optimizations over the top of that, by hand.<p>The &quot;compiler&quot;&#x27;s job would then be to assert that the behaviour of the source matches the behaviour of the provided assembly. (This is probably a hard&#x2F;impossible problem to solve in the general case, but I think it&#x27;d be solvable in enough cases to be useful)<p>To me this would offer the best of both worlds - readable, auditable source code, alongside high-performance assembly that you know won&#x27;t randomly break in a future compiler update.</div><br/></div></div><div id="41147622" class="c"><input type="checkbox" id="c-41147622" checked=""/><div class="controls bullet"><span class="by">johnfn</span><span>|</span><a href="#41147962">prev</a><span>|</span><a href="#41150312">next</a><span>|</span><label class="collapse" for="c-41147622">[-]</label><label class="expand" for="c-41147622">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The bugs admitted in the compiler changelogs are just the tip of the iceberg. Whenever possible, compiler writers refuse to take responsibility for the bugs they introduced, even though the compiled code worked fine before the &quot;optimizations&quot;.<p>This makes it difficult to read the rest of the article. Really? All compiler authors, as a blanket statement, act in bad faith? Whenever possible?<p>&gt; As a cryptographic example, benchmarks across many CPUs show that the avx2 implementation of kyber768 is about 4 times faster than portable code compiled with an &quot;optimizing&quot; compiler.<p>What? This is an apples to oranges comparison. Compilers optimize all code they parse; optimizing a single algorithm will of course speed up implementations of that specific algorithm, but what about the 99.9999999% of code which is <i>not</i> your particular hand-optimized algorithm?</div><br/><div id="41147704" class="c"><input type="checkbox" id="c-41147704" checked=""/><div class="controls bullet"><span class="by">marcus0x62</span><span>|</span><a href="#41147622">parent</a><span>|</span><a href="#41150312">next</a><span>|</span><label class="collapse" for="c-41147704">[-]</label><label class="expand" for="c-41147704">[9 more]</label></div><br/><div class="children"><div class="content">&gt; This makes it difficult to read the rest of the article. Really? All compiler authors, as a blanket statement, act in bad faith? Whenever possible?<p>When I saw the link was to DJB’s site, I figured the post would contain a vitriolic and hyperbolic rant. It’s pretty on-brand for him (although, to be fair, he’s usually right.)</div><br/><div id="41147969" class="c"><input type="checkbox" id="c-41147969" checked=""/><div class="controls bullet"><span class="by">UncleMeat</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41147704">parent</a><span>|</span><a href="#41147788">next</a><span>|</span><label class="collapse" for="c-41147969">[-]</label><label class="expand" for="c-41147969">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think DJB is right here, but I do think he is one of the few &quot;ugh compilers taking advantage of UB&quot; people who is actually serious about it. DJB wants absolute certainty in predicting the compiled code so that he can make significantly stronger guarantees about his programs than almost anybody else needs.<p>The bad news for him is that the bulk of clang users aren&#x27;t writing core cryptographic primitives and really DJB just needs a different language and compiler stack for his specific goals.</div><br/><div id="41148505" class="c"><input type="checkbox" id="c-41148505" checked=""/><div class="controls bullet"><span class="by">g-b-r</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41147969">parent</a><span>|</span><a href="#41147788">next</a><span>|</span><label class="collapse" for="c-41148505">[-]</label><label class="expand" for="c-41148505">[1 more]</label></div><br/><div class="children"><div class="content">The bad news for us is that plenty of cryptographic (or otherwise critical) code is <i>already</i> written in C or C++, and when compiler writers play with their optimizations, they cause real-world problems to a good portion of the population</div><br/></div></div></div></div><div id="41147788" class="c"><input type="checkbox" id="c-41147788" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41147704">parent</a><span>|</span><a href="#41147969">prev</a><span>|</span><a href="#41150312">next</a><span>|</span><label class="collapse" for="c-41147788">[-]</label><label class="expand" for="c-41147788">[6 more]</label></div><br/><div class="children"><div class="content">&gt; (although, to be fair, he’s usually right.)<p>This is worth emphasizing. I actually can&#x27;t think of any articles of his other than this one that miss the mark.</div><br/><div id="41148632" class="c"><input type="checkbox" id="c-41148632" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41147788">parent</a><span>|</span><a href="#41148095">next</a><span>|</span><label class="collapse" for="c-41148632">[-]</label><label class="expand" for="c-41148632">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;debunking NIST&#x27;s calculation&quot; one was, if I&#x27;m remembering this right, refuted by Chris Peikert on the PQC mailing list immediately after it was posted.</div><br/></div></div><div id="41148095" class="c"><input type="checkbox" id="c-41148095" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41147788">parent</a><span>|</span><a href="#41148632">prev</a><span>|</span><a href="#41150312">next</a><span>|</span><label class="collapse" for="c-41148095">[-]</label><label class="expand" for="c-41148095">[4 more]</label></div><br/><div class="children"><div class="content">I’m not sure this one is wrong, especially if you’ve been bitten by underdocumented compiler or framework changes that modify behavior of previously working code.<p>For example, I have a small utility app built against SwiftUI for macOS 13. Compiling on macOS 14 while still linking against frameworks for 13 results in broken UI interaction in a particular critical use case. This was a deliberate change made to migrate devs away from a particular API, but it fails silently at compile time and runtime. Moving the code back to a macOS 13 machine would produce the correct result.<p>As a dev, I can no longer trust that linking against specific library version will produce the same result and now need to think of some tuple of compile host and library version<p>At one point should working code be considered correct and complete when compiler writers change code generation that doesn’t depend on UB? I’m sure it’s worse for JITed languages where constant time operations work in test and for the first few hundred iterations and then are “optimized” into variable time branching instructions on a production host somewhere.</div><br/><div id="41148421" class="c"><input type="checkbox" id="c-41148421" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41148095">parent</a><span>|</span><a href="#41150312">next</a><span>|</span><label class="collapse" for="c-41148421">[-]</label><label class="expand" for="c-41148421">[3 more]</label></div><br/><div class="children"><div class="content">No, he’s wrong. What you’re talking about is completely different than what you are: your code doesn’t work because Apple changes the behavior of their frameworks, which has nothing to do with what compiler you’re using. There’s a different contract there than what a C compiler gives you.</div><br/><div id="41148761" class="c"><input type="checkbox" id="c-41148761" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41148421">parent</a><span>|</span><a href="#41150312">next</a><span>|</span><label class="collapse" for="c-41148761">[-]</label><label class="expand" for="c-41148761">[2 more]</label></div><br/><div class="children"><div class="content">It’s not quite that simple in Swift-land. There is a significant overlap between what’s compiler and what’s runtime. I’m supposedly linking against the same libraries, but changing the host platform changes the output binaries. Same code, same linked libraries, different host platform, different codegen.<p>Mine isn’t security critical, but the result is similarly unexpected.</div><br/><div id="41150108" class="c"><input type="checkbox" id="c-41150108" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#41147622">root</a><span>|</span><a href="#41148761">parent</a><span>|</span><a href="#41150312">next</a><span>|</span><label class="collapse" for="c-41150108">[-]</label><label class="expand" for="c-41150108">[1 more]</label></div><br/><div class="children"><div class="content">It’s really not the same thing. Your complaint is about Apple’s complex framework API management, not about the compiler optimization&#x2F;undefined behavior.<p>Swift frameworks sometimes blur the line the way I think you mean by being able to be back-deployed to earlier OS releases through embedding in your binary. Apple’s documentation is poor (and has been since the NeXT takeover in 1997), but, again, that’s not a compiler issue as such.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41150312" class="c"><input type="checkbox" id="c-41150312" checked=""/><div class="controls bullet"><span class="by">_orz_</span><span>|</span><a href="#41147622">prev</a><span>|</span><a href="#41147602">next</a><span>|</span><label class="collapse" for="c-41150312">[-]</label><label class="expand" for="c-41150312">[1 more]</label></div><br/><div class="children"><div class="content">What an interesting discussion. Especially everything about that writing it in Asm would be the solution if you want secure code.<p>Both, gcc and clang, are orders of magnitude better tested than all the closed source applications, developed under tight timelines and that we essentially trust our lives with.<p>To be very clear, there are compiler bugs but those are almost never the problem in the first place. In the vast majority of cases it starts with buggy user code. An now back to handwritten assembly…</div><br/></div></div><div id="41147602" class="c"><input type="checkbox" id="c-41147602" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41150312">prev</a><span>|</span><a href="#41148046">next</a><span>|</span><label class="collapse" for="c-41147602">[-]</label><label class="expand" for="c-41147602">[3 more]</label></div><br/><div class="children"><div class="content">I was already rolling my eyes but then I saw the unironic link to “The Death of Optimizing Compilers” and they might as well have fell out of my head. Someone please explain to the crypto people that designing a general-purpose language around side-channel resistance is actually stupid since most people don’t need it, optimizations actually do help quite a lot (…if they didn’t, you wouldn’t be begging for them: -O0 exists), and the model of UB C(++) has is not going away. If you want to make your own dedicated cryptography compiler that does all this stuff I honestly think you should and I would support such a thing but when you think the whole world is conspiring against your attempts to write perfect code maybe it’s you.</div><br/><div id="41149791" class="c"><input type="checkbox" id="c-41149791" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41147602">parent</a><span>|</span><a href="#41148046">next</a><span>|</span><label class="collapse" for="c-41149791">[-]</label><label class="expand" for="c-41149791">[2 more]</label></div><br/><div class="children"><div class="content">The crypto people really want to write slow code. That&#x27;s what constant time means - your best case is as slow as your worst case. Noone else wants that so there&#x27;s direct tension when they also want to work in some dialect of a general purpose language.</div><br/><div id="41150569" class="c"><input type="checkbox" id="c-41150569" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#41147602">root</a><span>|</span><a href="#41149791">parent</a><span>|</span><a href="#41148046">next</a><span>|</span><label class="collapse" for="c-41150569">[-]</label><label class="expand" for="c-41150569">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The crypto people really want to write slow code. That&#x27;s what constant time means - your best case is as slow as your worst case.<p>At least for a hot path constant-time algo, they want <i>all</i> cases to run as slow as the worst case. But just as important-- they want that algo to be fast as is feasible. AFAICT that&#x27;s the only reason we&#x27;re talking about C&#x2F;C++ here.<p>The problem with writing &quot;slow code&quot; would have been that all the big companies who need to go fast would have chosen to roll their own hot-shot implementations for speed of it.  That would introduce more risk into the most widely-used cases, while the &quot;safe&quot; version would have been relegated to the least used software.<p>Instead, the guy complaining in the article about compiler determinism wrote fast crypto things in C. AFAICT everybody just uses that. And he continues to complain about the potential of compiler indeterminacy-- indeterminacy in the name of optimization-- breaking the fast crypto things.<p>He also points out that in the cases where optimization really matters-- like ffmpeg-- the hot path code is hand-optimized and not left up to the compiler optimizer. I&#x27;d add audio plugins to that.<p>I&#x27;d also add fftw, which apparently has a runtime (method-space?) heuristic that checks which of its buttload of hand-optimized routines win the race on your particular cpu.</div><br/></div></div></div></div></div></div><div id="41148046" class="c"><input type="checkbox" id="c-41148046" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#41147602">prev</a><span>|</span><a href="#41151750">next</a><span>|</span><label class="collapse" for="c-41148046">[-]</label><label class="expand" for="c-41148046">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It would be interesting to study what percentage of security failures can be partly or entirely attributed to compiler &quot;optimizations&quot;.<p>I bet it&#x27;s roughly none.</div><br/><div id="41149777" class="c"><input type="checkbox" id="c-41149777" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41148046">parent</a><span>|</span><a href="#41148521">next</a><span>|</span><label class="collapse" for="c-41149777">[-]</label><label class="expand" for="c-41149777">[2 more]</label></div><br/><div class="children"><div class="content">Deleting null pointer checks in the Linux kernel is the first one to come to mind</div><br/><div id="41149868" class="c"><input type="checkbox" id="c-41149868" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#41148046">root</a><span>|</span><a href="#41149777">parent</a><span>|</span><a href="#41148521">next</a><span>|</span><label class="collapse" for="c-41149868">[-]</label><label class="expand" for="c-41149868">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one CVE, right? How many other vulnerabilities were caused by compiler optimizations, whether they were bugs in the compiler or allowed by the spec?</div><br/></div></div></div></div><div id="41148521" class="c"><input type="checkbox" id="c-41148521" checked=""/><div class="controls bullet"><span class="by">g-b-r</span><span>|</span><a href="#41148046">parent</a><span>|</span><a href="#41149777">prev</a><span>|</span><a href="#41151750">next</a><span>|</span><label class="collapse" for="c-41148521">[-]</label><label class="expand" for="c-41148521">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah, because no security failure was ever related to undefined behavior</div><br/></div></div></div></div><div id="41151750" class="c"><input type="checkbox" id="c-41151750" checked=""/><div class="controls bullet"><span class="by">inglor_cz</span><span>|</span><a href="#41148046">prev</a><span>|</span><a href="#41147796">next</a><span>|</span><label class="collapse" for="c-41151750">[-]</label><label class="expand" for="c-41151750">[1 more]</label></div><br/><div class="children"><div class="content">Similarly to not checking array bounds, undefined behavior was once introduced in the name of efficiency - back in the ages when the performance difference really mattered.<p>And both are just a major headache now, and belong to reasons why few people start new projects in C.<p>I wonder how many such design decisions, relevant today, but with a potential to screw up future humanity, we are making right now.</div><br/></div></div><div id="41147796" class="c"><input type="checkbox" id="c-41147796" checked=""/><div class="controls bullet"><span class="by">quuxplusone</span><span>|</span><a href="#41151750">prev</a><span>|</span><a href="#41150641">next</a><span>|</span><label class="collapse" for="c-41147796">[-]</label><label class="expand" for="c-41147796">[4 more]</label></div><br/><div class="children"><div class="content">The author&#x27;s Clang patch is interesting, but I wonder if what he really wants is, like, a new optimization level &quot;-Obranchless&quot; which is like O2&#x2F;O3 but disables all optimizations which might introduce new conditional branches. Presumably optimizations that _remove_ branches are fine; it&#x27;s just that you don&#x27;t want any deliberately branchless subexpression being replaced with a branch.<p>Basically like today&#x27;s &quot;-Og&#x2F;-Odebug&quot; or &quot;-fno-omit-frame-pointers&quot; but for this specific niche.<p>I&#x27;d be interested to see a post comparing the performance and vulnerability of the mentioned crypto code with and without this (hypothetical) -Obranchless.</div><br/><div id="41147823" class="c"><input type="checkbox" id="c-41147823" checked=""/><div class="controls bullet"><span class="by">quuxplusone</span><span>|</span><a href="#41147796">parent</a><span>|</span><a href="#41150641">next</a><span>|</span><label class="collapse" for="c-41147823">[-]</label><label class="expand" for="c-41147823">[3 more]</label></div><br/><div class="children"><div class="content">... except that even my idea fails to help with software math. If the programmer writes `uint128 a, b; ... a &#x2F;= b` under -Obranchless, does that mean they don&#x27;t want us calling a C++-runtime software division routine (__udiv3 or however it&#x27;s spelled) that might contain branches? And if so, then what on earth do we do instead? — well, just give an error at compile time, I guess.</div><br/><div id="41148143" class="c"><input type="checkbox" id="c-41148143" checked=""/><div class="controls bullet"><span class="by">nolist_policy</span><span>|</span><a href="#41147796">root</a><span>|</span><a href="#41147823">parent</a><span>|</span><a href="#41148135">next</a><span>|</span><label class="collapse" for="c-41148143">[-]</label><label class="expand" for="c-41148143">[1 more]</label></div><br/><div class="children"><div class="content">Not branchless, they just need it to be constant-time. That is definitely doable with pure software division.</div><br/></div></div><div id="41148135" class="c"><input type="checkbox" id="c-41148135" checked=""/><div class="controls bullet"><span class="by">detaro</span><span>|</span><a href="#41147796">root</a><span>|</span><a href="#41147823">parent</a><span>|</span><a href="#41148143">prev</a><span>|</span><a href="#41150641">next</a><span>|</span><label class="collapse" for="c-41148135">[-]</label><label class="expand" for="c-41148135">[1 more]</label></div><br/><div class="children"><div class="content">Yes, a compile failure would IMHO be the only useful result in that case.</div><br/></div></div></div></div></div></div><div id="41150641" class="c"><input type="checkbox" id="c-41150641" checked=""/><div class="controls bullet"><span class="by">gok</span><span>|</span><a href="#41147796">prev</a><span>|</span><a href="#41147438">next</a><span>|</span><label class="collapse" for="c-41150641">[-]</label><label class="expand" for="c-41150641">[1 more]</label></div><br/><div class="children"><div class="content">Computer security is not a serious field. There is no other group that honestly feels &quot;do what I meant, not what I said&quot; is a sign of someone else&#x27;s bug.</div><br/></div></div><div id="41147438" class="c"><input type="checkbox" id="c-41147438" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#41150641">prev</a><span>|</span><a href="#41148090">next</a><span>|</span><label class="collapse" for="c-41147438">[-]</label><label class="expand" for="c-41147438">[10 more]</label></div><br/><div class="children"><div class="content">Compile your code with `-O0` and shut up already.</div><br/><div id="41147549" class="c"><input type="checkbox" id="c-41147549" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41147438">parent</a><span>|</span><a href="#41148698">next</a><span>|</span><label class="collapse" for="c-41147549">[-]</label><label class="expand" for="c-41147549">[8 more]</label></div><br/><div class="children"><div class="content">Unfortunately GCC’s codegen for GCC’s x86 intrinsics headers is really remarkably awful at -O0, particularly around constant loads and broadcasts, because those usually use code that’s as naïve as possible and rely on compiler optimizations to actually turn it into a broadcast, immediate, or whatever. (I haven’t checked Clang.)</div><br/><div id="41147999" class="c"><input type="checkbox" id="c-41147999" checked=""/><div class="controls bullet"><span class="by">jjuhl</span><span>|</span><a href="#41147438">root</a><span>|</span><a href="#41147549">parent</a><span>|</span><a href="#41148029">next</a><span>|</span><label class="collapse" for="c-41147999">[-]</label><label class="expand" for="c-41147999">[5 more]</label></div><br/><div class="children"><div class="content">&quot;Unfortunately GCC’s codegen for GCC’s x86 intrinsics headers is really remarkably awful at -O0&quot; - but that kind of seems to be what is asked for..</div><br/><div id="41148111" class="c"><input type="checkbox" id="c-41148111" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41147438">root</a><span>|</span><a href="#41147999">parent</a><span>|</span><a href="#41148029">next</a><span>|</span><label class="collapse" for="c-41148111">[-]</label><label class="expand" for="c-41148111">[4 more]</label></div><br/><div class="children"><div class="content">No. If I say (e.g.) _mm256_set_epi32(a,b,...,c) with constant arguments (which is the preferred way to make a vector constant), I expect to see 32 aligned bytes in the constant pool and a VMOVDQA in the code, not the mess of VPINSRDs that I’ll get at -O0 and that makes it essentially impossible to write decent vectorized code. The same way that I don’t expect to see a MUL in the assembly when I write sizeof(int) * CHAR_BIT in the source (and IIRC I won’t see one).<p>(Brought to you by a two-week investigation of a mysterious literally 100× slowdown that was caused by the fact that QA always ran a debug build and those are always compiled at -O0.)</div><br/><div id="41149142" class="c"><input type="checkbox" id="c-41149142" checked=""/><div class="controls bullet"><span class="by">jjuhl</span><span>|</span><a href="#41147438">root</a><span>|</span><a href="#41148111">parent</a><span>|</span><a href="#41148029">next</a><span>|</span><label class="collapse" for="c-41149142">[-]</label><label class="expand" for="c-41149142">[3 more]</label></div><br/><div class="children"><div class="content">Seems you want the compiler to do some <i>optimization</i>, to improve the generated code. Or?</div><br/><div id="41149421" class="c"><input type="checkbox" id="c-41149421" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41147438">root</a><span>|</span><a href="#41149142">parent</a><span>|</span><a href="#41148029">next</a><span>|</span><label class="collapse" for="c-41149421">[-]</label><label class="expand" for="c-41149421">[2 more]</label></div><br/><div class="children"><div class="content">In this case, I’d expect constant folding to be the absolute minimum performed at all optimization levels. It is, in fact,—for integers. For (integer) vectors, it’s not, even though it’s much more important there. That’s why advising cryptographers who program using vector intrinsics (aka “assembly except you get a register allocator”) to compile with GCC at -O0 is such bad advice. (Just checked MSVC and it’s better there.)<p>There are, however, more unambiguous cases, where Intel documents an intrinsic to produce an instruction, but GCC does not in fact produce said instruction from said intrinsic unless optimization is enabled. (I just don’t remember them because constants in particular were so ridiculously bad in the specific case I hit.)</div><br/><div id="41149808" class="c"><input type="checkbox" id="c-41149808" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41147438">root</a><span>|</span><a href="#41149421">parent</a><span>|</span><a href="#41148029">next</a><span>|</span><label class="collapse" for="c-41149808">[-]</label><label class="expand" for="c-41149808">[1 more]</label></div><br/><div class="children"><div class="content">If you constant fold and keep things in registers then you generally can&#x27;t look at or change the pieces in a debugger. So everything gets written to the stack where it&#x27;s easy to find.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41148029" class="c"><input type="checkbox" id="c-41148029" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41147438">root</a><span>|</span><a href="#41147549">parent</a><span>|</span><a href="#41147999">prev</a><span>|</span><a href="#41148698">next</a><span>|</span><label class="collapse" for="c-41148029">[-]</label><label class="expand" for="c-41148029">[2 more]</label></div><br/><div class="children"><div class="content">Clang tends to put everything on the stack at -O0 and actually try to do register allocation only as an optimization.</div><br/><div id="41148129" class="c"><input type="checkbox" id="c-41148129" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41147438">root</a><span>|</span><a href="#41148029">parent</a><span>|</span><a href="#41148698">next</a><span>|</span><label class="collapse" for="c-41148129">[-]</label><label class="expand" for="c-41148129">[1 more]</label></div><br/><div class="children"><div class="content">Generally? Sure, so does GCC, but that’s IME less impactful than a pessimized vectorized routine. (Corollary that I hit literally yesterday: exclusively at -O0, until you step past the opening brace—i.e. the function prologue—GDB will show stack garbage instead of the function arguments passed in registers.)</div><br/></div></div></div></div></div></div></div></div><div id="41148090" class="c"><input type="checkbox" id="c-41148090" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41147438">prev</a><span>|</span><a href="#41147804">next</a><span>|</span><label class="collapse" for="c-41148090">[-]</label><label class="expand" for="c-41148090">[1 more]</label></div><br/><div class="children"><div class="content">UB means undefined behavior<p>Somehow it took me long minutes to infer this.</div><br/></div></div><div id="41147804" class="c"><input type="checkbox" id="c-41147804" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41148090">prev</a><span>|</span><label class="collapse" for="c-41147804">[-]</label><label class="expand" for="c-41147804">[4 more]</label></div><br/><div class="children"><div class="content">Complains about branching, but doesn&#x27;t even mention `__builtin_expect_with_probability`.</div><br/><div id="41148072" class="c"><input type="checkbox" id="c-41148072" checked=""/><div class="controls bullet"><span class="by">dchest</span><span>|</span><a href="#41147804">parent</a><span>|</span><a href="#41148057">next</a><span>|</span><label class="collapse" for="c-41148072">[-]</label><label class="expand" for="c-41148072">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no point in mentioning something that doesn&#x27;t solve the issue.</div><br/><div id="41148251" class="c"><input type="checkbox" id="c-41148251" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41147804">root</a><span>|</span><a href="#41148072">parent</a><span>|</span><a href="#41148057">next</a><span>|</span><label class="collapse" for="c-41148251">[-]</label><label class="expand" for="c-41148251">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s as close an answer as you&#x27;re going to get while using a language that&#x27;s unsuitable for the issue.<p>And in practice it&#x27;s pretty reliable at generating `cmov`s ...</div><br/></div></div></div></div><div id="41148057" class="c"><input type="checkbox" id="c-41148057" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#41147804">parent</a><span>|</span><a href="#41148072">prev</a><span>|</span><label class="collapse" for="c-41148057">[-]</label><label class="expand" for="c-41148057">[1 more]</label></div><br/><div class="children"><div class="content">Why is that relevant?</div><br/></div></div></div></div></div></div></div></div></div></body></html>