<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731834066719" as="style"/><link rel="stylesheet" href="styles.css?v=1731834066719"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://simondobson.org/2010/05/14/cs-book-worth-reading-twice/">SICP: The only computer science book worth reading twice? (2010)</a> <span class="domain">(<a href="https://simondobson.org">simondobson.org</a>)</span></div><div class="subtext"><span>pieterr</span> | <span>120 comments</span></div><br/><div><div id="42159121" class="c"><input type="checkbox" id="c-42159121" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#42158506">next</a><span>|</span><label class="collapse" for="c-42159121">[-]</label><label class="expand" for="c-42159121">[41 more]</label></div><br/><div class="children"><div class="content">It’s interesting, SICP and other many other “classic” texts talk about designing programs, but these days I think the much more important skill is designing systems.<p>I don’t know if distributed systems is consider part of “Computer Science” but it is a much more common problem that I see needs to be solved.<p>I try to write systems in the simplest way possible and then use observability tools to figure out where the design is deficient and then maybe I will pull out a data structure or some other “computer sciency” thing to solve that problem. It turns out that big O notation and runtime complexity doesn’t matter the majority of the time and you can solve most problems with arrays and fast CPUs. And even when you have runtime problems you should profile the program to find the hot spots.<p>What computer science doesn’t teach you is how memory caching works in CPUs. Your fancy graph algorithm may have good runtime complexity but it completely hoses the CPU cache and you may have been able to go faster with an array with good cache usage.<p>The much more common problems I have is how to deal with fault tolerance, correctness in distributed locks and queues, and system scalability.<p>Maybe I am just biased because I have a computer&#x2F;electrical engineering background.</div><br/><div id="42161980" class="c"><input type="checkbox" id="c-42161980" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42162797">next</a><span>|</span><label class="collapse" for="c-42161980">[-]</label><label class="expand" for="c-42161980">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but these days I think the much more important skill is designing systems.<p>It is hard to design systems if you don&#x27;t have the perspective of implementing them. Yes, you move up the value chain to designing things, no, but no, you don&#x27;t get to skip gaining experience lower down the value chain.<p>&gt; What computer science doesn’t teach you is how memory caching works in CPUs.<p>That was literally my first quarter in my CS undergrad 30 years ago, the old Hennessy and Patterson book, which I believe is still used today. Are things so different now?<p>&gt; The much more common problems I have is how to deal with fault tolerance, correctness in distributed locks and queues, and system scalability.<p>All of that was covered in my CS undergrad, I wasn&#x27;t even in a fancy computer engineering&#x2F;EE background.</div><br/><div id="42162822" class="c"><input type="checkbox" id="c-42162822" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42161980">parent</a><span>|</span><a href="#42162797">next</a><span>|</span><label class="collapse" for="c-42162822">[-]</label><label class="expand" for="c-42162822">[2 more]</label></div><br/><div class="children"><div class="content">I think CS 30 years ago was closer to computer engineering today.<p>At my uni 10 years ago the CS program didn’t touch anything related to hardware, hell the CS program didn’t even need to take multivariable calculus. In my computer engineering program we covered solid state physics, electromagnetism, digital electronics design, digital signals processing, CPU architecture, compiler design, OS design, algorithms, software engineering, distributed systems design.<p>The computer engineering program took you from solid state physics and transistor design to PAXOS.<p>The CS program was much more focused on logic proofs and more formalism and they never touched anything hardware adjacent.<p>I realize this is different between programs, but from what I read and hear many CS programs these days start at Java and never go down abstraction levels.<p>I do agree with you that learning the fundamentals is important, but I would argue that a SICP type course is not fundamental — physics is fundamental. And once you learn how we use physics to build CPUs you learn that fancy algorithms and complex solutions are not necessary most of the time given how fast computers are today. If you can get your CPU pipelined properly with high cache hits, branch prediction hits, prefetch hits, and SIMD you can easily brute force many problems.<p>And for those 10% of problems which cannot be brute forced, 90% of those problems can be solved with profiling and memoization, and for the 10% of those problems you cannot solve with memoization you can solve 90% of them with b-trees.</div><br/><div id="42162880" class="c"><input type="checkbox" id="c-42162880" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42162822">parent</a><span>|</span><a href="#42162797">next</a><span>|</span><label class="collapse" for="c-42162880">[-]</label><label class="expand" for="c-42162880">[1 more]</label></div><br/><div class="children"><div class="content">A top tier CS program is going to make you learn computer architecture along side automata and proofs. MIT went the extra mile with the SICP, it was honestly a hole I didn’t have access to in my top tier program, but I only realized this because I studied PL in grad school. You should go through it if you haven’t, I think it would have made my ugrad experience better and I definitely benefited from a great well rounded curriculum already (UW CSE is still no slouch, but it isn’t MIT!).<p>If you are into physics and mechanics, then you have to check the SICM (SICP’s less famous cousin) out as well. Again, MIT went the extra mile with that as well.</div><br/></div></div></div></div></div></div><div id="42162797" class="c"><input type="checkbox" id="c-42162797" checked=""/><div class="controls bullet"><span class="by">0xDEAFBEAD</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42161980">prev</a><span>|</span><a href="#42160025">next</a><span>|</span><label class="collapse" for="c-42162797">[-]</label><label class="expand" for="c-42162797">[1 more]</label></div><br/><div class="children"><div class="content">&gt;What computer science doesn’t teach you is how memory caching works in CPUs. Your fancy graph algorithm may have good runtime complexity but it completely hoses the CPU cache and you may have been able to go faster with an array with good cache usage.<p>Traditionally, the field of databases is largely about solving algorithm problems in the scenario where you have much more data that can fit in memory.  Data exists on disk as &quot;pages&quot;, you have a fixed number of &quot;page slots&quot; in RAM.  Moving pages from disk to RAM or RAM to disk is slow, so you want to do as little of that as you can.  This makes trivial problems interesting -- e.g. there&#x27;s no notion of a &#x27;join&#x27; in classic computer science because it&#x27;s too trivial to bother naming.<p>We&#x27;re used to thinking of the study of algorithms as a sort of pure essence, but one could argue that algorithmic efficiency is only meaningful in a particular data and hardware context.  That&#x27;s part of what keeps our jobs interesting, I guess -- otherwise algorithm expertise wouldn&#x27;t be as useful, since you could just apply libraries&#x2F;cookbook solutions everywhere.</div><br/></div></div><div id="42160025" class="c"><input type="checkbox" id="c-42160025" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42162797">prev</a><span>|</span><a href="#42159581">next</a><span>|</span><label class="collapse" for="c-42160025">[-]</label><label class="expand" for="c-42160025">[10 more]</label></div><br/><div class="children"><div class="content">Well CS and software dev in trenches moved a bit.<p>There are still jobs where people write frameworks, database engines or version control tools. Those jobs require heavy CS and algorithms, data structures day to day. But there are less of those jobs nowadays as no one is implementing db engine for their app they just use Postgres.<p>Other jobs that is vast majority is dealing with implementing business logic. Using database with understanding how it works in details is of course going to produce better outcomes. Yet one still can produce great amount of working software without knowing how indexes are stored on disk.<p>Also a lot of CS graduates fell into a trap where they think their job is to write a framework - where in reality they should just use frameworks and implement business logic- while using CS background to fully understand frameworks already existing.</div><br/><div id="42160291" class="c"><input type="checkbox" id="c-42160291" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160025">parent</a><span>|</span><a href="#42160667">next</a><span>|</span><label class="collapse" for="c-42160291">[-]</label><label class="expand" for="c-42160291">[5 more]</label></div><br/><div class="children"><div class="content">&gt; while using CS background to fully understand frameworks already existing.<p>Most frameworks today are so complicated that you typically cannot understand them fully, and even understanding them somewhat partially is more than a full-time job.</div><br/><div id="42161755" class="c"><input type="checkbox" id="c-42161755" checked=""/><div class="controls bullet"><span class="by">porknubbins</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160291">parent</a><span>|</span><a href="#42161127">next</a><span>|</span><label class="collapse" for="c-42161755">[-]</label><label class="expand" for="c-42161755">[3 more]</label></div><br/><div class="children"><div class="content">I wish someone told me this back when I was trying to get a programming job as a self taught programmer. I would do things like try to build a simple React clone thinking it would help me overcome imposter syndrome to fully understand things from the base up, but it was pretty futile because no one really has time to wrap their head around something that big unless they are paid full time to do it.</div><br/></div></div><div id="42161127" class="c"><input type="checkbox" id="c-42161127" checked=""/><div class="controls bullet"><span class="by">hbbio</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160291">parent</a><span>|</span><a href="#42161755">prev</a><span>|</span><a href="#42160667">next</a><span>|</span><label class="collapse" for="c-42161127">[-]</label><label class="expand" for="c-42161127">[1 more]</label></div><br/><div class="children"><div class="content">Last week, after reading Methodology is bullshit here, this was my first thought!<p><a href="https:&#x2F;&#x2F;x.com&#x2F;henri__OK&#x2F;status&#x2F;1854813243916882365" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;henri__OK&#x2F;status&#x2F;1854813243916882365</a></div><br/></div></div></div></div><div id="42160667" class="c"><input type="checkbox" id="c-42160667" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160025">parent</a><span>|</span><a href="#42160291">prev</a><span>|</span><a href="#42160478">next</a><span>|</span><label class="collapse" for="c-42160667">[-]</label><label class="expand" for="c-42160667">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, though new technologies -- web browsers, mobile devices -- have necessitated some framework writing.</div><br/><div id="42160782" class="c"><input type="checkbox" id="c-42160782" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160667">parent</a><span>|</span><a href="#42160478">next</a><span>|</span><label class="collapse" for="c-42160782">[-]</label><label class="expand" for="c-42160782">[2 more]</label></div><br/><div class="children"><div class="content">So yes, some people working at Microsoft, Apple and Google wrote those frameworks. But that&#x27;s like a drop in the bucket.</div><br/><div id="42160790" class="c"><input type="checkbox" id="c-42160790" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160782">parent</a><span>|</span><a href="#42160478">next</a><span>|</span><label class="collapse" for="c-42160790">[-]</label><label class="expand" for="c-42160790">[1 more]</label></div><br/><div class="children"><div class="content">+Meta ;)</div><br/></div></div></div></div></div></div><div id="42160478" class="c"><input type="checkbox" id="c-42160478" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160025">parent</a><span>|</span><a href="#42160667">prev</a><span>|</span><a href="#42159581">next</a><span>|</span><label class="collapse" for="c-42160478">[-]</label><label class="expand" for="c-42160478">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yet one still can produce great amount of working software without knowing how indexes are stored on disk.<p>I agree... up to a point. Most software will likely be replaced&#x2F;obsolete before it even reaches a scale where indexes even matter (at all) given how fast the underlying hardware is at this point.<p>... but I don&#x27;t think this is particularly relevant wrt. the &quot;to CS or not CS&quot; question. If a CS grad has been paying any attention they usually have a decent idea of what kinds of problems are intractable vs. problems that are tractable (but maybe expensive to compute) vs. easy. Also just general exposure to different ways to approach solving a problem (logic programming, pure functional, etc.) can be very valuable. There&#x27;s just much that one couldn&#x27;t come up with on their own if one weren&#x27;t exposed to the ideas from the vast expanse of ideas that are known in CS. (And even a master&#x27;s doesn&#x27;t come close to scratching the surface of it all.)</div><br/></div></div></div></div><div id="42159581" class="c"><input type="checkbox" id="c-42159581" checked=""/><div class="controls bullet"><span class="by">pipes</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42160025">prev</a><span>|</span><a href="#42159469">next</a><span>|</span><label class="collapse" for="c-42159581">[-]</label><label class="expand" for="c-42159581">[1 more]</label></div><br/><div class="children"><div class="content">True. However I find that most junior and even experienced programmers struggle with tactical level coding. I&#x27;m really suffering with this right now because the small component I&#x27;m tasked with making a small change to is annoyingly stateful and deals with 2 abstractions at once. (It processes files and uses the file system and database to store it&#x27;s state). I&#x27;m shocked how badly it has been thought out. I&#x27;ve spent days trying to avoid doing what has gone before, bits bolted on that make it even more difficult to understand. It really seems that pull request culture has just led to any old crap being approved because no one has the band width to think deeply about the actual code. Bring back in person code reviews !</div><br/></div></div><div id="42159469" class="c"><input type="checkbox" id="c-42159469" checked=""/><div class="controls bullet"><span class="by">soegaard</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42159581">prev</a><span>|</span><a href="#42161150">next</a><span>|</span><label class="collapse" for="c-42159469">[-]</label><label class="expand" for="c-42159469">[7 more]</label></div><br/><div class="children"><div class="content">Have you seen<p>&quot;Software Design for Flexibility: How to Avoid Programming Yourself into a Corner&quot;
by Chris Hanson and Gerald Jay Sussman<p>It&#x27;s from 2021.</div><br/><div id="42159520" class="c"><input type="checkbox" id="c-42159520" checked=""/><div class="controls bullet"><span class="by">pipes</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159469">parent</a><span>|</span><a href="#42161150">next</a><span>|</span><label class="collapse" for="c-42159520">[-]</label><label class="expand" for="c-42159520">[6 more]</label></div><br/><div class="children"><div class="content">I hadn&#x27;t, that looks excellent.</div><br/><div id="42162054" class="c"><input type="checkbox" id="c-42162054" checked=""/><div class="controls bullet"><span class="by">crystal_revenge</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159520">parent</a><span>|</span><a href="#42160904">next</a><span>|</span><label class="collapse" for="c-42162054">[-]</label><label class="expand" for="c-42162054">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, while I really <i>want</i> to love Software Design for Flexibility, it&#x27;s clear that Hanson and Sussman haven&#x27;t really <i>solved</i> (or even come close to solving) the problem they have identified in the book.<p>The introduction to that book is <i>brilliant</i> at identifying just how much room software has to grow (you can find similar talks from various Strange Loop sessions Sussman has done), and is really quite inspirational for anyone seriously thinking about the future of computing.<p>But the rest of the book fails to provide a coherent answer to the questions that are brought up in the intro. It shows off some neat functional programming tricks, but repeatedly fails to deliver on solving the (admittedly ambitious) challenges it provides for itself.<p>I&#x27;m still glad I have a copy, and have re-read the first half multiple times now, but sadly it&#x27;s not the book it wants to be. To be fair though, that is because we haven&#x27;t come close to understanding computation enough to solve those problems.<p>It&#x27;s a very ambitious book that falls short of it&#x27;s own ambitious.</div><br/></div></div><div id="42160904" class="c"><input type="checkbox" id="c-42160904" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159520">parent</a><span>|</span><a href="#42162054">prev</a><span>|</span><a href="#42161150">next</a><span>|</span><label class="collapse" for="c-42160904">[-]</label><label class="expand" for="c-42160904">[4 more]</label></div><br/><div class="children"><div class="content">IMO it&#x27;s not excellent. It&#x27;s not like SICP, it&#x27;s obtuse for no reason, I find it a hard slog. Flexibility is good but it seems to try to make every bit of your program flexibile and pluggable and you just need to do something eventually.<p>My opinion, I&#x27;d welcome others on the book; there was a small splash when it came out but not much discussion since.</div><br/><div id="42161097" class="c"><input type="checkbox" id="c-42161097" checked=""/><div class="controls bullet"><span class="by">gregmac</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160904">parent</a><span>|</span><a href="#42161100">next</a><span>|</span><label class="collapse" for="c-42161097">[-]</label><label class="expand" for="c-42161097">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t read the book, but my experience is that the way to make things flexible is to make them simple as possible.<p>When I&#x27;ve used (or built) something that was built in the style like you&#x27;re talking about, it&#x27;s almost always wrong, and the extra complexity and stuff now makes it harder to do right. It&#x27;s not surprising: unknown future requirements are unknown. Over building is trying to predict the future.<p>It&#x27;s like someone building a shed and pouring a foundation that can work for a skyscraper. Except it turns out what we needed was a house that has a different footprint. Or maybe the skyscraper is twice the height and has a stop for the newly-built underneath. Now we have to break apart the foundation before we can even begin work on new stuff; it would have been less work if the original just used a foundation for a shed.</div><br/></div></div><div id="42161100" class="c"><input type="checkbox" id="c-42161100" checked=""/><div class="controls bullet"><span class="by">maroonblazer</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160904">parent</a><span>|</span><a href="#42161097">prev</a><span>|</span><a href="#42161150">next</a><span>|</span><label class="collapse" for="c-42161100">[-]</label><label class="expand" for="c-42161100">[2 more]</label></div><br/><div class="children"><div class="content">Is there another book you&#x27;d recommend - more recent than SICP - for how to avoid programming yourself into a corner?</div><br/><div id="42161502" class="c"><input type="checkbox" id="c-42161502" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42161100">parent</a><span>|</span><a href="#42161150">next</a><span>|</span><label class="collapse" for="c-42161502">[-]</label><label class="expand" for="c-42161502">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about books, but I think the best approach is functional programming in a dynamic language. That could be because I&#x27;m currently an Elixir fanboy, but I think Lisps, especially Scheme or Clojure, or a functional-restricted approach in JavaScript could do it as well. I agree with parent comment that it&#x27;s better to keep things as simple as possible and make the changes when necessary vs. building in all the flexibility in the beginning.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42161150" class="c"><input type="checkbox" id="c-42161150" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42159469">prev</a><span>|</span><a href="#42159448">next</a><span>|</span><label class="collapse" for="c-42161150">[-]</label><label class="expand" for="c-42161150">[2 more]</label></div><br/><div class="children"><div class="content">Scouring SICP cannot imbue the student with mechanical sympathy any more than poring over analysis of Coltrane makes me a saxophonist.<p>Nevertheless. It must be done. Theory <i>and</i> practice.</div><br/><div id="42161820" class="c"><input type="checkbox" id="c-42161820" checked=""/><div class="controls bullet"><span class="by">sameoldtune</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42161150">parent</a><span>|</span><a href="#42159448">next</a><span>|</span><label class="collapse" for="c-42161820">[-]</label><label class="expand" for="c-42161820">[1 more]</label></div><br/><div class="children"><div class="content">Nicely said. The way I think about it: if we can’t write legible and adaptable functions, then we have no chance at making viable systems. All the same engineering skills are at play, just on a different scale.</div><br/></div></div></div></div><div id="42159448" class="c"><input type="checkbox" id="c-42159448" checked=""/><div class="controls bullet"><span class="by">tkiolp4</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42161150">prev</a><span>|</span><a href="#42160394">next</a><span>|</span><label class="collapse" for="c-42159448">[-]</label><label class="expand" for="c-42159448">[6 more]</label></div><br/><div class="children"><div class="content">I find books like SICP interesting and not very useful. I love reading them because I like this stuff, but I don’t get to apply their teachings in real world software. It’s a problem because naturally I want to spend my time reading these kind of books, but if I do that I would be jobless. I need to divide my time between reading pearls like SICP and boring Kafka&#x2F;Postgres&#x2F;Golang&#x2F;K8s&#x2F;AWS documentation.</div><br/><div id="42159780" class="c"><input type="checkbox" id="c-42159780" checked=""/><div class="controls bullet"><span class="by">lovecg</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159448">parent</a><span>|</span><a href="#42162184">next</a><span>|</span><label class="collapse" for="c-42159780">[-]</label><label class="expand" for="c-42159780">[3 more]</label></div><br/><div class="children"><div class="content">I don’t find them useful in the sense of directly applying practical techniques in my day job, but I consider them somewhat necessary background reading to get into the right state of mind. You can very quickly tell when someone never acquired any academic knowledge in this area (or never played with functional languages or similar pastimes) - you can’t explain to those people why modifying global variables all over the place in a large program is a bad idea and other things like that. They just nod along skeptically and then somehow keep stumbling into the same kind of mess over and over.</div><br/><div id="42162043" class="c"><input type="checkbox" id="c-42162043" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159780">parent</a><span>|</span><a href="#42162184">next</a><span>|</span><label class="collapse" for="c-42162043">[-]</label><label class="expand" for="c-42162043">[2 more]</label></div><br/><div class="children"><div class="content">You kind of defeat your own argument. You say it&#x27;s important to learn &quot;academic knowledge&quot;, but then acknowledge the organization will not value your knowledge.<p>I do agree with you though.</div><br/><div id="42162309" class="c"><input type="checkbox" id="c-42162309" checked=""/><div class="controls bullet"><span class="by">lovecg</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42162043">parent</a><span>|</span><a href="#42162184">next</a><span>|</span><label class="collapse" for="c-42162309">[-]</label><label class="expand" for="c-42162309">[1 more]</label></div><br/><div class="children"><div class="content">Well in my experience good organizations do recognize that the better design means lower costs in the long run, and people who don’t get that tend to not get promoted. Communicating this effectively up and down the chain is a whole different art in itself though.</div><br/></div></div></div></div></div></div><div id="42162184" class="c"><input type="checkbox" id="c-42162184" checked=""/><div class="controls bullet"><span class="by">gonzobonzo</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159448">parent</a><span>|</span><a href="#42159780">prev</a><span>|</span><a href="#42160982">next</a><span>|</span><label class="collapse" for="c-42162184">[-]</label><label class="expand" for="c-42162184">[1 more]</label></div><br/><div class="children"><div class="content">One of the problems I&#x27;ve seen is that when new learners and self-taught individuals ask for advice, a lot of software engineers give recommendations based on what they wish their job was or how they would like to imagine themselves.</div><br/></div></div><div id="42160982" class="c"><input type="checkbox" id="c-42160982" checked=""/><div class="controls bullet"><span class="by">sriram_malhar</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159448">parent</a><span>|</span><a href="#42162184">prev</a><span>|</span><a href="#42160394">next</a><span>|</span><label class="collapse" for="c-42160982">[-]</label><label class="expand" for="c-42160982">[1 more]</label></div><br/><div class="children"><div class="content">The first reason why I really loved SICP is that it is based on Scheme, a language with powerful primitives. I came from a self-taught world of PL&#x2F;1, Algol, C, then later C++, Java etc. None of them had closures, hygienic macros, anonymous functions, functional programming, call&#x2F;cc, and of course, &quot;amb&quot;, the non-deterministic choice operator. At an even more basic level, SICP taught me that a lot of non-trivial code can be written with just sequences and maps, with good enough efficiency!<p>Because SICP&#x27;s starting point was so high, they could describe many concepts easily from the ground up, from object oriented programming, backtracking, constraint programming and non-determinism.<p>This taught me a number of techniques to apply in real-life, because I could readily identify the missing building blocks in the language or system I was given to work with. For example, I was able to build a lightweight threads system in Java quite readily because I knew that the missing piece was a continuations feature in Java.<p>See <a href="https:&#x2F;&#x2F;github.com&#x2F;kilim&#x2F;kilim">https:&#x2F;&#x2F;github.com&#x2F;kilim&#x2F;kilim</a></div><br/></div></div></div></div><div id="42160394" class="c"><input type="checkbox" id="c-42160394" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42159448">prev</a><span>|</span><a href="#42160515">next</a><span>|</span><label class="collapse" for="c-42160394">[-]</label><label class="expand" for="c-42160394">[1 more]</label></div><br/><div class="children"><div class="content">&gt; these days I think the much more important skill is designing systems<p>That&#x27;s true, but that doesn&#x27;t mean that there is no value in having an understanding of how established technology works under the hood.<p>&gt; What computer science doesn’t teach you is how memory caching works in CPUs.<p>That is also a very good point.  There is a lot of daylight between the lambda calculus and real systems.</div><br/></div></div><div id="42160515" class="c"><input type="checkbox" id="c-42160515" checked=""/><div class="controls bullet"><span class="by">esfandia</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42160394">prev</a><span>|</span><a href="#42159154">next</a><span>|</span><label class="collapse" for="c-42160515">[-]</label><label class="expand" for="c-42160515">[3 more]</label></div><br/><div class="children"><div class="content">The right book for the right problem. SICP isn&#x27;t meant to teach you how to tackle fault-tolerance in a complex distributed system. Here is a textbook that talks about distributed systems (van Steen and Tannenbaum):<p><a href="https:&#x2F;&#x2F;www.amazon.ca&#x2F;Distributed-Systems-Maarten-van-Steen&#x2F;dp&#x2F;1543057381" rel="nofollow">https:&#x2F;&#x2F;www.amazon.ca&#x2F;Distributed-Systems-Maarten-van-Steen&#x2F;...</a></div><br/><div id="42162917" class="c"><input type="checkbox" id="c-42162917" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160515">parent</a><span>|</span><a href="#42161736">next</a><span>|</span><label class="collapse" for="c-42162917">[-]</label><label class="expand" for="c-42162917">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I have the distributed system book from van Steen :)</div><br/></div></div><div id="42161736" class="c"><input type="checkbox" id="c-42161736" checked=""/><div class="controls bullet"><span class="by">nioj</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42160515">parent</a><span>|</span><a href="#42162917">prev</a><span>|</span><a href="#42159154">next</a><span>|</span><label class="collapse" for="c-42161736">[-]</label><label class="expand" for="c-42161736">[1 more]</label></div><br/><div class="children"><div class="content">You can also get a free PDF version of that textbook here <a href="https:&#x2F;&#x2F;www.distributed-systems.net&#x2F;index.php&#x2F;books&#x2F;ds4&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.distributed-systems.net&#x2F;index.php&#x2F;books&#x2F;ds4&#x2F;</a> (you only need to provide an email)</div><br/></div></div></div></div><div id="42159154" class="c"><input type="checkbox" id="c-42159154" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42160515">prev</a><span>|</span><a href="#42160581">next</a><span>|</span><label class="collapse" for="c-42159154">[-]</label><label class="expand" for="c-42159154">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re in luck. Part 5 of the book is about building a virtual machine to run lisp simalated at the register lelvel: <a href="https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;books_pres_0&#x2F;6515&#x2F;sicp.zip&#x2F;full-text&#x2F;book&#x2F;book-Z-H-32.html#%_sec_5.2" rel="nofollow">https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;b...</a><p>Writing a network between n such machines is left as an exercise to the reader.</div><br/></div></div><div id="42160581" class="c"><input type="checkbox" id="c-42160581" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42159154">prev</a><span>|</span><a href="#42160656">next</a><span>|</span><label class="collapse" for="c-42160581">[-]</label><label class="expand" for="c-42160581">[1 more]</label></div><br/><div class="children"><div class="content">There are still innumerable people writing standalone programs, single-purpose embedded systems, independent components and libraries, etc<p>The industry has <i>expanded</i> to include a lot of large-scale distributed cloud projects (often where we might have expected mainframes and cobol before), with many of today&#x27;s largest employers doing most of their work there, but none of that other stuff really went away. It&#x27;s still being done every day.<p>You need a book for what <i>you&#x27;re</i> doing, and not every book is going to be that. Apparently, SICP is not it. I possess and have read many books, and only some small number of them are applicable to the projects I&#x27;m working on at any time.<p>They don&#x27;t compete with each other, they complement each other.</div><br/></div></div><div id="42160656" class="c"><input type="checkbox" id="c-42160656" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42160581">prev</a><span>|</span><a href="#42159177">next</a><span>|</span><label class="collapse" for="c-42160656">[-]</label><label class="expand" for="c-42160656">[1 more]</label></div><br/><div class="children"><div class="content">I think the classic CLR text is great but, yeah, caches through quite a monkey wrench into naive big O analysis.<p>Still, I think the time investment to learn algos and data structures isn&#x27;t too much of a burden.</div><br/></div></div><div id="42159177" class="c"><input type="checkbox" id="c-42159177" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#42159121">parent</a><span>|</span><a href="#42160656">prev</a><span>|</span><a href="#42159600">next</a><span>|</span><label class="collapse" for="c-42159177">[-]</label><label class="expand" for="c-42159177">[2 more]</label></div><br/><div class="children"><div class="content">If you knew how to design programs you could run it all on a single box and wouldn’t have to design “systems.”<p>I’m being slightly facetious, but only slightly. If you really think everything is solvable with arrays, you are not going to scale well and of course you’re going to need to throw a lot more hardware at the problem.</div><br/><div id="42162909" class="c"><input type="checkbox" id="c-42162909" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#42159121">root</a><span>|</span><a href="#42159177">parent</a><span>|</span><a href="#42159600">next</a><span>|</span><label class="collapse" for="c-42162909">[-]</label><label class="expand" for="c-42162909">[1 more]</label></div><br/><div class="children"><div class="content">My argument is that 90% of problems can be solved with arrays, 5% of problems can be solved with memoization, 3% of problems can be solved with b-trees, and 2% of problems with other data structures.<p>It is good to know that solutions to the 2% exists, but what we should be focusing on is writing the simplest code possible which solves the problem and then only optimize afterwards using a profiler.
God forbid you have to work on some codebase written by someone who believes they are the second coming of haskell with crazy recursion and backtracing, monads, red black trees, and a DSL on top of the whole thing.<p>You are right that many problems can be solved with a single box, but my argument is that you do not need fancy algorithms to solve problems on a single box. We should strive to use single boxes whenever possible to reduce complexity.<p>Computation is designed by humans to serve humans, we should make it as easy as possible for humans to understand. I’m probably going to start a flamewar here, but this is why simple solutions like UNIX and golang have prevailed in the past. Simple code is easy to understand and therefore it is easy to modify and reason about. Some people think simple means that you decompose programs into the smallest possible functional parts, but simple to me is a 500 line main function.</div><br/></div></div></div></div></div></div><div id="42158506" class="c"><input type="checkbox" id="c-42158506" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#42159121">prev</a><span>|</span><a href="#42161495">next</a><span>|</span><label class="collapse" for="c-42158506">[-]</label><label class="expand" for="c-42158506">[8 more]</label></div><br/><div class="children"><div class="content">The article has a broken link for the free copy:<p><a href="https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;books_pres_0&#x2F;6515&#x2F;sicp.zip&#x2F;full-text&#x2F;book&#x2F;book.html" rel="nofollow">https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;b...</a><p><a href="https:&#x2F;&#x2F;web.mit.edu&#x2F;6.001&#x2F;6.037&#x2F;sicp.pdf" rel="nofollow">https:&#x2F;&#x2F;web.mit.edu&#x2F;6.001&#x2F;6.037&#x2F;sicp.pdf</a><p>I hadn&#x27;t seen a blessed PDF version until today.  Circa 2001, only the HTML version was freely available, and someone converted it to TeXinfo: <a href="https:&#x2F;&#x2F;www.neilvandyke.org&#x2F;sicp-texi&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.neilvandyke.org&#x2F;sicp-texi&#x2F;</a><p>If anyone wants to work through SICP today, you can run the code in MIT Scheme, or in DrRacket: <a href="https:&#x2F;&#x2F;www.neilvandyke.org&#x2F;racket&#x2F;sicp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.neilvandyke.org&#x2F;racket&#x2F;sicp&#x2F;</a></div><br/><div id="42158920" class="c"><input type="checkbox" id="c-42158920" checked=""/><div class="controls bullet"><span class="by">kkylin</span><span>|</span><a href="#42158506">parent</a><span>|</span><a href="#42158584">next</a><span>|</span><label class="collapse" for="c-42158920">[-]</label><label class="expand" for="c-42158920">[3 more]</label></div><br/><div class="children"><div class="content">For anyone wishing to try: the maintainers of MIT Scheme no longer provide a .dmg but you can download and build the x86_64 version of MIT Scheme.  The current release (v12.1) works on a Mac running Sequoia with Intel CPU or on Apple silicon via Rosetta.  But the native code compiler (not necessary for SICP AFAIK) is a little broken.  (Anecdotally it worked on macOS prior to Monterey, so maybe an Apple-supplied dependency changed.  Haven&#x27;t tracked down the issue.)<p>All of that is to say: if you do not need MIT Scheme and don&#x27;t want to fuss with compiling it, then Racket might be a better way to go.</div><br/><div id="42160685" class="c"><input type="checkbox" id="c-42160685" checked=""/><div class="controls bullet"><span class="by">xdavidliu</span><span>|</span><a href="#42158506">root</a><span>|</span><a href="#42158920">parent</a><span>|</span><a href="#42158584">next</a><span>|</span><label class="collapse" for="c-42160685">[-]</label><label class="expand" for="c-42160685">[2 more]</label></div><br/><div class="children"><div class="content">most package managers have it, including apt and brew, so most of the time no need to build your own</div><br/><div id="42161618" class="c"><input type="checkbox" id="c-42161618" checked=""/><div class="controls bullet"><span class="by">kkylin</span><span>|</span><a href="#42158506">root</a><span>|</span><a href="#42160685">parent</a><span>|</span><a href="#42158584">next</a><span>|</span><label class="collapse" for="c-42161618">[-]</label><label class="expand" for="c-42161618">[1 more]</label></div><br/><div class="children"><div class="content">Good point!  though my comment about the native code compiler being broken still applies to the brew-installed version</div><br/></div></div></div></div></div></div><div id="42158584" class="c"><input type="checkbox" id="c-42158584" checked=""/><div class="controls bullet"><span class="by">xdavidliu</span><span>|</span><a href="#42158506">parent</a><span>|</span><a href="#42158920">prev</a><span>|</span><a href="#42158769">next</a><span>|</span><label class="collapse" for="c-42158584">[-]</label><label class="expand" for="c-42158584">[1 more]</label></div><br/><div class="children"><div class="content">one thing to note is that the second chapter&#x27;s &quot;picture language&quot; is not supported in MIT Scheme in 2024. There used to be a package but it&#x27;s like 2 decades out of maintenance. In Dr. Racket however, there is a package specifically for working through those problems.</div><br/></div></div><div id="42158769" class="c"><input type="checkbox" id="c-42158769" checked=""/><div class="controls bullet"><span class="by">owl_vision</span><span>|</span><a href="#42158506">parent</a><span>|</span><a href="#42158584">prev</a><span>|</span><a href="#42161636">next</a><span>|</span><label class="collapse" for="c-42158769">[-]</label><label class="expand" for="c-42158769">[1 more]</label></div><br/><div class="children"><div class="content">Dr Racket has SICP and HTDP as a teaching pack.</div><br/></div></div><div id="42161636" class="c"><input type="checkbox" id="c-42161636" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#42158506">parent</a><span>|</span><a href="#42158769">prev</a><span>|</span><a href="#42158866">next</a><span>|</span><label class="collapse" for="c-42161636">[-]</label><label class="expand" for="c-42161636">[1 more]</label></div><br/><div class="children"><div class="content">Just as a data point, I&#x27;d recommend going through it in Racket, which I believe has an explicit SICP mode. I went through it in GNU Guile and it was a pain because there were some minor syntactic differences between Guile and MIT Scheme.</div><br/></div></div><div id="42158866" class="c"><input type="checkbox" id="c-42158866" checked=""/><div class="controls bullet"><span class="by">jgon</span><span>|</span><a href="#42158506">parent</a><span>|</span><a href="#42161636">prev</a><span>|</span><a href="#42161495">next</a><span>|</span><label class="collapse" for="c-42158866">[-]</label><label class="expand" for="c-42158866">[1 more]</label></div><br/><div class="children"><div class="content">The texinfo version was I believe the source for the really nice HTML5 version if you want to read it in a browser, but with nice formatting that the MIT original version: <a href="https:&#x2F;&#x2F;sarabander.github.io&#x2F;sicp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sarabander.github.io&#x2F;sicp&#x2F;</a></div><br/></div></div></div></div><div id="42161495" class="c"><input type="checkbox" id="c-42161495" checked=""/><div class="controls bullet"><span class="by">freethejazz</span><span>|</span><a href="#42158506">prev</a><span>|</span><a href="#42162727">next</a><span>|</span><label class="collapse" for="c-42161495">[-]</label><label class="expand" for="c-42161495">[2 more]</label></div><br/><div class="children"><div class="content">I haven’t seen it in the comments yet, but you can watch Abelson and Sussman teaching the material from this book from recorded lectures in 1986.<p>I still find their description of how to create and group abstractions in various layers to be useful personally and as a mentor. (In the videos, lesson 3A, 1:07:55)<p><a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;playlist?list=PLE18841CABEA24090" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;playlist?list=PLE18841CABEA24090</a></div><br/><div id="42161522" class="c"><input type="checkbox" id="c-42161522" checked=""/><div class="controls bullet"><span class="by">selimthegrim</span><span>|</span><a href="#42161495">parent</a><span>|</span><a href="#42162727">next</a><span>|</span><label class="collapse" for="c-42161522">[-]</label><label class="expand" for="c-42161522">[1 more]</label></div><br/><div class="children"><div class="content">The Kabbalah joke gets me every time.</div><br/></div></div></div></div><div id="42162727" class="c"><input type="checkbox" id="c-42162727" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#42161495">prev</a><span>|</span><a href="#42159453">next</a><span>|</span><label class="collapse" for="c-42162727">[-]</label><label class="expand" for="c-42162727">[1 more]</label></div><br/><div class="children"><div class="content">Next to SICP, I like the entire &quot;The Little *&quot; series as reading twice (or more) material. And Types and Programming languages. For applicable (in what I do anyway) CS. But not only reading though; implementing as well; I need to repeat these things otherwise I forget parts.<p>I myself, but probably because I knew and respect the guy, I reread the works of Dijkstra ever so often; books + papers. Not really applicable anymore, but good for the brain and he was a good writer (imho).</div><br/></div></div><div id="42159453" class="c"><input type="checkbox" id="c-42159453" checked=""/><div class="controls bullet"><span class="by">MikeTaylor</span><span>|</span><a href="#42162727">prev</a><span>|</span><a href="#42158703">next</a><span>|</span><label class="collapse" for="c-42159453">[-]</label><label class="expand" for="c-42159453">[2 more]</label></div><br/><div class="children"><div class="content">Just dropping in to say that The Elements of Programming Style is worth reading three times — and I have read it many more times than that, and benefitted from it. Here&#x27;s my review (from 2010) if you&#x27;re interested: <a href="https:&#x2F;&#x2F;reprog.wordpress.com&#x2F;2010&#x2F;03&#x2F;06&#x2F;programming-books-part-2-the-elements-of-programming-style&#x2F;" rel="nofollow">https:&#x2F;&#x2F;reprog.wordpress.com&#x2F;2010&#x2F;03&#x2F;06&#x2F;programming-books-pa...</a></div><br/><div id="42160588" class="c"><input type="checkbox" id="c-42160588" checked=""/><div class="controls bullet"><span class="by">jacoblambda</span><span>|</span><a href="#42159453">parent</a><span>|</span><a href="#42158703">next</a><span>|</span><label class="collapse" for="c-42160588">[-]</label><label class="expand" for="c-42160588">[1 more]</label></div><br/><div class="children"><div class="content">Oh and here I thought you were talking about Elements of Programming by Stepanov and McJones which tbh I&#x27;d give the same recommendation&#x2F;review.<p><a href="https:&#x2F;&#x2F;elementsofprogramming.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;elementsofprogramming.com&#x2F;</a></div><br/></div></div></div></div><div id="42158703" class="c"><input type="checkbox" id="c-42158703" checked=""/><div class="controls bullet"><span class="by">alabhyajindal</span><span>|</span><a href="#42159453">prev</a><span>|</span><a href="#42159383">next</a><span>|</span><label class="collapse" for="c-42158703">[-]</label><label class="expand" for="c-42158703">[15 more]</label></div><br/><div class="children"><div class="content">I really wanted to like SICP but Lisp throws me off. I love Haskell and Standard ML however! Did others have a similar experience? Might be interesting to read a book similar in spirit to SICP but using a different language as a vehicle (No, I don&#x27;t want to do SICP in JavaScript).</div><br/><div id="42162892" class="c"><input type="checkbox" id="c-42162892" checked=""/><div class="controls bullet"><span class="by">bez00m</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42159370">next</a><span>|</span><label class="collapse" for="c-42162892">[-]</label><label class="expand" for="c-42162892">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Functional Programming in Scala&quot; aka &quot;Red Book of Scala&quot; is a the one that IMO teaches to think the same way as SICP, while using a typed language. The books stand next to each other on my bookshelf, definitely worth reading.</div><br/></div></div><div id="42159370" class="c"><input type="checkbox" id="c-42159370" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42162892">prev</a><span>|</span><a href="#42160635">next</a><span>|</span><label class="collapse" for="c-42159370">[-]</label><label class="expand" for="c-42159370">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in a 1987 article titled &quot;A Critique of Abelson and Sussman or Why Calculating is Better than Scheming&quot; (<a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;24697.24706" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;24697.24706</a>), where the author advocates the use of KRC or Miranda as alternatives to Scheme.  I don&#x27;t know much about KRC, but Miranda is a statically-typed functional programming language that influenced Haskell.</div><br/></div></div><div id="42160635" class="c"><input type="checkbox" id="c-42160635" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42159370">prev</a><span>|</span><a href="#42158826">next</a><span>|</span><label class="collapse" for="c-42160635">[-]</label><label class="expand" for="c-42160635">[5 more]</label></div><br/><div class="children"><div class="content">SICP isn&#x27;t a book about Lisp, however it uses some of Lisp&#x27;s unique properties to demonstrate important concepts that other languages can&#x27;t easily replicate. A book that&#x27;s meant to be similar to SICP that doesn&#x27;t use Scheme or Lisp would not be anything like SICP, or at least not teach the same things. Haskell and ML are in my experience much harder to understand than Scheme, so I&#x27;m wondering what your difficulty is?</div><br/><div id="42160673" class="c"><input type="checkbox" id="c-42160673" checked=""/><div class="controls bullet"><span class="by">ok123456</span><span>|</span><a href="#42158703">root</a><span>|</span><a href="#42160635">parent</a><span>|</span><a href="#42158826">next</a><span>|</span><label class="collapse" for="c-42160673">[-]</label><label class="expand" for="c-42160673">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a SICP edition done in Javascript.</div><br/><div id="42160850" class="c"><input type="checkbox" id="c-42160850" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#42158703">root</a><span>|</span><a href="#42160673">parent</a><span>|</span><a href="#42158826">next</a><span>|</span><label class="collapse" for="c-42160850">[-]</label><label class="expand" for="c-42160850">[3 more]</label></div><br/><div class="children"><div class="content">Have you looked at it? It&#x27;s an abomination. The point of SICP isn&#x27;t Scheme or the syntax of Scheme, but what it represents. Whoever made the Javascript rewrite didn&#x27;t understand that. You can&#x27;t write a metacircular interpreter in Javascript, because Javascript is not homoiconic.</div><br/><div id="42162117" class="c"><input type="checkbox" id="c-42162117" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42158703">root</a><span>|</span><a href="#42160850">parent</a><span>|</span><a href="#42161431">next</a><span>|</span><label class="collapse" for="c-42162117">[-]</label><label class="expand" for="c-42162117">[1 more]</label></div><br/><div class="children"><div class="content"><i>You can&#x27;t write a metacircular interpreter in Javascript, because Javascript is not homoiconic.</i><p>Is that a downside? I never wrote or used metacurcular interpreter in my life and still don’t know why I had to read about it. Is it an interesting implementation technique of lisp? Yes. Does anyone really need that?<p>You can rip off that part and everything that follows and that will be enough for a regular programmer. No one itt needs to know how to design metacircular interpreter on register machines.</div><br/></div></div><div id="42161431" class="c"><input type="checkbox" id="c-42161431" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#42158703">root</a><span>|</span><a href="#42160850">parent</a><span>|</span><a href="#42162117">prev</a><span>|</span><a href="#42158826">next</a><span>|</span><label class="collapse" for="c-42161431">[-]</label><label class="expand" for="c-42161431">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure someone wrote a very basic, very literal scheme to JavaScript transpiler and just ran the book&#x27;s code through it. The results look nothing like what any normal person would write.</div><br/></div></div></div></div></div></div></div></div><div id="42158826" class="c"><input type="checkbox" id="c-42158826" checked=""/><div class="controls bullet"><span class="by">rustybolt</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42160635">prev</a><span>|</span><a href="#42160603">next</a><span>|</span><label class="collapse" for="c-42158826">[-]</label><label class="expand" for="c-42158826">[2 more]</label></div><br/><div class="children"><div class="content">I really wanted to like SICP and I probably would have if I read it 15 years ago. I started reading it last month and I found it to be too broad. It covers too much interesting mathematical principles and then jumps to the next one right when it starts to get interesting. In other words, it&#x27;s too shallow.<p>It probably doesn&#x27;t help that I&#x27;ve seen many courses&#x2F;documents that are (in hindsight) derivatives from SICP, so I have the nagging thought &quot;not this <i>again</i>&quot; when a topic is introduced in SICP.</div><br/><div id="42159553" class="c"><input type="checkbox" id="c-42159553" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42158703">root</a><span>|</span><a href="#42158826">parent</a><span>|</span><a href="#42160603">next</a><span>|</span><label class="collapse" for="c-42159553">[-]</label><label class="expand" for="c-42159553">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s written for engineers, they already know the math, but they don&#x27;t know how to design and implement virtual machines, objects, compilers and whatnot that it shows how to do.</div><br/></div></div></div></div><div id="42160603" class="c"><input type="checkbox" id="c-42160603" checked=""/><div class="controls bullet"><span class="by">2c2c2c</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42158826">prev</a><span>|</span><a href="#42160830">next</a><span>|</span><label class="collapse" for="c-42160603">[-]</label><label class="expand" for="c-42160603">[1 more]</label></div><br/><div class="children"><div class="content">i thought berkeley was using a modified version of the book using python a few years back</div><br/></div></div><div id="42160830" class="c"><input type="checkbox" id="c-42160830" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42160603">prev</a><span>|</span><a href="#42161196">next</a><span>|</span><label class="collapse" for="c-42160830">[-]</label><label class="expand" for="c-42160830">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why Lisp throws you off. I only read SICP after I became proficient in Haskell and it is just fine.</div><br/></div></div><div id="42161196" class="c"><input type="checkbox" id="c-42161196" checked=""/><div class="controls bullet"><span class="by">whimsicalism</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42160830">prev</a><span>|</span><a href="#42158751">next</a><span>|</span><label class="collapse" for="c-42161196">[-]</label><label class="expand" for="c-42161196">[1 more]</label></div><br/><div class="children"><div class="content">yes, i like ML (well.. ocaml) and bounced off SICP for the same reason. It was actually SICM that made me come back and stick with it, the ideas were just too interesting (whereas for SICP it was a lot of ideas I was already familiar with)</div><br/></div></div><div id="42158751" class="c"><input type="checkbox" id="c-42158751" checked=""/><div class="controls bullet"><span class="by">horeszko</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42161196">prev</a><span>|</span><a href="#42159255">next</a><span>|</span><label class="collapse" for="c-42158751">[-]</label><label class="expand" for="c-42158751">[1 more]</label></div><br/><div class="children"><div class="content">I think there is a Python version if that floats your boat</div><br/></div></div><div id="42159255" class="c"><input type="checkbox" id="c-42159255" checked=""/><div class="controls bullet"><span class="by">hluska</span><span>|</span><a href="#42158703">parent</a><span>|</span><a href="#42158751">prev</a><span>|</span><a href="#42159383">next</a><span>|</span><label class="collapse" for="c-42159255">[-]</label><label class="expand" for="c-42159255">[1 more]</label></div><br/><div class="children"><div class="content">I can identify with that - Lisp throws me off (because I’m not smart enough). But I ended up forcing myself to work through it and learned a tremendous amount because I’m not smart enough to work with a lisp. It felt like I spent so much time just reading through the code that I ended up learning more than I would in a language I’m comfortable with.<p>There is a Python version of SICP. I have never worked through it or even given it more than a cursory scan so this is not an endorsement more just a link to prove it exists:<p><a href="https:&#x2F;&#x2F;wizardforcel.gitbooks.io&#x2F;sicp-in-python&#x2F;content&#x2F;0.html" rel="nofollow">https:&#x2F;&#x2F;wizardforcel.gitbooks.io&#x2F;sicp-in-python&#x2F;content&#x2F;0.ht...</a></div><br/></div></div></div></div><div id="42159383" class="c"><input type="checkbox" id="c-42159383" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42158703">prev</a><span>|</span><a href="#42158508">next</a><span>|</span><label class="collapse" for="c-42159383">[-]</label><label class="expand" for="c-42159383">[3 more]</label></div><br/><div class="children"><div class="content">Curious to hear folks opinion on the newer Software Design for Flexibility: How to Avoid Programming Yourself into a Corner (<a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;gp&#x2F;aw&#x2F;d&#x2F;0262045494" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;gp&#x2F;aw&#x2F;d&#x2F;0262045494</a>)?</div><br/><div id="42159960" class="c"><input type="checkbox" id="c-42159960" checked=""/><div class="controls bullet"><span class="by">golly_ned</span><span>|</span><a href="#42159383">parent</a><span>|</span><a href="#42158508">next</a><span>|</span><label class="collapse" for="c-42159960">[-]</label><label class="expand" for="c-42159960">[2 more]</label></div><br/><div class="children"><div class="content">It’s a much, much denser successor to sicp. I hadn’t succeeded in self-studying with it despite strong lisp&#x2F;scheme chops and strong affinity for sicp.</div><br/><div id="42162810" class="c"><input type="checkbox" id="c-42162810" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42159383">root</a><span>|</span><a href="#42159960">parent</a><span>|</span><a href="#42158508">next</a><span>|</span><label class="collapse" for="c-42162810">[-]</label><label class="expand" for="c-42162810">[1 more]</label></div><br/><div class="children"><div class="content">I have a copy.  Found it fun, but not quite as mind shifting.  I think I need to try it again, but I am curious how others feel.</div><br/></div></div></div></div></div></div><div id="42158508" class="c"><input type="checkbox" id="c-42158508" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42159383">prev</a><span>|</span><a href="#42159540">next</a><span>|</span><label class="collapse" for="c-42158508">[-]</label><label class="expand" for="c-42158508">[1 more]</label></div><br/><div class="children"><div class="content">My second reading made me dig the footnotes and references, and there&#x27;s a big world of beauty out there too. IIRC there&#x27;s a paper where Sussman and some team made a custom design programmable processor to compute celestial bodies properties (trajectories). Mind bending as usual.</div><br/></div></div><div id="42159540" class="c"><input type="checkbox" id="c-42159540" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#42158508">prev</a><span>|</span><a href="#42158940">next</a><span>|</span><label class="collapse" for="c-42159540">[-]</label><label class="expand" for="c-42159540">[2 more]</label></div><br/><div class="children"><div class="content">SICP helped me understand early on that there were many models of programming, even though I&#x27;d learned a limited number in my undergraduate. It was one of the books that helped me feel equipped to read the docs of any language, library or framework and have some notion of how to orient myself.</div><br/><div id="42162214" class="c"><input type="checkbox" id="c-42162214" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42159540">parent</a><span>|</span><a href="#42158940">next</a><span>|</span><label class="collapse" for="c-42162214">[-]</label><label class="expand" for="c-42162214">[1 more]</label></div><br/><div class="children"><div class="content">One of the best programming classes I had in college was a comparative languages course where multiple languages were covered, each in two week or so blocks.</div><br/></div></div></div></div><div id="42158940" class="c"><input type="checkbox" id="c-42158940" checked=""/><div class="controls bullet"><span class="by">myleshenderson</span><span>|</span><a href="#42159540">prev</a><span>|</span><a href="#42158530">next</a><span>|</span><label class="collapse" for="c-42158940">[-]</label><label class="expand" for="c-42158940">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been programming for 25 years and have owned the book for about 10 years. I just recently started to work through it and started with Dr. Racket.<p>There are things to love about Dr. Racket: hovering over a variable and visually seeing its connections to other places in the code is really cool. But ultimately I was a bit frustrated that it wasn&#x27;t vs code.<p>So I stood up an configuration that let me use vs code (cursor actually) to work through the exercises. The LLM integration into cursor is cool as you can give it your code and whatever narrative you wrote and ask for feedback.<p>I am a tiny way through the exercises but having turned my code, the responses that I write, and the feedback that I get from the LLM into a static site.<p>It&#x27;s been a fun way to spend a little time. For sure, I&#x27;m not getting the full benefit of working through SICP just with my own thoughts (without the aid of an LLM), but it&#x27;s neat to see how you can integrate an LLM into the exercise.</div><br/></div></div><div id="42158530" class="c"><input type="checkbox" id="c-42158530" checked=""/><div class="controls bullet"><span class="by">jasonpeacock</span><span>|</span><a href="#42158940">prev</a><span>|</span><a href="#42162029">next</a><span>|</span><label class="collapse" for="c-42158530">[-]</label><label class="expand" for="c-42158530">[4 more]</label></div><br/><div class="children"><div class="content">Original version: <a href="https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;books_pres_0&#x2F;6515&#x2F;sicp.zip&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;b...</a><p>Javascript version: <a href="https:&#x2F;&#x2F;sourceacademy.org&#x2F;sicpjs&#x2F;index" rel="nofollow">https:&#x2F;&#x2F;sourceacademy.org&#x2F;sicpjs&#x2F;index</a></div><br/><div id="42158564" class="c"><input type="checkbox" id="c-42158564" checked=""/><div class="controls bullet"><span class="by">ElD0C</span><span>|</span><a href="#42158530">parent</a><span>|</span><a href="#42162029">next</a><span>|</span><label class="collapse" for="c-42158564">[-]</label><label class="expand" for="c-42158564">[3 more]</label></div><br/><div class="children"><div class="content">And the Python version: <a href="http:&#x2F;&#x2F;www.composingprograms.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.composingprograms.com&#x2F;</a></div><br/><div id="42158591" class="c"><input type="checkbox" id="c-42158591" checked=""/><div class="controls bullet"><span class="by">xdavidliu</span><span>|</span><a href="#42158530">root</a><span>|</span><a href="#42158564">parent</a><span>|</span><a href="#42162029">next</a><span>|</span><label class="collapse" for="c-42158591">[-]</label><label class="expand" for="c-42158591">[2 more]</label></div><br/><div class="children"><div class="content">this is not the Python version of SICP. It&#x27;s a different book inspired by SICP. There&#x27;s no &quot;picture language&quot; in chapter 2, and there&#x27;s no &quot;metacircular evaluator&quot; and &quot;register machine&quot; in chapter 5.</div><br/><div id="42160969" class="c"><input type="checkbox" id="c-42160969" checked=""/><div class="controls bullet"><span class="by">ted_dunning</span><span>|</span><a href="#42158530">root</a><span>|</span><a href="#42158591">parent</a><span>|</span><a href="#42162029">next</a><span>|</span><label class="collapse" for="c-42160969">[-]</label><label class="expand" for="c-42160969">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to understand the point without these.</div><br/></div></div></div></div></div></div></div></div><div id="42162029" class="c"><input type="checkbox" id="c-42162029" checked=""/><div class="controls bullet"><span class="by">nomilk</span><span>|</span><a href="#42158530">prev</a><span>|</span><a href="#42162717">next</a><span>|</span><label class="collapse" for="c-42162029">[-]</label><label class="expand" for="c-42162029">[3 more]</label></div><br/><div class="children"><div class="content">I considered reading SICP recently but this changed my mind:<p>&gt; It&#x27;s old and feels old. originally in scheme, they recently re released the book in JavaScript which is more approachable to today&#x27;s audiences and there are still good things in there about encapsulation and building dsls. ymmv. Though the language and programming design concepts hold up, we&#x27;re playing at higher levels of abstraction on more powerful machines and consequently the examples sometimes seem too tiny and simple.<p>I had studied economics in a similar way, but learning slightly old&#x2F;outdated ideas demotivated me - I was much more interested in learning what works and what&#x27;s considered the best way to do things, not what had been considered a good idea at some point in the past.<p>I don&#x27;t want to be a downer on SICP (especially since I haven&#x27;t even read it), but I hope this info might help others (or elicit a strong refutation).</div><br/><div id="42162080" class="c"><input type="checkbox" id="c-42162080" checked=""/><div class="controls bullet"><span class="by">crystal_revenge</span><span>|</span><a href="#42162029">parent</a><span>|</span><a href="#42162316">next</a><span>|</span><label class="collapse" for="c-42162080">[-]</label><label class="expand" for="c-42162080">[1 more]</label></div><br/><div class="children"><div class="content">Scheme as basically an implementation of the untyped lambda calculus will eternally be a good frame work to think about the problems of computation in.<p>In the more practical area Racket (the most modern Scheme) has basically any practical functionality you would want, while amazingly remaining a platform for an incredible amount of experimentation in computation and programming language theory.<p>But SICP is a book that is for people interested in the study of computation what programming languages <i>can</i> be. If you&#x27;re worried about getting a job in software it won&#x27;t be all that useful, but it will remain a classic for anyone interested in engaging in creating the future of software.</div><br/></div></div><div id="42162316" class="c"><input type="checkbox" id="c-42162316" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#42162029">parent</a><span>|</span><a href="#42162080">prev</a><span>|</span><a href="#42162717">next</a><span>|</span><label class="collapse" for="c-42162316">[-]</label><label class="expand" for="c-42162316">[1 more]</label></div><br/><div class="children"><div class="content">Sure, SICP is not a good book for people wanting to do rote learning, imitation, &#x27;best practice&#x27; while ignoring the history.<p>It&#x27;s for people that would like to learn rather advanced programming techniques and foundational ideas in computer science.</div><br/></div></div></div></div><div id="42162717" class="c"><input type="checkbox" id="c-42162717" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#42162029">prev</a><span>|</span><a href="#42158974">next</a><span>|</span><label class="collapse" for="c-42162717">[-]</label><label class="expand" for="c-42162717">[1 more]</label></div><br/><div class="children"><div class="content">Many classics are worth reading twice. Knuth, Tanenbaum, Stephens, PAIP, ...</div><br/></div></div><div id="42158974" class="c"><input type="checkbox" id="c-42158974" checked=""/><div class="controls bullet"><span class="by">spit2wind</span><span>|</span><a href="#42162717">prev</a><span>|</span><a href="#42158747">next</a><span>|</span><label class="collapse" for="c-42158974">[-]</label><label class="expand" for="c-42158974">[1 more]</label></div><br/><div class="children"><div class="content">Programming Pearls is another book that rereads well. It&#x27;s also short, too, which makes rereading it possible.</div><br/></div></div><div id="42158747" class="c"><input type="checkbox" id="c-42158747" checked=""/><div class="controls bullet"><span class="by">owl_vision</span><span>|</span><a href="#42158974">prev</a><span>|</span><a href="#42158869">next</a><span>|</span><label class="collapse" for="c-42158747">[-]</label><label class="expand" for="c-42158747">[4 more]</label></div><br/><div class="children"><div class="content">i&#x27;d also recommend &quot;Concrete Abstractions: An Introduction to Computer Science using Scheme&quot; by Max Hailperin, Barbara Keiser, Karl Knight.<p><a href="http:&#x2F;&#x2F;www.gustavus.edu&#x2F;+max&#x2F;concrete-abstractions.html" rel="nofollow">http:&#x2F;&#x2F;www.gustavus.edu&#x2F;+max&#x2F;concrete-abstractions.html</a></div><br/><div id="42160479" class="c"><input type="checkbox" id="c-42160479" checked=""/><div class="controls bullet"><span class="by">maxhailperin</span><span>|</span><a href="#42158747">parent</a><span>|</span><a href="#42158846">next</a><span>|</span><label class="collapse" for="c-42160479">[-]</label><label class="expand" for="c-42160479">[2 more]</label></div><br/><div class="children"><div class="content">Spelling correction on the second author&#x27;s last name: Kaiser</div><br/><div id="42160604" class="c"><input type="checkbox" id="c-42160604" checked=""/><div class="controls bullet"><span class="by">owl_vision</span><span>|</span><a href="#42158747">root</a><span>|</span><a href="#42160479">parent</a><span>|</span><a href="#42158846">next</a><span>|</span><label class="collapse" for="c-42160604">[-]</label><label class="expand" for="c-42160604">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the correction.  pardon my typo.</div><br/></div></div></div></div><div id="42158846" class="c"><input type="checkbox" id="c-42158846" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#42158747">parent</a><span>|</span><a href="#42160479">prev</a><span>|</span><a href="#42158869">next</a><span>|</span><label class="collapse" for="c-42158846">[-]</label><label class="expand" for="c-42158846">[1 more]</label></div><br/><div class="children"><div class="content">I concur, I am learning from it now…</div><br/></div></div></div></div><div id="42158869" class="c"><input type="checkbox" id="c-42158869" checked=""/><div class="controls bullet"><span class="by">Upvoter33</span><span>|</span><a href="#42158747">prev</a><span>|</span><a href="#42158589">next</a><span>|</span><label class="collapse" for="c-42158869">[-]</label><label class="expand" for="c-42158869">[1 more]</label></div><br/><div class="children"><div class="content">There are some great books, and every book means something different to each person who reads it.<p>K&amp;R influenced a generation of programmers.<p>Hennessy and Patterson influence a generation of architects.<p>etc. etc.<p>It&#x27;s not just SICP.<p>But the greater point: a book can be meaningful, and we can always use more good ones.</div><br/></div></div><div id="42158589" class="c"><input type="checkbox" id="c-42158589" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42158869">prev</a><span>|</span><a href="#42159874">next</a><span>|</span><label class="collapse" for="c-42158589">[-]</label><label class="expand" for="c-42158589">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called procedural epistemology — the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects<p>Ironic, given the increasing use of functional programming in domains where old-fashioned imperative&#x2F;OO programming used to reign alone.</div><br/><div id="42159002" class="c"><input type="checkbox" id="c-42159002" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42158589">parent</a><span>|</span><a href="#42159874">next</a><span>|</span><label class="collapse" for="c-42159002">[-]</label><label class="expand" for="c-42159002">[3 more]</label></div><br/><div class="children"><div class="content">I think in the context of the book &#x27;procedural epistemology&#x27; encompasses all programming, not just what you&#x27;d call procedural programming.</div><br/><div id="42159119" class="c"><input type="checkbox" id="c-42159119" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42158589">root</a><span>|</span><a href="#42159002">parent</a><span>|</span><a href="#42159874">next</a><span>|</span><label class="collapse" for="c-42159119">[-]</label><label class="expand" for="c-42159119">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, I don’t think so. Functional programming is definitely based on the “declarative point of view taken by classical mathematical subjects”.</div><br/><div id="42159915" class="c"><input type="checkbox" id="c-42159915" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#42158589">root</a><span>|</span><a href="#42159119">parent</a><span>|</span><a href="#42159874">next</a><span>|</span><label class="collapse" for="c-42159915">[-]</label><label class="expand" for="c-42159915">[1 more]</label></div><br/><div class="children"><div class="content">I disagree since the book is using a functional programming language to advance the idea that CS is about procedural epistemology as opposed to the declarative stance of maths.<p>The idea that a &#x27;procedural programming paradigm&#x27; exists in contrast with a &#x27;functional programming paradigm&#x27; is blogspeak imho.</div><br/></div></div></div></div></div></div></div></div><div id="42159874" class="c"><input type="checkbox" id="c-42159874" checked=""/><div class="controls bullet"><span class="by">jnordwick</span><span>|</span><a href="#42158589">prev</a><span>|</span><a href="#42158823">next</a><span>|</span><label class="collapse" for="c-42159874">[-]</label><label class="expand" for="c-42159874">[2 more]</label></div><br/><div class="children"><div class="content">I took cs61a at Berkeley as my very first computer science class I couldn&#x27;t program I never tried to so scheme was my first language.<p>My ta told me that everybody should take the class twice when you first come in and when you&#x27;re graduating.<p>When you first take it especially if you know other languages like C at the time you don&#x27;t get the full depth of the problems you&#x27;re given a great introduction and you think you understand everything but you don&#x27;t realize the depth of complexity. Message passing the metacircular evaluator, continuations as the basis of all flow control, etc<p>You think they are neat tricks that you understand the curriculum because you can do the homework you don&#x27;t understand how those neat tricks are really the basis of everything else you&#x27;ll do.<p>When you&#x27;re graduating you&#x27;ve had time to go through all your classes you realize just how foundation was principles are and you get so much more out of the book.<p>Well I didn&#x27;t take the class a second time I need help grade and TA for a couple semesters.<p>I work as a quant developer and in trading now and even though my field has nothing to do with that I still think it&#x27;s the basis of me as a developer.</div><br/><div id="42159975" class="c"><input type="checkbox" id="c-42159975" checked=""/><div class="controls bullet"><span class="by">golly_ned</span><span>|</span><a href="#42159874">parent</a><span>|</span><a href="#42158823">next</a><span>|</span><label class="collapse" for="c-42159975">[-]</label><label class="expand" for="c-42159975">[1 more]</label></div><br/><div class="children"><div class="content">My same experience. For much of the rest of the cs curriculum I felt like we had already to some extent covered the main ideas in 61a with sicp.</div><br/></div></div></div></div><div id="42158823" class="c"><input type="checkbox" id="c-42158823" checked=""/><div class="controls bullet"><span class="by">whobre</span><span>|</span><a href="#42159874">prev</a><span>|</span><a href="#42161949">next</a><span>|</span><label class="collapse" for="c-42158823">[-]</label><label class="expand" for="c-42158823">[8 more]</label></div><br/><div class="children"><div class="content">I don’t quite get the cult status of SICP. I read it and it’s a fine beginner programming book, but nothing more.</div><br/><div id="42158885" class="c"><input type="checkbox" id="c-42158885" checked=""/><div class="controls bullet"><span class="by">jgon</span><span>|</span><a href="#42158823">parent</a><span>|</span><a href="#42159817">next</a><span>|</span><label class="collapse" for="c-42158885">[-]</label><label class="expand" for="c-42158885">[4 more]</label></div><br/><div class="children"><div class="content">Just so we&#x27;re clear, this is a &quot;beginner programming book&quot; that has you create a scheme interpreter, then a register machine simulator, then a compiler out of your interpreter that will then have its compiled code run on the register machine simulator, by the final chapter.<p>This is probably the part where you&#x27;d step up and post a link to your repo with solutions to the exercises to back up your talk, but generally I only see this sort of casual dismissal from people who haven&#x27;t actually worked through the book.</div><br/><div id="42159489" class="c"><input type="checkbox" id="c-42159489" checked=""/><div class="controls bullet"><span class="by">dbtc</span><span>|</span><a href="#42158823">root</a><span>|</span><a href="#42158885">parent</a><span>|</span><a href="#42161019">next</a><span>|</span><label class="collapse" for="c-42159489">[-]</label><label class="expand" for="c-42159489">[2 more]</label></div><br/><div class="children"><div class="content">I commend your righteous indignation. Made me smile. Flame on!</div><br/><div id="42160562" class="c"><input type="checkbox" id="c-42160562" checked=""/><div class="controls bullet"><span class="by">becquerel</span><span>|</span><a href="#42158823">root</a><span>|</span><a href="#42159489">parent</a><span>|</span><a href="#42161019">next</a><span>|</span><label class="collapse" for="c-42160562">[-]</label><label class="expand" for="c-42160562">[1 more]</label></div><br/><div class="children"><div class="content">One aspires to be a hater of such high caliber.</div><br/></div></div></div></div><div id="42161019" class="c"><input type="checkbox" id="c-42161019" checked=""/><div class="controls bullet"><span class="by">veqq</span><span>|</span><a href="#42158823">root</a><span>|</span><a href="#42158885">parent</a><span>|</span><a href="#42159489">prev</a><span>|</span><a href="#42159817">next</a><span>|</span><label class="collapse" for="c-42161019">[-]</label><label class="expand" for="c-42161019">[1 more]</label></div><br/><div class="children"><div class="content">Concrete Abstractions, Schematics of Computation and others from the era (also using Scheme) covered similar ground (and went far further!) SICP is denser and sticks to theory forgoing databases, operating systems and actually implementing scheme in assembly.</div><br/></div></div></div></div><div id="42159817" class="c"><input type="checkbox" id="c-42159817" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42158823">parent</a><span>|</span><a href="#42158885">prev</a><span>|</span><a href="#42161949">next</a><span>|</span><label class="collapse" for="c-42159817">[-]</label><label class="expand" for="c-42159817">[3 more]</label></div><br/><div class="children"><div class="content">I don’t understand this comment. If you master the material you know more than 90% of engineers in the field.</div><br/><div id="42160138" class="c"><input type="checkbox" id="c-42160138" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#42158823">root</a><span>|</span><a href="#42159817">parent</a><span>|</span><a href="#42161949">next</a><span>|</span><label class="collapse" for="c-42160138">[-]</label><label class="expand" for="c-42160138">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you master the material you know more than 90% of engineers in the field.<p>Telling someone that he&#x2F;she is smarter than 90% of the people is <i>not</i> a praise. :-)</div><br/><div id="42160177" class="c"><input type="checkbox" id="c-42160177" checked=""/><div class="controls bullet"><span class="by">bdangubic</span><span>|</span><a href="#42158823">root</a><span>|</span><a href="#42160138">parent</a><span>|</span><a href="#42161949">next</a><span>|</span><label class="collapse" for="c-42160177">[-]</label><label class="expand" for="c-42160177">[1 more]</label></div><br/><div class="children"><div class="content">amen… just look at 90% of people at the DMV :-)</div><br/></div></div></div></div></div></div></div></div><div id="42161949" class="c"><input type="checkbox" id="c-42161949" checked=""/><div class="controls bullet"><span class="by">virtuallynathan</span><span>|</span><a href="#42158823">prev</a><span>|</span><a href="#42160220">next</a><span>|</span><label class="collapse" for="c-42161949">[-]</label><label class="expand" for="c-42161949">[1 more]</label></div><br/><div class="children"><div class="content">Always fun to see one of my professors from the quite tiny, but awesome computer science department at St Andrews on HN!</div><br/></div></div><div id="42160220" class="c"><input type="checkbox" id="c-42160220" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42161949">prev</a><span>|</span><a href="#42159071">next</a><span>|</span><label class="collapse" for="c-42160220">[-]</label><label class="expand" for="c-42160220">[4 more]</label></div><br/><div class="children"><div class="content">My favourite part of SICP and something that has stuck with me for years is the idea of &quot;wishful programming&quot;. That is where you build something top-down by simply wishing you had the lower-level routines. Then, of course, you actually go and build those lower-level routines until you reach the bottom. I find this way of thinking works really well with test-driven development. Write a test against functionality you <i>wish</i> you had, then go and fulfill that wish. Most developers seem to build stuff bottom-up and then end up with something that isn&#x27;t really what anyone wished for.</div><br/><div id="42162718" class="c"><input type="checkbox" id="c-42162718" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42160220">parent</a><span>|</span><a href="#42162235">next</a><span>|</span><label class="collapse" for="c-42162718">[-]</label><label class="expand" for="c-42162718">[1 more]</label></div><br/><div class="children"><div class="content">They do that because their wish is performance and naturalness.<p>You may accidentally wish something you don’t yet know the true nature of, and this will create a fragile mess at the bottom. It usually does, cause algorithmic nature of things is rarely intuitive. Starting from the bottom is like starting from quarks that you have rather than from “I want magic to exist”. Well it does not. You reach the bottom and there’s quarks instead of magicules and you’ve lost all context clues on the way which could help to convert between two physics.<p>Both approaches have their use, because sometimes you have to be bold with your wishes to solve a deep problem. But personally I prefer magic to be packed into the before-topmost layer. I.e. build from the bottom up, and then, just before the business logic, create a convenience magic layer that translates to&#x2F;from business speak. It becomes adjustable and doesn’t induce a tangled mess all the way down.</div><br/></div></div><div id="42162235" class="c"><input type="checkbox" id="c-42162235" checked=""/><div class="controls bullet"><span class="by">WillAdams</span><span>|</span><a href="#42160220">parent</a><span>|</span><a href="#42162718">prev</a><span>|</span><a href="#42161028">next</a><span>|</span><label class="collapse" for="c-42162235">[-]</label><label class="expand" for="c-42162235">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, Dr. Donald Knuth used pretty much that approach when writing TeX --- he started by writing out the sort of formatting&#x2F;tagging which seemed appropriate, then theorizing about the sort of programming which would be appropriate for markup (hence macros), then worked on the implementation.<p>I&#x27;ve been trying a similar thing for my own effort to create a library for modeling G-code in OpenSCAD --- hopefully with the recent re-write in &quot;pure&quot; OpenPythonSCAD it will become something usable.</div><br/></div></div><div id="42161028" class="c"><input type="checkbox" id="c-42161028" checked=""/><div class="controls bullet"><span class="by">Qem</span><span>|</span><a href="#42160220">parent</a><span>|</span><a href="#42162235">prev</a><span>|</span><a href="#42159071">next</a><span>|</span><label class="collapse" for="c-42161028">[-]</label><label class="expand" for="c-42161028">[1 more]</label></div><br/><div class="children"><div class="content">The Smalltalk world has great support for this, through coding in the debugger. You should try Pharo.</div><br/></div></div></div></div><div id="42159071" class="c"><input type="checkbox" id="c-42159071" checked=""/><div class="controls bullet"><span class="by">scop</span><span>|</span><a href="#42160220">prev</a><span>|</span><a href="#42162074">next</a><span>|</span><label class="collapse" for="c-42159071">[-]</label><label class="expand" for="c-42159071">[2 more]</label></div><br/><div class="children"><div class="content">I’m slowly making my way through it a second time and thoroughly enjoying it. The first time through it seemed quite abstract, albeit only because of my completely lack of real world programming. The second time through it a revelation as I now have a strong base of experience through which to understand it (experience which it also, informs!).<p>I am using Elixir’s Livebook to take notes and complete the exercises. It is very helpful to have a live notebook tool while reading it!</div><br/><div id="42160876" class="c"><input type="checkbox" id="c-42160876" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#42159071">parent</a><span>|</span><a href="#42162074">next</a><span>|</span><label class="collapse" for="c-42160876">[-]</label><label class="expand" for="c-42160876">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re doing the exercises in Elixir and not Scheme then?</div><br/></div></div></div></div><div id="42158956" class="c"><input type="checkbox" id="c-42158956" checked=""/><div class="controls bullet"><span class="by">docandrew</span><span>|</span><a href="#42162074">prev</a><span>|</span><a href="#42158478">next</a><span>|</span><label class="collapse" for="c-42158956">[-]</label><label class="expand" for="c-42158956">[1 more]</label></div><br/><div class="children"><div class="content">I’m working through it now, for someone with a computer engineering, EE or math background I think this is a great resource to get started with CS fundamentals.</div><br/></div></div><div id="42158478" class="c"><input type="checkbox" id="c-42158478" checked=""/><div class="controls bullet"><span class="by">jph</span><span>|</span><a href="#42158956">prev</a><span>|</span><a href="#42160938">next</a><span>|</span><label class="collapse" for="c-42158478">[-]</label><label class="expand" for="c-42158478">[1 more]</label></div><br/><div class="children"><div class="content">SICP is available for free: <a href="https:&#x2F;&#x2F;web.mit.edu&#x2F;6.001&#x2F;6.037&#x2F;sicp.pdf" rel="nofollow">https:&#x2F;&#x2F;web.mit.edu&#x2F;6.001&#x2F;6.037&#x2F;sicp.pdf</a><p>If you want to get it elsewhere, the full info is: 
Structure and interpretation of computer programs by Hal Abelson and Jerry Sussman (MIT Press. 1984. ISBN 0-262-01077-1).</div><br/></div></div><div id="42160938" class="c"><input type="checkbox" id="c-42160938" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42158478">prev</a><span>|</span><a href="#42161114">next</a><span>|</span><label class="collapse" for="c-42160938">[-]</label><label class="expand" for="c-42160938">[1 more]</label></div><br/><div class="children"><div class="content">Hot take: SICP and SD4F &quot;considered harmful (without counterpoint)&quot;*.<p>Why? The modus operandi of problem solving in these books is object oriented programming masquerading as functional programming, and it is presented as a _neutral_ beginner book.  It is _not neutral_.  This is a very opinionated approach to programming.<p>To be fair, I do not believe the authors intended for this style of programming to be taken as gospel, but it is often presented _without counterpoint_.<p>The most powerful technique introduced -- implementing complex behavior via extensible polymorphic generics -- is virtually unmaintainable without a compiler-supported static type checker.  You would know that if you ever tried to implement the code yourself in a dynamic language of your choice.<p>The ramifications of these choices can be felt far and wide and are largely unquestioned.<p>Ironically, they make code hard to understand, hard to extend, and hard to maintain. I need to reiterate, I do not believe the intention of the authors was to suggest these ideas should be used beyond a pedagogical setting, but they often are.<p>As a specific critique to SD4F, which states as a goal making code more resilient by emulating biology, I would point to Leslie Lamport&#x27;s talk on logic vs biology[1].<p>I would add that I think SICP would be fine if it were taught in tandem with Paradigms of Artificial Intelligence Programming by Peter Norvig[2]. PAIP offers a completely different approach to solving problems, also using lisp. This approach is much closer to constructing a language to model a problem and then solving the problem symbolically using the language created. Areas that use OO techniques, such as the chapter in CLOS, are clearly marked as such.<p>In other words, I say &quot;SICP considered harmful&quot; because thrusting it upon an eager newcomer as a trusted neutral guide to beginner coding (without offering any counterpoint) could set them back by a decade, filling their head with &quot;functional object oriented programming&quot; concepts that don&#x27;t translate well to industry or CS.<p>[*]: I say this as someone who has thoroughly studied both books,
implemented the code, taken Dave Beazely courses to have the information spoon fed to me (dabeaz is awesome btw, take all his stuff) and used the techniques in production code bases.<p>[1]: <a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;pubs&#x2F;future-of-computing.pdf" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;pubs&#x2F;future-of-computing.p...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp</a></div><br/></div></div><div id="42161114" class="c"><input type="checkbox" id="c-42161114" checked=""/><div class="controls bullet"><span class="by">Avid_F</span><span>|</span><a href="#42160938">prev</a><span>|</span><a href="#42161453">next</a><span>|</span><label class="collapse" for="c-42161114">[-]</label><label class="expand" for="c-42161114">[1 more]</label></div><br/><div class="children"><div class="content">That and the art of computer programming</div><br/></div></div><div id="42161453" class="c"><input type="checkbox" id="c-42161453" checked=""/><div class="controls bullet"><span class="by">Iwan-Zotow</span><span>|</span><a href="#42161114">prev</a><span>|</span><a href="#42161128">next</a><span>|</span><label class="collapse" for="c-42161453">[-]</label><label class="expand" for="c-42161453">[1 more]</label></div><br/><div class="children"><div class="content">TAOCP</div><br/></div></div><div id="42161128" class="c"><input type="checkbox" id="c-42161128" checked=""/><div class="controls bullet"><span class="by">Jiahang</span><span>|</span><a href="#42161453">prev</a><span>|</span><a href="#42162128">next</a><span>|</span><label class="collapse" for="c-42161128">[-]</label><label class="expand" for="c-42161128">[1 more]</label></div><br/><div class="children"><div class="content">and CSAPP i think</div><br/></div></div><div id="42162128" class="c"><input type="checkbox" id="c-42162128" checked=""/><div class="controls bullet"><span class="by">soup10</span><span>|</span><a href="#42161128">prev</a><span>|</span><label class="collapse" for="c-42162128">[-]</label><label class="expand" for="c-42162128">[1 more]</label></div><br/><div class="children"><div class="content">I picked up SICP expecting to read something really interesting or profound with the way it&#x27;s been hyped up over the years however it&#x27;s more of a how-to manual for working with Scheme&#x2F;LISP and frankly that didn&#x27;t interest me.  Unfortunately most people have come to accept that LISP isn&#x27;t a particularly effective way of programming even if some people get really excited by the idea of mutable and interchangeable data and code it&#x27;s just not as powerful as they make it out to be and the obfuscation of program flow and execution and the lack of separation&#x2F;delineation of data and code proves to be a hinderance more often than it is helpful.  This doesn&#x27;t discount LISP&#x27;s contribution to computer science historically and how it&#x27;s influenced modern day language design over the years, just that in my opinion LISP&#x2F;SCHEME is more of a historical curiosity than a modern day guide to effective programming. (And certainly one that has no place as the introductory class at MIT).  Anyway I&#x27;ve said something negative about SICP so prepare for this to be downvoted to the bottom :)</div><br/></div></div></div></div></div></div></div></body></html>