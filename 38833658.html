<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704186060864" as="style"/><link rel="stylesheet" href="styles.css?v=1704186060864"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://timmastny.com/blog/a-star-tricks-for-videogame-path-finding/">A* tricks for videogame path finding</a>Â <span class="domain">(<a href="https://timmastny.com">timmastny.com</a>)</span></div><div class="subtext"><span>azhenley</span> | <span>80 comments</span></div><br/><div><div id="38835127" class="c"><input type="checkbox" id="c-38835127" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38835357">next</a><span>|</span><label class="collapse" for="c-38835127">[-]</label><label class="expand" for="c-38835127">[33 more]</label></div><br/><div class="children"><div class="content">Some tricks I used for A* in a production MMO:<p>1. Hierarchical graphs: city-level, inter-room in building, intra-room. Allows for navigation from any point in any room in any building in any city to any other point in a fraction of a millisecond.<p>2. Store metadata about the current a* search in the graph nodes themselves so you don&#x27;t have to maintain in a separate associative array.<p>3. Don&#x27;t follow the resulting paths directly, use them as input to a steering behavior that tries to cut corners to the next path node when possible. Also, if you are pathing to go to another character, make the target character drop &quot;breadcrumbs&quot; that get added to the path when their new position would not be straight-line navigable from the last node of the path .</div><br/><div id="38835515" class="c"><input type="checkbox" id="c-38835515" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38837142">next</a><span>|</span><label class="collapse" for="c-38835515">[-]</label><label class="expand" for="c-38835515">[4 more]</label></div><br/><div class="children"><div class="content">Oh, and compute the distance from each path node to the nearest obstacle and store that in the path node. As long as your character is inside one of these &quot;bubbles&quot;, you can skip collision detection against the world entirely.</div><br/><div id="38838212" class="c"><input type="checkbox" id="c-38838212" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835515">parent</a><span>|</span><a href="#38837956">next</a><span>|</span><label class="collapse" for="c-38838212">[-]</label><label class="expand" for="c-38838212">[1 more]</label></div><br/><div class="children"><div class="content">Oh like in path tracing.</div><br/></div></div><div id="38837956" class="c"><input type="checkbox" id="c-38837956" checked=""/><div class="controls bullet"><span class="by">two_in_one</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835515">parent</a><span>|</span><a href="#38838212">prev</a><span>|</span><a href="#38837142">next</a><span>|</span><label class="collapse" for="c-38837956">[-]</label><label class="expand" for="c-38837956">[2 more]</label></div><br/><div class="children"><div class="content">nearest object can be dynamic thing</div><br/><div id="38838202" class="c"><input type="checkbox" id="c-38838202" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38837956">parent</a><span>|</span><a href="#38837142">next</a><span>|</span><label class="collapse" for="c-38838202">[-]</label><label class="expand" for="c-38838202">[1 more]</label></div><br/><div class="children"><div class="content">Yes, though many systems make a distinction between fixed objects (like level geometry) and moveable stuff.<p>If you are inside the bubble, you can disable collision with the fixed objects, and only check for the moveables.<p>In old-school terms that&#x27;s background vs sprites.</div><br/></div></div></div></div></div></div><div id="38837142" class="c"><input type="checkbox" id="c-38837142" checked=""/><div class="controls bullet"><span class="by">YesBox</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38835515">prev</a><span>|</span><a href="#38835436">next</a><span>|</span><label class="collapse" for="c-38837142">[-]</label><label class="expand" for="c-38837142">[1 more]</label></div><br/><div class="children"><div class="content">Im working on a city builder[0] where you can see inside homes. Expanding on point 1...<p>1. The streets have their own graph, as does each individual building. There&#x27;s an address book; each building stores the driveway tile connecting to the street graph here.<p>2. Pathing inside homes uses A*. In order to make this extra fast, I bake the 8-directional egress weights for each tile in the building&#x2F;yard.<p>2b. This gets condensed down into a 16-bit bitmask (2 bit chunks, 8 directions) and then stored in a hash table<p>2c. Each bit-chunk has four possible states:<p>FULL_BLOCK (e.g. a wall)<p>HARD_BLOCK (e.g. a large object that prevents walking through the tile from any direction)<p>SOFT_BLOCK (e.g. a smaller object that prevents passage on one edge)<p>NO_BLOCK (e.g. an unoccupied tile, or a tile with a tiny object)<p>This way a unit pathing inside a building does not need to check for obstacles on every tile. This also allows units to pass through tiles with objects provided the object is not huge and is rotated in such a way that the exit and entrance edge is not blocked. Lastly, an agent can still walk through a wall if the player e.g. forgot to place a door, to prevent the simulation from breaking down.<p>3. I use a waypoint system (stored in a queue) for agents so they can traverse through the different graph hierarchies with ease. This is also used to e.g. tell the unit to walk to their car first if they are driving.<p>4. Pathing on the street uses a different method (though still utilizes a baked graph) that makes it extra zippy.<p>[0] <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;2287430&#x2F;Metropolis_1998&#x2F;" rel="nofollow">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;2287430&#x2F;Metropolis_1998&#x2F;</a></div><br/></div></div><div id="38835436" class="c"><input type="checkbox" id="c-38835436" checked=""/><div class="controls bullet"><span class="by">hwillis</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38837142">prev</a><span>|</span><a href="#38835631">next</a><span>|</span><label class="collapse" for="c-38835436">[-]</label><label class="expand" for="c-38835436">[16 more]</label></div><br/><div class="children"><div class="content">&gt; Hierarchical graphs: city-level, inter-room in building, intra-room.<p>Handmade?  It&#x27;s always annoying to me when you have a small NP-hard problem (graph partitioning is definitely a recurring one for me) and you want to just throw some box algorithm at it without having to shop around for a library that you have to learn.<p>I remember there was a while in college where I didn&#x27;t understand why A* in an RTS would be such a hard thing... and then I watched a video or read something that pointed out that if you don&#x27;t want units walking through each other then <i>every single moving thing</i> is constantly re-pathing around every other unit.  New respect for command and conquer.</div><br/><div id="38835606" class="c"><input type="checkbox" id="c-38835606" checked=""/><div class="controls bullet"><span class="by">araes</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835436">parent</a><span>|</span><a href="#38835469">next</a><span>|</span><label class="collapse" for="c-38835606">[-]</label><label class="expand" for="c-38835606">[5 more]</label></div><br/><div class="children"><div class="content">This is one of the main issues in attempting to build a game like the Total War series.<p>When you start getting into 10,000 unit formations that need to pivot or strafe, while moving around or through other unit groups and obstacles, A* starts being rather challenging.<p>Trying to get 100,000 horses to ford a river reasonably when there&#x27;s only a relatively small zone of safety can be tough to program.<p>Also, mipmaps towards the hierarchical comment of aappleby and hwillis.</div><br/><div id="38836600" class="c"><input type="checkbox" id="c-38836600" checked=""/><div class="controls bullet"><span class="by">sojuz151</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835606">parent</a><span>|</span><a href="#38837045">next</a><span>|</span><label class="collapse" for="c-38836600">[-]</label><label class="expand" for="c-38836600">[1 more]</label></div><br/><div class="children"><div class="content">TBH running a full A* for each soldier is not only waistfull but also not realistic.  Most people are just moving with the group and might not even know where the entire formation is going</div><br/></div></div><div id="38837045" class="c"><input type="checkbox" id="c-38837045" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835606">parent</a><span>|</span><a href="#38836600">prev</a><span>|</span><a href="#38838972">next</a><span>|</span><label class="collapse" for="c-38837045">[-]</label><label class="expand" for="c-38837045">[1 more]</label></div><br/><div class="children"><div class="content">Isnât the standard solution there to pick one of the horses to do the full path while telling the others âtry to move along this path, if not possible then as close as possible, otherwise in the average direction of this group of horsesâ or something similar?</div><br/></div></div><div id="38838972" class="c"><input type="checkbox" id="c-38838972" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835606">parent</a><span>|</span><a href="#38837045">prev</a><span>|</span><a href="#38836652">next</a><span>|</span><label class="collapse" for="c-38838972">[-]</label><label class="expand" for="c-38838972">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Trying to get 100,000 horses to ford a river reasonably when there&#x27;s only a relatively small zone of safety can be tough to program.<p>I imagine this is also very tough in real life</div><br/></div></div></div></div><div id="38835469" class="c"><input type="checkbox" id="c-38835469" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835436">parent</a><span>|</span><a href="#38835606">prev</a><span>|</span><a href="#38835478">next</a><span>|</span><label class="collapse" for="c-38835469">[-]</label><label class="expand" for="c-38835469">[1 more]</label></div><br/><div class="children"><div class="content">Handmade, but trivial to build - I made a tool so the guys in the world editor could just click anywhere to drop a path node and the tool would automatically link path nodes and prune redundant edges from the graph. Took a few minutes to do a whole city. Building graphs were mostly autogenerated from the navigation mesh and labeled &quot;door&quot; objects, with optional manually placed nodes when the room geometry was weird.</div><br/></div></div><div id="38835478" class="c"><input type="checkbox" id="c-38835478" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835436">parent</a><span>|</span><a href="#38835469">prev</a><span>|</span><a href="#38835503">next</a><span>|</span><label class="collapse" for="c-38835478">[-]</label><label class="expand" for="c-38835478">[1 more]</label></div><br/><div class="children"><div class="content">Also every single thing shouldn&#x27;t be pathing around everything else, they should use something like a flocking behavior to organize themselves. Pathing is only for long distance navigation in complex environments.</div><br/></div></div><div id="38835503" class="c"><input type="checkbox" id="c-38835503" checked=""/><div class="controls bullet"><span class="by">superjan</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835436">parent</a><span>|</span><a href="#38835478">prev</a><span>|</span><a href="#38838215">next</a><span>|</span><label class="collapse" for="c-38835503">[-]</label><label class="expand" for="c-38835503">[2 more]</label></div><br/><div class="children"><div class="content">I have seen an article posted here that did A* on a low resolution versions of the game map, and use the output of that as the heuristic for the full res version. In that design, the low res version was auto generated.</div><br/><div id="38838221" class="c"><input type="checkbox" id="c-38838221" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835503">parent</a><span>|</span><a href="#38838215">next</a><span>|</span><label class="collapse" for="c-38838221">[-]</label><label class="expand" for="c-38838221">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s nifty, because A* itself is already a two-step process that uses a heuristic.  You can blow it up to multiple steps fairly easily.</div><br/></div></div></div></div><div id="38838215" class="c"><input type="checkbox" id="c-38838215" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835436">parent</a><span>|</span><a href="#38835503">prev</a><span>|</span><a href="#38836817">next</a><span>|</span><label class="collapse" for="c-38838215">[-]</label><label class="expand" for="c-38838215">[1 more]</label></div><br/><div class="children"><div class="content">Small NP-hard problems aren&#x27;t actually that bad.  You can usually formulate them as eg a integer programming problem or a SMT problem, and throw an off-the-shelf solver at them.<p>You only need to learn the solver once, and you can re-use it for all kinds of problems.  (Assuming that your instances don&#x27;t have to be solved with low latency.  Eg only as part of your level generation process, or at most when loading a randomly generated level, but not every frame or so.)<p><a href="https:&#x2F;&#x2F;developers.google.com&#x2F;optimization" rel="nofollow">https:&#x2F;&#x2F;developers.google.com&#x2F;optimization</a> has a decent collection of tools.</div><br/></div></div><div id="38836817" class="c"><input type="checkbox" id="c-38836817" checked=""/><div class="controls bullet"><span class="by">SirMaster</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835436">parent</a><span>|</span><a href="#38838215">prev</a><span>|</span><a href="#38835518">next</a><span>|</span><label class="collapse" for="c-38836817">[-]</label><label class="expand" for="c-38836817">[4 more]</label></div><br/><div class="children"><div class="content">I donât know about C&amp;C but in StarCraft units are constantly walking into each other, getting temporarily hung up and stuck a bit.<p>If they were constantly re-pathing around each other though you would certainly also run into issues too.<p>Why shouldnât the units use the information they have about the current destination and path of the other allied units instead of just constantly seeing them as moving obstacles.</div><br/><div id="38837185" class="c"><input type="checkbox" id="c-38837185" checked=""/><div class="controls bullet"><span class="by">otikik</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38836817">parent</a><span>|</span><a href="#38837016">next</a><span>|</span><label class="collapse" for="c-38837185">[-]</label><label class="expand" for="c-38837185">[1 more]</label></div><br/><div class="children"><div class="content">Well pathing in sc2 improved significantly, although some problems remain (ultralisks dieing before reaching their target).<p>In the case of SC1, the dragoon in particular was really bad because its speed would change significantly depending on which part of the animation it was in. Thatâs what made wheeled vehicles and tanks were less wonky. Their speed was constant as they moved.</div><br/></div></div><div id="38837016" class="c"><input type="checkbox" id="c-38837016" checked=""/><div class="controls bullet"><span class="by">KptMarchewa</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38836817">parent</a><span>|</span><a href="#38837185">prev</a><span>|</span><a href="#38835518">next</a><span>|</span><label class="collapse" for="c-38837016">[-]</label><label class="expand" for="c-38837016">[2 more]</label></div><br/><div class="children"><div class="content">Some of the units in Brood War are legendary due to their bad pathfinding like Dragoon.</div><br/><div id="38837681" class="c"><input type="checkbox" id="c-38837681" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38837016">parent</a><span>|</span><a href="#38835518">next</a><span>|</span><label class="collapse" for="c-38837681">[-]</label><label class="expand" for="c-38837681">[1 more]</label></div><br/><div class="children"><div class="content">Which is incidentally what made SC the high skill ceiling it has.<p>If the pathing of SC had been &quot;great&quot;, the game mightn&#x27;t have taken off the way it did competitively.</div><br/></div></div></div></div></div></div><div id="38835518" class="c"><input type="checkbox" id="c-38835518" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835436">parent</a><span>|</span><a href="#38836817">prev</a><span>|</span><a href="#38835631">next</a><span>|</span><label class="collapse" for="c-38835518">[-]</label><label class="expand" for="c-38835518">[1 more]</label></div><br/><div class="children"><div class="content">Search for &quot;flowfield pathfinding&quot;. Individual units don&#x27;t follow a per-unit line. They follow a  high-level flow and use local steering to avoid nearby units.</div><br/></div></div></div></div><div id="38835631" class="c"><input type="checkbox" id="c-38835631" checked=""/><div class="controls bullet"><span class="by">doophus</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38835436">prev</a><span>|</span><a href="#38839134">next</a><span>|</span><label class="collapse" for="c-38835631">[-]</label><label class="expand" for="c-38835631">[3 more]</label></div><br/><div class="children"><div class="content">&gt; 2. Store metadata about the current a* search in the graph nodes themselves so you don&#x27;t have to maintain in a separate associative array.<p>This might be suitable in some circumstances, but it mixes your hot &amp; cold data, prevents concurrent searches from being performed. Personally I&#x27;d steer away from this without an extremely good reason.</div><br/><div id="38835652" class="c"><input type="checkbox" id="c-38835652" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835631">parent</a><span>|</span><a href="#38839134">next</a><span>|</span><label class="collapse" for="c-38835652">[-]</label><label class="expand" for="c-38835652">[2 more]</label></div><br/><div class="children"><div class="content">Correct, but it was still way faster that way. Pathfinding was already asynchronous (queries happened on another thread so they didn&#x27;t block any game update loops) and queries were infrequent enough that doing one at a time was fine.</div><br/><div id="38837005" class="c"><input type="checkbox" id="c-38837005" checked=""/><div class="controls bullet"><span class="by">KptMarchewa</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835652">parent</a><span>|</span><a href="#38839134">next</a><span>|</span><label class="collapse" for="c-38837005">[-]</label><label class="expand" for="c-38837005">[1 more]</label></div><br/><div class="children"><div class="content">Oh that would be unpleasant if you wanted deterministic behaviour - for example multiplayer RTS.</div><br/></div></div></div></div></div></div><div id="38839134" class="c"><input type="checkbox" id="c-38839134" checked=""/><div class="controls bullet"><span class="by">Zondartul</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38835631">prev</a><span>|</span><a href="#38837842">next</a><span>|</span><label class="collapse" for="c-38839134">[-]</label><label class="expand" for="c-38839134">[1 more]</label></div><br/><div class="children"><div class="content"><i>takes notes</i> Fascinating. Any other sage advice on navigation and game-ai?</div><br/></div></div><div id="38837842" class="c"><input type="checkbox" id="c-38837842" checked=""/><div class="controls bullet"><span class="by">mrmuagi</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38839134">prev</a><span>|</span><a href="#38835803">next</a><span>|</span><label class="collapse" for="c-38837842">[-]</label><label class="expand" for="c-38837842">[1 more]</label></div><br/><div class="children"><div class="content">Songs of Syx is a very performant game that uses 1. I believe, not 100% sure though. It&#x27;s like Dwarf Fortress but with 100 of times more amount of map actors.</div><br/></div></div><div id="38835803" class="c"><input type="checkbox" id="c-38835803" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38837842">prev</a><span>|</span><a href="#38836429">next</a><span>|</span><label class="collapse" for="c-38835803">[-]</label><label class="expand" for="c-38835803">[4 more]</label></div><br/><div class="children"><div class="content">You know as someone who deals with path planning in robotics where there&#x27;s a stack of academic papers on each of these concepts, seeing it labelled &quot;tricks&quot; is really funny.</div><br/><div id="38835929" class="c"><input type="checkbox" id="c-38835929" checked=""/><div class="controls bullet"><span class="by">deadbabe</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835803">parent</a><span>|</span><a href="#38836152">prev</a><span>|</span><a href="#38836429">next</a><span>|</span><label class="collapse" for="c-38835929">[-]</label><label class="expand" for="c-38835929">[2 more]</label></div><br/><div class="children"><div class="content">Theyâre tricks because ideally computational power should be so plentiful that optimizations would be totally unnecessary.</div><br/><div id="38836351" class="c"><input type="checkbox" id="c-38836351" checked=""/><div class="controls bullet"><span class="by">ivancho</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38835929">parent</a><span>|</span><a href="#38836429">next</a><span>|</span><label class="collapse" for="c-38836351">[-]</label><label class="expand" for="c-38836351">[1 more]</label></div><br/><div class="children"><div class="content">Jevons paradox will kick in, we&#x27;ll start computing more things instead</div><br/></div></div></div></div></div></div><div id="38836429" class="c"><input type="checkbox" id="c-38836429" checked=""/><div class="controls bullet"><span class="by">Udo</span><span>|</span><a href="#38835127">parent</a><span>|</span><a href="#38835803">prev</a><span>|</span><a href="#38835357">next</a><span>|</span><label class="collapse" for="c-38836429">[-]</label><label class="expand" for="c-38836429">[2 more]</label></div><br/><div class="children"><div class="content">Expanding on the &quot;breadcrumbs&quot;: pheromone trails or &quot;trampled grass&quot; are awesome, not only because they are a great data source for steering heuristics, but they also lead to organic-seeming navigation behavior that is pleasant to look at.</div><br/><div id="38839463" class="c"><input type="checkbox" id="c-38839463" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38835127">root</a><span>|</span><a href="#38836429">parent</a><span>|</span><a href="#38835357">next</a><span>|</span><label class="collapse" for="c-38839463">[-]</label><label class="expand" for="c-38839463">[1 more]</label></div><br/><div class="children"><div class="content">Usually if something wants to go where something else is, it either want to go in its footsteps or flank it at a point where it predicted to be when both meet.</div><br/></div></div></div></div></div></div><div id="38835357" class="c"><input type="checkbox" id="c-38835357" checked=""/><div class="controls bullet"><span class="by">mopierotti</span><span>|</span><a href="#38835127">prev</a><span>|</span><a href="#38835550">next</a><span>|</span><label class="collapse" for="c-38835357">[-]</label><label class="expand" for="c-38835357">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve spent a lot of time thinking about fast pathfinding in order to speed up my Scala Quoridor AI*[0], and here are some tips&#x2F;tricks I&#x27;ve learned:<p>- MPAA (multipath adaptive A*) is great if you need to re-search the same area multiple times as obstacles are introduced. It allows you to feed in the results of previous searches in order to speed up pathfinding.<p>- JPS (jump point search) looks very appealing in theory because it allows you to significantly reduce the number of &quot;nodes&quot; considered, but I found that the increased overhead in identifying jump points meant it didn&#x27;t provide a speedup. There might be a way to marry the ideas of MPAA and JPS, but it is very easy to conceptually shoot yourself in the foot with minor conceptual details when getting creative with the algorithms. (As a contrived example, using a &quot;&gt;&quot; when you needed a &quot;&gt;=&quot; might mean you are no longer guaranteed to output the real shortest path in certain situations)<p>- Instead of using a proper heap for storing open nodes, consider using a bucketed priority queue if your max priority value is a relatively low integer. This means there&#x27;s an underlying array indexed by priority, which makes push&#x27;ing and pop&#x27;ing quite fast.<p>[0] Quoridor takes place on a 9x9 grid, and repeated pathfinding is essential in order to determine how close a player is to their goal, and more broadly whether the goal is even reachable. (In order to even determine the valid moves from a given position, all moves must be checked to see if they make a goal unreachable). I plan to release this within the next few months, including at least 3 decision making &quot;engines&quot;: mtdf (a min-max variant), MCTS (parallel with some tricks), and a hybrid involving catboost.</div><br/><div id="38835783" class="c"><input type="checkbox" id="c-38835783" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#38835357">parent</a><span>|</span><a href="#38838396">next</a><span>|</span><label class="collapse" for="c-38835783">[-]</label><label class="expand" for="c-38835783">[3 more]</label></div><br/><div class="children"><div class="content">9x9 is a really small grid. 81 tiles. Storing all the distances from every tile to every other tile would take 6561 bytes. Fits in a typical L1 cache.<p>The nice thing about that is that you can use it as a lookup table for your heuristic function instead of the usual straight line. This table can be initialized at the start of each turn, for example using the Floyd-Warshall algorithm with the already placed walls. I managed to significantly speed up my A* on a similar problem using this technique, plus, it is really simple, it was straight A* though, no MPAA or JPS.</div><br/><div id="38835972" class="c"><input type="checkbox" id="c-38835972" checked=""/><div class="controls bullet"><span class="by">mopierotti</span><span>|</span><a href="#38835357">root</a><span>|</span><a href="#38835783">parent</a><span>|</span><a href="#38836447">next</a><span>|</span><label class="collapse" for="c-38835972">[-]</label><label class="expand" for="c-38835972">[1 more]</label></div><br/><div class="children"><div class="content">Interesting idea, thanks! I will probably try this. I had stopped tweaking things too much after implementing MPAA, because most of the searches end up &quot;short circuit&quot;-ing relatively quickly.<p>With MPAA you preserve all previous shortest paths that have been found (in the form of an Array where array(nodeIndex) points to the nodeIndex of the next node on the path). When attempting to optimistically follow one of these paths, if the algorithm hits a new wall, it will null out the path it took up until the wall. However a future search (or iteration in the same search) may still reuse the part of the shortest path that still exists after the wall.<p>That said, you&#x27;re right that it&#x27;s a tiny grid, and cache behavior can dominate any abstract theoretical properties in surprising ways.</div><br/></div></div><div id="38836447" class="c"><input type="checkbox" id="c-38836447" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#38835357">root</a><span>|</span><a href="#38835783">parent</a><span>|</span><a href="#38835972">prev</a><span>|</span><a href="#38838396">next</a><span>|</span><label class="collapse" for="c-38836447">[-]</label><label class="expand" for="c-38836447">[1 more]</label></div><br/><div class="children"><div class="content">&gt; would take 6561 bytes<p>3240 if you&#x27;re nasty.</div><br/></div></div></div></div><div id="38838396" class="c"><input type="checkbox" id="c-38838396" checked=""/><div class="controls bullet"><span class="by">keriati1</span><span>|</span><a href="#38835357">parent</a><span>|</span><a href="#38835783">prev</a><span>|</span><a href="#38835550">next</a><span>|</span><label class="collapse" for="c-38838396">[-]</label><label class="expand" for="c-38838396">[1 more]</label></div><br/><div class="children"><div class="content">+1 for the bucket queue. I learned about that trick a few weeks ago and in my use cases it cut the time to run A* by around 60-70%.</div><br/></div></div></div></div><div id="38835550" class="c"><input type="checkbox" id="c-38835550" checked=""/><div class="controls bullet"><span class="by">superjan</span><span>|</span><a href="#38835357">prev</a><span>|</span><a href="#38834509">next</a><span>|</span><label class="collapse" for="c-38835550">[-]</label><label class="expand" for="c-38835550">[1 more]</label></div><br/><div class="children"><div class="content">When there is more than one enemy, it can become worthwhile to simply use dijkstra from the playerâs point of view, and then each monster can look up the optimal route to the player. It makes the computation cost more predictable when the monster count is variable.</div><br/></div></div><div id="38834509" class="c"><input type="checkbox" id="c-38834509" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38835550">prev</a><span>|</span><a href="#38836113">next</a><span>|</span><label class="collapse" for="c-38834509">[-]</label><label class="expand" for="c-38834509">[7 more]</label></div><br/><div class="children"><div class="content">The âdepth too smallâ problem shown in the last animation produces an interesting behavior appearance; it looks like the monster is âwaiting to seeâ which way youâll go. I think you can even âfake it outâ by starting to go in one direction, then switching, right?<p>Thankfully weâre quite forgiving about this stuff, humans seem to model everything as intelligent, haha.</div><br/><div id="38834577" class="c"><input type="checkbox" id="c-38834577" checked=""/><div class="controls bullet"><span class="by">tmastny</span><span>|</span><a href="#38834509">parent</a><span>|</span><a href="#38834836">next</a><span>|</span><label class="collapse" for="c-38834577">[-]</label><label class="expand" for="c-38834577">[5 more]</label></div><br/><div class="children"><div class="content">Author here: That&#x27;s a cool idea, I hadn&#x27;t thought of that! It doesn&#x27;t quite work in the current implementation, but would with some small tweaks.<p>Basically we would need to have the enemy update their path only after a small delay (instead of every frame), so &quot;momentum&quot; would carry them on their existing path so the player could fake them out.</div><br/><div id="38834652" class="c"><input type="checkbox" id="c-38834652" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38834509">root</a><span>|</span><a href="#38834577">parent</a><span>|</span><a href="#38835307">next</a><span>|</span><label class="collapse" for="c-38834652">[-]</label><label class="expand" for="c-38834652">[3 more]</label></div><br/><div class="children"><div class="content">It could also be interesting to target a tile some number of nodes in front of the player, so the monster will go to âcut the player offâ sometimes. Maybe it could result in some interesting behavior if combined with your momentum idea. The goal of enemy AI is to be trick-able in a fun manner, right?<p>Of course, it is easy to come up with fun ideas for enemy AI, I think if you went after all of them youâd never have time to write the nice blog post.</div><br/><div id="38834828" class="c"><input type="checkbox" id="c-38834828" checked=""/><div class="controls bullet"><span class="by">OscarCunningham</span><span>|</span><a href="#38834509">root</a><span>|</span><a href="#38834652">parent</a><span>|</span><a href="#38835307">next</a><span>|</span><label class="collapse" for="c-38834828">[-]</label><label class="expand" for="c-38834828">[2 more]</label></div><br/><div class="children"><div class="content">You have invented the pink ghost from Pac-Man.</div><br/><div id="38834896" class="c"><input type="checkbox" id="c-38834896" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38834509">root</a><span>|</span><a href="#38834828">parent</a><span>|</span><a href="#38835307">next</a><span>|</span><label class="collapse" for="c-38834896">[-]</label><label class="expand" for="c-38834896">[1 more]</label></div><br/><div class="children"><div class="content">The pac-man ghost AIs are definitely worth a search, fun stuff from such a simple program.</div><br/></div></div></div></div></div></div><div id="38835307" class="c"><input type="checkbox" id="c-38835307" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#38834509">root</a><span>|</span><a href="#38834577">parent</a><span>|</span><a href="#38834652">prev</a><span>|</span><a href="#38834836">next</a><span>|</span><label class="collapse" for="c-38835307">[-]</label><label class="expand" for="c-38835307">[1 more]</label></div><br/><div class="children"><div class="content">&gt; instead of every frame<p>It&#x27;s wasteful to recompute paths every frame, since people don&#x27;t entirely rethink their gross movements every 16ms. Way back when I coded some monster pathfinding, I also randomized the re-pathing interval to avoid intermittent lag (multithreading wasn&#x27;t really a thing back then), which also made the monsters behave more realistically.</div><br/></div></div></div></div><div id="38834836" class="c"><input type="checkbox" id="c-38834836" checked=""/><div class="controls bullet"><span class="by">sitzkrieg</span><span>|</span><a href="#38834509">parent</a><span>|</span><a href="#38834577">prev</a><span>|</span><a href="#38836113">next</a><span>|</span><label class="collapse" for="c-38834836">[-]</label><label class="expand" for="c-38834836">[1 more]</label></div><br/><div class="children"><div class="content">i did exactly this implemented w a turn delay + &quot;scent trail following&quot; added on too, it works out nicely and at times looks like the ai is pausing to recollect itself before beelining towards the player lol</div><br/></div></div></div></div><div id="38836113" class="c"><input type="checkbox" id="c-38836113" checked=""/><div class="controls bullet"><span class="by">djmips</span><span>|</span><a href="#38834509">prev</a><span>|</span><a href="#38835610">next</a><span>|</span><label class="collapse" for="c-38836113">[-]</label><label class="expand" for="c-38836113">[4 more]</label></div><br/><div class="children"><div class="content">An interesting application of A* in a game context was a programmer who was faced with making the Computer opponents of a game in the early 2000s and what he came up with was an abstraction of the options the AI had in the game and used A* to find the closest distance in the graph. I thought it was pretty cool because it wasn&#x27;t using A* in the traditional way of pathfinding the world but instead pathfinding in a representation of choices the computer could make where the shortest path represented a possible best strategy.</div><br/><div id="38836579" class="c"><input type="checkbox" id="c-38836579" checked=""/><div class="controls bullet"><span class="by">adanto6840</span><span>|</span><a href="#38836113">parent</a><span>|</span><a href="#38838444">next</a><span>|</span><label class="collapse" for="c-38836579">[-]</label><label class="expand" for="c-38836579">[1 more]</label></div><br/><div class="children"><div class="content">One of the more common approaches to AI in games is called GOAP [0][1] (Goal Oriented Action Planning), and it essentially &quot;selects&quot; which action set using the same concept -- graph searching (typically using A*) the available options.<p>0 - <a href="https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;design&#x2F;building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning" rel="nofollow">https:&#x2F;&#x2F;www.gamedeveloper.com&#x2F;design&#x2F;building-the-ai-of-f-e-...</a><p>1 - <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230804100329&#x2F;https:&#x2F;&#x2F;alumni.media.mit.edu&#x2F;~jorkin&#x2F;goap.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230804100329&#x2F;https:&#x2F;&#x2F;alumni.me...</a><p>See also (not mine): <a href="https:&#x2F;&#x2F;github.com&#x2F;agoose77&#x2F;goap-resources">https:&#x2F;&#x2F;github.com&#x2F;agoose77&#x2F;goap-resources</a></div><br/></div></div><div id="38838444" class="c"><input type="checkbox" id="c-38838444" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#38836113">parent</a><span>|</span><a href="#38836579">prev</a><span>|</span><a href="#38836198">next</a><span>|</span><label class="collapse" for="c-38838444">[-]</label><label class="expand" for="c-38838444">[1 more]</label></div><br/><div class="children"><div class="content">I think the ability to use similar âplanningâ algorithms for walking through a room, choosing an option for attack&#x2F;defend&#x2F;use item, which enemy to target, may account for some of the attribution of intelligence to game AI. Humans seem to think they and other humans put as much thought and think in similar patterns about wildly dissimilar activities like planning a route or weighting risk&#x2F;reward or planning an event 6 months out. So the ability to encode a wide variety of âsearch spaceâ into an appropriate graph for use with a common algorithm lends a perceived verisimilitude to the AIâs thoughtfulness and near-personhood when immersed in play.</div><br/></div></div><div id="38836198" class="c"><input type="checkbox" id="c-38836198" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#38836113">parent</a><span>|</span><a href="#38838444">prev</a><span>|</span><a href="#38835610">next</a><span>|</span><label class="collapse" for="c-38836198">[-]</label><label class="expand" for="c-38836198">[1 more]</label></div><br/><div class="children"><div class="content">This is basically how you win every CodinGame Spring&#x2F;Fall Challenge, though you check many paths in parallel (beam search) instead of a single at a time (A*).</div><br/></div></div></div></div><div id="38835610" class="c"><input type="checkbox" id="c-38835610" checked=""/><div class="controls bullet"><span class="by">gwillz</span><span>|</span><a href="#38836113">prev</a><span>|</span><a href="#38836996">next</a><span>|</span><label class="collapse" for="c-38835610">[-]</label><label class="expand" for="c-38835610">[5 more]</label></div><br/><div class="children"><div class="content">I remember learning A* at uni while at the same time experiencing it&#x27;s quirks on our shared minecraft server.<p>The server was really chugging and so I ran a trace on it. I found the zombies were stuck in a loop trying to find their way into a village that we had completely secured with a large fence. Being a naive implementation (at the time) it meant they never gave up.<p>I recall there being a bug report with a good amount of detail about how they were going about fixing it.</div><br/><div id="38837137" class="c"><input type="checkbox" id="c-38837137" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#38835610">parent</a><span>|</span><a href="#38836482">next</a><span>|</span><label class="collapse" for="c-38837137">[-]</label><label class="expand" for="c-38837137">[1 more]</label></div><br/><div class="children"><div class="content">A similar long-time bug in Dwarf Fortress: if you have a door or hatch marked as impassable by animals, but a stray tame critter (usually a cat) wants to get through, it will never give up trying to find a path to the other side. This can have a very noticeable effect on your fps, especially if there are several animals all trying to get past the impassable portal.<p>(Of course, one could argue that it&#x27;s incredibly realistic behavior for a cat to very insistently demand to get past a closed door. It would be even more realistic if, once the door is finally opened, the cat would immediately change its mind and lose all interest in getting through!)</div><br/></div></div><div id="38836482" class="c"><input type="checkbox" id="c-38836482" checked=""/><div class="controls bullet"><span class="by">justinl33</span><span>|</span><a href="#38835610">parent</a><span>|</span><a href="#38837137">prev</a><span>|</span><a href="#38836996">next</a><span>|</span><label class="collapse" for="c-38836482">[-]</label><label class="expand" for="c-38836482">[3 more]</label></div><br/><div class="children"><div class="content">Been looking around for the past 10 minutes trying to find information on the mob-following implementation in Minecraft - can&#x27;t find a thing. I assume it&#x27;s just vanilla A* with some parameters?</div><br/><div id="38837031" class="c"><input type="checkbox" id="c-38837031" checked=""/><div class="controls bullet"><span class="by">gwillz</span><span>|</span><a href="#38835610">root</a><span>|</span><a href="#38836482">parent</a><span>|</span><a href="#38836996">next</a><span>|</span><label class="collapse" for="c-38837031">[-]</label><label class="expand" for="c-38837031">[2 more]</label></div><br/><div class="children"><div class="content">Found it!<p><a href="https:&#x2F;&#x2F;bugs.mojang.com&#x2F;browse&#x2F;MC-17630?focusedCommentId=92590&amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-92590" rel="nofollow">https:&#x2F;&#x2F;bugs.mojang.com&#x2F;browse&#x2F;MC-17630?focusedCommentId=925...</a></div><br/><div id="38839299" class="c"><input type="checkbox" id="c-38839299" checked=""/><div class="controls bullet"><span class="by">justinl33</span><span>|</span><a href="#38835610">root</a><span>|</span><a href="#38837031">parent</a><span>|</span><a href="#38836996">next</a><span>|</span><label class="collapse" for="c-38839299">[-]</label><label class="expand" for="c-38839299">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Since working the (apparently A</i>) pathfinding algorithm...*<p>Beautiful.</div><br/></div></div></div></div></div></div></div></div><div id="38836996" class="c"><input type="checkbox" id="c-38836996" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#38835610">prev</a><span>|</span><a href="#38835876">next</a><span>|</span><label class="collapse" for="c-38836996">[-]</label><label class="expand" for="c-38836996">[2 more]</label></div><br/><div class="children"><div class="content">Off topic, but tangentially related:<p>I was trying to use a modified Dijkstra &#x2F; A* algorithm for this yearâs Advent of Code Day 17 problem:<p><a href="https:&#x2F;&#x2F;adventofcode.com&#x2F;2023&#x2F;day&#x2F;17" rel="nofollow">https:&#x2F;&#x2F;adventofcode.com&#x2F;2023&#x2F;day&#x2F;17</a><p>I never got the right answer though because there was some issue with the way I was tracking visited nodes. I was trying to use north, south, west, east rather than row and column direction values like other solutions I read, but Iâm stubborn and it seems to me I should be able to get it work storing cell (as a (row, column) tuple)), direction, and distance travelled (1-3).<p>If you did this day, how did you do it?</div><br/><div id="38838216" class="c"><input type="checkbox" id="c-38838216" checked=""/><div class="controls bullet"><span class="by">Cogito</span><span>|</span><a href="#38836996">parent</a><span>|</span><a href="#38835876">next</a><span>|</span><label class="collapse" for="c-38838216">[-]</label><label class="expand" for="c-38838216">[1 more]</label></div><br/><div class="children"><div class="content">My search nodes were tuples of position, direction, and steps taken in the same direction.<p>More or less a straight depth first search with a priority queue from there.</div><br/></div></div></div></div><div id="38835876" class="c"><input type="checkbox" id="c-38835876" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#38836996">prev</a><span>|</span><a href="#38835448">next</a><span>|</span><label class="collapse" for="c-38835876">[-]</label><label class="expand" for="c-38835876">[2 more]</label></div><br/><div class="children"><div class="content">This article + this HN thread have some nice tricks. I haven&#x27;t needed A* for much (yet), but I do know there&#x27;s a nice Haskell library for it <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;astar-monad-0.3.0.0#readme" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;astar-monad-0.3.0.0#read...</a></div><br/><div id="38835914" class="c"><input type="checkbox" id="c-38835914" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#38835876">parent</a><span>|</span><a href="#38835448">next</a><span>|</span><label class="collapse" for="c-38835914">[-]</label><label class="expand" for="c-38835914">[1 more]</label></div><br/><div class="children"><div class="content">Apparently that&#x27;s deprecated in favor of monad-dijkstra! <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;monad-dijkstra" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;monad-dijkstra</a></div><br/></div></div></div></div><div id="38837230" class="c"><input type="checkbox" id="c-38837230" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#38835448">prev</a><span>|</span><a href="#38835323">next</a><span>|</span><label class="collapse" for="c-38837230">[-]</label><label class="expand" for="c-38837230">[1 more]</label></div><br/><div class="children"><div class="content">One neat pathfinding trick that I use for an in game GPS is to allow the user to specify multiple destinations and find the closest one. Rather than just running it multiple times, I temporarily add a synthetic node to each of the destinations and path to the synthetic node and then look at the previous node to figure out which one to go to.<p>Are there better ways?</div><br/></div></div><div id="38835323" class="c"><input type="checkbox" id="c-38835323" checked=""/><div class="controls bullet"><span class="by">antman</span><span>|</span><a href="#38837230">prev</a><span>|</span><a href="#38834446">next</a><span>|</span><label class="collapse" for="c-38835323">[-]</label><label class="expand" for="c-38835323">[1 more]</label></div><br/><div class="children"><div class="content">Check out dstar, take a look the graph at 3:36<p><a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=skK-3UfcXW0" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=skK-3UfcXW0</a></div><br/></div></div><div id="38834446" class="c"><input type="checkbox" id="c-38834446" checked=""/><div class="controls bullet"><span class="by">mysterydip</span><span>|</span><a href="#38835323">prev</a><span>|</span><a href="#38834910">next</a><span>|</span><label class="collapse" for="c-38834446">[-]</label><label class="expand" for="c-38834446">[3 more]</label></div><br/><div class="children"><div class="content">Any time A* comes up, someone plugs this great resource: <a href="https:&#x2F;&#x2F;www.redblobgames.com&#x2F;pathfinding&#x2F;a-star&#x2F;introduction.html" rel="nofollow">https:&#x2F;&#x2F;www.redblobgames.com&#x2F;pathfinding&#x2F;a-star&#x2F;introduction...</a></div><br/><div id="38835057" class="c"><input type="checkbox" id="c-38835057" checked=""/><div class="controls bullet"><span class="by">urbandw311er</span><span>|</span><a href="#38834446">parent</a><span>|</span><a href="#38834910">next</a><span>|</span><label class="collapse" for="c-38835057">[-]</label><label class="expand" for="c-38835057">[2 more]</label></div><br/><div class="children"><div class="content">The next big advance after A* is something called [contraction hierarchies](<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Contraction_hierarchies" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Contraction_hierarchies</a>)<p>Iâd love to see a âpart 2â of this resource or similar that explains those in this kind of Laymans terms. There were some white papers but then I suspect the big tech companies started to guard this research a little more closely once its potential to give a commercial edge became apparent.</div><br/><div id="38835639" class="c"><input type="checkbox" id="c-38835639" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#38834446">root</a><span>|</span><a href="#38835057">parent</a><span>|</span><a href="#38834910">next</a><span>|</span><label class="collapse" for="c-38835639">[-]</label><label class="expand" for="c-38835639">[1 more]</label></div><br/><div class="children"><div class="content">See also <i>Time-Dependent Contraction Hierarchies</i> (2008) [pdf] <a href="https:&#x2F;&#x2F;algo2.iti.kit.edu&#x2F;documents&#x2F;routeplanning&#x2F;tch_alenex09.pdf" rel="nofollow">https:&#x2F;&#x2F;algo2.iti.kit.edu&#x2F;documents&#x2F;routeplanning&#x2F;tch_alenex...</a><p>Oh the fun of cobbling heuristic algorithms to work in the real-world where precise algorithms are big-O too slow.</div><br/></div></div></div></div></div></div><div id="38834910" class="c"><input type="checkbox" id="c-38834910" checked=""/><div class="controls bullet"><span class="by">slowhadoken</span><span>|</span><a href="#38834446">prev</a><span>|</span><a href="#38835965">next</a><span>|</span><label class="collapse" for="c-38834910">[-]</label><label class="expand" for="c-38834910">[5 more]</label></div><br/><div class="children"><div class="content">A* is cool but pixel base solutions are naive. Also Dijkstra with a heuristic is just the beginning to a A.I. rabbit hole.</div><br/><div id="38835096" class="c"><input type="checkbox" id="c-38835096" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#38834910">parent</a><span>|</span><a href="#38835965">next</a><span>|</span><label class="collapse" for="c-38835096">[-]</label><label class="expand" for="c-38835096">[4 more]</label></div><br/><div class="children"><div class="content">&gt; pixel base solutions are naive.<p>Why, and what do you mean, and what are the alternatives? Pixels are just the search space and may have nothing to do with the sophistication level of the search algorithm, no? In the case of simple 2d games that can run on retro hardware, searching over pixels may be the best thing to do with limited memory and limited cycles, itâs why they often do collision detection on pixels as well.</div><br/><div id="38835648" class="c"><input type="checkbox" id="c-38835648" checked=""/><div class="controls bullet"><span class="by">Arch485</span><span>|</span><a href="#38834910">root</a><span>|</span><a href="#38835096">parent</a><span>|</span><a href="#38835851">next</a><span>|</span><label class="collapse" for="c-38835648">[-]</label><label class="expand" for="c-38835648">[2 more]</label></div><br/><div class="children"><div class="content">If every tile in the game (&quot;tile&quot; being some discrete unit of walkable&#x2F;not walkable) is 8px by 8px, then you&#x27;re doing 64x the work you need to. The tile data will also be stored somewhere anyways to handle player collisions etc. (except in cases where memory is _extremely_ limited, but those are rare - in that case pixel data is used, as you suggested)</div><br/><div id="38835924" class="c"><input type="checkbox" id="c-38835924" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#38834910">root</a><span>|</span><a href="#38835648">parent</a><span>|</span><a href="#38835851">next</a><span>|</span><label class="collapse" for="c-38835924">[-]</label><label class="expand" for="c-38835924">[1 more]</label></div><br/><div class="children"><div class="content">True, but if players and AI and game elements can move in units of pixels, and exist in multiple tiles at once, the it may be difficult to work in units of tiles. Not clear the parent was distinguishing between pixels and tiles too, or if the ânaiveâ comment was aimed at any kind of gridding, or something else.</div><br/></div></div></div></div><div id="38835851" class="c"><input type="checkbox" id="c-38835851" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#38834910">root</a><span>|</span><a href="#38835096">parent</a><span>|</span><a href="#38835648">prev</a><span>|</span><a href="#38835965">next</a><span>|</span><label class="collapse" for="c-38835851">[-]</label><label class="expand" for="c-38835851">[1 more]</label></div><br/><div class="children"><div class="content">Voronoi graphs are a fast option to get you in the approximate area, then a fine grid can do the last-mile part if need be. It does require preprocessing the map first though.</div><br/></div></div></div></div></div></div><div id="38835965" class="c"><input type="checkbox" id="c-38835965" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38834910">prev</a><span>|</span><a href="#38834289">next</a><span>|</span><label class="collapse" for="c-38835965">[-]</label><label class="expand" for="c-38835965">[1 more]</label></div><br/><div class="children"><div class="content">Some other tricks:<p>* If you assign terrain costs to <i>tiles</i> rather than borders (= paths) between tiles, that creates a user-visible asymmetry! ... unless the cost is always max() of the two tile costs or something.<p>* The direction in which you run the algorithm matters, especially if you&#x27;re doing one-to-many or partial paths. That said, it <i>is</i> possible to do any-to-goal directly, by adding an extra field to your datum.<p>* A* fails pretty badly on C-shaped obstacles<p>* You need to have an admissible heuristic. This means no negative (usually stricter, in fact: not less than 1) weights (usually reasonable, but can cause complications if you <i>want</i> to funnel traffic onto &quot;highways&quot; even if that&#x27;s slightly longer), and makes teleporters complicated:<p><pre><code>    \* if a teleporter connects to all other teleporters, the new heuristic is `min(old heuristic, heuristic to the nearest teleporter, heuristic from the teleporter to the goal)

    \* if sets of teleporters are unrelated, you probably want to preprocess paths between every pair of teleporters. Doing this without unnecessary work is left as an exercise for the reader.
</code></pre>
* If you have a convex walkable area, you know that the shortest path between <i>any</i> two points within it is a straight line, and this can significantly shorten A*. Note that a given tile will almost always be part of more than one such useful area (you certainly don&#x27;t want to consider all valid areas), and this should not be limited to rectangular areas (in particular, don&#x27;t let diagonal corridors be a worst case). It&#x27;s okay to exclude &quot;pocket&quot; tiles near the wall; they&#x27;ll still exist as individual tiles for pathfinding purposes if you really need to go there.<p>* Optimization gets harder if your map has multiple movement types (e.g. walk, swim, fly) and individual entities can exercise more than one of those.<p>* When pathfinding across multiple maps (hierarchial pathfinding is important), the shortest connectivity is not necessarily the shortest path. Sometimes cutting through a building is faster than going around it. If your transitions are not point-like, even recording shortest paths between all such transitions isn&#x27;t enough. (imagine  citygate| .house. |citygate, where the house transitions are small enough to not be part of the shortest paths from the extremity of one gate to the other, but are optimal if you start at the center of the gate)<p><pre><code>    \* speaking of non-point-like transitions, *please* preserve relative position at least somewhat. Instead of &quot;entering this transition line teleports you to this point on the other map&quot;, use &quot;entering this transition line teleports you to the equivalent (with scaling if needed) position along this other transition line&quot;. It&#x27;s not hard when I say it like that, right? (even if you want one-way transitions, you should model them as a transition that is currently disabled, so your target is homogeneous)
</code></pre>
* Even if you do run a full A*, you don&#x27;t have to store every node, only nodes where you turn (this usually beats storing immediate direction for every node, except for extreme mazes of twisty little passages). Rounded convex obstacles (thus concave open spaces) are your enemy unless you also add wall-sliding logic here.</div><br/></div></div><div id="38834289" class="c"><input type="checkbox" id="c-38834289" checked=""/><div class="controls bullet"><span class="by">markisus</span><span>|</span><a href="#38835965">prev</a><span>|</span><a href="#38836628">next</a><span>|</span><label class="collapse" for="c-38834289">[-]</label><label class="expand" for="c-38834289">[5 more]</label></div><br/><div class="children"><div class="content">It would be interesting to see these classical methods compared to a simple RL method that optimizes a tiny neural net or decision tree which is given access to the map, player, and monster positions. I think it would cost a tiny bit more compute but have fewer annoying edge cases.</div><br/><div id="38834473" class="c"><input type="checkbox" id="c-38834473" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#38834289">parent</a><span>|</span><a href="#38835189">next</a><span>|</span><label class="collapse" for="c-38834473">[-]</label><label class="expand" for="c-38834473">[1 more]</label></div><br/><div class="children"><div class="content">I suspect that it would have a similar number of edge cases, but they would be harder to interpret and reproduce. That&#x27;s just been my experience with moving from unlearned algorithms to deep learning in general.</div><br/></div></div><div id="38835189" class="c"><input type="checkbox" id="c-38835189" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#38834289">parent</a><span>|</span><a href="#38834473">prev</a><span>|</span><a href="#38835022">next</a><span>|</span><label class="collapse" for="c-38835189">[-]</label><label class="expand" for="c-38835189">[1 more]</label></div><br/><div class="children"><div class="content">Usually what happens in cases like this is that the RL network ends up learning a slightly crappier version of A*<p>Or finds a bug in the environment and learns to teleport, those are fun too</div><br/></div></div><div id="38835022" class="c"><input type="checkbox" id="c-38835022" checked=""/><div class="controls bullet"><span class="by">qumpis</span><span>|</span><a href="#38834289">parent</a><span>|</span><a href="#38835189">prev</a><span>|</span><a href="#38836628">next</a><span>|</span><label class="collapse" for="c-38835022">[-]</label><label class="expand" for="c-38835022">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen RL with decision trees! it sounds really interesting. Any classic results worth looking into?</div><br/><div id="38835574" class="c"><input type="checkbox" id="c-38835574" checked=""/><div class="controls bullet"><span class="by">markisus</span><span>|</span><a href="#38834289">root</a><span>|</span><a href="#38835022">parent</a><span>|</span><a href="#38836628">next</a><span>|</span><label class="collapse" for="c-38835574">[-]</label><label class="expand" for="c-38835574">[1 more]</label></div><br/><div class="children"><div class="content">This is a relatively recent paper you might find interesting. <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2204.03771" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2204.03771</a><p>A random forest is also a universal function approximator so anything a neural net can do, so can a random forest (in theory). In practice, neural nets are easier for modern hardware to optimize while I think trees incur computational overhead due to branchiness.</div><br/></div></div></div></div></div></div><div id="38836628" class="c"><input type="checkbox" id="c-38836628" checked=""/><div class="controls bullet"><span class="by">initplus</span><span>|</span><a href="#38834289">prev</a><span>|</span><a href="#38835983">next</a><span>|</span><label class="collapse" for="c-38836628">[-]</label><label class="expand" for="c-38836628">[1 more]</label></div><br/><div class="children"><div class="content">Naive implementations of A* can break down in some common scenarios, with highly connected graphs where many solutions exist. Imagine a long barrier with the start and goal placed on either side at the exact midpoint.<p>Tie handling is really important! A* is often described as minimizing f(n), where f(n) = g(n) + h(n), g(n) = path distance so far, h(n) = distance to goal heuristic. But for any valid shortest path the remaining work for the algorithm to do is determined by the size of g(n). So when selecting the next node to explore you must minimize first by f(n), and then maximize  g(n) as a tiebreaker. Same is achieved by breaking ties with LIFO.</div><br/></div></div><div id="38835983" class="c"><input type="checkbox" id="c-38835983" checked=""/><div class="controls bullet"><span class="by">deadbabe</span><span>|</span><a href="#38836628">prev</a><span>|</span><label class="collapse" for="c-38835983">[-]</label><label class="expand" for="c-38835983">[2 more]</label></div><br/><div class="children"><div class="content">Can someone share tips for A* pathfinding where NPCs have limited knowledge about the map, where they must got from point A to point B without knowing entirely about whatâs in between?</div><br/><div id="38836071" class="c"><input type="checkbox" id="c-38836071" checked=""/><div class="controls bullet"><span class="by">mm_aa</span><span>|</span><a href="#38835983">parent</a><span>|</span><label class="collapse" for="c-38836071">[-]</label><label class="expand" for="c-38836071">[1 more]</label></div><br/><div class="children"><div class="content">Micromouse competition is exactly about this. There are plenty of algorithms published. Some version of flood fill is the most popular I think.</div><br/></div></div></div></div></div></div></div></div></div></body></html>