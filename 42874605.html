<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738227667500" as="style"/><link rel="stylesheet" href="styles.css?v=1738227667500"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2022/10/06/hard-mode-rust.html">Hard Mode Rust</a> <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>rrampage</span> | <span>19 comments</span></div><br/><div><div id="42875725" class="c"><input type="checkbox" id="c-42875725" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#42875630">next</a><span>|</span><label class="collapse" for="c-42875725">[-]</label><label class="expand" for="c-42875725">[4 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help but feel this is reintroducing some of the problems it claims to solve in working around the difficulties.<p>* The fact that there is an `Oom` error that can be thrown means that there is no increase in reliability: you still don&#x27;t know how much memory you&#x27;re going to need, but now you have the added problem of asking the user for how much memory you&#x27;re going to be using — which they are going to be guessing blindly on!<p>* This is because the memory usage is not much more predictable than it would be in easy mode Rust. (Also that &quot;mem.lem()&#x2F;2&quot; scratch space is kind of crappy; if you&#x27;re going to do this, do it well. Perhaps in allocating the <i>correct</i> amount of scratch space, you end up with a dynamic allocator at the end of your memory. Does that sound like stack space at the start of memory and heap space at the end of memory? Yes, your programming language does that for you already, but built-in instead of bolted-on.)<p>* Furthermore, the &quot;easy mode&quot; code uses lots of Box, but if you want you can get the benefits of RAII without all the boxes by allocating owned vectors scrupulously. Then you get the benefit of an ownership tracking system in the language&#x27;s typesystem without having to `unsafe` your way to a half reimplementation of the same. You can get your performance without most of the mess.<p>* Spaghetti can be avoided (if you so desire) in the same way as the previous point.<p>What you do achieve is that at least you can <i>test</i> that Oom condition. Perhaps what you actually want is an allocator that allows for simulating a particular max heap size.</div><br/><div id="42875774" class="c"><input type="checkbox" id="c-42875774" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42875725">parent</a><span>|</span><a href="#42875630">next</a><span>|</span><label class="collapse" for="c-42875774">[-]</label><label class="expand" for="c-42875774">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I can&#x27;t help but feel this is reintroducing some of the problems it claims to solve in working around the difficulties.<p>When I read <i>&quot;So we do need to write our own allocator&quot;</i>, I winced. Almost every time I&#x27;ve had to hunt down a hard bug in a Rust crate, one that requires a debugger, it turns out to be someone who wrote their own unsafe allocator and botched the job.</div><br/><div id="42875928" class="c"><input type="checkbox" id="c-42875928" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42875725">root</a><span>|</span><a href="#42875774">parent</a><span>|</span><a href="#42875630">next</a><span>|</span><label class="collapse" for="c-42875928">[-]</label><label class="expand" for="c-42875928">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why languages like Zig come with several specialized allocators implemented in the stdlib which can be plugged into any other code in the stdlib that needs to allocate memory. You <i>can</i> still implement your own allocator of course, but often there&#x27;s one already in the stdlib that fits your need (especially also because allocators are stackable&#x2F;composable).</div><br/><div id="42876140" class="c"><input type="checkbox" id="c-42876140" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42875725">root</a><span>|</span><a href="#42875928">parent</a><span>|</span><a href="#42875630">next</a><span>|</span><label class="collapse" for="c-42876140">[-]</label><label class="expand" for="c-42876140">[1 more]</label></div><br/><div class="children"><div class="content">Rust also has a bunch of tested allocators ready to use, though usually in the form of crates (jemalloc, mimalloc, slab allocators, what have you). The problems caused by people implementing custom allocators are no different in either Rust or Zig.</div><br/></div></div></div></div></div></div></div></div><div id="42875630" class="c"><input type="checkbox" id="c-42875630" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42875725">prev</a><span>|</span><a href="#42876066">next</a><span>|</span><label class="collapse" for="c-42875630">[-]</label><label class="expand" for="c-42875630">[3 more]</label></div><br/><div class="children"><div class="content">The criticism of RAII is a little odd to me.  The author list four bullet points as to why RAII is bad, but I don&#x27;t think I&#x27;ve ever found them to be an issue in practice.  When I&#x27;m writing C (which of course does not have RAII), I rarely think all that deeply about how much I am allocating.  But I also don&#x27;t write C for embedded&#x2F;constrained devices anymore.</div><br/><div id="42875912" class="c"><input type="checkbox" id="c-42875912" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#42875630">parent</a><span>|</span><a href="#42875868">next</a><span>|</span><label class="collapse" for="c-42875912">[-]</label><label class="expand" for="c-42875912">[1 more]</label></div><br/><div class="children"><div class="content">Allocating in the hot path degrades the performance unless you&#x27;re using an allocator that is designed for that and you are hand-tuning to not need to allocate more memory.
This can be a game or anything with a hot path you care about, doesn&#x27;t have to be deployed on an embedded device.</div><br/></div></div><div id="42875868" class="c"><input type="checkbox" id="c-42875868" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42875630">parent</a><span>|</span><a href="#42875912">prev</a><span>|</span><a href="#42876066">next</a><span>|</span><label class="collapse" for="c-42875868">[-]</label><label class="expand" for="c-42875868">[1 more]</label></div><br/><div class="children"><div class="content">It mostly becomes a problem at scale when you need to juggle tens or hundreds of thousands of &#x27;objects&#x27; with unpredictable lifetimes and complex interrelationships. The cases where I have seen granular memory allocation become a problem were mostly game code bases which started small and simple (e.g. a programmer implemented a new system with let&#x27;s say a hundred items to handle in mind, but for one or another reason, 3 years later that system needs to handle tens of thousands of items).</div><br/></div></div></div></div><div id="42876066" class="c"><input type="checkbox" id="c-42876066" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#42875630">prev</a><span>|</span><a href="#42875519">next</a><span>|</span><label class="collapse" for="c-42876066">[-]</label><label class="expand" for="c-42876066">[1 more]</label></div><br/><div class="children"><div class="content">So, it&#x27;s just arena allocator, which is still RAII.</div><br/></div></div><div id="42875519" class="c"><input type="checkbox" id="c-42875519" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#42876066">prev</a><span>|</span><a href="#42875412">next</a><span>|</span><label class="collapse" for="c-42875519">[-]</label><label class="expand" for="c-42875519">[5 more]</label></div><br/><div class="children"><div class="content">The article starts with:<p><pre><code>    &gt; This criticism is aimed at RAII — the language-defining feature of C++, which was wholesale imported to Rust as well.

    &gt; because allocating resources becomes easy, RAII encourages a sloppy attitude to resources
</code></pre>
Then lists 4x bullet points about why it is bad.<p>I never once heard this criticism for RAII in C++.  Am I missing something?  Coming from C to C++, RAII was a godsend for me regarding resource clean-up.</div><br/><div id="42875786" class="c"><input type="checkbox" id="c-42875786" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42875519">parent</a><span>|</span><a href="#42875603">next</a><span>|</span><label class="collapse" for="c-42875786">[-]</label><label class="expand" for="c-42875786">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite common knowledge in the gamedev world (at least the part that writes C++ code, the other parts that uses C# or JS has roughly the same problem, just caused by unpredictable GC behaviour).<p>Towards the end of the 90s, game development transitioned from C to C++, and was also infected by the almighty OOP brain virus. The result was often code which allocated each tiny object on the heap and managed object lifetime through smart pointers (often shared pointers for everything). Then deep into development after a million lines of code there&#x27;s &#x27;suddenly&#x27; thousands of tiny alloc&#x2F;frees per frame and all over the codebase but hidden from view because the free happens implicitly via RAII - and I have to admit in shame that I was actively contributing to this code style in my youth before the quite obvious realization (supported by hard profiling data) that automatic memory management isn&#x27;t free ;)<p>Also the infamous &#x27;25k allocs per keystroke&#x27; in Chrome because of sloppy std::string usage:<p><a href="https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;g&#x2F;chromium-dev&#x2F;c&#x2F;EUqoIz2iFU4&#x2F;m&#x2F;kPZ5ZK0K3gEJ" rel="nofollow">https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;g&#x2F;chromium-dev&#x2F;c&#x2F;EU...</a><p>Apart from performance, the other problem is debuggability. If you have a lot of &#x27;memory allocation noise&#x27; to sift though in the memory debugger, it&#x27;s hard to find the one allocation that causes problems.</div><br/></div></div><div id="42875603" class="c"><input type="checkbox" id="c-42875603" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#42875519">parent</a><span>|</span><a href="#42875786">prev</a><span>|</span><a href="#42875597">next</a><span>|</span><label class="collapse" for="c-42875603">[-]</label><label class="expand" for="c-42875603">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Poor performance. Usually, it is significantly more efficient to allocate and free resources in batches.<p>This one is big. It is a lot of accounting work to individually allocate and deallocate a lot of objects.<p>The Zig approach is to force you to decide on and write all of your allocation and deallocation code, which I found leads to more performant code almost by default – Rust is explicitly leaving that on the table. C obviously works the same way, but doesn&#x27;t have an arena allocator in the standard library.<p>Re: C++ vs Rust, it might be more of a pain in Rust because of this: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33637092">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33637092</a></div><br/><div id="42875791" class="c"><input type="checkbox" id="c-42875791" checked=""/><div class="controls bullet"><span class="by">ladyanita22</span><span>|</span><a href="#42875519">root</a><span>|</span><a href="#42875603">parent</a><span>|</span><a href="#42875597">next</a><span>|</span><label class="collapse" for="c-42875791">[-]</label><label class="expand" for="c-42875791">[1 more]</label></div><br/><div class="children"><div class="content">I am happy that Rust defaults to the easier, saner, safer approach by default, but lets you bypass RAII if you want to do so.</div><br/></div></div></div></div><div id="42875597" class="c"><input type="checkbox" id="c-42875597" checked=""/><div class="controls bullet"><span class="by">Hemospectrum</span><span>|</span><a href="#42875519">parent</a><span>|</span><a href="#42875603">prev</a><span>|</span><a href="#42875412">next</a><span>|</span><label class="collapse" for="c-42875597">[-]</label><label class="expand" for="c-42875597">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re most likely to hear it from kernel programmers and Go&#x2F;Zig&#x2F;Odin advocates, but it rarely comes up as a criticism of C++ in particular. Perhaps that&#x27;s because RAII is merely &quot;distasteful&quot; in that cohort, whereas there are many other qualities of C++ that might be considered total showstoppers for adoption before matters of taste are ever on the table.<p>There was an HN thread a few months ago[0] debating whether RAII is reason enough to disqualify Rust as a systems language, with some strong opinions in both directions.<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42291417">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42291417</a></div><br/></div></div></div></div><div id="42875412" class="c"><input type="checkbox" id="c-42875412" checked=""/><div class="controls bullet"><span class="by">akshayshah</span><span>|</span><a href="#42875519">prev</a><span>|</span><a href="#42875640">next</a><span>|</span><label class="collapse" for="c-42875412">[-]</label><label class="expand" for="c-42875412">[2 more]</label></div><br/><div class="children"><div class="content">It’s interesting that the author now works on TigerBeetle (written in Zig). As I understand it, TigerBeetle’s style guide leans heavily on this style of resource management.</div><br/><div id="42875611" class="c"><input type="checkbox" id="c-42875611" checked=""/><div class="controls bullet"><span class="by">messe</span><span>|</span><a href="#42875412">parent</a><span>|</span><a href="#42875640">next</a><span>|</span><label class="collapse" for="c-42875611">[-]</label><label class="expand" for="c-42875611">[1 more]</label></div><br/><div class="children"><div class="content">Explicitly marking areas of code that allocate is a core part of idiomatic Zig, so that doesn&#x27;t surprise me all that much.</div><br/></div></div></div></div><div id="42875640" class="c"><input type="checkbox" id="c-42875640" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#42875412">prev</a><span>|</span><label class="collapse" for="c-42875640">[-]</label><label class="expand" for="c-42875640">[3 more]</label></div><br/><div class="children"><div class="content">I usually like matklad&#x27;s writings but I have to be overly dismissive for a change.<p>This is a skill issue.<p>C, C++, Rust, it doesn&#x27;t matter - if you have a systems problem where you are concerned about resource constraints and you need to care about worst-case resource allocation, you <i>must</i> consider the worst case when you are designing the program. RAII does not solve this problem, it never did, and anyone who thinks it does needs to practice programming more.<p>It is not &quot;hard&quot; to solve though. It&#x27;s just another thing your compiler can&#x27;t track and you need to be reasonably intelligent about. There are sections of a program that cannot tolerate resource exhaustion, for which you set some limit, which is then programmable in some way, which then uses some shared state to acquire and release things of which RAII may help. But you still must handle or otherwise report failures.<p>This is a bread and butter architecture concern for systems programming and if you&#x27;re <i>not</i> doing it, get good at it.</div><br/><div id="42876019" class="c"><input type="checkbox" id="c-42876019" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42875640">parent</a><span>|</span><a href="#42875845">next</a><span>|</span><label class="collapse" for="c-42876019">[-]</label><label class="expand" for="c-42876019">[1 more]</label></div><br/><div class="children"><div class="content">As long the language in question is turing-complete, everything is equally a skill issue.</div><br/></div></div><div id="42875845" class="c"><input type="checkbox" id="c-42875845" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42875640">parent</a><span>|</span><a href="#42876019">prev</a><span>|</span><label class="collapse" for="c-42875845">[-]</label><label class="expand" for="c-42875845">[1 more]</label></div><br/><div class="children"><div class="content">Just like writing memory safe code in C is a skill issue right? ;)<p>(I write mostly C code myself, but I&#x27;m also not immune to f*cking up now and then even though I write code for a long time)</div><br/></div></div></div></div></div></div></div></div></div></body></html>