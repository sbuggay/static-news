<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722416514608" as="style"/><link rel="stylesheet" href="styles.css?v=1722416514608"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://words.filippo.io/rustgo/">Rustgo: Calling Rust from Go with near-zero overhead (2017)</a> <span class="domain">(<a href="https://words.filippo.io">words.filippo.io</a>)</span></div><div class="subtext"><span>telotortium</span> | <span>20 comments</span></div><br/><div><div id="41117473" class="c"><input type="checkbox" id="c-41117473" checked=""/><div class="controls bullet"><span class="by">yutijke</span><span>|</span><a href="#41117454">next</a><span>|</span><label class="collapse" for="c-41117473">[-]</label><label class="expand" for="c-41117473">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;petermattis&#x2F;fastcgo">https:&#x2F;&#x2F;github.com&#x2F;petermattis&#x2F;fastcgo</a>, which is now 7 years old seems to do something similar with but with less requirement to know about obscure CGO FFI configuration. It is also seems more generally applicable for any language with C interop.<p>There had been an issue for having something similar in the language itself - <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;42469">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;42469</a>, but the Golang compiler team rejected it. If you have followed similar discussions around this with the Golang compiler team, you will notice a pattern of interaction that strongly indicates that they are very much opposed to ever accepting this into the compiler.</div><br/></div></div><div id="41117454" class="c"><input type="checkbox" id="c-41117454" checked=""/><div class="controls bullet"><span class="by">odanalysis</span><span>|</span><a href="#41117473">prev</a><span>|</span><a href="#41116725">next</a><span>|</span><label class="collapse" for="c-41117454">[-]</label><label class="expand" for="c-41117454">[1 more]</label></div><br/><div class="children"><div class="content">Does this mean you could now use gokrazy to run rust apps on an sbc with better startup speeds than linux??</div><br/></div></div><div id="41116725" class="c"><input type="checkbox" id="c-41116725" checked=""/><div class="controls bullet"><span class="by">gnabgib</span><span>|</span><a href="#41117454">prev</a><span>|</span><a href="#41117311">next</a><span>|</span><label class="collapse" for="c-41116725">[-]</label><label class="expand" for="c-41116725">[1 more]</label></div><br/><div class="children"><div class="content">(2017) Discussions:<p>2017 (282 points, 68 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15017519">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15017519</a><p>2019 (107 points, 37 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20600178">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20600178</a></div><br/></div></div><div id="41117311" class="c"><input type="checkbox" id="c-41117311" checked=""/><div class="controls bullet"><span class="by">nickcw</span><span>|</span><a href="#41116725">prev</a><span>|</span><a href="#41116881">next</a><span>|</span><label class="collapse" for="c-41117311">[-]</label><label class="expand" for="c-41117311">[1 more]</label></div><br/><div class="children"><div class="content">That was a great read. All that linker wrangling is sure to break on the next version of go&#x2F;rust&#x2F;linker isn&#x27;t it?<p>I wonder if it would have been easier to disassemble the rust binary and turn it into Go assembly and use that.<p>That would need a fairly complicated program to process the binary back into assembler. Maybe getting the rust compiler to output assembly and processing into Go assembly would be the way.<p>Using Go assembly would save fighting with the linker, be more likely to survive upgrades and it would be cross platform (well at least on platforms with the same CPU arch).</div><br/></div></div><div id="41116881" class="c"><input type="checkbox" id="c-41116881" checked=""/><div class="controls bullet"><span class="by">zxilly</span><span>|</span><a href="#41117311">prev</a><span>|</span><a href="#41117041">next</a><span>|</span><label class="collapse" for="c-41116881">[-]</label><label class="expand" for="c-41116881">[3 more]</label></div><br/><div class="children"><div class="content">There are many years since the article being written. I&#x27;m wondering if there is a better solution in 2024.</div><br/><div id="41117080" class="c"><input type="checkbox" id="c-41117080" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#41116881">parent</a><span>|</span><a href="#41117001">next</a><span>|</span><label class="collapse" for="c-41117080">[-]</label><label class="expand" for="c-41117080">[1 more]</label></div><br/><div class="children"><div class="content">Cgo overhead was made 5-30x faster in go1.21, and it was already within noise levels in this article, so i&#x27;d use that.</div><br/></div></div><div id="41117001" class="c"><input type="checkbox" id="c-41117001" checked=""/><div class="controls bullet"><span class="by">ozgrakkurt</span><span>|</span><a href="#41116881">parent</a><span>|</span><a href="#41117080">prev</a><span>|</span><a href="#41117041">next</a><span>|</span><label class="collapse" for="c-41117001">[-]</label><label class="expand" for="c-41117001">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t seem like there is. Probably because go developers want code to be pure go if possible</div><br/></div></div></div></div><div id="41117041" class="c"><input type="checkbox" id="c-41117041" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41116881">prev</a><span>|</span><a href="#41117164">next</a><span>|</span><label class="collapse" for="c-41117041">[-]</label><label class="expand" for="c-41117041">[1 more]</label></div><br/><div class="children"><div class="content">This is totally sick! I can&#x27;t wait to go through these repro steps using new versions.</div><br/></div></div><div id="41117164" class="c"><input type="checkbox" id="c-41117164" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#41117041">prev</a><span>|</span><a href="#41116891">next</a><span>|</span><label class="collapse" for="c-41117164">[-]</label><label class="expand" for="c-41117164">[10 more]</label></div><br/><div class="children"><div class="content">What is the benefit of this?<p>I was under the impression that go isn&#x27;t that far off from rust on most speed metrics being both compiled. So this adds complexity for what gain?</div><br/><div id="41117172" class="c"><input type="checkbox" id="c-41117172" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#41117164">parent</a><span>|</span><a href="#41117305">next</a><span>|</span><label class="collapse" for="c-41117172">[-]</label><label class="expand" for="c-41117172">[1 more]</label></div><br/><div class="children"><div class="content">In benchmarks I&#x27;ve seen, Go is ~6 times slower.<p>But generally speaking, the reason I prefer Rust to Go for most developments is its type system. I could see myself using Rust to handle business-specific&#x2F;safety-critical logic and Go as a fast prototyping language to assemble them.</div><br/></div></div><div id="41117305" class="c"><input type="checkbox" id="c-41117305" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#41117164">parent</a><span>|</span><a href="#41117172">prev</a><span>|</span><a href="#41117287">next</a><span>|</span><label class="collapse" for="c-41117305">[-]</label><label class="expand" for="c-41117305">[1 more]</label></div><br/><div class="children"><div class="content">&gt; go isn&#x27;t that far off from rust on most speed metrics being both compiled<p>The only way I see this happening for the same code snippet is if the Rust code was being compiled in debug mode instead of release mode.</div><br/></div></div><div id="41117287" class="c"><input type="checkbox" id="c-41117287" checked=""/><div class="controls bullet"><span class="by">aranw</span><span>|</span><a href="#41117164">parent</a><span>|</span><a href="#41117305">prev</a><span>|</span><a href="#41117179">next</a><span>|</span><label class="collapse" for="c-41117287">[-]</label><label class="expand" for="c-41117287">[1 more]</label></div><br/><div class="children"><div class="content">The benefit isn&#x27;t necessarily for speed there are some libraries for example available in Rust that are not in Go. This is something I am exploring at the moment rather than having to totally rewrite the library in Go</div><br/></div></div><div id="41117179" class="c"><input type="checkbox" id="c-41117179" checked=""/><div class="controls bullet"><span class="by">null_investor</span><span>|</span><a href="#41117164">parent</a><span>|</span><a href="#41117287">prev</a><span>|</span><a href="#41116891">next</a><span>|</span><label class="collapse" for="c-41117179">[-]</label><label class="expand" for="c-41117179">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s widely incorrect, Rust and C are like 2-5x faster than Go?<p>Go has arguably a better concurrency model, so for some usecases it can work much better, but for some realtime programming stuff, Go is a no-go ba-dum-tss.<p>For webdev I would never chose Rust over Go, each language has their own advantage.</div><br/><div id="41117207" class="c"><input type="checkbox" id="c-41117207" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41117164">root</a><span>|</span><a href="#41117179">parent</a><span>|</span><a href="#41117346">next</a><span>|</span><label class="collapse" for="c-41117207">[-]</label><label class="expand" for="c-41117207">[3 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s concurrency model lets you just access the same mutable variable from multiple goroutines - that kind of &quot;good model&quot; you can also get with C and some implementation of channels and green threads.</div><br/><div id="41117463" class="c"><input type="checkbox" id="c-41117463" checked=""/><div class="controls bullet"><span class="by">null_investor</span><span>|</span><a href="#41117164">root</a><span>|</span><a href="#41117207">parent</a><span>|</span><a href="#41117414">next</a><span>|</span><label class="collapse" for="c-41117463">[-]</label><label class="expand" for="c-41117463">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but having coded in both languages you can see how Go&#x27;s concurrency system works well with it and fits neatly.<p>Try using async in Rust and you&#x27;ll see what I mean, it sucks to use it.<p>The same applies to cpp, you&#x27;ll need years and years of experience to write somewhat decent cpp what you can write in Go with a few weeks learning coroutines, and will still be prone to make mistakes. I&#x27;ve done lots of cpp and can affirm that after decades I&#x27;m still not sure if my concurrent solution will run as well as my half-assed Go coroutine code.<p>Go coroutines is a good abstraction that is very fitting to the language, similar to the actor model and the BEAM VM (erlang&#x2F;elixir).<p>Use the same abstraction in another language (like JVM or C) and you&#x27;ll see how the devex makes a huge difference.</div><br/></div></div><div id="41117414" class="c"><input type="checkbox" id="c-41117414" checked=""/><div class="controls bullet"><span class="by">brightball</span><span>|</span><a href="#41117164">root</a><span>|</span><a href="#41117207">parent</a><span>|</span><a href="#41117463">prev</a><span>|</span><a href="#41117346">next</a><span>|</span><label class="collapse" for="c-41117414">[-]</label><label class="expand" for="c-41117414">[1 more]</label></div><br/><div class="children"><div class="content">It still offers good structures to help you be careful in these situations, but you’re right. It’s not as complete of a concurrency model as BEAM languages.</div><br/></div></div></div></div><div id="41117346" class="c"><input type="checkbox" id="c-41117346" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41117164">root</a><span>|</span><a href="#41117179">parent</a><span>|</span><a href="#41117207">prev</a><span>|</span><a href="#41116891">next</a><span>|</span><label class="collapse" for="c-41117346">[-]</label><label class="expand" for="c-41117346">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Go has arguably a better concurrency model<p>Go might have a better concurrency <i>implementation</i>, Go’s concurrency <i>model</i> is pretty much just threads and telling you to git gud scrub.</div><br/><div id="41117479" class="c"><input type="checkbox" id="c-41117479" checked=""/><div class="controls bullet"><span class="by">null_investor</span><span>|</span><a href="#41117164">root</a><span>|</span><a href="#41117346">parent</a><span>|</span><a href="#41116891">next</a><span>|</span><label class="collapse" for="c-41117479">[-]</label><label class="expand" for="c-41117479">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, it&#x27;s more precise to say that it&#x27;s an implementation. I&#x27;m happy you understood what I meant though.<p>The developer experience on using it is much better than using coroutines in another lang.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>