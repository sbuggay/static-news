<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724662868663" as="style"/><link rel="stylesheet" href="styles.css?v=1724662868663"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://notgull.net/announcing-dozer/">Writing a Rust compiler in C</a> <span class="domain">(<a href="https://notgull.net">notgull.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>147 comments</span></div><br/><div><div id="41351953" class="c"><input type="checkbox" id="c-41351953" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41352769">next</a><span>|</span><label class="collapse" for="c-41351953">[-]</label><label class="expand" for="c-41351953">[25 more]</label></div><br/><div class="children"><div class="content">If I were to try bootstrapping rust, I think I would write a proto-rust in C that has fewer features than full rust, and then write a full rust compiler in proto-rust.<p>‘proto-rust’ might, for example, not have a borrow checker, may have limited or no macro support, may never free memory (freeing memory isn’t strictly needed in a compiler whose only goal in life is to compile a better compiler), and definitely need not create good code.<p>That proto-rust would basically be C with rust syntax, but for rust aficionados, I think that’s better than writing a rust compiler in “C with C syntax” that this project aims for.<p>Anybody know why this path wasn’t taken?</div><br/><div id="41352472" class="c"><input type="checkbox" id="c-41352472" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41351953">parent</a><span>|</span><a href="#41352038">next</a><span>|</span><label class="collapse" for="c-41352472">[-]</label><label class="expand" for="c-41352472">[4 more]</label></div><br/><div class="children"><div class="content">FWIW mrustc, the existing state of the art non-rust rust compiler, already doesn’t have a borrow checker.<p>Removing the borrow checker doesn’t break any correct programs — it just makes it so a huge amount of incorrect programs can be compiled. This is fine, since we mainly want to use mrustc to compile rustc, and we already know rustc can compile itself with no borrow checker errors.</div><br/><div id="41352988" class="c"><input type="checkbox" id="c-41352988" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352472">parent</a><span>|</span><a href="#41353796">next</a><span>|</span><label class="collapse" for="c-41352988">[-]</label><label class="expand" for="c-41352988">[1 more]</label></div><br/><div class="children"><div class="content">And once you have yourself bootstrapped, you can presumably turn around and compile the compiler again, now with borrow-checking and optimizations.<p>In the very special case of proto-rust bootstrapping, the cost of not having borrow-checking can be paid back basically right away.</div><br/></div></div><div id="41353796" class="c"><input type="checkbox" id="c-41353796" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352472">parent</a><span>|</span><a href="#41352988">prev</a><span>|</span><a href="#41352038">next</a><span>|</span><label class="collapse" for="c-41353796">[-]</label><label class="expand" for="c-41353796">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Removing the borrow checker doesn&#x27;t break any correct programs - it just makes it so a huge amount of incorrect programs can be compiled.&quot;<p>Not a user of Rust programs myself but am curious how users determine whether a Rust binary was compiled with mrustc or rustc.</div><br/><div id="41354073" class="c"><input type="checkbox" id="c-41354073" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41353796">parent</a><span>|</span><a href="#41352038">next</a><span>|</span><label class="collapse" for="c-41354073">[-]</label><label class="expand" for="c-41354073">[1 more]</label></div><br/><div class="children"><div class="content">You can assume that unless you have some specific information to the contrary, any Rust binary you encounter in real life was built with rustc. mrustc is not used for any mainstream purpose other than in the bootstrap chain of rustc in distros like Guix that care about reproducibility, and even then, the build of rustc they distribute to users will be re-built from the bootstrapped rustc, it won’t be one compiled by mrustc directly.</div><br/></div></div></div></div></div></div><div id="41352038" class="c"><input type="checkbox" id="c-41352038" checked=""/><div class="controls bullet"><span class="by">sjrd</span><span>|</span><a href="#41351953">parent</a><span>|</span><a href="#41352472">prev</a><span>|</span><a href="#41352076">next</a><span>|</span><label class="collapse" for="c-41352038">[-]</label><label class="expand" for="c-41352038">[2 more]</label></div><br/><div class="children"><div class="content">This is what we did for Mozart&#x2F;Oz [1]. We have a compiler for &quot;proto-Oz&quot; written in Scala. We use it to compile the real compiler, which is written in Oz. Since the Scala compiler produces inefficient code, we then <i>re</i>compile the real compiler with itself. This way we finally have an efficient real compiler producing good code. This is all part of the standard build of the language.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;mozart&#x2F;mozart2">https:&#x2F;&#x2F;github.com&#x2F;mozart&#x2F;mozart2</a></div><br/><div id="41354324" class="c"><input type="checkbox" id="c-41354324" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352038">parent</a><span>|</span><a href="#41352076">next</a><span>|</span><label class="collapse" for="c-41354324">[-]</label><label class="expand" for="c-41354324">[1 more]</label></div><br/><div class="children"><div class="content">Is it possible to bootstrap Scala?</div><br/></div></div></div></div><div id="41352076" class="c"><input type="checkbox" id="c-41352076" checked=""/><div class="controls bullet"><span class="by">TwentyPosts</span><span>|</span><a href="#41351953">parent</a><span>|</span><a href="#41352038">prev</a><span>|</span><a href="#41352769">next</a><span>|</span><label class="collapse" for="c-41352076">[-]</label><label class="expand" for="c-41352076">[18 more]</label></div><br/><div class="children"><div class="content">So now you&#x27;re writing two compilers.<p>What did you actually gain from this, outside of more work?</div><br/><div id="41352134" class="c"><input type="checkbox" id="c-41352134" checked=""/><div class="controls bullet"><span class="by">returningfory2</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352076">parent</a><span>|</span><a href="#41353176">next</a><span>|</span><label class="collapse" for="c-41352134">[-]</label><label class="expand" for="c-41352134">[14 more]</label></div><br/><div class="children"><div class="content">Writing a small compiler in C and a big compiler in Rust is simpler than writing a big compiler in C.</div><br/><div id="41352606" class="c"><input type="checkbox" id="c-41352606" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352134">parent</a><span>|</span><a href="#41352593">next</a><span>|</span><label class="collapse" for="c-41352606">[-]</label><label class="expand" for="c-41352606">[7 more]</label></div><br/><div class="children"><div class="content">But writing a Rust compiler in Rust is already done.</div><br/><div id="41352680" class="c"><input type="checkbox" id="c-41352680" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352606">parent</a><span>|</span><a href="#41352633">prev</a><span>|</span><a href="#41352593">next</a><span>|</span><label class="collapse" for="c-41352680">[-]</label><label class="expand" for="c-41352680">[5 more]</label></div><br/><div class="children"><div class="content">How do you compile that on a new platform?</div><br/><div id="41353694" class="c"><input type="checkbox" id="c-41353694" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352680">parent</a><span>|</span><a href="#41352923">next</a><span>|</span><label class="collapse" for="c-41353694">[-]</label><label class="expand" for="c-41353694">[1 more]</label></div><br/><div class="children"><div class="content">Cross-compilation. There is no requirement of being able to run the compiler on the platform to compile for that platform.<p>It is much easier to add support for a platform to the compiler backend than to write a new, full compiler with its own, new bootstrapping method.</div><br/></div></div><div id="41352923" class="c"><input type="checkbox" id="c-41352923" checked=""/><div class="controls bullet"><span class="by">projektfu</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352680">parent</a><span>|</span><a href="#41353694">prev</a><span>|</span><a href="#41352914">next</a><span>|</span><label class="collapse" for="c-41352923">[-]</label><label class="expand" for="c-41352923">[2 more]</label></div><br/><div class="children"><div class="content">One way would be to have an intermediate target that is easily recompiled or run on any hardware.<p><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;goodbye-cpp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;goodbye-cpp&#x2F;</a></div><br/><div id="41353090" class="c"><input type="checkbox" id="c-41353090" checked=""/><div class="controls bullet"><span class="by">maxdamantus</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352923">parent</a><span>|</span><a href="#41352914">next</a><span>|</span><label class="collapse" for="c-41353090">[-]</label><label class="expand" for="c-41353090">[1 more]</label></div><br/><div class="children"><div class="content">But that doesn&#x27;t conform to the &quot;Descent Principle&quot; described in the article.<p>I haven&#x27;t really been following Zig, but I still felt slightly disappointed when I learnt that they were just replacing a source-based bootstrapping compiler with a binary blob that someone generated and added to the source tree.<p>The thing that makes me uncomfortable with that approach is that if a certain kind of bug (or virus! [0]) is found in the compiler, it&#x27;s possible that you have to fix the bug in multiple versions to rebootstrap, in case the bug (or virus!) manages to persist itself into the compilation output. The Dozer article talks about the eventual goal of removing all generated files from the rustc source tree, ie undoing what Zig recently decided to do.<p>If everything is reliably built from source, you can just fix any bugs by editing the current source files.<p>[0] <a href="https:&#x2F;&#x2F;wiki.c2.com&#x2F;?TheKenThompsonHack" rel="nofollow">https:&#x2F;&#x2F;wiki.c2.com&#x2F;?TheKenThompsonHack</a></div><br/></div></div></div></div><div id="41352914" class="c"><input type="checkbox" id="c-41352914" checked=""/><div class="controls bullet"><span class="by">macjohnmcc</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352680">parent</a><span>|</span><a href="#41352923">prev</a><span>|</span><a href="#41352593">next</a><span>|</span><label class="collapse" for="c-41352914">[-]</label><label class="expand" for="c-41352914">[1 more]</label></div><br/><div class="children"><div class="content">Cross compilation.</div><br/></div></div></div></div></div></div><div id="41352593" class="c"><input type="checkbox" id="c-41352593" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352134">parent</a><span>|</span><a href="#41352606">prev</a><span>|</span><a href="#41352174">next</a><span>|</span><label class="collapse" for="c-41352593">[-]</label><label class="expand" for="c-41352593">[5 more]</label></div><br/><div class="children"><div class="content">Writing programs in Rust is not simpler then writing programs in C.</div><br/><div id="41352682" class="c"><input type="checkbox" id="c-41352682" checked=""/><div class="controls bullet"><span class="by">tux3</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352593">parent</a><span>|</span><a href="#41352700">next</a><span>|</span><label class="collapse" for="c-41352682">[-]</label><label class="expand" for="c-41352682">[1 more]</label></div><br/><div class="children"><div class="content">For compilers specifically, I think plenty of people would disagree.<p>It&#x27;s not that it&#x27;s exceedingly hard in C, but programming languages have evolved in the last millenium, and there are indeed language features that make writing compilers easier than it used to be<p>I have the most fun when I write x86 MASM assembly. It&#x27;s a pretty simple language all in all, even with the macro system. Much simpler than C.<p>But a simple language doesn&#x27;t always make it simple to write complex programs like compilers.</div><br/></div></div><div id="41352700" class="c"><input type="checkbox" id="c-41352700" checked=""/><div class="controls bullet"><span class="by">ZoomZoomZoom</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352593">parent</a><span>|</span><a href="#41352682">prev</a><span>|</span><a href="#41354900">next</a><span>|</span><label class="collapse" for="c-41352700">[-]</label><label class="expand" for="c-41352700">[1 more]</label></div><br/><div class="children"><div class="content">Sure, for you it isn&#x27;t. It is for me. Especially if we&#x27;re talking &quot;working roughly as intended&quot; programs.</div><br/></div></div><div id="41354900" class="c"><input type="checkbox" id="c-41354900" checked=""/><div class="controls bullet"><span class="by">adwn</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352593">parent</a><span>|</span><a href="#41352700">prev</a><span>|</span><a href="#41353571">next</a><span>|</span><label class="collapse" for="c-41354900">[-]</label><label class="expand" for="c-41354900">[1 more]</label></div><br/><div class="children"><div class="content">Writing <i>non-trivial</i> programs is easier in Rust than in C, for people that are <i>equally proficient</i> in C as in Rust. Especially if you&#x27;re allowed to use Cargo and the Rust crates ecosystem.<p>C isn&#x27;t even in the same league as Rust when it comes to productivity – again, if you&#x27;re <i>equally proficient</i> in Rust as in C.</div><br/></div></div><div id="41353571" class="c"><input type="checkbox" id="c-41353571" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352593">parent</a><span>|</span><a href="#41354900">prev</a><span>|</span><a href="#41352174">next</a><span>|</span><label class="collapse" for="c-41353571">[-]</label><label class="expand" for="c-41353571">[1 more]</label></div><br/><div class="children"><div class="content">Writing programs <i>that compile</i> is much easier in C. It lets me accidentally do all sorts of ill-advised things that the Rust compiler will correctly yell at me about.<p>I don&#x27;t remember it being any easier to write C that passes through a static analyzer like Coverity etc. than it is to write Rust. Think of rustc like a built-in static analyzer that won&#x27;t let you ignore it. Sometimes that means it&#x27;s harder to sneak bad ideas past the compiler.</div><br/></div></div></div></div></div></div><div id="41353176" class="c"><input type="checkbox" id="c-41353176" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352076">parent</a><span>|</span><a href="#41352134">prev</a><span>|</span><a href="#41352123">next</a><span>|</span><label class="collapse" for="c-41353176">[-]</label><label class="expand" for="c-41353176">[1 more]</label></div><br/><div class="children"><div class="content">You can now have trustworthy Rust compiler binaries, through the work of the Bootstrappable Builds community, which found a way to build a C compiler without having C compiler binaries yet.<p><a href="https:&#x2F;&#x2F;bootstrappable.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bootstrappable.org&#x2F;</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;fosslinux&#x2F;live-bootstrap&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;fosslinux&#x2F;live-bootstrap&#x2F;</a></div><br/></div></div><div id="41352123" class="c"><input type="checkbox" id="c-41352123" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352076">parent</a><span>|</span><a href="#41353176">prev</a><span>|</span><a href="#41352457">next</a><span>|</span><label class="collapse" for="c-41352123">[-]</label><label class="expand" for="c-41352123">[1 more]</label></div><br/><div class="children"><div class="content">Two simpler pieces of work as opposed to one complex one. Even if the two parts might be more volume, they&#x27;re both easier to write and debug.</div><br/></div></div><div id="41352457" class="c"><input type="checkbox" id="c-41352457" checked=""/><div class="controls bullet"><span class="by">ok123456</span><span>|</span><a href="#41351953">root</a><span>|</span><a href="#41352076">parent</a><span>|</span><a href="#41352123">prev</a><span>|</span><a href="#41352769">next</a><span>|</span><label class="collapse" for="c-41352457">[-]</label><label class="expand" for="c-41352457">[1 more]</label></div><br/><div class="children"><div class="content">You often write two compilers when trying to bootstrap a C compiler, as GCC used to do. Often, it&#x27;s a very simple version of the language implemented in the architecture&#x27;s assembly.</div><br/></div></div></div></div></div></div><div id="41352769" class="c"><input type="checkbox" id="c-41352769" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#41351953">prev</a><span>|</span><a href="#41351715">next</a><span>|</span><label class="collapse" for="c-41352769">[-]</label><label class="expand" for="c-41352769">[3 more]</label></div><br/><div class="children"><div class="content">Just for the lulz I&#x27;m writing a C compiler in Rust as a hobby, and it is humorously called &quot;Small C Compiler&quot;, a call back to &quot;Tiny C Compiler&quot; because Rust is obviously more heavyweight than C.<p>It uses Cranelift as a back end, but the whole compiler architecture is pluggable and hackable with lots of traits throwing around. I do not intend to open source it unless it works on a somewhat functional stage to be able to handle printf(&quot;%s&quot;, &quot;Hello World!&quot;), so until then, it will never see the light of day.<p>I&#x27;ve not been able to make too much progress, but I&#x27;ve tried to implement the preprocessor and parser, and I have been involved on rust-peg and HimeCC because of the infamous typedef problem. I know that in the industry we just use a symbol table to keep the typedef context, but that had a limitation of not able to read types below. I wonder what is the academic solution to that as well, and I can only think of transactional memory.<p>Anything that helps would eventually make me open source it!</div><br/><div id="41353324" class="c"><input type="checkbox" id="c-41353324" checked=""/><div class="controls bullet"><span class="by">a_e_k</span><span>|</span><a href="#41352769">parent</a><span>|</span><a href="#41353959">next</a><span>|</span><label class="collapse" for="c-41353324">[-]</label><label class="expand" for="c-41353324">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, (i.e., for some historical fun) Dr. Dobbs Journal published a program called &quot;Small C Compiler&quot; by Ron Cain back in 1980. [1]<p>Later, it was expanded by James Hendrix into a full book with a more complete implementation. [2]  (As a kid, coming across this book in the bargain bin at CompUSA was what led to me learning C.  I still have my copy!)<p>[1] <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;dr_dobbs_journal_vol_05_201803&#x2F;page&#x2F;n189&#x2F;mode&#x2F;2up" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;dr_dobbs_journal_vol_05_201803&#x2F;p...</a><p>[2] <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Small-Compiler-Language-Theory-Design&#x2F;dp&#x2F;0934375887" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Small-Compiler-Language-Theory-Design...</a></div><br/></div></div><div id="41353959" class="c"><input type="checkbox" id="c-41353959" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#41352769">parent</a><span>|</span><a href="#41353324">prev</a><span>|</span><a href="#41351715">next</a><span>|</span><label class="collapse" for="c-41353959">[-]</label><label class="expand" for="c-41353959">[1 more]</label></div><br/><div class="children"><div class="content">Hope you name it not “SCC” but “SmaCC”.</div><br/></div></div></div></div><div id="41351715" class="c"><input type="checkbox" id="c-41351715" checked=""/><div class="controls bullet"><span class="by">prologist11</span><span>|</span><a href="#41352769">prev</a><span>|</span><a href="#41352435">next</a><span>|</span><label class="collapse" for="c-41351715">[-]</label><label class="expand" for="c-41351715">[28 more]</label></div><br/><div class="children"><div class="content">This is super cool but what&#x27;s interesting is that this same kind of bootstrapping problem exists for hardware as well. What makes computers? Previously built computers and software running on them. The whole thing is really interesting to think about.</div><br/><div id="41353400" class="c"><input type="checkbox" id="c-41353400" checked=""/><div class="controls bullet"><span class="by">quuxplusone</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41352486">next</a><span>|</span><label class="collapse" for="c-41353400">[-]</label><label class="expand" for="c-41353400">[1 more]</label></div><br/><div class="children"><div class="content">The same bootstrapping problem exists for everything. What makes roads? Construction equipment. How do you get that construction equipment to the job site, without a road already being there?<p>I actually met a person a few months ago who worked for a startup doing delivery&#x2F;fulfillment of materials for construction projects. They pointed out that this requires special expertise beyond, say, Amazon, not only because these materials tend to have unusual and&#x2F;or dangerous physical properties, but also because the delivery addresses tend to be... well, they tend not to have addresses yet! This is all solvable (apparently), but only with expertise beyond the usual for delivery companies in the modern age.</div><br/></div></div><div id="41352486" class="c"><input type="checkbox" id="c-41352486" checked=""/><div class="controls bullet"><span class="by">ch33zer</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41353400">prev</a><span>|</span><a href="#41351973">next</a><span>|</span><label class="collapse" for="c-41352486">[-]</label><label class="expand" for="c-41352486">[2 more]</label></div><br/><div class="children"><div class="content">I used to work at a company that built data centers. They were trying to get their software to appoint that you could turn up an entire data center from a laptop. Why? So that you could work with European companies and prove to regulators that there were no backdoors. It was a fascinating problem but very difficult. My team was only tangentially involved but we did some work to forward our data to a proxy that ensured that all our data was auditable and not sending stuff it shouldn&#x27;t. I left before it finished but I heard it was scrapped as too difficult.</div><br/><div id="41353839" class="c"><input type="checkbox" id="c-41353839" checked=""/><div class="controls bullet"><span class="by">technofiend</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352486">parent</a><span>|</span><a href="#41351973">next</a><span>|</span><label class="collapse" for="c-41353839">[-]</label><label class="expand" for="c-41353839">[1 more]</label></div><br/><div class="children"><div class="content">Anecdotally I&#x27;ve used software that was capable of it if your hardware could be netbooted, preferably with pxe&#x2F;ipxe.  I used rackn and there&#x27;s other vendors like maas with purportedly the same abilities.<p>RackN is good enough it&#x27;ll let you build virtualization on top of bare metal and then keep going up the stack: building VMs, kubernetes, whatever. You just set up rules for pools, turn on dhcp and let auto discovered equipment take on roles based on the rules you set. Easy to do although I wouldn&#x27;t envy anyone building a competitor from scratch.</div><br/></div></div></div></div><div id="41351973" class="c"><input type="checkbox" id="c-41351973" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41352486">prev</a><span>|</span><a href="#41352287">next</a><span>|</span><label class="collapse" for="c-41351973">[-]</label><label class="expand" for="c-41351973">[3 more]</label></div><br/><div class="children"><div class="content">Then you look at the assembly for the old Cray-1 computers (octal opcodes) and the IBM System&#x2F;360 computers (word opcodes),  and you realize,  they made it so amazingly simple you can mostly just write the opcode bytes and assemble by hand if you like.<p>Then x86 came along,  without the giant budgets or the big purchasers,  and so they made that assembly as efficient and densely packed as is possible;  unfortunately,  you lose what you might otherwise conveniently have on other machines.</div><br/><div id="41352616" class="c"><input type="checkbox" id="c-41352616" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351973">parent</a><span>|</span><a href="#41353236">next</a><span>|</span><label class="collapse" for="c-41352616">[-]</label><label class="expand" for="c-41352616">[1 more]</label></div><br/><div class="children"><div class="content">x86 is the same if you stick to the origional 4bit subset. However it has been extended so many times that you can&#x27;t find the nice parts.</div><br/></div></div><div id="41353236" class="c"><input type="checkbox" id="c-41353236" checked=""/><div class="controls bullet"><span class="by">ScottBurson</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351973">parent</a><span>|</span><a href="#41352616">prev</a><span>|</span><a href="#41352287">next</a><span>|</span><label class="collapse" for="c-41353236">[-]</label><label class="expand" for="c-41353236">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read somewhere that Seymour Cray used to write his entire operating system in absolute octal.  (&quot;Absolute&quot; means no relocation; all memory accesses and jumps must be hand-targeted to the correct address, as they would have to be with no assembler involved.)</div><br/></div></div></div></div><div id="41352287" class="c"><input type="checkbox" id="c-41352287" checked=""/><div class="controls bullet"><span class="by">ekimekim</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41351973">prev</a><span>|</span><a href="#41352776">next</a><span>|</span><label class="collapse" for="c-41352287">[-]</label><label class="expand" for="c-41352287">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the coolest things about these kinds of bootstrapping projects + reproducible builds IMO. One could imagine creating an incredibly simple computer directly out of discrete components. It would be big, inefficient and slow as molasses, but it could in theory conform to instruction set architecture, and you could use it to build these bootstrap programs, and you could then assert that you get the same result on your fully-understood bad computer as you get on not-fully-trusted modern hardware.</div><br/></div></div><div id="41352776" class="c"><input type="checkbox" id="c-41352776" checked=""/><div class="controls bullet"><span class="by">massysett</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41352287">prev</a><span>|</span><a href="#41353037">next</a><span>|</span><label class="collapse" for="c-41352776">[-]</label><label class="expand" for="c-41352776">[2 more]</label></div><br/><div class="children"><div class="content">Interesting to think about even at a human civilization level. What if humans somehow went back to the Stone Age, but in present day.  Could we build back to what we have now?<p>Kind of a bootstrapping problem. For example, current oil reserves are harder to get than they were a century ago. Could we bootstrap our way into getting them?</div><br/><div id="41355243" class="c"><input type="checkbox" id="c-41355243" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352776">parent</a><span>|</span><a href="#41353037">next</a><span>|</span><label class="collapse" for="c-41355243">[-]</label><label class="expand" for="c-41355243">[1 more]</label></div><br/><div class="children"><div class="content">Would we want to build the same stuff again? Why bootstrap to oil if you can directly go for renewable alternatives?</div><br/></div></div></div></div><div id="41353037" class="c"><input type="checkbox" id="c-41353037" checked=""/><div class="controls bullet"><span class="by">grishka</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41352776">prev</a><span>|</span><a href="#41354489">next</a><span>|</span><label class="collapse" for="c-41353037">[-]</label><label class="expand" for="c-41353037">[1 more]</label></div><br/><div class="children"><div class="content">Lithography masks for early integrated circuits were drawn by hand iirc.</div><br/></div></div><div id="41354489" class="c"><input type="checkbox" id="c-41354489" checked=""/><div class="controls bullet"><span class="by">underbooter</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41353037">prev</a><span>|</span><a href="#41352181">next</a><span>|</span><label class="collapse" for="c-41354489">[-]</label><label class="expand" for="c-41354489">[2 more]</label></div><br/><div class="children"><div class="content">And who makes people?</div><br/><div id="41354534" class="c"><input type="checkbox" id="c-41354534" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41354489">parent</a><span>|</span><a href="#41352181">next</a><span>|</span><label class="collapse" for="c-41354534">[-]</label><label class="expand" for="c-41354534">[1 more]</label></div><br/><div class="children"><div class="content">Storks</div><br/></div></div></div></div><div id="41352181" class="c"><input type="checkbox" id="c-41352181" checked=""/><div class="controls bullet"><span class="by">sekuntul</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41354489">prev</a><span>|</span><a href="#41351945">next</a><span>|</span><label class="collapse" for="c-41352181">[-]</label><label class="expand" for="c-41352181">[1 more]</label></div><br/><div class="children"><div class="content">yep</div><br/></div></div><div id="41351945" class="c"><input type="checkbox" id="c-41351945" checked=""/><div class="controls bullet"><span class="by">durumu</span><span>|</span><a href="#41351715">parent</a><span>|</span><a href="#41352181">prev</a><span>|</span><a href="#41352435">next</a><span>|</span><label class="collapse" for="c-41351945">[-]</label><label class="expand" for="c-41351945">[14 more]</label></div><br/><div class="children"><div class="content">Which came first, the computers or the code?</div><br/><div id="41352312" class="c"><input type="checkbox" id="c-41352312" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351945">parent</a><span>|</span><a href="#41351985">next</a><span>|</span><label class="collapse" for="c-41352312">[-]</label><label class="expand" for="c-41352312">[1 more]</label></div><br/><div class="children"><div class="content">Ada Lovelace is often credited as the first computer programmer. She died in the late 1800s. Programmable electronic computers didn&#x27;t come along until the mid 1900s.<p>Though it obviously depends a bit on what you are willing to count as computer, or as code.</div><br/></div></div><div id="41351985" class="c"><input type="checkbox" id="c-41351985" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351945">parent</a><span>|</span><a href="#41352312">prev</a><span>|</span><a href="#41352797">next</a><span>|</span><label class="collapse" for="c-41351985">[-]</label><label class="expand" for="c-41351985">[9 more]</label></div><br/><div class="children"><div class="content">(The code, of course; the code drove music boxes and looms centuries before computers. Same for chicken and egg: eggs are maybe a billion years older.)</div><br/><div id="41352269" class="c"><input type="checkbox" id="c-41352269" checked=""/><div class="controls bullet"><span class="by">867-5309</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351985">parent</a><span>|</span><a href="#41352797">next</a><span>|</span><label class="collapse" for="c-41352269">[-]</label><label class="expand" for="c-41352269">[8 more]</label></div><br/><div class="children"><div class="content">so..the code drove computers</div><br/><div id="41352320" class="c"><input type="checkbox" id="c-41352320" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352269">parent</a><span>|</span><a href="#41352797">next</a><span>|</span><label class="collapse" for="c-41352320">[-]</label><label class="expand" for="c-41352320">[7 more]</label></div><br/><div class="children"><div class="content">Correct. And the chicken was written in COBOL.</div><br/><div id="41352432" class="c"><input type="checkbox" id="c-41352432" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352320">parent</a><span>|</span><a href="#41352410">next</a><span>|</span><label class="collapse" for="c-41352432">[-]</label><label class="expand" for="c-41352432">[4 more]</label></div><br/><div class="children"><div class="content">Probably off-topic, but the chicken and the egg &quot;paradox&quot; always seemed silly to me in the context of evolution. We know that there were birds long before chickens, so at some point, the first bird that we would consider to be in the species &quot;chicken&quot; had to hatch from an egg from a bird that was _not_ a chicken, so the egg came first. (This assumes that the question is specifically about chicken eggs; it&#x27;s even simpler if you count non-chicken eggs from the ancestors of the first chicken, but the logic still works even if you don&#x27;t).</div><br/><div id="41352650" class="c"><input type="checkbox" id="c-41352650" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352432">parent</a><span>|</span><a href="#41352569">next</a><span>|</span><label class="collapse" for="c-41352650">[-]</label><label class="expand" for="c-41352650">[1 more]</label></div><br/><div class="children"><div class="content">Or to take it another direction - how do they gestate? At what point can we call it a chicken and when does the shell (assuming that&#x27;s what would make us call it an egg) develop?</div><br/></div></div><div id="41352569" class="c"><input type="checkbox" id="c-41352569" checked=""/><div class="controls bullet"><span class="by">867-5309</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352432">parent</a><span>|</span><a href="#41352650">prev</a><span>|</span><a href="#41352410">next</a><span>|</span><label class="collapse" for="c-41352569">[-]</label><label class="expand" for="c-41352569">[2 more]</label></div><br/><div class="children"><div class="content">the chicken is just an example of an egg-laying and -borne animal. substitute it with the first</div><br/><div id="41352657" class="c"><input type="checkbox" id="c-41352657" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352569">parent</a><span>|</span><a href="#41352410">next</a><span>|</span><label class="collapse" for="c-41352657">[-]</label><label class="expand" for="c-41352657">[1 more]</label></div><br/><div class="children"><div class="content">I think that changes the answer by GP&#x27;s logic though, since then the first egg-layer obviously came before its egg.</div><br/></div></div></div></div></div></div><div id="41352410" class="c"><input type="checkbox" id="c-41352410" checked=""/><div class="controls bullet"><span class="by">ed_elliott_asc</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352320">parent</a><span>|</span><a href="#41352432">prev</a><span>|</span><a href="#41352797">next</a><span>|</span><label class="collapse" for="c-41352410">[-]</label><label class="expand" for="c-41352410">[2 more]</label></div><br/><div class="children"><div class="content">So that is how it crossed the road</div><br/><div id="41352466" class="c"><input type="checkbox" id="c-41352466" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41352410">parent</a><span>|</span><a href="#41352797">next</a><span>|</span><label class="collapse" for="c-41352466">[-]</label><label class="expand" for="c-41352466">[1 more]</label></div><br/><div class="children"><div class="content">No.  It was running on a mainframe.  It was JCL that let it cross the road.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41352797" class="c"><input type="checkbox" id="c-41352797" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351945">parent</a><span>|</span><a href="#41351985">prev</a><span>|</span><a href="#41351984">next</a><span>|</span><label class="collapse" for="c-41352797">[-]</label><label class="expand" for="c-41352797">[1 more]</label></div><br/><div class="children"><div class="content">It has to be the code, since those are the information&#x2F;ideas that you&#x27;ve written on any kind of medium such as on a whiteboard or on a paper, or better known as &quot;algorithms&quot;.<p>Also keep in mind with the use of &quot;computer&quot; -- in the past real humans, and in paricular a huge batch, are hired to compute log and sine lookup tables on hand. Earliest case of human SIMD by the way, and some would even take to break encryption by breaking and reversing code boxes, hence they are called &quot;computers&quot;, and I reckon many of them being females.</div><br/></div></div><div id="41351984" class="c"><input type="checkbox" id="c-41351984" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351945">parent</a><span>|</span><a href="#41352797">prev</a><span>|</span><a href="#41352435">next</a><span>|</span><label class="collapse" for="c-41351984">[-]</label><label class="expand" for="c-41351984">[2 more]</label></div><br/><div class="children"><div class="content">Code, unless you count the abacus etc</div><br/><div id="41354405" class="c"><input type="checkbox" id="c-41354405" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#41351715">root</a><span>|</span><a href="#41351984">parent</a><span>|</span><a href="#41352435">next</a><span>|</span><label class="collapse" for="c-41354405">[-]</label><label class="expand" for="c-41354405">[1 more]</label></div><br/><div class="children"><div class="content">i heard the first assembler was written in machine code, then that was used to create compiler. machine code u can just chuck into the cpu. its a little less trivial than assembly because its harder to remember but if u know assembly u can learn it easy enough :&gt;. i dont feel this is an unrealistic path sk i chose to beleive it without any evidence :D</div><br/></div></div></div></div></div></div></div></div><div id="41352435" class="c"><input type="checkbox" id="c-41352435" checked=""/><div class="controls bullet"><span class="by">ericyd</span><span>|</span><a href="#41351715">prev</a><span>|</span><a href="#41352699">next</a><span>|</span><label class="collapse" for="c-41352435">[-]</label><label class="expand" for="c-41352435">[5 more]</label></div><br/><div class="children"><div class="content">Kind of annoying that I had to follow 4 links just to find a high level justification of the benefits of bootstrapping [0]. I was kinda hoping the &quot;Why&quot; part of this title would address that.<p>[0] <a href="https:&#x2F;&#x2F;bootstrappable.org&#x2F;benefits.html" rel="nofollow">https:&#x2F;&#x2F;bootstrappable.org&#x2F;benefits.html</a></div><br/><div id="41352938" class="c"><input type="checkbox" id="c-41352938" checked=""/><div class="controls bullet"><span class="by">ludocode</span><span>|</span><a href="#41352435">parent</a><span>|</span><a href="#41352980">next</a><span>|</span><label class="collapse" for="c-41352938">[-]</label><label class="expand" for="c-41352938">[3 more]</label></div><br/><div class="children"><div class="content">It can be difficult to explain why bootstrapping is important. I put a &quot;Why?&quot; section in the README of my own bootstrapping compiler [0] for this reason.<p>Security is a big reason and it&#x27;s one the bootstrappable team tend to focus on. In order to avoid the trusting trust problem and other attacks (like the recent xz backdoor), we need to be able to bootstrap everything from pure source code. They go as far as deleting all pre-generated files to ensure that they only rely on things that are hand-written and auditable. So bootstrapping Python for example is pretty complicated because the source contains code generated by Python scripts.<p>I&#x27;m much more interested in the cultural preservation aspect of it. We want to preserve contemporary media for future archaeologists, for example in the Arctic World Archive [1]. Unfortunately it&#x27;s pointless if they have no way to decode it. So what do we do? We can preserve the specs, but we can&#x27;t really expect them to implement x265 and everything else they would need from scratch. We can preserve binaries, but then they&#x27;d need to either get thousand-year-old hardware running or virtualize a thousand-year-old CPU. We can give them, say, a definition of a simple Lisp, and then give them code that runs on that, but then who&#x27;s going to implement x265 in a basic Lisp? None of this is really practical.<p>That&#x27;s why in my project I made a simple virtual machine, then bootstrapped C on top of it. It&#x27;s trivially portable, not just to present-day architectures but to future and alien architectures as well. Any future archaeologist or alien civilization could implement the VM in a day, then run the C bootstrap on it, then compile ffmpeg or whatever and decode our media. There are no black boxes here: it&#x27;s all debuggable, auditable, open, handwritten source code.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ludocode&#x2F;onramp?tab=readme-ov-file#why-bootstrap">https:&#x2F;&#x2F;github.com&#x2F;ludocode&#x2F;onramp?tab=readme-ov-file#why-bo...</a><p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arctic_World_Archive" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Arctic_World_Archive</a></div><br/><div id="41353992" class="c"><input type="checkbox" id="c-41353992" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41352435">root</a><span>|</span><a href="#41352938">parent</a><span>|</span><a href="#41352980">next</a><span>|</span><label class="collapse" for="c-41353992">[-]</label><label class="expand" for="c-41353992">[2 more]</label></div><br/><div class="children"><div class="content">Say you start with nothing but &quot;pure source code&quot;.<p>With what tool do you process that source code?</div><br/><div id="41354144" class="c"><input type="checkbox" id="c-41354144" checked=""/><div class="controls bullet"><span class="by">ludocode</span><span>|</span><a href="#41352435">root</a><span>|</span><a href="#41353992">parent</a><span>|</span><a href="#41352980">next</a><span>|</span><label class="collapse" for="c-41354144">[-]</label><label class="expand" for="c-41354144">[1 more]</label></div><br/><div class="children"><div class="content">The minimum tool that bootstrapping projects tend to start with is a hex monitor. That is, a simple-as-possible tool that converts hexadecimal bytes of input into raw bytes in memory, and then jumps to it.<p>You need some way of getting this hex tool in memory of course. On traditional computers this could be done on front panel switches, but of course modern computers don&#x27;t have those anymore. You could also imagine it hand-woven into core rope memory for example, which could then be connected directly to the CPU at its boot address. There are many options here; getting the hex tool running is very platform-specific.<p>Once you have a hex tool, you can then use that to input the next stage, which is written in commented hexadecimal source code. The next tool then adds a few features, and so does the tool after that, and so on, eventually working your way up to assembly and C.</div><br/></div></div></div></div></div></div></div></div><div id="41352699" class="c"><input type="checkbox" id="c-41352699" checked=""/><div class="controls bullet"><span class="by">perching_aix</span><span>|</span><a href="#41352435">prev</a><span>|</span><a href="#41351840">next</a><span>|</span><label class="collapse" for="c-41352699">[-]</label><label class="expand" for="c-41352699">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit confused.<p>It&#x27;s a bit difficult to dissect, but long story short, in the middle of the post the author finally provides the reason for them embarking on the journey mentioned in the title:<p>&gt; The main issue (...) is that, by the time C++ is introduced into the bootstrap chain, the bootstrap is basically over. So if you wanted to use Rust at any point before C++ is introduced, you’re out of luck. So, for me, it would be really nice if there was a Rust compiler that could be bootstrapped from C. Specifically, a Rust compiler that can be bootstrapped from TinyCC, while assuming that there are no tools on the system yet that could be potentially useful.<p>However, this contradicts the premise they lay out earlier in the post:<p>&gt; Every new version of rustc was compiled with the previous version of rustc. So rustc version 1.80.0 was compiled with rustc version 1.79.0. Which was, in turn, compiled with rustc version 1.78.0. And so on and so forth, all the way back to version 0.7 if the compiler. At that point, the compiler was written in OCaml. So all you needed was an OCaml compiler to get a fully functioning rustc program. (...) There is a project that can *successfully* compile the OCaml compiler using Guile, which is one of the many variants of Scheme, which is one of many variants of Lisp. Not to mention, Guile’s interpreter is written in C.<p>The contradiction of course is that then there is a path that is without C++ like they want it to, it&#x27;s just not the one that the rustc team uses day-to-day. The author even claims that it actually works (see the emphasis I placed).<p>So I&#x27;m ultimately not entirely sure about the motivation here. Is the goal to create a <i>nicer</i> C based bootstrapping process? Is the goal to do that <i>and</i> have that eventually become the day-to-day way rustc is bootstrapped? Why does the author want to get rid of the C++ stage? Why does the author prefer to have a C stage?<p>The only thing that&#x27;s clear then is that the author just wants to do this period, and that&#x27;s fine. But otherwise, even after reading through their fairly lengthy post, I&#x27;m none the wiser.</div><br/><div id="41352796" class="c"><input type="checkbox" id="c-41352796" checked=""/><div class="controls bullet"><span class="by">ludocode</span><span>|</span><a href="#41352699">parent</a><span>|</span><a href="#41351840">next</a><span>|</span><label class="collapse" for="c-41352796">[-]</label><label class="expand" for="c-41352796">[9 more]</label></div><br/><div class="children"><div class="content">While it is <i>technically</i> possible to bootstrap Rust from Guile and the 0.7 Rust compiler, you would need to recompile the Rust compiler about a hundred times. Each step takes hours, and you can&#x27;t skip any steps because, like he said, 1.80 requires 1.79, 1.79 requires 1.78, and so on all the way back to 0.7. Even if fully automated, this bootstrap would take months.<p>Moreover, I believe the earlier versions of rustc only output LLVM, so you need to bootstrap a C++ compiler to compile LLVM anyway. If you have a C++ compiler, you might as well compile mrustc. Currently, mrustc only supports rustc 1.54, so you&#x27;d still have to compile through some 35 versions of it.<p>None of this is practical. The goal of Dozer (this project) is to be able to bootstrap a small C compiler, compile Dozer, and use it to directly compile the latest rustc. This gives you Rust right away without having to bootstrap C++ or anything else in between.</div><br/><div id="41353180" class="c"><input type="checkbox" id="c-41353180" checked=""/><div class="controls bullet"><span class="by">0x0203</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41352796">parent</a><span>|</span><a href="#41352865">next</a><span>|</span><label class="collapse" for="c-41353180">[-]</label><label class="expand" for="c-41353180">[6 more]</label></div><br/><div class="children"><div class="content">This is accurate. I&#x27;m an OS&#x2F;kernel developer and a colleague was given the task of porting rust to our OS. If I remember correctly, it did indeed take months. I don&#x27;t think mrustc was an option at the time for reasons I don&#x27;t recall, so he did indeed have to go all the way back to the very early versions and work his way through nearly all the intermediate versions. I had to do a similar thing porting java, although that wasn&#x27;t quite as annoying as porting rust. I really do wish more language developers would provide a more practical way of bootstrapping their compilers like the article is describing&#x2F;attempting. I&#x27;ve seen some that do a really good job. Others seem to assume only *nix and Windows exist, which has been pretty frustrating.</div><br/><div id="41354361" class="c"><input type="checkbox" id="c-41354361" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41353180">parent</a><span>|</span><a href="#41354108">next</a><span>|</span><label class="collapse" for="c-41354361">[-]</label><label class="expand" for="c-41354361">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious as to why you need to bootstrap at all? Why not start with adding the OS&#x2F;kernel as a target for cross-compilation and then cross-compile the compiler?</div><br/></div></div><div id="41354108" class="c"><input type="checkbox" id="c-41354108" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41353180">parent</a><span>|</span><a href="#41354361">prev</a><span>|</span><a href="#41353465">next</a><span>|</span><label class="collapse" for="c-41354108">[-]</label><label class="expand" for="c-41354108">[2 more]</label></div><br/><div class="children"><div class="content">Nim uses a smaller bootstrap compiler that uses pre-generated C code to then build the compiler proper. It&#x27;s pretty nifty for porting.</div><br/><div id="41354349" class="c"><input type="checkbox" id="c-41354349" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41354108">parent</a><span>|</span><a href="#41353465">next</a><span>|</span><label class="collapse" for="c-41354349">[-]</label><label class="expand" for="c-41354349">[1 more]</label></div><br/><div class="children"><div class="content">The article mentions that the Bootstrappable Builds folks don&#x27;t allow pre-generated  code in their processes, they always have to build or bootstrap it from the real source.</div><br/></div></div></div></div><div id="41353465" class="c"><input type="checkbox" id="c-41353465" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41353180">parent</a><span>|</span><a href="#41354108">prev</a><span>|</span><a href="#41352865">next</a><span>|</span><label class="collapse" for="c-41353465">[-]</label><label class="expand" for="c-41353465">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s interesting!  what kind of os did you write?  it sounds like you didn&#x27;t think supporting the linux system call interface was a good idea, or perhaps even feasible?</div><br/><div id="41353947" class="c"><input type="checkbox" id="c-41353947" checked=""/><div class="controls bullet"><span class="by">0x0203</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41353465">parent</a><span>|</span><a href="#41352865">next</a><span>|</span><label class="collapse" for="c-41353947">[-]</label><label class="expand" for="c-41353947">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s got a fairly linux like ABI, though we don&#x27;t aim or care to be 1-1 compatible, and it has&#x2F;requires our own custom interfaces. Porting most software that was written for linux is usually pretty easy. But we can&#x27;t just run binaries compiled for linux on our stuff. So for languages that require a compiler written in its own language where they don&#x27;t supply cross compilers or boot strapping compilers built with the lowest common denominator (usually c or c++), things can get a little trickier.</div><br/></div></div></div></div></div></div><div id="41352865" class="c"><input type="checkbox" id="c-41352865" checked=""/><div class="controls bullet"><span class="by">perching_aix</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41352796">parent</a><span>|</span><a href="#41353180">prev</a><span>|</span><a href="#41351840">next</a><span>|</span><label class="collapse" for="c-41352865">[-]</label><label class="expand" for="c-41352865">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Moreover, I believe the earlier versions of rustc only output LLVM, so you need to bootstrap a C++ compiler to compile LLVM anyway. If you have a C++ compiler, you might as well compile mrustc. Currently, mrustc only supports rustc 1.54, so you&#x27;d still have to compile through some 35 versions of it.<p>Not sure I follow - isn&#x27;t rustc still only a compiler frontend to LLVM, like clang is for C&#x2F;C++? So if you have any version of rustc, haven&#x27;t you at that point kind of &quot;arrived&quot; and started bootstrapping it on itself, meaning mission complete?<p>Ultimately from what I glean the answer really is just that this would be made nicer with Dozer, but I still wish this was explicitly stated by the author in the post. It&#x27;s not like the drudgery of the ocaml route escapes me.</div><br/><div id="41353256" class="c"><input type="checkbox" id="c-41353256" checked=""/><div class="controls bullet"><span class="by">mbrubeck</span><span>|</span><a href="#41352699">root</a><span>|</span><a href="#41352865">parent</a><span>|</span><a href="#41351840">next</a><span>|</span><label class="collapse" for="c-41353256">[-]</label><label class="expand" for="c-41353256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure I follow - isn&#x27;t rustc still only a compiler frontend to LLVM, like clang is for C&#x2F;C++?<p>The rustc source tree currently includes LLVM, GCC, and Cranelift backends: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;c6db1ca3c93ad69692a4c4b5542f26fda4bf3aec&#x2F;config.example.toml#L656-L661">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;c6db1ca3c93ad69692a4c...</a><p>(Cranelift itself is written in Rust.)</div><br/></div></div></div></div></div></div></div></div><div id="41351840" class="c"><input type="checkbox" id="c-41351840" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#41352699">prev</a><span>|</span><a href="#41352735">next</a><span>|</span><label class="collapse" for="c-41351840">[-]</label><label class="expand" for="c-41351840">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I see the point. To generate functional new binaries on the target machine, rustc will need to support the target. If you add that support to rustc, you can just have it build itself.</div><br/><div id="41352032" class="c"><input type="checkbox" id="c-41352032" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#41351840">parent</a><span>|</span><a href="#41352735">next</a><span>|</span><label class="collapse" for="c-41352032">[-]</label><label class="expand" for="c-41352032">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about having a shorter auditable bootstrap process much more than it is about supporting new architectures.</div><br/><div id="41352196" class="c"><input type="checkbox" id="c-41352196" checked=""/><div class="controls bullet"><span class="by">dathery</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352032">parent</a><span>|</span><a href="#41352185">next</a><span>|</span><label class="collapse" for="c-41352196">[-]</label><label class="expand" for="c-41352196">[4 more]</label></div><br/><div class="children"><div class="content">Not dismissing the usefulness of the project at all, but curious what the concrete benefits of that are -- is it mainly to have a smaller, more auditable bootstrap process to make it easier to avoid &quot;Reflections on Trusting Trust&quot;-type attacks?<p>It seems like you&#x27;d need to trust a C compiler anyway, but I guess the idea is that there are a lot of small C compiler designs that are fairly easy to port?</div><br/><div id="41352859" class="c"><input type="checkbox" id="c-41352859" checked=""/><div class="controls bullet"><span class="by">johnklos</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352196">parent</a><span>|</span><a href="#41352555">next</a><span>|</span><label class="collapse" for="c-41352859">[-]</label><label class="expand" for="c-41352859">[1 more]</label></div><br/><div class="children"><div class="content">Let me make a small example that may illustrate the issue.<p>You can download the NetBSD source tree and compile it with any reasonable c compiler, whether you&#x27;re running some sort of BSD, macOS or Linux. Some OSes have much older gcc (Red Hat, for instance), some have modern gcc, some have llvm. The source tree first compiles a compiler, which then compiles NetBSD. It&#x27;s an automatic, easy to understand, easy to audit, two step process that&#x27;s really nice and clean.<p>With rust, if you want to compile current rust, you need a pretty modern, up to date rust. You can usually use the last few versions, but you certainly can&#x27;t use a version of rust that&#x27;s even a year old. This, to some of us, is ridiculous - the language shouldn&#x27;t change so much so quickly that something that was brand new a year ago literally can&#x27;t be used today to compile something current.<p>If you really want to bootstrap rust from c, you&#x27;d have to start with rust from many years ago, compile it, then use it to compile newer rust, then use that to compile even newer rust, perhaps a half a dozen times until you get to today&#x27;s rust. Again, this is really silly.<p>There are many of us who&#x27;d like to see rust be more directly usable and less dependent on a chain of compilers six levels deep.</div><br/></div></div><div id="41352555" class="c"><input type="checkbox" id="c-41352555" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352196">parent</a><span>|</span><a href="#41352859">prev</a><span>|</span><a href="#41352185">next</a><span>|</span><label class="collapse" for="c-41352555">[-]</label><label class="expand" for="c-41352555">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It seems like you&#x27;d need to trust a C compiler anyway, but I guess the idea is that there are a lot of small C compiler designs that are fairly easy to port?<p>Sorry but TFA explains it very well how to go from nothing to TinyCC. The author&#x27;s effort now is to go from TinyCC to Rust.</div><br/><div id="41352649" class="c"><input type="checkbox" id="c-41352649" checked=""/><div class="controls bullet"><span class="by">dathery</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352555">parent</a><span>|</span><a href="#41352185">next</a><span>|</span><label class="collapse" for="c-41352649">[-]</label><label class="expand" for="c-41352649">[1 more]</label></div><br/><div class="children"><div class="content">Right, but I was trying to understand the author&#x27;s motivation, and this was me handwaving about if it could be about compiler trust. The article discusses bootstrapping but not explicitly why the author cares—is it just a fun exercise (they do mention fascination)? Are they using an obscure architecture where there is no OCaml compiler and so they need the short bootstrap chain? _Is_ it about compiler trust?<p>(Again since it can come off wrong in text, this was just pure curiosity about the project, not dismissiveness.)</div><br/></div></div></div></div></div></div><div id="41352185" class="c"><input type="checkbox" id="c-41352185" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352032">parent</a><span>|</span><a href="#41352196">prev</a><span>|</span><a href="#41352735">next</a><span>|</span><label class="collapse" for="c-41352185">[-]</label><label class="expand" for="c-41352185">[5 more]</label></div><br/><div class="children"><div class="content">Regardless, the process is so long that it seems inauditable in practise.<p>Like i guess i can see the appeal of starting from nothing as a kind of cool achievement, but i dont think it helps with auditing code.</div><br/><div id="41352305" class="c"><input type="checkbox" id="c-41352305" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352185">parent</a><span>|</span><a href="#41352735">next</a><span>|</span><label class="collapse" for="c-41352305">[-]</label><label class="expand" for="c-41352305">[4 more]</label></div><br/><div class="children"><div class="content">But with the Rust compiler in C the audit path would be much shorter it sounds like, and therefore be more auditable.<p>Plus OP also wrote in the post that a goal was to be able to bootstrap to Rust without first having to bootstrap to C++, so that other things can be written in Rust earlier on in the process. That could mean more of the foundation of everything being bootstrapped being written in Rust, instead of in C or C++.</div><br/><div id="41352664" class="c"><input type="checkbox" id="c-41352664" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352305">parent</a><span>|</span><a href="#41352735">next</a><span>|</span><label class="collapse" for="c-41352664">[-]</label><label class="expand" for="c-41352664">[3 more]</label></div><br/><div class="children"><div class="content">What good is being slightly shorter if it us still nowhere remotely close to practical?<p>Its kind of like saying 100 years is a lot shorter than 200 years. It might be true, but if all the time you have to dedicate is a few hours it really doesnt matter.</div><br/><div id="41354927" class="c"><input type="checkbox" id="c-41354927" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352664">parent</a><span>|</span><a href="#41353418">next</a><span>|</span><label class="collapse" for="c-41354927">[-]</label><label class="expand" for="c-41354927">[1 more]</label></div><br/><div class="children"><div class="content">It will be hex editor -&gt; assembler -&gt; tinycc -&gt; dozer -&gt; latest rust so should absolutely be doable or am I missing something?</div><br/></div></div><div id="41353418" class="c"><input type="checkbox" id="c-41353418" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#41351840">root</a><span>|</span><a href="#41352664">parent</a><span>|</span><a href="#41354927">prev</a><span>|</span><a href="#41352735">next</a><span>|</span><label class="collapse" for="c-41353418">[-]</label><label class="expand" for="c-41353418">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t need to be _perfectly_ auditable to be worthwhile — it just needs to be more auditable than the alternatives available today.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41352735" class="c"><input type="checkbox" id="c-41352735" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#41351840">prev</a><span>|</span><a href="#41352254">next</a><span>|</span><label class="collapse" for="c-41352735">[-]</label><label class="expand" for="c-41352735">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes I fantasize about writing a C++ interpreter or compiler in scheme: going directly from scheme to current gcc would be a <i>huge</i> shortcut. But common wisdom is that writing a C++ compiler is basically impossible. Still, it’d be instructive!</div><br/></div></div><div id="41352254" class="c"><input type="checkbox" id="c-41352254" checked=""/><div class="controls bullet"><span class="by">cranky908canuck</span><span>|</span><a href="#41352735">prev</a><span>|</span><a href="#41353126">next</a><span>|</span><label class="collapse" for="c-41352254">[-]</label><label class="expand" for="c-41352254">[3 more]</label></div><br/><div class="children"><div class="content">Looking at the whole stack (starting from a sub-assembler), could this be a way to bypass the issues around &quot;trusting trust&quot;?<p><a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rdriley&#x2F;487&#x2F;papers&#x2F;Thompson_1984_ReflectionsonTrustingTrust.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rdriley&#x2F;487&#x2F;papers&#x2F;Thompson_1984_Ref...</a></div><br/><div id="41352653" class="c"><input type="checkbox" id="c-41352653" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41352254">parent</a><span>|</span><a href="#41352726">next</a><span>|</span><label class="collapse" for="c-41352653">[-]</label><label class="expand" for="c-41352653">[1 more]</label></div><br/><div class="children"><div class="content">Only if you audit everything and run the whole process. Even then there is <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Underhanded_C_Contest" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Underhanded_C_Contest</a> which some enteries would have got past me in an audit</div><br/></div></div><div id="41352726" class="c"><input type="checkbox" id="c-41352726" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#41352254">parent</a><span>|</span><a href="#41352653">prev</a><span>|</span><a href="#41353126">next</a><span>|</span><label class="collapse" for="c-41352726">[-]</label><label class="expand" for="c-41352726">[1 more]</label></div><br/><div class="children"><div class="content">I thought that was the whole point?</div><br/></div></div></div></div><div id="41353126" class="c"><input type="checkbox" id="c-41353126" checked=""/><div class="controls bullet"><span class="by">nilslice</span><span>|</span><a href="#41352254">prev</a><span>|</span><a href="#41352280">next</a><span>|</span><label class="collapse" for="c-41353126">[-]</label><label class="expand" for="c-41353126">[1 more]</label></div><br/><div class="children"><div class="content">love the use of QBE for backend here. will be interesting to follow and see any comparisons against rust with llvm! good luck!</div><br/></div></div><div id="41352280" class="c"><input type="checkbox" id="c-41352280" checked=""/><div class="controls bullet"><span class="by">cranky908canuck</span><span>|</span><a href="#41353126">prev</a><span>|</span><a href="#41351801">next</a><span>|</span><label class="collapse" for="c-41352280">[-]</label><label class="expand" for="c-41352280">[5 more]</label></div><br/><div class="children"><div class="content">&lt;mischief&gt;
Maybe the bootstrap process should use FORTH as part of the toolchain?
&lt;&#x2F;mischief&gt;<p>Not mischief: I&#x27;d probably look at that option if I was taking this on.</div><br/><div id="41353053" class="c"><input type="checkbox" id="c-41353053" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#41352280">parent</a><span>|</span><a href="#41352725">next</a><span>|</span><label class="collapse" for="c-41353053">[-]</label><label class="expand" for="c-41353053">[3 more]</label></div><br/><div class="children"><div class="content">From one of the guys heavily involved in all this bootstrapping stuff:<p><a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;fybdug&#x2F;pulling_linux_up_by_its_bootstraps#c_xkmusz" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;fybdug&#x2F;pulling_linux_up_by_its_bootstrap...</a><p>&gt; The answer to the question about FORTH is:<p>&gt; well we bootstrapped multiple FORTHs; no one actually was willing to actually do the bootstrapping steps in FORTH besides Virgil Dupras who did collapseOS and duskOS. (Which unfortunately neither currently have a path to GCC or Linux)</div><br/><div id="41354119" class="c"><input type="checkbox" id="c-41354119" checked=""/><div class="controls bullet"><span class="by">blacksqr</span><span>|</span><a href="#41352280">root</a><span>|</span><a href="#41353053">parent</a><span>|</span><a href="#41352725">next</a><span>|</span><label class="collapse" for="c-41354119">[-]</label><label class="expand" for="c-41354119">[2 more]</label></div><br/><div class="children"><div class="content">The ultimate answer given later in the above-linked comment is that bootstrapping with FORTH is a great idea but programming in FORTH isn&#x27;t fun enough to follow up on the notion.</div><br/><div id="41355007" class="c"><input type="checkbox" id="c-41355007" checked=""/><div class="controls bullet"><span class="by">ropejumper</span><span>|</span><a href="#41352280">root</a><span>|</span><a href="#41354119">parent</a><span>|</span><a href="#41352725">next</a><span>|</span><label class="collapse" for="c-41355007">[-]</label><label class="expand" for="c-41355007">[1 more]</label></div><br/><div class="children"><div class="content">Bootstrapping with forth is a GREAT idea. I think it&#x27;s one of the best languages to use for bootstrapping.<p>The reason is simple: forth can be almost the first thing in the chain, and it&#x27;s so flexible that most of the rest of the bootstrap can be done by simply building up forth definitions.<p>The way the bootstrap chain generally builds up the level of abstraction is by compiling a somewhat more general language, multiple times, until you reach something usable. If you bootstrap forth you&#x27;re basically there. You have clean, readable source code that can be ran with a ridiculously simple interpreter&#x2F;compiler. It&#x27;s a very natural choice.<p>But of course forth is such a different paradigm that most people just don&#x27;t want to learn how to write in it properly (in such a way that you end up with actually readable code). Which is fine. I guess it really isn&#x27;t fun enough for most. But it&#x27;s difficult to ignore just how great of a fit it is.</div><br/></div></div></div></div></div></div><div id="41352725" class="c"><input type="checkbox" id="c-41352725" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#41352280">parent</a><span>|</span><a href="#41353053">prev</a><span>|</span><a href="#41351801">next</a><span>|</span><label class="collapse" for="c-41352725">[-]</label><label class="expand" for="c-41352725">[1 more]</label></div><br/><div class="children"><div class="content">IIUC, this is frequently suggested but never followed through on by someone who knows enough Forth to do it.</div><br/></div></div></div></div><div id="41351801" class="c"><input type="checkbox" id="c-41351801" checked=""/><div class="controls bullet"><span class="by">iTokio</span><span>|</span><a href="#41352280">prev</a><span>|</span><a href="#41352672">next</a><span>|</span><label class="collapse" for="c-41351801">[-]</label><label class="expand" for="c-41351801">[7 more]</label></div><br/><div class="children"><div class="content">It’s a huge project, I wonder if it wouldn’t be simpler to try to compile cranelift or mrustc to wasm (that’s still quite difficult) then use wasm2c to get a bootstrap compiler.</div><br/><div id="41351851" class="c"><input type="checkbox" id="c-41351851" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#41351801">parent</a><span>|</span><a href="#41351843">next</a><span>|</span><label class="collapse" for="c-41351851">[-]</label><label class="expand" for="c-41351851">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the approach Zig is taking: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;goodbye-cpp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;news&#x2F;goodbye-cpp&#x2F;</a></div><br/></div></div><div id="41351843" class="c"><input type="checkbox" id="c-41351843" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41351801">parent</a><span>|</span><a href="#41351851">prev</a><span>|</span><a href="#41352672">next</a><span>|</span><label class="collapse" for="c-41351843">[-]</label><label class="expand" for="c-41351843">[5 more]</label></div><br/><div class="children"><div class="content">The resulting C would not be “source code”.<p>Edit to explain further: the point is for the code to be written (or at least auditable) by humans.</div><br/><div id="41352494" class="c"><input type="checkbox" id="c-41352494" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#41351801">root</a><span>|</span><a href="#41351843">parent</a><span>|</span><a href="#41352672">next</a><span>|</span><label class="collapse" for="c-41352494">[-]</label><label class="expand" for="c-41352494">[4 more]</label></div><br/><div class="children"><div class="content">As long both rust-to-wasm (or zig-to-wasm) and wasm2c are auditable, and every step reproducible, why do you need the generated C to be auditable?</div><br/><div id="41354367" class="c"><input type="checkbox" id="c-41354367" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#41351801">root</a><span>|</span><a href="#41352494">parent</a><span>|</span><a href="#41352557">next</a><span>|</span><label class="collapse" for="c-41354367">[-]</label><label class="expand" for="c-41354367">[1 more]</label></div><br/><div class="children"><div class="content">The article mentions that the Bootstrappable Builds folks don&#x27;t allow pre-generated code in their processes, they always have to build or bootstrap it from the real source.</div><br/></div></div><div id="41352557" class="c"><input type="checkbox" id="c-41352557" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41351801">root</a><span>|</span><a href="#41352494">parent</a><span>|</span><a href="#41354367">prev</a><span>|</span><a href="#41353110">next</a><span>|</span><label class="collapse" for="c-41352557">[-]</label><label class="expand" for="c-41352557">[1 more]</label></div><br/><div class="children"><div class="content">The point is to shorten the minimal bootstrap path to Rust.<p>With your suggestion you can&#x27;t use rust until after you already have rust-to-wasm transpiler available (which almost certainly itself already requires rust, so you are back where you started).</div><br/></div></div><div id="41353110" class="c"><input type="checkbox" id="c-41353110" checked=""/><div class="controls bullet"><span class="by">ludocode</span><span>|</span><a href="#41351801">root</a><span>|</span><a href="#41352494">parent</a><span>|</span><a href="#41352557">prev</a><span>|</span><a href="#41352672">next</a><span>|</span><label class="collapse" for="c-41353110">[-]</label><label class="expand" for="c-41353110">[1 more]</label></div><br/><div class="children"><div class="content">The generated C code could contain a backdoor. Generated C is not really auditable so there would be no way to tell that the code is compromised.</div><br/></div></div></div></div></div></div></div></div><div id="41352672" class="c"><input type="checkbox" id="c-41352672" checked=""/><div class="controls bullet"><span class="by">Ruq</span><span>|</span><a href="#41351801">prev</a><span>|</span><a href="#41352781">next</a><span>|</span><label class="collapse" for="c-41352672">[-]</label><label class="expand" for="c-41352672">[1 more]</label></div><br/><div class="children"><div class="content">It always comes back to C.</div><br/></div></div><div id="41352781" class="c"><input type="checkbox" id="c-41352781" checked=""/><div class="controls bullet"><span class="by">namjh</span><span>|</span><a href="#41352672">prev</a><span>|</span><a href="#41351913">next</a><span>|</span><label class="collapse" for="c-41352781">[-]</label><label class="expand" for="c-41352781">[2 more]</label></div><br/><div class="children"><div class="content">Do we have a better method of verifying compilation output than just re-executing the compiler with same source, than comparing the output? TEE attestation could be a thing(albeit it could be a &quot;trusted&quot; third party which occasionally be broken).</div><br/><div id="41355158" class="c"><input type="checkbox" id="c-41355158" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#41352781">parent</a><span>|</span><a href="#41351913">next</a><span>|</span><label class="collapse" for="c-41355158">[-]</label><label class="expand" for="c-41355158">[1 more]</label></div><br/><div class="children"><div class="content">Diverse double-compiling (DDC) can help.</div><br/></div></div></div></div><div id="41351913" class="c"><input type="checkbox" id="c-41351913" checked=""/><div class="controls bullet"><span class="by">nijaar</span><span>|</span><a href="#41352781">prev</a><span>|</span><a href="#41353403">next</a><span>|</span><label class="collapse" for="c-41351913">[-]</label><label class="expand" for="c-41351913">[4 more]</label></div><br/><div class="children"><div class="content">if this works would this make the rust compiler considerably smaller &#x2F; faster?</div><br/><div id="41351979" class="c"><input type="checkbox" id="c-41351979" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41351913">parent</a><span>|</span><a href="#41353403">next</a><span>|</span><label class="collapse" for="c-41351979">[-]</label><label class="expand" for="c-41351979">[3 more]</label></div><br/><div class="children"><div class="content">Smaller? Yes. Faster? Almost certainly not.<p>It really doesn&#x27;t make sense to optimize anything in a bootstrapping compiler. Usually the only code that will ever be compiled by this compiler will be rustc itself. And rustc doesn&#x27;t need to run fast - just fast enough to recompile itself. So, the output also probably won&#x27;t have any optimisations applied either.</div><br/><div id="41353778" class="c"><input type="checkbox" id="c-41353778" checked=""/><div class="controls bullet"><span class="by">nijaar</span><span>|</span><a href="#41351913">root</a><span>|</span><a href="#41351979">parent</a><span>|</span><a href="#41353403">next</a><span>|</span><label class="collapse" for="c-41353778">[-]</label><label class="expand" for="c-41353778">[2 more]</label></div><br/><div class="children"><div class="content">if it is smaller, doesn&#x27;t it mean that it has less code to execute hence should it be faster? Trying to understand better -- this is something completely new for me</div><br/><div id="41353925" class="c"><input type="checkbox" id="c-41353925" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41351913">root</a><span>|</span><a href="#41353778">parent</a><span>|</span><a href="#41353403">next</a><span>|</span><label class="collapse" for="c-41353925">[-]</label><label class="expand" for="c-41353925">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily, in fact one of the most important optimizations for compilers is inlining code (copy-pasting function bodies into call sites) which results in more code being generated (more space) but faster wallclock times (more speed). Most optimizations tradeoff size for speed in some way, and compilers have flags to control it (eg -Os vs -O3 tells most C compilers to optimize for size instead of speed).<p>Where optimizing for size <i>is</i> optimizing for speed is when it&#x27;s faster (in terms of wall clock time) for a program to compute data than to read it from memory, disk, i&#x2F;o etc, because i&#x2F;o bandwidth is generally much slower than execution bandwidth. That means the processor does more work, but it takes less time because it&#x27;s not waiting for data to load through the cache or memory.</div><br/></div></div></div></div></div></div></div></div><div id="41353403" class="c"><input type="checkbox" id="c-41353403" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#41351913">prev</a><span>|</span><a href="#41352463">next</a><span>|</span><label class="collapse" for="c-41353403">[-]</label><label class="expand" for="c-41353403">[2 more]</label></div><br/><div class="children"><div class="content">Why isn&#x27;t anyone referring to bootstrapping a rust compiler as &quot;rusting rust&quot;? :D</div><br/><div id="41353881" class="c"><input type="checkbox" id="c-41353881" checked=""/><div class="controls bullet"><span class="by">cylinder714</span><span>|</span><a href="#41353403">parent</a><span>|</span><a href="#41352463">next</a><span>|</span><label class="collapse" for="c-41353881">[-]</label><label class="expand" for="c-41353881">[1 more]</label></div><br/><div class="children"><div class="content">Reflections on Rusting Trust: <a href="http:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2016&#x2F;12&#x2F;02&#x2F;reflections-on-rusting-trust&#x2F;" rel="nofollow">http:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2016&#x2F;12&#x2F;02&#x2F;reflections-on-...</a><p>HN discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13091941">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13091941</a></div><br/></div></div></div></div><div id="41352463" class="c"><input type="checkbox" id="c-41352463" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41353403">prev</a><span>|</span><a href="#41352137">next</a><span>|</span><label class="collapse" for="c-41352463">[-]</label><label class="expand" for="c-41352463">[5 more]</label></div><br/><div class="children"><div class="content">Why not write the compiler in Rust, then compile it to assembly, and then use some disassembler&#x2F;decompiler to compile that back to portable C?</div><br/><div id="41354368" class="c"><input type="checkbox" id="c-41354368" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#41352463">parent</a><span>|</span><a href="#41352478">next</a><span>|</span><label class="collapse" for="c-41354368">[-]</label><label class="expand" for="c-41354368">[1 more]</label></div><br/><div class="children"><div class="content">The article mentions that the Bootstrappable Builds folks don&#x27;t allow pre-generated code in their processes, they always have to build or bootstrap it from the real source.</div><br/></div></div><div id="41352478" class="c"><input type="checkbox" id="c-41352478" checked=""/><div class="controls bullet"><span class="by">mighmi</span><span>|</span><a href="#41352463">parent</a><span>|</span><a href="#41354368">prev</a><span>|</span><a href="#41352137">next</a><span>|</span><label class="collapse" for="c-41352478">[-]</label><label class="expand" for="c-41352478">[3 more]</label></div><br/><div class="children"><div class="content">Wait, dissemblers will turn assembly into any language you want?</div><br/><div id="41352485" class="c"><input type="checkbox" id="c-41352485" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41352463">root</a><span>|</span><a href="#41352478">parent</a><span>|</span><a href="#41352638">next</a><span>|</span><label class="collapse" for="c-41352485">[-]</label><label class="expand" for="c-41352485">[1 more]</label></div><br/><div class="children"><div class="content">Well, maybe decompiler is a better word.<p><a href="https:&#x2F;&#x2F;reverseengineering.stackexchange.com&#x2F;questions&#x2F;3748&#x2F;converting-assembly-code-to-c" rel="nofollow">https:&#x2F;&#x2F;reverseengineering.stackexchange.com&#x2F;questions&#x2F;3748&#x2F;...</a></div><br/></div></div><div id="41352638" class="c"><input type="checkbox" id="c-41352638" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41352463">root</a><span>|</span><a href="#41352478">parent</a><span>|</span><a href="#41352485">prev</a><span>|</span><a href="#41352137">next</a><span>|</span><label class="collapse" for="c-41352638">[-]</label><label class="expand" for="c-41352638">[1 more]</label></div><br/><div class="children"><div class="content">Well they try. They tend to get lost on x86 where instructions are not fixed length.</div><br/></div></div></div></div></div></div><div id="41352137" class="c"><input type="checkbox" id="c-41352137" checked=""/><div class="controls bullet"><span class="by">jhatemyjob</span><span>|</span><a href="#41352463">prev</a><span>|</span><a href="#41352849">next</a><span>|</span><label class="collapse" for="c-41352137">[-]</label><label class="expand" for="c-41352137">[5 more]</label></div><br/><div class="children"><div class="content">This is why the aforementioned ABI (of the latter language in the title of this post) won&#x27;t die for a long time. The name of the game is compatibility, not performance&#x2F;security. Bell Labs was first.</div><br/><div id="41352187" class="c"><input type="checkbox" id="c-41352187" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41352137">parent</a><span>|</span><a href="#41352314">next</a><span>|</span><label class="collapse" for="c-41352187">[-]</label><label class="expand" for="c-41352187">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I think rust made a big mistake for not going for a stable (or at least mostly stable like C++) ABI (other than the C one). The &quot;staticly link everything&quot; is fine for desktops and servers, but not for e.g. embedded Linux applications with limited storage. It&#x27;s too bad because things like routers are some of the most security sensitive devices.</div><br/><div id="41352281" class="c"><input type="checkbox" id="c-41352281" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41352137">root</a><span>|</span><a href="#41352187">parent</a><span>|</span><a href="#41352314">next</a><span>|</span><label class="collapse" for="c-41352281">[-]</label><label class="expand" for="c-41352281">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or at least mostly stable like C++<p>The C++ ABI doesn&#x27;t solve generics (templates); C++ templates live in header files, as source code, and get monomorphized into code that&#x27;s embedded in the binary that includes that header. The resulting monomorphized code is effectively statically linked, and any upgraded version of a shared library has to deal with old versions of template code from header files, or risk weird breakage.<p>Swift has a more realistic solution to this problem: polymorphic interfaces (the equivalent of Rust &quot;dyn&quot;). That&#x27;s something we&#x27;re taking inspiration from in the design of future Rust stable ABIs.<p>&gt; but not for e.g. embedded Linux applications with limited storage<p>Storage is often <i>not</i> the limiting factor for anything running embedded Linux (as opposed to something much smaller).<p>The primary point in favor of shared libraries is to aid in the logistics of upgrading dependencies for security. It&#x27;s possible to solve that in other ways, though.</div><br/></div></div></div></div><div id="41352314" class="c"><input type="checkbox" id="c-41352314" checked=""/><div class="controls bullet"><span class="by">Almondsetat</span><span>|</span><a href="#41352137">parent</a><span>|</span><a href="#41352187">prev</a><span>|</span><a href="#41352849">next</a><span>|</span><label class="collapse" for="c-41352314">[-]</label><label class="expand" for="c-41352314">[2 more]</label></div><br/><div class="children"><div class="content">The C ABI won&#x27;t die because it has a stranglehold on *NIX. Every new language you make has to conform in some way to C in order to use syscalls.</div><br/><div id="41354911" class="c"><input type="checkbox" id="c-41354911" checked=""/><div class="controls bullet"><span class="by">dpassens</span><span>|</span><a href="#41352137">root</a><span>|</span><a href="#41352314">parent</a><span>|</span><a href="#41352849">next</a><span>|</span><label class="collapse" for="c-41354911">[-]</label><label class="expand" for="c-41354911">[1 more]</label></div><br/><div class="children"><div class="content">That is not true on Linux, where you can just make syscalls yourself. They don&#x27;t even use the C ABI, even if it&#x27;s pretty similar (For syscalls, the fourth argument is passed in R10 instead of RCX, since that holds the return address for sysret).</div><br/></div></div></div></div></div></div><div id="41352849" class="c"><input type="checkbox" id="c-41352849" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#41352137">prev</a><span>|</span><a href="#41351818">next</a><span>|</span><label class="collapse" for="c-41352849">[-]</label><label class="expand" for="c-41352849">[1 more]</label></div><br/><div class="children"><div class="content">When I learned C a bit, I was looking up how people did C++-like stuff in C. I found objects, exceptions, concurrency, etc.<p>If mrustc is written in C++, could it be easier to use such C++-like primitives to port its working C++ to C? And do it a bit at a time using strong interoperability between C++ and C?<p>Before anyone says it, I know that would be a hard, porting effort with many pitfalls. Remember we’re comparing that to writing a Rust compiler in C, though. It might be easier to port the C++ to C.<p>This also reminds me of the C++ to C compilers that used to exist. I don’t know if they’re still around. I think both Rust to C&#x2F;C++ and C++ to human-readable C compilers would be useful today. Especially to combine the safety benefits of one with the tooling of the other.</div><br/></div></div><div id="41351818" class="c"><input type="checkbox" id="c-41351818" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#41352849">prev</a><span>|</span><a href="#41351719">next</a><span>|</span><label class="collapse" for="c-41351818">[-]</label><label class="expand" for="c-41351818">[1 more]</label></div><br/><div class="children"><div class="content">Very cool project.<p>I&#x27;m not totally sold on the practical justification (though I appreciate that might not be the real driving motive here). This targets Cranelift, so it gives you a Rust compiler targeting the platforms that Rust already supports. You <i>could</i> use it to cross compile Rust code from a non-supported platform to a supported one, but then you&#x27;d be using a &#x27;toy&#x27; implementation for generating your production builds (rather than just to bootstrap a compiler).</div><br/></div></div><div id="41351719" class="c"><input type="checkbox" id="c-41351719" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#41351818">prev</a><span>|</span><a href="#41352905">next</a><span>|</span><label class="collapse" for="c-41351719">[-]</label><label class="expand" for="c-41351719">[1 more]</label></div><br/><div class="children"><div class="content">TL;DR his goal is rust, but for bootstrapping a first rust compiler for a new environment, the work is already done for C<p>the article is interesting, and links to some interesting  things, but that&#x27;s what the article is about<p>his project is <a href="https:&#x2F;&#x2F;codeberg.org&#x2F;notgull&#x2F;dozer" rel="nofollow">https:&#x2F;&#x2F;codeberg.org&#x2F;notgull&#x2F;dozer</a><p>he references bootstrappable builds <a href="https:&#x2F;&#x2F;bootstrappable.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bootstrappable.org&#x2F;</a> a systematized approach to start from the ground up with very simple with a 512 byte &quot;machine coder&quot; (more basic than an assembler) and build up from there rudimentary tools, a &quot;small C subset compiler&quot; which compiles a better C compiler, etc, turtles all the way up.</div><br/></div></div><div id="41351799" class="c"><input type="checkbox" id="c-41351799" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41352905">prev</a><span>|</span><a href="#41352276">next</a><span>|</span><label class="collapse" for="c-41351799">[-]</label><label class="expand" for="c-41351799">[9 more]</label></div><br/><div class="children"><div class="content">For bootstrapping it still feels weird to target C. You could easily target a higher level language or just invent a better language. You don&#x27;t care about runtime performance. Feels like you don&#x27;t really gain that much by forcing yourself to jump through the C hoop, and the cost of having to write an entire compiler in C is huge.<p>Like, how hard would it be to go via Java instead? I bet you can bootstrap to Java very easily.</div><br/><div id="41352064" class="c"><input type="checkbox" id="c-41352064" checked=""/><div class="controls bullet"><span class="by">syntheticnature</span><span>|</span><a href="#41351799">parent</a><span>|</span><a href="#41351836">next</a><span>|</span><label class="collapse" for="c-41352064">[-]</label><label class="expand" for="c-41352064">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d expect it to be harder. I used to work on a large embedded device that ran some Java code, and there was a specialist vendor providing Java for the offbeat processor platform.<p>After a little digging, I found a blog post about it, and it does sound denser than the poster&#x27;s plans to bootstrap Rust: <a href="https:&#x2F;&#x2F;www.chainguard.dev&#x2F;unchained&#x2F;fully-bootstrapping-java-from-source-in-wolfi" rel="nofollow">https:&#x2F;&#x2F;www.chainguard.dev&#x2F;unchained&#x2F;fully-bootstrapping-jav...</a></div><br/></div></div><div id="41351836" class="c"><input type="checkbox" id="c-41351836" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#41351799">parent</a><span>|</span><a href="#41352064">prev</a><span>|</span><a href="#41352099">next</a><span>|</span><label class="collapse" for="c-41351836">[-]</label><label class="expand" for="c-41351836">[5 more]</label></div><br/><div class="children"><div class="content">Every platform, for better or worse, gets a C compiler first. Targeting C is the most practical option.</div><br/><div id="41352109" class="c"><input type="checkbox" id="c-41352109" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41351799">root</a><span>|</span><a href="#41351836">parent</a><span>|</span><a href="#41352099">next</a><span>|</span><label class="collapse" for="c-41352109">[-]</label><label class="expand" for="c-41352109">[4 more]</label></div><br/><div class="children"><div class="content">Right, but once you have C it&#x27;s fairly straightforward to use an interpreted language implemented in C (python, perl, guile, lua, whatever).<p>Obviously such a compiler would likely be unusably slow, but that&#x27;s not important here.</div><br/><div id="41352138" class="c"><input type="checkbox" id="c-41352138" checked=""/><div class="controls bullet"><span class="by">trueismywork</span><span>|</span><a href="#41351799">root</a><span>|</span><a href="#41352109">parent</a><span>|</span><a href="#41352099">next</a><span>|</span><label class="collapse" for="c-41352138">[-]</label><label class="expand" for="c-41352138">[3 more]</label></div><br/><div class="children"><div class="content">You overestimate the comprehensiveness of C standard with half the things being optional. It&#x27;s not given that python will compile on a minimal comforming C compiler.</div><br/><div id="41352201" class="c"><input type="checkbox" id="c-41352201" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41351799">root</a><span>|</span><a href="#41352138">parent</a><span>|</span><a href="#41352099">next</a><span>|</span><label class="collapse" for="c-41352201">[-]</label><label class="expand" for="c-41352201">[2 more]</label></div><br/><div class="children"><div class="content">True, but Lua probably will :)</div><br/><div id="41352415" class="c"><input type="checkbox" id="c-41352415" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#41351799">root</a><span>|</span><a href="#41352201">parent</a><span>|</span><a href="#41352099">next</a><span>|</span><label class="collapse" for="c-41352415">[-]</label><label class="expand" for="c-41352415">[1 more]</label></div><br/><div class="children"><div class="content">Lua definitely will compile on an ANSI C compiler, without POSIX or Win32 extensions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41352099" class="c"><input type="checkbox" id="c-41352099" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#41351799">parent</a><span>|</span><a href="#41351836">prev</a><span>|</span><a href="#41352276">next</a><span>|</span><label class="collapse" for="c-41352099">[-]</label><label class="expand" for="c-41352099">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>feels weird to target C</i><p>he&#x27;s not targeting C, he&#x27;s targeting rust; he&#x27;s using C<p>it&#x27;s an important distinction, because <i>he&#x27;s not writing the C compilers involved</i>, he&#x27;s leveraging them to compile his target rust compiler which will be used to compile a rust-on-rust compiler. The C compiler is the compiler he has available, any other solution he would have to write that compiler, but his target is rust.</div><br/><div id="41354868" class="c"><input type="checkbox" id="c-41354868" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41351799">root</a><span>|</span><a href="#41352099">parent</a><span>|</span><a href="#41352276">next</a><span>|</span><label class="collapse" for="c-41354868">[-]</label><label class="expand" for="c-41354868">[1 more]</label></div><br/><div class="children"><div class="content">Targeting C <i>as the language to write his Rust compiler in</i>. You knew that.</div><br/></div></div></div></div></div></div><div id="41352276" class="c"><input type="checkbox" id="c-41352276" checked=""/><div class="controls bullet"><span class="by">xiaodai</span><span>|</span><a href="#41351799">prev</a><span>|</span><a href="#41352297">next</a><span>|</span><label class="collapse" for="c-41352276">[-]</label><label class="expand" for="c-41352276">[1 more]</label></div><br/><div class="children"><div class="content">Should&#x27;ve written it in LLVM IR</div><br/></div></div><div id="41352297" class="c"><input type="checkbox" id="c-41352297" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41352276">prev</a><span>|</span><a href="#41352210">next</a><span>|</span><label class="collapse" for="c-41352297">[-]</label><label class="expand" for="c-41352297">[5 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  metadat@zukrfukr:&#x2F;src&#x2F;dozer$ \
  wc -l 
  $(find . -name &#x27;*.c&#x27;)
     280 .&#x2F;src&#x2F;item.c
     851 .&#x2F;src&#x2F;lex.c
     166 .&#x2F;src&#x2F;parser.c
     107 .&#x2F;src&#x2F;libdozer.c
     103 .&#x2F;src&#x2F;resolve.c
     167 .&#x2F;src&#x2F;path.c
     219 .&#x2F;src&#x2F;traverse.c
      91 .&#x2F;src&#x2F;scope.c
     144 .&#x2F;src&#x2F;qbe.c
     134 .&#x2F;src&#x2F;map.c
    1045 .&#x2F;src&#x2F;expr.c
     266 .&#x2F;src&#x2F;nhad.c
     349 .&#x2F;src&#x2F;emit.c
      92 .&#x2F;src&#x2F;main.c
     231 .&#x2F;src&#x2F;type.c
     223 .&#x2F;src&#x2F;pattern.c
      97 .&#x2F;src&#x2F;typemap.c
     224 .&#x2F;src&#x2F;token.c
     148 .&#x2F;src&#x2F;util.c
     141 .&#x2F;src&#x2F;stmt.c
    5078 total
</code></pre>
5kloc is pretty light for a `rustc&#x27;, where are the tests showing what aspects of the grammar ar supported so far in <i>@notgull&#x27;s crowning achievement </i>?  The article might be longer than the source code, which would be extremely impressive if the thing actually worked :)<p>I was not able to compile tokio with <i>dozer</i>.<p>For comparison, turn towards the other major lang HN submission today: a Golang compiler written in PHP; It comes with extensive tests showing what works and what does not.  Somehow even the goroutines are working.. in PHP.<p><i>Golang interpreter written in PHP</i> - <a href="https:&#x2F;&#x2F;github.com&#x2F;tuqqu&#x2F;go-php">https:&#x2F;&#x2F;github.com&#x2F;tuqqu&#x2F;go-php</a> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41339818">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41339818</a><p>Godspeed.</div><br/><div id="41353210" class="c"><input type="checkbox" id="c-41353210" checked=""/><div class="controls bullet"><span class="by">csb6</span><span>|</span><a href="#41352297">parent</a><span>|</span><a href="#41352451">next</a><span>|</span><label class="collapse" for="c-41353210">[-]</label><label class="expand" for="c-41353210">[1 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; But so far, I have the lexer done, as well as a sizable part of the parser. Macro&#x2F;module expansion is something I’m putting off as long as possible, typechecking only supports i32, and codegen is a little bit rough. But it’s a start.<p>So it is currently nowhere near complete (and the author never claims otherwise).</div><br/></div></div><div id="41352451" class="c"><input type="checkbox" id="c-41352451" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41352297">parent</a><span>|</span><a href="#41353210">prev</a><span>|</span><a href="#41352624">next</a><span>|</span><label class="collapse" for="c-41352451">[-]</label><label class="expand" for="c-41352451">[1 more]</label></div><br/><div class="children"><div class="content">The project isn’t complete. It can only build trivial examples, definitely not something like tokio.</div><br/></div></div><div id="41352624" class="c"><input type="checkbox" id="c-41352624" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#41352297">parent</a><span>|</span><a href="#41352451">prev</a><span>|</span><a href="#41352210">next</a><span>|</span><label class="collapse" for="c-41352624">[-]</label><label class="expand" for="c-41352624">[2 more]</label></div><br/><div class="children"><div class="content">The goroutines are working in that they execute, they are not concurrent.</div><br/><div id="41352687" class="c"><input type="checkbox" id="c-41352687" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41352297">root</a><span>|</span><a href="#41352624">parent</a><span>|</span><a href="#41352210">next</a><span>|</span><label class="collapse" for="c-41352687">[-]</label><label class="expand" for="c-41352687">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only a `#include &lt;pthread.h&gt;&#x27; away.  *grin*</div><br/></div></div></div></div></div></div><div id="41352210" class="c"><input type="checkbox" id="c-41352210" checked=""/><div class="controls bullet"><span class="by">modevs</span><span>|</span><a href="#41352297">prev</a><span>|</span><a href="#41352198">next</a><span>|</span><label class="collapse" for="c-41352210">[-]</label><label class="expand" for="c-41352210">[6 more]</label></div><br/><div class="children"><div class="content">Rewrite it in C. Great idea. Just do not tell it to rust community...<p>I like to see that programmers like you still exist and belive in what they do.<p>Remembered this article...
<a href="https:&#x2F;&#x2F;drewdevault.com&#x2F;2019&#x2F;03&#x2F;25&#x2F;Rust-is-not-a-good-C-replacement.html" rel="nofollow">https:&#x2F;&#x2F;drewdevault.com&#x2F;2019&#x2F;03&#x2F;25&#x2F;Rust-is-not-a-good-C-repl...</a></div><br/><div id="41352628" class="c"><input type="checkbox" id="c-41352628" checked=""/><div class="controls bullet"><span class="by">mustache_kimono</span><span>|</span><a href="#41352210">parent</a><span>|</span><a href="#41352690">next</a><span>|</span><label class="collapse" for="c-41352628">[-]</label><label class="expand" for="c-41352628">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Remembered this article... <a href="https:&#x2F;&#x2F;drewdevault.com&#x2F;2019&#x2F;03&#x2F;25&#x2F;Rust-is-not-a-good-C-replacement.html" rel="nofollow">https:&#x2F;&#x2F;drewdevault.com&#x2F;2019&#x2F;03&#x2F;25&#x2F;Rust-is-not-a-good-C-repl...</a><p>Remembering Drew Devault is the Fox News of programming bloggers.  He exhibits the same sort of bad faith obtuseness, and knee-jerk neck beard tech conservatism,  that makes me&#x2F;many want to scream.<p>First, his thesis is risible.  &quot;Rust is not a good C replacement&quot;.  Note, Drew does not mean replace C code with Rust code, but Rust, the language, literally replacing C, the language.  Ignoring, perhaps, Rust doesn&#x27;t want to &quot;replace&quot; C, because we have C!<p>Next, see the bulleted text.  Upon each topic something interesting might be said re: Rust, but instead they all serve a garbage thesis that <i>Rust can never be the 50 year old language that the tech world is currently built upon</i>.  Well, duh.<p>My least favorite, though, is the final bullet:<p>&gt; Safety. Yes, Rust is more safe. I don’t really care. In light of all of these problems, I’ll take my segfaults and buffer overflows.<p>And everyone wants to be a cowboy and watch things blow up when they are 8 years old.</div><br/></div></div><div id="41352690" class="c"><input type="checkbox" id="c-41352690" checked=""/><div class="controls bullet"><span class="by">samsartor</span><span>|</span><a href="#41352210">parent</a><span>|</span><a href="#41352628">prev</a><span>|</span><a href="#41352490">next</a><span>|</span><label class="collapse" for="c-41352690">[-]</label><label class="expand" for="c-41352690">[3 more]</label></div><br/><div class="children"><div class="content">The community has been very supportive of the gccrs (<a href="https:&#x2F;&#x2F;github.com&#x2F;Rust-GCC&#x2F;gccrs">https:&#x2F;&#x2F;github.com&#x2F;Rust-GCC&#x2F;gccrs</a>) project, which is the main project to write a Rust compiler written in C.</div><br/><div id="41352740" class="c"><input type="checkbox" id="c-41352740" checked=""/><div class="controls bullet"><span class="by">Narishma</span><span>|</span><a href="#41352210">root</a><span>|</span><a href="#41352690">parent</a><span>|</span><a href="#41353857">next</a><span>|</span><label class="collapse" for="c-41352740">[-]</label><label class="expand" for="c-41352740">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say very supportive at all. It often gets bashed whenever some news about it is posted on r&#x2F;rust for example.</div><br/></div></div><div id="41353857" class="c"><input type="checkbox" id="c-41353857" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#41352210">root</a><span>|</span><a href="#41352690">parent</a><span>|</span><a href="#41352740">prev</a><span>|</span><a href="#41352490">next</a><span>|</span><label class="collapse" for="c-41353857">[-]</label><label class="expand" for="c-41353857">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in C++, not C</div><br/></div></div></div></div><div id="41352490" class="c"><input type="checkbox" id="c-41352490" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#41352210">parent</a><span>|</span><a href="#41352690">prev</a><span>|</span><a href="#41352198">next</a><span>|</span><label class="collapse" for="c-41352490">[-]</label><label class="expand" for="c-41352490">[1 more]</label></div><br/><div class="children"><div class="content">What does that article have to do with this article? The author of the latter article even says that they don’t enjoy writing C, which is kind of the opposite of what your article says</div><br/></div></div></div></div><div id="41352198" class="c"><input type="checkbox" id="c-41352198" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#41352210">prev</a><span>|</span><a href="#41352448">next</a><span>|</span><label class="collapse" for="c-41352198">[-]</label><label class="expand" for="c-41352198">[2 more]</label></div><br/><div class="children"><div class="content">Given that we&#x27;re this far along, bootstrapping is purely an aesthetic exercise (and a cool one, to be sure -- I love aesthetic exercises). If it were an actual practical concern, presumably it would be much easier to use the current rustc toolchain to compile rustc to RISC-V and write a RISC-V emulator in C suitable for TinyC. Unless it&#x27;s a trust exercise and you don&#x27;t trust any rustc version.</div><br/><div id="41353047" class="c"><input type="checkbox" id="c-41353047" checked=""/><div class="controls bullet"><span class="by">0x0203</span><span>|</span><a href="#41352198">parent</a><span>|</span><a href="#41352448">next</a><span>|</span><label class="collapse" for="c-41353047">[-]</label><label class="expand" for="c-41353047">[1 more]</label></div><br/><div class="children"><div class="content">The practical concern for my colleagues and me is that we&#x27;re OS&#x2F;kernel developers for an operating system that isn&#x27;t currently supported. I had to fight these kind of problems to get java ported to our OS, and a coworker had to do it for rust, which was much much harder. And he did end up having to start from one of the earliest versions and compile nearly every blasted version between then and now to get the latest. It&#x27;s a royal pain and a major time sink. If there were a viable rustc that was written in C or even C++ at the time, we could have been done in a few days. Instead it took months.</div><br/></div></div></div></div></div></div></div></div></div></body></html>