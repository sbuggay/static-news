<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709715666032" as="style"/><link rel="stylesheet" href="styles.css?v=1709715666032"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://extremelearning.com.au/how-to-generate-uniformly-random-points-on-n-spheres-and-n-balls/">How to generate uniformly random points on n-spheres and in n-balls</a> <span class="domain">(<a href="https://extremelearning.com.au">extremelearning.com.au</a>)</span></div><div class="subtext"><span>egorpv</span> | <span>71 comments</span></div><br/><div><div id="39607616" class="c"><input type="checkbox" id="c-39607616" checked=""/><div class="controls bullet"><span class="by">frankfrank13</span><span>|</span><a href="#39609656">next</a><span>|</span><label class="collapse" for="c-39607616">[-]</label><label class="expand" for="c-39607616">[19 more]</label></div><br/><div class="children"><div class="content">I actually needed this at work once! We needed to fuzz peoples address in a mapped view for analytics, without revealing PII. It ended up never being shipped, but we needed to fuzz geographic data and the thinking was like:<p>1. Truncate your lat longs to some arbitrary decimal place (this is very very stupid, you end up with grid lines [1])<p>2. The above method ^^ but everyone tries basically doing like random angle + random length along angle, which doesn&#x27;t generate uniform results in a circle as the article mentions[2]. So then you try generating points in a box that encloses your circle, and rejecting anything outside the circle, but that smells bad. So you do some googling and find method 6 listed in the article (Good! and Fast!)<p>3. Realize that fuzzing points is stupid, what you really want is to view points in aggregate anyways, so you try heat maps<p>[1]: Ok you always end up with grid lines, but truncating to like 1-6 decimal places produces very obvious grid lines to the human eye<p>[2]: Try this in pyplot! You&#x27;ll see right away with ~100 points its not uniform in the way you expect</div><br/><div id="39612201" class="c"><input type="checkbox" id="c-39612201" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#39607616">parent</a><span>|</span><a href="#39608009">next</a><span>|</span><label class="collapse" for="c-39612201">[-]</label><label class="expand" for="c-39612201">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d just have used Uber&#x27;s hexagonal tiling library. <a href="https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;h3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;h3&#x2F;</a></div><br/></div></div><div id="39608009" class="c"><input type="checkbox" id="c-39608009" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39607616">parent</a><span>|</span><a href="#39612201">prev</a><span>|</span><a href="#39607661">next</a><span>|</span><label class="collapse" for="c-39608009">[-]</label><label class="expand" for="c-39608009">[9 more]</label></div><br/><div class="children"><div class="content">The rejection method smells pretty good to me, in the sense that it should be pretty obvious to anybody with, like, middle school level math I think (right?).<p>It might fail for higher dimensions, but lots of programs only run on a 3D sphere of a planet, haha!</div><br/><div id="39610673" class="c"><input type="checkbox" id="c-39610673" checked=""/><div class="controls bullet"><span class="by">contravariant</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39608009">parent</a><span>|</span><a href="#39607661">next</a><span>|</span><label class="collapse" for="c-39610673">[-]</label><label class="expand" for="c-39610673">[8 more]</label></div><br/><div class="children"><div class="content">Fail is an understatement, the ratio between the two volumes is basically (n&#x2F;2)!(4&#x2F;pi)^(n&#x2F;2). Which is also the expected number of tries you&#x27;ll need. The time doesn&#x27;t merely grow exponentially it grows <i>faster</i> than exponential.<p>I don&#x27;t actually know of any useful algorithms with worse asymptomatic behaviour.</div><br/><div id="39613345" class="c"><input type="checkbox" id="c-39613345" checked=""/><div class="controls bullet"><span class="by">fjkdlsjflkds</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39610673">parent</a><span>|</span><a href="#39611107">next</a><span>|</span><label class="collapse" for="c-39613345">[-]</label><label class="expand" for="c-39613345">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t actually know of any useful algorithms with worse asymptomatic behaviour.<p>Note: &quot;asymptomatic&quot; does not mean the same as &quot;asymptotic&quot;</div><br/></div></div><div id="39611107" class="c"><input type="checkbox" id="c-39611107" checked=""/><div class="controls bullet"><span class="by">ianferrel</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39610673">parent</a><span>|</span><a href="#39613345">prev</a><span>|</span><a href="#39611158">next</a><span>|</span><label class="collapse" for="c-39611107">[-]</label><label class="expand" for="c-39611107">[5 more]</label></div><br/><div class="children"><div class="content">Sure, but for the most-used real-world geometry, n = 2 or 3. So how fast it grows really doesn&#x27;t matter.<p>Most maps are 2-dimensional and this is fine.</div><br/><div id="39612046" class="c"><input type="checkbox" id="c-39612046" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39611107">parent</a><span>|</span><a href="#39611178">next</a><span>|</span><label class="collapse" for="c-39612046">[-]</label><label class="expand" for="c-39612046">[2 more]</label></div><br/><div class="children"><div class="content">When I saw &quot;n&quot; in the title I assumed they wanted something that worked reasonably for large n.  Rejection is no good because of the notorious &quot;curse of dimensionality&quot;.  So my idea was to choose a suitable distribution on the radius, then draw from it and choose the angles at random (not sure what those angles are called).  You might have to delete the point at the center for that to work.</div><br/><div id="39613568" class="c"><input type="checkbox" id="c-39613568" checked=""/><div class="controls bullet"><span class="by">Certhas</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39612046">parent</a><span>|</span><a href="#39611178">next</a><span>|</span><label class="collapse" for="c-39613568">[-]</label><label class="expand" for="c-39613568">[1 more]</label></div><br/><div class="children"><div class="content">The article explicitly discusses both. Versions for low dimensions that have favorable properties, and those for high dimensions.<p>The method you propose is not used in high dimensions in practice as it would involve evaluating order n^2 trigonometric functions and is also far harder to implement than the methods discussed in the article.</div><br/></div></div></div></div><div id="39611178" class="c"><input type="checkbox" id="c-39611178" checked=""/><div class="controls bullet"><span class="by">ls612</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39611107">parent</a><span>|</span><a href="#39612046">prev</a><span>|</span><a href="#39611158">next</a><span>|</span><label class="collapse" for="c-39611178">[-]</label><label class="expand" for="c-39611178">[2 more]</label></div><br/><div class="children"><div class="content">Maybe n=4 if you have a timestamp as another dimension.</div><br/><div id="39612662" class="c"><input type="checkbox" id="c-39612662" checked=""/><div class="controls bullet"><span class="by">alanbernstein</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39611178">parent</a><span>|</span><a href="#39611158">next</a><span>|</span><label class="collapse" for="c-39612662">[-]</label><label class="expand" for="c-39612662">[1 more]</label></div><br/><div class="children"><div class="content">Do your timestamps occupy a hypersphere?</div><br/></div></div></div></div></div></div><div id="39611158" class="c"><input type="checkbox" id="c-39611158" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39610673">parent</a><span>|</span><a href="#39611107">prev</a><span>|</span><a href="#39607661">next</a><span>|</span><label class="collapse" for="c-39611158">[-]</label><label class="expand" for="c-39611158">[1 more]</label></div><br/><div class="children"><div class="content">I doubt that the number of dimensions is the parameter that grows. It’s going to be constant for 99.99% of cases.</div><br/></div></div></div></div></div></div><div id="39607661" class="c"><input type="checkbox" id="c-39607661" checked=""/><div class="controls bullet"><span class="by">bagels</span><span>|</span><a href="#39607616">parent</a><span>|</span><a href="#39608009">prev</a><span>|</span><a href="#39609586">next</a><span>|</span><label class="collapse" for="c-39607661">[-]</label><label class="expand" for="c-39607661">[4 more]</label></div><br/><div class="children"><div class="content">I needed something related, n roughly evenly distributed points on the surface of a sphere. Ended up using a Fibonacci spiral.<p><a href="https:&#x2F;&#x2F;extremelearning.com.au&#x2F;how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice&#x2F;" rel="nofollow">https:&#x2F;&#x2F;extremelearning.com.au&#x2F;how-to-evenly-distribute-poin...</a></div><br/><div id="39612606" class="c"><input type="checkbox" id="c-39612606" checked=""/><div class="controls bullet"><span class="by">milleramp</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39607661">parent</a><span>|</span><a href="#39612667">next</a><span>|</span><label class="collapse" for="c-39612606">[-]</label><label class="expand" for="c-39612606">[1 more]</label></div><br/><div class="children"><div class="content">Hey me too, very interesting problem.  I also used this method as well.
<a href="https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;abs&#x2F;pii&#x2F;S0010465518301292" rel="nofollow">https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;abs&#x2F;pii&#x2F;S00104...</a></div><br/></div></div><div id="39612667" class="c"><input type="checkbox" id="c-39612667" checked=""/><div class="controls bullet"><span class="by">alanbernstein</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39607661">parent</a><span>|</span><a href="#39612606">prev</a><span>|</span><a href="#39609586">next</a><span>|</span><label class="collapse" for="c-39612667">[-]</label><label class="expand" for="c-39612667">[2 more]</label></div><br/><div class="children"><div class="content">Force directed layout is my favorite for this.</div><br/><div id="39613364" class="c"><input type="checkbox" id="c-39613364" checked=""/><div class="controls bullet"><span class="by">fjkdlsjflkds</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39612667">parent</a><span>|</span><a href="#39609586">next</a><span>|</span><label class="collapse" for="c-39613364">[-]</label><label class="expand" for="c-39613364">[1 more]</label></div><br/><div class="children"><div class="content">...but then the algorithmic complexity goes from O(N) to O(N^2), or at least O(N log N), since points have to interact with each other.<p>(N denotes the number of points you need to generate)</div><br/></div></div></div></div></div></div><div id="39609586" class="c"><input type="checkbox" id="c-39609586" checked=""/><div class="controls bullet"><span class="by">chpatrick</span><span>|</span><a href="#39607616">parent</a><span>|</span><a href="#39607661">prev</a><span>|</span><a href="#39609656">next</a><span>|</span><label class="collapse" for="c-39609586">[-]</label><label class="expand" for="c-39609586">[4 more]</label></div><br/><div class="children"><div class="content">What if someone lives in a really remote location so they&#x27;re the only ones in the heat map cell?</div><br/><div id="39611216" class="c"><input type="checkbox" id="c-39611216" checked=""/><div class="controls bullet"><span class="by">nick7376182</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39609586">parent</a><span>|</span><a href="#39609619">next</a><span>|</span><label class="collapse" for="c-39611216">[-]</label><label class="expand" for="c-39611216">[1 more]</label></div><br/><div class="children"><div class="content">Assign everyone a random offset, that doesn&#x27;t change, that is large enough to obscure the address with some reasonable radius but small enough to not drastically skew the heat map at a lower zoom level</div><br/></div></div><div id="39609619" class="c"><input type="checkbox" id="c-39609619" checked=""/><div class="controls bullet"><span class="by">nighthawk454</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39609586">parent</a><span>|</span><a href="#39611216">prev</a><span>|</span><a href="#39609656">next</a><span>|</span><label class="collapse" for="c-39609619">[-]</label><label class="expand" for="c-39609619">[2 more]</label></div><br/><div class="children"><div class="content">I should think after defining a uniform distribution of points, you could cluster them as needed to form larger lower-resolution chunks according to population size. Binning everyone in that region to say the central most point. Which could then be adaptive as the populations change.</div><br/><div id="39611990" class="c"><input type="checkbox" id="c-39611990" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#39607616">root</a><span>|</span><a href="#39609619">parent</a><span>|</span><a href="#39609656">next</a><span>|</span><label class="collapse" for="c-39611990">[-]</label><label class="expand" for="c-39611990">[1 more]</label></div><br/><div class="children"><div class="content">This is the correct answer. You need an aggregation threshold that restricts precision when population count is too low. In this case, the cell size needs to increase until there are at least N users.</div><br/></div></div></div></div></div></div></div></div><div id="39609656" class="c"><input type="checkbox" id="c-39609656" checked=""/><div class="controls bullet"><span class="by">dmd</span><span>|</span><a href="#39607616">prev</a><span>|</span><a href="#39611848">next</a><span>|</span><label class="collapse" for="c-39609656">[-]</label><label class="expand" for="c-39609656">[5 more]</label></div><br/><div class="children"><div class="content">As an RA, before starting grad school, I hacked together some code to choose a random point on a sphere, for some psychophysics experiment I was doing.<p>Fortunately, I never used it for anything, because I made the classic naive mistake of simply choosing a random theta in 0,2pi and phi in -pi,pi, which ends up with points biased towards the poles.<p>Somehow *12 years later* my subconscious flagged it up and I woke up in the middle of the night realizing the issue. Even though I&#x27;d never revisited it since then!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dmd&#x2F;thesis&#x2F;commit&#x2F;bff319690188a62a79821aa404b82e9835bf7499">https:&#x2F;&#x2F;github.com&#x2F;dmd&#x2F;thesis&#x2F;commit&#x2F;bff319690188a62a79821aa...</a></div><br/><div id="39609783" class="c"><input type="checkbox" id="c-39609783" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#39609656">parent</a><span>|</span><a href="#39610001">next</a><span>|</span><label class="collapse" for="c-39609783">[-]</label><label class="expand" for="c-39609783">[1 more]</label></div><br/><div class="children"><div class="content">A friend of mine made this mistake a long time ago when sampling points in a circle. He was baffled and couldn&#x27;t understand why there was concentration of points around some areas of the circle. My explanation: draw a square around this circle; trace a horizontal line passing along its center; now, draw a diagonal line; can you see it is more likely that a randomly sampled point is closer to the diagonal than to horizontal line? He said &quot;sure!&quot; and I asked &quot;why?&quot; to what he promptly answered &quot;because its longer.&quot;. He then asked what he should do about it, I simply said: &quot;just ignore the points that are too far&quot;. He immediately understood that points inside the square but outside the disk were the reason for the concentration of the points.</div><br/></div></div><div id="39610001" class="c"><input type="checkbox" id="c-39610001" checked=""/><div class="controls bullet"><span class="by">xanderlewis</span><span>|</span><a href="#39609656">parent</a><span>|</span><a href="#39609783">prev</a><span>|</span><a href="#39611848">next</a><span>|</span><label class="collapse" for="c-39610001">[-]</label><label class="expand" for="c-39610001">[3 more]</label></div><br/><div class="children"><div class="content">&gt; simply choosing a random theta in 0,2pi and phi in -pi,pi, which ends up with points biased towards the poles.<p>Am I right in thinking that it’s because circles of constant theta on the sphere contain the same ‘expected’ number of points (since phi is uniformly distributed), and these circles get smaller (and in the limit, shrink to a point) as one travels towards the poles — hence, higher density of points…?<p>…makes me realise that spherical polar coordinates, as natural as they seem, aren’t in some way homogeneous in the sense that whilst the mapping (theta, phi) —&gt; (x, y, z) is continuous, it isn’t uniformly so… or something like that. I don’t know enough (possibly differential) geometry to articulate it properly, but it feels like the problem of getting genuinely uniform sampling from a sphere (or indeed any manifold) is somewhat equivalent to having a ‘nice’ coordinate system (one that respects the symmetry of the sphere). Basically, polar coordinates are prejudiced and treat points differently depending on how close to the poles they are.<p>By definition, our sampling in the domain space (two intervals) is uniform; the problem comes when we project through a coordinate system that doesn’t respect this.<p>Which better solution did you use? I’m having trouble reading your code on my current device.</div><br/><div id="39610182" class="c"><input type="checkbox" id="c-39610182" checked=""/><div class="controls bullet"><span class="by">dmd</span><span>|</span><a href="#39609656">root</a><span>|</span><a href="#39610001">parent</a><span>|</span><a href="#39611225">next</a><span>|</span><label class="collapse" for="c-39610182">[-]</label><label class="expand" for="c-39610182">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Which better solution did you use?<p>I didn&#x27;t, since I haven&#x27;t touched or needed this code since 2003. I just put a warning saying don&#x27;t use it.</div><br/></div></div><div id="39611225" class="c"><input type="checkbox" id="c-39611225" checked=""/><div class="controls bullet"><span class="by">eli_gottlieb</span><span>|</span><a href="#39609656">root</a><span>|</span><a href="#39610001">parent</a><span>|</span><a href="#39610182">prev</a><span>|</span><a href="#39611848">next</a><span>|</span><label class="collapse" for="c-39611225">[-]</label><label class="expand" for="c-39611225">[1 more]</label></div><br/><div class="children"><div class="content">&gt; whilst the mapping (theta, phi) —&gt; (x, y, z) is continuous, it isn’t uniformly so… or something like that.<p>The term is &quot;measure preserving&quot;.  The mapping is continuous but it doesn&#x27;t preserve the length of intervals projected through it.</div><br/></div></div></div></div></div></div><div id="39611848" class="c"><input type="checkbox" id="c-39611848" checked=""/><div class="controls bullet"><span class="by">porphyra</span><span>|</span><a href="#39609656">prev</a><span>|</span><a href="#39610757">next</a><span>|</span><label class="collapse" for="c-39611848">[-]</label><label class="expand" for="c-39611848">[2 more]</label></div><br/><div class="children"><div class="content">Another way to generate uniformly random points on a 2D disk that the author forgot to mention: let A be an n x n complex matrix whose elements are iid copies of a fixed random variable with unit variance. Let lambda_i be its ith eigenvalue, and let x_i = 1&#x2F;sqrt(n) real(lambda_i) and y_i = 1&#x2F;sqrt(n) imag(lambda_i). As n approaches infinity, the distribution of x, y approaches almost certainly to the uniform distribution over the unit disk.<p>Tao, T., Vu, V., and Krishnapur, M. (2010) Random matrices: universality of ESDs and the circular law. The Annals of Probability. 38(5) 2023-2065.</div><br/><div id="39613209" class="c"><input type="checkbox" id="c-39613209" checked=""/><div class="controls bullet"><span class="by">kurlberg</span><span>|</span><a href="#39611848">parent</a><span>|</span><a href="#39610757">next</a><span>|</span><label class="collapse" for="c-39613209">[-]</label><label class="expand" for="c-39613209">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very inefficient, both on terms of runtime and in terms wasted entropy.</div><br/></div></div></div></div><div id="39610757" class="c"><input type="checkbox" id="c-39610757" checked=""/><div class="controls bullet"><span class="by">pugworthy</span><span>|</span><a href="#39611848">prev</a><span>|</span><a href="#39612865">next</a><span>|</span><label class="collapse" for="c-39610757">[-]</label><label class="expand" for="c-39610757">[2 more]</label></div><br/><div class="children"><div class="content">2-ball (disk) distribution is kind of interesting in gaming when simulating gun projectile hit locations.<p>If the circle represents the area in which a simulated projectile will hit, you probably don&#x27;t want a truly random distribution of points but instead have a bias towards the middle of the circle.  A real gun shot multiple times at a fixed target will probably (assuming perfect aim but some variation on every shot) have more shots hit the middle of the pattern than the edges.<p>Some early Valve shot code actually had a purely random distribution, but at some point an alternate version got written and shared at <a href="https:&#x2F;&#x2F;developer.valvesoftware.com&#x2F;wiki&#x2F;CShotManipulator" rel="nofollow">https:&#x2F;&#x2F;developer.valvesoftware.com&#x2F;wiki&#x2F;CShotManipulator</a><p>Ironically the biased version is based on a pretty simple method that in fact people sometimes get wrong when they want a truly random point distribution in a circle.  Just doing a random radius and theta will lead to a biased distribution.  Wolfram Mathworld has a good writeup on it at <a href="https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;DiskPointPicking.html" rel="nofollow">https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;DiskPointPicking.html</a></div><br/><div id="39610835" class="c"><input type="checkbox" id="c-39610835" checked=""/><div class="controls bullet"><span class="by">xanderlewis</span><span>|</span><a href="#39610757">parent</a><span>|</span><a href="#39612865">next</a><span>|</span><label class="collapse" for="c-39610835">[-]</label><label class="expand" for="c-39610835">[1 more]</label></div><br/><div class="children"><div class="content">&gt; truly random distribution<p>&gt; purely random distribution<p>Nitpick: you don’t mean <i>random</i>; you mean <i>uniform</i>.</div><br/></div></div></div></div><div id="39612865" class="c"><input type="checkbox" id="c-39612865" checked=""/><div class="controls bullet"><span class="by">renonce</span><span>|</span><a href="#39610757">prev</a><span>|</span><a href="#39609147">next</a><span>|</span><label class="collapse" for="c-39612865">[-]</label><label class="expand" for="c-39612865">[1 more]</label></div><br/><div class="children"><div class="content">I learned the easiest way to do d-dimension sampling in Foundations of Data Science: see <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34575637">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34575637</a> or <a href="https:&#x2F;&#x2F;www.cs.cornell.edu&#x2F;jeh&#x2F;book.pdf?file=book.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.cornell.edu&#x2F;jeh&#x2F;book.pdf?file=book.pdf</a><p>I don&#x27;t think it&#x27;s a good idea to introduce over 20 different methods before talking about the correct one that works for any number of dimensions, say n, and the reason behind its correctness is very obvious:<p>* Generate a random vector by sampling n standard normal distributions: `vector = np.random.randn(n)`<p>* Key step: show that the vector has a uniform direction.<p>The proof is as follows: you look at the probability density function of a normal distribution, which is `p(x)=1&#x2F;sqrt(2pi)*exp(-x^2&#x2F;2)`, and the probability density function of the vector is the product of all these densities of its individual dimensions. Now the product `p(x1)p(x2)...p(xn)=1&#x2F;sqrt(2pi)^n*exp(-(x1^2+x2^2+...+xn^2)&#x2F;2)` since `exp(a)exp(b)=exp(a+b)` due to power functions.<p>Now it&#x27;s easy to see that probability density is invariant to vector length, which means the vector has uniform probability for any specific value of x1^2+x2^2+...+xn^2. Whatever rotation you apply after sampling this vector, since rotation preserves x1^2+x2^2+...+xn^2 by definition, you get the exact same probability density function and therefore the same distribution of vectors.<p>* Now that the direction of the vector is uniformly sampled, decide the radius separately: for n-sphere the radius is just 1, and for n-ball the volume of the radius is proportional to the nth power of the radius, so you sample a uniform number from [0,1] as the volume and take the nth root as the radius: `radius = np.random.uniform(0, 1)*(1&#x2F;n)`<p>* Normalize the vector to the radius: `vector = vector &#x2F; np.sqrt((vector*2).sum()) * radius`<p>I think Section 2 of this book provides a much better perspective on the problem of generating uniform random points, since it also provides intuition behind the geometry of high dimensions and properties of the unit ball, etc.</div><br/></div></div><div id="39609147" class="c"><input type="checkbox" id="c-39609147" checked=""/><div class="controls bullet"><span class="by">montefischer</span><span>|</span><a href="#39612865">prev</a><span>|</span><a href="#39612840">next</a><span>|</span><label class="collapse" for="c-39609147">[-]</label><label class="expand" for="c-39609147">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested in things like this, you might like to read the paper of Diaconis, Holmes, and Shashahani on sampling from a manifold. <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1206.6913" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1206.6913</a></div><br/></div></div><div id="39612840" class="c"><input type="checkbox" id="c-39612840" checked=""/><div class="controls bullet"><span class="by">stefanka</span><span>|</span><a href="#39609147">prev</a><span>|</span><a href="#39613134">next</a><span>|</span><label class="collapse" for="c-39612840">[-]</label><label class="expand" for="c-39612840">[1 more]</label></div><br/><div class="children"><div class="content">I encountered the need for uniform random points on hyperspheres, and found this solution (with Python code) very helpful: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;59279721" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;59279721</a>.<p>Currently, I am porting my codebase to Rust and did that part over the weekend, so if anyone is interested in this exact implementation, I&#x27;d willing to share it (as a crate if necessary).</div><br/></div></div><div id="39613134" class="c"><input type="checkbox" id="c-39613134" checked=""/><div class="controls bullet"><span class="by">ackbar03</span><span>|</span><a href="#39612840">prev</a><span>|</span><a href="#39610704">next</a><span>|</span><label class="collapse" for="c-39613134">[-]</label><label class="expand" for="c-39613134">[1 more]</label></div><br/><div class="children"><div class="content">Is this the same as uniform SO(N) sampling? I had to do something similar like this for some deep learning training method I was working on. I gave up</div><br/></div></div><div id="39610704" class="c"><input type="checkbox" id="c-39610704" checked=""/><div class="controls bullet"><span class="by">atum47</span><span>|</span><a href="#39613134">prev</a><span>|</span><a href="#39607942">next</a><span>|</span><label class="collapse" for="c-39610704">[-]</label><label class="expand" for="c-39610704">[1 more]</label></div><br/><div class="children"><div class="content">Some years ago I saw a blue and red image that caught my attention. The red dots seemed to be floating around the blue ones. I later found out that has a name - Chromostereopsis [1]. So I decided to make my own image and needed to distribute some points in a circle, this how I did it [2].<p>[1] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chromostereopsis" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chromostereopsis</a><p>[2] - <a href="https:&#x2F;&#x2F;jsfiddle.net&#x2F;victorqribeiro&#x2F;vxf2ajzm&#x2F;48&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jsfiddle.net&#x2F;victorqribeiro&#x2F;vxf2ajzm&#x2F;48&#x2F;</a></div><br/></div></div><div id="39607942" class="c"><input type="checkbox" id="c-39607942" checked=""/><div class="controls bullet"><span class="by">enthdegree</span><span>|</span><a href="#39610704">prev</a><span>|</span><a href="#39609022">next</a><span>|</span><label class="collapse" for="c-39607942">[-]</label><label class="expand" for="c-39607942">[1 more]</label></div><br/><div class="children"><div class="content">I find it hard to believe the dropped coordinates approaches were first noticed in 2010 and proven in 2017.</div><br/></div></div><div id="39609022" class="c"><input type="checkbox" id="c-39609022" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39607942">prev</a><span>|</span><a href="#39608596">next</a><span>|</span><label class="collapse" for="c-39609022">[-]</label><label class="expand" for="c-39609022">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if CS people have studied the method of Lubotzky, Phillips and Sarnak to produce well-distributed points on spheres: <a href="https:&#x2F;&#x2F;onlinelibrary.wiley.com&#x2F;doi&#x2F;abs&#x2F;10.1002&#x2F;cpa.3160390710" rel="nofollow">https:&#x2F;&#x2F;onlinelibrary.wiley.com&#x2F;doi&#x2F;abs&#x2F;10.1002&#x2F;cpa.31603907...</a></div><br/></div></div><div id="39608596" class="c"><input type="checkbox" id="c-39608596" checked=""/><div class="controls bullet"><span class="by">kloch</span><span>|</span><a href="#39609022">prev</a><span>|</span><a href="#39612098">next</a><span>|</span><label class="collapse" for="c-39608596">[-]</label><label class="expand" for="c-39608596">[1 more]</label></div><br/><div class="children"><div class="content">I find it amusing that you need a normal distribution of scalars to generate a uniform distribution of vectors on an n-sphere.</div><br/></div></div><div id="39612098" class="c"><input type="checkbox" id="c-39612098" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#39608596">prev</a><span>|</span><a href="#39609542">next</a><span>|</span><label class="collapse" for="c-39612098">[-]</label><label class="expand" for="c-39612098">[3 more]</label></div><br/><div class="children"><div class="content">Off topic: isn&#x27;t &quot;uniformly random&quot; a contradiction of terms?</div><br/><div id="39612177" class="c"><input type="checkbox" id="c-39612177" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#39612098">parent</a><span>|</span><a href="#39612208">next</a><span>|</span><label class="collapse" for="c-39612177">[-]</label><label class="expand" for="c-39612177">[1 more]</label></div><br/><div class="children"><div class="content">No. Random just means you can&#x27;t predict what value will be chosen, but doesn&#x27;t tell you how likely different values are.<p>If I roll a 12-sided die, that&#x27;s random. If I roll two 6-sided dice and add the result, that&#x27;s also random, but it has a different distribution of values.<p>The two dice verison, there&#x27;s one way to get a result of 2, but _several_ ways to get 7. You&#x27;ll get 7 way more often than you&#x27;ll get 2.<p>The one-die version each outcome is equally likely. You&#x27;re exactly as likely to get 2 as you are to get 7 or any other value in the range of possibilities.<p>The one-die version is a uniform distribution. The two-dice version is not uniform.</div><br/></div></div><div id="39612208" class="c"><input type="checkbox" id="c-39612208" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#39612098">parent</a><span>|</span><a href="#39612177">prev</a><span>|</span><a href="#39609542">next</a><span>|</span><label class="collapse" for="c-39612208">[-]</label><label class="expand" for="c-39612208">[1 more]</label></div><br/><div class="children"><div class="content">Random is not precise; it does specify a distribution, though uniform is commonly assumed. A better term is &quot;uniformly distributed&quot;.</div><br/></div></div></div></div><div id="39609542" class="c"><input type="checkbox" id="c-39609542" checked=""/><div class="controls bullet"><span class="by">xLaszlo</span><span>|</span><a href="#39612098">prev</a><span>|</span><a href="#39609648">next</a><span>|</span><label class="collapse" for="c-39609542">[-]</label><label class="expand" for="c-39609542">[2 more]</label></div><br/><div class="children"><div class="content">If you are looking for low discrepancy (fills the space &quot;smoothly&quot;) quasy random numbers check out Sobol and Niederreiter sequences.</div><br/><div id="39610236" class="c"><input type="checkbox" id="c-39610236" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39609542">parent</a><span>|</span><a href="#39609648">next</a><span>|</span><label class="collapse" for="c-39610236">[-]</label><label class="expand" for="c-39610236">[1 more]</label></div><br/><div class="children"><div class="content">No don&#x27;t. Look at plastic numbers instead. They are much better.</div><br/></div></div></div></div><div id="39609648" class="c"><input type="checkbox" id="c-39609648" checked=""/><div class="controls bullet"><span class="by">nighthawk454</span><span>|</span><a href="#39609542">prev</a><span>|</span><a href="#39607627">next</a><span>|</span><label class="collapse" for="c-39609648">[-]</label><label class="expand" for="c-39609648">[1 more]</label></div><br/><div class="children"><div class="content">See also this method based on optimizing nearest-neighbor distances after initializing with fibonacci spiral:<p><a href="https:&#x2F;&#x2F;extremelearning.com.au&#x2F;how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice&#x2F;" rel="nofollow">https:&#x2F;&#x2F;extremelearning.com.au&#x2F;how-to-evenly-distribute-poin...</a></div><br/></div></div><div id="39607627" class="c"><input type="checkbox" id="c-39607627" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39609648">prev</a><span>|</span><a href="#39607519">next</a><span>|</span><label class="collapse" for="c-39607627">[-]</label><label class="expand" for="c-39607627">[4 more]</label></div><br/><div class="children"><div class="content">I was always surprised at how easily you get biased sampling when generating random points despite all input - something I often saw students do was essentially normalize({2<i>rand() - 1, 2</i>rand() - 1, 2<i>rand() - 1}) or variations of that (where rand() is &quot;good&quot; not the literal rand(3)), and there are numerous other ways that are more subtly wrong. IIRC the nominally correct way for a sphere specifically is something like a=rand() b=rand() and the random point is </i>something* like { cos(a)<i>sin(b), sin(b), cos(a)</i>cos(b) }[1]<p>I think the best illustration of &quot;reasonable choices of what random values should be used leading to biased results&quot; is Bertrand&#x27;s paradox which I was introduced to via numberphile&#x2F;3blue1brown: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mZBwsm6B280" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mZBwsm6B280</a> and am just glad that nothing I have ever needed random sampling for has ever been important :D<p>[1] please don&#x27;t use this blindly, I&#x27;m really just going off very old recollection, if you need it google random sphere sampling :D</div><br/><div id="39608044" class="c"><input type="checkbox" id="c-39608044" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39607627">parent</a><span>|</span><a href="#39607519">next</a><span>|</span><label class="collapse" for="c-39608044">[-]</label><label class="expand" for="c-39608044">[3 more]</label></div><br/><div class="children"><div class="content">I used to think “normal distributions are everywhere” but the more math and science I watch on YouTube the more the central limit theorem pops up. It’s the CLT that’s everywhere, it just brings normal distribution as it’s +1.</div><br/><div id="39610986" class="c"><input type="checkbox" id="c-39610986" checked=""/><div class="controls bullet"><span class="by">richrichie</span><span>|</span><a href="#39607627">root</a><span>|</span><a href="#39608044">parent</a><span>|</span><a href="#39607519">next</a><span>|</span><label class="collapse" for="c-39610986">[-]</label><label class="expand" for="c-39610986">[2 more]</label></div><br/><div class="children"><div class="content">Indeed.
The fundamental insight behind CLT i.e. sample average is normally distributed even when population distribution is not normal is intuitive, yet the the theorem is magical.</div><br/><div id="39611322" class="c"><input type="checkbox" id="c-39611322" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39607627">root</a><span>|</span><a href="#39610986">parent</a><span>|</span><a href="#39607519">next</a><span>|</span><label class="collapse" for="c-39611322">[-]</label><label class="expand" for="c-39611322">[1 more]</label></div><br/><div class="children"><div class="content">When you have more than one variable, the outcomes get clumpy.</div><br/></div></div></div></div></div></div></div></div><div id="39607519" class="c"><input type="checkbox" id="c-39607519" checked=""/><div class="controls bullet"><span class="by">JadoJodo</span><span>|</span><a href="#39607627">prev</a><span>|</span><label class="collapse" for="c-39607519">[-]</label><label class="expand" for="c-39607519">[24 more]</label></div><br/><div class="children"><div class="content">I&#x27;m definitely not at all qualified to talk about this, but... aren&#x27;t &quot;uniform&quot; and &quot;random&quot; antonyms?</div><br/><div id="39607587" class="c"><input type="checkbox" id="c-39607587" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#39607519">parent</a><span>|</span><a href="#39607576">next</a><span>|</span><label class="collapse" for="c-39607587">[-]</label><label class="expand" for="c-39607587">[3 more]</label></div><br/><div class="children"><div class="content">No, &#x27;uniform&#x27; refers to the distribution, which need not be uniform, e.g.<p><a href="https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;reference&#x2F;random&#x2F;generated&#x2F;numpy.random.normal.html" rel="nofollow">https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;reference&#x2F;random&#x2F;generated&#x2F;nump...</a><p>Or in god&#x27;s own words (<i>TAOCP section 3.4</i>):<p><i>Applications of random numbers often call for other kinds of distributions, however; for example, if we want to make a random choice from among k alternatives, we want a random integer between 1 and k. If some simulation process calls for a random waiting time between occurrences of independent events, a random number with the exponential distribution is desired. Sometimes we don&#x27;t even want random numbers — we want a random permutation (a random arrangement of n objects) or a random combination (a random choice of k objects from a collection of n).<p>In principle, any of these other random quantities can be obtained from the uniform deviates U0, U1, U2, ...; people have devised a number of important &quot;random tricks&quot; for the efficient transformation of uniform deviates. A study of these techniques also gives us insight into the proper use of random numbers in any Monte Carlo application.</i></div><br/><div id="39608984" class="c"><input type="checkbox" id="c-39608984" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607587">parent</a><span>|</span><a href="#39607576">next</a><span>|</span><label class="collapse" for="c-39608984">[-]</label><label class="expand" for="c-39608984">[2 more]</label></div><br/><div class="children"><div class="content">&quot;All distributions are uniform&quot; is one of the two cardinal crimes of a school level of statistics understanding, the other being &quot;all probabilities are independent&quot;.</div><br/></div></div></div></div><div id="39607576" class="c"><input type="checkbox" id="c-39607576" checked=""/><div class="controls bullet"><span class="by">bqmjjx0kac</span><span>|</span><a href="#39607519">parent</a><span>|</span><a href="#39607587">prev</a><span>|</span><a href="#39609438">next</a><span>|</span><label class="collapse" for="c-39607576">[-]</label><label class="expand" for="c-39607576">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Uniform&quot; here indicates that all values have an equal probability of being picked. The distribution is flat.</div><br/></div></div><div id="39607569" class="c"><input type="checkbox" id="c-39607569" checked=""/><div class="controls bullet"><span class="by">icoder</span><span>|</span><a href="#39607519">parent</a><span>|</span><a href="#39609438">prev</a><span>|</span><a href="#39607715">next</a><span>|</span><label class="collapse" for="c-39607569">[-]</label><label class="expand" for="c-39607569">[1 more]</label></div><br/><div class="children"><div class="content">The article explains this quite early on, as I understand it, it means that every spot has the same chance of being picked.</div><br/></div></div><div id="39607715" class="c"><input type="checkbox" id="c-39607715" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39607519">parent</a><span>|</span><a href="#39607569">prev</a><span>|</span><a href="#39607664">next</a><span>|</span><label class="collapse" for="c-39607715">[-]</label><label class="expand" for="c-39607715">[1 more]</label></div><br/><div class="children"><div class="content">Nope, uniform is a description of the probabilities of a random distribution.<p>The easiest example most people are aware of in practice is throwing two 6 sided dice vs one 12 sided dice. The outcome of both is random, but people seem to know fairly intuitively that the two dice case produces is more likely to produce middle values than extreme ones, while the single 12 sided dice doesn&#x27;t have that behavior.</div><br/></div></div><div id="39607664" class="c"><input type="checkbox" id="c-39607664" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#39607519">parent</a><span>|</span><a href="#39607715">prev</a><span>|</span><a href="#39607850">next</a><span>|</span><label class="collapse" for="c-39607664">[-]</label><label class="expand" for="c-39607664">[15 more]</label></div><br/><div class="children"><div class="content">No. I would go so far as to say, if it’s not uniformly random, it isn’t random.<p>My reasoning is, if you are counting cards in a game, you are giving yourself an advantage. But what really happens is that from your point of view cards will be drawn less and less uniformly randomly. Or put in another way, if you know the distribution is normal, you can bet on the the result being near the center and come out on top, but if it’s uniformly random distribution all hopes are out.</div><br/><div id="39607847" class="c"><input type="checkbox" id="c-39607847" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607664">parent</a><span>|</span><a href="#39610644">next</a><span>|</span><label class="collapse" for="c-39607847">[-]</label><label class="expand" for="c-39607847">[6 more]</label></div><br/><div class="children"><div class="content">Random (in statistics) means you cannot conclude the next value ahead of time. That&#x27;s different than saying the next value is uniformly likely to be any value and the two concepts are actually orthogonal. E.g. If I had a bag with 99 red balls and 1 blue ball then randomly selected one you may assume there is a high chance there will be a red ball, based on the odds, but you aren&#x27;t able to actually know which ball will be next until it&#x27;s drawn.</div><br/><div id="39608123" class="c"><input type="checkbox" id="c-39608123" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607847">parent</a><span>|</span><a href="#39609768">next</a><span>|</span><label class="collapse" for="c-39608123">[-]</label><label class="expand" for="c-39608123">[1 more]</label></div><br/><div class="children"><div class="content">But if you’re given a double or nothing bet option on each draw, you know there’s a range of strategies that vary from maximum winnings, to most likely winnings. You want a good story you go for max. You need a few thousand to head off a problem with your car, you bet a different way.</div><br/></div></div><div id="39609768" class="c"><input type="checkbox" id="c-39609768" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607847">parent</a><span>|</span><a href="#39608123">prev</a><span>|</span><a href="#39610644">next</a><span>|</span><label class="collapse" for="c-39609768">[-]</label><label class="expand" for="c-39609768">[4 more]</label></div><br/><div class="children"><div class="content">The second pick will have better odds of a blue ball, assuming the first one picked was red and the ball was not put back however - correct?<p>Even more so if you’ve gone 50 picks like that, and are now down to 49 red balls and one blue ball.<p>That is what card counting helps you with - knowing the odds based on your current state, as compared to the initial state.</div><br/><div id="39612048" class="c"><input type="checkbox" id="c-39612048" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39609768">parent</a><span>|</span><a href="#39610644">next</a><span>|</span><label class="collapse" for="c-39612048">[-]</label><label class="expand" for="c-39612048">[3 more]</label></div><br/><div class="children"><div class="content">Depends if the balls are placed back or not. Similar to cards, any game which never replenishes the deck and lets you draw all the cards down to the last one lets the last pick (but not the prior ones) be non-random.</div><br/><div id="39612188" class="c"><input type="checkbox" id="c-39612188" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39612048">parent</a><span>|</span><a href="#39610644">next</a><span>|</span><label class="collapse" for="c-39612188">[-]</label><label class="expand" for="c-39612188">[2 more]</label></div><br/><div class="children"><div class="content">I literally stated ‘if the balls don’t get put back’.<p>And the last card was still random, btw. But can be guessed now with perfect precision due to the process of elimination.<p>Random at shuffle doesn’t mean unguessable or unpredictable as the game goes on.</div><br/><div id="39612409" class="c"><input type="checkbox" id="c-39612409" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39612188">parent</a><span>|</span><a href="#39610644">next</a><span>|</span><label class="collapse" for="c-39612409">[-]</label><label class="expand" for="c-39612409">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, meant to say the more generic &quot;replenished&quot; but typed a bit of your comment while reading it at the same time :p. That&#x27;s what I was saying by the next part, it doesn&#x27;t matter _how_ it&#x27;s replenished just that the pool doesn&#x27;t dwindle to 1 option for any reason. E.g. you could not put them back pull and mix from multiple decks&#x2F;ball sources as the game progresses and even though 51 cards&#x2F;99 balls are discarded you don&#x27;t know what n+1 is for certain yet.<p>I disagree the last card is &quot;still&quot; random, at least in the sense of statistics. It &quot;was&quot; random up until the measure of uncertainty of the next event reaches 0 (i.e. entropy reaches 0). At that point it&#x27;s no longer a &quot;guess&quot;, there is no uncertainty and the remaining pattern is always 100% predictable in that regardless which proceeding events occured to get there it can always be known what the next value is without uncertainty. Since there ceases to be any uncertainty in what the remaining pattern will be there ceases to be randomness in the next value generated. That the card&#x27;s value was not known at n=0 does not affect whether the n+1 card still is&#x2F;isn&#x27;t random when n=51. In another form, that you didn&#x27;t previously know the value of card n=52 with past information holds no influence whether the value is random or not with new information. Statistical randomness is all about what you know of the future predictability, not about how something came about.<p>This is also true of events which fall into predictable patterns at any point along the path. E.g. if I had a (relatively useless) hardware random number generator that generated random numbers 0-127 once per second until it generated a 0 at n=17, at which point it ceased being able to pull randomness from it&#x27;s dead circuits and always produced 0 afterward, the first 17 values were all statistically random at the time of their draw but n=[18,inf) are all now predictable and no longer random from that point on.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39610644" class="c"><input type="checkbox" id="c-39610644" checked=""/><div class="controls bullet"><span class="by">saalweachter</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607664">parent</a><span>|</span><a href="#39607847">prev</a><span>|</span><a href="#39610863">next</a><span>|</span><label class="collapse" for="c-39610644">[-]</label><label class="expand" for="c-39610644">[1 more]</label></div><br/><div class="children"><div class="content">A simple example of non-uniform randomness is the two-dice roll.<p>Rolling two dice gives you a number which is random in [2, 12], but not uniform -- 7 is far more likely than 2 or 12.</div><br/></div></div><div id="39610863" class="c"><input type="checkbox" id="c-39610863" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607664">parent</a><span>|</span><a href="#39610644">prev</a><span>|</span><a href="#39607815">next</a><span>|</span><label class="collapse" for="c-39610863">[-]</label><label class="expand" for="c-39610863">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Or put in another way, if you know the distribution is normal, you can bet on the the result being near the center and come out on top, but if it’s uniformly random distribution all hopes are out.<p>That’s just because the payout distribution and real distribution are different, and there’s a place the payout is at a loss.<p>If you bet on a uniform distribution of 2 through 12 that payed out according to a normal distribution, you’d make a killing betting on 2 or 12 (the “outliers”). If you roll 2d6 (normalish) and get paid according to a uniform distribution, you’ll make a killing betting on 7.</div><br/></div></div><div id="39607815" class="c"><input type="checkbox" id="c-39607815" checked=""/><div class="controls bullet"><span class="by">kelseyfrog</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607664">parent</a><span>|</span><a href="#39610863">prev</a><span>|</span><a href="#39607748">next</a><span>|</span><label class="collapse" for="c-39607815">[-]</label><label class="expand" for="c-39607815">[1 more]</label></div><br/><div class="children"><div class="content">By that criteria, wouldn&#x27;t a discrete distribution with infinite support be even <i>more</i> random?<p>Finite support somehow seems <i>less</i> random because you can still say something interesting about its mean and bounds in the same way you can say something about the mean and variance of a normal distribution.</div><br/></div></div><div id="39607748" class="c"><input type="checkbox" id="c-39607748" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607664">parent</a><span>|</span><a href="#39607815">prev</a><span>|</span><a href="#39610702">next</a><span>|</span><label class="collapse" for="c-39607748">[-]</label><label class="expand" for="c-39607748">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty of things that are random, that are not uniformly random. The hardware RNGs that are used for physically based RNG are not uniform, including the great lava lamp wall or geiger counters, etc.<p>The problem is if you are doing something that requires uniform random values, and your random source is not uniform, then things will go wrong.</div><br/></div></div><div id="39610702" class="c"><input type="checkbox" id="c-39610702" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607664">parent</a><span>|</span><a href="#39607748">prev</a><span>|</span><a href="#39607780">next</a><span>|</span><label class="collapse" for="c-39610702">[-]</label><label class="expand" for="c-39610702">[1 more]</label></div><br/><div class="children"><div class="content">The uniform distribution is in some sense the <i>most random</i> distribution you can choose, given that you have a finite number of cards. Formally, it&#x27;s the maximum entropy distribution on a finite domain.<p>But what if the domain isn&#x27;t finite? e.g. the entire real line? Then we can&#x27;t define a uniform distribution, because the total probability can never sum to one. We can still define a maximum entropy distribution, but only by making some more assumptions. The normal distribution is the maximum entropy distribution on the real line, given a particular mean and variance.<p>Other examples: on the positive real line, the exponential distribution is maximum-entropy for a given mean. Poisson distribution is the equivalent on the non-negative integers.</div><br/></div></div><div id="39608640" class="c"><input type="checkbox" id="c-39608640" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#39607519">root</a><span>|</span><a href="#39607664">parent</a><span>|</span><a href="#39607780">prev</a><span>|</span><a href="#39607775">next</a><span>|</span><label class="collapse" for="c-39608640">[-]</label><label class="expand" for="c-39608640">[1 more]</label></div><br/><div class="children"><div class="content">A normal random variate is just a uniform random variate that&#x27;s gone thru a 1-1 function.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>