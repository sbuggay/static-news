<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683363668492" as="style"/><link rel="stylesheet" href="styles.css?v=1683363668492"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zverok.space/blog/2023-05-05-ruby-types.html">A few words on Ruby&#x27;s type annotations state</a> <span class="domain">(<a href="https://zverok.space">zverok.space</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>74 comments</span></div><br/><div><div id="35835684" class="c"><input type="checkbox" id="c-35835684" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#35834351">next</a><span>|</span><label class="collapse" for="c-35835684">[-]</label><label class="expand" for="c-35835684">[14 more]</label></div><br/><div class="children"><div class="content">My experience is that you can have powerful runtime metaprogramming, or you can have good static type checking, but you can&#x27;t have both.<p>In most of the larger programs I&#x27;ve worked in the value of static typing is immense. In terms of my productivity, the only programming language feature that&#x27;s possibly had a bigger positive impact is garbage collection.<p>Runtime metaprogramming is very cool, but I&#x27;ve yet to work in a codebase where I felt that the value of it was greater than the value I get from good static analysis.<p>One way to think of static types is that they&#x27;re a debugger that <i>simultaneously debugs every possible run</i> of the program. And on top of that, you also get code navigation and better performance. It&#x27;s hard for me to imagine a sufficiently great metaprogramming feature that would be worth giving that up.</div><br/><div id="35835770" class="c"><input type="checkbox" id="c-35835770" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#35835684">parent</a><span>|</span><a href="#35838657">next</a><span>|</span><label class="collapse" for="c-35835770">[-]</label><label class="expand" for="c-35835770">[5 more]</label></div><br/><div class="children"><div class="content">I feel that oftentimes runtime metaprogramming is to make up for code that can&#x27;t be written down statically. But if you have the right macros then you don&#x27;t need the metaprogramming to happen at runtime. For instance, Rust has a pretty solid type system (not quite Haskell, but more intricate than Java) <i>and</i> lets you do things like generate serialization and deserialization code for arbitrary structs at compile time, which most languages would do at runtime by inspecting fields or something similar.<p>All this to say, runtime metaprogramming doesn&#x27;t seem inherently more capable compared to what&#x27;s possible in the more “static compiler” languages; rather, it seems like an escape hatch for when you can&#x27;t generate the code you want at compile time.</div><br/><div id="35839148" class="c"><input type="checkbox" id="c-35839148" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35835770">parent</a><span>|</span><a href="#35838852">next</a><span>|</span><label class="collapse" for="c-35839148">[-]</label><label class="expand" for="c-35839148">[1 more]</label></div><br/><div class="children"><div class="content"><i>All this to say, runtime metaprogramming doesn&#x27;t seem inherently more capable compared to what&#x27;s possible in the more “static compiler” languages; rather, it seems like an escape hatch for when you can&#x27;t generate the code you want at compile time.</i><p>It&#x27;s by definition more powerful though, in that the runtime language is (hopefully) more powerful than the type description language.<p>I&#x27;m not arguing that it isn&#x27;t preferable to produce (de)serialisation code statically. Just that by definition it&#x27;s more capable as it can do everything the runtime can.</div><br/></div></div><div id="35838852" class="c"><input type="checkbox" id="c-35838852" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35835770">parent</a><span>|</span><a href="#35839148">prev</a><span>|</span><a href="#35836064">next</a><span>|</span><label class="collapse" for="c-35838852">[-]</label><label class="expand" for="c-35838852">[1 more]</label></div><br/><div class="children"><div class="content">What I find absolutely intriguing is the existence of multiple compile&#x2F;runtimes, like a Matryoshka doll. LISPs are most famous for attempting to solve this problem with their macro systems. The JVM ecosystem also has a very oft used, but more advanced case for this: runtime code generation.<p>Depending on how dynamic your problem is this might be required and then “traditional compile-time” macros would not be enough.</div><br/></div></div><div id="35836064" class="c"><input type="checkbox" id="c-35836064" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35835770">parent</a><span>|</span><a href="#35838852">prev</a><span>|</span><a href="#35837126">next</a><span>|</span><label class="collapse" for="c-35836064">[-]</label><label class="expand" for="c-35836064">[1 more]</label></div><br/><div class="children"><div class="content">Yes, <i>compile</i>-time metaprogramming is a different approach that I&#x27;m personally really interested in. There are trade-offs as always, but it can give you much of the power of metaprogramming without totally killing static analysis.</div><br/></div></div><div id="35837126" class="c"><input type="checkbox" id="c-35837126" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35835770">parent</a><span>|</span><a href="#35836064">prev</a><span>|</span><a href="#35838657">next</a><span>|</span><label class="collapse" for="c-35837126">[-]</label><label class="expand" for="c-35837126">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For instance, Rust has a pretty solid type system (not quite Haskell, but more intricate than Java) and lets you do things like generate serialization and deserialization code for arbitrary structs at compile time, which most languages would do at runtime by inspecting fields or something similar.<p>For that matter, Haskell can do exactly the same thing, and as you note its type system is even more sophisticated than Rust’s.</div><br/></div></div></div></div><div id="35838657" class="c"><input type="checkbox" id="c-35838657" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#35835684">parent</a><span>|</span><a href="#35835770">prev</a><span>|</span><a href="#35837914">next</a><span>|</span><label class="collapse" for="c-35838657">[-]</label><label class="expand" for="c-35838657">[1 more]</label></div><br/><div class="children"><div class="content">I quite like Typescript&#x27;s approach here, which is (a) to model that metaprogramming as much as possible with metaprogramming of types, and (b) to always give you an escape hatch so you can wrap type unsafe metaprogramming in a type safe layer.<p>For example, I recently wrote a function that takes an arbitration nested object and a list of paths through that object (e.g. &quot;path.to.object&quot;), and does things with the data found at those paths. For (1), I could write a type that, given an object type, would return all the possible allowed paths as types, basically preventing the function from being used correctly (and it already has helped me catch a few typos here and there). So now func({foo:...}, &quot;bar&quot;) is disallowed directly at the type system.<p>But working with those exact types inside the function would have been too complicated, so I also did (2): inside the function, I just treated as the strings as normal strings (which, to the runtime, they are!) and did normal JavaScript metaprogramming to get arbitrary keys from arbitrary objects. I then have less type safety inside the function, but I can test that part more, while still leaving the caller of the function with the exact correct types.<p>In fairness, there are other ways to solve the same problem in other languages, with similar type safety. And JavaScript natively is not that high up on the metaprogramming scale. But I&#x27;m always impressed in Typescript how much a powerful type system and metaprogramming can dovetail into each other.</div><br/></div></div><div id="35837914" class="c"><input type="checkbox" id="c-35837914" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#35835684">parent</a><span>|</span><a href="#35838657">prev</a><span>|</span><a href="#35837088">next</a><span>|</span><label class="collapse" for="c-35837914">[-]</label><label class="expand" for="c-35837914">[1 more]</label></div><br/><div class="children"><div class="content">Working with a large Django codebase, I agree. Django leans on metaprogramming hard, and it&#x27;s hard to express the type &quot;It&#x27;s a Model, but doesn&#x27;t have an inner class Meta right now, but it will at runtime&quot;.</div><br/></div></div><div id="35837088" class="c"><input type="checkbox" id="c-35837088" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#35835684">parent</a><span>|</span><a href="#35837914">prev</a><span>|</span><a href="#35835772">next</a><span>|</span><label class="collapse" for="c-35837088">[-]</label><label class="expand" for="c-35837088">[1 more]</label></div><br/><div class="children"><div class="content">I would only give up static typing to have at least the amount of power that I get using Common Lisp</div><br/></div></div><div id="35835772" class="c"><input type="checkbox" id="c-35835772" checked=""/><div class="controls bullet"><span class="by">syspec</span><span>|</span><a href="#35835684">parent</a><span>|</span><a href="#35837088">prev</a><span>|</span><a href="#35834351">next</a><span>|</span><label class="collapse" for="c-35835772">[-]</label><label class="expand" for="c-35835772">[5 more]</label></div><br/><div class="children"><div class="content">Java honestly provides both, and it does it extremely well! I personally prefer to use Kotlin, but same idea.</div><br/><div id="35836057" class="c"><input type="checkbox" id="c-35836057" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35835772">parent</a><span>|</span><a href="#35835959">next</a><span>|</span><label class="collapse" for="c-35836057">[-]</label><label class="expand" for="c-35836057">[2 more]</label></div><br/><div class="children"><div class="content">Java can do some fairly powerful stuff with reflection and classloaders, but isn&#x27;t anywhere near the level of runtime flexibility you can get with Smalltalk or Ruby where the entire running program is a mutable data structure you can programmatically introspect over and modify.</div><br/><div id="35838869" class="c"><input type="checkbox" id="c-35838869" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35836057">parent</a><span>|</span><a href="#35835959">next</a><span>|</span><label class="collapse" for="c-35838869">[-]</label><label class="expand" for="c-35838869">[1 more]</label></div><br/><div class="children"><div class="content">Well, groovy runs on top of the JVM and can change every method even on an object-level, or even implement how non-defined functions are to be run.</div><br/></div></div></div></div><div id="35835959" class="c"><input type="checkbox" id="c-35835959" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35835772">parent</a><span>|</span><a href="#35836057">prev</a><span>|</span><a href="#35834351">next</a><span>|</span><label class="collapse" for="c-35835959">[-]</label><label class="expand" for="c-35835959">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Java honestly provides both<p>I think there is a serious disconnect about what is &quot;metaprogramming.&quot;</div><br/><div id="35835986" class="c"><input type="checkbox" id="c-35835986" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#35835684">root</a><span>|</span><a href="#35835959">parent</a><span>|</span><a href="#35834351">next</a><span>|</span><label class="collapse" for="c-35835986">[-]</label><label class="expand" for="c-35835986">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I was going to say Haskell does both very well, but that&#x27;s impossible to agree or disagree without first agreeing on a definition for metaprogramming.</div><br/></div></div></div></div></div></div></div></div><div id="35834351" class="c"><input type="checkbox" id="c-35834351" checked=""/><div class="controls bullet"><span class="by">ezekg</span><span>|</span><a href="#35835684">prev</a><span>|</span><a href="#35834090">next</a><span>|</span><label class="collapse" for="c-35834351">[-]</label><label class="expand" for="c-35834351">[4 more]</label></div><br/><div class="children"><div class="content">As a huge proponent of Ruby&#x27;s new pattern matching syntax (it has changed the way I write Ruby), I really, <i>really</i> like the idea of defp. So many times I wish I could overload a method, dispatching by pattern. Instead, I have to pattern match in the method body, which causes the method definition to become convoluted:<p><pre><code>    def for_environment(environment)
      environment =
        case environment
        in String =&gt; code unless code in UUID_RE
          return none # no support for filtering via environment codes
        in UUID_RE =&gt; id
          return none unless env = Environment.find_by(id:)

          env
        in Environment =&gt; env
          env
        in nil
          nil
        end
      
      ...
    end
</code></pre>
I think defp looks and <i>feels</i> very Ruby-like compared to the alternatives (which have the problems you discussed).<p>And Elixir is great, so I can appreciate the inspiration.</div><br/><div id="35838967" class="c"><input type="checkbox" id="c-35838967" checked=""/><div class="controls bullet"><span class="by">ckolkey</span><span>|</span><a href="#35834351">parent</a><span>|</span><a href="#35834817">next</a><span>|</span><label class="collapse" for="c-35838967">[-]</label><label class="expand" for="c-35838967">[1 more]</label></div><br/><div class="children"><div class="content">I completely agree. That really stood out from the article</div><br/></div></div></div></div><div id="35834090" class="c"><input type="checkbox" id="c-35834090" checked=""/><div class="controls bullet"><span class="by">egonschiele</span><span>|</span><a href="#35834351">prev</a><span>|</span><a href="#35834087">next</a><span>|</span><label class="collapse" for="c-35834090">[-]</label><label class="expand" for="c-35834090">[25 more]</label></div><br/><div class="children"><div class="content">I had written a code contracts library for Ruby about 10 years ago [1]. I stopped working on it, mainly because it only provided runtime type checking, and I wanted static type checking. Nowadays my main language is typescript. I miss ruby, but can&#x27;t give up the static typing that typescript provides. I really wish Ruby had a type system with the same level of support. VSCode has phenomenal TS support, and there&#x27;s a community adding types to projects [2]. This is something I&#x27;d like for Ruby also.<p>&gt; An integral part of this informality is relying on Matz’s taste and intuition for everything that affects the language’s core.<p>I think a more defined process would mean a better future for Ruby and Ruby developers.<p>- [1] <a href="https:&#x2F;&#x2F;github.com&#x2F;egonschiele&#x2F;contracts.ruby">https:&#x2F;&#x2F;github.com&#x2F;egonschiele&#x2F;contracts.ruby</a><p>- [2] <a href="https:&#x2F;&#x2F;github.com&#x2F;DefinitelyTyped&#x2F;DefinitelyTyped">https:&#x2F;&#x2F;github.com&#x2F;DefinitelyTyped&#x2F;DefinitelyTyped</a></div><br/><div id="35838947" class="c"><input type="checkbox" id="c-35838947" checked=""/><div class="controls bullet"><span class="by">bilalq</span><span>|</span><a href="#35834090">parent</a><span>|</span><a href="#35834456">next</a><span>|</span><label class="collapse" for="c-35838947">[-]</label><label class="expand" for="c-35838947">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for creating contracts! I used it quite heavily in the past. While the lack of static checking was definitely a pain point, I kind of worked around it by having heavy unit test coverage for invalid types. In some ways, it functioned like a literate programming style for asserts.<p>Nowadays, I almost exclusively write things in TypeScript, and yes, the type system there brings so much peace of mind.<p>Doing a community-driven approach like DefinitelyTyped for third-party libs in Ruby seems like it&#x27;d be much harder than JS. The culture around metaprogramming and complex overloads seems like it&#x27;d be insanely difficult to type.</div><br/></div></div><div id="35834456" class="c"><input type="checkbox" id="c-35834456" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#35834090">parent</a><span>|</span><a href="#35838947">prev</a><span>|</span><a href="#35838502">next</a><span>|</span><label class="collapse" for="c-35834456">[-]</label><label class="expand" for="c-35834456">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it only provided runtime type checking<p>That&#x27;s the big nail in the coffin. Except for RBS and Steep, I don&#x27;t know of any that does&#x2F;did static type checking.<p>And yup, Sorbet&#x27;s static type check is very partial to the point they recommend enabling runtime type checking.<p>Also in its usage, Sorbet needs to _evaluate_ files. Too bad if one of them was a script that included `FileUtils.rm_rf`. Ok I&#x27;m going overboard (maybe?), but Sorbet is not stable in face of code that has side effects when the file contents is evaluated.</div><br/><div id="35835910" class="c"><input type="checkbox" id="c-35835910" checked=""/><div class="controls bullet"><span class="by">eric-hu</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834456">parent</a><span>|</span><a href="#35838502">next</a><span>|</span><label class="collapse" for="c-35835910">[-]</label><label class="expand" for="c-35835910">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also in its usage, Sorbet needs to _evaluate_ files.<p>Are you saying this in the context of static analysis or runtime analysis? I’m pretty sure Sorbet does not need to eval files for static analysis.<p>&gt; Ok I&#x27;m going overboard (maybe?)<p>You are going overboard. I like both TS and Sorbet. Neither type system will protect you from running malicious code on your computer.</div><br/></div></div></div></div><div id="35838502" class="c"><input type="checkbox" id="c-35838502" checked=""/><div class="controls bullet"><span class="by">gsinclair</span><span>|</span><a href="#35834090">parent</a><span>|</span><a href="#35834456">prev</a><span>|</span><a href="#35834104">next</a><span>|</span><label class="collapse" for="c-35838502">[-]</label><label class="expand" for="c-35838502">[1 more]</label></div><br/><div class="children"><div class="content">I still use and love that contracts library, so thank you.
 Sure, it’s not the same as static typing, but for me it’s broadly better. To take a simple example, static typing can’t guarantee an argument is a natural number, as opposed to an (edit: integer).</div><br/></div></div><div id="35834104" class="c"><input type="checkbox" id="c-35834104" checked=""/><div class="controls bullet"><span class="by">parthdesai</span><span>|</span><a href="#35834090">parent</a><span>|</span><a href="#35838502">prev</a><span>|</span><a href="#35834254">next</a><span>|</span><label class="collapse" for="c-35834104">[-]</label><label class="expand" for="c-35834104">[7 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;sorbet.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sorbet.org&#x2F;</a> ?</div><br/><div id="35834212" class="c"><input type="checkbox" id="c-35834212" checked=""/><div class="controls bullet"><span class="by">egonschiele</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834104">parent</a><span>|</span><a href="#35834254">next</a><span>|</span><label class="collapse" for="c-35834212">[-]</label><label class="expand" for="c-35834212">[6 more]</label></div><br/><div class="children"><div class="content">So many JS projects are switching to TS, but AFAIK the same isn&#x27;t happening within Ruby, which reduces some of the type-checking benefit.<p>Also, this is subjective but I don&#x27;t like the syntax.<p>&gt; Sorbet is 100% compatible with Ruby. It type checks normal method definitions, and introduces backwards-compatible syntax for method signatures.<p>I would have preferred if they had introduced a compile step the way typescript does, and provided a TS-like syntax. I find the current version hard to read.</div><br/><div id="35834297" class="c"><input type="checkbox" id="c-35834297" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834212">parent</a><span>|</span><a href="#35835585">next</a><span>|</span><label class="collapse" for="c-35834297">[-]</label><label class="expand" for="c-35834297">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So many JS projects are switching to TS, but AFAIK the same isn&#x27;t happening within Ruby<p>The sheer propagation of JS might have something to do with the big push to have some kind of typing. From my own experience, if I see ruby I know I can either re-write it or find an alternative in TS&#x2F;JS.<p>The ubiquity of JS makes it more accessible, but I&#x27;m still trying to find reasons why one would choose Ruby.. I&#x27;m always a &#x27;right tool for the job&#x27; but I don&#x27;t know what the niche is.<p>Edit : My pedant in me :<p>&gt; compile step the way typescript doe<p>Typescript transpiles to JS. I don&#x27;t &#x27;believe&#x27; there is a compilation step.</div><br/><div id="35835645" class="c"><input type="checkbox" id="c-35835645" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834297">parent</a><span>|</span><a href="#35835585">next</a><span>|</span><label class="collapse" for="c-35835645">[-]</label><label class="expand" for="c-35835645">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; compile step the way typescript [does]<p>&gt; Typescript transpiles to JS. I don&#x27;t &#x27;believe&#x27; there is a compilation step.<p>This is a common misconception. Transpiling is not something distinct from compiling. &quot;Transpiler&quot; is just a trendy name for a certain subset of compilers. Just because it compiles to another &quot;high level&quot; language doesn&#x27;t mean it&#x27;s not a compiler.<p>Every &quot;transpiler&quot; <i>is</i> a compiler.<p>Sources:<p>On BIX in the 1980s, when the only implementation of C++ was Cfront, which translated to C, I asked Bjarne Stroustrup if it was a preprocessor. He told me quite emphatically, &quot;No, Cfront is a <i>compiler</i>.&quot; (I don&#x27;t think the term &quot;transpiler&quot; was in common use at that time.)<p>The Wikipedia article on Cfront agrees:<p>&gt; <i>Cfront was the original compiler for C++ (then known as &quot;C with Classes&quot;) from around 1983, which converted C++ to C</i><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cfront" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cfront</a><p>More recently, and relevant to this discussion, the TypeScript team specifically calls <i>tsc</i> a compiler:<p>&gt; <i>Let’s get acquainted with our new friend tsc, the TypeScript compiler.</i><p><a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;basic-types.html#tsc-the-typescript-compiler" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;basic-types.h...</a><p>In fact, if you search that page for &quot;pil&quot;, you will find nine references to &quot;compile&quot; and none for &quot;transpile&quot;.</div><br/></div></div></div></div><div id="35835585" class="c"><input type="checkbox" id="c-35835585" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834212">parent</a><span>|</span><a href="#35834297">prev</a><span>|</span><a href="#35836088">next</a><span>|</span><label class="collapse" for="c-35835585">[-]</label><label class="expand" for="c-35835585">[2 more]</label></div><br/><div class="children"><div class="content">TS has a way to attach type annotations (.d.ts files) on top of existing JS code base, thus allowing for gradual migration and relatively peaceful coexistence. Same with Python: you can add type definitions on top of existing untyped code, as a separate package. In either case, types can be provided by a third party, e.g. yourself if you want to use a particular library and it still lacks typing support.<p>Does Sorbet offer something comparable? That would make adoption easier.</div><br/><div id="35835693" class="c"><input type="checkbox" id="c-35835693" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35835585">parent</a><span>|</span><a href="#35836088">next</a><span>|</span><label class="collapse" for="c-35835693">[-]</label><label class="expand" for="c-35835693">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does Sorbet offer something comparable?<p>Yes, RBI files.</div><br/></div></div></div></div><div id="35836088" class="c"><input type="checkbox" id="c-35836088" checked=""/><div class="controls bullet"><span class="by">whakim</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834212">parent</a><span>|</span><a href="#35835585">prev</a><span>|</span><a href="#35834254">next</a><span>|</span><label class="collapse" for="c-35836088">[-]</label><label class="expand" for="c-35836088">[1 more]</label></div><br/><div class="children"><div class="content">The problem (as TFA points out) is that most of the available options (including &quot;a TS-like syntax&quot;) are already valid Ruby code.<p>I do agree with your first point that the lack of adoption of Sorbet among library maintainers negates some of the benefit of the type system (compared to TS). Seeing all those `T.untyped`&#x27;s in generated RBI files is a little scary :D.</div><br/></div></div></div></div></div></div><div id="35834254" class="c"><input type="checkbox" id="c-35834254" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#35834090">parent</a><span>|</span><a href="#35834104">prev</a><span>|</span><a href="#35834087">next</a><span>|</span><label class="collapse" for="c-35834254">[-]</label><label class="expand" for="c-35834254">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m genuinely curious, why do you miss Ruby, or why would you prefer it overall over TS ?<p>When I was playing around with ruby for any significant sized projects, I found it became unmaintainable. Granted I was most definitely using it wrong, but apart from that, I didn&#x27;t see the appeal.</div><br/><div id="35834799" class="c"><input type="checkbox" id="c-35834799" checked=""/><div class="controls bullet"><span class="by">ncphillips</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834254">parent</a><span>|</span><a href="#35834736">next</a><span>|</span><label class="collapse" for="c-35834799">[-]</label><label class="expand" for="c-35834799">[9 more]</label></div><br/><div class="children"><div class="content">I used to hate Ruby.<p>Last year I spent 10 months alone on a Rails app. I decided to buy in. Do things the Ruby&#x2F;Rails way. Read books on how to think about OO in Ruby. TDD everything.<p>I can’t quite say what changed. But now Ruby is my favourite language.<p>It is almost encourages you to write clean code but it doesn’t force you to. It lets you make mistakes. It treats you like a grown up.<p>TS, Java, etc. They treat you like a child who can’t be trusted to do things right.<p>Yes, this means you can end up with some horrifying god awful Ruby code. But it also means you can end up with some truly beautiful abstractions.<p>I think the very things that prevent you from creating unmaintainable messes are the things that prevent you from writing incredible pieces of software.<p>That’s probably why they miss Ruby</div><br/><div id="35834876" class="c"><input type="checkbox" id="c-35834876" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834799">parent</a><span>|</span><a href="#35838296">next</a><span>|</span><label class="collapse" for="c-35834876">[-]</label><label class="expand" for="c-35834876">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mean to pick on your comment specifically, but I really dislike the notion that someone who appreciates, prefers, or relies on static types and a more strict compiler or toolchain is somehow not a grown-up.<p>[Edit]: Added a missing word</div><br/><div id="35835478" class="c"><input type="checkbox" id="c-35835478" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834876">parent</a><span>|</span><a href="#35837085">next</a><span>|</span><label class="collapse" for="c-35835478">[-]</label><label class="expand" for="c-35835478">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know that that’s GP’s assertion at all.<p>I feel similarly re: Java and Ruby. But I also love Rust which relies on static types and one of the strictest compilers in existence.<p>But there’s something I can’t quite put my finger on where—yeah—Java and Golang (in my mind) force me into a boxed-in world where I’m not trusted to make good decisions about abstractions, but Rust and Ruby encourage me to do so.</div><br/></div></div><div id="35837085" class="c"><input type="checkbox" id="c-35837085" checked=""/><div class="controls bullet"><span class="by">ncphillips</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834876">parent</a><span>|</span><a href="#35835478">prev</a><span>|</span><a href="#35838080">next</a><span>|</span><label class="collapse" for="c-35837085">[-]</label><label class="expand" for="c-35837085">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I totally get that. Not really the best framing.<p>A slightly better framing is they  languages within stricter static types put up guardrails. They’re meant to keep you safe. Sometimes they also make it hard for you from going where you want to go.<p>Don’t get me wrong i like static languages too. TS is one of my favourites. My time with Java was good. Just trying to give a different perspective on Ruby</div><br/></div></div><div id="35838080" class="c"><input type="checkbox" id="c-35838080" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834876">parent</a><span>|</span><a href="#35837085">prev</a><span>|</span><a href="#35838296">next</a><span>|</span><label class="collapse" for="c-35838080">[-]</label><label class="expand" for="c-35838080">[1 more]</label></div><br/><div class="children"><div class="content">Whether you ‘are a grown up’ is a completely separate thing from whether you are being <i>treated</i> like a grown up.</div><br/></div></div></div></div><div id="35838296" class="c"><input type="checkbox" id="c-35838296" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834799">parent</a><span>|</span><a href="#35834876">prev</a><span>|</span><a href="#35837006">next</a><span>|</span><label class="collapse" for="c-35838296">[-]</label><label class="expand" for="c-35838296">[1 more]</label></div><br/><div class="children"><div class="content">&gt; TS, Java, etc. They treat you like a child who can’t be trusted to do things right.<p>This is totally Java, but TypeScript? Practically every error can be turned off in the config or in a comment, and the type system is a veritable arsenal of powerful footguns.</div><br/></div></div><div id="35837006" class="c"><input type="checkbox" id="c-35837006" checked=""/><div class="controls bullet"><span class="by">VagueMag</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834799">parent</a><span>|</span><a href="#35838296">prev</a><span>|</span><a href="#35836233">next</a><span>|</span><label class="collapse" for="c-35837006">[-]</label><label class="expand" for="c-35837006">[2 more]</label></div><br/><div class="children"><div class="content">Any chance I could ask for books you found especially useful in Ruby buy-in?</div><br/><div id="35837056" class="c"><input type="checkbox" id="c-35837056" checked=""/><div class="controls bullet"><span class="by">ncphillips</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35837006">parent</a><span>|</span><a href="#35836233">next</a><span>|</span><label class="collapse" for="c-35837056">[-]</label><label class="expand" for="c-35837056">[1 more]</label></div><br/><div class="children"><div class="content">Sandi Metz and Avdi Grimm are the people I mostly read.<p>Practical Object Oriented Design in Ruby by Sandi. She has a lot of great talks on YouTube as well.</div><br/></div></div></div></div><div id="35836233" class="c"><input type="checkbox" id="c-35836233" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834799">parent</a><span>|</span><a href="#35837006">prev</a><span>|</span><a href="#35834736">next</a><span>|</span><label class="collapse" for="c-35836233">[-]</label><label class="expand" for="c-35836233">[1 more]</label></div><br/><div class="children"><div class="content">This is 100% me</div><br/></div></div></div></div><div id="35834736" class="c"><input type="checkbox" id="c-35834736" checked=""/><div class="controls bullet"><span class="by">izietto</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834254">parent</a><span>|</span><a href="#35834799">prev</a><span>|</span><a href="#35835485">next</a><span>|</span><label class="collapse" for="c-35834736">[-]</label><label class="expand" for="c-35834736">[2 more]</label></div><br/><div class="children"><div class="content">My two cents:<p>1. 2. 3. 4. 5. standard library<p>6. consistency with OOP *<p>7. &quot;everything is English language&quot;. I find good Ruby readable just like books **<p>* Ruby is the best translation of &quot;everything is an object&quot; imho<p>** evil Ruby is the Perl side of the moon, but it&#x27;s easy to ignore it<p>&gt; When I was playing around with ruby for any significant sized projects, I found it became unmaintainable<p>Ruby requires tons of discipline, as it has obscure meta-programming powers that are meant to be used for DSL libraries, while usually Ruby beginners spam them understating their make your codebase unmaintainable.</div><br/><div id="35835526" class="c"><input type="checkbox" id="c-35835526" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834736">parent</a><span>|</span><a href="#35835485">next</a><span>|</span><label class="collapse" for="c-35835526">[-]</label><label class="expand" for="c-35835526">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Ruby is the epitome of “with great power comes great responsibility”.<p>I have inarguably written some of the absolutely most elegant solutions of my entire career in it. But without good discipline, experience, and understanding you can absolutely make a horrifying mess of unrivaled proportion.<p>Unfortunately when you work on real world projects where most devs are relatively junior (or otherwise inexperienced with Ruby) or on projects where there have been multiple cooks who didn’t necessarily share the same underlying mindset about the project, you end up with more of the latter than the former.<p>But for small, consistent teams of experienced Ruby engineers? It can be incredible.</div><br/></div></div></div></div><div id="35835485" class="c"><input type="checkbox" id="c-35835485" checked=""/><div class="controls bullet"><span class="by">egonschiele</span><span>|</span><a href="#35834090">root</a><span>|</span><a href="#35834254">parent</a><span>|</span><a href="#35834736">prev</a><span>|</span><a href="#35834087">next</a><span>|</span><label class="collapse" for="c-35835485">[-]</label><label class="expand" for="c-35835485">[1 more]</label></div><br/><div class="children"><div class="content">One reason is blocks. I wish other languages had blocks. Swift has them, and it means you can write some very readable DSLs. Tbh I&#x27;m happy with Typescript, but Ruby was my language of choice for years.</div><br/></div></div></div></div></div></div><div id="35834087" class="c"><input type="checkbox" id="c-35834087" checked=""/><div class="controls bullet"><span class="by">uticus</span><span>|</span><a href="#35834090">prev</a><span>|</span><a href="#35834022">next</a><span>|</span><label class="collapse" for="c-35834087">[-]</label><label class="expand" for="c-35834087">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In my OSS and blogging activities, I am mostly focused on the same concepts: Ruby intuitions and lucid code...the main question is always “how the language leads us to express this in the clearest way possible.”<p>Unfortunately this article itself needs some editing. I stuck through to the end, but it was not enjoyably lucid.<p>&gt; I honestly tried to perform it alongside the reader: since the early drafts of the article, my expectations were that I’d come up with some coherent idea about a possible Ruby typing syntax. My attempt resulted in a deeper understanding of the level of design complexity making it hardly achievable.<p>Plus one for trying it out, I guess. The temptation is there, because Ruby is so flexible. &quot;It works so well for DSLs, maybe it can be expanded to include typing!&quot; The trouble is, the added syntax rules to support typing will never stay in the sweet spot between &quot;enough in the foreground to assist coding&quot; and &quot;enough in the background to not distract from the coding flow.&quot; You either live without it, as in Ruby, or learn to mentally parse over it, as in other languages with the Func(String s, Int i) syntax.<p>For myself, I&#x27;m fine with the typing being in a separate .rbs file. Especially if my IDE supports it well.</div><br/><div id="35835692" class="c"><input type="checkbox" id="c-35835692" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#35834087">parent</a><span>|</span><a href="#35834325">next</a><span>|</span><label class="collapse" for="c-35835692">[-]</label><label class="expand" for="c-35835692">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>this article itself needs some editing.</i><p>Possibly! But likely the reason is this:<p>&gt; <i>I am writing this on my phone, in a barrack that houses some 200+ of my brothers-in-arms in the Ukrainian army’s training camp; I use short periods of rest between training, mostly at night and on Sundays.</i><p>I won&#x27;t expect a lot of text-polishing opportunities in conditions like that. I&#x27;d be grateful for any coherent and insightful output, like the article.</div><br/></div></div><div id="35834325" class="c"><input type="checkbox" id="c-35834325" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#35834087">parent</a><span>|</span><a href="#35835692">prev</a><span>|</span><a href="#35836171">next</a><span>|</span><label class="collapse" for="c-35834325">[-]</label><label class="expand" for="c-35834325">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For myself, I&#x27;m fine with the typing being in a separate .rbs file<p>We type[0] by having one separate .rbs file per .rb file. Works really well with an editor&#x27;s vertical splits: type outline on one side, code on the other. That, or use something like vim-projectionist[1].<p>We have a static typing guide for contributors[2], and I&#x27;m also accreting common errors and issues behind the scenes to produce a &#x27;rbs+steep by example&#x27; to ease folks in.<p>[0]: (WIP: there&#x27;s a huge codebase to type, but we&#x27;re progressively getting there) <a href="https:&#x2F;&#x2F;github.com&#x2F;DataDog&#x2F;dd-trace-rb&#x2F;tree&#x2F;master&#x2F;sig">https:&#x2F;&#x2F;github.com&#x2F;DataDog&#x2F;dd-trace-rb&#x2F;tree&#x2F;master&#x2F;sig</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-projectionist">https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-projectionist</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;DataDog&#x2F;dd-trace-rb&#x2F;blob&#x2F;master&#x2F;docs&#x2F;StaticTypingGuide.md">https:&#x2F;&#x2F;github.com&#x2F;DataDog&#x2F;dd-trace-rb&#x2F;blob&#x2F;master&#x2F;docs&#x2F;Stat...</a></div><br/></div></div><div id="35836171" class="c"><input type="checkbox" id="c-35836171" checked=""/><div class="controls bullet"><span class="by">anon84873628</span><span>|</span><a href="#35834087">parent</a><span>|</span><a href="#35834325">prev</a><span>|</span><a href="#35834022">next</a><span>|</span><label class="collapse" for="c-35836171">[-]</label><label class="expand" for="c-35836171">[1 more]</label></div><br/><div class="children"><div class="content">Well the author did caveat that he wrote the post in between military training in Ukraine, so I&#x27;m willing to give a pass on the copyediting.</div><br/></div></div></div></div><div id="35834022" class="c"><input type="checkbox" id="c-35834022" checked=""/><div class="controls bullet"><span class="by">mbell</span><span>|</span><a href="#35834087">prev</a><span>|</span><a href="#35836230">next</a><span>|</span><label class="collapse" for="c-35834022">[-]</label><label class="expand" for="c-35834022">[1 more]</label></div><br/><div class="children"><div class="content">The biggest issue with current attempts at typing in Ruby is the choice of a nominal type system. If there ever was a language that called for structural typing, it&#x27;s Ruby.</div><br/></div></div><div id="35836230" class="c"><input type="checkbox" id="c-35836230" checked=""/><div class="controls bullet"><span class="by">nickjj</span><span>|</span><a href="#35834022">prev</a><span>|</span><a href="#35838686">next</a><span>|</span><label class="collapse" for="c-35836230">[-]</label><label class="expand" for="c-35836230">[4 more]</label></div><br/><div class="children"><div class="content">Does anyone else prefer the Ruby typed parameter syntax over the Python one even though the author says it would likely be rejected by Rubyists? Here&#x27;s an example from the post:<p><pre><code>    # Python&#x27;s current type hints

    def readlines(name: str, chomp: bool = False):
</code></pre>
vs<p><pre><code>    # Ruby&#x27;s potentially valid type hints that don&#x27;t exist today

    def readlines(String name, Boolean chomp: false)

</code></pre>
I know with Ruby you often want to put more important things first, because it deserves to be the center of attention but in the above case I think the 2nd one is so much more readable at a glance. There&#x27;s less syntactic noise with the Ruby example because it avoids the equals sign and excess colons. You could also make a case when calling a function both the type and name of the param itself are really important. If you think of this as a user experience exercise, someone calling your function is the user. As a user I very much like the idea of knowing what I need to pass in and &quot;what I need to pass in&quot; is a combination of a descriptive name and potential type.<p>At a fundamental level, imperative or partially imperative languages are nice because you can typically build upon what you know to do new things in incremental steps.<p>For example if you know how to make a variable and a loop you can combine your knowledge to make a nested loop and mutate a variable without learning any new concepts.<p>The Ruby example feels like you&#x27;re incrementally adding something new. I don&#x27;t really need to learn anything new to understand I&#x27;m adding types. It&#x27;s also very clean looking. The Python one looks like a different language. I mean, I know both Python and Ruby and use them regularly but `chomp: bool = False` just looks icky to me. It&#x27;s like some weird hybrid Python &#x2F; Ruby combo and takes a few seconds to understand.</div><br/><div id="35836808" class="c"><input type="checkbox" id="c-35836808" checked=""/><div class="controls bullet"><span class="by">eric-hu</span><span>|</span><a href="#35836230">parent</a><span>|</span><a href="#35836317">next</a><span>|</span><label class="collapse" for="c-35836808">[-]</label><label class="expand" for="c-35836808">[1 more]</label></div><br/><div class="children"><div class="content">The Ruby example you gave looks good for these simple cases. I feel like this could break down for more complex cases though. What about generic types? Or what Sorbet calls Shapes (e.g. the input type is a hash with 2 specific keys -- stuff like this is typical with JSON ingestion in TS).</div><br/></div></div><div id="35836317" class="c"><input type="checkbox" id="c-35836317" checked=""/><div class="controls bullet"><span class="by">jaxn</span><span>|</span><a href="#35836230">parent</a><span>|</span><a href="#35836808">prev</a><span>|</span><a href="#35838686">next</a><span>|</span><label class="collapse" for="c-35836317">[-]</label><label class="expand" for="c-35836317">[2 more]</label></div><br/><div class="children"><div class="content">In Ruby, I would see your example as name having the value str. Chomp would have the value of the result of the  operation assigning bool the value of False, which I result of the operation might be true, so would chomp have the value of true? Either way, it looks like an assignment instead of comparison error, so I’d kick it back in a PR no matter how it worked.</div><br/><div id="35836368" class="c"><input type="checkbox" id="c-35836368" checked=""/><div class="controls bullet"><span class="by">caseyohara</span><span>|</span><a href="#35836230">root</a><span>|</span><a href="#35836317">parent</a><span>|</span><a href="#35838686">next</a><span>|</span><label class="collapse" for="c-35836368">[-]</label><label class="expand" for="c-35836368">[1 more]</label></div><br/><div class="children"><div class="content">I think you confused the examples, the first one is Python.</div><br/></div></div></div></div></div></div><div id="35838686" class="c"><input type="checkbox" id="c-35838686" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#35836230">prev</a><span>|</span><a href="#35833256">next</a><span>|</span><label class="collapse" for="c-35838686">[-]</label><label class="expand" for="c-35838686">[3 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t they just use `foo :: String`?</div><br/><div id="35839189" class="c"><input type="checkbox" id="c-35839189" checked=""/><div class="controls bullet"><span class="by">grncdr</span><span>|</span><a href="#35838686">parent</a><span>|</span><a href="#35833256">next</a><span>|</span><label class="collapse" for="c-35839189">[-]</label><label class="expand" for="c-35839189">[2 more]</label></div><br/><div class="children"><div class="content">That’s already valid syntax meaning  “resolve the String constant starting at foo”</div><br/><div id="35839381" class="c"><input type="checkbox" id="c-35839381" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#35838686">root</a><span>|</span><a href="#35839189">parent</a><span>|</span><a href="#35833256">next</a><span>|</span><label class="collapse" for="c-35839381">[-]</label><label class="expand" for="c-35839381">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you&#x27;re right.<p>The more you think about it the less arguments there are for &quot;just use Crystal&quot;.</div><br/></div></div></div></div></div></div><div id="35833256" class="c"><input type="checkbox" id="c-35833256" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#35838686">prev</a><span>|</span><a href="#35833804">next</a><span>|</span><label class="collapse" for="c-35833256">[-]</label><label class="expand" for="c-35833256">[9 more]</label></div><br/><div class="children"><div class="content">I am not convinced of the utility of how good type annotations are in the long term.<p>I think static typing is a very fundamental part of language design that affects the entire language. To make static typing ergonomic without massive boilerplate, you also need concepts like generics, co and contra-variance, type inference, and other things that dynamically typed languages never have to really concern themselves with.<p>When you try to bolt it on afterwards, I think you can end up with a lot of foot guns and corner cases and a false sense of security.</div><br/><div id="35834261" class="c"><input type="checkbox" id="c-35834261" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#35833256">parent</a><span>|</span><a href="#35834093">next</a><span>|</span><label class="collapse" for="c-35834261">[-]</label><label class="expand" for="c-35834261">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am not convinced of the utility of how good type annotations are in the long term.<p>Anecdata: adding typing (via Sorbet, then RBS) to multiple projects over the years uncovered many corner case (and not-so-corner case but non obvious) bugs, some subtle but critical, before they ended up crashing production.<p>I can vouch with real life experience that it is useful. RBS+Steep is so useful I inadvertently found myself† beginning to write type-first, describing my code in .rbs files then filling in the implementation. Thinking in types has helped me uncovered issues right at the idea stage when I could have produced a smart^Wfatally flawed implementation that would still work thanks to Ruby&#x27;s dynamism (mind you, Ruby&#x27;s dynamism is great, it is merely a tool to be wielded at appropriate times)<p>† Which is kinda useful as a &quot;ok this thing works&quot; rule of thumb in my book</div><br/></div></div><div id="35834093" class="c"><input type="checkbox" id="c-35834093" checked=""/><div class="controls bullet"><span class="by">itake</span><span>|</span><a href="#35833256">parent</a><span>|</span><a href="#35834261">prev</a><span>|</span><a href="#35834852">next</a><span>|</span><label class="collapse" for="c-35834093">[-]</label><label class="expand" for="c-35834093">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked in multiple systems written in python, ruby, and JS where an untyped dict|hash|object is passed from function to function. In each function, keys are read; keys are written; keys are deleted. Tracking params were actually called by each function was a nightmare.<p>If this &quot;magic&quot; dictionary was sourced from a schemeless api or database, it was impossible to figure out the schema of this dict without running the code in production.</div><br/></div></div><div id="35834852" class="c"><input type="checkbox" id="c-35834852" checked=""/><div class="controls bullet"><span class="by">akavi</span><span>|</span><a href="#35833256">parent</a><span>|</span><a href="#35834093">prev</a><span>|</span><a href="#35833395">next</a><span>|</span><label class="collapse" for="c-35834852">[-]</label><label class="expand" for="c-35834852">[3 more]</label></div><br/><div class="children"><div class="content">Have you used typescript? Because to my eyes, that&#x27;s a <i>massively</i> successful &quot;bolted on&quot; type system.<p>Sure there&#x27;re holes in the system, but the utility is significant, especially relative to the cost.</div><br/><div id="35837643" class="c"><input type="checkbox" id="c-35837643" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#35833256">root</a><span>|</span><a href="#35834852">parent</a><span>|</span><a href="#35833395">next</a><span>|</span><label class="collapse" for="c-35837643">[-]</label><label class="expand" for="c-35837643">[2 more]</label></div><br/><div class="children"><div class="content">Typescript is more successful by the numbers than almost all “native” typed languages</div><br/><div id="35839039" class="c"><input type="checkbox" id="c-35839039" checked=""/><div class="controls bullet"><span class="by">bilalq</span><span>|</span><a href="#35833256">root</a><span>|</span><a href="#35837643">parent</a><span>|</span><a href="#35833395">next</a><span>|</span><label class="collapse" for="c-35839039">[-]</label><label class="expand" for="c-35839039">[1 more]</label></div><br/><div class="children"><div class="content">Not just more successful in terms of adoption, but safer even than many &quot;native&quot; typed languages. You can never really tell if a random method in Java can return null without reading through its source and the transitive source of anything it may potentially call. And with dynamic dispatch, this becomes literally impossible. That Java virus of null contaminates other JVM languages like Scala too. It&#x27;s even worse because you can have Option types that are themselves potentially nullable. Some&#x2F;None&#x2F;null is a terrible situation to be stuck in.<p>And then the expressiveness of the type system there is also really pragmatic. You can&#x27;t natively express union types in Java and many other static languages without writing your own Either monad implementation. Instead, you often wind up with code that has objects with a hodge-podge of field sets that are nullable.<p>It&#x27;s nothing short of miraculous how well the null-safety situation is in TypeScript. It&#x27;s built on the back of community-driven types in DefinitelyTyped where the maintainers of libs often aren&#x27;t the ones writing and keeping types up to date. Nowadays, types are becoming more and more first-party, but it still amazes me how we got to this point.</div><br/></div></div></div></div></div></div><div id="35833395" class="c"><input type="checkbox" id="c-35833395" checked=""/><div class="controls bullet"><span class="by">LesZedCB</span><span>|</span><a href="#35833256">parent</a><span>|</span><a href="#35834852">prev</a><span>|</span><a href="#35836831">next</a><span>|</span><label class="collapse" for="c-35833395">[-]</label><label class="expand" for="c-35833395">[1 more]</label></div><br/><div class="children"><div class="content">i personally really like the idea of what clojure has done with spec or malli instead of type annotations. it just <i>feels</i> to me more like what rubyists want: pragmatic validation of &quot;does this quack?&quot; but like you say, i&#x27;m not sure ergonomics can be brought up to the level of ease&#x2F;happiness to be used regularly</div><br/></div></div><div id="35836831" class="c"><input type="checkbox" id="c-35836831" checked=""/><div class="controls bullet"><span class="by">eric-hu</span><span>|</span><a href="#35833256">parent</a><span>|</span><a href="#35833395">prev</a><span>|</span><a href="#35835902">next</a><span>|</span><label class="collapse" for="c-35836831">[-]</label><label class="expand" for="c-35836831">[1 more]</label></div><br/><div class="children"><div class="content">The author speaks to this in the blog post too.<p>&gt; The “this can be typed, this can’t” approach would most probably lead to a schism unseen before: splitting of the community into those who prefer type-annotated code and consequently became reluctant to any of the most expressive and dynamic features—and everyone else.<p>I&#x27;m an active user of Sorbet at work, and I can see this happening even with my own opinions. On the one hand, I don&#x27;t want to see the Ruby ecosystem fractured more, but on the other, I&#x27;ve seen clear benefits from helping add static typing to my team&#x27;s project. I didn&#x27;t really know much about Steep at the time, so I pushed for Sorbet. My first preference was actually Ruby 3 types, but when I looked into implementing them, I found they provided much weaker guarantees than Sorbet. The tooling also wasn&#x27;t there.</div><br/></div></div><div id="35835902" class="c"><input type="checkbox" id="c-35835902" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#35833256">parent</a><span>|</span><a href="#35836831">prev</a><span>|</span><a href="#35833804">next</a><span>|</span><label class="collapse" for="c-35835902">[-]</label><label class="expand" for="c-35835902">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I just duplicated a Go method because it wouldn&#x27;t accept a typed vararg as  untyped (...any), and methods can&#x27;t be generic either. I would rather not have static types at all than a not-quite-complete type system. I find Common Lisp&#x27;s gradual approach to types very convenient.</div><br/></div></div></div></div><div id="35833804" class="c"><input type="checkbox" id="c-35833804" checked=""/><div class="controls bullet"><span class="by">hhthrowaway1230</span><span>|</span><a href="#35833256">prev</a><span>|</span><a href="#35835723">next</a><span>|</span><label class="collapse" for="c-35833804">[-]</label><label class="expand" for="c-35833804">[3 more]</label></div><br/><div class="children"><div class="content">Ruby needs opt-in inline typing. Much like python. Typing is a language or dsl of what u expect to receive as input and as output. Its a communication mechanism. Leaving out ambigiousness. the job for ruby is to make it not a hassle but a joy to use.</div><br/><div id="35834392" class="c"><input type="checkbox" id="c-35834392" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#35833804">parent</a><span>|</span><a href="#35834512">next</a><span>|</span><label class="collapse" for="c-35834392">[-]</label><label class="expand" for="c-35834392">[1 more]</label></div><br/><div class="children"><div class="content">I disagree with inline. It obscures the code, especially with a language as terse as Ruby. That&#x27;s a code editor job to present me with types appropriately within its UI (which may be tooltips, autocompletion, virtual text that looks like comments or annotations†...)<p>Having types in separate .rbs files has proven to me to be perfectly usable, and in fact better in many ways.<p>Sorbet&#x27;s DSL of having `sig { }` present is the worst kind of annotation, as it needs to pollute `Kernel` with `#sig`, even when you disable runtime checking.<p>This is a no-go if you develop anything else than an app (e.g a gem) as you certainly don&#x27;t want to push Sorbet†† as a dependency to your gem consumers, not the least because `sorbet-static`†† is still only available for `x86_64`. In general Sorbet seems to be designed to type apps, gems being an afterthought.<p>† <a href="https:&#x2F;&#x2F;github.com&#x2F;jubnzv&#x2F;virtual-types.nvim">https:&#x2F;&#x2F;github.com&#x2F;jubnzv&#x2F;virtual-types.nvim</a><p>†† or include a monkyepatch that defines an empty `Kernel#sig`<p>†† <a href="https:&#x2F;&#x2F;rubygems.org&#x2F;gems&#x2F;sorbet-static" rel="nofollow">https:&#x2F;&#x2F;rubygems.org&#x2F;gems&#x2F;sorbet-static</a></div><br/></div></div><div id="35834512" class="c"><input type="checkbox" id="c-35834512" checked=""/><div class="controls bullet"><span class="by">ezekg</span><span>|</span><a href="#35833804">parent</a><span>|</span><a href="#35834392">prev</a><span>|</span><a href="#35835723">next</a><span>|</span><label class="collapse" for="c-35834512">[-]</label><label class="expand" for="c-35834512">[1 more]</label></div><br/><div class="children"><div class="content">Did you read the article? It discusses this topic and how it&#x27;s a hard problem in Ruby vs. Python due to Ruby&#x27;s syntax choices.</div><br/></div></div></div></div><div id="35835723" class="c"><input type="checkbox" id="c-35835723" checked=""/><div class="controls bullet"><span class="by">ecshafer</span><span>|</span><a href="#35833804">prev</a><span>|</span><a href="#35833905">next</a><span>|</span><label class="collapse" for="c-35835723">[-]</label><label class="expand" for="c-35835723">[2 more]</label></div><br/><div class="children"><div class="content">I do not like Sorbet, and I don&#x27;t think ruby&#x27;s type annotation is in a great spot. The claims of Sorbet to allow easy refactoring are just not there imo, and do not reach the level of Java. Sorbet if anything involves more time fighting sorbet, and you still rely on tests for validation. Steep looks better, but I think it needs to be brought in file.<p>Personally if we do bring types, I would like to see an optional typescript like definition<p>def foo(:String x) -&gt; String<p>or similar.</div><br/><div id="35838149" class="c"><input type="checkbox" id="c-35838149" checked=""/><div class="controls bullet"><span class="by">whakim</span><span>|</span><a href="#35835723">parent</a><span>|</span><a href="#35833905">next</a><span>|</span><label class="collapse" for="c-35838149">[-]</label><label class="expand" for="c-35838149">[1 more]</label></div><br/><div class="children"><div class="content">The article does a good job explaining why Typescript-like type annotations won&#x27;t work (unless you only allow them in method definitions): most TS-like syntax is already valid Ruby code in one way or another.<p>That aside, I&#x27;m curious where specifically you found Sorbet lacking?</div><br/></div></div></div></div><div id="35833905" class="c"><input type="checkbox" id="c-35833905" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#35835723">prev</a><span>|</span><a href="#35839098">next</a><span>|</span><label class="collapse" for="c-35833905">[-]</label><label class="expand" for="c-35833905">[1 more]</label></div><br/><div class="children"><div class="content">Took me a bit thinking through it all, but I arrived at the same place as the author in the end - use the pattern matching system, and if the types don&#x27;t match then the block you&#x27;re dispatched to just raises an error. The rest is just finding a satisfying syntax.</div><br/></div></div><div id="35839098" class="c"><input type="checkbox" id="c-35839098" checked=""/><div class="controls bullet"><span class="by">transfire</span><span>|</span><a href="#35833905">prev</a><span>|</span><a href="#35833651">next</a><span>|</span><label class="collapse" for="c-35839098">[-]</label><label class="expand" for="c-35839098">[1 more]</label></div><br/><div class="children"><div class="content">As in Elixir&#x2F;Erlang it would nice if they could be define separately.<p><pre><code>    def [] in Integer =&gt; index
      # ...
    end

    def [] in Integer =&gt; start, Integer =&gt; length
      # ...
    end

    def [] in Range =&gt; range
      # ...
    end</code></pre></div><br/></div></div><div id="35833651" class="c"><input type="checkbox" id="c-35833651" checked=""/><div class="controls bullet"><span class="by">al2o3cr</span><span>|</span><a href="#35839098">prev</a><span>|</span><a href="#35834572">next</a><span>|</span><label class="collapse" for="c-35833651">[-]</label><label class="expand" for="c-35833651">[1 more]</label></div><br/><div class="children"><div class="content">An observation about the discussion immediately under &quot;In fact, we in Ruby have several incomplete systems of type-annotations-in-disguise&quot; - to me, that list indicates that fitting all those things into a SINGLE type system is a huge challenge. The spaces of <i>possible</i> types for a JSON API, an ORM, and an interactor&#x27;s inputs are all different.</div><br/></div></div><div id="35834572" class="c"><input type="checkbox" id="c-35834572" checked=""/><div class="controls bullet"><span class="by">sproketboy</span><span>|</span><a href="#35833651">prev</a><span>|</span><label class="collapse" for="c-35834572">[-]</label><label class="expand" for="c-35834572">[1 more]</label></div><br/><div class="children"><div class="content">Adding types after the fact is never going to work out well.</div><br/></div></div></div></div></div></div></div></body></html>