<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715072455713" as="style"/><link rel="stylesheet" href="styles.css?v=1715072455713"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://eli.thegreenplace.net/2019/faster-xml-stream-processing-in-go/">Faster XML Stream Processing in Go (2019)</a>Â <span class="domain">(<a href="https://eli.thegreenplace.net">eli.thegreenplace.net</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>15 comments</span></div><br/><div><div id="40281148" class="c"><input type="checkbox" id="c-40281148" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#40281754">next</a><span>|</span><label class="collapse" for="c-40281148">[-]</label><label class="expand" for="c-40281148">[1 more]</label></div><br/><div class="children"><div class="content">I love this type of optimisation story.<p>Interesting to note that his &quot;in theory&quot; best performance still calls to lxml.  A true in theory best performance would surely be in the multiple Gigabyte per second range (if simdjson&#x27;s performance is taken as a goal), and not 0.56 seconds to process 230 MiB which is only about half a GBps.  Half a gigabyte per second is probably more than sufficient for most uses, so I&#x27;m splitting hairs somewhat.<p>Here is the issue for slow sax parsing in encoding&#x2F;xml.  No work on it since around 2020:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;21823">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;21823</a></div><br/></div></div><div id="40281754" class="c"><input type="checkbox" id="c-40281754" checked=""/><div class="controls bullet"><span class="by">llimllib</span><span>|</span><a href="#40281148">prev</a><span>|</span><a href="#40281190">next</a><span>|</span><label class="collapse" for="c-40281754">[-]</label><label class="expand" for="c-40281754">[2 more]</label></div><br/><div class="children"><div class="content">I reran the results on my m1 mac pro since this post is 6 years old:<p><pre><code>    python etree: 3.25s
    python lxml: 2.01s
    go stdlib: 3.35s
    go gosax: 1.45s
    C: 0.38s
</code></pre>
So, python etree gives the same result 6 years on while lxml has gotten faster. Go&#x27;s standard library does about as well as python&#x27;s stdlib, and has gotten faster on the cgo binding.<p>Procedure:<p><pre><code>    - clone https:&#x2F;&#x2F;github.com&#x2F;eliben&#x2F;xmlgen
    - run `xmlgen -f 2 &gt; out.xml` to generate a test xml file
    - clone https:&#x2F;&#x2F;github.com&#x2F;eliben&#x2F;code-for-blog&#x2F; and switch to the 2019&#x2F;xml-stream dir
    - mv out.xml from above to the current directory
    - `time python etree-count.py out.xml`
    - `pip install lxml &amp;&amp; time python lxml-count.py out.xml`
    - `go build go-stdlib-count.go &amp;&amp; time .&#x2F;go-stdlib-count out.xml`
    - `cd c-libxmlsax-count &amp;&amp; make &amp;&amp; time .&#x2F;c-libxmlsax-count ..&#x2F;out.xml`
    - `cd gosax-count &amp;&amp; go build gosax-count-simple.go &amp;&amp; time .&#x2F;gosax-count-simple ..&#x2F;out.xml`</code></pre></div><br/></div></div><div id="40281190" class="c"><input type="checkbox" id="c-40281190" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#40281754">prev</a><span>|</span><a href="#40282120">next</a><span>|</span><label class="collapse" for="c-40281190">[-]</label><label class="expand" for="c-40281190">[7 more]</label></div><br/><div class="children"><div class="content">Great post.<p>An issue I have with it is the way it frames the speed of a language, e.g., Python, C, etc., especially here:<p>&gt; I implemented the same program using pure C with libxml, which has a SAX API. [...] It takes just 0.56 seconds to process our 230 MiB input file, which is very impressive given the other results, but also not very surprising. This is C, after all.<p>What the author is actually comparing here of course is the quality of the GCC (or LLVM or whatever) code generator, not &quot;C&quot; versus e.g. Go (the programming language and&#x2F;or its standard libraries).<p>There are enough misapprehensions about the source of good&#x2F;bad performance of Runtimes, Not Languages.  Quips like this (that it&#x27;s &quot;C, after all&quot;) don&#x27;t help that discussion.</div><br/><div id="40283259" class="c"><input type="checkbox" id="c-40283259" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#40281190">parent</a><span>|</span><a href="#40281486">next</a><span>|</span><label class="collapse" for="c-40283259">[-]</label><label class="expand" for="c-40283259">[2 more]</label></div><br/><div class="children"><div class="content">Some language paradigms are always going to produce less optimised binaries.<p>Such as garbage collected languages vs non-garbage collected languages. And Python enables meta programming, which itself massively reduces the performance of the language (from a purely computational perspective).<p>While C compilers do generally have much better support for optimisations, the language itself was initially designed to sit pretty close to assembly. So even unoptimised C will perform better than the equivalent code written in Go or Python using their respective idioms.</div><br/><div id="40283526" class="c"><input type="checkbox" id="c-40283526" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40281190">root</a><span>|</span><a href="#40283259">parent</a><span>|</span><a href="#40281486">next</a><span>|</span><label class="collapse" for="c-40283526">[-]</label><label class="expand" for="c-40283526">[1 more]</label></div><br/><div class="children"><div class="content">Garbage collection is completely orthogonal to the quality of emitted codegen.<p>What GC does have impact on is the way VM handles memory management:<p>- Cost of allocation helper calls &#x2F; are they (partially) inlined<p>- Cost of write barriers<p>- Cost of GC pauses, their frequency or the cost paid in other places if it&#x27;s shifted from GC pauses (which Go does)<p>- Cost of thread suspension&#x2F;yielding strategy - relates to the previous point but is distinct should a GC have full stop-the-world phase<p>Generally speaking, Go&#x27;s compiler is very weak but where Go manages to get performance back are two areas:<p>- Go forces you to write a lot of, effectively, manually inlined code by virtue of being painful to use abstractions and generics in<p>- By constraining the range of tools you can use, it focuses on providing lightweight implementation for those (e.g. channels)<p>This allows Go to excel at particular niche it is targeted at (networked back-end services) but results in its severe underperformance against expectations the moment you step away from that use case.<p>Both JVM and .NET are good counterexamples to Go that being garbage collected does not mean sacrificing performance. Unfortunately, historical choices in JVM prevent it from reaching zero-cost abstraction + low&#x2F;zero-allocation style of performance oriented code in C, C++ and Rust so C# remains pretty much the only GC-based language that lets you do so.<p>Swift receives honorable mention but it appears to consistently have much worse performance due to ARC and virtual dispatch so it can&#x27;t really compete unless you write totally-not-C code in it.</div><br/></div></div></div></div><div id="40281486" class="c"><input type="checkbox" id="c-40281486" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40281190">parent</a><span>|</span><a href="#40283259">prev</a><span>|</span><a href="#40282545">next</a><span>|</span><label class="collapse" for="c-40281486">[-]</label><label class="expand" for="c-40281486">[3 more]</label></div><br/><div class="children"><div class="content">The C runtime doesn&#x27;t really show up on a profiler though. It&#x27;s crawl the init_array then jump to main. Small enough that a lot of people don&#x27;t notice the C runtime exists at all. Compiling C to efficient machine code is a much easier problem than compiling Go to similar machine code since all the heavy lifting is done by the programmer.</div><br/><div id="40281746" class="c"><input type="checkbox" id="c-40281746" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40281190">root</a><span>|</span><a href="#40281486">parent</a><span>|</span><a href="#40282545">next</a><span>|</span><label class="collapse" for="c-40281746">[-]</label><label class="expand" for="c-40281746">[2 more]</label></div><br/><div class="children"><div class="content">C doesn&#x27;t really have a &quot;run time&quot;. The startup code is optional and I wouldn&#x27;t really call it a &quot;run time&quot; in the sense that Go has a runtime for managing goroutines and GC.<p>It&#x27;s not that easy to write Go code with no dynamic memory allocations and no GC pressure.<p>I think it&#x27;s fair to say &quot;C is faster than Go&quot;. It&#x27;s not purely a function of the language but a combination of factors including the quality of the compiler&#x2F;optimizer, available libraries, and language features (and their performance cost).</div><br/><div id="40282978" class="c"><input type="checkbox" id="c-40282978" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#40281190">root</a><span>|</span><a href="#40281746">parent</a><span>|</span><a href="#40282545">next</a><span>|</span><label class="collapse" for="c-40282978">[-]</label><label class="expand" for="c-40282978">[1 more]</label></div><br/><div class="children"><div class="content">Yes it typically does have a runtime. For example, it has persistent structures in memory related to malloc&#x2F;free, and the manipulation of those most definitely show up when you profile.</div><br/></div></div></div></div></div></div><div id="40282545" class="c"><input type="checkbox" id="c-40282545" checked=""/><div class="controls bullet"><span class="by">ternaryoperator</span><span>|</span><a href="#40281190">parent</a><span>|</span><a href="#40281486">prev</a><span>|</span><a href="#40282120">next</a><span>|</span><label class="collapse" for="c-40282545">[-]</label><label class="expand" for="c-40282545">[1 more]</label></div><br/><div class="children"><div class="content">The golang runtime has a penalty due to the fact that it sets up memory for GC at startup. It is legitimately C runtime vs. go runtime.</div><br/></div></div></div></div><div id="40282120" class="c"><input type="checkbox" id="c-40282120" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40281190">prev</a><span>|</span><a href="#40283480">next</a><span>|</span><label class="collapse" for="c-40282120">[-]</label><label class="expand" for="c-40282120">[1 more]</label></div><br/><div class="children"><div class="content"><i>The task is to find how many times &quot;Africa&quot; appears in the data of the &lt;location&gt; tag throughout the document.</i><p>I wonder how fast grep&#x2F;strstr compares, since they can run at &quot;faster than memcpy&quot; speeds, which means dozens of GB&#x2F;s on any relatively recent machine. I know it&#x27;s not the &quot;pedantically correct&quot; way to to do it, but in practice it works well. Only mode-escapes like CDATA can break the fact that XML tags otherwise cannot occur as substrings, so a substring match can work otherwise. This is especially true for JSON which doesn&#x27;t have such escapes.<p>Of course not using XML may gain more than an order of magnitude in speed, so if you have the chance to control both ends and get rid of XML in favour of a simpler binary protocol, I strongly recommend advocating for it.</div><br/></div></div><div id="40283480" class="c"><input type="checkbox" id="c-40283480" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40282120">prev</a><span>|</span><a href="#40281151">next</a><span>|</span><label class="collapse" for="c-40283480">[-]</label><label class="expand" for="c-40283480">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure the C performance would have been matched by C# were it to be ported there.<p>While not XML (which does not see much love from the community to surprise of HN), gigabytes per second of parsing throughput are reached for CSV without sacrificing UX: <a href="https:&#x2F;&#x2F;github.com&#x2F;nietras&#x2F;Sep?tab=readme-ov-file#packageassets-benchmark-results">https:&#x2F;&#x2F;github.com&#x2F;nietras&#x2F;Sep?tab=readme-ov-file#packageass...</a></div><br/></div></div><div id="40281151" class="c"><input type="checkbox" id="c-40281151" checked=""/><div class="controls bullet"><span class="by">notamy</span><span>|</span><a href="#40283480">prev</a><span>|</span><a href="#40281692">next</a><span>|</span><label class="collapse" for="c-40281151">[-]</label><label class="expand" for="c-40281151">[1 more]</label></div><br/><div class="children"><div class="content">(2019)</div><br/></div></div></div></div></div></div></div></body></html>