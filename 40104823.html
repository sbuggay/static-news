<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713776468192" as="style"/><link rel="stylesheet" href="styles.css?v=1713776468192"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: Which books/resources to understand modern Assembler?</a> </div><div class="subtext"><span>throwaway63467</span> | <span>53 comments</span></div><br/><div><div id="40110256" class="c"><input type="checkbox" id="c-40110256" checked=""/><div class="controls bullet"><span class="by">jstrieb</span><span>|</span><a href="#40110466">next</a><span>|</span><label class="collapse" for="c-40110256">[-]</label><label class="expand" for="c-40110256">[3 more]</label></div><br/><div class="children"><div class="content">Not specific to LLVM or JIT, but if you want a visceral intuition for the basics of ARM assembly, I made a free, online game at work (for mobile and desktop) that may help you:<p><a href="https:&#x2F;&#x2F;ofrak.com&#x2F;tetris&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ofrak.com&#x2F;tetris&#x2F;</a><p>I didn&#x27;t do much ARM before working on the game, but since playing a lot, I&#x27;m very quick at reading disassembly, even for instructions not present in the game. It might help you to do the same – the timed game aspect forces you to learn to read the instructions quickly.<p>The game is like Tetris, but the blocks are ARM assembly instructions. As instructions fall, you can change the operand registers. Locking instructions into the .text section executes them in a CPU emulator running client-side in the browser, so you can immediately see the effects of every action. Your score is stored in memory at the address pointed to by one of the registers, so even though you earn points for each instruction executed without segfaulting, the true goal is to execute instructions that directly change the memory containing the score value.<p>When I released it a bit less than a year ago, I posted it to Hacker News as a Show HN:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37083309">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37083309</a></div><br/><div id="40111861" class="c"><input type="checkbox" id="c-40111861" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#40110256">parent</a><span>|</span><a href="#40110634">next</a><span>|</span><label class="collapse" for="c-40111861">[-]</label><label class="expand" for="c-40111861">[1 more]</label></div><br/><div class="children"><div class="content">&gt; at work<p>What kind of job?</div><br/></div></div><div id="40110634" class="c"><input type="checkbox" id="c-40110634" checked=""/><div class="controls bullet"><span class="by">dabber</span><span>|</span><a href="#40110256">parent</a><span>|</span><a href="#40111861">prev</a><span>|</span><a href="#40110466">next</a><span>|</span><label class="collapse" for="c-40110634">[-]</label><label class="expand" for="c-40110634">[1 more]</label></div><br/><div class="children"><div class="content">This is awesome! Thanks for sharing it again, I guess I missed the original Share HN.</div><br/></div></div></div></div><div id="40110466" class="c"><input type="checkbox" id="c-40110466" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40110256">prev</a><span>|</span><a href="#40106499">next</a><span>|</span><label class="collapse" for="c-40110466">[-]</label><label class="expand" for="c-40110466">[3 more]</label></div><br/><div class="children"><div class="content">All you really need is an instruction set reference, such as:
<a href="https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;index.html</a>
and have a compiler that supports an inline assembler, like the D compiler, with Intel assembler syntax and use it like:<p><pre><code>    private uint asmBitswap32(uint x) @trusted pure
    {
        asm pure nothrow @nogc { naked; }

        version (D_InlineAsm_X86_64)
        {
            version (Win64)
                asm pure nothrow @nogc { mov EAX, ECX; }
            else
                asm pure nothrow @nogc { mov EAX, EDI; }
        }

        asm pure nothrow @nogc
        {
            &#x2F;&#x2F; Author: Tiago Gasiba.
            mov EDX, EAX;
            shr EAX, 1;
            and EDX, 0x5555_5555;
            and EAX, 0x5555_5555;
            shl EDX, 1;
            or  EAX, EDX;
            mov EDX, EAX;
            shr EAX, 2;
            and EDX, 0x3333_3333;
            and EAX, 0x3333_3333;
            shl EDX, 2;
            or  EAX, EDX;
            mov EDX, EAX;
            shr EAX, 4;
            and EDX, 0x0f0f_0f0f;
            and EAX, 0x0f0f_0f0f;
            shl EDX, 4;
            or  EAX, EDX;
            bswap EAX;
            ret;
        }
    }
</code></pre>
The compiler will handle all the program setup and teardown, and you can just concentrate on the assembler part. You can also compile programs with the -vasm switch and the compiler will emit the asm corresponding to the code:<p><pre><code>    int square(int x) { return x * x; }
</code></pre>
compiling:<p><pre><code>    dmd -c test.d -vasm
</code></pre>
prints:<p><pre><code>    _D4test6squareFiZi:
    0000:   0F AF C0                 imul      EAX,EAX
    0003:   C3                       ret
</code></pre>
By trying simple expressions like `x * x` and looking at what the compiler generates, and looking at the instructions in the referenced link, you&#x27;ll get the hang of it pretty quick.</div><br/><div id="40112054" class="c"><input type="checkbox" id="c-40112054" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40110466">parent</a><span>|</span><a href="#40106499">next</a><span>|</span><label class="collapse" for="c-40112054">[-]</label><label class="expand" for="c-40112054">[2 more]</label></div><br/><div class="children"><div class="content">Reading that makes the GCC inline asm format look <i>really</i> ugly. Some envy. Too used to inline asm looking like<p><pre><code>  __asm__ volatile(&quot;syscall&quot;
                   : &quot;=a&quot;(ret)
                   : &quot;a&quot;(n), &quot;D&quot;(a0), &quot;S&quot;(a1), &quot;d&quot;(a2), &quot;r&quot;(r10), &quot;r&quot;(r8),
                     &quot;r&quot;(r9)
                   : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);</code></pre></div><br/><div id="40112414" class="c"><input type="checkbox" id="c-40112414" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40110466">root</a><span>|</span><a href="#40112054">parent</a><span>|</span><a href="#40106499">next</a><span>|</span><label class="collapse" for="c-40112414">[-]</label><label class="expand" for="c-40112414">[1 more]</label></div><br/><div class="children"><div class="content">GCC inline assembly looks incredibly cursed. Back in the day, the Borland tool suite (Turbo&#x2F;Borland C++, Turbo Pascal) had inline assembly that looked more like the D compiler example above.<p>GCC does, however, know what to do with a .s file, so you can write your assembly routines <i>outside</i> your C(++) source and just compile them in like a C module, which is what I did last time I was hardcore slinging x86 opcodes.</div><br/></div></div></div></div></div></div><div id="40106499" class="c"><input type="checkbox" id="c-40106499" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#40110466">prev</a><span>|</span><a href="#40110253">next</a><span>|</span><label class="collapse" for="c-40106499">[-]</label><label class="expand" for="c-40106499">[2 more]</label></div><br/><div class="children"><div class="content">&#x27;Computer Architeture: A Quantitative Apporach&quot; and&#x2F;or more specific design types (mips, arm, etc) can be found under the Morgan Kaufmann Series in Computer Architeture and Design.<p>&quot;Getting Started with LLVM Core Libraries: Get to Grips With Llvm Essentials and Use the Core Libraries to Build Advanced Tools &quot;<p>&quot;The Architecture of Open Source Applications (Volume 1) : LLVM&quot; <a href="https:&#x2F;&#x2F;aosabook.org&#x2F;en&#x2F;v1&#x2F;llvm.html" rel="nofollow">https:&#x2F;&#x2F;aosabook.org&#x2F;en&#x2F;v1&#x2F;llvm.html</a><p>&quot;Tourist Guide to LLVM source code&quot; : <a href="https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;1453" rel="nofollow">https:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;1453</a><p>llvm home page : <a href="https:&#x2F;&#x2F;llvm.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;</a><p>llvm tutorial : <a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;tutorial&#x2F;" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;tutorial&#x2F;</a><p>llvm reference : <a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html</a><p>learn by examples :  C source code to &#x27;llvm&#x27; bitcode : <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;9148890&#x2F;how-to-make-clang-compile-to-llvm-ir#9149406" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;9148890&#x2F;how-to-make-clan...</a></div><br/><div id="40111403" class="c"><input type="checkbox" id="c-40111403" checked=""/><div class="controls bullet"><span class="by">RheingoldRiver</span><span>|</span><a href="#40106499">parent</a><span>|</span><a href="#40110253">next</a><span>|</span><label class="collapse" for="c-40111403">[-]</label><label class="expand" for="c-40111403">[1 more]</label></div><br/><div class="children"><div class="content">You have a typo that will make an amazon search fail on copy paste, corrected version is &quot;Computer Architecture: A Quantitative Approach&quot;<p>kinda amazing to me that amazon cannot fix this but it returns 0 results (at least for me)</div><br/></div></div></div></div><div id="40110253" class="c"><input type="checkbox" id="c-40110253" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40106499">prev</a><span>|</span><a href="#40112400">next</a><span>|</span><label class="collapse" for="c-40110253">[-]</label><label class="expand" for="c-40110253">[4 more]</label></div><br/><div class="children"><div class="content">IMO You should just stick some programs in Ghidra&#x2F;Godbolt and see what they emit, especially for small individual snippets whenever you think &quot;I want to do X, what&#x27;s the best way of doing it&quot;. There really isn&#x27;t much difference between &quot;baby&#x27;s first assembly&quot; program, where you just have movs and like five other common instructions, and the kind of assembly an optimizing compiler emits: it&#x27;s a matter of recognizing that some operations can be merged into a more specialized one or the addressing mode of another, or you can use a setcc with a results flag from something you already computed, or what have you. The good code that LLVM and JITs emit for the most part aren&#x27;t due to much better instruction selection but due to much better optimization passes, which learning more about assembly doesn&#x27;t help with: it&#x27;s about transforming code in general at a high level, which you would do at the compiler IR step before touching assembly at all.</div><br/><div id="40111791" class="c"><input type="checkbox" id="c-40111791" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#40110253">parent</a><span>|</span><a href="#40111132">next</a><span>|</span><label class="collapse" for="c-40111791">[-]</label><label class="expand" for="c-40111791">[2 more]</label></div><br/><div class="children"><div class="content">&gt; much better optimization passes, which learning more about assembly doesn&#x27;t help with<p>I think you have to include an understanding of the underlying processor architecture as part of &quot;learning more about assembly&quot;. If you&#x27;re writing assembler without instruction scheduling in mind, you would be better off not writing assembler at all, and letting the LLVM optimizers do instruction scheduling for you.</div><br/><div id="40112338" class="c"><input type="checkbox" id="c-40112338" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#40110253">root</a><span>|</span><a href="#40111791">parent</a><span>|</span><a href="#40111132">next</a><span>|</span><label class="collapse" for="c-40112338">[-]</label><label class="expand" for="c-40112338">[1 more]</label></div><br/><div class="children"><div class="content">How can one learn instruction scheduling for Intel. Are the algo of branch prediction and out of order execution revealed in the manual? Thanks.</div><br/></div></div></div></div><div id="40111132" class="c"><input type="checkbox" id="c-40111132" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#40110253">parent</a><span>|</span><a href="#40111791">prev</a><span>|</span><a href="#40112400">next</a><span>|</span><label class="collapse" for="c-40111132">[-]</label><label class="expand" for="c-40111132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or you can use a setcc with a results flag from something you already computed<p>Funny enough, on large CPUs this can be slower than recomputing something, because they don&#x27;t like long dependency chains and sometimes even have penalties for reading a register that hasn&#x27;t been written for hundreds of instructions.</div><br/></div></div></div></div><div id="40112400" class="c"><input type="checkbox" id="c-40112400" checked=""/><div class="controls bullet"><span class="by">maldev</span><span>|</span><a href="#40110253">prev</a><span>|</span><a href="#40109864">next</a><span>|</span><label class="collapse" for="c-40112400">[-]</label><label class="expand" for="c-40112400">[1 more]</label></div><br/><div class="children"><div class="content">I would highly recommend AMD&#x27;s developer manual. It&#x27;s a lot more written for actual reading rather than a pure tech manual with super thick language like Intel&#x27;s is.<p>I would also recommend NASM&#x27;s guide for syntax and such. <a href="https:&#x2F;&#x2F;www.nasm.us&#x2F;xdoc&#x2F;2.13.03rc1&#x2F;html&#x2F;nasmdoc0.html" rel="nofollow">https:&#x2F;&#x2F;www.nasm.us&#x2F;xdoc&#x2F;2.13.03rc1&#x2F;html&#x2F;nasmdoc0.html</a></div><br/></div></div><div id="40109864" class="c"><input type="checkbox" id="c-40109864" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#40112400">prev</a><span>|</span><a href="#40109366">next</a><span>|</span><label class="collapse" for="c-40109864">[-]</label><label class="expand" for="c-40109864">[4 more]</label></div><br/><div class="children"><div class="content">How I learned:<p>Step #1: read the arch manual for some CPU. Read most if not all of it. It’s a lot of reading but it’s worth it. My first was PowerPC and my second was x86. By the time I got to arm, I only needed to use the manual as a reference. These days I would start with x86 because the manuals are well written and easily available. And the HW is easily available.<p>Step #2: compile small programs for that arch using GCC, clang, whatever and then dump disassembly and try to understand the correspondence between your code and the instructions.</div><br/><div id="40110000" class="c"><input type="checkbox" id="c-40110000" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#40109864">parent</a><span>|</span><a href="#40111798">next</a><span>|</span><label class="collapse" for="c-40110000">[-]</label><label class="expand" for="c-40110000">[1 more]</label></div><br/><div class="children"><div class="content">The Godbolt compiler explorer can be very helpful for step 2 there.  It&#x27;s neat to see how different compilers codegen the same source.</div><br/></div></div><div id="40111798" class="c"><input type="checkbox" id="c-40111798" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#40109864">parent</a><span>|</span><a href="#40110000">prev</a><span>|</span><a href="#40109366">next</a><span>|</span><label class="collapse" for="c-40111798">[-]</label><label class="expand" for="c-40111798">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I would start with x86 because the manuals are well written and easily available<p>.. and because the ARM system manuals are just unimaginably awful. ;-P</div><br/><div id="40112214" class="c"><input type="checkbox" id="c-40112214" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#40109864">root</a><span>|</span><a href="#40111798">parent</a><span>|</span><a href="#40109366">next</a><span>|</span><label class="collapse" for="c-40112214">[-]</label><label class="expand" for="c-40112214">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m biased because I&#x27;ve spent a lot more time with them, but I rather prefer the Arm manuals, because I found they more reliably have the exact detail and solid pseudocode for how everything behaves. Plus for ages Intel split it up annoyingly into multiple different PDF documents (though it looks like you can get a combined manual now).</div><br/></div></div></div></div></div></div><div id="40109366" class="c"><input type="checkbox" id="c-40109366" checked=""/><div class="controls bullet"><span class="by">t-3</span><span>|</span><a href="#40109864">prev</a><span>|</span><a href="#40112027">next</a><span>|</span><label class="collapse" for="c-40109366">[-]</label><label class="expand" for="c-40109366">[1 more]</label></div><br/><div class="children"><div class="content">I like this book, it&#x27;s just as good as The Art of Assembly Language, but much cheaper: <a href="https:&#x2F;&#x2F;rayseyfarth.com&#x2F;asm&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;rayseyfarth.com&#x2F;asm&#x2F;index.html</a><p>If you are interested in ARM or RISC-V assembly, the concepts are pretty similar but the instructions are different. For <i>any</i> architecture, you&#x27;re going to have to read the architecture manuals to get a good working knowledge of the instructions and how to use them. An easy way to get started is to write a program in C, then replace the functions with assembly code one by one until your C code is just main() and a header.<p>ARMv7: <a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;100076&#x2F;0200&#x2F;a32-t32-instruction-set-reference&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;100076&#x2F;0200&#x2F;a32-t32-...</a><p>ARMv8: <a href="https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;ddi0602&#x2F;2024-03&#x2F;Base-Instructions" rel="nofollow">https:&#x2F;&#x2F;developer.arm.com&#x2F;documentation&#x2F;ddi0602&#x2F;2024-03&#x2F;Base...</a><p>alternative: <a href="https:&#x2F;&#x2F;www.scs.stanford.edu&#x2F;~zyedidia&#x2F;arm64&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scs.stanford.edu&#x2F;~zyedidia&#x2F;arm64&#x2F;</a><p>RISC-V: <a href="https:&#x2F;&#x2F;riscv.org&#x2F;technical&#x2F;specifications&#x2F;" rel="nofollow">https:&#x2F;&#x2F;riscv.org&#x2F;technical&#x2F;specifications&#x2F;</a><p>x86: <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;intel-sdm.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a><p>web format: <a href="http:&#x2F;&#x2F;x86.dapsen.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;x86.dapsen.com&#x2F;</a><p>If you like to learn by example (most of these are not great, but good enough to get started):<p><a href="https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Assembly" rel="nofollow">https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Assembly</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;TheAlgorithms&#x2F;AArch64_Assembly">https:&#x2F;&#x2F;github.com&#x2F;TheAlgorithms&#x2F;AArch64_Assembly</a></div><br/></div></div><div id="40112027" class="c"><input type="checkbox" id="c-40112027" checked=""/><div class="controls bullet"><span class="by">asalahli</span><span>|</span><a href="#40109366">prev</a><span>|</span><a href="#40109895">next</a><span>|</span><label class="collapse" for="c-40112027">[-]</label><label class="expand" for="c-40112027">[1 more]</label></div><br/><div class="children"><div class="content">I started with this excellent NASM tutorial[0] then went straight to Intel manuals.[1]<p>0. <a href="https:&#x2F;&#x2F;cs.lmu.edu&#x2F;~ray&#x2F;notes&#x2F;nasmtutorial&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cs.lmu.edu&#x2F;~ray&#x2F;notes&#x2F;nasmtutorial&#x2F;</a><p>1. <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;intel-sdm.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a></div><br/></div></div><div id="40109895" class="c"><input type="checkbox" id="c-40109895" checked=""/><div class="controls bullet"><span class="by">mtreis86</span><span>|</span><a href="#40112027">prev</a><span>|</span><a href="#40110718">next</a><span>|</span><label class="collapse" for="c-40109895">[-]</label><label class="expand" for="c-40109895">[1 more]</label></div><br/><div class="children"><div class="content">Play through the game Turing Complete, by the end you&#x27;ll have built your own ISA and solved some puzzles with it. Keep playing for to get on the high scores list and you&#x27;ll turn those assembly routines into ASICs.</div><br/></div></div><div id="40110718" class="c"><input type="checkbox" id="c-40110718" checked=""/><div class="controls bullet"><span class="by">ksherlock</span><span>|</span><a href="#40109895">prev</a><span>|</span><a href="#40104993">next</a><span>|</span><label class="collapse" for="c-40110718">[-]</label><label class="expand" for="c-40110718">[1 more]</label></div><br/><div class="children"><div class="content">Someday -- not today, not tomorrow, but someday -- you&#x27;ll probably want to read Agner Fog&#x27;s optimization manuals.<p><a href="https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;#manuals" rel="nofollow">https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;#manuals</a></div><br/></div></div><div id="40104993" class="c"><input type="checkbox" id="c-40104993" checked=""/><div class="controls bullet"><span class="by">zoenolan</span><span>|</span><a href="#40110718">prev</a><span>|</span><a href="#40111717">next</a><span>|</span><label class="collapse" for="c-40104993">[-]</label><label class="expand" for="c-40104993">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.nand2tetris.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.nand2tetris.org&#x2F;</a><p>As a good refresher on assembly and  compilers</div><br/><div id="40110439" class="c"><input type="checkbox" id="c-40110439" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#40104993">parent</a><span>|</span><a href="#40108443">next</a><span>|</span><label class="collapse" for="c-40110439">[-]</label><label class="expand" for="c-40110439">[2 more]</label></div><br/><div class="children"><div class="content">I really like this book, is more than a refresher imo, it <i>really</i> goes from NAND gates all the way up to building a CPU using a Verilog-like language, its assembler language, then a higher-level language, etc.<p>The only thing that is not as nice is the tooling, it&#x27;s GUI based and uses Java. One of the projects on my backburner is to attempt to write a better toolset for it. Or maybe I should just wait for someone else to do it haha (to be clear, there&#x27;s nothing wrong with the existing tooling, I&#x27;d just rather something not based on Java that I could run on a normal IDE, say, VS Code).</div><br/><div id="40111723" class="c"><input type="checkbox" id="c-40111723" checked=""/><div class="controls bullet"><span class="by">deosjr</span><span>|</span><a href="#40104993">root</a><span>|</span><a href="#40110439">parent</a><span>|</span><a href="#40108443">next</a><span>|</span><label class="collapse" for="c-40111723">[-]</label><label class="expand" for="c-40111723">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly why I built my own tooling when going through the book.
I built everything in Golang and am working on some visualisations in Javascript.
Repo: <a href="https:&#x2F;&#x2F;github.com&#x2F;deosjr&#x2F;nand2tetris">https:&#x2F;&#x2F;github.com&#x2F;deosjr&#x2F;nand2tetris</a>
Website: <a href="https:&#x2F;&#x2F;deosjr.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;deosjr.github.io&#x2F;</a> (lispmachine part is wip)</div><br/></div></div></div></div></div></div><div id="40111717" class="c"><input type="checkbox" id="c-40111717" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40104993">prev</a><span>|</span><a href="#40109720">next</a><span>|</span><label class="collapse" for="c-40111717">[-]</label><label class="expand" for="c-40111717">[1 more]</label></div><br/><div class="children"><div class="content">The highload.fun wiki[0] links some resources. The intel optimization manual[1] is also useful.<p>These resources are mostly aimed at solving problems for which compilers are not very useful, so there are probably other resources that are a better fit.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;Highload-fun&#x2F;platform&#x2F;wiki">https:&#x2F;&#x2F;github.com&#x2F;Highload-fun&#x2F;platform&#x2F;wiki</a><p>[1]: <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;content-details&#x2F;671488&#x2F;intel-64-and-ia-32-architectures-optimization-reference-manual-volume-1.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;content-details&#x2F;6714...</a></div><br/></div></div><div id="40109720" class="c"><input type="checkbox" id="c-40109720" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#40111717">prev</a><span>|</span><a href="#40111651">next</a><span>|</span><label class="collapse" for="c-40109720">[-]</label><label class="expand" for="c-40109720">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a good book to suggest, but one tip you may find helpful:<p>A typical function has two kinds of assembly code:<p>(1) The ABI-required logic for functions and function calls, and<p>(2) Everything else, which can be more or less whatever you want.  As long as you don&#x27;t stomp on the details required by the ABI.</div><br/></div></div><div id="40111651" class="c"><input type="checkbox" id="c-40111651" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#40109720">prev</a><span>|</span><a href="#40109817">next</a><span>|</span><label class="collapse" for="c-40111651">[-]</label><label class="expand" for="c-40111651">[1 more]</label></div><br/><div class="children"><div class="content">Go to the source: the Intel Software Developer Manuals.<p><a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;intel-sdm.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a><p>You will want the first two volumes. For LLVM and JIT work you don&#x27;t need the last two volumes.<p>Not kind, or gentle, but certainly definitive and authoritative.</div><br/></div></div><div id="40109817" class="c"><input type="checkbox" id="c-40109817" checked=""/><div class="controls bullet"><span class="by">mtklein</span><span>|</span><a href="#40111651">prev</a><span>|</span><a href="#40110767">next</a><span>|</span><label class="collapse" for="c-40109817">[-]</label><label class="expand" for="c-40109817">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d suggest working incrementally from areas of your existing strength.  Tweak whatever code base you are most familiar with, starting with a tiny change, and see how the assembly changes.  I use objdump -d and git diff --no-index for this all the time.</div><br/></div></div><div id="40110767" class="c"><input type="checkbox" id="c-40110767" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#40109817">prev</a><span>|</span><a href="#40105274">next</a><span>|</span><label class="collapse" for="c-40110767">[-]</label><label class="expand" for="c-40110767">[1 more]</label></div><br/><div class="children"><div class="content">The first thing you’ll learn is that a macro assembler is surprisingly high level; much of what you think of as C-style high level can be done by macros.</div><br/></div></div><div id="40105274" class="c"><input type="checkbox" id="c-40105274" checked=""/><div class="controls bullet"><span class="by">oldmanludd</span><span>|</span><a href="#40110767">prev</a><span>|</span><a href="#40110872">next</a><span>|</span><label class="collapse" for="c-40105274">[-]</label><label class="expand" for="c-40105274">[2 more]</label></div><br/><div class="children"><div class="content">OpenSecurityTraining2 has some Assembly courses<p><a href="https:&#x2F;&#x2F;p.ost2.fyi&#x2F;courses" rel="nofollow">https:&#x2F;&#x2F;p.ost2.fyi&#x2F;courses</a></div><br/><div id="40110999" class="c"><input type="checkbox" id="c-40110999" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#40105274">parent</a><span>|</span><a href="#40110872">next</a><span>|</span><label class="collapse" for="c-40110999">[-]</label><label class="expand" for="c-40110999">[1 more]</label></div><br/><div class="children"><div class="content">Ah, so it&#x27;s the updated version of this:
<a href="https:&#x2F;&#x2F;opensecuritytraining.info&#x2F;IntroX86.html" rel="nofollow">https:&#x2F;&#x2F;opensecuritytraining.info&#x2F;IntroX86.html</a><p>Let&#x27;s see...</div><br/></div></div></div></div><div id="40110872" class="c"><input type="checkbox" id="c-40110872" checked=""/><div class="controls bullet"><span class="by">joncmu</span><span>|</span><a href="#40105274">prev</a><span>|</span><a href="#40110824">next</a><span>|</span><label class="collapse" for="c-40110872">[-]</label><label class="expand" for="c-40110872">[3 more]</label></div><br/><div class="children"><div class="content">If you want to learn one of the oldest assembly languages you can still find a modern computer to run it on check out IBM Z assembly.  There is a great list of resources here: <a href="https:&#x2F;&#x2F;idcp.marist.edu&#x2F;assembler-resources" rel="nofollow">https:&#x2F;&#x2F;idcp.marist.edu&#x2F;assembler-resources</a><p>The one resource they don&#x27;t list is the ISA manual which is called the Principles of Operation which the latest version can be found here: <a href="https:&#x2F;&#x2F;publibfp.dhe.ibm.com&#x2F;epubs&#x2F;pdf&#x2F;a227832d.pdf" rel="nofollow">https:&#x2F;&#x2F;publibfp.dhe.ibm.com&#x2F;epubs&#x2F;pdf&#x2F;a227832d.pdf</a><p>It is actually pretty amazing at how easy it is to learn other architectures once you understand how one or two work.</div><br/><div id="40111663" class="c"><input type="checkbox" id="c-40111663" checked=""/><div class="controls bullet"><span class="by">seankurtz</span><span>|</span><a href="#40110872">parent</a><span>|</span><a href="#40111011">next</a><span>|</span><label class="collapse" for="c-40111663">[-]</label><label class="expand" for="c-40111663">[1 more]</label></div><br/><div class="children"><div class="content">The benefit to learning s390x assembler over others is that there are actually still experts around that program entirely in the macro assembler, and environments that still expect or require it (technically, its a solved problem to link against the assembler code from Metal C, but all the docs and APIs are specified entirely in assembler for much of the low level OS internals, and you really do need to know it to work with it in any significant professional capacity).<p>Its tough to learn on x86 or ARM, because there has been a lot of standardization towards C, and that is sorta the expected low level API&#x2F;ABI even at the kernel level in 2024. Calling conventions have been standardized, and really very little actual programming is done manually in assembly these days. So its sort of artificial trying to learn assembly on those ISAs these days. Certainly there are not many APIs specified in assembly. Perhaps one exception would be compiler&#x2F;linker backends, but that is a whole other can of worms you&#x27;ve gotta learn if you go that route.<p>IBM Z is different in that respect. It makes it probably a more difficult and unwieldy platform overall if you just wanna make a quick app and ship (why I&#x27;m not advocating you all go out and buy mainframes lol), but for learning how to program assembler &quot;in the real world&quot;, its the last bastion of a much older school of programming and a great learning environment that will challenge some of the assumptions you maybe have picked up that actually come from Unix or C and not the ISAs themselves.<p>Its also, in my humble opinion, a pretty nice macro assembler to actually work with. Its had a lot of development over the years (perhaps as a result of it remaining a significant force in the systems programming world for mainframes long after similar programming interfaces were quietly retired on newer platforms), and so I quite like the actual assembler itself, now known as IBM HLASM.<p>I tend to recommend newcomers pick up a free pdf book from here by the esteemed John Ehrman (RIP)<p><a href="https:&#x2F;&#x2F;idcp.marist.edu&#x2F;assembler-resources" rel="nofollow">https:&#x2F;&#x2F;idcp.marist.edu&#x2F;assembler-resources</a><p>along with the POPs specified above. And make an account on zXplore or similar and play around after doing the (very short) introductory portion.</div><br/></div></div><div id="40111011" class="c"><input type="checkbox" id="c-40111011" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40110872">parent</a><span>|</span><a href="#40111663">prev</a><span>|</span><a href="#40110824">next</a><span>|</span><label class="collapse" for="c-40111011">[-]</label><label class="expand" for="c-40111011">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If you want to learn one of the oldest assembly languages you can still find a modern computer to run it on check out IBM Z assembly.<p>6502 assembly on the Commodore 64 was good fun.<p>Pretty simple ISA.</div><br/></div></div></div></div><div id="40110824" class="c"><input type="checkbox" id="c-40110824" checked=""/><div class="controls bullet"><span class="by">billsix</span><span>|</span><a href="#40110872">prev</a><span>|</span><a href="#40108696">next</a><span>|</span><label class="collapse" for="c-40110824">[-]</label><label class="expand" for="c-40110824">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve liked Jonathan Bartlett&#x27;s books, his newest is &quot;Learn to Program with Assembly&quot;</div><br/><div id="40111343" class="c"><input type="checkbox" id="c-40111343" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40110824">parent</a><span>|</span><a href="#40108696">next</a><span>|</span><label class="collapse" for="c-40111343">[-]</label><label class="expand" for="c-40111343">[1 more]</label></div><br/><div class="children"><div class="content">Seconded; his books are a very good introduction to assembly programming.</div><br/></div></div></div></div><div id="40108696" class="c"><input type="checkbox" id="c-40108696" checked=""/><div class="controls bullet"><span class="by">alexdowad</span><span>|</span><a href="#40110824">prev</a><span>|</span><a href="#40111726">next</a><span>|</span><label class="collapse" for="c-40108696">[-]</label><label class="expand" for="c-40108696">[1 more]</label></div><br/><div class="children"><div class="content">Aside from what has already been suggested, you could consider reading selected chapters of Intel&#x27;s programmer manual. I personally read through the whole thing once (well, skimmed some parts).<p>From my experience, Intel&#x27;s x86 manual is better and easier to read than AMD&#x27;s. It&#x27;s a free download.</div><br/></div></div><div id="40111726" class="c"><input type="checkbox" id="c-40111726" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#40108696">prev</a><span>|</span><a href="#40110006">next</a><span>|</span><label class="collapse" for="c-40111726">[-]</label><label class="expand" for="c-40111726">[1 more]</label></div><br/><div class="children"><div class="content">OT: Not a modern one, but &quot;Z80 Assembly Language Subroutines&quot; has been my favorite computer book for 40+ years.</div><br/></div></div><div id="40110006" class="c"><input type="checkbox" id="c-40110006" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40111726">prev</a><span>|</span><a href="#40110047">next</a><span>|</span><label class="collapse" for="c-40110006">[-]</label><label class="expand" for="c-40110006">[1 more]</label></div><br/><div class="children"><div class="content">There are two aspects to assembler. One is the target machine - learning what instructions, memory, performance characteristics you&#x27;re dealing with.<p>The other is the assembler - what syntax it gives you, how it handles macros, whether it optimises, whether it does any semantic analysis. GNU AS is different to NASM is different to flat assembler.<p>I didn&#x27;t get much out of reading compiler disassembly relative to handwritten assembly. I&#x27;d recommend trying to find some of the latter, might need to be maths libs or video codecs or similar. I&#x27;d be interested in recommendations here, the asm I learned from was proprietary.</div><br/></div></div><div id="40110047" class="c"><input type="checkbox" id="c-40110047" checked=""/><div class="controls bullet"><span class="by">vmchale</span><span>|</span><a href="#40110006">prev</a><span>|</span><a href="#40110404">next</a><span>|</span><label class="collapse" for="c-40110047">[-]</label><label class="expand" for="c-40110047">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a blog post on writing a JIT that can handle FFI calls: <a href="http:&#x2F;&#x2F;blog.vmchale.com&#x2F;article&#x2F;jit" rel="nofollow">http:&#x2F;&#x2F;blog.vmchale.com&#x2F;article&#x2F;jit</a><p>If you want the full monty, I think you&#x27;ll have to read the LLVM documentation on JIT linking: <a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;JITLink.html" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;JITLink.html</a><p>I haven&#x27;t found any academic papers or tutorials on JIT linking, unfortunately.</div><br/></div></div><div id="40110404" class="c"><input type="checkbox" id="c-40110404" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40110047">prev</a><span>|</span><a href="#40111330">next</a><span>|</span><label class="collapse" for="c-40110404">[-]</label><label class="expand" for="c-40110404">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re interested in ARM 32 bit, I can recommend book &quot;Raspberry Pi Assembly Language Programming: ARM Processor Coding&quot;<p>It very thoroughly describes Cortex M0 assembly language and it also touches the concept of multiprocessor programming. And you just need two Raspi Picos (one to serve as programmer) which are very available.</div><br/></div></div><div id="40111330" class="c"><input type="checkbox" id="c-40111330" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40110404">prev</a><span>|</span><a href="#40109692">next</a><span>|</span><label class="collapse" for="c-40111330">[-]</label><label class="expand" for="c-40111330">[1 more]</label></div><br/><div class="children"><div class="content">Not specific to LLVM&#x2F;JIT but for assembly checkout the books by Larry Pyeatt(ARM) and Daniel Kusswurm(x86).</div><br/></div></div><div id="40109692" class="c"><input type="checkbox" id="c-40109692" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#40111330">prev</a><span>|</span><a href="#40111743">next</a><span>|</span><label class="collapse" for="c-40109692">[-]</label><label class="expand" for="c-40109692">[4 more]</label></div><br/><div class="children"><div class="content">A great way to learn assembler is to closely examine code generated by a compiler, e.g. on godbolt.org.</div><br/><div id="40110435" class="c"><input type="checkbox" id="c-40110435" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#40109692">parent</a><span>|</span><a href="#40110460">next</a><span>|</span><label class="collapse" for="c-40110435">[-]</label><label class="expand" for="c-40110435">[2 more]</label></div><br/><div class="children"><div class="content">Manually with:<p><pre><code>    gcc -c -O0 -no-pie main.c
</code></pre>
Probably also be worth throwing in -nostdlib while learning to keep it bare-bones, otherwise will need to link the c runtime.<p>Assemble the emitted .S file:<p><pre><code>     as -o main.o main.S
</code></pre>
Link with c runtime<p><pre><code>    ld -o main -lc main.o crt1.o crti.o crtn.o --entry main
</code></pre>
If using -nostdlib, add your own start.S with a simple entry which calls main with no command line arguments.<p><pre><code>    BITS 64

    %define SYS_exit 60

            global _start

    _start:
            xor edi, edi
            xor esi, esi
            call main
            xor eax, eax
            mov al, SYS_exit
            xor edi, edi
            syscall
</code></pre>
Assemble with:<p><pre><code>    nasm -felf64 -o start.o start.S
</code></pre>
And link both:<p><pre><code>    ld -o main main.o start.o --strip-debug
</code></pre>
Check the result:<p><pre><code>    objdump -x -S main
</code></pre>
To keep even more minimal, add your own link.ld file instead of using the default:<p><pre><code>    OUTPUT_FORMAT(&quot;elf64-x86-64&quot;)
    OUTPUT(main)
    ENTRY(_start)

    INPUT(main.o)
    INPUT(start.o)

    SECTIONS
    {
        PROVIDE (__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000)); 
        . = SEGMENT_START(&quot;text-segment&quot;, 0x400000) + SIZEOF_HEADERS;
        .text : { *(.text)  }
        .eh_frame : { *(.eh_frame) ; }
        .data : { *(.data) ; }
        .bss : { *(.bss) ; }
    }
</code></pre>
Link with:<p><pre><code>   ld -T link.ld</code></pre></div><br/><div id="40111287" class="c"><input type="checkbox" id="c-40111287" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40109692">root</a><span>|</span><a href="#40110435">parent</a><span>|</span><a href="#40110460">next</a><span>|</span><label class="collapse" for="c-40111287">[-]</label><label class="expand" for="c-40111287">[1 more]</label></div><br/><div class="children"><div class="content">Nice!<p>PSA: Read Hongjiu Lu&#x27;s classic paper <i>ELF: From The Programmer&#x27;s Perspective</i> as a preliminary to get an idea of how the above steps fit together.</div><br/></div></div></div></div><div id="40110460" class="c"><input type="checkbox" id="c-40110460" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40109692">parent</a><span>|</span><a href="#40110435">prev</a><span>|</span><a href="#40111743">next</a><span>|</span><label class="collapse" for="c-40110460">[-]</label><label class="expand" for="c-40110460">[1 more]</label></div><br/><div class="children"><div class="content">IMO that is not a good starting point for beginners to assembly.<p>They can go for it later, after learning assembly basics.</div><br/></div></div></div></div><div id="40111743" class="c"><input type="checkbox" id="c-40111743" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#40109692">prev</a><span>|</span><a href="#40110368">next</a><span>|</span><label class="collapse" for="c-40111743">[-]</label><label class="expand" for="c-40111743">[1 more]</label></div><br/><div class="children"><div class="content">Build a Forth</div><br/></div></div><div id="40110368" class="c"><input type="checkbox" id="c-40110368" checked=""/><div class="controls bullet"><span class="by">kylecazar</span><span>|</span><a href="#40111743">prev</a><span>|</span><a href="#40110144">next</a><span>|</span><label class="collapse" for="c-40110368">[-]</label><label class="expand" for="c-40110368">[2 more]</label></div><br/><div class="children"><div class="content">Fond memories of ordering the then-free print volumes of the IA-32 reference manuals from Intel... and actually receiving them.</div><br/><div id="40111837" class="c"><input type="checkbox" id="c-40111837" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#40110368">parent</a><span>|</span><a href="#40110144">next</a><span>|</span><label class="collapse" for="c-40111837">[-]</label><label class="expand" for="c-40111837">[1 more]</label></div><br/><div class="children"><div class="content">Fond memories of dropping in to the local Intel sales office to pick up the then-free Intel Reference manuals whenever a new processor came out! No appointment necessary.</div><br/></div></div></div></div><div id="40110144" class="c"><input type="checkbox" id="c-40110144" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40110368">prev</a><span>|</span><a href="#40111750">next</a><span>|</span><label class="collapse" for="c-40110144">[-]</label><label class="expand" for="c-40110144">[1 more]</label></div><br/><div class="children"><div class="content">For those who want to do x86 assembly first, google Paul Carter assembly language.<p>It could be one option.</div><br/></div></div><div id="40111750" class="c"><input type="checkbox" id="c-40111750" checked=""/><div class="controls bullet"><span class="by">Vosporos</span><span>|</span><a href="#40110144">prev</a><span>|</span><label class="collapse" for="c-40111750">[-]</label><label class="expand" for="c-40111750">[1 more]</label></div><br/><div class="children"><div class="content">The mario kart Wii retro-players have you covered with ARMv8: <a href="https:&#x2F;&#x2F;mariokartwii.com&#x2F;armv8&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mariokartwii.com&#x2F;armv8&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>