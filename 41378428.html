<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724922069026" as="style"/><link rel="stylesheet" href="styles.css?v=1724922069026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.lightbluetouchpaper.org/2022/07/22/formal-cheri/">Formal CHERI: design-time proof of full-scale architecture security properties (2022)</a> <span class="domain">(<a href="https://www.lightbluetouchpaper.org">www.lightbluetouchpaper.org</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>41 comments</span></div><br/><div><div id="41379146" class="c"><input type="checkbox" id="c-41379146" checked=""/><div class="controls bullet"><span class="by">anotherhue</span><span>|</span><a href="#41382026">next</a><span>|</span><label class="collapse" for="c-41379146">[-]</label><label class="expand" for="c-41379146">[21 more]</label></div><br/><div class="children"><div class="content">I&#x27;d take this over incremental clock speed improvements any day.</div><br/><div id="41379198" class="c"><input type="checkbox" id="c-41379198" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41379146">parent</a><span>|</span><a href="#41382026">next</a><span>|</span><label class="collapse" for="c-41379198">[-]</label><label class="expand" for="c-41379198">[20 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been a huge fan of CHERI for years, but unfortunately the hardware is <i>super</i> closed (huge research institutions only). Hopefully there will be a hardware option for hobbyists one of these years (the virtual machines don&#x27;t interest me).</div><br/><div id="41379546" class="c"><input type="checkbox" id="c-41379546" checked=""/><div class="controls bullet"><span class="by">gnufx</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379198">parent</a><span>|</span><a href="#41384521">next</a><span>|</span><label class="collapse" for="c-41379546">[-]</label><label class="expand" for="c-41379546">[8 more]</label></div><br/><div class="children"><div class="content">I wonder why emulators aren&#x27;t interesting for a hobbyist.  However, there are FPGA implementations [1], and micro-controller-type systems on FPGA available commercially [2].<p>[3] has a list of publications for the rigorous engineering agenda.<p>1. <a href="https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;research&#x2F;security&#x2F;ctsrd&#x2F;cheri&#x2F;cheri-risc-v.html#cores" rel="nofollow">https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;research&#x2F;security&#x2F;ctsrd&#x2F;cheri&#x2F;cheri...</a><p>2. <a href="https:&#x2F;&#x2F;cheriot.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cheriot.org&#x2F;</a><p>3. <a href="https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;research&#x2F;security&#x2F;ctsrd&#x2F;cheri&#x2F;cheri-formal.html" rel="nofollow">https:&#x2F;&#x2F;www.cl.cam.ac.uk&#x2F;research&#x2F;security&#x2F;ctsrd&#x2F;cheri&#x2F;cheri...</a></div><br/><div id="41379955" class="c"><input type="checkbox" id="c-41379955" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379546">parent</a><span>|</span><a href="#41383343">prev</a><span>|</span><a href="#41384521">next</a><span>|</span><label class="collapse" for="c-41379955">[-]</label><label class="expand" for="c-41379955">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder why emulators aren&#x27;t interesting for a hobbyist.<p>I have the Rust programming language to fill the software part of this niche. The hardware part of CHERI is what makes it interesting to me.<p>(e.g. I&#x27;ve tinkered with Rust bootloaders before, and it doesn&#x27;t matter too much whether the emulator is CHERI or not since Rust itself lets me express memory safety in the type system.)</div><br/><div id="41385821" class="c"><input type="checkbox" id="c-41385821" checked=""/><div class="controls bullet"><span class="by">nwf</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379955">parent</a><span>|</span><a href="#41384521">next</a><span>|</span><label class="collapse" for="c-41385821">[-]</label><label class="expand" for="c-41385821">[5 more]</label></div><br/><div class="children"><div class="content">&gt; it doesn&#x27;t matter too much whether the emulator is CHERI or not since Rust itself lets me express memory safety in the type system<p>You might be interested in a <i>very</i> timely blog post: <a href="https:&#x2F;&#x2F;cheriot.org&#x2F;cheri&#x2F;myths&#x2F;2024&#x2F;08&#x2F;28&#x2F;cheri-myths-safe-languages.html" rel="nofollow">https:&#x2F;&#x2F;cheriot.org&#x2F;cheri&#x2F;myths&#x2F;2024&#x2F;08&#x2F;28&#x2F;cheri-myths-safe-...</a></div><br/><div id="41386385" class="c"><input type="checkbox" id="c-41386385" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41385821">parent</a><span>|</span><a href="#41386480">next</a><span>|</span><label class="collapse" for="c-41386385">[-]</label><label class="expand" for="c-41386385">[3 more]</label></div><br/><div class="children"><div class="content">&gt; CHERI doesn’t guarantee that your code is free from memory-safety errors, it guarantees that any memory-safety bugs will trap and not affect confidentiality or integrity of your program.<p>That sounds an awful lot like ensuring your code is free from memory-safety errors.  A language which always traps on erroneous memory accesses <i>is</i> a memory safe language, so if CHERI really guarantees what that sentence says, then C on CHERI hardware is memory safe.</div><br/><div id="41386496" class="c"><input type="checkbox" id="c-41386496" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41386385">parent</a><span>|</span><a href="#41386480">next</a><span>|</span><label class="collapse" for="c-41386496">[-]</label><label class="expand" for="c-41386496">[2 more]</label></div><br/><div class="children"><div class="content">C on CHERI hardware is not magically memory-safe. CHERI just traps on memory-unsafety.</div><br/><div id="41387325" class="c"><input type="checkbox" id="c-41387325" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41386496">parent</a><span>|</span><a href="#41386480">next</a><span>|</span><label class="collapse" for="c-41387325">[-]</label><label class="expand" for="c-41387325">[1 more]</label></div><br/><div class="children"><div class="content">If it traps on <i>all</i> things that would otherwise be memory-unsafety then it is memory safe.  If trapping doesn&#x27;t count as memory safe, then e.g. Rust isn&#x27;t memory safe, since it traps on OOB accesses to arrays.</div><br/></div></div></div></div></div></div><div id="41386480" class="c"><input type="checkbox" id="c-41386480" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41385821">parent</a><span>|</span><a href="#41386385">prev</a><span>|</span><a href="#41384521">next</a><span>|</span><label class="collapse" for="c-41386480">[-]</label><label class="expand" for="c-41386480">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not talking about writing robust software, I&#x27;m talking about having fun - Rust&#x27;s type system already provides the type of fun that I would have gotten from a CHERI emulator. That&#x27;s why only getting to own physical CHERI hardware would truly pique my interest.<p>That article indeed is quite timely. I do agree with it. Slightly different angle though.</div><br/></div></div></div></div></div></div></div></div><div id="41384521" class="c"><input type="checkbox" id="c-41384521" checked=""/><div class="controls bullet"><span class="by">c-c-c-c-c</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379198">parent</a><span>|</span><a href="#41379546">prev</a><span>|</span><a href="#41385846">next</a><span>|</span><label class="collapse" for="c-41384521">[-]</label><label class="expand" for="c-41384521">[1 more]</label></div><br/><div class="children"><div class="content">CHERIoT chips will be available early next year from SCI Semiconductor iirc. I have heard of some samples floating around</div><br/></div></div><div id="41385846" class="c"><input type="checkbox" id="c-41385846" checked=""/><div class="controls bullet"><span class="by">nwf</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379198">parent</a><span>|</span><a href="#41384521">prev</a><span>|</span><a href="#41379222">next</a><span>|</span><label class="collapse" for="c-41385846">[-]</label><label class="expand" for="c-41385846">[2 more]</label></div><br/><div class="children"><div class="content">FWIW...<p>Morello boards are hard to come by, but there have been efforts to offer cloud-computing style use of them, especially now that bhyve support exists; if you&#x27;re interested I can try to find out more (I&#x27;d offer you time on <i>my</i> cloud-computing Morello cluster from MSR, but it&#x27;s offline for silly reasons).  The &quot;Big CHERI&quot; RISC-V FPGA boards are indeed quite expensive, but CHERIoT-Ibex runs on the Arty A7 or the purpose-built Sonata board, and those are much more reasonable.  (I&#x27;d still love to see it brought up on cheaper boards, too...)</div><br/><div id="41386516" class="c"><input type="checkbox" id="c-41386516" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41385846">parent</a><span>|</span><a href="#41379222">next</a><span>|</span><label class="collapse" for="c-41386516">[-]</label><label class="expand" for="c-41386516">[1 more]</label></div><br/><div class="children"><div class="content">Morello is definitely what I&#x27;d been eyeing for a while. AFAICT those are real systems (somewhat like HiFive Unleashed) and not just embedded chips (although they are embedded chips too). I&#x27;m kind of bored of microcomputers (Raspberry Pi et al.).</div><br/></div></div></div></div><div id="41379465" class="c"><input type="checkbox" id="c-41379465" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379198">parent</a><span>|</span><a href="#41379222">prev</a><span>|</span><a href="#41382026">next</a><span>|</span><label class="collapse" for="c-41379465">[-]</label><label class="expand" for="c-41379465">[7 more]</label></div><br/><div class="children"><div class="content">This project shares so many foundational computing ideals this represents the best aspects of “the many eyes surfacing not just bugs but assumptions”.<p>I’m actually more interested in developing from the riscV branch.<p>Thinking about computers in the 100 year time frame I decided that processing “local” symbols is better than more sophisticated processes. The risc-V direct access to symbol development is where I want to start defining my “local” symbols.<p>The hope is that this line of thought will reduce the number of abstraction layers between the user and their environment.<p>CHERI having these concepts defined for risc-v creates a foundation for local processing
Of symbols with a “good computing seal of integrity. I also see it as leading to less re-invention which should help progress.</div><br/><div id="41380092" class="c"><input type="checkbox" id="c-41380092" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379465">parent</a><span>|</span><a href="#41379580">next</a><span>|</span><label class="collapse" for="c-41380092">[-]</label><label class="expand" for="c-41380092">[5 more]</label></div><br/><div class="children"><div class="content">Hi, sorry, this is all quite a bit above my head but I am interested in alternate architectures, would you mind expanding on what kinds of symbols you&#x27;re talking about? My mind jumps to the members of an instruction set, but I assume you would have called them instructions in that case, what&#x27;s the alternative to a local symbol?</div><br/><div id="41382287" class="c"><input type="checkbox" id="c-41382287" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41380092">parent</a><span>|</span><a href="#41380928">next</a><span>|</span><label class="collapse" for="c-41382287">[-]</label><label class="expand" for="c-41382287">[3 more]</label></div><br/><div class="children"><div class="content">Sorry I&#x27;m always trying to keep it simple.<p>The symbols I&#x27;m discussing were first documented by Claude Shannon. When I&#x27;m discussing symbols or large circuits I consider them interchangeable views of the same thing. They represent each other.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Claude_Shannon" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Claude_Shannon</a><p>I&#x27;m actually a designer so if I wanted to describe them as instructions I easily could. I&#x27;m a stickler for language so I believe that the use of the term instructions limits the conversation because it is too specific to communicate what I&#x27;m thinking about.<p>I would say an early example local symbol development might be libC. Our current computing environment evolved from the Personal Computing revolution and the internet. This came about through commercial interests and public adoption. I see this development as reaffirming the ideals first proposed by the &quot;mother of all demos&quot;.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Mother_of_All_Demos" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Mother_of_All_Demos</a><p>What I consider a &quot;local&quot; symbol is being demonstrated by Apple with their on device ML. The highest ideal to me is that everyone develops their own personal symbol table of digital services. I see CHERI as offering the fast track to that type of computing. I see this a integrating rather than programming.</div><br/><div id="41383220" class="c"><input type="checkbox" id="c-41383220" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41382287">parent</a><span>|</span><a href="#41380928">next</a><span>|</span><label class="collapse" for="c-41383220">[-]</label><label class="expand" for="c-41383220">[2 more]</label></div><br/><div class="children"><div class="content">Intriguing, thanks, I&#x27;ll have to marinate on that.<p>I&#x27;m a big fan of the mother of all demos. Have you happened to have read &quot;what the dormouse said&quot; ? It has a great narrative of that event including all the behind the scenes action that Stewart Brand contributed, like setting up the TV broadcast truck on top of the hill to relay the video output and importantly the <i>sounds</i> of the mainframe back in Menlo park.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;What_the_Dormouse_Said" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;What_the_Dormouse_Said</a></div><br/><div id="41383368" class="c"><input type="checkbox" id="c-41383368" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41383220">parent</a><span>|</span><a href="#41380928">next</a><span>|</span><label class="collapse" for="c-41383368">[-]</label><label class="expand" for="c-41383368">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t read that book yet. I have been meaning to but just haven&#x27;t gotten to it.<p>I can&#x27;t believe we can watch the &quot;mother of all demos&quot;. That alone proves its significance.<p>My favorite aspect of the demo is that it reveals that our human computing desires are universal and have been there from the start. It has taken generations to achieve the mass adoptions of these ideas. This realization takes the mystique away from the BigCo and their services. They are simple human desires for technology that were obvious from the beginning.</div><br/></div></div></div></div></div></div></div></div><div id="41379580" class="c"><input type="checkbox" id="c-41379580" checked=""/><div class="controls bullet"><span class="by">gnufx</span><span>|</span><a href="#41379146">root</a><span>|</span><a href="#41379465">parent</a><span>|</span><a href="#41380092">prev</a><span>|</span><a href="#41382026">next</a><span>|</span><label class="collapse" for="c-41379580">[-]</label><label class="expand" for="c-41379580">[1 more]</label></div><br/><div class="children"><div class="content">See the references I just posted, crossing with that, for CHERI-RISC-V if others are interested.</div><br/></div></div></div></div></div></div></div></div><div id="41382026" class="c"><input type="checkbox" id="c-41382026" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41379146">prev</a><span>|</span><a href="#41379458">next</a><span>|</span><label class="collapse" for="c-41382026">[-]</label><label class="expand" for="c-41382026">[15 more]</label></div><br/><div class="children"><div class="content">Fil-C is now best case 2x slower than normal C, worst case about 6x, and I haven’t even finished implementing the obvious optimizations.<p>I bet that the Intel chip I’m on is more than 6x faster than any of the CHERI hardware.<p>Fil-C has a more deterministic and safer handling of use-after-free and it’s flexible enough to run CPython (pretty sure CPython was too much for CHERI’s capabilities).<p>If you consider that:<p>- Fil-C will get faster even without architecture help<p>- Fil-C runs on normal HW<p>- it probably only takes a small extension to the HW to eliminate any remaining Fil-C overhead (a much smaller extension than CHERI).<p>- Fil-C is just a thing I pulled out of my ass in the last 10 months or so and is a totally solo spare-time project (I.e. if a real compiler team did this full time they’d probably make it even better than where I’m at)<p>Then it sure does seem like CHERI is going to be doomed long term.</div><br/><div id="41388074" class="c"><input type="checkbox" id="c-41388074" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41382026">parent</a><span>|</span><a href="#41383275">next</a><span>|</span><label class="collapse" for="c-41388074">[-]</label><label class="expand" for="c-41388074">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge">https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge</a></div><br/></div></div><div id="41383275" class="c"><input type="checkbox" id="c-41383275" checked=""/><div class="controls bullet"><span class="by">gchadwick</span><span>|</span><a href="#41382026">parent</a><span>|</span><a href="#41388074">prev</a><span>|</span><a href="#41383242">next</a><span>|</span><label class="collapse" for="c-41383275">[-]</label><label class="expand" for="c-41383275">[2 more]</label></div><br/><div class="children"><div class="content">Improved hardware based abstractions to provide stronger security and better ways to isolate software components just seems like a good idea. Yes you can certainly do plenty in software (in particular using language like Rust) but presumably we still want hardware enforced security properties? So why not improve those as well as software?<p>To put it another way why not remove existing hardware security abstractions we do have? Ditch virtualization (or hugely strip it back), get rid of different privilege levels, loose page-table enforced permissions. After all you can just build safe software why bother with these things?<p>I for one don&#x27;t think this is a sensible line of argument, defence in depth is a good idea, build your software to be as secure as possible then build your hardware such that if there is some flaw in your software&#x27;s defences you can keep things contained though hardware abstractions.<p>Even with improved languages there&#x27;s a giant body of existing code you need to work with, with compartmentalization in CHERI you can keep this stuff safely contained. Plus how do you guarantee everything running on the system has been built in your safe language and compiled with your blessed known good compiler? Feasible in some places (like embedded systems) far less feasible in others.</div><br/><div id="41383522" class="c"><input type="checkbox" id="c-41383522" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41383275">parent</a><span>|</span><a href="#41383242">next</a><span>|</span><label class="collapse" for="c-41383522">[-]</label><label class="expand" for="c-41383522">[1 more]</label></div><br/><div class="children"><div class="content">Fil-C is not ABI compatible with regular C, so there’s no way to accidentally forget to compile some part of your stack with Fil-C.<p>If changing all the HW we use was as easy as waving a wand, then your argument would be sound. Unfortunately, it’s super hard to get folks to use different HW. And because of how silicon economics work out, a new upstart architecture with limited users is sure to experience slower perf scaling than the mainstream HW. That strongly disincentivizes anyone from being an early adopter of exotic new HW. I think that’s why CHERI isn’t mainstream yet despite a decade of investment.<p>Hence why even ignoring Fil-C, it’s probably more realistic to rewrite stuff in Rust than it is to switch to CHERI. Fil-C adds a third option where you pay some perf but you don’t have to rewrite your code or switch what HW you use. CHERI also costs perf - practically speaking, available CHERI HW is more than 6x slower than the HW Fil-C can run on. That’s fundamental, due to silicon economics.<p>Finally, I think you’re overselling the CHERI defense in depth. My understanding is that CHERIoT doesn’t use virtual memory and that there are subtle reasons why virtual memory and CHERI put together gets weird, especially if you want to support capability revocation. On the other hand, Fil-C works on top of virtual memory so you get both virtual memory protection and capability protection, hence more defense in depth.</div><br/></div></div></div></div><div id="41383242" class="c"><input type="checkbox" id="c-41383242" checked=""/><div class="controls bullet"><span class="by">pitaj</span><span>|</span><a href="#41382026">parent</a><span>|</span><a href="#41383275">prev</a><span>|</span><a href="#41382633">next</a><span>|</span><label class="collapse" for="c-41383242">[-]</label><label class="expand" for="c-41383242">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an interesting approach. A hybrid software with limited hardware change is interesting.<p>&gt; Fil-C will get faster even without architecture help<p>Only to a point. You&#x27;ll plateau eventually since you have checks on every dereference.</div><br/><div id="41383264" class="c"><input type="checkbox" id="c-41383264" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41383242">parent</a><span>|</span><a href="#41382633">next</a><span>|</span><label class="collapse" for="c-41383264">[-]</label><label class="expand" for="c-41383264">[3 more]</label></div><br/><div class="children"><div class="content">No, I won’t have checks on every dereference. The monotonicity of Fil-C’s capabilities makes it possible to do a lot of redundant check elimination.<p>That’s what I’m working on now. Should have some early results soon.</div><br/><div id="41383296" class="c"><input type="checkbox" id="c-41383296" checked=""/><div class="controls bullet"><span class="by">pitaj</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41383264">parent</a><span>|</span><a href="#41382633">next</a><span>|</span><label class="collapse" for="c-41383296">[-]</label><label class="expand" for="c-41383296">[2 more]</label></div><br/><div class="children"><div class="content">Obviously, removing repeated&#x2F;redundant bounds checks is a basic optimization. That&#x27;s not what I meant. My point still stands.</div><br/><div id="41383680" class="c"><input type="checkbox" id="c-41383680" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41383296">parent</a><span>|</span><a href="#41382633">next</a><span>|</span><label class="collapse" for="c-41383680">[-]</label><label class="expand" for="c-41383680">[1 more]</label></div><br/><div class="children"><div class="content">I think that check on every access is a lot different than check on some accesses.<p>That plateau might not be any different than the CHERI plateau, since at the microarch level, CHERI will have more checks since it cannot benefit from a compiler’s static reasoning about redundant check elimination.</div><br/></div></div></div></div></div></div></div></div><div id="41382633" class="c"><input type="checkbox" id="c-41382633" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41382026">parent</a><span>|</span><a href="#41383242">prev</a><span>|</span><a href="#41383426">next</a><span>|</span><label class="collapse" for="c-41382633">[-]</label><label class="expand" for="c-41382633">[4 more]</label></div><br/><div class="children"><div class="content">A big application of CHERI is embedded where you can&#x27;t just spend 6x more area&#x2F;power on software.<p>Also CHERI isn&#x27;t just about memory safety. It also supports software isolation &amp; capabilities.<p>See CherIoT for an example of both of these.</div><br/><div id="41382713" class="c"><input type="checkbox" id="c-41382713" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41382633">parent</a><span>|</span><a href="#41383426">next</a><span>|</span><label class="collapse" for="c-41382713">[-]</label><label class="expand" for="c-41382713">[3 more]</label></div><br/><div class="children"><div class="content">Fil-C is capability based and its capabilities offer stronger guarantees than CHERI’s.<p>My point is that if a single dude working solo for 10 months gets to 6x overhead in the bad case then the overhead of the software capability approach (either exactly Fil-C or something vaguely like it) is likely to be much much less than 6x in the limit. Fil-C was 200x slower just six months ago and I’m not even done optimizing. That should give you an idea of where it’s heading.</div><br/><div id="41382786" class="c"><input type="checkbox" id="c-41382786" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41382713">parent</a><span>|</span><a href="#41383426">next</a><span>|</span><label class="collapse" for="c-41382786">[-]</label><label class="expand" for="c-41382786">[2 more]</label></div><br/><div class="children"><div class="content">it would be interesting if you shared more details</div><br/><div id="41382928" class="c"><input type="checkbox" id="c-41382928" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41382786">parent</a><span>|</span><a href="#41383426">next</a><span>|</span><label class="collapse" for="c-41382928">[-]</label><label class="expand" for="c-41382928">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;deluge&#x2F;Manifesto.md">https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;delug...</a><p><a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=JRoX9_lXJFg" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=JRoX9_lXJFg</a><p>Note that both that doc and the video have old perf numbers. I’m landing optimizations all the time.</div><br/></div></div></div></div></div></div></div></div><div id="41383426" class="c"><input type="checkbox" id="c-41383426" checked=""/><div class="controls bullet"><span class="by">pitaj</span><span>|</span><a href="#41382026">parent</a><span>|</span><a href="#41382633">prev</a><span>|</span><a href="#41379458">next</a><span>|</span><label class="collapse" for="c-41383426">[-]</label><label class="expand" for="c-41383426">[3 more]</label></div><br/><div class="children"><div class="content">Recompiling everything is a non-starter in many cases.</div><br/><div id="41383535" class="c"><input type="checkbox" id="c-41383535" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41383426">parent</a><span>|</span><a href="#41379458">next</a><span>|</span><label class="collapse" for="c-41383535">[-]</label><label class="expand" for="c-41383535">[2 more]</label></div><br/><div class="children"><div class="content">If recompiling is a nonstarter then a new HW arch like CHERI is even more of a nonstarter.</div><br/><div id="41385872" class="c"><input type="checkbox" id="c-41385872" checked=""/><div class="controls bullet"><span class="by">nwf</span><span>|</span><a href="#41382026">root</a><span>|</span><a href="#41383535">parent</a><span>|</span><a href="#41379458">next</a><span>|</span><label class="collapse" for="c-41385872">[-]</label><label class="expand" for="c-41385872">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only mostly true; Big CHERI (that is, the 64-bit CHERI systems, not CHERIoT) specifically has support for running legacy binaries within capability confinement.  It&#x27;s true that we think recompiling is generally the better approach, but we can sandbox pre-CHERI libraries, for example, at library-scale granularity.</div><br/></div></div></div></div></div></div></div></div><div id="41381668" class="c"><input type="checkbox" id="c-41381668" checked=""/><div class="controls bullet"><span class="by">timhh</span><span>|</span><a href="#41379458">prev</a><span>|</span><a href="#41384561">next</a><span>|</span><label class="collapse" for="c-41381668">[-]</label><label class="expand" for="c-41381668">[1 more]</label></div><br/><div class="children"><div class="content">(2022)</div><br/></div></div></div></div></div></div></div></body></html>