<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683709263271" as="style"/><link rel="stylesheet" href="styles.css?v=1683709263271"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://groups.google.com/a/chromium.org/g/ct-policy/c/S17_j-WJ6dI">Random bit-flip invalidates certificate transparency log – again?</a> <span class="domain">(<a href="https://groups.google.com">groups.google.com</a>)</span></div><div class="subtext"><span>nickf</span> | <span>43 comments</span></div><br/><div><div id="35884294" class="c"><input type="checkbox" id="c-35884294" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#35883911">next</a><span>|</span><label class="collapse" for="c-35884294">[-]</label><label class="expand" for="c-35884294">[16 more]</label></div><br/><div class="children"><div class="content">The numbers from this Google SIGMETRICS09 paper are my usual benchmark for thinking about ECC DIMMs:<p><a href="https:&#x2F;&#x2F;www.cs.toronto.edu&#x2F;~bianca&#x2F;papers&#x2F;sigmetrics09.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.toronto.edu&#x2F;~bianca&#x2F;papers&#x2F;sigmetrics09.pdf</a><p>Their metric of “25,000 to 70,000 errors per billion device hours per megabit” is a bit hard to grapple with.  If you assume each error is a single bit then that’s 20 to 50 bytes per GB DIMM per month, or one bit per GB every two hours.</div><br/><div id="35884450" class="c"><input type="checkbox" id="c-35884450" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#35884294">parent</a><span>|</span><a href="#35884498">next</a><span>|</span><label class="collapse" for="c-35884450">[-]</label><label class="expand" for="c-35884450">[12 more]</label></div><br/><div class="children"><div class="content">&gt; or one bit per GB every two hours<p>How is that possible? Wouldn&#x27;t such an error frequency lead to user-observable problems all the time? For example, in the average statically compiled codebase, flipping a single bit in source code being edited (with the code then being saved to disk) will make it fail to compile with high probability, which would be noticed immediately. Yet I&#x27;ve never encountered this situation in practice, nor heard of anyone else encountering it, and like most people I don&#x27;t even use ECC RAM. That seems incongruent with the figure quoted above.</div><br/><div id="35884804" class="c"><input type="checkbox" id="c-35884804" checked=""/><div class="controls bullet"><span class="by">eklitzke</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884450">parent</a><span>|</span><a href="#35884717">next</a><span>|</span><label class="collapse" for="c-35884804">[-]</label><label class="expand" for="c-35884804">[5 more]</label></div><br/><div class="children"><div class="content">This paper is ~15 years old. It was published in 2009, but the data was collected 2006-2008. As densities for things like RAM increase, error rates have to decrease commensurately to hide errors from end users.<p>Additionally, Google runs hardware in their datacenters in a much more pathological way than most consumers will (e.g. they are more likely to run hardware much hotter than typical consumers).<p>The point is that the figures in the paper are an interesting starting point for discussion, but they&#x27;re not necessarily applicable to your laptop.</div><br/><div id="35884915" class="c"><input type="checkbox" id="c-35884915" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884804">parent</a><span>|</span><a href="#35884925">next</a><span>|</span><label class="collapse" for="c-35884915">[-]</label><label class="expand" for="c-35884915">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced by this argument. In practice, errors on consumer hardware seem to be <i>several orders of magnitude</i> less common than implied by the paper. If they weren&#x27;t, we&#x27;d be hearing anecdotes of one-character diffs appearing out of nowhere all the time, among many other issues.<p>It&#x27;s hard to see how this could be explained away with the slight increase in RAM densities since 2008, or different temperatures in data centers (plenty of individuals run their systems crazy hot, e.g. when the tower is stuffed with dust after years without cleaning).</div><br/></div></div><div id="35884925" class="c"><input type="checkbox" id="c-35884925" checked=""/><div class="controls bullet"><span class="by">YetAnotherNick</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884804">parent</a><span>|</span><a href="#35884915">prev</a><span>|</span><a href="#35885073">next</a><span>|</span><label class="collapse" for="c-35884925">[-]</label><label class="expand" for="c-35884925">[2 more]</label></div><br/><div class="children"><div class="content">But it should be applicable to EC2 instances, no? I have seen instances running for multiple months quite a bit of time. If there 1000s of random bit flip for any app, I think we should assume it is not running what we expect it to be running.</div><br/><div id="35884994" class="c"><input type="checkbox" id="c-35884994" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884925">parent</a><span>|</span><a href="#35885073">next</a><span>|</span><label class="collapse" for="c-35884994">[-]</label><label class="expand" for="c-35884994">[1 more]</label></div><br/><div class="children"><div class="content">It just dawned on me that EC2 is probably named that to avoid confusion with ECC.</div><br/></div></div></div></div><div id="35885073" class="c"><input type="checkbox" id="c-35885073" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884804">parent</a><span>|</span><a href="#35884925">prev</a><span>|</span><a href="#35884717">next</a><span>|</span><label class="collapse" for="c-35885073">[-]</label><label class="expand" for="c-35885073">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they are more likely to run hardware much hotter than typical consumers<p>I&#x27;d expect laptops and phones with their limited cooling capacity to run their hardware much hotter than datacenters with their expensive HVAC systems</div><br/></div></div></div></div><div id="35884717" class="c"><input type="checkbox" id="c-35884717" checked=""/><div class="controls bullet"><span class="by">jhugo</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884450">parent</a><span>|</span><a href="#35884804">prev</a><span>|</span><a href="#35884601">next</a><span>|</span><label class="collapse" for="c-35884717">[-]</label><label class="expand" for="c-35884717">[2 more]</label></div><br/><div class="children"><div class="content">One bit per GB of RAM, not per GB of processed source code (most of your RAM is likely empty most of the time, or used for stuff where a bit flip is less likely to be noticed). However, it still seems like a high estimate to me.</div><br/><div id="35884818" class="c"><input type="checkbox" id="c-35884818" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884717">parent</a><span>|</span><a href="#35884601">next</a><span>|</span><label class="collapse" for="c-35884818">[-]</label><label class="expand" for="c-35884818">[1 more]</label></div><br/><div class="children"><div class="content">I have 32 GB of RAM. If I only use 1 GB of it it&#x27;s still one bit flip in the RAM I&#x27;m using.</div><br/></div></div></div></div><div id="35884601" class="c"><input type="checkbox" id="c-35884601" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884450">parent</a><span>|</span><a href="#35884717">prev</a><span>|</span><a href="#35884498">next</a><span>|</span><label class="collapse" for="c-35884601">[-]</label><label class="expand" for="c-35884601">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s not realistic. This is as much code as goes through a CI I&#x27;m working with many times a day. I&#x27;d constantly see errors on an unknown variable if this was a real rate.</div><br/><div id="35884781" class="c"><input type="checkbox" id="c-35884781" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884601">parent</a><span>|</span><a href="#35884723">next</a><span>|</span><label class="collapse" for="c-35884781">[-]</label><label class="expand" for="c-35884781">[2 more]</label></div><br/><div class="children"><div class="content">Aren’t you forgetting the time aspect? If you’re keeping that code in RAM for just a few seconds at most then the probability of a random bit flip is negligible, even if the hourly rate is high.<p>But I agree this sounds unrealistic.</div><br/><div id="35885003" class="c"><input type="checkbox" id="c-35885003" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884781">parent</a><span>|</span><a href="#35884723">next</a><span>|</span><label class="collapse" for="c-35885003">[-]</label><label class="expand" for="c-35885003">[1 more]</label></div><br/><div class="children"><div class="content">Presumably, most of the code doesn&#x27;t change often, and consequently, should be kept in the filesystem cache and never actually read from disk. So the numbers could apply, I think.</div><br/></div></div></div></div><div id="35884723" class="c"><input type="checkbox" id="c-35884723" checked=""/><div class="controls bullet"><span class="by">teekert</span><span>|</span><a href="#35884294">root</a><span>|</span><a href="#35884601">parent</a><span>|</span><a href="#35884781">prev</a><span>|</span><a href="#35884498">next</a><span>|</span><label class="collapse" for="c-35884723">[-]</label><label class="expand" for="c-35884723">[1 more]</label></div><br/><div class="children"><div class="content">Or you are using ECC RAM?</div><br/></div></div></div></div></div></div><div id="35884498" class="c"><input type="checkbox" id="c-35884498" checked=""/><div class="controls bullet"><span class="by">proto_lambda</span><span>|</span><a href="#35884294">parent</a><span>|</span><a href="#35884450">prev</a><span>|</span><a href="#35884800">next</a><span>|</span><label class="collapse" for="c-35884498">[-]</label><label class="expand" for="c-35884498">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re off by a couple orders of magnitude there. 25e3 errors&#x2F;(1e9 h * 1e6 b) = 25e-12 errors&#x2F;hour&#x2F;bit, ~~or 4 errors&#x2F;hour&#x2F;<i>tera</i>byte.~~<p>Edit: nope, I got that last step wrong, it&#x27;s actually 200 errors&#x2F;hour&#x2F;terabyte, or 1 error&#x2F;gigabyte&#x2F;5 hours, pretty close to what you said.</div><br/></div></div><div id="35884800" class="c"><input type="checkbox" id="c-35884800" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#35884294">parent</a><span>|</span><a href="#35884498">prev</a><span>|</span><a href="#35884789">next</a><span>|</span><label class="collapse" for="c-35884800">[-]</label><label class="expand" for="c-35884800">[1 more]</label></div><br/><div class="children"><div class="content">4 bit flips per GB in a working day, in every GB of my laptop. Let&#x27;s keep using powers of 2: 256 days when I&#x27;m using it it&#x27;s 1024 bit flips per GB per year. Some will happen in unused memory, some in running programs. It&#x27;s 1024 * N bit flips in our code editor per year, were N is how many times our editor + language servers are larger than 1 GB.<p>Some in unused and unsaved data, some in code paths I&#x27;m not using. However some will probably crash a program because of a wrong or invalid machine code instruction or visibly alter data.<p>Times that per the number of people using computers. Those spelling mistakes or wrong figures were not our fault after all?<p>In a code editor people should see one character git diffs in files that are open in the editor, parked in a long unused tab (if the editor detects the change and saves it or asks to.)</div><br/></div></div><div id="35884789" class="c"><input type="checkbox" id="c-35884789" checked=""/><div class="controls bullet"><span class="by">PinguTS</span><span>|</span><a href="#35884294">parent</a><span>|</span><a href="#35884800">prev</a><span>|</span><a href="#35883911">next</a><span>|</span><label class="collapse" for="c-35884789">[-]</label><label class="expand" for="c-35884789">[1 more]</label></div><br/><div class="children"><div class="content">I never really experienced that in real life. That is the thing we need to cope with in functional safety or some call it machine safety. There are people working with (mainly) electrical machines and by possible all measures an error cause by interference, bit flip, stuck bit, … needs be detected that the worst case of dead and injured people needs to be prevented. That are things we also need to cope with in automated&#x2F;self driving cars.</div><br/></div></div></div></div><div id="35883911" class="c"><input type="checkbox" id="c-35883911" checked=""/><div class="controls bullet"><span class="by">nickf</span><span>|</span><a href="#35884294">prev</a><span>|</span><a href="#35884356">next</a><span>|</span><label class="collapse" for="c-35883911">[-]</label><label class="expand" for="c-35883911">[5 more]</label></div><br/><div class="children"><div class="content">This happened before a couple of years ago, and the problem seems to have repeated itself. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27728287" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27728287</a></div><br/><div id="35885168" class="c"><input type="checkbox" id="c-35885168" checked=""/><div class="controls bullet"><span class="by">KirillPanov</span><span>|</span><a href="#35883911">parent</a><span>|</span><a href="#35884810">next</a><span>|</span><label class="collapse" for="c-35885168">[-]</label><label class="expand" for="c-35885168">[1 more]</label></div><br/><div class="children"><div class="content">I cannot understand why they don&#x27;t use two-of-three voting to produce the log entries.<p>It doesn&#x27;t have to be three machines owned by separate organizations, or even in separate buildings.  Just three servers in the same rack, doing the same computations, and nobody signs anything unless one of the other two produces the exact same result.</div><br/></div></div><div id="35884810" class="c"><input type="checkbox" id="c-35884810" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#35883911">parent</a><span>|</span><a href="#35885168">prev</a><span>|</span><a href="#35885018">next</a><span>|</span><label class="collapse" for="c-35884810">[-]</label><label class="expand" for="c-35884810">[2 more]</label></div><br/><div class="children"><div class="content">Is coincidence plausible here?  Anyhow, Ian Fleming&#x27;s thoughts on such things seem applicable:<p>&quot;Once is happenstance. Twice is coincidence. Three times is enemy action&quot;</div><br/><div id="35885068" class="c"><input type="checkbox" id="c-35885068" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#35883911">root</a><span>|</span><a href="#35884810">parent</a><span>|</span><a href="#35885018">next</a><span>|</span><label class="collapse" for="c-35885068">[-]</label><label class="expand" for="c-35885068">[1 more]</label></div><br/><div class="children"><div class="content">Bitflips just happen. There&#x27;s a good chance the device and connection you&#x27;re using right now has had several bit flips in (unused) memory and you&#x27;ll never even know.<p>Everything is fine until these flips happen in critical code or data paths. ZFS corruption is a famous example, but there&#x27;s also DNS corruption that happens quite regularly (and has been demonstrated to be usable for malicious purposes).<p>I&#x27;m a little surprised the certificate transparency protocol doesn&#x27;t validate the incoming data well enough to detect these bit flips, but on the other hand most software I&#x27;ve seen just assumes the bytes in memory and the bytes received through the network are all what they&#x27;re supposed to be.</div><br/></div></div></div></div><div id="35885018" class="c"><input type="checkbox" id="c-35885018" checked=""/><div class="controls bullet"><span class="by">ThePowerOfFuet</span><span>|</span><a href="#35883911">parent</a><span>|</span><a href="#35884810">prev</a><span>|</span><a href="#35884356">next</a><span>|</span><label class="collapse" for="c-35885018">[-]</label><label class="expand" for="c-35885018">[1 more]</label></div><br/><div class="children"><div class="content">Same guy too (Andrew Ayer). Someone is keeping an eye on it!</div><br/></div></div></div></div><div id="35884356" class="c"><input type="checkbox" id="c-35884356" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#35883911">prev</a><span>|</span><a href="#35884565">next</a><span>|</span><label class="collapse" for="c-35884356">[-]</label><label class="expand" for="c-35884356">[5 more]</label></div><br/><div class="children"><div class="content">&gt;Unfortunately, it is not possible for the log to recover from this.<p>That sounds bad. What does this mean? Does the entire log need to be thrown out, and a new log needs to be create to start from scratch?</div><br/><div id="35884506" class="c"><input type="checkbox" id="c-35884506" checked=""/><div class="controls bullet"><span class="by">ryanwhitney</span><span>|</span><a href="#35884356">parent</a><span>|</span><a href="#35884565">next</a><span>|</span><label class="collapse" for="c-35884506">[-]</label><label class="expand" for="c-35884506">[4 more]</label></div><br/><div class="children"><div class="content">Comment by the author (from the last time this happened) seemed helpful:<p>&quot;OP here. Unless you work for a certificate authority or a web browser, this event will have zero impact on you. While this particular CT log has failed, there are many other CT logs, and certificates are required to be logged to 2-3 different logs (depending on certificate lifetime) so that if a log fails web browsers can rely on one of the other logs to ensure the certificate is publicly logged.<p>This is the 8th log to fail (although the first caused by a bit flip), and log failure has never caused a user-facing certificate error. The overall CT ecosystem has proven very resilient, even if a bit flip can take out an individual log.<p>(P.S. No one knows if it was really a cosmic ray or not. But it&#x27;s almost certainly a random hardware error rather than a software bug, and cosmic ray is just the informal term people like to use for unexplained hardware bit flips.)&quot;<p>-<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27731210" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27731210</a></div><br/><div id="35884913" class="c"><input type="checkbox" id="c-35884913" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#35884356">root</a><span>|</span><a href="#35884506">parent</a><span>|</span><a href="#35884768">next</a><span>|</span><label class="collapse" for="c-35884913">[-]</label><label class="expand" for="c-35884913">[1 more]</label></div><br/><div class="children"><div class="content">Cosmic rays are common. There is a detector exposed to the public in the Toledo metro station at Naples, Italy. It&#x27;s placed 40 meters underground. In this short video you can see 2 cosmic rays passing by <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=K_puq6U7khg">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=K_puq6U7khg</a></div><br/></div></div><div id="35884768" class="c"><input type="checkbox" id="c-35884768" checked=""/><div class="controls bullet"><span class="by">vivegi</span><span>|</span><a href="#35884356">root</a><span>|</span><a href="#35884506">parent</a><span>|</span><a href="#35884913">prev</a><span>|</span><a href="#35884565">next</a><span>|</span><label class="collapse" for="c-35884768">[-]</label><label class="expand" for="c-35884768">[2 more]</label></div><br/><div class="children"><div class="content">I have no knowledge of how the CAs maintain the CT logs.<p>What is the process for a CA to <i>rebuild</i> the CT log, if one exists? Is it something like what is illustrated below?<p>Let CA1, CA2, CA3 and CA4 be different certificate authorities. The set enumerated alongside each CA is the set of certificates logged into its CT log.<p><pre><code>  CA1 : {c1, c2, c3}

  CA2 : {c2, c3&#x27;}

  CA3 : {c1, c2}

  CA4 : {c1, c3}
</code></pre>
Suppose CA2 is where an issue was detected with certificate c3 (the anomalous cert is denoted by c3&#x27;) and CA2 trusts CA3 and CA4, then the set {c1, c2, c3} can be constructed after verifying the CT logs of CA3 and CA4 and merging their logs.<p>Is that kind of how it would work or would CA2 just truncate its log and restart from this point forward?</div><br/><div id="35884830" class="c"><input type="checkbox" id="c-35884830" checked=""/><div class="controls bullet"><span class="by">detaro</span><span>|</span><a href="#35884356">root</a><span>|</span><a href="#35884768">parent</a><span>|</span><a href="#35884565">next</a><span>|</span><label class="collapse" for="c-35884830">[-]</label><label class="expand" for="c-35884830">[1 more]</label></div><br/><div class="children"><div class="content">The broken log will just be replaced by a new one.</div><br/></div></div></div></div></div></div></div></div><div id="35884565" class="c"><input type="checkbox" id="c-35884565" checked=""/><div class="controls bullet"><span class="by">aeaa3</span><span>|</span><a href="#35884356">prev</a><span>|</span><a href="#35884753">next</a><span>|</span><label class="collapse" for="c-35884565">[-]</label><label class="expand" for="c-35884565">[1 more]</label></div><br/><div class="children"><div class="content">Do we know whether the machine on which this occurred had ECC memory?</div><br/></div></div><div id="35884753" class="c"><input type="checkbox" id="c-35884753" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#35884565">prev</a><span>|</span><a href="#35884154">next</a><span>|</span><label class="collapse" for="c-35884753">[-]</label><label class="expand" for="c-35884753">[8 more]</label></div><br/><div class="children"><div class="content">This is perhaps one of the few legitimate use cases for a distributed blockchain. Then several nodes have to agree for the chain to advance.</div><br/><div id="35884847" class="c"><input type="checkbox" id="c-35884847" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#35884753">parent</a><span>|</span><a href="#35884895">next</a><span>|</span><label class="collapse" for="c-35884847">[-]</label><label class="expand" for="c-35884847">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is perhaps one of the few legitimate use cases for a distributed blockchain.<p>It&#x27;s incredible how a global propaganda machine has turned one of the most transformative technologies of our time into something that&#x27;s considered shady and even crime-adjacent by default, and for which &quot;legitimate&quot; use cases are somehow considered special, when in reality there are countless potential applications for distributed ledgers. But the powers that be want to maintain centralized control at all costs, and their pushback has clearly reached even the minds of HN users.</div><br/><div id="35884942" class="c"><input type="checkbox" id="c-35884942" checked=""/><div class="controls bullet"><span class="by">automatic6131</span><span>|</span><a href="#35884753">root</a><span>|</span><a href="#35884847">parent</a><span>|</span><a href="#35884895">next</a><span>|</span><label class="collapse" for="c-35884942">[-]</label><label class="expand" for="c-35884942">[4 more]</label></div><br/><div class="children"><div class="content">Or, hear me out, the technology sucks. And a great deal of software engineers here can see that the Emperor has no clothes.</div><br/><div id="35884985" class="c"><input type="checkbox" id="c-35884985" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#35884753">root</a><span>|</span><a href="#35884942">parent</a><span>|</span><a href="#35884895">next</a><span>|</span><label class="collapse" for="c-35884985">[-]</label><label class="expand" for="c-35884985">[3 more]</label></div><br/><div class="children"><div class="content">If you can name an alternative technology that solves the same problem (integrity consensus without centralized authority), I&#x27;m all ears.</div><br/><div id="35885189" class="c"><input type="checkbox" id="c-35885189" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#35884753">root</a><span>|</span><a href="#35884985">parent</a><span>|</span><a href="#35885092">next</a><span>|</span><label class="collapse" for="c-35885189">[-]</label><label class="expand" for="c-35885189">[1 more]</label></div><br/><div class="children"><div class="content">Why do we care about the centralized authority part so much? There are a lot of problem domains where zero trust is not desirable or understood to be a fool&#x27;s errand.<p>In a B2B setting where you have 3 parties working together on an integration project wherein 2 parties are B2B vendors and the 3rd is a B2C org, where does the centralization reside? What about vendors of the B2B vendors? I honestly don&#x27;t know what we are getting at with this word anymore.<p>If we were to apply something like SQL Server w&#x2F; Ledger tables (i.e. centralized blockchain) to this kind of problem in my shop, we would almost certainly find a solution that all parties would find agreeable. This forces you to trust 1-2 parties (i.e. Microsoft themselves), but in the above we agree that for many (most?) areas this may likely be <i>explicitly desirable</i>. There are also technologies (again, centralized) that provide non-repudiation through the hosting layer itself. Example of this being something like Azure Confidential Ledger.<p>The part where this seems to get frustrating for people is the desired crystalline &amp; immediate nature of the system. If you operate with the tiniest amount of extra flexibility you can get so much more done - E.g. perhaps the business can review a data tamper event tomorrow with their partners on the phone.</div><br/></div></div><div id="35885092" class="c"><input type="checkbox" id="c-35885092" checked=""/><div class="controls bullet"><span class="by">automatic6131</span><span>|</span><a href="#35884753">root</a><span>|</span><a href="#35884985">parent</a><span>|</span><a href="#35885189">prev</a><span>|</span><a href="#35884895">next</a><span>|</span><label class="collapse" for="c-35885092">[-]</label><label class="expand" for="c-35885092">[1 more]</label></div><br/><div class="children"><div class="content">Try again when you can solve the problem without introducing a dozen others that make everything, overall, worse.<p>Until then, trusting a central authority will do just fine. It works well enough now.</div><br/></div></div></div></div></div></div></div></div><div id="35884895" class="c"><input type="checkbox" id="c-35884895" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#35884753">parent</a><span>|</span><a href="#35884847">prev</a><span>|</span><a href="#35884898">next</a><span>|</span><label class="collapse" for="c-35884895">[-]</label><label class="expand" for="c-35884895">[1 more]</label></div><br/><div class="children"><div class="content">Why?<p>What would a distributed agreement do that isn&#x27;t achieved by the existing multiple logs per cert?</div><br/></div></div><div id="35884898" class="c"><input type="checkbox" id="c-35884898" checked=""/><div class="controls bullet"><span class="by">nsteel</span><span>|</span><a href="#35884753">parent</a><span>|</span><a href="#35884895">prev</a><span>|</span><a href="#35884154">next</a><span>|</span><label class="collapse" for="c-35884898">[-]</label><label class="expand" for="c-35884898">[1 more]</label></div><br/><div class="children"><div class="content">(More&#x2F;stronger) ECC would seem a better choice. What am I missing?</div><br/></div></div></div></div><div id="35884154" class="c"><input type="checkbox" id="c-35884154" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#35884753">prev</a><span>|</span><a href="#35884297">next</a><span>|</span><label class="collapse" for="c-35884154">[-]</label><label class="expand" for="c-35884154">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s on the 4th line where it says<p>00000030: 9126 9384 ....<p>Instead of 9284 ....</div><br/></div></div><div id="35884297" class="c"><input type="checkbox" id="c-35884297" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#35884154">prev</a><span>|</span><a href="#35884358">next</a><span>|</span><label class="collapse" for="c-35884297">[-]</label><label class="expand" for="c-35884297">[2 more]</label></div><br/><div class="children"><div class="content">Interestingly, Google has a team of engineers dedicated to detecting hardware prone to these kinds of errors by perpetually QAing devices in the field. You can then replace the node before it breaks something important.</div><br/><div id="35885001" class="c"><input type="checkbox" id="c-35885001" checked=""/><div class="controls bullet"><span class="by">nsteel</span><span>|</span><a href="#35884297">parent</a><span>|</span><a href="#35884358">next</a><span>|</span><label class="collapse" for="c-35885001">[-]</label><label class="expand" for="c-35885001">[1 more]</label></div><br/><div class="children"><div class="content">I would hope, at the very least, everyone doing important work is using ECC and actively monitoring their correction counters. This should be automated.<p>We do a lot of extra testing on top of our vendor&#x27;s to catch weak bitcells before a device is shipped to customers. Over many generations of tech, RAM faults have always been a small but constant source of faults.</div><br/></div></div></div></div><div id="35884358" class="c"><input type="checkbox" id="c-35884358" checked=""/><div class="controls bullet"><span class="by">sushidev</span><span>|</span><a href="#35884297">prev</a><span>|</span><a href="#35884231">next</a><span>|</span><label class="collapse" for="c-35884358">[-]</label><label class="expand" for="c-35884358">[2 more]</label></div><br/><div class="children"><div class="content">what happened here?</div><br/><div id="35884412" class="c"><input type="checkbox" id="c-35884412" checked=""/><div class="controls bullet"><span class="by">swixmix</span><span>|</span><a href="#35884358">parent</a><span>|</span><a href="#35884231">next</a><span>|</span><label class="collapse" for="c-35884412">[-]</label><label class="expand" for="c-35884412">[1 more]</label></div><br/><div class="children"><div class="content">an append-only log became non-writable earlier than expected</div><br/></div></div></div></div></div></div></div></div></div></body></html>