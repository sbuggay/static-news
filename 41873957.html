<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729242071367" as="style"/><link rel="stylesheet" href="styles.css?v=1729242071367"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://neon.tech/blog/why-does-everyone-run-ancient-postgres-versions">Why does everyone run ancient Postgres versions?</a> <span class="domain">(<a href="https://neon.tech">neon.tech</a>)</span></div><div class="subtext"><span>davidgomes</span> | <span>161 comments</span></div><br/><div><div id="41877487" class="c"><input type="checkbox" id="c-41877487" checked=""/><div class="controls bullet"><span class="by">noirscape</span><span>|</span><a href="#41877172">next</a><span>|</span><label class="collapse" for="c-41877487">[-]</label><label class="expand" for="c-41877487">[1 more]</label></div><br/><div class="children"><div class="content">Because the actual process of upgrading Postgres is terrible.<p>I say this as someone who absolutely loves using it, but the actual process of upgrading Postgres is something that takes significant downtime, is error-prone and you&#x27;re often better off just dumping all the databases and reimporting them in a new folder. (A good idea in general since it&#x27;ll vacuum and compact indexes as well if you do it, combining a few maintenance routines in your upgrade path.)<p>It requires having the previous version of Postgres installed, something which can mess with a number of distro policies (not to mention docker, which is the most popular way to deploy software that will typically rely on Postgres), and unlike most software with that issue, Postgres is software you want to be managed by your distro.<p>Therefore, most people only upgrade by necessity - when their distro forces the upgrade or the version they&#x27;re using reaches EOL.</div><br/></div></div><div id="41877172" class="c"><input type="checkbox" id="c-41877172" checked=""/><div class="controls bullet"><span class="by">jgb1984</span><span>|</span><a href="#41877487">prev</a><span>|</span><a href="#41876822">next</a><span>|</span><label class="collapse" for="c-41877172">[-]</label><label class="expand" for="c-41877172">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used postgresql in most of my previous jobs, but using mariadb in my current one, and I must say it&#x27;s a joy to administer.<p>The replication and high availability that mariadb offers is rock solid, and much more advanced than what postgresql has to offer.
It works out of the box, no plugins or third party shenanigans needed, and there is &quot;one obvious way&quot; to do it. Not a dozen options like in the postgresql ecosystem, each with it&#x27;s own quirks and drawbacks.<p>Also, upgrades are a dream. I did 4 major long term stable release upgrades so far and everything was fully automatic and smooth sailing all around.<p>All of that with about 10 seconds downtime only for each upgrade, despite being a chunky 6TB database, thanks to the user friendly replication process.<p>I respect postgresql a lot, but mariadb allows me to sleep much better at night thanks to replication, smooth upgrades and no VACUUM to worry about.</div><br/><div id="41877215" class="c"><input type="checkbox" id="c-41877215" checked=""/><div class="controls bullet"><span class="by">Gud</span><span>|</span><a href="#41877172">parent</a><span>|</span><a href="#41877287">next</a><span>|</span><label class="collapse" for="c-41877215">[-]</label><label class="expand" for="c-41877215">[1 more]</label></div><br/><div class="children"><div class="content">This is highly interesting to me because I was on the PostgreSQL bandwagon way before it was cool(mostly because I’m a BSD&#x2F;MIT licensed fanatic).</div><br/></div></div></div></div><div id="41876822" class="c"><input type="checkbox" id="c-41876822" checked=""/><div class="controls bullet"><span class="by">elric</span><span>|</span><a href="#41877172">prev</a><span>|</span><a href="#41875055">next</a><span>|</span><label class="collapse" for="c-41876822">[-]</label><label class="expand" for="c-41876822">[12 more]</label></div><br/><div class="children"><div class="content">Lots of dogmatism in this discussion, it seems. A couple of things:<p>1. Most psql deployments are not exposed to the interwebz, they are typically only accessible to the applications that need them by virtue of network setup (firewalls etc). This limits the attack vector to whatever the application does. Good.<p>2. Distro vendors (RHEL et al) often stick to major psql release for the lifecycle of the OS version. If the OS lives longer than the psql major version, they take on the responsability of backporting critical security issues.<p>3. While upgrades aren&#x27;t hard, they&#x27;re not easy either.<p>4. Psql is pretty much feature complete for many workloads, and pretty stable in general. For many people, there is little need to chase the latest major version.</div><br/><div id="41877411" class="c"><input type="checkbox" id="c-41877411" checked=""/><div class="controls bullet"><span class="by">mhd</span><span>|</span><a href="#41876822">parent</a><span>|</span><a href="#41877438">next</a><span>|</span><label class="collapse" for="c-41877411">[-]</label><label class="expand" for="c-41877411">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 3. While upgrades aren&#x27;t hard, they&#x27;re not easy either.<p>And in my experience, apart from ease of use there&#x27;s also a major trust issue here. If you&#x27;re upgrading your app server framework&#x2F;language, it&#x27;s easy enough to do a rollback. With databases, people are worried that they might not notice errors right away and then you have to merge the data accumulated since the upgrade with the last backup in case of a rollback.<p>Not saying that this is entirely rational...<p>Also, new features on the SQL level are hard to sell if all you&#x27;re doing is lowest common denominator ORM (&quot;New window functions and faster lateral joins? But we&#x27;re doing all that in our code!&quot;).</div><br/></div></div><div id="41877438" class="c"><input type="checkbox" id="c-41877438" checked=""/><div class="controls bullet"><span class="by">bravetraveler</span><span>|</span><a href="#41876822">parent</a><span>|</span><a href="#41877411">prev</a><span>|</span><a href="#41877104">next</a><span>|</span><label class="collapse" for="c-41877438">[-]</label><label class="expand" for="c-41877438">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 4. Psql is pretty much feature complete for many workloads, and pretty stable in general. For many people, there is little need to chase the latest major version.<p>To drive this a little further, <i>&quot;latest and greatest&quot;</i> doesn&#x27;t always apply. I&#x27;ve chosen software - even databases - for greenfield deployments one or two releases behind for their <i>known</i> characteristics.<p>Stability doesn&#x27;t imply perfection, but rather, predictability.</div><br/></div></div><div id="41877104" class="c"><input type="checkbox" id="c-41877104" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#41876822">parent</a><span>|</span><a href="#41877438">prev</a><span>|</span><a href="#41877174">next</a><span>|</span><label class="collapse" for="c-41877104">[-]</label><label class="expand" for="c-41877104">[3 more]</label></div><br/><div class="children"><div class="content">Also:<p>5. If your IT department is spread thin already and that old version is running fine, the incentive to potentially create more work for yourself is not gigantic.</div><br/><div id="41877167" class="c"><input type="checkbox" id="c-41877167" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#41876822">root</a><span>|</span><a href="#41877104">parent</a><span>|</span><a href="#41877174">next</a><span>|</span><label class="collapse" for="c-41877167">[-]</label><label class="expand" for="c-41877167">[2 more]</label></div><br/><div class="children"><div class="content">One of the first laws of the universe that a good engineer learns is: Do not fix what is not broken.<p>And no, being old is not broken.</div><br/><div id="41877567" class="c"><input type="checkbox" id="c-41877567" checked=""/><div class="controls bullet"><span class="by">sunnybeetroot</span><span>|</span><a href="#41876822">root</a><span>|</span><a href="#41877167">parent</a><span>|</span><a href="#41877174">next</a><span>|</span><label class="collapse" for="c-41877567">[-]</label><label class="expand" for="c-41877567">[1 more]</label></div><br/><div class="children"><div class="content">I do agree, however I think it’s often easier to upgrade iteratively and deal with smaller issues that arise as opposed to upgrading a huge version diff and struggling to understand and fix all the failing parts.</div><br/></div></div></div></div></div></div><div id="41877174" class="c"><input type="checkbox" id="c-41877174" checked=""/><div class="controls bullet"><span class="by">newaccount74</span><span>|</span><a href="#41876822">parent</a><span>|</span><a href="#41877104">prev</a><span>|</span><a href="#41876901">next</a><span>|</span><label class="collapse" for="c-41877174">[-]</label><label class="expand" for="c-41877174">[3 more]</label></div><br/><div class="children"><div class="content">&gt; 3. While upgrades aren&#x27;t hard, they&#x27;re not easy either<p>I guess it depends on scale? I was surprised how easy it was on Ubuntu. There was an automatic migration script, and it worked. Took less than 5 minutes to upgrade.<p>Sure, there was downtime, but I think most applications out there can live with scheduled downtime of a few minutes.<p>If you can&#x27;t have downtime, then nothing is easy.</div><br/><div id="41877393" class="c"><input type="checkbox" id="c-41877393" checked=""/><div class="controls bullet"><span class="by">ForHackernews</span><span>|</span><a href="#41876822">root</a><span>|</span><a href="#41877174">parent</a><span>|</span><a href="#41876901">next</a><span>|</span><label class="collapse" for="c-41877393">[-]</label><label class="expand" for="c-41877393">[2 more]</label></div><br/><div class="children"><div class="content">Lots of companies pretend like they can&#x27;t afford 5 minutes of scheduled downtime. Then they end up with 12 hours of unscheduled downtime when shtf.</div><br/><div id="41877558" class="c"><input type="checkbox" id="c-41877558" checked=""/><div class="controls bullet"><span class="by">bravetraveler</span><span>|</span><a href="#41876822">root</a><span>|</span><a href="#41877393">parent</a><span>|</span><a href="#41876901">next</a><span>|</span><label class="collapse" for="c-41877558">[-]</label><label class="expand" for="c-41877558">[1 more]</label></div><br/><div class="children"><div class="content">For SRE the term of art is <i>&#x27;error budget&#x27;</i><p>To others reading, be mindful: the time databases require to upgrade depends greatly on the data stored within them&#x2F;where.</div><br/></div></div></div></div></div></div><div id="41876901" class="c"><input type="checkbox" id="c-41876901" checked=""/><div class="controls bullet"><span class="by">xvinci</span><span>|</span><a href="#41876822">parent</a><span>|</span><a href="#41877174">prev</a><span>|</span><a href="#41875055">next</a><span>|</span><label class="collapse" for="c-41876901">[-]</label><label class="expand" for="c-41876901">[3 more]</label></div><br/><div class="children"><div class="content">&quot;What the application does&quot; may not be what you think of, as it is dependent on how secure the application or the layers beneath it are. This is how people get everything pwned step by step. The database server may then reveal credentials to other apps etc.</div><br/><div id="41877188" class="c"><input type="checkbox" id="c-41877188" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41876822">root</a><span>|</span><a href="#41876901">parent</a><span>|</span><a href="#41877070">next</a><span>|</span><label class="collapse" for="c-41877188">[-]</label><label class="expand" for="c-41877188">[1 more]</label></div><br/><div class="children"><div class="content">If the database server <i>has</i> significant &quot;other apps&quot;, which it probably doesn&#x27;t.</div><br/></div></div><div id="41877070" class="c"><input type="checkbox" id="c-41877070" checked=""/><div class="controls bullet"><span class="by">elric</span><span>|</span><a href="#41876822">root</a><span>|</span><a href="#41876901">parent</a><span>|</span><a href="#41877188">prev</a><span>|</span><a href="#41875055">next</a><span>|</span><label class="collapse" for="c-41877070">[-]</label><label class="expand" for="c-41877070">[1 more]</label></div><br/><div class="children"><div class="content">Sure. Defense in depth is important. But I hope that your application is only able to talk TCP&#x2F;5432 to psql. No amount of psql upgrading will protect you against SQL injections in shitty application code.</div><br/></div></div></div></div></div></div><div id="41875055" class="c"><input type="checkbox" id="c-41875055" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#41876822">prev</a><span>|</span><a href="#41875084">next</a><span>|</span><label class="collapse" for="c-41875055">[-]</label><label class="expand" for="c-41875055">[69 more]</label></div><br/><div class="children"><div class="content">Upgrades are hard. There was no replication in the before times. The original block-level replication didn&#x27;t work among different major versions. Slony was a painful workaround based on triggers that amplified writes.<p>Newer PostgreSQL versions are better. Yet still not quite as robust or easy as MySQL.<p>At a certain scale even MySQL upgrades can be painful. At least when you cannot spare more than a few minutes of downtime.</div><br/><div id="41876174" class="c"><input type="checkbox" id="c-41876174" checked=""/><div class="controls bullet"><span class="by">darth_avocado</span><span>|</span><a href="#41875055">parent</a><span>|</span><a href="#41876232">next</a><span>|</span><label class="collapse" for="c-41876174">[-]</label><label class="expand" for="c-41876174">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At least when you cannot spare more than a few minutes of downtime.<p>I think it boils down to this. We used to constantly be running the obsolete pg version until it became an emergency mostly because upgrading with the tooling available at the time was very painful. Today however, we stay relatively up to date. Once you figure out the data replication, you can almost do blue green deployments on databases with almost no down time.</div><br/></div></div><div id="41876232" class="c"><input type="checkbox" id="c-41876232" checked=""/><div class="controls bullet"><span class="by">slotrans</span><span>|</span><a href="#41875055">parent</a><span>|</span><a href="#41876174">prev</a><span>|</span><a href="#41877268">next</a><span>|</span><label class="collapse" for="c-41876232">[-]</label><label class="expand" for="c-41876232">[20 more]</label></div><br/><div class="children"><div class="content">&quot;Not as robust as MySQL&quot;? Surely you&#x27;re joking.</div><br/><div id="41876309" class="c"><input type="checkbox" id="c-41876309" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876232">parent</a><span>|</span><a href="#41876384">next</a><span>|</span><label class="collapse" for="c-41876309">[-]</label><label class="expand" for="c-41876309">[16 more]</label></div><br/><div class="children"><div class="content">They’re not wrong. If you’ve ever spent meaningful time administering both, you’ll know that Postgres takes far more hands-on work to keep it going.<p>To be clear, I like both. Postgres has a lot more features, and is far more extensible. But there’s no getting around the fact that its MVCC implementation means that at scale, you have to worry about things that simply do not exist for MySQL: vacuuming, txid wraparound, etc.</div><br/><div id="41876650" class="c"><input type="checkbox" id="c-41876650" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876309">parent</a><span>|</span><a href="#41876387">next</a><span>|</span><label class="collapse" for="c-41876650">[-]</label><label class="expand" for="c-41876650">[5 more]</label></div><br/><div class="children"><div class="content">My experience of both is that MySQL is easier for developers, PostgreSQL is easier for sysads.<p>That was true in 2012; dunno if it still applies though.</div><br/><div id="41877270" class="c"><input type="checkbox" id="c-41877270" checked=""/><div class="controls bullet"><span class="by">GoblinSlayer</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876650">parent</a><span>|</span><a href="#41876791">next</a><span>|</span><label class="collapse" for="c-41877270">[-]</label><label class="expand" for="c-41877270">[1 more]</label></div><br/><div class="children"><div class="content">&gt;MySQL is easier for developers<p>Except that search doesn&#x27;t work, because all text is in latin1 encoding.</div><br/></div></div><div id="41876791" class="c"><input type="checkbox" id="c-41876791" checked=""/><div class="controls bullet"><span class="by">sofixa</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876650">parent</a><span>|</span><a href="#41877270">prev</a><span>|</span><a href="#41876387">next</a><span>|</span><label class="collapse" for="c-41876791">[-]</label><label class="expand" for="c-41876791">[3 more]</label></div><br/><div class="children"><div class="content">I doubt it was true in 2012, because sysadmins would be the ones trying to make it run reliably, including things like replication, upgrades, etc.<p>Pretty sure that even in 2012 MySQL had very easy to use replication, which Postgres didn&#x27;t have well into the late 2010s (does it today? It&#x27;s been a while since I&#x27;ve ran any databases).</div><br/><div id="41876810" class="c"><input type="checkbox" id="c-41876810" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876791">parent</a><span>|</span><a href="#41876387">next</a><span>|</span><label class="collapse" for="c-41876810">[-]</label><label class="expand" for="c-41876810">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I doubt it was true in 2012, because sysadmins would be the ones trying to make it run reliably, including things like replication, upgrades, etc.<p>Possibly I got it wrong and switched around which was easier on the devs and which was easier on the sysads?<p>In my defence, ISTR, when talking to sysads about MySQL vs PostgreSQL, they preferred the latter due to having less to worry about once deployed (MySQL would apparently magically lose data sometimes).</div><br/><div id="41877205" class="c"><input type="checkbox" id="c-41877205" checked=""/><div class="controls bullet"><span class="by">karamanolev</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876810">parent</a><span>|</span><a href="#41876387">next</a><span>|</span><label class="collapse" for="c-41877205">[-]</label><label class="expand" for="c-41877205">[1 more]</label></div><br/><div class="children"><div class="content">MyISAM in the olden days could&#x2F;would magically lose data. InnoDB has been the de facto standard for a while and I haven&#x27;t seen data loss attributed to it.</div><br/></div></div></div></div></div></div></div></div><div id="41876387" class="c"><input type="checkbox" id="c-41876387" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876309">parent</a><span>|</span><a href="#41876650">prev</a><span>|</span><a href="#41877061">next</a><span>|</span><label class="collapse" for="c-41876387">[-]</label><label class="expand" for="c-41876387">[7 more]</label></div><br/><div class="children"><div class="content">Yeah but you don&#x27;t need to worry about your data existing. MySQL has been known to silently fail the one job of a DB.</div><br/><div id="41876737" class="c"><input type="checkbox" id="c-41876737" checked=""/><div class="controls bullet"><span class="by">maxk42</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876387">parent</a><span>|</span><a href="#41876576">next</a><span>|</span><label class="collapse" for="c-41876737">[-]</label><label class="expand" for="c-41876737">[1 more]</label></div><br/><div class="children"><div class="content">Not in around 15 years.  You&#x27;re thinking of when MyISAM was the default storage engine for MySQL.  It has been InnoDB for over a decade.  InnoDB is very reliable - I&#x27;ve never had a single data loss incident in all that time, and I&#x27;ve managed some very large (PB-scale) and active databases.<p>Postgres is definitely more difficult to administer.</div><br/></div></div><div id="41876576" class="c"><input type="checkbox" id="c-41876576" checked=""/><div class="controls bullet"><span class="by">SavageBeast</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876387">parent</a><span>|</span><a href="#41876737">prev</a><span>|</span><a href="#41877061">next</a><span>|</span><label class="collapse" for="c-41876576">[-]</label><label class="expand" for="c-41876576">[5 more]</label></div><br/><div class="children"><div class="content">I recall this being the case A LOOOONG time ago but I haven&#x27;t heard of, read about, been warned to look out for or personally seen such a thing in forever. Have you?<p>* I&#x27;m running a lot of MySQL stuff and such a topic might be of interest to me</div><br/><div id="41876711" class="c"><input type="checkbox" id="c-41876711" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876576">parent</a><span>|</span><a href="#41876762">next</a><span>|</span><label class="collapse" for="c-41876711">[-]</label><label class="expand" for="c-41876711">[3 more]</label></div><br/><div class="children"><div class="content">From what I can tell, MySQL is supposed to be safe since 2018 if you have no data from before 2010.<p>The fact that you still can&#x27;t use DDL in transactions makes life exceedingly <i>painful</i>, but it&#x27;s technically safe if you write your migration code carefully enough.</div><br/><div id="41877299" class="c"><input type="checkbox" id="c-41877299" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876711">parent</a><span>|</span><a href="#41876795">next</a><span>|</span><label class="collapse" for="c-41877299">[-]</label><label class="expand" for="c-41877299">[1 more]</label></div><br/><div class="children"><div class="content">Some places still have columns declared as utf8 instead of utf8mb4, and there&#x27;s a special place in hell for authors of the MySQL general clusterfuck regarding encodings - it was all nice and great if you didn&#x27;t care about anything other than latin1 or ASCII - go outside that before utf8 option and it was horror that even experienced operators managed to fuckup (I have a badge from a Google conference in 2017 with nicely visible effect of &quot;we have mixed up one of the three separate encoding settings in MySQL and now you have mojibake in your badge&quot;).<p>And then there&#x27;s UTF8 not actually being UTF8, which can result in total lockup of a table if someone inputs a character that does not fit in UCS-2 and now you need to recover the database from backup and preferably convert all instances of utf8 to utf8mb4, because fuck you that&#x27;s why.</div><br/></div></div><div id="41876795" class="c"><input type="checkbox" id="c-41876795" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876711">parent</a><span>|</span><a href="#41877299">prev</a><span>|</span><a href="#41876762">next</a><span>|</span><label class="collapse" for="c-41876795">[-]</label><label class="expand" for="c-41876795">[1 more]</label></div><br/><div class="children"><div class="content">Lack of transactional DDL is certainly painful, but not unique for MySQL. Oracle doesn&#x27;t support it either.</div><br/></div></div></div></div><div id="41876762" class="c"><input type="checkbox" id="c-41876762" checked=""/><div class="controls bullet"><span class="by">elisbce</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876576">parent</a><span>|</span><a href="#41876711">prev</a><span>|</span><a href="#41877061">next</a><span>|</span><label class="collapse" for="c-41876762">[-]</label><label class="expand" for="c-41876762">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is messy when you want your MySQL databases to be mission critical in production, e.g. handling a large amount of customer data. Historically MySQL&#x27;s High Availability architecture has a lot of design and implementation issues because it was an afterthought. Dealing with large amount of critical data means you need it to be performant, reliable and available at the same time, which is hard and requires you to deal with caching, sharding, replication, network issues, zone&#x2F;resource planning, failovers, leader elections and semi-sync bugs, corrupted logs, manually fixing bad queries that killed the database, data migration, version upgrades, etc. There is a reason why big corps like Google&#x2F;Meta has dedicated teams of experts (like people who actually wrote the HA features) to maintain their mission critical MySQL deployments.</div><br/></div></div></div></div></div></div><div id="41877061" class="c"><input type="checkbox" id="c-41877061" checked=""/><div class="controls bullet"><span class="by">pritambarhate</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876309">parent</a><span>|</span><a href="#41876387">prev</a><span>|</span><a href="#41876384">next</a><span>|</span><label class="collapse" for="c-41877061">[-]</label><label class="expand" for="c-41877061">[3 more]</label></div><br/><div class="children"><div class="content">My experience has been exactly opposite. Ability to do Vacuums is good. MySQL doesn’t free up space taken by deleted rows. The only option to free up the space is to mysqldump the db and load it again. Not practical in most of the situations.</div><br/><div id="41877166" class="c"><input type="checkbox" id="c-41877166" checked=""/><div class="controls bullet"><span class="by">benoitg</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41877061">parent</a><span>|</span><a href="#41876384">next</a><span>|</span><label class="collapse" for="c-41877166">[-]</label><label class="expand" for="c-41877166">[2 more]</label></div><br/><div class="children"><div class="content">Not really, the innodb_file_per_table variable has been set to 1 for a long time. Running OPTIMIZE TABLE frees up the disk space in this case.</div><br/><div id="41877285" class="c"><input type="checkbox" id="c-41877285" checked=""/><div class="controls bullet"><span class="by">sudhirj</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41877166">parent</a><span>|</span><a href="#41876384">next</a><span>|</span><label class="collapse" for="c-41877285">[-]</label><label class="expand" for="c-41877285">[1 more]</label></div><br/><div class="children"><div class="content">Is this process materially different from a vacuum? Does it manage to optimise without a write lock?</div><br/></div></div></div></div></div></div></div></div><div id="41876384" class="c"><input type="checkbox" id="c-41876384" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876232">parent</a><span>|</span><a href="#41876309">prev</a><span>|</span><a href="#41877139">next</a><span>|</span><label class="collapse" for="c-41876384">[-]</label><label class="expand" for="c-41876384">[1 more]</label></div><br/><div class="children"><div class="content">Early MySQL versions made egregious design choices like quietly ignoring missing foreign keys and enum typos, truncating long strings, and randomly choosing rows from groups.<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230922210124&#x2F;https:&#x2F;&#x2F;grimoire.ca&#x2F;mysql&#x2F;choose-something-else&#x2F;#data-processing" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230922210124&#x2F;https:&#x2F;&#x2F;grimoire....</a></div><br/></div></div><div id="41877139" class="c"><input type="checkbox" id="c-41877139" checked=""/><div class="controls bullet"><span class="by">Propelloni</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876232">parent</a><span>|</span><a href="#41876384">prev</a><span>|</span><a href="#41877268">next</a><span>|</span><label class="collapse" for="c-41877139">[-]</label><label class="expand" for="c-41877139">[2 more]</label></div><br/><div class="children"><div class="content">It is hard to live down a reputation ;)<p>MySQL was immortalized as the database in every LAMP stack. And just like PHP it improved considerably since then.</div><br/><div id="41877303" class="c"><input type="checkbox" id="c-41877303" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41877139">parent</a><span>|</span><a href="#41877268">next</a><span>|</span><label class="collapse" for="c-41877303">[-]</label><label class="expand" for="c-41877303">[1 more]</label></div><br/><div class="children"><div class="content">Also for licensing reasons for a long time there was surviving contingent of MySQL 3.23 in LAMP hosting.</div><br/></div></div></div></div></div></div><div id="41877268" class="c"><input type="checkbox" id="c-41877268" checked=""/><div class="controls bullet"><span class="by">pella</span><span>|</span><a href="#41875055">parent</a><span>|</span><a href="#41876232">prev</a><span>|</span><a href="#41877029">next</a><span>|</span><label class="collapse" for="c-41877268">[-]</label><label class="expand" for="c-41877268">[1 more]</label></div><br/><div class="children"><div class="content">MySQL vs. PostgreSQL - Jepsen Analyses<p><a href="https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;mysql-8.0.34" rel="nofollow">https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;mysql-8.0.34</a> ( MySQL 8.0.34 2023-12-19 )<p>HN: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38695750">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38695750</a><p><i>&quot;MySQL is a popular relational database. We revisit Kleppmann’s 2014 Hermitage and confirm that MySQL’s Repeatable Read still allows G2-item, G-single, and lost update. Using our transaction consistency checker Elle, we show that MySQL Repeatable Read also violates internal consistency. Furthermore, it violates Monotonic Atomic View: transactions can observe some of another transaction’s effects, then later fail to observe other effects of that same transaction. We demonstrate violations of ANSI SQL’s requirements for Repeatable Read. We believe MySQL Repeatable Read is somewhat stronger than Read Committed. As a lagniappe, we show that AWS RDS MySQL clusters routinely violate Serializability.&quot;</i><p>---------------<p><a href="https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;postgresql-12.3" rel="nofollow">https:&#x2F;&#x2F;jepsen.io&#x2F;analyses&#x2F;postgresql-12.3</a> ( PostgreSQL 12.3  2020-06-12 )<p>HN: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23498781">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23498781</a><p><i>&quot;PostgreSQL is a widely-known relational database system. We evaluated PostgreSQL using Jepsen’s new transactional isolation checker Elle, and found that transactions executed with serializable isolation on a single PostgreSQL instance were not, in fact, serializable. Under normal operation, transactions could occasionally exhibit G2-item: an anomaly involving a set of transactions which (roughly speaking) mutually fail to observe each other’s writes. In addition, we found frequent instances of G2-item under PostgreSQL “repeatable read”, which is explicitly proscribed by commonly-cited formalizations of repeatable read. As previously reported by Martin Kleppmann, this is due to the fact that PostgreSQL “repeatable read” is actually snapshot isolation. This behavior is allowable due to long-discussed ambiguities in the ANSI SQL standard, but could be surprising for users familiar with the literature. A patch for the bug we found in serializability is scheduled for the next minor release, on August 13th, and the presence of G2-item under repeatable read could be readily addressed through documentation.&quot;</i></div><br/></div></div><div id="41877029" class="c"><input type="checkbox" id="c-41877029" checked=""/><div class="controls bullet"><span class="by">cenamus</span><span>|</span><a href="#41875055">parent</a><span>|</span><a href="#41877268">prev</a><span>|</span><a href="#41876375">next</a><span>|</span><label class="collapse" for="c-41877029">[-]</label><label class="expand" for="c-41877029">[2 more]</label></div><br/><div class="children"><div class="content">Is slony some sort of language joke? Slon is czech (probably slavic in general) for elephant.<p>(which may be actually derived from the turkish aslan, for lion, but somehow the animal got mixed up)</div><br/><div id="41877211" class="c"><input type="checkbox" id="c-41877211" checked=""/><div class="controls bullet"><span class="by">newaccount74</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41877029">parent</a><span>|</span><a href="#41876375">next</a><span>|</span><label class="collapse" for="c-41877211">[-]</label><label class="expand" for="c-41877211">[1 more]</label></div><br/><div class="children"><div class="content">I think so. The PostgreSQL logo is an elephant, and the community calls him &quot;Slonik&quot;, probably derived from the Russian word for elephant. There is also a node.js driver that is called &quot;slonik&quot;</div><br/></div></div></div></div><div id="41876375" class="c"><input type="checkbox" id="c-41876375" checked=""/><div class="controls bullet"><span class="by">aorloff</span><span>|</span><a href="#41875055">parent</a><span>|</span><a href="#41877029">prev</a><span>|</span><a href="#41875126">next</a><span>|</span><label class="collapse" for="c-41876375">[-]</label><label class="expand" for="c-41876375">[1 more]</label></div><br/><div class="children"><div class="content">A shudder went through my body hearing that, I had forgotten all about Slony.</div><br/></div></div><div id="41875126" class="c"><input type="checkbox" id="c-41875126" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#41875055">parent</a><span>|</span><a href="#41876375">prev</a><span>|</span><a href="#41875084">next</a><span>|</span><label class="collapse" for="c-41875126">[-]</label><label class="expand" for="c-41875126">[43 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wondered why Postgres is so insanely popular. I mean it has some nice things like very powerful support for a very comprehensive subset of SQL functionality, but most apps don&#x27;t need all that.<p>It really feels like early 1990s vintage Unix software. It&#x27;s clunky and arcane and it&#x27;s hard to feel confident doing anything complex with it.</div><br/><div id="41875306" class="c"><input type="checkbox" id="c-41875306" checked=""/><div class="controls bullet"><span class="by">tpmoney</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875126">parent</a><span>|</span><a href="#41876346">next</a><span>|</span><label class="collapse" for="c-41875306">[-]</label><label class="expand" for="c-41875306">[15 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve always wondered why Postgres is so insanely popular.<p>In no particular order, my preference for postgres is driven by:<p><pre><code>  * Date &#x2F; time functions that don&#x27;t suck
  * UTF-8 is really UTF-8
  * 99% of a backup can be done live with nothing more than rsyncing the data directory and the WAL files
  * Really comprehensive documentation
  * LTREE and fuzzy string match extensions
  * Familiarity from using it for years
</code></pre>
MySQL&#x2F;Maria I&#x27;m sure is fine, but it&#x27;s one of hose things where it&#x27;s just different enough and I haven&#x27;t encountered a compelling use case for changing my preference.</div><br/><div id="41875336" class="c"><input type="checkbox" id="c-41875336" checked=""/><div class="controls bullet"><span class="by">fhdsgbbcaA</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875306">parent</a><span>|</span><a href="#41876296">next</a><span>|</span><label class="collapse" for="c-41875336">[-]</label><label class="expand" for="c-41875336">[13 more]</label></div><br/><div class="children"><div class="content">UTF-8 is what made me switch. It’s insane MySQL has something called UTF-8 that <i>isn&#x27;t</i> really UTF-8, but do have a type UTF8MB4 that actually <i>is</i> correct. This means if you use UFT-8 in MySQL, you can’t use emoji for example.</div><br/><div id="41875430" class="c"><input type="checkbox" id="c-41875430" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875336">parent</a><span>|</span><a href="#41876285">next</a><span>|</span><label class="collapse" for="c-41875430">[-]</label><label class="expand" for="c-41875430">[10 more]</label></div><br/><div class="children"><div class="content">And the fact that adding real utf-8 support limited (limits?) the length of strings that can be indexed</div><br/><div id="41875764" class="c"><input type="checkbox" id="c-41875764" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875430">parent</a><span>|</span><a href="#41876285">next</a><span>|</span><label class="collapse" for="c-41875764">[-]</label><label class="expand" for="c-41875764">[9 more]</label></div><br/><div class="children"><div class="content">Postgres limits btree keys to 2704 bytes, which is actually slightly smaller than MySQL&#x27;s limit of 3072 bytes, assuming the default InnoDB storage engine.<p>That said, when using utf8mb4 in an index key, MySQL uses the &quot;worst case&quot; of each character being 4 bytes. So it effectively limits the max key size to 3072&#x2F;4 = 768 characters, when a column is using the utf8mb4 character set.<p>For practical purposes, this doesn&#x27;t cause much pain, as it&#x27;s generally inadvisable to use complete long-ish strings as a key. And there are various workarounds, like using prefixes or hashes as the key, or using binary strings as keys to get the full 3072 bytes (if you don&#x27;t need collation behaviors).</div><br/><div id="41875901" class="c"><input type="checkbox" id="c-41875901" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875764">parent</a><span>|</span><a href="#41876285">next</a><span>|</span><label class="collapse" for="c-41875901">[-]</label><label class="expand" for="c-41875901">[8 more]</label></div><br/><div class="children"><div class="content">&gt; So it effectively limits the max key size to 3072&#x2F;4 = 768 characters, when a column is using the utf8mb4 character set.<p>This is exactly what I mean. 768 characters for an index is woefully bad. And for no obviously great reason: you can just index the encoded UTF-8 text.<p>This was literally reason why a former company (who will remain nameless) refused to add Unicode support. It&#x27;s not even an imagined problem.</div><br/><div id="41876347" class="c"><input type="checkbox" id="c-41876347" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875901">parent</a><span>|</span><a href="#41876001">next</a><span>|</span><label class="collapse" for="c-41876347">[-]</label><label class="expand" for="c-41876347">[1 more]</label></div><br/><div class="children"><div class="content">You should not be indexing 768 characters in any circumstance I can imagine. Go ahead and try it. Spin up two tables, fill them with a few million rows, and slap and index on them. Give one a reasonable prefix limit, and let the other go wild. Make sure you ANALYZE each, then run queries in a loop and check the times.<p>Spoiler: I literally did this a couple of days ago. The index size bloat means that any possible savings you might have gained from collisions are obliterated from page fetches. I tested with a measly 128 characters vs. a prefix of 16, and that was enough for the average query time to be equal, with the smaller index winning for the minimum.</div><br/></div></div><div id="41876001" class="c"><input type="checkbox" id="c-41876001" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875901">parent</a><span>|</span><a href="#41876347">prev</a><span>|</span><a href="#41876285">next</a><span>|</span><label class="collapse" for="c-41876001">[-]</label><label class="expand" for="c-41876001">[6 more]</label></div><br/><div class="children"><div class="content">Why did you need to index fairly long strings in their entirety in a way that preserves collation behaviors?<p>And why is a 768 character limit woefully bad, but a 2704 character limit is totally fine?</div><br/><div id="41876259" class="c"><input type="checkbox" id="c-41876259" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876001">parent</a><span>|</span><a href="#41876450">next</a><span>|</span><label class="collapse" for="c-41876259">[-]</label><label class="expand" for="c-41876259">[4 more]</label></div><br/><div class="children"><div class="content">A URL, for instance, can&#x27;t be safely stored in 768 characters, but it can be stored safely in 2704. If you then wanted to sort those URLs so that all URLs for each domain and path within that domain are adjacent, you need an index. Especially if you want to paginate over them with a cursor. Doing that without an index on the raw value is a royal pain in the ass.<p>Hell, even just being able to sort user-submitted strings up to a kilobyte. Why up to a kilobyte? Some users have strings that are kind of long. If I have to define a second column that&#x27;s the truncated prefix, that&#x27;s just a silly waste of space because MySQL decided to use utf-32 under the hood.</div><br/><div id="41876664" class="c"><input type="checkbox" id="c-41876664" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876259">parent</a><span>|</span><a href="#41876474">next</a><span>|</span><label class="collapse" for="c-41876664">[-]</label><label class="expand" for="c-41876664">[1 more]</label></div><br/><div class="children"><div class="content">To be honest, indexes aren&#x27;t designed for that. They&#x27;re meant for fast lookup of short identifiers. Things like people&#x27;s names and product ID&#x27;s. Not long URL&#x27;s. It&#x27;s not performant.<p>If you need to keep a million long URL&#x27;s in a defined sort order, my first recommendation would be, don&#x27;t -- see if there&#x27;s another way to achieve your end result. But if you absolutely have to, then create a new integer column to be your sort key, and use a little bit of extra code to give it values that produce the same sort order.<p>Creating short numerical primary keys for long strings is a common database technique.</div><br/></div></div><div id="41876474" class="c"><input type="checkbox" id="c-41876474" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876259">parent</a><span>|</span><a href="#41876664">prev</a><span>|</span><a href="#41876823">next</a><span>|</span><label class="collapse" for="c-41876474">[-]</label><label class="expand" for="c-41876474">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A URL, for instance<p>VARBINARY is typically ok for that I&#x27;d think? Then you can utilize the full 3072 byte limit for the key, since there&#x27;s no character set applied.<p>&gt; even just being able to sort user-submitted strings up to a kilobyte<p>As a software engineer, I completely agree. But as a DBA, I am obligated to make a &quot;tsk&quot; sound and scowl disapprovingly!</div><br/></div></div><div id="41876823" class="c"><input type="checkbox" id="c-41876823" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876259">parent</a><span>|</span><a href="#41876474">prev</a><span>|</span><a href="#41876450">next</a><span>|</span><label class="collapse" for="c-41876823">[-]</label><label class="expand" for="c-41876823">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it can be stored safely in 2704<p>No, it can&#x27;t. URL doesn&#x27;t have any length limit, regardless of the fact that different software will impose different limits.</div><br/></div></div></div></div><div id="41876450" class="c"><input type="checkbox" id="c-41876450" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876001">parent</a><span>|</span><a href="#41876259">prev</a><span>|</span><a href="#41876285">next</a><span>|</span><label class="collapse" for="c-41876450">[-]</label><label class="expand" for="c-41876450">[1 more]</label></div><br/><div class="children"><div class="content">You might just load someone else&#x27;s data, and the index is desirable in general for speeding up analytic queries. It&#x27;s possible to work around that, of course. But depending on what you do, it can make writing efficient queries against the data more difficult. That&#x27;s just a distraction because most of the time, those long columns won&#x27;t matter anyway.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41876285" class="c"><input type="checkbox" id="c-41876285" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875336">parent</a><span>|</span><a href="#41875430">prev</a><span>|</span><a href="#41876296">next</a><span>|</span><label class="collapse" for="c-41876285">[-]</label><label class="expand" for="c-41876285">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This means if you use UFT-8 in MySQL, you can’t use emoji for example.<p>I for one have always viewed this as a perk.</div><br/><div id="41876570" class="c"><input type="checkbox" id="c-41876570" checked=""/><div class="controls bullet"><span class="by">fhdsgbbcaA</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876285">parent</a><span>|</span><a href="#41876296">next</a><span>|</span><label class="collapse" for="c-41876570">[-]</label><label class="expand" for="c-41876570">[1 more]</label></div><br/><div class="children"><div class="content">A database that doesn’t give you back what you put into it is never a perk. It literally can’t handle storing and retrieving the data.</div><br/></div></div></div></div></div></div><div id="41876296" class="c"><input type="checkbox" id="c-41876296" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875306">parent</a><span>|</span><a href="#41875336">prev</a><span>|</span><a href="#41876346">next</a><span>|</span><label class="collapse" for="c-41876296">[-]</label><label class="expand" for="c-41876296">[1 more]</label></div><br/><div class="children"><div class="content">MySQL does have ON UPDATE for its DATETIME, though; something that Postgres inexplicably still lacks.</div><br/></div></div></div></div><div id="41876346" class="c"><input type="checkbox" id="c-41876346" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875126">parent</a><span>|</span><a href="#41875306">prev</a><span>|</span><a href="#41875168">next</a><span>|</span><label class="collapse" for="c-41876346">[-]</label><label class="expand" for="c-41876346">[2 more]</label></div><br/><div class="children"><div class="content">* transactional DDL<p>* comprehensive transaction model using different modes<p>* PostGIS and lots of other great extensions<p>* supports most of the current SQL standard and is clear on interpretation of edge-cases in the documentation<p>* support for writing stored procedures in any major programming language<p>* many useful functions regarding dates, sets, ranges, json, xml, ...<p>* custom datatypes<p>* extremely thought-out and standardized approach to development: if a feature is included it generally works well in interaction with everything else<p>* syntax, semantics and performance are all very predictable<p>* great documentation<p>Regarding MySQL &#x2F; MariaDB: MySQL optimized for performance first. Until 2010 the standard-storage-engine MyISAM didn&#x27;t even support transactions.<p>PostgreSQL always focused on correctness and stability and then made sure everything performed.</div><br/><div id="41877457" class="c"><input type="checkbox" id="c-41877457" checked=""/><div class="controls bullet"><span class="by">arkh</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876346">parent</a><span>|</span><a href="#41875168">next</a><span>|</span><label class="collapse" for="c-41877457">[-]</label><label class="expand" for="c-41877457">[1 more]</label></div><br/><div class="children"><div class="content">&gt; * custom datatypes<p>Good in theory. But last time I checked the main libs to connect to pgsql, everything you get back from the database are strings. So you need something in your app to convert those strings to the equivalent data structures.</div><br/></div></div></div></div><div id="41875168" class="c"><input type="checkbox" id="c-41875168" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875126">parent</a><span>|</span><a href="#41876346">prev</a><span>|</span><a href="#41875240">next</a><span>|</span><label class="collapse" for="c-41875168">[-]</label><label class="expand" for="c-41875168">[8 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the alternative? MySQL? No transactional DDL, immediate fail.</div><br/><div id="41875276" class="c"><input type="checkbox" id="c-41875276" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875168">parent</a><span>|</span><a href="#41875729">next</a><span>|</span><label class="collapse" for="c-41875276">[-]</label><label class="expand" for="c-41875276">[4 more]</label></div><br/><div class="children"><div class="content">I worked for a company that migrated from mysql to postgres, but then got big enough they wanted to hire fulltime database experts and ended up migrating <i>back</i> to mysql because it was easier to find talent</div><br/><div id="41875436" class="c"><input type="checkbox" id="c-41875436" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875276">parent</a><span>|</span><a href="#41875533">next</a><span>|</span><label class="collapse" for="c-41875436">[-]</label><label class="expand" for="c-41875436">[1 more]</label></div><br/><div class="children"><div class="content">Dunno if that says much about Postgres, but it says a lot about the company</div><br/></div></div></div></div><div id="41875729" class="c"><input type="checkbox" id="c-41875729" checked=""/><div class="controls bullet"><span class="by">cosmotic</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875168">parent</a><span>|</span><a href="#41875276">prev</a><span>|</span><a href="#41876552">next</a><span>|</span><label class="collapse" for="c-41875729">[-]</label><label class="expand" for="c-41875729">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just DDL that isn&#x27;t transactional, there&#x27;s a whole bunch of other things that aren&#x27;t. And they break the transactionality silently. It&#x27;s like an obstical course where bumping into something might be fatal.</div><br/><div id="41875779" class="c"><input type="checkbox" id="c-41875779" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875729">parent</a><span>|</span><a href="#41876552">next</a><span>|</span><label class="collapse" for="c-41875779">[-]</label><label class="expand" for="c-41875779">[1 more]</label></div><br/><div class="children"><div class="content">What specific non-DDL things are you referring to here?<p>Aside from DDL, the only other major ones are manipulating users&#x2F;grants, manipulating replication, a small number of other administrative commands, and LOCK TABLES.<p>This is all documented <i>very</i> clearly on <a href="https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.4&#x2F;en&#x2F;implicit-commit.html" rel="nofollow">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.4&#x2F;en&#x2F;implicit-commit.html</a>. Hardly an &quot;obstical course&quot;.</div><br/></div></div></div></div><div id="41876552" class="c"><input type="checkbox" id="c-41876552" checked=""/><div class="controls bullet"><span class="by">cvalka</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875168">parent</a><span>|</span><a href="#41875729">prev</a><span>|</span><a href="#41875240">next</a><span>|</span><label class="collapse" for="c-41876552">[-]</label><label class="expand" for="c-41876552">[1 more]</label></div><br/><div class="children"><div class="content">TiDB</div><br/></div></div></div></div><div id="41875240" class="c"><input type="checkbox" id="c-41875240" checked=""/><div class="controls bullet"><span class="by">justin_oaks</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875126">parent</a><span>|</span><a href="#41875168">prev</a><span>|</span><a href="#41877119">next</a><span>|</span><label class="collapse" for="c-41875240">[-]</label><label class="expand" for="c-41875240">[13 more]</label></div><br/><div class="children"><div class="content">&gt; It really feels like early 1990s vintage Unix software. It&#x27;s clunky and arcane and it&#x27;s hard to feel confident doing anything complex with it.<p>How software &quot;feels&quot; is subjective. Can you be more specific?</div><br/><div id="41875625" class="c"><input type="checkbox" id="c-41875625" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875240">parent</a><span>|</span><a href="#41877469">next</a><span>|</span><label class="collapse" for="c-41875625">[-]</label><label class="expand" for="c-41875625">[1 more]</label></div><br/><div class="children"><div class="content">It requires a ton of somewhat arcane maintenance at scale. Vacuum shenanigans, Index fragmentation requiring manual reindexing, Txid wraparounds. I like Postgres but it’s definitely way more work to maintain a large instance than mysql. MySQL just kinda works</div><br/></div></div><div id="41877469" class="c"><input type="checkbox" id="c-41877469" checked=""/><div class="controls bullet"><span class="by">arkh</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875240">parent</a><span>|</span><a href="#41875625">prev</a><span>|</span><a href="#41875286">next</a><span>|</span><label class="collapse" for="c-41877469">[-]</label><label class="expand" for="c-41877469">[1 more]</label></div><br/><div class="children"><div class="content">Having to tinker with pg_hba.conf files on the server so manage how users can connect.</div><br/></div></div><div id="41875286" class="c"><input type="checkbox" id="c-41875286" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875240">parent</a><span>|</span><a href="#41877469">prev</a><span>|</span><a href="#41877119">next</a><span>|</span><label class="collapse" for="c-41875286">[-]</label><label class="expand" for="c-41875286">[10 more]</label></div><br/><div class="children"><div class="content">The command line experience is old school style i.e. to show tables.<p><pre><code>  \c database
  \dt
</code></pre>
Versus:<p><pre><code>  use database
  show tables</code></pre></div><br/><div id="41875689" class="c"><input type="checkbox" id="c-41875689" checked=""/><div class="controls bullet"><span class="by">georgyo</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875286">parent</a><span>|</span><a href="#41875573">next</a><span>|</span><label class="collapse" for="c-41875689">[-]</label><label class="expand" for="c-41875689">[2 more]</label></div><br/><div class="children"><div class="content">I started with MySQL in 2006 for my personal projects, but what first won me over to psql was those commands.<p>Today I use CLIs like usql to interact with MySQL and SQLite so I can continue to use those commands.<p>At first glance they may be less obvious, but they are significantly more discoverable. \? Just shows you all of them. In MySQL it always feels like I need to Google it.</div><br/><div id="41876427" class="c"><input type="checkbox" id="c-41876427" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875689">parent</a><span>|</span><a href="#41875573">next</a><span>|</span><label class="collapse" for="c-41876427">[-]</label><label class="expand" for="c-41876427">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At first glance they may be less obvious, but they are significantly more discoverable. \? Just shows you all of them. In MySQL it always feels like I need to Google it.<p>In MySQL either `?` or `help` or `\?` will show you the help...</div><br/></div></div></div></div><div id="41875573" class="c"><input type="checkbox" id="c-41875573" checked=""/><div class="controls bullet"><span class="by">rootusrootus</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875286">parent</a><span>|</span><a href="#41875689">prev</a><span>|</span><a href="#41875328">next</a><span>|</span><label class="collapse" for="c-41875573">[-]</label><label class="expand" for="c-41875573">[1 more]</label></div><br/><div class="children"><div class="content">I assume this is really what it comes down to.  If psql added those verbose-but-descriptive commands a whole bunch of people comfortable with mysql would be a lot happier using postgres.</div><br/></div></div><div id="41875328" class="c"><input type="checkbox" id="c-41875328" checked=""/><div class="controls bullet"><span class="by">dventimi</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875286">parent</a><span>|</span><a href="#41875573">prev</a><span>|</span><a href="#41875350">next</a><span>|</span><label class="collapse" for="c-41875328">[-]</label><label class="expand" for="c-41875328">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s psql.</div><br/></div></div><div id="41875350" class="c"><input type="checkbox" id="c-41875350" checked=""/><div class="controls bullet"><span class="by">fhdsgbbcaA</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875286">parent</a><span>|</span><a href="#41875328">prev</a><span>|</span><a href="#41877119">next</a><span>|</span><label class="collapse" for="c-41875350">[-]</label><label class="expand" for="c-41875350">[5 more]</label></div><br/><div class="children"><div class="content">It’s also faster to type.</div><br/><div id="41876111" class="c"><input type="checkbox" id="c-41876111" checked=""/><div class="controls bullet"><span class="by">eYrKEC2</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875350">parent</a><span>|</span><a href="#41877119">next</a><span>|</span><label class="collapse" for="c-41876111">[-]</label><label class="expand" for="c-41876111">[4 more]</label></div><br/><div class="children"><div class="content">Not after you have to google, &quot;What&#x27;s the equivalent of `show tables` in postgres?&quot;, because the psql command names are completely arbitrary.</div><br/><div id="41876166" class="c"><input type="checkbox" id="c-41876166" checked=""/><div class="controls bullet"><span class="by">fhdsgbbcaA</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876111">parent</a><span>|</span><a href="#41877357">prev</a><span>|</span><a href="#41877119">next</a><span>|</span><label class="collapse" for="c-41876166">[-]</label><label class="expand" for="c-41876166">[2 more]</label></div><br/><div class="children"><div class="content">Which you need to do exactly once.</div><br/><div id="41876478" class="c"><input type="checkbox" id="c-41876478" checked=""/><div class="controls bullet"><span class="by">kalleboo</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41876166">parent</a><span>|</span><a href="#41877119">next</a><span>|</span><label class="collapse" for="c-41876478">[-]</label><label class="expand" for="c-41876478">[1 more]</label></div><br/><div class="children"><div class="content">I need to manually admin my database server maybe once every 2 years or so. Definitely not remembering them 2 years later.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41877119" class="c"><input type="checkbox" id="c-41877119" checked=""/><div class="controls bullet"><span class="by">Scramblejams</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875126">parent</a><span>|</span><a href="#41875240">prev</a><span>|</span><a href="#41876770">next</a><span>|</span><label class="collapse" for="c-41877119">[-]</label><label class="expand" for="c-41877119">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve always wondered why Postgres is so insanely popular.<p>Just another anecdote: MySQL lost data for me (2004). I spent some time evaluating the projects and Postgres’ development process seemed much more mature — methodical, careful, and focused on correctness. Boring, which I loved.<p>I didn’t need whatever perf advantage MySQL had so I switched to Postgres and never looked back. And then the Oracle drama and Monty’s behavior around it — not saying he was wrong or right, but it was the opposite of boring — just reinforced my decision.<p>I like to play with new tech in various spots of the stack, but for filesystems and databases I go boring all the way.</div><br/></div></div><div id="41876770" class="c"><input type="checkbox" id="c-41876770" checked=""/><div class="controls bullet"><span class="by">moogly</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875126">parent</a><span>|</span><a href="#41877119">prev</a><span>|</span><a href="#41875587">next</a><span>|</span><label class="collapse" for="c-41876770">[-]</label><label class="expand" for="c-41876770">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve always wondered why Postgres is so insanely popular<p>Real answer: no licensing cost</div><br/></div></div><div id="41875587" class="c"><input type="checkbox" id="c-41875587" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875126">parent</a><span>|</span><a href="#41876770">prev</a><span>|</span><a href="#41875084">next</a><span>|</span><label class="collapse" for="c-41875587">[-]</label><label class="expand" for="c-41875587">[2 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s not tainted and cursed by Oracle, like MySQL (and Oracle).</div><br/><div id="41877266" class="c"><input type="checkbox" id="c-41877266" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41875055">root</a><span>|</span><a href="#41875587">parent</a><span>|</span><a href="#41875084">next</a><span>|</span><label class="collapse" for="c-41877266">[-]</label><label class="expand" for="c-41877266">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what MariaDB is for, right? I&#x27;m surprised to hear people recommend the Oracle fork of MySQL (still called MySQL because they own the trademark) rather than the original project (now called MariaDB)</div><br/></div></div></div></div></div></div></div></div><div id="41875084" class="c"><input type="checkbox" id="c-41875084" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#41875055">prev</a><span>|</span><a href="#41877509">next</a><span>|</span><label class="collapse" for="c-41875084">[-]</label><label class="expand" for="c-41875084">[1 more]</label></div><br/><div class="children"><div class="content">The risk&#x2F;reward ratio of fucking with something that works perfectly fine as is is not great.<p>So for fresh installs yes but existing ones not so much</div><br/></div></div><div id="41877509" class="c"><input type="checkbox" id="c-41877509" checked=""/><div class="controls bullet"><span class="by">ZiiS</span><span>|</span><a href="#41875084">prev</a><span>|</span><a href="#41876591">next</a><span>|</span><label class="collapse" for="c-41877509">[-]</label><label class="expand" for="c-41877509">[1 more]</label></div><br/><div class="children"><div class="content">Because they already work great, you are unlikly to get forced to upgrade, and they are the part of your system doing the most critical work under the heviest load.</div><br/></div></div><div id="41876591" class="c"><input type="checkbox" id="c-41876591" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#41877509">prev</a><span>|</span><a href="#41875268">next</a><span>|</span><label class="collapse" for="c-41876591">[-]</label><label class="expand" for="c-41876591">[1 more]</label></div><br/><div class="children"><div class="content">Lol, try upgrading old MongoDB stuff.<p>Database engines (every single one) are notorious for incompatibilities between major versions, upgrading mission critical stuff means updating and re-testing entire applications, which in some cases can be a multi-million dollar process, before going into production.<p>Even if you deeply know&#x2F;think that there&#x27;s no problem upgrading, if something does fail in production after an upgrade and it&#x27;s mission critical..</div><br/></div></div><div id="41875268" class="c"><input type="checkbox" id="c-41875268" checked=""/><div class="controls bullet"><span class="by">justin_oaks</span><span>|</span><a href="#41876591">prev</a><span>|</span><a href="#41877395">next</a><span>|</span><label class="collapse" for="c-41875268">[-]</label><label class="expand" for="c-41875268">[11 more]</label></div><br/><div class="children"><div class="content">My upgrade policy for everything:<p>Significant security vulnerability? Upgrade<p>Feature you need? Upgrade<p>All other reasons: Don&#x27;t upgrade.<p>Upgrading takes effort and it is risky. The benefits must be worth the risks.</div><br/><div id="41876707" class="c"><input type="checkbox" id="c-41876707" checked=""/><div class="controls bullet"><span class="by">occz</span><span>|</span><a href="#41875268">parent</a><span>|</span><a href="#41876163">next</a><span>|</span><label class="collapse" for="c-41876707">[-]</label><label class="expand" for="c-41876707">[2 more]</label></div><br/><div class="children"><div class="content">Upgrading when multiple versions behind is significantly more risky than doing it when the update is relatively fresh.<p>Additionally, actions done frequently are less risky than actions done rarely, since you develop skills in performing that action as an organization - see high deployment frequency as a strategy of managing deployment risk.<p>This adds up to continuous upgrading being the least risky option in aggregate.</div><br/><div id="41877368" class="c"><input type="checkbox" id="c-41877368" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#41875268">root</a><span>|</span><a href="#41876707">parent</a><span>|</span><a href="#41876163">next</a><span>|</span><label class="collapse" for="c-41877368">[-]</label><label class="expand" for="c-41877368">[1 more]</label></div><br/><div class="children"><div class="content">Not if software regressions are the main concern.</div><br/></div></div></div></div><div id="41876163" class="c"><input type="checkbox" id="c-41876163" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41875268">parent</a><span>|</span><a href="#41876707">prev</a><span>|</span><a href="#41875370">next</a><span>|</span><label class="collapse" for="c-41876163">[-]</label><label class="expand" for="c-41876163">[1 more]</label></div><br/><div class="children"><div class="content">Once your version doesn’t receive security fixes you’re one CERT advisory away from having your whole week pre-empted by an emergency upgrade.<p>I’ve been there with products that were still internal at the time. I can only imagine how much fun that is with a public product. But then I do have a pretty vivid imagination. We changed to periodic upgrades after that to avoid the obvious problem staring us in the face.</div><br/></div></div><div id="41875370" class="c"><input type="checkbox" id="c-41875370" checked=""/><div class="controls bullet"><span class="by">natmaka</span><span>|</span><a href="#41875268">parent</a><span>|</span><a href="#41876163">prev</a><span>|</span><a href="#41875465">next</a><span>|</span><label class="collapse" for="c-41875370">[-]</label><label class="expand" for="c-41875370">[4 more]</label></div><br/><div class="children"><div class="content">Suggestion: add &quot;End of life (no more maintenance for this version)?  Upgrade&quot;</div><br/><div id="41876193" class="c"><input type="checkbox" id="c-41876193" checked=""/><div class="controls bullet"><span class="by">Gormo</span><span>|</span><a href="#41875268">root</a><span>|</span><a href="#41875370">parent</a><span>|</span><a href="#41875465">next</a><span>|</span><label class="collapse" for="c-41876193">[-]</label><label class="expand" for="c-41876193">[3 more]</label></div><br/><div class="children"><div class="content">Why?  If the implemented featureset meets your needs, and there are no unresolved bugs or security vulnerabilities relevant to your use cases, what further &quot;maintenance&quot; do you need?</div><br/><div id="41876247" class="c"><input type="checkbox" id="c-41876247" checked=""/><div class="controls bullet"><span class="by">abraham</span><span>|</span><a href="#41875268">root</a><span>|</span><a href="#41876193">parent</a><span>|</span><a href="#41876460">next</a><span>|</span><label class="collapse" for="c-41876247">[-]</label><label class="expand" for="c-41876247">[1 more]</label></div><br/><div class="children"><div class="content">When a critical security patch comes out, you don&#x27;t want to have to to do a major version upgrade to get it.</div><br/></div></div><div id="41876460" class="c"><input type="checkbox" id="c-41876460" checked=""/><div class="controls bullet"><span class="by">FearNotDaniel</span><span>|</span><a href="#41875268">root</a><span>|</span><a href="#41876193">parent</a><span>|</span><a href="#41876247">prev</a><span>|</span><a href="#41875465">next</a><span>|</span><label class="collapse" for="c-41876460">[-]</label><label class="expand" for="c-41876460">[1 more]</label></div><br/><div class="children"><div class="content">Because when the maintainers have stopped patching that version against all <i>known</i> security vulnerabilities, that doesn&#x27;t stop the bad guys from looking for <i>more</i> vulnerabilities. When they find one, it will get exploited. So you either wake up to an email from Have I Been Pwned to say all your customer data has been exfiltrated [0], or (if you&#x27;re lucky) you have a mad scramble to do that update before they get you.<p>[0] Probably including those passwords you didn&#x27;t hash, and those credit card numbers you shouldn&#x27;t be storing in the first place because, what the heck, it meets <i>your</i> needs.</div><br/></div></div></div></div></div></div><div id="41875465" class="c"><input type="checkbox" id="c-41875465" checked=""/><div class="controls bullet"><span class="by">throwaway918299</span><span>|</span><a href="#41875268">parent</a><span>|</span><a href="#41875370">prev</a><span>|</span><a href="#41876254">next</a><span>|</span><label class="collapse" for="c-41875465">[-]</label><label class="expand" for="c-41875465">[2 more]</label></div><br/><div class="children"><div class="content">Here’s another reason to upgrade: your version is end of life and your cloud provider forced it.<p>Thank you Amazon!</div><br/><div id="41876897" class="c"><input type="checkbox" id="c-41876897" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#41875268">root</a><span>|</span><a href="#41875465">parent</a><span>|</span><a href="#41876254">next</a><span>|</span><label class="collapse" for="c-41876897">[-]</label><label class="expand" for="c-41876897">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is actually a good thing and comes with warnings beforehand.</div><br/></div></div></div></div><div id="41876254" class="c"><input type="checkbox" id="c-41876254" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#41875268">parent</a><span>|</span><a href="#41875465">prev</a><span>|</span><a href="#41877395">next</a><span>|</span><label class="collapse" for="c-41876254">[-]</label><label class="expand" for="c-41876254">[1 more]</label></div><br/><div class="children"><div class="content">Eventually you get forced to update it when the other stuff you use starts having minimum version requirements.</div><br/></div></div></div></div><div id="41877395" class="c"><input type="checkbox" id="c-41877395" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#41875268">prev</a><span>|</span><a href="#41875253">next</a><span>|</span><label class="collapse" for="c-41877395">[-]</label><label class="expand" for="c-41877395">[1 more]</label></div><br/><div class="children"><div class="content">Why don&#x27;t people upgrade? Why don&#x27;t we ask why upgrading is necessary? I understand that Postgres is free software, and if you choose to use it, you&#x27;re signing up for whatever upgrade cadence the developers give you. But really, I with the developers would spend a bit more time patching &quot;old&quot; versions. 6 years is really too short a time to have to do an upgrade, especially if you have many database servers.</div><br/></div></div><div id="41875253" class="c"><input type="checkbox" id="c-41875253" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41877395">prev</a><span>|</span><a href="#41875321">next</a><span>|</span><label class="collapse" for="c-41875253">[-]</label><label class="expand" for="c-41875253">[1 more]</label></div><br/><div class="children"><div class="content">In Oracle, ALTER TABLE MOVE in 8i was a godsend, finally enabling a table reorganization without export&#x2F;import.<p>My timid management forbade an upgrade from Oracle 7.3.4 until 2013. It was <i>agony</i> to remain on that museum piece for as long as we did.<p>I am upgrade-minded, but my management is not. I always lose.<p>I am retiring in two years. I will not miss their problems, not at all.<p>Edit: Oracle 10g was the last release that (for us) brought <i>must-have</i> features. Sure, upgrading to 19 or 23 would be great, but it doesn&#x27;t bring anything that I really <i>want</i>.</div><br/></div></div><div id="41875321" class="c"><input type="checkbox" id="c-41875321" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41875253">prev</a><span>|</span><a href="#41876746">next</a><span>|</span><label class="collapse" for="c-41875321">[-]</label><label class="expand" for="c-41875321">[10 more]</label></div><br/><div class="children"><div class="content">Databases tend to be &quot;stickier&quot; than other parts of any large software system. Largely because database migrations are costly. You can&#x27;t just tear down an old database and rebuild a new one, you have to figure out how to move all that data across too.<p>The consequence is that things in database-land tends to move slower than other types of software. This I think is the major reason why we still use SQL.</div><br/><div id="41875368" class="c"><input type="checkbox" id="c-41875368" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41875321">parent</a><span>|</span><a href="#41875643">next</a><span>|</span><label class="collapse" for="c-41875368">[-]</label><label class="expand" for="c-41875368">[5 more]</label></div><br/><div class="children"><div class="content">Have postgres updates actually been requiring users do migrations? Or is this just a fear that something will go wrong?</div><br/><div id="41876371" class="c"><input type="checkbox" id="c-41876371" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41875321">root</a><span>|</span><a href="#41875368">parent</a><span>|</span><a href="#41875513">next</a><span>|</span><label class="collapse" for="c-41876371">[-]</label><label class="expand" for="c-41876371">[1 more]</label></div><br/><div class="children"><div class="content">From what I can gather, yes[1]:<p><i>A dump&#x2F;reload of the database or use of the pg_upgrade application is required for major upgrades.</i><p>Now, seems one can mostly use pg_upgrade, which only rewrites the system tables[2] so is fairly quick. But if on-disk format has changed it seems you&#x27;re forced to dump and reload.<p>At work we&#x27;ve mainly been using SQLAnywhere, which would just disable new functionality for databases using old on-disk format. So upgrading major versions has usually been fairly painless and quick.<p>[1]: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;support&#x2F;versioning&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;support&#x2F;versioning&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;pgupgrade.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;pgupgrade.html</a></div><br/></div></div><div id="41875513" class="c"><input type="checkbox" id="c-41875513" checked=""/><div class="controls bullet"><span class="by">bc_programming</span><span>|</span><a href="#41875321">root</a><span>|</span><a href="#41875368">parent</a><span>|</span><a href="#41876371">prev</a><span>|</span><a href="#41875643">next</a><span>|</span><label class="collapse" for="c-41875513">[-]</label><label class="expand" for="c-41875513">[3 more]</label></div><br/><div class="children"><div class="content">Well if it&#x27;s self-hosted you have to do it yourself. You can either backup your databases from the old version and restore it to the new version once installed, or you can use pg_upgrade to upgrade&#x2F;copy a old version data directory to the new version.<p>I don&#x27;t think this is done automatically when you simply install a new postgres version, but I&#x27;m not certain of that.</div><br/></div></div></div></div><div id="41875643" class="c"><input type="checkbox" id="c-41875643" checked=""/><div class="controls bullet"><span class="by">polishdude20</span><span>|</span><a href="#41875321">parent</a><span>|</span><a href="#41875368">prev</a><span>|</span><a href="#41876746">next</a><span>|</span><label class="collapse" for="c-41875643">[-]</label><label class="expand" for="c-41875643">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the SQL alternative?</div><br/><div id="41876579" class="c"><input type="checkbox" id="c-41876579" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#41875321">root</a><span>|</span><a href="#41875643">parent</a><span>|</span><a href="#41875871">next</a><span>|</span><label class="collapse" for="c-41876579">[-]</label><label class="expand" for="c-41876579">[2 more]</label></div><br/><div class="children"><div class="content">Hopefully Edgedb. It could make most ORMs and heavyweight web frameworks redundant, maybe some BI tools and jobs too.<p><a href="https:&#x2F;&#x2F;www.edgedb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.edgedb.com&#x2F;</a></div><br/><div id="41877541" class="c"><input type="checkbox" id="c-41877541" checked=""/><div class="controls bullet"><span class="by">adhamsalama</span><span>|</span><a href="#41875321">root</a><span>|</span><a href="#41876579">parent</a><span>|</span><a href="#41875871">next</a><span>|</span><label class="collapse" for="c-41877541">[-]</label><label class="expand" for="c-41877541">[1 more]</label></div><br/><div class="children"><div class="content">Looks kind of like PRQL <a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql</a></div><br/></div></div></div></div><div id="41875871" class="c"><input type="checkbox" id="c-41875871" checked=""/><div class="controls bullet"><span class="by">p10_user</span><span>|</span><a href="#41875321">root</a><span>|</span><a href="#41875643">parent</a><span>|</span><a href="#41876579">prev</a><span>|</span><a href="#41876746">next</a><span>|</span><label class="collapse" for="c-41875871">[-]</label><label class="expand" for="c-41875871">[1 more]</label></div><br/><div class="children"><div class="content">JSON - er JSON-based document storage - documents with unique identifiers. and the ability to define and set schemas for the JSON, and ... we&#x27;re back to a relational database</div><br/></div></div></div></div></div></div><div id="41876746" class="c"><input type="checkbox" id="c-41876746" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#41875321">prev</a><span>|</span><a href="#41875089">next</a><span>|</span><label class="collapse" for="c-41876746">[-]</label><label class="expand" for="c-41876746">[6 more]</label></div><br/><div class="children"><div class="content">i ll tell you why from my end. I installed Postgres14 via homebrew many years ago on my Apple M1 mac mini. I searched a lot on how to &quot;upgrade&quot; this installation but found nothing. I have a few databases running with data on it which I can&#x27;t afford to lose if something goes down for more than 1 hour. I wish someone would guide me on how to actually install a newer postgres such as v17 without breaking an existing v14 install or losing data since I am not an expert by any means</div><br/><div id="41876775" class="c"><input type="checkbox" id="c-41876775" checked=""/><div class="controls bullet"><span class="by">sofixa</span><span>|</span><a href="#41876746">parent</a><span>|</span><a href="#41877506">next</a><span>|</span><label class="collapse" for="c-41876775">[-]</label><label class="expand" for="c-41876775">[1 more]</label></div><br/><div class="children"><div class="content">And this, kids, is a good example of why homebrew is not a real package manager, and why macOS is not the best at running production services.<p>I hope you have a backup somewhere else, not on the Mac Mini. One option would be to restore it on another machine on Postgres 14, follow the upgrade path to 17 (idk if you can jump directly but a few Google searches will cover this), verify the data, back up the new db, somehow upgrade Posgtres on your Mac, and restore the new back up. Done.</div><br/></div></div><div id="41877506" class="c"><input type="checkbox" id="c-41877506" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#41876746">parent</a><span>|</span><a href="#41876775">prev</a><span>|</span><a href="#41876779">next</a><span>|</span><label class="collapse" for="c-41877506">[-]</label><label class="expand" for="c-41877506">[1 more]</label></div><br/><div class="children"><div class="content">This kind of sounds like a Homebrew issue…?<p>I’ve run multiple variants of PostgreSQL on my MacBook under MacPorts. Can’t even remember the last time I thought about it, to be honest.</div><br/></div></div><div id="41876779" class="c"><input type="checkbox" id="c-41876779" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#41876746">parent</a><span>|</span><a href="#41877506">prev</a><span>|</span><a href="#41875089">next</a><span>|</span><label class="collapse" for="c-41876779">[-]</label><label class="expand" for="c-41876779">[3 more]</label></div><br/><div class="children"><div class="content">Forget about something as major as Postgres, I have trouble updating packages (that aren&#x27;t install via pip&#x2F;npm&#x2F;cargo) on Linux all the time as a newbie. The experience is worse than Windows for some reason.<p>Hell, I have a hard time to <i>tell</i> the version of some system build-in binaries.<p>A few months ago, I have trouble to unzip a file which turns out ot be AES-encrypted. Some answers on SO [1] saying I should update my `unzip` to newer version but I can&#x27;t find any updates for my distro, and I have no idea (still no, so feel free to teach me) to update it manually to make my `unzip` supporting AES. And all the versions, the good and the bad, all say they&#x27;re &quot;version 6.0.0&quot; despite they behavior obviously differently.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;60674080&#x2F;how-to-open-winzip-password-protected-archive&#x2F;60676298#60676298" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;60674080&#x2F;how-to-open-win...</a></div><br/><div id="41876830" class="c"><input type="checkbox" id="c-41876830" checked=""/><div class="controls bullet"><span class="by">sofixa</span><span>|</span><a href="#41876746">root</a><span>|</span><a href="#41876779">parent</a><span>|</span><a href="#41875089">next</a><span>|</span><label class="collapse" for="c-41876830">[-]</label><label class="expand" for="c-41876830">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I have trouble updating packages (that aren&#x27;t install via pip&#x2F;npm&#x2F;cargo) on Linux all the time as a newbie. The experience is worse than Windows for some reason<p>If you haven&#x27;t installed them via your programming language&#x27;s package manager, you either installed them manually or via the OS package manager. The first one you&#x27;d know how to upgrade, and for the second you can ask it what version it is and what version is available to upgrade to (for compatibility reasons it might not be the latest, or latest major, unless you use the software vendor&#x27;s own package manager repositories).<p>It&#x27;s actually much easier than in Windows, because you have a piece of software (package manager) that is your one stop shop to knowing what is installed, update it, check versions available, etc. <i>unless you&#x27;ve manually installed stuff</i>.<p>In Windows you... google and download random 
.exes? Cool. As good as the worst possible option on Linux.</div><br/><div id="41876905" class="c"><input type="checkbox" id="c-41876905" checked=""/><div class="controls bullet"><span class="by">thrdbndndn</span><span>|</span><a href="#41876746">root</a><span>|</span><a href="#41876830">parent</a><span>|</span><a href="#41875089">next</a><span>|</span><label class="collapse" for="c-41876905">[-]</label><label class="expand" for="c-41876905">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly random. It&#x27;s not hard to tell which website is official 7-zip website. Also choco and scoop exist on Windows.<p>&gt; As good as the worst possible option on Linux.<p>I understand this is not a fair comparison, but in practice, they&#x27;re not as easy. When using Windows, I usually use it with a proper GUI interface, so popping up a browser and download the newest installer for a software from their official website would take me less than 1 min.<p>Doing similar for my Linux VPS with only a terminal is much more complicated.</div><br/></div></div></div></div></div></div></div></div><div id="41875089" class="c"><input type="checkbox" id="c-41875089" checked=""/><div class="controls bullet"><span class="by">xpasky</span><span>|</span><a href="#41876746">prev</a><span>|</span><a href="#41876834">next</a><span>|</span><label class="collapse" for="c-41875089">[-]</label><label class="expand" for="c-41875089">[2 more]</label></div><br/><div class="children"><div class="content">Related...<p><pre><code>  postgres    1958  0.0  0.0 247616 26040 ?        S    Jul21   3:03 &#x2F;usr&#x2F;lib&#x2F;postgresql&#x2F;11&#x2F;bin&#x2F;postgres
  postgres 1085195  0.0  0.0 249804 24740 ?        Ss   Aug19   2:01 &#x2F;usr&#x2F;lib&#x2F;postgresql&#x2F;13&#x2F;bin&#x2F;postgres
  postgres 1085196  0.0  0.0 223240 27900 ?        Ss   Aug19   1:59 &#x2F;usr&#x2F;lib&#x2F;postgresql&#x2F;15&#x2F;bin&#x2F;postgres
</code></pre>
Postgres is the only thing on my Debian that doesn&#x27;t seamlessly automatically upgrade across dist-upgrades, but instead leaves old versions around for me to deal with manually... which I seem to never get around to.</div><br/><div id="41875113" class="c"><input type="checkbox" id="c-41875113" checked=""/><div class="controls bullet"><span class="by">heavyset_go</span><span>|</span><a href="#41875089">parent</a><span>|</span><a href="#41876834">next</a><span>|</span><label class="collapse" for="c-41875113">[-]</label><label class="expand" for="c-41875113">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because you install versioned packages like postgresql-15: <a href="https:&#x2F;&#x2F;tracker.debian.org&#x2F;pkg&#x2F;postgresql-15" rel="nofollow">https:&#x2F;&#x2F;tracker.debian.org&#x2F;pkg&#x2F;postgresql-15</a><p>That way you can have multiple versions of the same package.</div><br/></div></div></div></div><div id="41876834" class="c"><input type="checkbox" id="c-41876834" checked=""/><div class="controls bullet"><span class="by">arend321</span><span>|</span><a href="#41875089">prev</a><span>|</span><a href="#41877282">next</a><span>|</span><label class="collapse" for="c-41876834">[-]</label><label class="expand" for="c-41876834">[1 more]</label></div><br/><div class="children"><div class="content">I guess I&#x27;m lucky and 10 minutes of downtime is not a problem for my customers during off-peak hours, every year or so. Upgrading has always been a painless experience with just a pg_dump and pg_restore on the upgraded db server.</div><br/></div></div><div id="41877282" class="c"><input type="checkbox" id="c-41877282" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#41876834">prev</a><span>|</span><a href="#41875117">next</a><span>|</span><label class="collapse" for="c-41877282">[-]</label><label class="expand" for="c-41877282">[1 more]</label></div><br/><div class="children"><div class="content">Our team uses AWS managed postgres, and the ease of operations and upgrades really alleviates stress for us. Managed DBs are worth the cost.</div><br/></div></div><div id="41875117" class="c"><input type="checkbox" id="c-41875117" checked=""/><div class="controls bullet"><span class="by">Apreche</span><span>|</span><a href="#41877282">prev</a><span>|</span><a href="#41877071">next</a><span>|</span><label class="collapse" for="c-41875117">[-]</label><label class="expand" for="c-41875117">[5 more]</label></div><br/><div class="children"><div class="content">Because upgrading is a lot of work, and is higher risk than upgrading other software.</div><br/><div id="41875174" class="c"><input type="checkbox" id="c-41875174" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41875117">parent</a><span>|</span><a href="#41877335">next</a><span>|</span><label class="collapse" for="c-41875174">[-]</label><label class="expand" for="c-41875174">[3 more]</label></div><br/><div class="children"><div class="content">Seems like a massive design fail if they can&#x27;t maintain backwards compatability and provide a safe, low friction upgrade process.</div><br/><div id="41875459" class="c"><input type="checkbox" id="c-41875459" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#41875117">root</a><span>|</span><a href="#41875174">parent</a><span>|</span><a href="#41876082">next</a><span>|</span><label class="collapse" for="c-41875459">[-]</label><label class="expand" for="c-41875459">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more about avoiding downtime (I just upgraded a pg with 1TB of data from v11 to v16 and I didn&#x27;t notice any breaking changes). In an ideal world, every client of the DB should be able to handle the case where the DB is down and patiently wait for the DB to come back to keep doing its job. But from my experience, it&#x27;s rarely the case, there is always at least 1 micro service running somewhere in the cloud that everybody forgot about that will just crash if the DB is down, which could mean losing data.</div><br/></div></div><div id="41876082" class="c"><input type="checkbox" id="c-41876082" checked=""/><div class="controls bullet"><span class="by">voidfunc</span><span>|</span><a href="#41875117">root</a><span>|</span><a href="#41875174">parent</a><span>|</span><a href="#41875459">prev</a><span>|</span><a href="#41877335">next</a><span>|</span><label class="collapse" for="c-41876082">[-]</label><label class="expand" for="c-41876082">[1 more]</label></div><br/><div class="children"><div class="content">95% of projects are design fails in this regard... few projects think about Day 2 Ops</div><br/></div></div></div></div><div id="41877335" class="c"><input type="checkbox" id="c-41877335" checked=""/><div class="controls bullet"><span class="by">forinti</span><span>|</span><a href="#41875117">parent</a><span>|</span><a href="#41875174">prev</a><span>|</span><a href="#41877071">next</a><span>|</span><label class="collapse" for="c-41877335">[-]</label><label class="expand" for="c-41877335">[1 more]</label></div><br/><div class="children"><div class="content">I find that upgrading Postgresql is really easy.<p>Testing all the apps that use it, not so much.</div><br/></div></div></div></div><div id="41877071" class="c"><input type="checkbox" id="c-41877071" checked=""/><div class="controls bullet"><span class="by">TomK32</span><span>|</span><a href="#41875117">prev</a><span>|</span><a href="#41875996">next</a><span>|</span><label class="collapse" for="c-41877071">[-]</label><label class="expand" for="c-41877071">[1 more]</label></div><br/><div class="children"><div class="content">Ha, I run arch on my dev machine and they just LOVE upgrading postgres. t has always been a pain until my projects all got their postgres in a docker container. I just don&#x27;t like to do extra steps for the upgrade process between major versions.</div><br/></div></div><div id="41875996" class="c"><input type="checkbox" id="c-41875996" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#41877071">prev</a><span>|</span><a href="#41877232">next</a><span>|</span><label class="collapse" for="c-41875996">[-]</label><label class="expand" for="c-41875996">[2 more]</label></div><br/><div class="children"><div class="content">Quick note that the article is talking about why folks are on versions of PG that are not ancient (14, 15).</div><br/><div id="41877185" class="c"><input type="checkbox" id="c-41877185" checked=""/><div class="controls bullet"><span class="by">craigds</span><span>|</span><a href="#41875996">parent</a><span>|</span><a href="#41877232">next</a><span>|</span><label class="collapse" for="c-41877185">[-]</label><label class="expand" for="c-41877185">[1 more]</label></div><br/><div class="children"><div class="content">right? we&#x27;re on 13 and only now starting to consider upgrading to 16, and I don&#x27;t think we&#x27;re very abnormal and I don&#x27;t consider 13 ancient. We have customers still using 9.3. (That last one does actually count as ancient.)</div><br/></div></div></div></div><div id="41877232" class="c"><input type="checkbox" id="c-41877232" checked=""/><div class="controls bullet"><span class="by">lousken</span><span>|</span><a href="#41875996">prev</a><span>|</span><a href="#41877051">next</a><span>|</span><label class="collapse" for="c-41877232">[-]</label><label class="expand" for="c-41877232">[1 more]</label></div><br/><div class="children"><div class="content">pg15 is not ancient at all and it has been a part of latest debian hence I don&#x27;t see an issue. Same with python or any other dependency. You rarely need the newest shiny these days and being within the support window is fine</div><br/></div></div><div id="41877051" class="c"><input type="checkbox" id="c-41877051" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41877232">prev</a><span>|</span><a href="#41876324">next</a><span>|</span><label class="collapse" for="c-41877051">[-]</label><label class="expand" for="c-41877051">[1 more]</label></div><br/><div class="children"><div class="content">For the same reason lots of companies are stuck on Java 8, .NET Framework, C++98 &#x2F; C++11, C89,.....</div><br/></div></div><div id="41876324" class="c"><input type="checkbox" id="c-41876324" checked=""/><div class="controls bullet"><span class="by">redslazer</span><span>|</span><a href="#41877051">prev</a><span>|</span><a href="#41875471">next</a><span>|</span><label class="collapse" for="c-41876324">[-]</label><label class="expand" for="c-41876324">[2 more]</label></div><br/><div class="children"><div class="content">Funnily enough neon does not offer an easy way to upgrade database compared to other managed database hosting.</div><br/><div id="41876617" class="c"><input type="checkbox" id="c-41876617" checked=""/><div class="controls bullet"><span class="by">andrenotgiant</span><span>|</span><a href="#41876324">parent</a><span>|</span><a href="#41875471">next</a><span>|</span><label class="collapse" for="c-41876617">[-]</label><label class="expand" for="c-41876617">[1 more]</label></div><br/><div class="children"><div class="content">(Neon employee) We auto-upgrade minor versions as long as they can be done autonomously. For major versions, you&#x27;re right it&#x27;s still manual but we&#x27;re working on improving that. Here is our version policy: <a href="https:&#x2F;&#x2F;neon.tech&#x2F;docs&#x2F;postgresql&#x2F;postgres-version-policy" rel="nofollow">https:&#x2F;&#x2F;neon.tech&#x2F;docs&#x2F;postgresql&#x2F;postgres-version-policy</a></div><br/></div></div></div></div><div id="41875471" class="c"><input type="checkbox" id="c-41875471" checked=""/><div class="controls bullet"><span class="by">yobert</span><span>|</span><a href="#41876324">prev</a><span>|</span><a href="#41875265">next</a><span>|</span><label class="collapse" for="c-41875471">[-]</label><label class="expand" for="c-41875471">[4 more]</label></div><br/><div class="children"><div class="content">I have a large production deployment that is still on 9.6 because the software depends on table inheritance. (Oh man!)</div><br/><div id="41876689" class="c"><input type="checkbox" id="c-41876689" checked=""/><div class="controls bullet"><span class="by">mnahkies</span><span>|</span><a href="#41875471">parent</a><span>|</span><a href="#41877352">next</a><span>|</span><label class="collapse" for="c-41876689">[-]</label><label class="expand" for="c-41876689">[2 more]</label></div><br/><div class="children"><div class="content">Unless I&#x27;m mistaken table inheritance is still a thing in current PG versions, in terms of partitioning at least it&#x27;s just less commonly used in favour of declarative partitioning since it&#x27;s easier to manage.<p>It&#x27;s been a long time since I worked with v9.x in anger, so I could well be forgetting things though<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;ddl-partitioning.html#DDL-PARTITIONING-USING-INHERITANCE" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;ddl-partitioning.htm...</a></div><br/><div id="41877142" class="c"><input type="checkbox" id="c-41877142" checked=""/><div class="controls bullet"><span class="by">yobert</span><span>|</span><a href="#41875471">root</a><span>|</span><a href="#41876689">parent</a><span>|</span><a href="#41877352">next</a><span>|</span><label class="collapse" for="c-41877142">[-]</label><label class="expand" for="c-41877142">[1 more]</label></div><br/><div class="children"><div class="content">Our problem isn&#x27;t the inheritance feature itself-- it&#x27;s the removal of the config knob `sql_inheritance` which lets you change whether inherited tables are included in queries by default or not (behavior controlled manually by the * notation). It&#x27;s a goofy behavior nobody liked, but we have a mountain of SQL that depends on that knob. It&#x27;s fixable... Just a pain :)</div><br/></div></div></div></div><div id="41877352" class="c"><input type="checkbox" id="c-41877352" checked=""/><div class="controls bullet"><span class="by">forinti</span><span>|</span><a href="#41875471">parent</a><span>|</span><a href="#41876689">prev</a><span>|</span><a href="#41875265">next</a><span>|</span><label class="collapse" for="c-41877352">[-]</label><label class="expand" for="c-41877352">[1 more]</label></div><br/><div class="children"><div class="content">For a while I had a separate version 9 cluster because of one application.<p>But it wasn&#x27;t really a nuisance. Postgresql doesn&#x27;t give a DBA much to worry about.</div><br/></div></div></div></div><div id="41875265" class="c"><input type="checkbox" id="c-41875265" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41875471">prev</a><span>|</span><a href="#41875061">next</a><span>|</span><label class="collapse" for="c-41875265">[-]</label><label class="expand" for="c-41875265">[4 more]</label></div><br/><div class="children"><div class="content">If PostgreSQL has replication, why are they talking about &quot;minimal&quot; downtime? Is there no quorum strategy that delivers high availability? I don&#x27;t know as much as I should.</div><br/><div id="41875844" class="c"><input type="checkbox" id="c-41875844" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41875265">parent</a><span>|</span><a href="#41875061">next</a><span>|</span><label class="collapse" for="c-41875844">[-]</label><label class="expand" for="c-41875844">[3 more]</label></div><br/><div class="children"><div class="content">Writes happen on your primary. At some point, you need to stop accepting writes, wait for the replica to fully catch up, reverse the replication so the replica is the new primary, then direct writes to the new primary. That&#x27;s hard to do without <i>any</i> downtime.<p>There&#x27;s no option where the nodes all accept writes.</div><br/><div id="41876300" class="c"><input type="checkbox" id="c-41876300" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41875265">root</a><span>|</span><a href="#41875844">parent</a><span>|</span><a href="#41875061">next</a><span>|</span><label class="collapse" for="c-41876300">[-]</label><label class="expand" for="c-41876300">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;warm-standby.html#SYNCHRONOUS-REPLICATION-HA" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;warm-standby.html#SY...</a> mentions quorum-based synchronous replication, which sounds encouraging.</div><br/><div id="41876360" class="c"><input type="checkbox" id="c-41876360" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41875265">root</a><span>|</span><a href="#41876300">parent</a><span>|</span><a href="#41875061">next</a><span>|</span><label class="collapse" for="c-41876360">[-]</label><label class="expand" for="c-41876360">[1 more]</label></div><br/><div class="children"><div class="content">That still only has one primary: you can&#x27;t just start pointing writes at the upgraded standbys. Synchronous replication (besides having its own downsides) just shortens the time needed for the replicas to catch up. You still need to perform a cutover.</div><br/></div></div></div></div></div></div></div></div><div id="41875061" class="c"><input type="checkbox" id="c-41875061" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#41875265">prev</a><span>|</span><a href="#41875730">next</a><span>|</span><label class="collapse" for="c-41875061">[-]</label><label class="expand" for="c-41875061">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always found it fascinating that there is a vocal contingent at HN that seems to legitimately hate advertising. But then an article like this turns up that is obvious advertising and is also a good article - we get a nice summary of what the major performance features over different postgres versions are, and some interesting case studies (I&#x27;d never even heard of the NOT VALID option although apparently it is nothing new).</div><br/><div id="41875283" class="c"><input type="checkbox" id="c-41875283" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#41875061">parent</a><span>|</span><a href="#41875176">next</a><span>|</span><label class="collapse" for="c-41875283">[-]</label><label class="expand" for="c-41875283">[2 more]</label></div><br/><div class="children"><div class="content">This is something I&#x27;ve heard called &quot;permission marketing&quot;. The idea is that you show genuinely useful ads to only the few people who will benefit from them, rather than indiscriminately blasting millions of innocent bystanders. Then these few people will actually welcome your marketing efforts.<p>The classic example is advertising a new improved fishing reel in a fishing magazine. People buy the magazine (well, 20 years ago they did) because they <i>want</i> to know about things like new improved fishing reels.<p>It&#x27;s a world away from the overwhelming avalanche of bullshit that is modern advertising&#x2F;spam. There&#x27;s nothing at all weird about hating advertising in general but being ok with permission marketing.<p>If you follow this idea further you&#x27;ll find that very few people, even the most vocal, genuinely hate <i>advertising</i>. We all want to know about useful products and services. We just don&#x27;t want to see a million ads a day for Apple, Coke, Pepsi, Nike,  erectile dysfunction, fake single women in your area, Nigerian princes...<p>Because when it reaches a certain scale, and when too many psychological tricks are being played, and everything is always, BRIGHT, BIG, hyper-sexualized, when you can&#x27;t walk down any street, watch anything, read anything, without seeing people richer, smarter, younger, sexier, happier than you, it goes far beyond just advertising. It&#x27;s brainwashing. It has to stop because it&#x27;s extremely unhealthy for our societies, our mental health, our children.</div><br/><div id="41875997" class="c"><input type="checkbox" id="c-41875997" checked=""/><div class="controls bullet"><span class="by">shiroiushi</span><span>|</span><a href="#41875061">root</a><span>|</span><a href="#41875283">parent</a><span>|</span><a href="#41875176">next</a><span>|</span><label class="collapse" for="c-41875997">[-]</label><label class="expand" for="c-41875997">[1 more]</label></div><br/><div class="children"><div class="content">Well said.  If I&#x27;m reading about fishing, for instance, an ad for a new piece of fishing gear would not be too annoying, as long as it isn&#x27;t too intrusive (like popping up in the middle of my reading).<p>But when I&#x27;m watching a YouTube video, having the video cut <i>mid-sentence</i> to some hyper-annoying and unrelated noisy ad simply angers me and makes me look for an ad-blocker.</div><br/></div></div></div></div><div id="41875176" class="c"><input type="checkbox" id="c-41875176" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#41875061">parent</a><span>|</span><a href="#41875283">prev</a><span>|</span><a href="#41875403">next</a><span>|</span><label class="collapse" for="c-41875176">[-]</label><label class="expand" for="c-41875176">[1 more]</label></div><br/><div class="children"><div class="content">I rarely see much objection to contentful &#x27;advertising&#x27; like this. Anyway, the answer really is that it&#x27;s fully handled by submission&#x2F;voting&#x2F;flagging mechanisms, doesn&#x27;t matter what anyone might say.</div><br/></div></div><div id="41875403" class="c"><input type="checkbox" id="c-41875403" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#41875061">parent</a><span>|</span><a href="#41875176">prev</a><span>|</span><a href="#41875730">next</a><span>|</span><label class="collapse" for="c-41875403">[-]</label><label class="expand" for="c-41875403">[1 more]</label></div><br/><div class="children"><div class="content">Yes but Neon databases is a funder of Postgres development. So I&#x27;m interested in hearing what they have to say. If they&#x27;re advertising then I think helping open source is the right way to go about it. To me it sounds like they just want to make sure people benefit from all the money they&#x27;re spending.</div><br/></div></div></div></div><div id="41875730" class="c"><input type="checkbox" id="c-41875730" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#41875061">prev</a><span>|</span><a href="#41877183">next</a><span>|</span><label class="collapse" for="c-41875730">[-]</label><label class="expand" for="c-41875730">[2 more]</label></div><br/><div class="children"><div class="content">corporate friction</div><br/><div id="41876933" class="c"><input type="checkbox" id="c-41876933" checked=""/><div class="controls bullet"><span class="by">linuxandrew</span><span>|</span><a href="#41875730">parent</a><span>|</span><a href="#41877183">next</a><span>|</span><label class="collapse" for="c-41876933">[-]</label><label class="expand" for="c-41876933">[1 more]</label></div><br/><div class="children"><div class="content">Exactly this. At my old employer we (the sysadmins&#x2F;operational DBAs) were pushing for newer, supported versions of Postgres. The push back was always the regression testing cycle, amount of desired change and willingness of the product owner to even engage. The testing cycle was so long that I tried to convince them to test on Postgres beta, because it would well and truly be prod with a few bugfix releases by the time testing was completed (alas, they went with n-1 release of Postgres instead).</div><br/></div></div></div></div><div id="41877183" class="c"><input type="checkbox" id="c-41877183" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#41875730">prev</a><span>|</span><a href="#41875170">next</a><span>|</span><label class="collapse" for="c-41877183">[-]</label><label class="expand" for="c-41877183">[1 more]</label></div><br/><div class="children"><div class="content">oh no, do i hear postgres fanboys cry in unison again?</div><br/></div></div><div id="41875170" class="c"><input type="checkbox" id="c-41875170" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#41877183">prev</a><span>|</span><a href="#41875178">next</a><span>|</span><label class="collapse" for="c-41875170">[-]</label><label class="expand" for="c-41875170">[2 more]</label></div><br/><div class="children"><div class="content">Honestly, I&#x27;ve aside from React and Java (8 -&gt; 21 is big but still not that big), there&#x27;s very little software that I updated and noticed a major step change difference in the system. Once it works, its fine</div><br/><div id="41875214" class="c"><input type="checkbox" id="c-41875214" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#41875170">parent</a><span>|</span><a href="#41875178">next</a><span>|</span><label class="collapse" for="c-41875214">[-]</label><label class="expand" for="c-41875214">[1 more]</label></div><br/><div class="children"><div class="content">Postgres and mysql usually have changes in each new version that are important enough to motivate an upgrade, whatever it is new features or better performance or both. Although it really depends if your are using the features they are improving or not (e.g. if you don&#x27;t use partitions, well of course that 30% perf improvement on write operations on partitions won&#x27;t benefit you).<p>You can check this article about Uber migrating its Mysql from v5 to v8 posted here 3 days ago [1]. Among other things, they observed a &quot;~94% reduction in overall database lock time.&quot; The before&#x2F;after graph is pretty impressive. It also gave them window functions and better JSON support, which are two very big features.<p>[1] <a href="https:&#x2F;&#x2F;www.uber.com&#x2F;en-JO&#x2F;blog&#x2F;upgrading-ubers-mysql-fleet" rel="nofollow">https:&#x2F;&#x2F;www.uber.com&#x2F;en-JO&#x2F;blog&#x2F;upgrading-ubers-mysql-fleet</a></div><br/></div></div></div></div><div id="41875178" class="c"><input type="checkbox" id="c-41875178" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#41875170">prev</a><span>|</span><a href="#41875116">next</a><span>|</span><label class="collapse" for="c-41875178">[-]</label><label class="expand" for="c-41875178">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Postgres 17.0 has been out for a bit and ...<p>No. It&#x27;s been released in September 2024. That&#x27;s not &quot;quite a bit&quot;.<p>Now as to why people aren&#x27;t all on 17 and not even on 16 yet, here&#x27;s an acronym for you: LTS [1]<p>Debian 11 Bullseye is the current LTS. It came out in 2021.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Long-term_support" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Long-term_support</a></div><br/><div id="41875638" class="c"><input type="checkbox" id="c-41875638" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#41875178">parent</a><span>|</span><a href="#41875606">next</a><span>|</span><label class="collapse" for="c-41875638">[-]</label><label class="expand" for="c-41875638">[1 more]</label></div><br/><div class="children"><div class="content">PostgreSQL doesn&#x27;t have a long term support policy [1]. They release a new version around this time every year, and support it for about 5 years.<p>[1] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;support&#x2F;versioning&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;support&#x2F;versioning&#x2F;</a></div><br/></div></div><div id="41875606" class="c"><input type="checkbox" id="c-41875606" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41875178">parent</a><span>|</span><a href="#41875638">prev</a><span>|</span><a href="#41875765">next</a><span>|</span><label class="collapse" for="c-41875606">[-]</label><label class="expand" for="c-41875606">[1 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t say &quot;quite a bit&quot; (long time), they said &quot;a bit&quot; (short time).</div><br/></div></div><div id="41875765" class="c"><input type="checkbox" id="c-41875765" checked=""/><div class="controls bullet"><span class="by">hairyplanter</span><span>|</span><a href="#41875178">parent</a><span>|</span><a href="#41875606">prev</a><span>|</span><a href="#41875116">next</a><span>|</span><label class="collapse" for="c-41875765">[-]</label><label class="expand" for="c-41875765">[2 more]</label></div><br/><div class="children"><div class="content">Debian doesn&#x27;t have LTS and non-LTS.<p>Debian has Stable. That&#x27;s it.</div><br/><div id="41876528" class="c"><input type="checkbox" id="c-41876528" checked=""/><div class="controls bullet"><span class="by">rationably</span><span>|</span><a href="#41875178">root</a><span>|</span><a href="#41875765">parent</a><span>|</span><a href="#41875116">next</a><span>|</span><label class="collapse" for="c-41876528">[-]</label><label class="expand" for="c-41876528">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;wiki.debian.org&#x2F;LTS" rel="nofollow">https:&#x2F;&#x2F;wiki.debian.org&#x2F;LTS</a></div><br/></div></div></div></div></div></div><div id="41875116" class="c"><input type="checkbox" id="c-41875116" checked=""/><div class="controls bullet"><span class="by">nathanaldensr</span><span>|</span><a href="#41875178">prev</a><span>|</span><a href="#41876183">next</a><span>|</span><label class="collapse" for="c-41875116">[-]</label><label class="expand" for="c-41875116">[3 more]</label></div><br/><div class="children"><div class="content">Weird that the maybe-AI-generated image of a column says &quot;Postgres 13&quot; on it when the article talks about Postgres 17.</div><br/><div id="41875275" class="c"><input type="checkbox" id="c-41875275" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#41875116">parent</a><span>|</span><a href="#41876183">next</a><span>|</span><label class="collapse" for="c-41875275">[-]</label><label class="expand" for="c-41875275">[2 more]</label></div><br/><div class="children"><div class="content">Seems perfectly reasonable to me. The article is about people not upgrading from older versions. One could imagine that PostgreSQL 13.0 is the “pillar” of some company, that their whole system relies upon. The article then goes into detail on what they are missing out on by not upgrading PostgreSQL to a more recent major version, and why it might be that so many stay on ancient versions, and also how you can actually perform major version upgrades of PostgreSQL.</div><br/><div id="41876558" class="c"><input type="checkbox" id="c-41876558" checked=""/><div class="controls bullet"><span class="by">FearNotDaniel</span><span>|</span><a href="#41875116">root</a><span>|</span><a href="#41875275">parent</a><span>|</span><a href="#41876183">next</a><span>|</span><label class="collapse" for="c-41876558">[-]</label><label class="expand" for="c-41876558">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I mean it&#x27;s not <i>hugely</i> imaginative, but it kind of makes sense, if you want to describe pg 13 as &quot;ancient&quot; that you use some kind of Greek&#x2F;Roman temple as a visual analogy for that. Not particularly well executed - a serif font might have helped to drive the &quot;joke&quot; home - but nobody&#x27;s trying to win an art contest here.</div><br/></div></div></div></div></div></div><div id="41876183" class="c"><input type="checkbox" id="c-41876183" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#41875116">prev</a><span>|</span><label class="collapse" for="c-41876183">[-]</label><label class="expand" for="c-41876183">[1 more]</label></div><br/><div class="children"><div class="content">Because we don&#x27;t really like it to begin with.<p>The RDBMS has not fundamentally changed much since the 80&#x27;s. It&#x27;s the same basic design inside and out, with a shitload of tweaks and optimizations. Don&#x27;t get me wrong - you can get very far with tweaks and optimizations. But the foundations root you to a particular model, and some things in that model will always be painful.<p>The important question to me isn&#x27;t why don&#x27;t people upgrade. It&#x27;s why do people run Postgres?<p>Is there no other kind of database? No, there are hundreds of different databases. Is it because Postgres does things fundamentally different and better than anything else? No, lots of things work somewhat like Postgres, with pros and cons. Is it because you can&#x27;t do things without Postgres? No, there are always alternatives that you can make work. Is it because it&#x27;s impossible for it to keep working without upgrading? No, any database with long-term support could continue working without upgrading.<p>So why use Postgres at all? Answer: it&#x27;s the incumbency, stupid.<p>When a big fucking honking giant &quot;thing&quot; sucks up all the air in the room, provides for most of the use cases, and is accepted by all the users, then it&#x27;s extremely hard to justify <i>not</i> using it. Incumbents usually win, even if they&#x27;re old, disreputable, buggy, and annoying. Even if they&#x27;re missing some obvious features other things have. Even if people loudly complain that they want change. It&#x27;s just more annoying <i>not</i> to use them.<p>We&#x27;re used to them. We&#x27;ve adapted. Trying to do something else is going to be annoying and hard. So we stick to what we know. But that doesn&#x27;t mean we have to stroke the balls while working the shaft. Upgrading isn&#x27;t exactly fun. It doesn&#x27;t even buy us anything, other than the promise of &quot;support&quot;, or &quot;compatibility&quot; with whatever else will eventually require it. So we upgrade, eventually, when we must.<p>But the constant mind-numbing march away from entropy isn&#x27;t a fantastic reason to keep using the thing. When you have to convince yourself to stick with it, it&#x27;s likely you&#x27;re in an toxic relationship. If you&#x27;re honest with yourself, you&#x27;ll agree that it&#x27;s time for a change. You deserve better.<p>But switching is full of unknowns. Ominous. Time-consuming. <i>Hard.</i> You know you want to, maybe even need to. But there&#x27;s too much to lose. So you stick to the familiar, to what you can handle. Maybe something better will come down the pike soon. You even tell yourself you&#x27;re lucky to be here. But deep down you know you&#x27;re just comforting yourself. You wish you had something else. Something that brings you joy. Something better. Something... <i>right</i>.  But that something isn&#x27;t here right now. So until Mr. Right gets here, you&#x27;ll stick with Mr. Right Now.<p>Time to get ready for the next upgrade.....  sigh...</div><br/></div></div></div></div></div></div></div></body></html>