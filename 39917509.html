<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712221254621" as="style"/><link rel="stylesheet" href="styles.css?v=1712221254621"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://developers.redhat.com/articles/2024/04/03/improvements-static-analysis-gcc-14-compiler">Improvements to static analysis in GCC 14</a> <span class="domain">(<a href="https://developers.redhat.com">developers.redhat.com</a>)</span></div><div class="subtext"><span>dmalcolm</span> | <span>101 comments</span></div><br/><div><div id="39928003" class="c"><input type="checkbox" id="c-39928003" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#39922145">next</a><span>|</span><label class="collapse" for="c-39928003">[-]</label><label class="expand" for="c-39928003">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really great. Shear amount of work is huge. It seems difficulty level is on par with introducing fat pointers&#x2F;array views into stdlib and C standard.</div><br/></div></div><div id="39922145" class="c"><input type="checkbox" id="c-39922145" checked=""/><div class="controls bullet"><span class="by">quincepie</span><span>|</span><a href="#39928003">prev</a><span>|</span><a href="#39920533">next</a><span>|</span><label class="collapse" for="c-39922145">[-]</label><label class="expand" for="c-39922145">[32 more]</label></div><br/><div class="children"><div class="content">To me fanalyzer is one of GCC killer features over clang. It makes programming C much easier by explaining errors. The error messages also began to feel similar to Rust in terms of being developer friendly.</div><br/><div id="39922603" class="c"><input type="checkbox" id="c-39922603" checked=""/><div class="controls bullet"><span class="by">mr_00ff00</span><span>|</span><a href="#39922145">parent</a><span>|</span><a href="#39922724">next</a><span>|</span><label class="collapse" for="c-39922603">[-]</label><label class="expand" for="c-39922603">[25 more]</label></div><br/><div class="children"><div class="content">I know Rust (esp on HN) is very hyped for its memory safety and nice abstractions, but I really wonder how much Rust owes its popularity to its error messages.<p>I would say the #1 reason I stop learning a technology is because of frustrating or unclear errors.<p>EDIT: Getting a bit of topic, but I meant more because I love C and would love it more with rust level error messages.</div><br/><div id="39924945" class="c"><input type="checkbox" id="c-39924945" checked=""/><div class="controls bullet"><span class="by">darby_eight</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922603">parent</a><span>|</span><a href="#39922796">next</a><span>|</span><label class="collapse" for="c-39924945">[-]</label><label class="expand" for="c-39924945">[5 more]</label></div><br/><div class="children"><div class="content">Clang already had decent error messages by the time rust stabilized. There&#x27;s simply not much you can do at runtime to explain a segfault.</div><br/><div id="39925311" class="c"><input type="checkbox" id="c-39925311" checked=""/><div class="controls bullet"><span class="by">GrumpySloth</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39924945">parent</a><span>|</span><a href="#39922796">next</a><span>|</span><label class="collapse" for="c-39925311">[-]</label><label class="expand" for="c-39925311">[4 more]</label></div><br/><div class="children"><div class="content">Not when you called templated functions and were greeted with compile-time template stack traces. Or you called overloaded functions and were presented with 50 alternatives you might have meant. The language is inherently unfriendly to user-friendly error messages.</div><br/><div id="39925322" class="c"><input type="checkbox" id="c-39925322" checked=""/><div class="controls bullet"><span class="by">darby_eight</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39925311">parent</a><span>|</span><a href="#39922796">next</a><span>|</span><label class="collapse" for="c-39925322">[-]</label><label class="expand" for="c-39925322">[3 more]</label></div><br/><div class="children"><div class="content">Rust doesn&#x27;t have templates, mister c plus plus user.<p>Perhaps you might include an example of such a user-unfriendly message?</div><br/><div id="39925378" class="c"><input type="checkbox" id="c-39925378" checked=""/><div class="controls bullet"><span class="by">GrumpySloth</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39925322">parent</a><span>|</span><a href="#39922796">next</a><span>|</span><label class="collapse" for="c-39925378">[-]</label><label class="expand" for="c-39925378">[2 more]</label></div><br/><div class="children"><div class="content">I’m talking about C++. You wrote that Clang already had friendly error messages. While they were less unfriendly than GCC, calling them friendly is a stretch.<p>Rust having traits instead of templates is a big ergonomic improvement in that area.</div><br/><div id="39927067" class="c"><input type="checkbox" id="c-39927067" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39925378">parent</a><span>|</span><a href="#39922796">next</a><span>|</span><label class="collapse" for="c-39927067">[-]</label><label class="expand" for="c-39927067">[1 more]</label></div><br/><div class="children"><div class="content">Funnily enough, trait bounds are still a big pain in the neck to provide good diagnostics for because of the amount of things that need to be tracked that are cross cutting across stages of the compiler that under normal operation don&#x27;t need to talk to each other. They got better in 2018, as async&#x2F;await put them even more front and center and focused some attention on them, and a lot of work for keeping additional metadata around was added since then (search the codebase for enum ObligationCauseCode if you&#x27;re curious) to improve them. Now with the new &quot;next&quot; trait solver they have a chance to get even better.<p>It still easier than providing good diagnostics for template errors though :) (althought I&#x27;m convinced that if addressing those errors was high priority, common cases of template instantiations could be modeled internally in the same way as traits purely for diagnostics and materially improve the situation — I understand why it hasn&#x27;t happened, it is hard and not obviously important).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39922796" class="c"><input type="checkbox" id="c-39922796" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922603">parent</a><span>|</span><a href="#39924945">prev</a><span>|</span><a href="#39923127">next</a><span>|</span><label class="collapse" for="c-39922796">[-]</label><label class="expand" for="c-39922796">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what makes me wary of modifying my NixOS config. A single typo and you get an error dump comparable to C++03 templates.</div><br/><div id="39923402" class="c"><input type="checkbox" id="c-39923402" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922796">parent</a><span>|</span><a href="#39926662">next</a><span>|</span><label class="collapse" for="c-39923402">[-]</label><label class="expand" for="c-39923402">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s definitely the most painful part of iterating on Nix code for me, even in simple configs. You eventually develop an intuition for common problems and rely more on that than on deciphering the stack traces, but that&#x27;s really not ideal.</div><br/></div></div><div id="39926662" class="c"><input type="checkbox" id="c-39926662" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922796">parent</a><span>|</span><a href="#39923402">prev</a><span>|</span><a href="#39923117">next</a><span>|</span><label class="collapse" for="c-39926662">[-]</label><label class="expand" for="c-39926662">[1 more]</label></div><br/><div class="children"><div class="content">Actually, thats a reason why I never even touched Nix.  Besides, being functional and all the hype, but the syntax and naming of the language feels ad-hoc enough for me to never have caught on...</div><br/></div></div><div id="39923117" class="c"><input type="checkbox" id="c-39923117" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922796">parent</a><span>|</span><a href="#39926662">prev</a><span>|</span><a href="#39923127">next</a><span>|</span><label class="collapse" for="c-39923117">[-]</label><label class="expand" for="c-39923117">[3 more]</label></div><br/><div class="children"><div class="content">... but you do get an error. That&#x27;s a lot better what you typically get with C or C++. Assuming it&#x27;s valid systax, of course.<p>This is a veering off topic, but I do agree that Nix-the-language has a lot of issues.<p>(You might suggest Guix, but I don&#x27;t want to faff about with non-supported repositories for table stakes like firmware and such. Maybe Nickel will eventually provide a more pleasant and principled way to define Nix configurations?)</div><br/><div id="39924345" class="c"><input type="checkbox" id="c-39924345" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923117">parent</a><span>|</span><a href="#39923127">next</a><span>|</span><label class="collapse" for="c-39924345">[-]</label><label class="expand" for="c-39924345">[2 more]</label></div><br/><div class="children"><div class="content">My favourite Nix error message is<p><pre><code>    infinite recursion encountered, at undefined position</code></pre></div><br/><div id="39924918" class="c"><input type="checkbox" id="c-39924918" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39924345">parent</a><span>|</span><a href="#39923127">next</a><span>|</span><label class="collapse" for="c-39924918">[-]</label><label class="expand" for="c-39924918">[1 more]</label></div><br/><div class="children"><div class="content">Haha, reminds me of some Scheme interpreter that would just say something like &#x27;missing paren&#x27; at position 0 or EOF depending on where the imbalance was :)<p>... but, yeah... I&#x27;m pretty sure there could be <i>some</i> hints as to whereabouts that infinite recursion was detected.</div><br/></div></div></div></div></div></div></div></div><div id="39923127" class="c"><input type="checkbox" id="c-39923127" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922603">parent</a><span>|</span><a href="#39922796">prev</a><span>|</span><a href="#39923044">next</a><span>|</span><label class="collapse" for="c-39923127">[-]</label><label class="expand" for="c-39923127">[3 more]</label></div><br/><div class="children"><div class="content">Arguably Rust got good error messages by learning from Elm: <a href="https:&#x2F;&#x2F;elm-lang.org&#x2F;news&#x2F;compiler-errors-for-humans" rel="nofollow">https:&#x2F;&#x2F;elm-lang.org&#x2F;news&#x2F;compiler-errors-for-humans</a></div><br/><div id="39924147" class="c"><input type="checkbox" id="c-39924147" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923127">parent</a><span>|</span><a href="#39924949">next</a><span>|</span><label class="collapse" for="c-39924147">[-]</label><label class="expand" for="c-39924147">[1 more]</label></div><br/><div class="children"><div class="content">Elm is acknowledged as being the initial inspiration for focusing on diagnostics early on, but Rust got good error messages through elbow grease and focused attention over a long period of time.<p>People getting used to good errors and demanding more, is part of the virtuous circle that keeps them high quality.<p>Making good looking diagnostics requires UX work, but making <i>good diagnostics</i> requires a flexible compiler architecture and a lot of effort, nothing more, nothing less.</div><br/></div></div><div id="39924949" class="c"><input type="checkbox" id="c-39924949" checked=""/><div class="controls bullet"><span class="by">darby_eight</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923127">parent</a><span>|</span><a href="#39924147">prev</a><span>|</span><a href="#39923044">next</a><span>|</span><label class="collapse" for="c-39924949">[-]</label><label class="expand" for="c-39924949">[1 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s eye towards errors predates Elm entirely.</div><br/></div></div></div></div><div id="39923044" class="c"><input type="checkbox" id="c-39923044" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922603">parent</a><span>|</span><a href="#39923127">prev</a><span>|</span><a href="#39923255">next</a><span>|</span><label class="collapse" for="c-39923044">[-]</label><label class="expand" for="c-39923044">[4 more]</label></div><br/><div class="children"><div class="content">Yeah Rust is popular because it&#x27;s a practical language with a nice type system, decent escape hatches, and good tooling. The borrow checker attracts some, but it could have easily been done in a way with terrible usability.</div><br/><div id="39924955" class="c"><input type="checkbox" id="c-39924955" checked=""/><div class="controls bullet"><span class="by">darby_eight</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923044">parent</a><span>|</span><a href="#39923255">next</a><span>|</span><label class="collapse" for="c-39924955">[-]</label><label class="expand" for="c-39924955">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The borrow checker attracts some, but it could have easily been done in a way with terrible usability.<p>Why would anyone use the resulting language over C? What you&#x27;re describing is C with a slightly friendlier compiler.</div><br/><div id="39925341" class="c"><input type="checkbox" id="c-39925341" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39924955">parent</a><span>|</span><a href="#39923255">next</a><span>|</span><label class="collapse" for="c-39925341">[-]</label><label class="expand" for="c-39925341">[2 more]</label></div><br/><div class="children"><div class="content">I have never heard C as being described to have a good type system.</div><br/><div id="39925483" class="c"><input type="checkbox" id="c-39925483" checked=""/><div class="controls bullet"><span class="by">darby_eight</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39925341">parent</a><span>|</span><a href="#39923255">next</a><span>|</span><label class="collapse" for="c-39925483">[-]</label><label class="expand" for="c-39925483">[1 more]</label></div><br/><div class="children"><div class="content">You could try to argue this is the only source of rust&#x27;s popularity.... or you could admit that the borrow checker is in fact a reason why folks use Rust over C.</div><br/></div></div></div></div></div></div></div></div><div id="39923255" class="c"><input type="checkbox" id="c-39923255" checked=""/><div class="controls bullet"><span class="by">jonathankoren</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922603">parent</a><span>|</span><a href="#39923044">prev</a><span>|</span><a href="#39923062">next</a><span>|</span><label class="collapse" for="c-39923255">[-]</label><label class="expand" for="c-39923255">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I would say the #1 reason I stop learning a technology is because of frustrating or unclear errors.<p>Overly verbose error messages that obscure more than illuminate are chief complaint against C++.<p>Honestly, they can just sap all the energy out of a project.</div><br/><div id="39923317" class="c"><input type="checkbox" id="c-39923317" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923255">parent</a><span>|</span><a href="#39923062">next</a><span>|</span><label class="collapse" for="c-39923317">[-]</label><label class="expand" for="c-39923317">[1 more]</label></div><br/><div class="children"><div class="content">&quot;You violated a template rule.  Here&#x27;s a novel on everything that&#x27;s broken as a result&quot;<p>It&#x27;s why the Constraint system was important for C++.</div><br/></div></div></div></div><div id="39923062" class="c"><input type="checkbox" id="c-39923062" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922603">parent</a><span>|</span><a href="#39923255">prev</a><span>|</span><a href="#39922724">next</a><span>|</span><label class="collapse" for="c-39923062">[-]</label><label class="expand" for="c-39923062">[4 more]</label></div><br/><div class="children"><div class="content">The hard problem with C is that it&#x27;s hard to tell if what the programmer wrote is an error. Hence warnings... which can be very hit or miss, or absurd overkill in some cases.<p>(Signed overflow being a prime example where you really either just need to <i>define</i> what happens or accept that your compiler is basically never going to warn you about a possible signed overflow -- which is UB. The compromise here by Rust is to allow one to pick between some implementation defined behaviors. That seems pretty sensible.)</div><br/><div id="39923223" class="c"><input type="checkbox" id="c-39923223" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923062">parent</a><span>|</span><a href="#39922724">next</a><span>|</span><label class="collapse" for="c-39923223">[-]</label><label class="expand" for="c-39923223">[3 more]</label></div><br/><div class="children"><div class="content">For signed overflow I use -fsanitize=signed-integer-overflow .</div><br/><div id="39923356" class="c"><input type="checkbox" id="c-39923356" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923223">parent</a><span>|</span><a href="#39922724">next</a><span>|</span><label class="collapse" for="c-39923356">[-]</label><label class="expand" for="c-39923356">[2 more]</label></div><br/><div class="children"><div class="content">Good. I wonder how many people do and also if their compilers support it. (One would hope so, of course. I assume clang and GCC do.)<p>... but the question is really what you ship to production.<p>Btw, possible signed overflow was just an example of things <i>people do not want warnings for</i>. OOB is far more dangerous, obviously... and the cost for sanitizer in <i>that</i> case is HUGE... and it doesn&#x27;t actually catch all cases AFAIUI.</div><br/><div id="39927831" class="c"><input type="checkbox" id="c-39927831" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39923356">parent</a><span>|</span><a href="#39922724">next</a><span>|</span><label class="collapse" for="c-39927831">[-]</label><label class="expand" for="c-39927831">[1 more]</label></div><br/><div class="children"><div class="content">For OOB you can enable bound checking in the C++ standard library. That&#x27;s relatively cheap. Of course it won&#x27;t help with C raw pointers and C array.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39922724" class="c"><input type="checkbox" id="c-39922724" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#39922145">parent</a><span>|</span><a href="#39922603">prev</a><span>|</span><a href="#39922643">next</a><span>|</span><label class="collapse" for="c-39922724">[-]</label><label class="expand" for="c-39922724">[3 more]</label></div><br/><div class="children"><div class="content">I have had the exact opposite experience: clang constantly gives me much better error messages than GCC, implementations of some warnings or errors catch more cases, and clang-tidy is able to do much better static analysis.</div><br/><div id="39926026" class="c"><input type="checkbox" id="c-39926026" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39922724">parent</a><span>|</span><a href="#39922643">next</a><span>|</span><label class="collapse" for="c-39926026">[-]</label><label class="expand" for="c-39926026">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Copilot explain this error&quot; has made this whole discussion irrelevant for me.</div><br/><div id="39927194" class="c"><input type="checkbox" id="c-39927194" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39926026">parent</a><span>|</span><a href="#39922643">next</a><span>|</span><label class="collapse" for="c-39927194">[-]</label><label class="expand" for="c-39927194">[1 more]</label></div><br/><div class="children"><div class="content">An issue is immediacy: problems are better the earlier they are pointed out (why online errors are better than compile errorswl, which are better than CI errors, which are runtime errors). Having to copy paste an error adds a layer of indirection that gets in the way of the flow.<p>Another is reproducibility and accuracy: LLMs have a tendency to confidently state things that are wrong, and to say different things to different people, the compiler has the advantage of being deterministic and generally have better understanding of what&#x27;s going on to produce correct suggestions (although we still have cases of incorrect assumptions producing invalid suggestions, I believe we have a good track record there).<p>If those tools help you, more power to you, but I fear their use by inexperienced rustaceans being misled (an expert can identify when the bot is wrong, a novice might just end up questioning their sanity).<p><i>Side note: the more I write the more I realize that the same concerns I have with LLMs also apply to the compiler in some way and am trying to bridge that cognitive dissonance. I&#x27;m guessing that the reproducibility argument, ensuring the same good error triggers for everyone that makes the same mistake and the lack of human curation, are the thing that makes me uneasy about LLMs for teaching languages.</i></div><br/></div></div></div></div></div></div><div id="39922643" class="c"><input type="checkbox" id="c-39922643" checked=""/><div class="controls bullet"><span class="by">someplaceguy</span><span>|</span><a href="#39922145">parent</a><span>|</span><a href="#39922724">prev</a><span>|</span><a href="#39924938">next</a><span>|</span><label class="collapse" for="c-39922643">[-]</label><label class="expand" for="c-39922643">[1 more]</label></div><br/><div class="children"><div class="content">Clang has a similar tool, the Clang Static Analyzer: <a href="https:&#x2F;&#x2F;clang-analyzer.llvm.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;clang-analyzer.llvm.org&#x2F;</a></div><br/></div></div><div id="39924938" class="c"><input type="checkbox" id="c-39924938" checked=""/><div class="controls bullet"><span class="by">darby_eight</span><span>|</span><a href="#39922145">parent</a><span>|</span><a href="#39922643">prev</a><span>|</span><a href="#39920533">next</a><span>|</span><label class="collapse" for="c-39924938">[-]</label><label class="expand" for="c-39924938">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m quite surprised that clang doesn&#x27;t have static analysis! That doesn&#x27;t seem right, but I don&#x27;t program much in C anymore.</div><br/><div id="39925290" class="c"><input type="checkbox" id="c-39925290" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39922145">root</a><span>|</span><a href="#39924938">parent</a><span>|</span><a href="#39920533">next</a><span>|</span><label class="collapse" for="c-39925290">[-]</label><label class="expand" for="c-39925290">[1 more]</label></div><br/><div class="children"><div class="content">It does. However it catches some different things*</div><br/></div></div></div></div></div></div><div id="39920533" class="c"><input type="checkbox" id="c-39920533" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#39922145">prev</a><span>|</span><a href="#39920861">next</a><span>|</span><label class="collapse" for="c-39920533">[-]</label><label class="expand" for="c-39920533">[1 more]</label></div><br/><div class="children"><div class="content">36 more comments in this other thread:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39918278">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39918278</a> (<i>&quot;GCC 14 Boasts Nice ASCII Art for Visualizing Buffer Overflows (phoronix.com)&quot;</i>, 2 hours ago)</div><br/></div></div><div id="39920861" class="c"><input type="checkbox" id="c-39920861" checked=""/><div class="controls bullet"><span class="by">Davidbrcz</span><span>|</span><a href="#39920533">prev</a><span>|</span><a href="#39920429">next</a><span>|</span><label class="collapse" for="c-39920861">[-]</label><label class="expand" for="c-39920861">[2 more]</label></div><br/><div class="children"><div class="content">I wish there was a better output format for the analysis, because this is hell for screen readers.</div><br/><div id="39921261" class="c"><input type="checkbox" id="c-39921261" checked=""/><div class="controls bullet"><span class="by">dmalcolm</span><span>|</span><a href="#39920861">parent</a><span>|</span><a href="#39920429">next</a><span>|</span><label class="collapse" for="c-39921261">[-]</label><label class="expand" for="c-39921261">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I implemented SARIF output in GCC 13 which is viewable by e.g. VS Code (via a plugin) - though the ASCII art isn&#x27;t.<p>You can see an example of the output here:
  <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;aan6Kfxds" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;aan6Kfxds</a>
(that&#x27;s the first example from the article, with -fdiagnostics-format=sarif-stderr added to the command-line options)<p>I experimented with SVG output for the diagrams, but didn&#x27;t get this in good enough shape for GCC 14.</div><br/></div></div></div></div><div id="39920429" class="c"><input type="checkbox" id="c-39920429" checked=""/><div class="controls bullet"><span class="by">1udfx9cf8azi0</span><span>|</span><a href="#39920861">prev</a><span>|</span><a href="#39919544">next</a><span>|</span><label class="collapse" for="c-39920429">[-]</label><label class="expand" for="c-39920429">[7 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    if (nbytes &lt; sizeof(*hwrpb))
        return -1;
    
    if (copy_to_user(buffer, hwrpb, nbytes) != 0)
        return -2;
</code></pre>
The fix that was done was:<p><pre><code>    if (nbytes &gt; sizeof(*hwrpb))
</code></pre>
But I think the correct fix is:<p><pre><code>    if (copy_to_user(buffer, hwrpb, sizeof(*hwrpb)) != 0)
</code></pre>
It never makes sense to copy out of the hwrpb pointer any size other than sizeof(*hwrpb).</div><br/><div id="39920587" class="c"><input type="checkbox" id="c-39920587" checked=""/><div class="controls bullet"><span class="by">pwagland</span><span>|</span><a href="#39920429">parent</a><span>|</span><a href="#39919544">next</a><span>|</span><label class="collapse" for="c-39920587">[-]</label><label class="expand" for="c-39920587">[6 more]</label></div><br/><div class="children"><div class="content">Right, but the size of the buffer is given, it doesn&#x27;t make sense to stomp over end of the callers buffer either, so you can&#x27;t use pass in something longer than `nbytes` either.</div><br/><div id="39920823" class="c"><input type="checkbox" id="c-39920823" checked=""/><div class="controls bullet"><span class="by">1udfx9cf8azi0</span><span>|</span><a href="#39920429">root</a><span>|</span><a href="#39920587">parent</a><span>|</span><a href="#39919544">next</a><span>|</span><label class="collapse" for="c-39920823">[-]</label><label class="expand" for="c-39920823">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what the original check is for:<p><pre><code>    if (nbytes &lt; sizeof(*hwrpb))
</code></pre>
If the buffer isn&#x27;t large enough to hold *hwrpb, then it already fails. The original check was good, only needed to change the amount of bytes copied to sizeof(*hwrpb).</div><br/><div id="39921786" class="c"><input type="checkbox" id="c-39921786" checked=""/><div class="controls bullet"><span class="by">sltkr</span><span>|</span><a href="#39920429">root</a><span>|</span><a href="#39920823">parent</a><span>|</span><a href="#39921667">next</a><span>|</span><label class="collapse" for="c-39921786">[-]</label><label class="expand" for="c-39921786">[2 more]</label></div><br/><div class="children"><div class="content">No, because if nbytes &gt; sizeof(*hwrpb), your version causes the kernel to only write part of the buffer, and then when the app accesses fields at the end of the struct, it would read uninitialized data, which is very bad.<p>Recall that the API is intended to be used like this:<p><pre><code>    struct hwrbp buf;
    getsysinfo(GSI_GET_HWRPB, &amp;buf, sizeof(buf), &#x2F;* .. *&#x2F;);
</code></pre>
At first glance, it might seem unnecessary to pass the buffer size at all, because in theory the user and kernel should agree on what the sizeof(struct hwrbp) is. But the reason it is passed is because there are various reasons why the separately compiled kernel and user binaries might disagree (e.g., incorrect compiler flags, wrong header file being used, struct has changed between different versions, etc.), and it&#x27;s useful to detect that. So you can make an argument that the most conservative check is:<p><pre><code>    if (nbytes != sizeof(\*hwrpb)) return -1;
</code></pre>
After all, if the user and kernel disagree on the correct size of the struct, then <i>something</i> is wrong! But allowing nbytes &lt; sizeof(*hwrpb) has the benefit that the kernel developers can add fields at the end of the struct without breaking backward compatibility with older applications.<p>I would agree with you if the kernel had some other mechanism to pass the size of the buffer that was actually filled to the client (like e.g. the read() syscall does) but the getsysinfo() API doesn&#x27;t return that data, so the kernel must either fill the buffer entirely or return failure.*</div><br/><div id="39922042" class="c"><input type="checkbox" id="c-39922042" checked=""/><div class="controls bullet"><span class="by">1udfx9cf8azi0</span><span>|</span><a href="#39920429">root</a><span>|</span><a href="#39921786">parent</a><span>|</span><a href="#39921667">next</a><span>|</span><label class="collapse" for="c-39922042">[-]</label><label class="expand" for="c-39922042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No, because if nbytes &gt; sizeof(*hwrpb), your version causes the kernel to only write part of the buffer, and then when the app accesses fields at the end of the struct, it would read uninitialized data, which is very bad.<p>&gt; I would agree with you if the kernel had some other mechanism to pass the size of the buffer that was actually filled to the client (like e.g. the read() syscall does) but the getsysinfo() API doesn&#x27;t return that data, so the kernel must either fill the buffer entirely or return failure.<p>As you mention, this struct is versioned. Userspace can tell how much of the struct was filled by checking the size field (hwrpb-&gt;size).<p>&gt; But allowing nbytes &lt; sizeof(*hwrpb) has the benefit that the kernel developers can add fields at the end of the struct without breaking backward compatibility with older applications.<p>That&#x27;s a related but separate issue. Backward compatibility can be handled by switching on nbytes or by copying fewer bytes with a carefully designed struct. It&#x27;s not clear that backward compatibility was the original intention of this code, the original intention more seems to be sanitizing tainted input. This struct has not changed in at least 16 years.</div><br/></div></div></div></div><div id="39921667" class="c"><input type="checkbox" id="c-39921667" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#39920429">root</a><span>|</span><a href="#39920823">parent</a><span>|</span><a href="#39921786">prev</a><span>|</span><a href="#39919544">next</a><span>|</span><label class="collapse" for="c-39921667">[-]</label><label class="expand" for="c-39921667">[2 more]</label></div><br/><div class="children"><div class="content">The original less-than check was deemed incorrect, and was replaced entirely. For good or for ill, it seems the author deems it valid to pass in a value smaller than sizeof *hwrpb, and that many bytes will be dutifully copied. This might form part of some barebones API versioning mechanism.</div><br/><div id="39921803" class="c"><input type="checkbox" id="c-39921803" checked=""/><div class="controls bullet"><span class="by">1udfx9cf8azi0</span><span>|</span><a href="#39920429">root</a><span>|</span><a href="#39921667">parent</a><span>|</span><a href="#39919544">next</a><span>|</span><label class="collapse" for="c-39921803">[-]</label><label class="expand" for="c-39921803">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The original less-than check was deemed incorrect<p>It was only deemed incorrect because of an information leak. Not because it&#x27;s a valid use-case for user space to copy smaller portions of *hwrpb into user space. <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;21c5977a836e399fc710ff2c5367845ed5c2527f">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;commit&#x2F;21c5977a836e399fc71...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39919544" class="c"><input type="checkbox" id="c-39919544" checked=""/><div class="controls bullet"><span class="by">noam_k</span><span>|</span><a href="#39920429">prev</a><span>|</span><a href="#39919999">next</a><span>|</span><label class="collapse" for="c-39919544">[-]</label><label class="expand" for="c-39919544">[52 more]</label></div><br/><div class="children"><div class="content">Very cool stuff!<p>I haven&#x27;t done much C development lately, so I&#x27;m curious how often `strcpy` and `strcat` are used. Last I checked they&#x27;re almost as big no-nos as using goto. (Yes, I know goto is often preferred in kernel dev...) Can anyone share on how helpful the c-string analyses are to them?</div><br/><div id="39920264" class="c"><input type="checkbox" id="c-39920264" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39919544">parent</a><span>|</span><a href="#39919962">next</a><span>|</span><label class="collapse" for="c-39920264">[-]</label><label class="expand" for="c-39920264">[5 more]</label></div><br/><div class="children"><div class="content">The use of goto is unambiguously correct and elegant in some contexts. Unwavering avoidance of goto can lead to unnecessarily ugly, convoluted code that is difficult to maintain. It usually isn&#x27;t common but it has valid uses.<p>While use of functions like `strcpy` are less advisable, there are contexts in which they are guaranteed to be correct unless other strong (e.g. language-level) invariants are broken, in which case you have much bigger problems. In these somewhat infrequent cases, there is a valid argument that notionally safer alternatives may be slightly less efficient for no benefit.</div><br/><div id="39921230" class="c"><input type="checkbox" id="c-39921230" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920264">parent</a><span>|</span><a href="#39920472">next</a><span>|</span><label class="collapse" for="c-39921230">[-]</label><label class="expand" for="c-39921230">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The use of goto is unambiguously correct and elegant in some contexts.<p>For C, absolutely.  For  C++, it&#x27;s likely a footgun.</div><br/><div id="39922100" class="c"><input type="checkbox" id="c-39922100" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921230">parent</a><span>|</span><a href="#39920472">next</a><span>|</span><label class="collapse" for="c-39922100">[-]</label><label class="expand" for="c-39922100">[1 more]</label></div><br/><div class="children"><div class="content">It has fewer use cases in C++ but it still has use cases where the alternatives are worse.</div><br/></div></div></div></div><div id="39920472" class="c"><input type="checkbox" id="c-39920472" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920264">parent</a><span>|</span><a href="#39921230">prev</a><span>|</span><a href="#39919962">next</a><span>|</span><label class="collapse" for="c-39920472">[-]</label><label class="expand" for="c-39920472">[2 more]</label></div><br/><div class="children"><div class="content">strcpy and friends don&#x27;t really have any benefits beyond just being there. The &quot;safer&quot; versions are still unsafe in many cases, while being less performant and more annoying to use.<p>Writing a strbuffer type and associated functions isn&#x27;t particularly hard and the resulting interface is nicer to use, safer, and more efficient.</div><br/><div id="39928021" class="c"><input type="checkbox" id="c-39928021" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920472">parent</a><span>|</span><a href="#39919962">next</a><span>|</span><label class="collapse" for="c-39928021">[-]</label><label class="expand" for="c-39928021">[1 more]</label></div><br/><div class="children"><div class="content">I argue strview (non-owning) is almost always what is needed. Most of string operations are searching and slicing.</div><br/></div></div></div></div></div></div><div id="39919962" class="c"><input type="checkbox" id="c-39919962" checked=""/><div class="controls bullet"><span class="by">i80and</span><span>|</span><a href="#39919544">parent</a><span>|</span><a href="#39920264">prev</a><span>|</span><a href="#39919647">next</a><span>|</span><label class="collapse" for="c-39919962">[-]</label><label class="expand" for="c-39919962">[1 more]</label></div><br/><div class="children"><div class="content">Some usage of goto is still idiomatic in C if used in ways logically equivalent to structured programming constructs C lacks. It requires some care, but I mean, it&#x27;s C.<p>(I&#x27;m not however fond at all of longjmp)</div><br/></div></div><div id="39919647" class="c"><input type="checkbox" id="c-39919647" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#39919544">parent</a><span>|</span><a href="#39919962">prev</a><span>|</span><a href="#39921483">next</a><span>|</span><label class="collapse" for="c-39919647">[-]</label><label class="expand" for="c-39919647">[27 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing wrong with simple usages of goto.<p>The strxcpy family on the other hand is complete garbage and should never be used for any reason. I&#x27;m horrified that they&#x27;re used in the kernel at all. All of those functions (and every failed attempt at &quot;fixing&quot; them) should have been nuked from orbit.</div><br/><div id="39925963" class="c"><input type="checkbox" id="c-39925963" checked=""/><div class="controls bullet"><span class="by">Ysraes</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919647">parent</a><span>|</span><a href="#39920246">next</a><span>|</span><label class="collapse" for="c-39925963">[-]</label><label class="expand" for="c-39925963">[1 more]</label></div><br/><div class="children"><div class="content">This is the approach taken in git <a href="https:&#x2F;&#x2F;github.com&#x2F;git&#x2F;git&#x2F;blob&#x2F;master&#x2F;banned.h">https:&#x2F;&#x2F;github.com&#x2F;git&#x2F;git&#x2F;blob&#x2F;master&#x2F;banned.h</a></div><br/></div></div><div id="39920246" class="c"><input type="checkbox" id="c-39920246" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919647">parent</a><span>|</span><a href="#39925963">prev</a><span>|</span><a href="#39919820">next</a><span>|</span><label class="collapse" for="c-39920246">[-]</label><label class="expand" for="c-39920246">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s nothing wrong with simple usages of goto<p>Indeed a like a few gotos here and there for doing cleanup toward the end of the function.</div><br/><div id="39920370" class="c"><input type="checkbox" id="c-39920370" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920246">parent</a><span>|</span><a href="#39919820">next</a><span>|</span><label class="collapse" for="c-39920370">[-]</label><label class="expand" for="c-39920370">[1 more]</label></div><br/><div class="children"><div class="content">Or to break out of nested loops. The problem is with unstructured goto spaghetti making the code impossible to follow without essentially running it in your head (or a debugger).<p>Goto + Switch (or the GCC computed goto extension) is also a wonderful way to implement state machines.</div><br/></div></div></div></div><div id="39919820" class="c"><input type="checkbox" id="c-39919820" checked=""/><div class="controls bullet"><span class="by">laweijfmvo</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919647">parent</a><span>|</span><a href="#39920246">prev</a><span>|</span><a href="#39921483">next</a><span>|</span><label class="collapse" for="c-39919820">[-]</label><label class="expand" for="c-39919820">[23 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with `strncpy`?</div><br/><div id="39919907" class="c"><input type="checkbox" id="c-39919907" checked=""/><div class="controls bullet"><span class="by">i80and</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919820">parent</a><span>|</span><a href="#39920378">next</a><span>|</span><label class="collapse" for="c-39919907">[-]</label><label class="expand" for="c-39919907">[12 more]</label></div><br/><div class="children"><div class="content">strncpy won&#x27;t always write a trailing nul byte, causing out of bounds reads elsewhere. It&#x27;s a nasty little fellow. See the warning at <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;strncpy" rel="nofollow">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;3&#x2F;strncpy</a><p>strlcpy() is better and what most people think strncpy() is, but still results in truncated strings if not used carefully which can also lead to big problems.</div><br/><div id="39920050" class="c"><input type="checkbox" id="c-39920050" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919907">parent</a><span>|</span><a href="#39920064">next</a><span>|</span><label class="collapse" for="c-39920050">[-]</label><label class="expand" for="c-39920050">[7 more]</label></div><br/><div class="children"><div class="content">Speaking of strlcpy, Linus has some colorful opinions on it:<p>&gt; Note that we have so few &#x27;strlcpy()&#x27; calls that we really should remove that horrid horrid interface. It&#x27;s a buggy piece of sh*t. &#x27;strlcpy()&#x27; is fundamentally unsafe BY DESIGN if you don&#x27;t trust the source string - which is one of the alleged reasons to use it. --Linus<p>Maybe strscpy is finally the one true fixed design to fix them all. Personally I think the whole exercise is one of unbeliavable stupidity when the real solution is obvious: using proper string buffer types with length and capacity for any sort of string manipulation.</div><br/><div id="39922573" class="c"><input type="checkbox" id="c-39922573" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920050">parent</a><span>|</span><a href="#39920064">next</a><span>|</span><label class="collapse" for="c-39922573">[-]</label><label class="expand" for="c-39922573">[6 more]</label></div><br/><div class="children"><div class="content">&gt; the real solution is obvious<p>If it were obvious it would have been done already. Witness the many variants that try to make it better but don&#x27;t.<p>&gt; using proper string buffer types with length and capacity<p>Which you then can&#x27;t pass to any other library. String management is very easy to solve within the boundaries of your own code. But you&#x27;ll need to interact with existing code as well.</div><br/><div id="39923757" class="c"><input type="checkbox" id="c-39923757" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39922573">parent</a><span>|</span><a href="#39927113">next</a><span>|</span><label class="collapse" for="c-39923757">[-]</label><label class="expand" for="c-39923757">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If it were obvious it would have been done already. Witness the many variants that try to make it better but don&#x27;t.<p>Every other language with mutable strings, including C++, does it like that. It is obvious. The reason it is not done in C is not ignorance, it is laziness.<p>&gt; Which you then can&#x27;t pass to any other library. String management is very easy to solve within the boundaries of your own code. But you&#x27;ll need to interact with existing code as well.<p>Ignoring the also obvious solution of just keeping a null terminator around (see: C++ std::string), you should only worry about it at the boundary with the other library.<p>Same as converting from utf-8 to utf-16 to talk to the Windows API for example.</div><br/><div id="39926593" class="c"><input type="checkbox" id="c-39926593" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39923757">parent</a><span>|</span><a href="#39926817">next</a><span>|</span><label class="collapse" for="c-39926593">[-]</label><label class="expand" for="c-39926593">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The reason it is not done in C is not ignorance, it is laziness.<p>Of course not. C has been around since the dawn of UNIX and the majority of important libraries at the OS level are written in it.<p>Compatibility with such a vast amount of code is a lot more important than anything else.<p>If it were so easy why do you think nobody has done it?<p>&gt; Ignoring the also obvious solution of just keeping a null terminator around<p>That&#x27;s not very useful for the general case. If your code relies on the extra metadata (length, size) being correct and you&#x27;re passing that null-terminated buffer around to libraries outside your code, it won&#x27;t be correct since nothing else is aware of it.</div><br/></div></div><div id="39926817" class="c"><input type="checkbox" id="c-39926817" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39923757">parent</a><span>|</span><a href="#39926593">prev</a><span>|</span><a href="#39927113">next</a><span>|</span><label class="collapse" for="c-39926817">[-]</label><label class="expand" for="c-39926817">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you should only worry about it at the boundary with the other library.<p>If this was a mitigation, it would solve all problems with nul-terminated strings i.e. do strict and error-checked conversions to nul-terminated strings at all boundaries to the program, and then nul-terminated strings and len-specified strings are equivalently dangerous (or safe, depending on your perspective).<p>The problem is precisely that unsanitised input makes its way into the application, bypassing any checks.</div><br/></div></div></div></div><div id="39927113" class="c"><input type="checkbox" id="c-39927113" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39922573">parent</a><span>|</span><a href="#39923757">prev</a><span>|</span><a href="#39920064">next</a><span>|</span><label class="collapse" for="c-39927113">[-]</label><label class="expand" for="c-39927113">[2 more]</label></div><br/><div class="children"><div class="content">For me the &quot;real&quot; solution looks something like this:<p><pre><code>    ssize_t strxcpy(char* restrict dst, const char* restrict src, ssize_t len)
</code></pre>
Strxcpy copies the string from src to dst.  The len parameter is the number of bytes available in the dst buffer.  The dst buffer is always terminated with a null byte, so the maximum length of string that can be copied into it is len - 1.  strxcpy returns the number of characters copied on success, but can return the following negative values:<p><pre><code>    E_INVALID_PARAMETER: Ether dst or src are NULL or len &lt; 1, no data was copied
    W_TRUNCATED: len - 1 bytes were copied but more characters were available in src.
</code></pre>
strxcat would work similarly.  I have not decided if the return value should include the terminating null or not.</div><br/><div id="39927197" class="c"><input type="checkbox" id="c-39927197" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39927113">parent</a><span>|</span><a href="#39920064">next</a><span>|</span><label class="collapse" for="c-39927197">[-]</label><label class="expand" for="c-39927197">[1 more]</label></div><br/><div class="children"><div class="content">How is this useful though? I mean yes, it is useful in avoiding the buffer overruns. But that&#x27;s not the only consideration, you also want code that handles data correctly. This just truncates at buffer size so data is lost.<p>So, if you want the code to work correctly, you need to either check the return code and reallocate dst and call the copy again. But if you&#x27;re going to do that might as well check src len and allocate dst correctly before calling it so it never fails. But if you&#x27;re already doing <i>that</i>, you can call strcpy just fine and never have a problem.</div><br/></div></div></div></div></div></div></div></div><div id="39920064" class="c"><input type="checkbox" id="c-39920064" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919907">parent</a><span>|</span><a href="#39920050">prev</a><span>|</span><a href="#39925420">next</a><span>|</span><label class="collapse" for="c-39920064">[-]</label><label class="expand" for="c-39920064">[1 more]</label></div><br/><div class="children"><div class="content">The problem with strlcpy is the return value.  You can be burned badly if you are using it to for example pull out a fixed chunk of string from a 10TB memory mapped file, especially if you&#x27;re pulling out all of the 32 byte chunks from that huge file and you just wanted a function to stick the trailing 0 on the string and handle short reads gracefully.<p>It&#x27;s even worse if you are using it because you don&#x27;t fully trust the input string to be null terminated.  Maybe you have reasons to be believe that it will be at least as long as you need, but can&#x27;t trust that it is a real string.  As a function that was theoretically written as &quot;fix&quot; for strncpy it is worse in some fundamental ways.  At least strncpy is easy enough to make safe by always over-allocating your buffer by 1 byte and stuffing a 0 in the last byte.</div><br/></div></div><div id="39925420" class="c"><input type="checkbox" id="c-39925420" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919907">parent</a><span>|</span><a href="#39920064">prev</a><span>|</span><a href="#39921823">next</a><span>|</span><label class="collapse" for="c-39925420">[-]</label><label class="expand" for="c-39925420">[1 more]</label></div><br/><div class="children"><div class="content">strncpy() also zero pads the entire buffer. If it&#x27;s significantly larger than the copied string you&#x27;re wasting cycles on pointless move operations for normal, low-security string handling. This behavior is for filling in fixed length fields in data structures. It isn&#x27;t suitable for general purpose string processing.</div><br/></div></div><div id="39921823" class="c"><input type="checkbox" id="c-39921823" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919907">parent</a><span>|</span><a href="#39925420">prev</a><span>|</span><a href="#39920378">next</a><span>|</span><label class="collapse" for="c-39921823">[-]</label><label class="expand" for="c-39921823">[2 more]</label></div><br/><div class="children"><div class="content">#define strncpyz(d,s,l) *(strncpy(d,s,l)+(l))=0<p>Of course this one is unsafe for macro expansion. But well, its C :)</div><br/><div id="39926933" class="c"><input type="checkbox" id="c-39926933" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921823">parent</a><span>|</span><a href="#39920378">next</a><span>|</span><label class="collapse" for="c-39926933">[-]</label><label class="expand" for="c-39926933">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather put the final nul at d+l-1 than at d+l, so that l can be the size of d, not &quot;one more than the size of d&quot;:<p><pre><code>  strncpyz(buf,src,sizeof buf);</code></pre></div><br/></div></div></div></div></div></div><div id="39920378" class="c"><input type="checkbox" id="c-39920378" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919820">parent</a><span>|</span><a href="#39919907">prev</a><span>|</span><a href="#39921626">next</a><span>|</span><label class="collapse" for="c-39920378">[-]</label><label class="expand" for="c-39920378">[1 more]</label></div><br/><div class="children"><div class="content">As others have already pointed out it, it doesn&#x27;t guarantee that the result is null-terminated. But that&#x27;s not the only problem! In addition, it always pads the remaining space with zeros:<p><pre><code>    char buf[1000];
    strncpy(buf, &quot;foo&quot;, sizeof(buf));
</code></pre>
This writes 3 characters and 9997 zeros. It&#x27;s probably not what you want 99% of the time.</div><br/></div></div><div id="39921626" class="c"><input type="checkbox" id="c-39921626" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919820">parent</a><span>|</span><a href="#39920378">prev</a><span>|</span><a href="#39919882">next</a><span>|</span><label class="collapse" for="c-39921626">[-]</label><label class="expand" for="c-39921626">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not possible to use it safely unless you know that the source string fits in the destination buffer. Every strncpy must be followed by `dst[sizeof dst - 1] = 0`, and even if you do that you still have no idea if you truncated the source string, so you have to put in a further check.<p><pre><code>    strncpy (dst, src, (sizeof dst) - 1);
    dst[(sizeof dst) - 1] = 0;
    int truncated = strlen (dst) - strlen (src);
</code></pre>
Without the extra two lines after every strncpy, you&#x27;re probably going to have a a hard to discover transient bug.</div><br/><div id="39923368" class="c"><input type="checkbox" id="c-39923368" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921626">parent</a><span>|</span><a href="#39919882">next</a><span>|</span><label class="collapse" for="c-39923368">[-]</label><label class="expand" for="c-39923368">[6 more]</label></div><br/><div class="children"><div class="content">if you really want to use standard C string functions, use instead:<p><pre><code>    int ret = snprintf(dst, sizeof dst, &quot;%s&quot;, src);
    if (ret &gt;= n || ret &lt; 0)
    {
        &#x2F;* failed *&#x2F;
    }
</code></pre>
or as a function:<p><pre><code>    bool ya_strcpy(const char* s, char* d, size_t n)
    {
        int cp = snprintf(d, n, &quot;%s&quot;, s);
        bool ok = cp &gt;= 0 &amp;&amp; cp &lt; n;
        ok ? *s = *s : 0;
        return ok;
    }</code></pre></div><br/><div id="39927014" class="c"><input type="checkbox" id="c-39927014" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39923368">parent</a><span>|</span><a href="#39927028">next</a><span>|</span><label class="collapse" for="c-39927014">[-]</label><label class="expand" for="c-39927014">[3 more]</label></div><br/><div class="children"><div class="content">snprintf only returns negative if an &quot;encoding error&quot; occurs, which has to do with multi-byte characters.<p>I think for that to possibly happen, you have to be in a locale with some character encoding in effect and snprintf is asked to print some multi-byte sequence that is invalid for that encoding.<p>Thus, I suspect, if you don&#x27;t call that &quot;f...f...frob my C program&quot; function known as setlocale, it will never happen.</div><br/><div id="39927399" class="c"><input type="checkbox" id="c-39927399" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39927014">parent</a><span>|</span><a href="#39927028">next</a><span>|</span><label class="collapse" for="c-39927399">[-]</label><label class="expand" for="c-39927399">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Thus, I suspect, if you don&#x27;t call that &quot;f...f...frob my C program&quot; function known as setlocale, it will never happen.<p>Of all the footguns in a hosted C implementation, I believe setlocale (and locale in general) is so broken that even compilers and library developers can&#x27;t workaround it to make it safe.<p>The only other unfixable C-standard footgun that comes close, I think, are the environment-reading-and-writing functions, but at least with those, worst-case is leaking a negligible amount of memory in normal usage, or using an old value even when a newer one is available.</div><br/><div id="39927574" class="c"><input type="checkbox" id="c-39927574" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39927399">parent</a><span>|</span><a href="#39927028">next</a><span>|</span><label class="collapse" for="c-39927574">[-]</label><label class="expand" for="c-39927574">[1 more]</label></div><br/><div class="children"><div class="content">I see that in Glibc, snprintf goes to the same general _IO_vsprintf function, which has various ominous -1 returns.<p>I don&#x27;t <i>think</i> I see anything that looks like the detection of a conversion error, but rather other reasons. I would have to follow the code in detail to convince myself that glibc&#x27;s snprintf cannot return -1 under some obscure conditions.<p>Defending against that value is probably wise.<p>As far as C locale goes, come on, the design was basically cemented in more or less its current form in 1989 ANSI C. What the hell did anyone know about internationalizing applications in 1989.</div><br/></div></div></div></div></div></div><div id="39927028" class="c"><input type="checkbox" id="c-39927028" checked=""/><div class="controls bullet"><span class="by">aulin</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39923368">parent</a><span>|</span><a href="#39927014">prev</a><span>|</span><a href="#39926827">next</a><span>|</span><label class="collapse" for="c-39927028">[-]</label><label class="expand" for="c-39927028">[1 more]</label></div><br/><div class="children"><div class="content">except no one does that return code check and worse they often use the return code to advance a pointer in concatenated strings</div><br/></div></div><div id="39926827" class="c"><input type="checkbox" id="c-39926827" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39923368">parent</a><span>|</span><a href="#39927028">prev</a><span>|</span><a href="#39919882">next</a><span>|</span><label class="collapse" for="c-39926827">[-]</label><label class="expand" for="c-39926827">[1 more]</label></div><br/><div class="children"><div class="content">I actually <i>do</i> use `snprintf()` and friends.</div><br/></div></div></div></div></div></div><div id="39919882" class="c"><input type="checkbox" id="c-39919882" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919820">parent</a><span>|</span><a href="#39921626">prev</a><span>|</span><a href="#39921422">next</a><span>|</span><label class="collapse" for="c-39919882">[-]</label><label class="expand" for="c-39919882">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t guarantee that the output is null terminated. Big source of exploits.</div><br/></div></div><div id="39921422" class="c"><input type="checkbox" id="c-39921422" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39919820">parent</a><span>|</span><a href="#39919882">prev</a><span>|</span><a href="#39921483">next</a><span>|</span><label class="collapse" for="c-39921422">[-]</label><label class="expand" for="c-39921422">[1 more]</label></div><br/><div class="children"><div class="content">`strncpy` is commonly misunderstood.  It&#x27;s name misleads people into thinking it&#x27;s a safely-truncating version of `strcpy`.  It&#x27;s not.<p>I&#x27;ve seen a lot of code where people changed from `strcpy` to `strncpy` because they thought that was safety and security best practice.  Even sometimes creating a new security vulnerability which wasn&#x27;t there with `strcpy`.<p>`strncpy` does two unexpected things which lead to safety, security and performance issues, especially in large codebases where the destination buffers are passed to other code:<p>• `strncpy` does NOT zero-terminate the copied string if it limits the length.<p>Whatever is given the copied string in future is vulnerable to a buffer-read-overrun and junk characters appended to the string, unless the reader has specific knowledge of the buffer length and is strict about NOT treating it as a null-terminated string.  That&#x27;s unusual C, so it&#x27;s rarely done correctly.  It also doesn&#x27;t show up in testing or normal use, if `strnlen` is &quot;for safety&quot; and nobody enters data that large.<p>• `strncpy` writes the entire destination buffer with zeros after the copied string.<p>Usually this isn&#x27;t a safety and security problem, but it can be terrible for performace if large buffers are being used to ensure there&#x27;s room for all likely input data.<p>I&#x27;ve seen these issues in large, commercial C code, with unfortunate effects:<p>The code had a security fault because under some circumstances, a password check would read characters after the end of a buffer due to lack of a zero-terminator, that authors over the years assumed would always be there.<p>A password change function could set the new password to something different than the user entered, so they couldn&#x27;t login after.<p>The code was assumed to be &quot;fast&quot; because it was C, and avoided &quot;slow&quot; memory allocation and a string API when processing strings.  It used preallocated char arrays all over the place to hold temporary strings and `strncpy` to &quot;safely&quot; copy.  They were wrong: It would have run faster with a clean string API that did allocations (for multiple reasons, not just `strncpy`).<p>Those char arrays had the slight inconvenience of causing oddly mismatched string length limits in text fields all over the place.  But it was worth it for performance, they thought.  To avoid that being a real problem, buffers tended to be sized to be &quot;larger&quot; than any likely value, so buffer sizes like 256 or 1000, 10000 or other arbitrary lengths plucked at random depending on developer mood at the time, and mismatched between countless different places in the large codebase.  `strncpy` was used to write to them.<p>Using `malloc`, or better a proper string object API, would have run much faster in real use, at the same time as being safer and cleaner code.<p>Even worse, sometimes strings would be appended in pieces, each time using `strncpy` with the remaining length of the destination buffer.  That filled the destination with zeros repeatedly, for every few characters appended.  Sometimes causing user-interactions that would take milliseconds if coded properly, to take minutes.<p>Ironically, even a slow scripting language like Python using ordinary string type would have probably run faster than the C application.  (Also Python dictionaries would have been faster than the buggy C hash tables in that application which took O(n) lookup time, and SQLite database tables would have been faster, smaller and simpler than the slow and large C &quot;optimised&quot; data structures they used to store data).</div><br/></div></div></div></div></div></div><div id="39921483" class="c"><input type="checkbox" id="c-39921483" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39919544">parent</a><span>|</span><a href="#39919647">prev</a><span>|</span><a href="#39920028">next</a><span>|</span><label class="collapse" for="c-39921483">[-]</label><label class="expand" for="c-39921483">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Last I checked they&#x27;re almost as big no-nos as using goto.<p>I don&#x27;t think so. Gotos are fine, strcat and strcpy without a malloc with the correct size in the same scope is a code smell.</div><br/></div></div><div id="39920028" class="c"><input type="checkbox" id="c-39920028" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39919544">parent</a><span>|</span><a href="#39921483">prev</a><span>|</span><a href="#39920146">next</a><span>|</span><label class="collapse" for="c-39920028">[-]</label><label class="expand" for="c-39920028">[2 more]</label></div><br/><div class="children"><div class="content">gotos are fine if used judiciously. strcpy and strcat are “fine” in that they work when you know your code is correct and you have big problems if you don’t. But this describes most of C, unfortunately.</div><br/><div id="39924312" class="c"><input type="checkbox" id="c-39924312" checked=""/><div class="controls bullet"><span class="by">dmit</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920028">parent</a><span>|</span><a href="#39920146">next</a><span>|</span><label class="collapse" for="c-39924312">[-]</label><label class="expand" for="c-39924312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; gotos are fine if used judiciously<p>Is there a language feature that is not? :)</div><br/></div></div></div></div><div id="39920146" class="c"><input type="checkbox" id="c-39920146" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39919544">parent</a><span>|</span><a href="#39920028">prev</a><span>|</span><a href="#39919999">next</a><span>|</span><label class="collapse" for="c-39920146">[-]</label><label class="expand" for="c-39920146">[15 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Last I checked they&#x27;re almost as big no-nos as using goto.</i><p>Huh? Why is goto a no-no? It is there for good reason. I think we all agree with Dijkstra that, in his words, unbridled gotos are harmful, but C&#x27;s goto is most definitely bridled. I doubt any language created in the last 50+ years has unbridled gotos. That&#x27;s an ancient programming technique that went out of fashion long ago (in large part because of Dijkstra).</div><br/><div id="39921279" class="c"><input type="checkbox" id="c-39921279" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920146">parent</a><span>|</span><a href="#39920756">next</a><span>|</span><label class="collapse" for="c-39921279">[-]</label><label class="expand" for="c-39921279">[13 more]</label></div><br/><div class="children"><div class="content">Languages other than C give you options for flow control so that you don&#x27;t need goto for that.  It is a spectrum, if you only use goto to jump to the end of a small function on error it is okay, though I prefer something better in my language.  I&#x27;ve seen 30,000 line functions with gotos used for flow control (loops and if branches) - something you can do in C if you are really that stupid and I think we will all agree is bad.  This 30,000+ line function with gotos as flow control was a lot more common in Dijkstra&#x27;s day.</div><br/><div id="39921655" class="c"><input type="checkbox" id="c-39921655" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921279">parent</a><span>|</span><a href="#39921553">next</a><span>|</span><label class="collapse" for="c-39921655">[-]</label><label class="expand" for="c-39921655">[4 more]</label></div><br/><div class="children"><div class="content">We all agree that you shouldn&#x27;t write bad code. Not using goto, not using any language construct.<p>But when unbridled gotos were the only tool in the toolbox, bad code was an inevitability in a codebase of any meaningful size. Not even the best programmer was immune. This is what the &quot;Go to statement considered harmful&quot; paper was about.<p>It was written in 1968. We listened. We created languages that addressed the concerns raised and moved forward. It is no longer relevant. Why does it keep getting repeated in a misappropriated way?</div><br/><div id="39925223" class="c"><input type="checkbox" id="c-39925223" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921655">parent</a><span>|</span><a href="#39921553">next</a><span>|</span><label class="collapse" for="c-39925223">[-]</label><label class="expand" for="c-39925223">[3 more]</label></div><br/><div class="children"><div class="content">In 1968 they had better languages and programmers were still using goto for control in them despite better options.</div><br/><div id="39927208" class="c"><input type="checkbox" id="c-39927208" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39925223">parent</a><span>|</span><a href="#39926922">next</a><span>|</span><label class="collapse" for="c-39927208">[-]</label><label class="expand" for="c-39927208">[1 more]</label></div><br/><div class="children"><div class="content">Of course. The ideas presented in said paper went back at least a decade prior, but languages were still showing up with unbridled gotos despite that. But that has changed in the meantime. What language are you or anyone you know using today that still has an unbridled goto statement?</div><br/></div></div></div></div></div></div><div id="39921553" class="c"><input type="checkbox" id="c-39921553" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921279">parent</a><span>|</span><a href="#39921655">prev</a><span>|</span><a href="#39922608">next</a><span>|</span><label class="collapse" for="c-39921553">[-]</label><label class="expand" for="c-39921553">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Languages other than C give you options for flow control so that you don&#x27;t need goto for that.<p>The idiom `if (error) goto cleanup` is about the only thing I see goto used for. What flow control replaces that <i>other</i> than exceptions?</div><br/><div id="39921916" class="c"><input type="checkbox" id="c-39921916" checked=""/><div class="controls bullet"><span class="by">sirwhinesalot</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921553">parent</a><span>|</span><a href="#39924468">next</a><span>|</span><label class="collapse" for="c-39921916">[-]</label><label class="expand" for="c-39921916">[2 more]</label></div><br/><div class="children"><div class="content">Jumping out of nested loops. Implementing higher level constructs like yield or defer. State machines. Compiler output that uses C as a &quot;cross-platform&quot; assembly language.<p>All of them are better served with more specialized language constructs but as a widely applicable hammer goto is pretty nice.<p>I don&#x27;t expect C to have good error handling or generators any time soon but with goto I can deal with it.</div><br/><div id="39922561" class="c"><input type="checkbox" id="c-39922561" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921916">parent</a><span>|</span><a href="#39924468">next</a><span>|</span><label class="collapse" for="c-39922561">[-]</label><label class="expand" for="c-39922561">[1 more]</label></div><br/><div class="children"><div class="content">Compiling HLL constructs in some of those scenarios ultimately produces a jump statement. So, it makes sense that a higher-level version of a jump would be helpful in the same situations.</div><br/></div></div></div></div><div id="39924468" class="c"><input type="checkbox" id="c-39924468" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921553">parent</a><span>|</span><a href="#39921916">prev</a><span>|</span><a href="#39921701">next</a><span>|</span><label class="collapse" for="c-39924468">[-]</label><label class="expand" for="c-39924468">[1 more]</label></div><br/><div class="children"><div class="content">RAII + destructors<p>Though gcc supports cleanup functions, just not very ergonomically.</div><br/></div></div><div id="39921701" class="c"><input type="checkbox" id="c-39921701" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921553">parent</a><span>|</span><a href="#39924468">prev</a><span>|</span><a href="#39922608">next</a><span>|</span><label class="collapse" for="c-39921701">[-]</label><label class="expand" for="c-39921701">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; What flow control replaces that other than exceptions?</i><p>defer has gained in popularity for that situation.</div><br/></div></div></div></div><div id="39922608" class="c"><input type="checkbox" id="c-39922608" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39921279">parent</a><span>|</span><a href="#39921553">prev</a><span>|</span><a href="#39920756">next</a><span>|</span><label class="collapse" for="c-39922608">[-]</label><label class="expand" for="c-39922608">[3 more]</label></div><br/><div class="children"><div class="content">&gt; 30,000 line functions with gotos<p>The problem there is the 30K line function, not the goto!</div><br/><div id="39925268" class="c"><input type="checkbox" id="c-39925268" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39922608">parent</a><span>|</span><a href="#39920756">next</a><span>|</span><label class="collapse" for="c-39925268">[-]</label><label class="expand" for="c-39925268">[2 more]</label></div><br/><div class="children"><div class="content">30k functions are a problem but they are manageable if goto isn&#x27;t used in them. I prefer not to but a have figured them out.</div><br/><div id="39926547" class="c"><input type="checkbox" id="c-39926547" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39925268">parent</a><span>|</span><a href="#39920756">next</a><span>|</span><label class="collapse" for="c-39926547">[-]</label><label class="expand" for="c-39926547">[1 more]</label></div><br/><div class="children"><div class="content">Wow! Longest single function I can think of having written is ~200 lines. I always feel bad when editing it but there&#x27;s no useful way to break it down so I let it be. But a single 30,000 line function? Wow.</div><br/></div></div></div></div></div></div></div></div><div id="39920756" class="c"><input type="checkbox" id="c-39920756" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#39919544">root</a><span>|</span><a href="#39920146">parent</a><span>|</span><a href="#39921279">prev</a><span>|</span><a href="#39919999">next</a><span>|</span><label class="collapse" for="c-39920756">[-]</label><label class="expand" for="c-39920756">[1 more]</label></div><br/><div class="children"><div class="content">goto used in certain idiomatic ways (e.g. to jump to cleanup code after an error, or to go to a `retry:` label, or to continue or break out of a multiply nested loop) is fine. What&#x27;s annoying is bypassing control flow with random goto spaghetti.</div><br/></div></div></div></div></div></div><div id="39919999" class="c"><input type="checkbox" id="c-39919999" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39919544">prev</a><span>|</span><a href="#39921967">next</a><span>|</span><label class="collapse" for="c-39919999">[-]</label><label class="expand" for="c-39919999">[1 more]</label></div><br/><div class="children"><div class="content">Very nice. I’m glad to see these all have detailed reports explaining what’s wrong!</div><br/></div></div><div id="39921967" class="c"><input type="checkbox" id="c-39921967" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#39919999">prev</a><span>|</span><a href="#39920363">next</a><span>|</span><label class="collapse" for="c-39921967">[-]</label><label class="expand" for="c-39921967">[2 more]</label></div><br/><div class="children"><div class="content">-Wstringop-overflow is the first warning I disable because of all the false positives.<p>I doubt the analyze variant would fare any better.</div><br/><div id="39924852" class="c"><input type="checkbox" id="c-39924852" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#39921967">parent</a><span>|</span><a href="#39920363">next</a><span>|</span><label class="collapse" for="c-39924852">[-]</label><label class="expand" for="c-39924852">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t sort of like pulling the battery out of your carbon monoxide detector because the constant beeping is giving you a headache and making you sleepy?</div><br/></div></div></div></div><div id="39926982" class="c"><input type="checkbox" id="c-39926982" checked=""/><div class="controls bullet"><span class="by">aulin</span><span>|</span><a href="#39920363">prev</a><span>|</span><label class="collapse" for="c-39926982">[-]</label><label class="expand" for="c-39926982">[1 more]</label></div><br/><div class="children"><div class="content">now we want a GCC language server!</div><br/></div></div></div></div></div></div></div></body></html>