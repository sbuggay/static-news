<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723885262457" as="style"/><link rel="stylesheet" href="styles.css?v=1723885262457"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://vanillajsx.com/">VanillaJSX.com</a> <span class="domain">(<a href="https://vanillajsx.com">vanillajsx.com</a>)</span></div><div class="subtext"><span>novocantico</span> | <span>137 comments</span></div><br/><div><div id="41272906" class="c"><input type="checkbox" id="c-41272906" checked=""/><div class="controls bullet"><span class="by">dqh</span><span>|</span><a href="#41271135">next</a><span>|</span><label class="collapse" for="c-41272906">[-]</label><label class="expand" for="c-41272906">[1 more]</label></div><br/><div class="children"><div class="content">Those interested in this space may find my fairly unknown project interesting: <a href="https:&#x2F;&#x2F;nakedjsx.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nakedjsx.org&#x2F;</a><p>It started as a static site generator but added a bunch of support for client JavaScript too.</div><br/></div></div><div id="41271135" class="c"><input type="checkbox" id="c-41271135" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41272906">prev</a><span>|</span><a href="#41271105">next</a><span>|</span><label class="collapse" for="c-41271135">[-]</label><label class="expand" for="c-41271135">[28 more]</label></div><br/><div class="children"><div class="content">Returning actual DOM nodes entirely blunts the big advantage of JSX (and non-JSX libraries like Lit) - which is their immediate mode style API, and UI=f(state) model.<p>You want to return a description of the DOM, rather than the real DOM, because you want to be able to reevaluate your templates repeatedly with new state, and efficiently update the DOM where that template is rendered to.<p>All the examples here use imperative DOM APIs to do updates, like with this:<p><pre><code>    function TodoInput(attrs: { add: (v: string) =&gt; void }) {
      const input = &lt;input &#x2F;&gt; as HTMLInputElement;
      input.placeholder = &#x27;Add todo item...&#x27;;
      input.onkeydown = (e) =&gt; {
        if (e.key === &#x27;Enter&#x27;) {
          attrs.add(input.value);
          input.value = &#x27;&#x27;;
        }
      };
      return input;
    }

    class TodoList {
      ul = &lt;ul class=&#x27;todolist&#x27; &#x2F;&gt; as HTMLUListElement;
      add(v: string) {
        const item = &lt;li&gt;{v}&lt;&#x2F;li&gt; as HTMLLIElement;
        item.onclick = () =&gt; item.remove();
        this.ul.append(item);
      }
    }
</code></pre>
Avoiding those `input.onkeydown = ...` and `this.ul.append(item)` cases, and instead just iterating over items in your template, is probably the main benefit of a VDOM.<p>(The problem with VDOMs is that diffing is slow, a problem solved by using templates that separate static from dynamic parts, like Lit - a library I work on).</div><br/><div id="41272196" class="c"><input type="checkbox" id="c-41272196" checked=""/><div class="controls bullet"><span class="by">francasso</span><span>|</span><a href="#41271135">parent</a><span>|</span><a href="#41272889">next</a><span>|</span><label class="collapse" for="c-41272196">[-]</label><label class="expand" for="c-41272196">[4 more]</label></div><br/><div class="children"><div class="content">From my experience creating complex  web UIs, the performance angle of using a vdom is pure fantasy if your application is complex enough.<p>In fact I now strongly believe it&#x27;s counter productive, because most people come to it thinking &quot;I can just trigger however many re-renders of this large piece of UI as I like, the vdom makes it ok&quot; and it doesn&#x27;t, the performance sucks, but now you have architected the app in a way that requires a rewrite to make the app perform well.<p>I have seen this exact sequence of events four times, by four different teams. The second, third and fourth, as a principal architect consulting for the team I tried to intervene and advocate for a vanilla architecture that is mindful about performance, citing the issues they would likely experience with react, but to no avail. There was a lot of &quot;oh but there many ways to avoid those issues&quot; followed by a list of things I was presumably ignorant about.<p>I guess most of us need to learn things the hard way.</div><br/><div id="41272357" class="c"><input type="checkbox" id="c-41272357" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41272196">parent</a><span>|</span><a href="#41272614">next</a><span>|</span><label class="collapse" for="c-41272357">[-]</label><label class="expand" for="c-41272357">[2 more]</label></div><br/><div class="children"><div class="content">And from <i>my</i> experience building complex web UIs, those team members were right -- there are many ways to avoid the issues and using vdom is great in general. True, there are situations where it falls short, which is why you will want to fall back to other techniques for those bits of architecture. Just like your JS, Python or Ruby server will call a bunch of functions written in C or the like. That doesn&#x27;t mean you should write your entire backend in C.</div><br/><div id="41272731" class="c"><input type="checkbox" id="c-41272731" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41272357">parent</a><span>|</span><a href="#41272614">next</a><span>|</span><label class="collapse" for="c-41272731">[-]</label><label class="expand" for="c-41272731">[1 more]</label></div><br/><div class="children"><div class="content">Yes, there are ways to avoid the issues, and they involve abandoning the immediate mode illusion that react created in the name of simplicity.</div><br/></div></div></div></div><div id="41272614" class="c"><input type="checkbox" id="c-41272614" checked=""/><div class="controls bullet"><span class="by">unconed</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41272196">parent</a><span>|</span><a href="#41272357">prev</a><span>|</span><a href="#41272889">next</a><span>|</span><label class="collapse" for="c-41272614">[-]</label><label class="expand" for="c-41272614">[1 more]</label></div><br/><div class="children"><div class="content">Yes and the solution is to put on your big boy pants and to actually do your front-end application architecture properly.<p>Separate source of truth from derived data. Separate possibly valid user intent from validated state. Use contexts to organize the data dependency graph of your application. Ensure all your widgets use a consistent value type in and out, don&#x27;t let events contaminate it. Use something like cursors or optics to simplify mutations and derive setters automatically.<p>I&#x27;ve never had an easier time building very complex UI functionality than with React. But it requires you to actively start reasoning about change in your code (what doesn&#x27;t change), and this is something most people are not used to.<p>Personally I think React compiler is folly for this reason: they are taking the most interesting part of React, the part that lets you write apps that are incremental from top to bottom, and telling you it&#x27;s too complicated for you to think about. Nonsense.<p>The issue is just that React makes pros feel like idiots unless they eat some humble pie and grok the principles and the reasons behind it. Which is that React is what you get when you try to come up with a UI architecture that can make entire classes of problems go away.<p>Without a VDOM, one way data flow, and diffing, your UI won&#x27;t just be slow, it&#x27;ll be full of secret O(n^2) cascades, random ifs to stop infinite cycles, random &quot;let&#x27;s update this state early so other code can immediately use it&quot; ordering issues, and so on.</div><br/></div></div></div></div><div id="41272889" class="c"><input type="checkbox" id="c-41272889" checked=""/><div class="controls bullet"><span class="by">dminik</span><span>|</span><a href="#41271135">parent</a><span>|</span><a href="#41272196">prev</a><span>|</span><a href="#41271285">next</a><span>|</span><label class="collapse" for="c-41272889">[-]</label><label class="expand" for="c-41272889">[1 more]</label></div><br/><div class="children"><div class="content">This really just isn&#x27;t true. If your state updates are at the component subtree level (like react) a vdom is a good choice. But, if you make your state changes more granular, you can get away with skipping VDOM entirely and work with just* regular dom nodes. Look at Solid or Svelte. No VDOM there, just pure granular updates.<p>*List reconciliation still has to happen, but you don&#x27;t need to pull out an entire vdom. You just have to have some mapping between  list items and their resulting DOM nodes.</div><br/></div></div><div id="41271285" class="c"><input type="checkbox" id="c-41271285" checked=""/><div class="controls bullet"><span class="by">JasonSage</span><span>|</span><a href="#41271135">parent</a><span>|</span><a href="#41272889">prev</a><span>|</span><a href="#41271169">next</a><span>|</span><label class="collapse" for="c-41271285">[-]</label><label class="expand" for="c-41271285">[2 more]</label></div><br/><div class="children"><div class="content">I agree with the sibling comment that this really depends on the user. To take a different approach: JSX is just a different DSL to the createElement function call pattern (see Preact.h for example) and all of the benefits you’re describing come from the framework and runtime.<p>More concisely: JSX is just an alternate function call syntax with some useful applications.<p>For example at my last company we used JSX to make test data factories that had an XML-like look but were using a builder-pattern in the element creation that was able to make contextual decisions about what was in the final data. Nothing to do with React, DOM, or inability to express the same thing declaratively without JSX.</div><br/><div id="41272676" class="c"><input type="checkbox" id="c-41272676" checked=""/><div class="controls bullet"><span class="by">spoonfeeder006</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271285">parent</a><span>|</span><a href="#41271169">next</a><span>|</span><label class="collapse" for="c-41272676">[-]</label><label class="expand" for="c-41272676">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example at my last company we used JSX to make test data factories<p>Thats really interesting, can you elaborate more?<p>For example did you use a specific JSX compiler? Was that written in house or used a 3rd party library?</div><br/></div></div></div></div><div id="41271169" class="c"><input type="checkbox" id="c-41271169" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41271135">parent</a><span>|</span><a href="#41271285">prev</a><span>|</span><a href="#41271681">next</a><span>|</span><label class="collapse" for="c-41271169">[-]</label><label class="expand" for="c-41271169">[10 more]</label></div><br/><div class="children"><div class="content">&gt; You want to return a description of the DOM, rather than the real DOM, because you want to be able to reevaluate your templates repeatedly with new state, and efficiently update the DOM where that template is rendered to.<p>Depends who &quot;you&quot; are.  I prefer to have my DOM nodes updated in place without all the reconciliation machinery. (no implication about what <i>you</i> want)</div><br/><div id="41271367" class="c"><input type="checkbox" id="c-41271367" checked=""/><div class="controls bullet"><span class="by">ericmcer</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271169">parent</a><span>|</span><a href="#41271241">next</a><span>|</span><label class="collapse" for="c-41271367">[-]</label><label class="expand" for="c-41271367">[2 more]</label></div><br/><div class="children"><div class="content">If you work on a team of suitable size I would hesitate to not leverage a VDom. I trust myself to not trigger dumb reflows, but the way I see a lot of people using React this could be a perf nightmare.</div><br/><div id="41271450" class="c"><input type="checkbox" id="c-41271450" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271367">parent</a><span>|</span><a href="#41271241">next</a><span>|</span><label class="collapse" for="c-41271450">[-]</label><label class="expand" for="c-41271450">[1 more]</label></div><br/><div class="children"><div class="content">I think that hits the real problem: it’s staffing and culture, not the tool. The 90th percentile site using a vDOM is also a perf nightmare, especially for anyone who doesn’t have a recent Apple device on a fast network, and that often has big impacts on usability and accessibility as well (dynamic loading sucks on screen readers unless you put way more time into it that most people do).<p>I was painfully reminded of that while visiting Europe last month on a data plan which was clearly deprioritized on partner networks - the old sites with .php in the URLs loaded in a few seconds and worked perfectly, but every time something failed to load in less than 5 minutes or partially loaded but didn’t work a quick trip over to webpagetest.org showed a lot of NextJS, React, et al. scripts trickling in because clearly a form with half a dozen fields needs 25MB of JavaScript.<p>The root cause is obvious: you get what you measure. If businesses prioritize Jira tickets closed per day, they’re going to get this soup of things promising to be easy to use for high developer velocity and they’re never going to get around to the optimizing it. If they’re trying to be able to hire as cheaply as possible, they’re going to look for the current tool boot camps are pushing and hire based on that, not looking for deeper knowledge of web standards or experience which costs more and shrink the candidate pool. If they’re looking for a safe choice, Facebook’s marketing means all of the big consulting companies will push React and few people will pause long enough to ask whether they’re building the same kind of apps it was designed to build (long session times, tons of local state being mutated, etc.) or whether they’re willing to invest the time needed to get it to perform reliably and well.</div><br/></div></div></div></div><div id="41271241" class="c"><input type="checkbox" id="c-41271241" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271169">parent</a><span>|</span><a href="#41271367">prev</a><span>|</span><a href="#41271681">next</a><span>|</span><label class="collapse" for="c-41271241">[-]</label><label class="expand" for="c-41271241">[7 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need diffing or reconciliation to turn a description of DOM into DOM. Lit works without a VDOM.<p>If all JSX does is return a DocumentFragment that you then need to imperatively add event listeners to and imperatively update, how is it much better than innerHTML?</div><br/><div id="41271867" class="c"><input type="checkbox" id="c-41271867" checked=""/><div class="controls bullet"><span class="by">esprehn</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271241">parent</a><span>|</span><a href="#41271892">next</a><span>|</span><label class="collapse" for="c-41271867">[-]</label><label class="expand" for="c-41271867">[1 more]</label></div><br/><div class="children"><div class="content">I think the answer to that is probably &quot;as good as soy, but with modern ergonomics&quot;. E4X was basically this and I think it&#x27;s a much nicer way to build DOM trees than strings since you can&#x27;t create invalid markup or concat partial tags. It also lets you reuse subtrees naturally where innerHTML makes that impossible.</div><br/></div></div><div id="41271892" class="c"><input type="checkbox" id="c-41271892" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271241">parent</a><span>|</span><a href="#41271867">prev</a><span>|</span><a href="#41271471">next</a><span>|</span><label class="collapse" for="c-41271892">[-]</label><label class="expand" for="c-41271892">[1 more]</label></div><br/><div class="children"><div class="content">innerHTML loses all local state, such as which elements have focus or where the cursor is in a text field.  Back when React first came out and people were getting used to the idea of VDOM diffing, they had demos front and center about how by using those diffs to only change what needed to change, such local state wouldn&#x27;t be lost.<p>This in theory could do something to copy that local state over, or diff the two DOMs directly without a VDOM (though from the sound of it, it probably doesn&#x27;t).</div><br/></div></div><div id="41271471" class="c"><input type="checkbox" id="c-41271471" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271241">parent</a><span>|</span><a href="#41271892">prev</a><span>|</span><a href="#41271387">next</a><span>|</span><label class="collapse" for="c-41271471">[-]</label><label class="expand" for="c-41271471">[1 more]</label></div><br/><div class="children"><div class="content">You can have JSX that produces DOM nodes or &quot;light-weight element descriptions&quot;.<p>You can have imperative event listeners and updates.<p>These are two independent dimensions.  I made UI framework called mutraction that produces real DOM elements from JSX expressions.  
It also updates any contents or attributes of those DOM nodes based on their dependencies without requiring imperative DOM interaction from application code.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tomtheisen&#x2F;mutraction">https:&#x2F;&#x2F;github.com&#x2F;tomtheisen&#x2F;mutraction</a><p>Here&#x27;s a click counter.  `track()`, as you might guess creates a proxy so that reads and writes can be converted into dependencies.<p><pre><code>    const model = track({ clicks: 0});
    const app = (
        &lt;button onclick={() =&gt; ++model.clicks }&gt;
            { model.clicks } clicks
        &lt;&#x2F;button&gt;
    );

    document.body.append(app);</code></pre></div><br/></div></div><div id="41271387" class="c"><input type="checkbox" id="c-41271387" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271241">parent</a><span>|</span><a href="#41271471">prev</a><span>|</span><a href="#41271681">next</a><span>|</span><label class="collapse" for="c-41271387">[-]</label><label class="expand" for="c-41271387">[3 more]</label></div><br/><div class="children"><div class="content">1) Type safety for element props.<p>2) Autocomplete for element props.<p>3) IDE support such as refactors and jump to definition&#x2F;jump to usages.<p>4) Proper syntax highlighting out of the box instead of the editor just saying &quot;there&#x27;s a string here&quot;.<p>5) A uniform pattern for defining custom components that work the same as primitives, rather than defining custom components as helper functions returning string fragments or something like that.<p>And so on. JSX has a lot going for it regardless of the semantics chosen. It&#x27;s just a syntax that is very convenient for lots of kinds of tooling, and it&#x27;s completely unopinated about the semantic context in which it is used.</div><br/><div id="41271491" class="c"><input type="checkbox" id="c-41271491" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271387">parent</a><span>|</span><a href="#41271681">next</a><span>|</span><label class="collapse" for="c-41271491">[-]</label><label class="expand" for="c-41271491">[2 more]</label></div><br/><div class="children"><div class="content">These are definitely helpful, but what you are describing are all language tool features rather than features of JSX itself. 5 would be the exception, but that is just user preference of what kind of syntax one likes to write components with.</div><br/><div id="41271508" class="c"><input type="checkbox" id="c-41271508" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271491">parent</a><span>|</span><a href="#41271681">next</a><span>|</span><label class="collapse" for="c-41271508">[-]</label><label class="expand" for="c-41271508">[1 more]</label></div><br/><div class="children"><div class="content">Well, yes. But OP was asking about what makes this better than `innerHTML`, and the obvious answer is that support for HTML programming embedded in JavaScript strings is generally bad while support for JSX is <i>very</i> good across all editors.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41271681" class="c"><input type="checkbox" id="c-41271681" checked=""/><div class="controls bullet"><span class="by">novocantico</span><span>|</span><a href="#41271135">parent</a><span>|</span><a href="#41271169">prev</a><span>|</span><a href="#41271946">next</a><span>|</span><label class="collapse" for="c-41271681">[-]</label><label class="expand" for="c-41271681">[5 more]</label></div><br/><div class="children"><div class="content">&gt; is probably the main benefit of a VDOM<p>I get the &quot;no more imperative updates&quot; dream. I&#x27;ve used these frameworks for probably a decade. I&#x27;ve mastered them.<p>Me personally, I prefer imperatively updating my DOM. I get completely fine-grained control over what&#x27;s happening. I can architect it to be an extremely efficient machine. I can make it extremely easy to add&#x2F;change&#x2F;remove&#x2F;fix features in my apps without forcing myself to think according to anyone else&#x27;s opinionated methodology.</div><br/><div id="41271743" class="c"><input type="checkbox" id="c-41271743" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271681">parent</a><span>|</span><a href="#41271922">next</a><span>|</span><label class="collapse" for="c-41271743">[-]</label><label class="expand" for="c-41271743">[1 more]</label></div><br/><div class="children"><div class="content">If you have little state, or simple uniform state, you can actually store it in the real DOM efficiently, as values of controls, or lists of similar DOM nodes under a common known parent. If most of your DOM is static, and you only need small bits of interactivity, React is an excessively heavy tool.<p>The farther you get into complex GUI territory, the more you want a declarative, functional approach, because it makes things simpler. The closer you are to a handful of controls with simple logic, the more you want to just imperatively tell them what to do, and leave the rest of the page alone, because it makes things simpler. We now just have better tools than jQuery for that.</div><br/></div></div><div id="41271922" class="c"><input type="checkbox" id="c-41271922" checked=""/><div class="controls bullet"><span class="by">newzisforsukas</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271681">parent</a><span>|</span><a href="#41271743">prev</a><span>|</span><a href="#41272467">next</a><span>|</span><label class="collapse" for="c-41271922">[-]</label><label class="expand" for="c-41271922">[2 more]</label></div><br/><div class="children"><div class="content">there is no reason something imperative cannot be declarative. the war is one of style, not capability, so saying you gain &quot;fine-grained control&quot; is kind of meaningless, imo</div><br/></div></div></div></div><div id="41271408" class="c"><input type="checkbox" id="c-41271408" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#41271135">parent</a><span>|</span><a href="#41271334">prev</a><span>|</span><a href="#41271576">next</a><span>|</span><label class="collapse" for="c-41271408">[-]</label><label class="expand" for="c-41271408">[2 more]</label></div><br/><div class="children"><div class="content"><i>Returning actual DOM nodes entirely blunts the big advantage of JSX (and non-JSX libraries like Lit) - which is their immediate mode style API, and UI=f(state) model.</i><p>I feel like this is one of the leakiest abstractions in all of computing. There&#x27;s a reason there&#x27;s an entire cottage industry around react; how to stop things rendering multiple times, refreshing needlessly, etc.</div><br/><div id="41272769" class="c"><input type="checkbox" id="c-41272769" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#41271135">root</a><span>|</span><a href="#41271408">parent</a><span>|</span><a href="#41271576">next</a><span>|</span><label class="collapse" for="c-41272769">[-]</label><label class="expand" for="c-41272769">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, as much as I liked the idea of an “immediate mode API which is in fact retained under the hood which makes things both ergonomic and performant”, the reality is that React failed to deliver on that and every sufficiently big app ends up having performance problems that are then fixed by opting out of the immediate mode illusion.</div><br/></div></div></div></div><div id="41271576" class="c"><input type="checkbox" id="c-41271576" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41271135">parent</a><span>|</span><a href="#41271408">prev</a><span>|</span><a href="#41271105">next</a><span>|</span><label class="collapse" for="c-41271576">[-]</label><label class="expand" for="c-41271576">[1 more]</label></div><br/><div class="children"><div class="content">Whether you like this project or not, your comment so completely misses the point.  You are confusing the JSX syntax, which is what the author wanted by extracting it away from React, for all the React candy.  This is a missing the forest for the trees kind of thing.<p>This mind numbing reliance upon layers of abstraction nonsense around state management is why I really don&#x27;t like React.  State management is ridiculously simple.  State management, when done correctly, is the most primitive example of MVC with no abstractions needed.</div><br/></div></div></div></div><div id="41271105" class="c"><input type="checkbox" id="c-41271105" checked=""/><div class="controls bullet"><span class="by">novocantico</span><span>|</span><a href="#41271135">prev</a><span>|</span><a href="#41271011">next</a><span>|</span><label class="collapse" for="c-41271105">[-]</label><label class="expand" for="c-41271105">[18 more]</label></div><br/><div class="children"><div class="content">Thanks for taking some interest in my project. It came from being frustrated with the state of SSGs over the past 10 years. I mostly just make static websites, and I wanted something that was simple and intuitive to me, and JSX seemed like a great fit. But I got very tired of the disproportionately scaled complexity of JSX frameworks like React. Long story short, I made an SSG that just renders JSX as strings. It was natural to extend that to the browser to just render JSX as DOM elements. And in a few cases (mostly layout) it lends well to shared components. Overall I&#x27;m happy with what I came up with, although some of it is admittedly a little hacky, and IDE support isn&#x27;t as good as it could be.<p>[edit] Oh also, this solution works really well for SEO. That&#x27;s another problem I didn&#x27;t find solved well in other JSX frameworks.</div><br/><div id="41271744" class="c"><input type="checkbox" id="c-41271744" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41271105">parent</a><span>|</span><a href="#41271291">next</a><span>|</span><label class="collapse" for="c-41271744">[-]</label><label class="expand" for="c-41271744">[7 more]</label></div><br/><div class="children"><div class="content">Just curious, have you seen Astro? I feel like it&#x27;s the perfect SSG, but maybe you have some reservations that VanillaJSX solves.</div><br/><div id="41271899" class="c"><input type="checkbox" id="c-41271899" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271744">parent</a><span>|</span><a href="#41271954">next</a><span>|</span><label class="collapse" for="c-41271899">[-]</label><label class="expand" for="c-41271899">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big fan of Astro, though I could see it being a bit more of an adjustment for JSX users than Svelte users since Astro&#x27;s syntax was originally based on Svelte.<p>That said, JSX can be used easily with Astro as long as you get used to at least a bit of The `.astro` syntax for wrapper components and pages&#x2F;layouts.</div><br/></div></div><div id="41271954" class="c"><input type="checkbox" id="c-41271954" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271744">parent</a><span>|</span><a href="#41271899">prev</a><span>|</span><a href="#41271897">next</a><span>|</span><label class="collapse" for="c-41271954">[-]</label><label class="expand" for="c-41271954">[2 more]</label></div><br/><div class="children"><div class="content">SSG?</div><br/><div id="41271981" class="c"><input type="checkbox" id="c-41271981" checked=""/><div class="controls bullet"><span class="by">blackeyeblitzar</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271954">parent</a><span>|</span><a href="#41271897">next</a><span>|</span><label class="collapse" for="c-41271981">[-]</label><label class="expand" for="c-41271981">[1 more]</label></div><br/><div class="children"><div class="content">Static site generator, apparently</div><br/></div></div></div></div><div id="41271897" class="c"><input type="checkbox" id="c-41271897" checked=""/><div class="controls bullet"><span class="by">newzisforsukas</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271744">parent</a><span>|</span><a href="#41271954">prev</a><span>|</span><a href="#41271291">next</a><span>|</span><label class="collapse" for="c-41271897">[-]</label><label class="expand" for="c-41271897">[3 more]</label></div><br/><div class="children"><div class="content">astro is nearly, if not as, &quot;complex&quot; as react, no?</div><br/><div id="41272332" class="c"><input type="checkbox" id="c-41272332" checked=""/><div class="controls bullet"><span class="by">molszanski</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271897">parent</a><span>|</span><a href="#41272382">next</a><span>|</span><label class="collapse" for="c-41272332">[-]</label><label class="expand" for="c-41272332">[1 more]</label></div><br/><div class="children"><div class="content">As person who has been doing “react” since 2016 I would say that it removes so much of the “react” complex BS that I am surprised it is not x100 times more popular.<p>We’ve recently moved one service from next to Astro and it was just removing a ton of boilerplate and “dance around” code.</div><br/></div></div><div id="41272382" class="c"><input type="checkbox" id="c-41272382" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271897">parent</a><span>|</span><a href="#41272332">prev</a><span>|</span><a href="#41271291">next</a><span>|</span><label class="collapse" for="c-41272382">[-]</label><label class="expand" for="c-41272382">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t really make sense to compare React to a static site generator.</div><br/></div></div></div></div></div></div><div id="41271291" class="c"><input type="checkbox" id="c-41271291" checked=""/><div class="controls bullet"><span class="by">thelastinuit</span><span>|</span><a href="#41271105">parent</a><span>|</span><a href="#41271744">prev</a><span>|</span><a href="#41271626">next</a><span>|</span><label class="collapse" for="c-41271291">[-]</label><label class="expand" for="c-41271291">[1 more]</label></div><br/><div class="children"><div class="content">not the hero we deserve but the villain we need</div><br/></div></div><div id="41271626" class="c"><input type="checkbox" id="c-41271626" checked=""/><div class="controls bullet"><span class="by">fredmerc</span><span>|</span><a href="#41271105">parent</a><span>|</span><a href="#41271291">prev</a><span>|</span><a href="#41272184">next</a><span>|</span><label class="collapse" for="c-41271626">[-]</label><label class="expand" for="c-41271626">[2 more]</label></div><br/><div class="children"><div class="content">A JSX for Django server side would be cool.</div><br/><div id="41271745" class="c"><input type="checkbox" id="c-41271745" checked=""/><div class="controls bullet"><span class="by">WesleyJohnson</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271626">parent</a><span>|</span><a href="#41272184">next</a><span>|</span><label class="collapse" for="c-41271745">[-]</label><label class="expand" for="c-41271745">[1 more]</label></div><br/><div class="children"><div class="content">How would you envision this working?</div><br/></div></div></div></div><div id="41272184" class="c"><input type="checkbox" id="c-41272184" checked=""/><div class="controls bullet"><span class="by">todotask</span><span>|</span><a href="#41271105">parent</a><span>|</span><a href="#41271626">prev</a><span>|</span><a href="#41271421">next</a><span>|</span><label class="collapse" for="c-41272184">[-]</label><label class="expand" for="c-41272184">[1 more]</label></div><br/><div class="children"><div class="content">Large WASM payload on your site could be optimized.</div><br/></div></div><div id="41271421" class="c"><input type="checkbox" id="c-41271421" checked=""/><div class="controls bullet"><span class="by">hyperhello</span><span>|</span><a href="#41271105">parent</a><span>|</span><a href="#41272184">prev</a><span>|</span><a href="#41271011">next</a><span>|</span><label class="collapse" for="c-41271421">[-]</label><label class="expand" for="c-41271421">[6 more]</label></div><br/><div class="children"><div class="content">What I’m seeing here is not new. It’s this vanilla pattern but with enough back support to leave off the framing and get the syntax highlighting:<p>Var button = html(’&lt;button&gt;im a button&lt;&#x2F;button&gt;’);<p>The html() function is trivial, but it just doesn’t <i>feel</i> like real programming to do this, even though there’s nothing else to it in the end.</div><br/><div id="41272589" class="c"><input type="checkbox" id="c-41272589" checked=""/><div class="controls bullet"><span class="by">mock-possum</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271421">parent</a><span>|</span><a href="#41271631">next</a><span>|</span><label class="collapse" for="c-41272589">[-]</label><label class="expand" for="c-41272589">[1 more]</label></div><br/><div class="children"><div class="content">Tagged template literals for html view templating is what I LOVE about Lit and lit-html. It’s JavaScript you can run natively in browser, no server or pre processor&#x2F;build step necessary.</div><br/></div></div><div id="41271631" class="c"><input type="checkbox" id="c-41271631" checked=""/><div class="controls bullet"><span class="by">hyperhello</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271421">parent</a><span>|</span><a href="#41272589">prev</a><span>|</span><a href="#41271011">next</a><span>|</span><label class="collapse" for="c-41271631">[-]</label><label class="expand" for="c-41271631">[4 more]</label></div><br/><div class="children"><div class="content">Downvote me but tell me why. The example is using .onclick, .textContent, etc in a completely vanilla way. I&#x27;m just pointing out you can get all the way vanilla and it still works. What&#x27;s the issue?</div><br/><div id="41271650" class="c"><input type="checkbox" id="c-41271650" checked=""/><div class="controls bullet"><span class="by">novocantico</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271631">parent</a><span>|</span><a href="#41271644">next</a><span>|</span><label class="collapse" for="c-41271650">[-]</label><label class="expand" for="c-41271650">[2 more]</label></div><br/><div class="children"><div class="content">lolinder explained it well in here</div><br/><div id="41271669" class="c"><input type="checkbox" id="c-41271669" checked=""/><div class="controls bullet"><span class="by">hyperhello</span><span>|</span><a href="#41271105">root</a><span>|</span><a href="#41271650">parent</a><span>|</span><a href="#41271644">next</a><span>|</span><label class="collapse" for="c-41271669">[-]</label><label class="expand" for="c-41271669">[1 more]</label></div><br/><div class="children"><div class="content">He did, and he pointed out the point is just IDE support so it has typing and autocomplete and syntax highlighting. Thanks, we agree!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41271011" class="c"><input type="checkbox" id="c-41271011" checked=""/><div class="controls bullet"><span class="by">cribbles</span><span>|</span><a href="#41271105">prev</a><span>|</span><a href="#41272617">next</a><span>|</span><label class="collapse" for="c-41271011">[-]</label><label class="expand" for="c-41271011">[11 more]</label></div><br/><div class="children"><div class="content">These &quot;what ifs&quot; are kinda funny because the origins of JSX can be traced back to Facebook&#x27;s XHP[1], which took explicit inspiration from E4X[2], an early JS standard that looked and behaved similar to the library described here.<p>[1] <a href="https:&#x2F;&#x2F;engineering.fb.com&#x2F;2010&#x2F;02&#x2F;09&#x2F;developer-tools&#x2F;xhp-a-new-way-to-write-php&#x2F;" rel="nofollow">https:&#x2F;&#x2F;engineering.fb.com&#x2F;2010&#x2F;02&#x2F;09&#x2F;developer-tools&#x2F;xhp-a-...</a><p>[2] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;ECMAScript_for_XML" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;ECMAScript_for_XML</a></div><br/><div id="41271249" class="c"><input type="checkbox" id="c-41271249" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#41271011">parent</a><span>|</span><a href="#41271968">next</a><span>|</span><label class="collapse" for="c-41271249">[-]</label><label class="expand" for="c-41271249">[5 more]</label></div><br/><div class="children"><div class="content">E4X had the unfortunate downside of returning actual DOM instances, which needed to be updated imperatively. That&#x27;s why JSX eclipsed it, and there hasn&#x27;t been a serious proposal for HTML templating in JS since then.<p>But maybe we can revive the general idea with a modern take: <a href="https:&#x2F;&#x2F;github.com&#x2F;WICG&#x2F;webcomponents&#x2F;issues&#x2F;1069">https:&#x2F;&#x2F;github.com&#x2F;WICG&#x2F;webcomponents&#x2F;issues&#x2F;1069</a></div><br/><div id="41272881" class="c"><input type="checkbox" id="c-41272881" checked=""/><div class="controls bullet"><span class="by">Sephr</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41271249">parent</a><span>|</span><a href="#41272879">next</a><span>|</span><label class="collapse" for="c-41272881">[-]</label><label class="expand" for="c-41272881">[1 more]</label></div><br/><div class="children"><div class="content">&gt; E4X had the unfortunate downside of returning actual DOM instances, which needed to be updated imperatively<p>Firefox never shipped the optional E4X DOM APIs. I wrote a polyfill for them at the time.[1]<p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;eligrey&#x2F;e4x.js&#x2F;blob&#x2F;master&#x2F;e4x.js">https:&#x2F;&#x2F;github.com&#x2F;eligrey&#x2F;e4x.js&#x2F;blob&#x2F;master&#x2F;e4x.js</a></div><br/></div></div><div id="41272879" class="c"><input type="checkbox" id="c-41272879" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41271249">parent</a><span>|</span><a href="#41272881">prev</a><span>|</span><a href="#41271343">next</a><span>|</span><label class="collapse" for="c-41272879">[-]</label><label class="expand" for="c-41272879">[1 more]</label></div><br/><div class="children"><div class="content">With &quot;imperatively&quot; you mean that the user of the templating system has to do it imperatively, and that is bad? Asking because imperative updates seem to be the way to go within the implementation, instead of creating new instances of elements every time.</div><br/></div></div><div id="41271343" class="c"><input type="checkbox" id="c-41271343" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41271249">parent</a><span>|</span><a href="#41272879">prev</a><span>|</span><a href="#41271987">next</a><span>|</span><label class="collapse" for="c-41271343">[-]</label><label class="expand" for="c-41271343">[1 more]</label></div><br/><div class="children"><div class="content">&gt; had the unfortunate downside of returning actual DOM instances, which needed to be updated imperatively.<p>Isn&#x27;t this what we have in TFA?</div><br/></div></div><div id="41271987" class="c"><input type="checkbox" id="c-41271987" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41271249">parent</a><span>|</span><a href="#41271343">prev</a><span>|</span><a href="#41271968">next</a><span>|</span><label class="collapse" for="c-41271987">[-]</label><label class="expand" for="c-41271987">[1 more]</label></div><br/><div class="children"><div class="content">Also E4X was only ever implemented in Firefox, never really got traction even in Firefox.<p>But even considering the single implementation problem, it also was just not a good language model, nor was it well specified or defined and it brought with it a pile of weird baggage and complexity.<p>Then because it was The Future there was no real thought into proper interop with JS (it was essentially a completely independent spec so adopted general syntax but specified in a way that meant JS could not simply adopt that syntax).</div><br/></div></div></div></div><div id="41271968" class="c"><input type="checkbox" id="c-41271968" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#41271011">parent</a><span>|</span><a href="#41271249">prev</a><span>|</span><a href="#41272617">next</a><span>|</span><label class="collapse" for="c-41271968">[-]</label><label class="expand" for="c-41271968">[5 more]</label></div><br/><div class="children"><div class="content">Fun fact, E4X is the reason JavaScript has ‘for(of)’ instead of ‘for each’ (the reason we didn’t get ‘for (:)’ is even dumber - it would conflict with ‘:type’ annotations a few TC39 members were convinced would magically be in the language)</div><br/><div id="41272082" class="c"><input type="checkbox" id="c-41272082" checked=""/><div class="controls bullet"><span class="by">rlt</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41271968">parent</a><span>|</span><a href="#41272439">next</a><span>|</span><label class="collapse" for="c-41272082">[-]</label><label class="expand" for="c-41272082">[2 more]</label></div><br/><div class="children"><div class="content">Like the type annotations that are now in TypeScript?</div><br/><div id="41272519" class="c"><input type="checkbox" id="c-41272519" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41272082">parent</a><span>|</span><a href="#41272439">next</a><span>|</span><label class="collapse" for="c-41272519">[-]</label><label class="expand" for="c-41272519">[1 more]</label></div><br/><div class="children"><div class="content">Yup, that were in typescript, pascal (and rust, etc when they came out).<p>But there was no real progress after years of them pushing this syntax, but failing to actually define a type system that was coherent, or a model that would allow it.<p>As a result I proposed `for (of)` largely to prevent sane enumeration from being blocked on the intransigence of two people.<p>It&#x27;s also worth noting that for(:) enumeration would not even preclude their syntax - it&#x27;s certainly not grammatically ambiguous - and most real world code in languages that support enumeration directly and support inference doesn&#x27;t explicitly specify the types , so the ugliness of `for(let a:type:expression)` would have be rare anyway.<p><i>shrug</i><p>Given that ECMA literally killed E4X a few years later the blanket ban on &quot;for each&quot; or &quot;foreach&quot; (because it would be &quot;confusing&quot; in E4X) is arguably worth than for(:), but again <i>shrug</i></div><br/></div></div></div></div><div id="41272439" class="c"><input type="checkbox" id="c-41272439" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41271968">parent</a><span>|</span><a href="#41272082">prev</a><span>|</span><a href="#41272617">next</a><span>|</span><label class="collapse" for="c-41272439">[-]</label><label class="expand" for="c-41272439">[2 more]</label></div><br/><div class="children"><div class="content">There is a proposal to add them, though it does seem to be stalled.</div><br/><div id="41272530" class="c"><input type="checkbox" id="c-41272530" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#41271011">root</a><span>|</span><a href="#41272439">parent</a><span>|</span><a href="#41272617">next</a><span>|</span><label class="collapse" for="c-41272530">[-]</label><label class="expand" for="c-41272530">[1 more]</label></div><br/><div class="children"><div class="content">There were proposals almost 2 decades ago. They&#x27;ve never gone anywhere because proponents of type specifiers don&#x27;t want to do the necessary corollary: specifying the type system.<p>Typescript and similar can do it because they don&#x27;t have to specify the type system, and can&#x27;t change it in meaningful ways over time. Things in the language standard cannot be easily changed, if they can be changed at all.</div><br/></div></div></div></div></div></div></div></div><div id="41272617" class="c"><input type="checkbox" id="c-41272617" checked=""/><div class="controls bullet"><span class="by">merlindru</span><span>|</span><a href="#41271011">prev</a><span>|</span><a href="#41272508">next</a><span>|</span><label class="collapse" for="c-41272617">[-]</label><label class="expand" for="c-41272617">[1 more]</label></div><br/><div class="children"><div class="content">VanJS deserves a mention here! <a href="https:&#x2F;&#x2F;vanjs.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vanjs.org&#x2F;</a><p>Another interesting thing is that other JSX libraries like Solid.JS also return DOM nodes, and I love that this idea is gaining traction<p>The closer we get to the platform we&#x27;re using, the better. Being removed by layers of abstractions CAN be useful, but in practice, I haven&#x27;t found a use for abstracting away the platform. (yet.)<p>Maybe huge projects like Facebook benefit from this tho (which I haven&#x27;t worked on)</div><br/></div></div><div id="41272508" class="c"><input type="checkbox" id="c-41272508" checked=""/><div class="controls bullet"><span class="by">whazor</span><span>|</span><a href="#41272617">prev</a><span>|</span><a href="#41271461">next</a><span>|</span><label class="collapse" for="c-41272508">[-]</label><label class="expand" for="c-41272508">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why the type casting (as HTMLButtonElement) is needed. Because document.createElement(&quot;button&quot;) returns HTMLButtonElement in TypeScript.</div><br/></div></div><div id="41271461" class="c"><input type="checkbox" id="c-41271461" checked=""/><div class="controls bullet"><span class="by">flowerlad</span><span>|</span><a href="#41272508">prev</a><span>|</span><a href="#41271886">next</a><span>|</span><label class="collapse" for="c-41271461">[-]</label><label class="expand" for="c-41271461">[1 more]</label></div><br/><div class="children"><div class="content">This is very similar to Vanilla TSX:
<a href="https:&#x2F;&#x2F;github.com&#x2F;wisercoder&#x2F;uibuilder">https:&#x2F;&#x2F;github.com&#x2F;wisercoder&#x2F;uibuilder</a><p>Here’s an app written using Vanilla TSX:
<a href="https:&#x2F;&#x2F;github.com&#x2F;wisercoder&#x2F;eureka&#x2F;tree&#x2F;master&#x2F;webapp&#x2F;ClientApp">https:&#x2F;&#x2F;github.com&#x2F;wisercoder&#x2F;eureka&#x2F;tree&#x2F;master&#x2F;webapp&#x2F;Clie...</a></div><br/></div></div><div id="41271886" class="c"><input type="checkbox" id="c-41271886" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#41271461">prev</a><span>|</span><a href="#41272504">next</a><span>|</span><label class="collapse" for="c-41271886">[-]</label><label class="expand" for="c-41271886">[2 more]</label></div><br/><div class="children"><div class="content">Does the final example not work in Firefox for anyone else? It worked in Edge, but not Firefox for me<p><pre><code>    Uncaught (in promise) TypeError: Map.groupBy(...).entries().map is not a function</code></pre></div><br/><div id="41272044" class="c"><input type="checkbox" id="c-41272044" checked=""/><div class="controls bullet"><span class="by">iammrpayments</span><span>|</span><a href="#41271886">parent</a><span>|</span><a href="#41272504">next</a><span>|</span><label class="collapse" for="c-41272044">[-]</label><label class="expand" for="c-41272044">[1 more]</label></div><br/><div class="children"><div class="content">Object.groupBy doesn’t seem to be available to all browsers before march 2024:
<a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;groupBy#browser_compatibility" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/></div></div></div></div><div id="41272504" class="c"><input type="checkbox" id="c-41272504" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41271886">prev</a><span>|</span><a href="#41271181">next</a><span>|</span><label class="collapse" for="c-41272504">[-]</label><label class="expand" for="c-41272504">[3 more]</label></div><br/><div class="children"><div class="content">What is the benefit of mixing js and html?<p><pre><code>    el = &lt;button&gt;Click me&lt;&#x2F;button&gt; as HTMLButtonElement;
</code></pre>
What would be the downside of<p><pre><code>    el = html.button(&#x27;&lt;button&gt;Click me&lt;&#x2F;button&gt;&#x27;);
</code></pre>
?<p>That way no compilation step would be needed and debugging would be easier as the code executed in the browser is the same code the developer writes.</div><br/><div id="41272782" class="c"><input type="checkbox" id="c-41272782" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#41272504">parent</a><span>|</span><a href="#41271181">next</a><span>|</span><label class="collapse" for="c-41272782">[-]</label><label class="expand" for="c-41272782">[2 more]</label></div><br/><div class="children"><div class="content">With the first example you have syntax highlighting and compile-time check.<p>With the second of you have stringa.</div><br/><div id="41272914" class="c"><input type="checkbox" id="c-41272914" checked=""/><div class="controls bullet"><span class="by">mg</span><span>|</span><a href="#41272504">root</a><span>|</span><a href="#41272782">parent</a><span>|</span><a href="#41271181">next</a><span>|</span><label class="collapse" for="c-41272914">[-]</label><label class="expand" for="c-41272914">[1 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t one be able to tell syntax highlighters and code checkers that the string that goes into the html.something() functions is html?</div><br/></div></div></div></div></div></div><div id="41271181" class="c"><input type="checkbox" id="c-41271181" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41272504">prev</a><span>|</span><a href="#41270997">next</a><span>|</span><label class="collapse" for="c-41271181">[-]</label><label class="expand" for="c-41271181">[1 more]</label></div><br/><div class="children"><div class="content">I also made a UI library based on the idea of jsx template expressions that produce real DOM nodes.  It also binds model objects to attributes, eliminating some of the imperative event handler boiler-plate.  I think it&#x27;s a great idea, but of course I would.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tomtheisen&#x2F;mutraction">https:&#x2F;&#x2F;github.com&#x2F;tomtheisen&#x2F;mutraction</a><p>It lets you do stuff like this.<p><pre><code>    const model = track({ clicks: 0});
    const app = (
        &lt;button onclick={() =&gt; ++model.clicks }&gt;
            { model.clicks } clicks
        &lt;&#x2F;button&gt;
    );

    document.body.append(app);</code></pre></div><br/></div></div><div id="41270997" class="c"><input type="checkbox" id="c-41270997" checked=""/><div class="controls bullet"><span class="by">sophiebits</span><span>|</span><a href="#41271181">prev</a><span>|</span><a href="#41270842">next</a><span>|</span><label class="collapse" for="c-41270997">[-]</label><label class="expand" for="c-41270997">[9 more]</label></div><br/><div class="children"><div class="content">These examples are cool but I think it’s important to note that none of them show components whose props can change over time, since that ability doesn’t seem to be modeled at all. Clever if you don’t need that but I’m having trouble seeing how it would scale to more complex apps.</div><br/><div id="41271585" class="c"><input type="checkbox" id="c-41271585" checked=""/><div class="controls bullet"><span class="by">novocantico</span><span>|</span><a href="#41270997">parent</a><span>|</span><a href="#41272290">next</a><span>|</span><label class="collapse" for="c-41271585">[-]</label><label class="expand" for="c-41271585">[1 more]</label></div><br/><div class="children"><div class="content">The technique I used here and in all my browser-side code is the exact same technique used by VS Code internally, and it scales very well. The only difference in my code is it&#x27;s more concise than writing 10 lines to construct and setup a DOM element the typical way.<p>Honestly, the real interesting part about my framework is <i>literally everything else</i>. Returning strings from JSX on the ssg-side; being able to import raw source directories and manipulate string|Buffer at ssg-time; the extremely efficient and lightning fast module system I wrote on top of chokidar and swc; probably more I&#x27;m forgetting, but basically the JSX-as-DOM is only the most <i>visually</i> interesting part. But really just a party trick.<p>[edit] Case in point: the source code to vanillajsx.com is extremely concise and clear and short, I literally wrote the whole thing today with zero deps (besides imlib), and the JSX-as-DOM demos are the least innovative part of it: <a href="https:&#x2F;&#x2F;github.com&#x2F;sdegutis&#x2F;vanillajsx.com&#x2F;tree&#x2F;main&#x2F;site">https:&#x2F;&#x2F;github.com&#x2F;sdegutis&#x2F;vanillajsx.com&#x2F;tree&#x2F;main&#x2F;site</a></div><br/></div></div><div id="41272290" class="c"><input type="checkbox" id="c-41272290" checked=""/><div class="controls bullet"><span class="by">tombl</span><span>|</span><a href="#41270997">parent</a><span>|</span><a href="#41271585">prev</a><span>|</span><a href="#41271162">next</a><span>|</span><label class="collapse" for="c-41272290">[-]</label><label class="expand" for="c-41272290">[1 more]</label></div><br/><div class="children"><div class="content">Yup, in order to scale this approach to any real size (and still have confidence that everything is working together like you expect), a proper reactivity solution is needed.<p>For those that appreciate this approach of JSX returning concrete DOM elements, Solid works exactly like this, with the addition of a proper reactivity layer.</div><br/></div></div><div id="41271162" class="c"><input type="checkbox" id="c-41271162" checked=""/><div class="controls bullet"><span class="by">numpad</span><span>|</span><a href="#41270997">parent</a><span>|</span><a href="#41272290">prev</a><span>|</span><a href="#41271315">next</a><span>|</span><label class="collapse" for="c-41271162">[-]</label><label class="expand" for="c-41271162">[4 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m missing something, but how would this prevent you from using setTimeout&#x2F;setInterval? But I agree that these projects often work great in small use cases, but quickly crumble under &quot;real world&quot; scenarios.</div><br/><div id="41271220" class="c"><input type="checkbox" id="c-41271220" checked=""/><div class="controls bullet"><span class="by">novocantico</span><span>|</span><a href="#41270997">root</a><span>|</span><a href="#41271162">parent</a><span>|</span><a href="#41271502">next</a><span>|</span><label class="collapse" for="c-41271220">[-]</label><label class="expand" for="c-41271220">[1 more]</label></div><br/><div class="children"><div class="content">I admit that the two most complex &quot;interactive apps&quot; I&#x27;ve built with this are not that complex according to many standards:<p>* <a href="https:&#x2F;&#x2F;www.immaculatalibrary.com&#x2F;books.html" rel="nofollow">https:&#x2F;&#x2F;www.immaculatalibrary.com&#x2F;books.html</a> (src = <a href="https:&#x2F;&#x2F;github.com&#x2F;sdegutis&#x2F;immaculatalibrary.com&#x2F;blob&#x2F;main&#x2F;site&#x2F;scripts&#x2F;books-page.tsx">https:&#x2F;&#x2F;github.com&#x2F;sdegutis&#x2F;immaculatalibrary.com&#x2F;blob&#x2F;main&#x2F;...</a>)<p>* <a href="https:&#x2F;&#x2F;www.immaculatalibrary.com&#x2F;prayers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.immaculatalibrary.com&#x2F;prayers&#x2F;</a> (src = <a href="https:&#x2F;&#x2F;github.com&#x2F;sdegutis&#x2F;immaculatalibrary.com&#x2F;blob&#x2F;main&#x2F;site&#x2F;prayers&#x2F;client.tsx">https:&#x2F;&#x2F;github.com&#x2F;sdegutis&#x2F;immaculatalibrary.com&#x2F;blob&#x2F;main&#x2F;...</a>)</div><br/></div></div><div id="41271502" class="c"><input type="checkbox" id="c-41271502" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#41270997">root</a><span>|</span><a href="#41271162">parent</a><span>|</span><a href="#41271220">prev</a><span>|</span><a href="#41271567">next</a><span>|</span><label class="collapse" for="c-41271502">[-]</label><label class="expand" for="c-41271502">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be hesitant to run something like a 30fps render loop in a web app. Its been years since I last saw or tried that in a real world app but it didn&#x27;t end well for performance.<p>Your best bet would be to queue up specific UI changes that need to be made as diff&#x27;s rather than checking the entire UI state. At that point, though, you might as well run them immediately as the change is needed.<p>If that was still a perf problem you would end up chasing a very complex solution like react fiber to partially update the UI on a loop while periodically pausing for user events.</div><br/></div></div><div id="41271567" class="c"><input type="checkbox" id="c-41271567" checked=""/><div class="controls bullet"><span class="by">sophiebits</span><span>|</span><a href="#41270997">root</a><span>|</span><a href="#41271162">parent</a><span>|</span><a href="#41271502">prev</a><span>|</span><a href="#41271315">next</a><span>|</span><label class="collapse" for="c-41271567">[-]</label><label class="expand" for="c-41271567">[1 more]</label></div><br/><div class="children"><div class="content">Sure, if you blow away the entire app on every state change. But that would lose not only state defined in components (like `i` in ClickMe) but also all state implicitly stored in DOM elements (selection, focus, scroll position, input value, media playback).</div><br/></div></div></div></div><div id="41271315" class="c"><input type="checkbox" id="c-41271315" checked=""/><div class="controls bullet"><span class="by">hellojebus</span><span>|</span><a href="#41270997">parent</a><span>|</span><a href="#41271162">prev</a><span>|</span><a href="#41270842">next</a><span>|</span><label class="collapse" for="c-41271315">[-]</label><label class="expand" for="c-41271315">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m by no means an advocate of this library, and never plan to use it, but to support component props that trigger rerenders, a&#x27;la React&#x2F;Vue, I would use JS Proxies here. Wouldn&#x27;t be that hard to implement.</div><br/><div id="41271562" class="c"><input type="checkbox" id="c-41271562" checked=""/><div class="controls bullet"><span class="by">sophiebits</span><span>|</span><a href="#41270997">root</a><span>|</span><a href="#41271315">parent</a><span>|</span><a href="#41270842">next</a><span>|</span><label class="collapse" for="c-41271562">[-]</label><label class="expand" for="c-41271562">[1 more]</label></div><br/><div class="children"><div class="content">How would you suggest using Proxy?</div><br/></div></div></div></div></div></div><div id="41270842" class="c"><input type="checkbox" id="c-41270842" checked=""/><div class="controls bullet"><span class="by">config_yml</span><span>|</span><a href="#41270997">prev</a><span>|</span><a href="#41272547">next</a><span>|</span><label class="collapse" for="c-41270842">[-]</label><label class="expand" for="c-41270842">[10 more]</label></div><br/><div class="children"><div class="content">Reminds me of Action Script 3 which had XML at the core of the language. It was a fun language to work with, but famously failed to become ES4.   Oh well, took us 10+ years to arrive close to that with Typescript and JSX.</div><br/><div id="41270971" class="c"><input type="checkbox" id="c-41270971" checked=""/><div class="controls bullet"><span class="by">quink</span><span>|</span><a href="#41270842">parent</a><span>|</span><a href="#41271023">next</a><span>|</span><label class="collapse" for="c-41270971">[-]</label><label class="expand" for="c-41270971">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ECMAScript_for_XML" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ECMAScript_for_XML</a> - Firefox had it too, but people at large just didn&#x27;t want it, so it got removed. It got disabled for web pages with the release of Firefox 17, 6 months prior to the first release of React.</div><br/><div id="41271088" class="c"><input type="checkbox" id="c-41271088" checked=""/><div class="controls bullet"><span class="by">sltkr</span><span>|</span><a href="#41270842">root</a><span>|</span><a href="#41270971">parent</a><span>|</span><a href="#41271346">next</a><span>|</span><label class="collapse" for="c-41271088">[-]</label><label class="expand" for="c-41271088">[2 more]</label></div><br/><div class="children"><div class="content">Personally I never heard about it. So it might not be that people didn&#x27;t want it, but that it wasn&#x27;t promoted much.<p>Also, it sounds like the only browser to ever support it was Firefox? That was probably much more of a limiting factor for adoption.</div><br/><div id="41271355" class="c"><input type="checkbox" id="c-41271355" checked=""/><div class="controls bullet"><span class="by">kibibu</span><span>|</span><a href="#41270842">root</a><span>|</span><a href="#41271088">parent</a><span>|</span><a href="#41271346">next</a><span>|</span><label class="collapse" for="c-41271355">[-]</label><label class="expand" for="c-41271355">[1 more]</label></div><br/><div class="children"><div class="content">If you weren&#x27;t coding for the flash platform you would have easily missed it.<p>Its a shame, E4X was really nice</div><br/></div></div></div></div><div id="41271346" class="c"><input type="checkbox" id="c-41271346" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#41270842">root</a><span>|</span><a href="#41270971">parent</a><span>|</span><a href="#41271088">prev</a><span>|</span><a href="#41271023">next</a><span>|</span><label class="collapse" for="c-41271346">[-]</label><label class="expand" for="c-41271346">[1 more]</label></div><br/><div class="children"><div class="content">People didn&#x27;t want it because browsers didn&#x27;t support it (except FF, as you noted). Some of us had our fingers crossed that other browsers would pick it up.</div><br/></div></div></div></div><div id="41271023" class="c"><input type="checkbox" id="c-41271023" checked=""/><div class="controls bullet"><span class="by">shove</span><span>|</span><a href="#41270842">parent</a><span>|</span><a href="#41270971">prev</a><span>|</span><a href="#41272547">next</a><span>|</span><label class="collapse" for="c-41271023">[-]</label><label class="expand" for="c-41271023">[5 more]</label></div><br/><div class="children"><div class="content">I don’t recall being able to construct XML inline like this unless maybe that was a Flex server thing?</div><br/><div id="41271361" class="c"><input type="checkbox" id="c-41271361" checked=""/><div class="controls bullet"><span class="by">zoogeny</span><span>|</span><a href="#41270842">root</a><span>|</span><a href="#41271023">parent</a><span>|</span><a href="#41271167">next</a><span>|</span><label class="collapse" for="c-41271361">[-]</label><label class="expand" for="c-41271361">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t recall being able to do the XML construction inline either, but that just might be my memory.<p>However, the XML selector syntax was a godsend. Recursively parsing an XML tree is really a pain. E4X would allow you to do things like:<p><pre><code>    var foo = someXml..childNodes.@attribute;
</code></pre>
I&#x27;m not even sure if that would work actually. There were a bunch of operators for doing things like getting a collection of children that all had the same tag so you could work with XML like:<p><pre><code>    &lt;someXml&gt;
       &lt;intermediateNodeYouWantToSkip&gt;
           &lt;childNode attribute=&quot;1&quot; &#x2F;&gt;
           &lt;childNode attribute=&quot;2&quot; &#x2F;&gt;
           &lt;childNode attribute=&quot;3&quot; &#x2F;&gt;
           &lt;unrelatedNode &#x2F;&gt;
       &lt;&#x2F;intermediateNodeYouWantToSkip&gt;
    &lt;&#x2F;someXml&gt;
</code></pre>
Another post here said people didn&#x27;t want it, but I don&#x27;t think that was the real reason it was dropped. There was a lot of drama at the time about Flash in general and a massive debacle about EcmaScript 4 (which ActionScript more or less adopted). There was also the whole XHTML thing happening.<p>Basically JSON as a format won out over XML and ES4&#x2F;XHTML were ditched. Frankly, a world that revolved around XML&#x2F;SOAP would have been a nightmare, so I guess killing off the easy processing of XML in JavaScript helped to stave off that potential future. XSS, XSLT and E4X were all casualties.</div><br/></div></div><div id="41271167" class="c"><input type="checkbox" id="c-41271167" checked=""/><div class="controls bullet"><span class="by">dugmartin</span><span>|</span><a href="#41270842">root</a><span>|</span><a href="#41271023">parent</a><span>|</span><a href="#41271361">prev</a><span>|</span><a href="#41271179">next</a><span>|</span><label class="collapse" for="c-41271167">[-]</label><label class="expand" for="c-41271167">[1 more]</label></div><br/><div class="children"><div class="content">It was an extension to ES4 called E4X - it allowed inline xml along with a new xml data type.  More info here: <a href="https:&#x2F;&#x2F;evertpot.com&#x2F;ecmascript-4-the-missing-version&#x2F;" rel="nofollow">https:&#x2F;&#x2F;evertpot.com&#x2F;ecmascript-4-the-missing-version&#x2F;</a></div><br/></div></div><div id="41271179" class="c"><input type="checkbox" id="c-41271179" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#41270842">root</a><span>|</span><a href="#41271023">parent</a><span>|</span><a href="#41271167">prev</a><span>|</span><a href="#41272547">next</a><span>|</span><label class="collapse" for="c-41271179">[-]</label><label class="expand" for="c-41271179">[2 more]</label></div><br/><div class="children"><div class="content">I think parent must be referring to Flex components. AS3 itself had an XML library which I recall being absolute hell to work with. The better way to send things over the wire with AS3 was with AMF.</div><br/><div id="41271243" class="c"><input type="checkbox" id="c-41271243" checked=""/><div class="controls bullet"><span class="by">theturtle32</span><span>|</span><a href="#41270842">root</a><span>|</span><a href="#41271179">parent</a><span>|</span><a href="#41272547">next</a><span>|</span><label class="collapse" for="c-41271243">[-]</label><label class="expand" for="c-41271243">[1 more]</label></div><br/><div class="children"><div class="content">Nope. I worked with Flex and it&#x27;s MXML files extensively. But the parent is talking about E4X, which was an extension to ECMAScript that allowed you to use XML elements inline with JavaScript in a manner VERY similar to how JSX is used today. It also included the ability to much more easily query and otherwise work with those XML document trees in native JavaScript.</div><br/></div></div></div></div></div></div></div></div><div id="41272547" class="c"><input type="checkbox" id="c-41272547" checked=""/><div class="controls bullet"><span class="by">miika</span><span>|</span><a href="#41270842">prev</a><span>|</span><a href="#41272440">next</a><span>|</span><label class="collapse" for="c-41272547">[-]</label><label class="expand" for="c-41272547">[1 more]</label></div><br/><div class="children"><div class="content">I used to explore similar stuff and prototyped something I call “Vanilla Components” but then  in the end I fell in love with Web Components and quit React (and all other frameworks).</div><br/></div></div><div id="41272440" class="c"><input type="checkbox" id="c-41272440" checked=""/><div class="controls bullet"><span class="by">drikerf</span><span>|</span><a href="#41272547">prev</a><span>|</span><a href="#41272343">next</a><span>|</span><label class="collapse" for="c-41272440">[-]</label><label class="expand" for="c-41272440">[2 more]</label></div><br/><div class="children"><div class="content">Nice project! I do wonder though if jsx is the best way to represent elements in code?<p>Clojure datastructures makes this so much more enjoyable. Everything is just basic lists and maps which makes it very flexible and powerful.<p>[:ul
  [:li &quot;task 1&quot;]
  [:li &quot;task 2&quot;]]<p>It&#x27;s weird that it&#x27;s not more common for making web apps.</div><br/><div id="41272507" class="c"><input type="checkbox" id="c-41272507" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41272440">parent</a><span>|</span><a href="#41272343">next</a><span>|</span><label class="collapse" for="c-41272507">[-]</label><label class="expand" for="c-41272507">[1 more]</label></div><br/><div class="children"><div class="content">There is a library for Python called htpy that does this.<p>Trouble is if you&#x27;re used to HTML it can take a while to get used to it. It&#x27;s like a learned helplessness or something.</div><br/></div></div></div></div><div id="41272343" class="c"><input type="checkbox" id="c-41272343" checked=""/><div class="controls bullet"><span class="by">hizanberg</span><span>|</span><a href="#41272440">prev</a><span>|</span><a href="#41271570">next</a><span>|</span><label class="collapse" for="c-41272343">[-]</label><label class="expand" for="c-41272343">[1 more]</label></div><br/><div class="children"><div class="content">Anyone else used Hono with SSR JSX? [1]<p>Was super productive and easy to create a Cloudflare Worker Web App that’s free to host thanks to Cloudflare’s generous 100k daily worker request limit.<p>Generally don’t believe in serverless for larger Apps, but for small websites that you just want to create, deploy and ignore - it’s great!<p><a href="https:&#x2F;&#x2F;hono.dev&#x2F;docs&#x2F;guides&#x2F;jsx" rel="nofollow">https:&#x2F;&#x2F;hono.dev&#x2F;docs&#x2F;guides&#x2F;jsx</a></div><br/></div></div><div id="41271570" class="c"><input type="checkbox" id="c-41271570" checked=""/><div class="controls bullet"><span class="by">slmjkdbtl</span><span>|</span><a href="#41272343">prev</a><span>|</span><a href="#41270999">next</a><span>|</span><label class="collapse" for="c-41271570">[-]</label><label class="expand" for="c-41271570">[10 more]</label></div><br/><div class="children"><div class="content">I never understand the appeal of JSX over something like<p><pre><code>  h(&quot;div&quot;, {}, [
    h(&quot;p&quot;, {}, &quot;this is easy&quot;),
    ...list.map((l) =&gt; h(&quot;li&quot;, {}, l),
  ])
</code></pre>
With this you automatically get loops, variable interpolation etc without having to invent a compiler and new syntax. Can someone help me understand?</div><br/><div id="41271664" class="c"><input type="checkbox" id="c-41271664" checked=""/><div class="controls bullet"><span class="by">sim0n</span><span>|</span><a href="#41271570">parent</a><span>|</span><a href="#41271654">next</a><span>|</span><label class="collapse" for="c-41271664">[-]</label><label class="expand" for="c-41271664">[4 more]</label></div><br/><div class="children"><div class="content">I would assume that lot of people just find the JSX equivalent a lot more readable and familiar (a matter of opinion, of course.)<p><pre><code>  &lt;div&gt;
    &lt;p&gt;this is easy&lt;&#x2F;p&gt;
    {list.map((l) =&gt; &lt;li&gt;{l}&lt;&#x2F;li&gt;)}
  &lt;&#x2F;div&gt;
</code></pre>
&gt; you automatically get loops, variable interpolation etc without having to invent a compiler and new syntax<p>To be fair to JSX, you use regular loops, interpolation, etc without any different syntax (`{}` accepts a vanilla JS expression), you just obviously need the compiler step to de-sugar the element tags to `createElement` calls.</div><br/><div id="41271678" class="c"><input type="checkbox" id="c-41271678" checked=""/><div class="controls bullet"><span class="by">slmjkdbtl</span><span>|</span><a href="#41271570">root</a><span>|</span><a href="#41271664">parent</a><span>|</span><a href="#41271654">next</a><span>|</span><label class="collapse" for="c-41271678">[-]</label><label class="expand" for="c-41271678">[3 more]</label></div><br/><div class="children"><div class="content">Yeah the syntax is almost identical to vanilla js, but requiring a compiler is quite cumbersome compared to the advantage it provides imo.</div><br/><div id="41271936" class="c"><input type="checkbox" id="c-41271936" checked=""/><div class="controls bullet"><span class="by">presentation</span><span>|</span><a href="#41271570">root</a><span>|</span><a href="#41271678">parent</a><span>|</span><a href="#41272794">next</a><span>|</span><label class="collapse" for="c-41271936">[-]</label><label class="expand" for="c-41271936">[1 more]</label></div><br/><div class="children"><div class="content">That said if anything pretty much all of the new school frameworks and many of the tools in their ecosystems are already dependent on compilers for optimization anyway, react itself is introducing a compiler in the latest versions.<p>Anyway I prefer the html looking syntax if anything because it looks like the output on the page. That’s dependent on a project coding style that doesn’t unnecessarily wrap things in components, which for my company’s product I’ve set as a standard.</div><br/></div></div><div id="41272794" class="c"><input type="checkbox" id="c-41272794" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#41271570">root</a><span>|</span><a href="#41271678">parent</a><span>|</span><a href="#41271936">prev</a><span>|</span><a href="#41271654">next</a><span>|</span><label class="collapse" for="c-41272794">[-]</label><label class="expand" for="c-41272794">[1 more]</label></div><br/><div class="children"><div class="content">Requiring a compiler also allows to catch mistakes at compile type, which is much more efficient in terms of development.</div><br/></div></div></div></div></div></div><div id="41271654" class="c"><input type="checkbox" id="c-41271654" checked=""/><div class="controls bullet"><span class="by">erikpukinskis</span><span>|</span><a href="#41271570">parent</a><span>|</span><a href="#41271664">prev</a><span>|</span><a href="#41271643">next</a><span>|</span><label class="collapse" for="c-41271654">[-]</label><label class="expand" for="c-41271654">[1 more]</label></div><br/><div class="children"><div class="content">You might be confusing JSX for something else. In JSX you also don’t need new syntax for loops. JSX Is JavaScript, as people like to say.<p>But to your point, JSX doesn’t really do much. Your h function is basically what React.creatElement does. Google “React without JSX” and you’ll see how it looks.<p>JSX is just syntactic sugar over React.creatElement. And that is what makes it so nice… there _are_ no special constructs for loops, or variables, or components. They are actual JavaScript loops, JavaScript variables, and JavaScript function.<p>It makes JSX easier to reason about than most templating languages.</div><br/></div></div><div id="41271643" class="c"><input type="checkbox" id="c-41271643" checked=""/><div class="controls bullet"><span class="by">fredmerc</span><span>|</span><a href="#41271570">parent</a><span>|</span><a href="#41271654">prev</a><span>|</span><a href="#41271684">next</a><span>|</span><label class="collapse" for="c-41271643">[-]</label><label class="expand" for="c-41271643">[1 more]</label></div><br/><div class="children"><div class="content">Keep going down that logical rabbit hole. You end up with Common Lisp!</div><br/></div></div><div id="41271684" class="c"><input type="checkbox" id="c-41271684" checked=""/><div class="controls bullet"><span class="by">plonq</span><span>|</span><a href="#41271570">parent</a><span>|</span><a href="#41271643">prev</a><span>|</span><a href="#41272074">next</a><span>|</span><label class="collapse" for="c-41271684">[-]</label><label class="expand" for="c-41271684">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve wondered the same thing. I think one benefit is that it looks like HTML, which means it looks similar to what you see in the browser&#x27;s DevTools, which makes it easier to compare and debug.</div><br/><div id="41272424" class="c"><input type="checkbox" id="c-41272424" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#41271570">root</a><span>|</span><a href="#41271684">parent</a><span>|</span><a href="#41272074">next</a><span>|</span><label class="collapse" for="c-41272424">[-]</label><label class="expand" for="c-41272424">[1 more]</label></div><br/><div class="children"><div class="content">It also makes it easier to see what it&#x27;s <i>not</i>: at a glance, the &quot;p&quot; could really be anything until you scan the context. The &lt;p&gt; isn&#x27;t a string (that on further examination turns out to get used for marking up a paragraph), it <i>is</i> a paragraph demarkation (in vdom, but still).</div><br/></div></div></div></div><div id="41272074" class="c"><input type="checkbox" id="c-41272074" checked=""/><div class="controls bullet"><span class="by">whichdan</span><span>|</span><a href="#41271570">parent</a><span>|</span><a href="#41271684">prev</a><span>|</span><a href="#41270999">next</a><span>|</span><label class="collapse" for="c-41272074">[-]</label><label class="expand" for="c-41272074">[1 more]</label></div><br/><div class="children"><div class="content">Elm works a lot like this and it&#x27;s quite nice.</div><br/></div></div></div></div><div id="41270999" class="c"><input type="checkbox" id="c-41270999" checked=""/><div class="controls bullet"><span class="by">ibash</span><span>|</span><a href="#41271570">prev</a><span>|</span><a href="#41271046">next</a><span>|</span><label class="collapse" for="c-41270999">[-]</label><label class="expand" for="c-41270999">[10 more]</label></div><br/><div class="children"><div class="content">People forget what problem the virtual dom and react is supposed to solve.<p>No better article than this: <a href="https:&#x2F;&#x2F;blog.vjeux.com&#x2F;2013&#x2F;javascript&#x2F;react-performance.html" rel="nofollow">https:&#x2F;&#x2F;blog.vjeux.com&#x2F;2013&#x2F;javascript&#x2F;react-performance.htm...</a></div><br/><div id="41271963" class="c"><input type="checkbox" id="c-41271963" checked=""/><div class="controls bullet"><span class="by">mbivert</span><span>|</span><a href="#41270999">parent</a><span>|</span><a href="#41271136">next</a><span>|</span><label class="collapse" for="c-41271963">[-]</label><label class="expand" for="c-41271963">[2 more]</label></div><br/><div class="children"><div class="content">(honest question, not trying to be snarky) Do you have one (many would be great) use cases where the practical gain of the virtual DOM solutions have a genuine impact?<p>I&#x27;m asking because, many of React (or friends) introductory material naturally focus on building things like TODO lists or Tic Tac Toe; while those offer insights into how to work with React (&amp; cie), they&#x27;re not showcasing cases where the performance gains are perceptible, and IMO not even cases where the &quot;organizational&quot; benefits of such libraries are salient.</div><br/><div id="41272660" class="c"><input type="checkbox" id="c-41272660" checked=""/><div class="controls bullet"><span class="by">eterps</span><span>|</span><a href="#41270999">root</a><span>|</span><a href="#41271963">parent</a><span>|</span><a href="#41271136">next</a><span>|</span><label class="collapse" for="c-41272660">[-]</label><label class="expand" for="c-41272660">[1 more]</label></div><br/><div class="children"><div class="content">This question is crucial to understanding the true value of React and virtual DOM technologies.<p>While there&#x27;s no doubt that React and virtual DOM offer advantages, it&#x27;s essential to clearly demonstrate where and how these benefits manifest in real-world applications.<p>&gt; <i>they&#x27;re not showcasing cases where the performance gains are perceptible</i><p>According to this commenter, it&#x27;s not even about the performance gains:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41271272">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41271272</a><p>&gt; <i>and IMO not even cases where the &quot;organizational&quot; benefits of such libraries are salient</i><p>Apparently, that is what it ultimately boils down to:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41271367">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41271367</a></div><br/></div></div></div></div><div id="41271136" class="c"><input type="checkbox" id="c-41271136" checked=""/><div class="controls bullet"><span class="by">guax</span><span>|</span><a href="#41270999">parent</a><span>|</span><a href="#41271963">prev</a><span>|</span><a href="#41271072">next</a><span>|</span><label class="collapse" for="c-41271136">[-]</label><label class="expand" for="c-41271136">[1 more]</label></div><br/><div class="children"><div class="content">For me is because is hard to remember that problem while dealing the the ones react brings.</div><br/></div></div><div id="41271072" class="c"><input type="checkbox" id="c-41271072" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41270999">parent</a><span>|</span><a href="#41271136">prev</a><span>|</span><a href="#41271645">next</a><span>|</span><label class="collapse" for="c-41271072">[-]</label><label class="expand" for="c-41271072">[4 more]</label></div><br/><div class="children"><div class="content">And then Svelte showed that you could avoid all that with a compilation step and live update the dom efficiently.<p><a href="https:&#x2F;&#x2F;svelte.dev&#x2F;blog&#x2F;virtual-dom-is-pure-overhead" rel="nofollow">https:&#x2F;&#x2F;svelte.dev&#x2F;blog&#x2F;virtual-dom-is-pure-overhead</a><p>React is also at the point where re-rendering the whole app is a fiction the library maintains for you while being smarter and doing less, why not go the whole way?</div><br/><div id="41271416" class="c"><input type="checkbox" id="c-41271416" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#41270999">root</a><span>|</span><a href="#41271072">parent</a><span>|</span><a href="#41271253">next</a><span>|</span><label class="collapse" for="c-41271416">[-]</label><label class="expand" for="c-41271416">[1 more]</label></div><br/><div class="children"><div class="content">And then SolidJS showed that you could do the same thing even without a compilation step.</div><br/></div></div><div id="41271253" class="c"><input type="checkbox" id="c-41271253" checked=""/><div class="controls bullet"><span class="by">ibash</span><span>|</span><a href="#41270999">root</a><span>|</span><a href="#41271072">parent</a><span>|</span><a href="#41271416">prev</a><span>|</span><a href="#41271645">next</a><span>|</span><label class="collapse" for="c-41271253">[-]</label><label class="expand" for="c-41271253">[2 more]</label></div><br/><div class="children"><div class="content">Agree, react is way too bloated right now. The original idea and first versions were great.</div><br/><div id="41271336" class="c"><input type="checkbox" id="c-41271336" checked=""/><div class="controls bullet"><span class="by">culi</span><span>|</span><a href="#41270999">root</a><span>|</span><a href="#41271253">parent</a><span>|</span><a href="#41271645">next</a><span>|</span><label class="collapse" for="c-41271336">[-]</label><label class="expand" for="c-41271336">[1 more]</label></div><br/><div class="children"><div class="content">The original idea and first versions were extremely inefficient and unscalable</div><br/></div></div></div></div></div></div><div id="41271645" class="c"><input type="checkbox" id="c-41271645" checked=""/><div class="controls bullet"><span class="by">insane_dreamer</span><span>|</span><a href="#41270999">parent</a><span>|</span><a href="#41271072">prev</a><span>|</span><a href="#41271046">next</a><span>|</span><label class="collapse" for="c-41271645">[-]</label><label class="expand" for="c-41271645">[2 more]</label></div><br/><div class="children"><div class="content">There are plenty of cases where optimizing for performance isn&#x27;t necessary. This is where React is not worth the extra headache and complexity.</div><br/><div id="41271953" class="c"><input type="checkbox" id="c-41271953" checked=""/><div class="controls bullet"><span class="by">presentation</span><span>|</span><a href="#41270999">root</a><span>|</span><a href="#41271645">parent</a><span>|</span><a href="#41271046">next</a><span>|</span><label class="collapse" for="c-41271953">[-]</label><label class="expand" for="c-41271953">[1 more]</label></div><br/><div class="children"><div class="content">React is set to become much less complex as a user once the react compiler is in place and if you use server components&#x2F;actions; in my product we’ve already basically eliminated 95% of useEffect calls, almost all data fetching, client side state management with the current gen tools, and once the compiler is in then all memoization will be gone too.<p>You still end up with the bloated bundle size but with one of the more modern react alternatives you can eliminate that too. So at least for me, I don’t mind the build complexity for the power I get; especially now that node itself is supporting typescript, the build side is getting simpler to set up as well.</div><br/></div></div></div></div></div></div><div id="41271046" class="c"><input type="checkbox" id="c-41271046" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#41270999">prev</a><span>|</span><a href="#41270820">next</a><span>|</span><label class="collapse" for="c-41271046">[-]</label><label class="expand" for="c-41271046">[1 more]</label></div><br/><div class="children"><div class="content">I was bummed when they removed E4X from the browser implementations.</div><br/></div></div><div id="41270820" class="c"><input type="checkbox" id="c-41270820" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#41271046">prev</a><span>|</span><a href="#41272012">next</a><span>|</span><label class="collapse" for="c-41270820">[-]</label><label class="expand" for="c-41270820">[14 more]</label></div><br/><div class="children"><div class="content">What benefit does the virtual DOM add?</div><br/><div id="41271379" class="c"><input type="checkbox" id="c-41271379" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#41270820">parent</a><span>|</span><a href="#41270960">next</a><span>|</span><label class="collapse" for="c-41271379">[-]</label><label class="expand" for="c-41271379">[1 more]</label></div><br/><div class="children"><div class="content">If you couldn’t efficiently batch updates, a vDOM could avoid repetitive updates in close succession, especially on IE6 (the browser React was designed for).<p>If you can control your app’s structure, it primarily adds significant increases in the RAM and CPU required for your app and slows load time because you are using a huge amount of JavaScript to emulate the carefully tuned C++ code built in to the browser. If you notice, most of the benchmarks from when React launched claiming performance wins were compared to heavyweight frameworks or complex jQuery plug-in combinations where a single user interaction might trigger cascading updates forcing the browser to rerender things which didn’t change along or to reflow multiple times in cascading update-measure-update chains. Pure DOM implementations were always faster, often by multiple orders of magnitude and once you could drop IE6, and then IE11, the DOM APIs and CSS were rich enough that much of the library code is now a net negative as well (e.g. people used to use complex code trying to build layouts which CSS grids solved).</div><br/></div></div><div id="41270960" class="c"><input type="checkbox" id="c-41270960" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#41270820">parent</a><span>|</span><a href="#41271379">prev</a><span>|</span><a href="#41270866">next</a><span>|</span><label class="collapse" for="c-41270960">[-]</label><label class="expand" for="c-41270960">[1 more]</label></div><br/><div class="children"><div class="content">It enabled a style of view library where you write immediate-mode type code that always recreates a whole component from scratch, versus having to write finicky code that both creates and then updates pieces of the page as state changes (dirty tracking, etc). Behind the scenes, you&#x27;re creating the vDOM from scratch, which is diffed against the actual retained-mode DOM, and then only the pieces that are different are updated.</div><br/></div></div><div id="41270866" class="c"><input type="checkbox" id="c-41270866" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#41270820">parent</a><span>|</span><a href="#41270960">prev</a><span>|</span><a href="#41270946">next</a><span>|</span><label class="collapse" for="c-41270866">[-]</label><label class="expand" for="c-41270866">[5 more]</label></div><br/><div class="children"><div class="content">DOM interactions (read, writes) are synchronous, they&#x27;re very slow, and it must happen on the main thread. This can cause the browser tab to freezing if access and updates aren&#x27;t carefully &quot;curated&quot; (ie you don&#x27;t want to read-check-then-write in a tight loop; or even write too often, even if it&#x27;s the same value).<p>It can also simplify some stuff surrounding event handling (but that&#x27;s not it&#x27;s main goal I think)<p>So people wrote various ways to defer&#x2F;batch&#x2F;denounce updates.<p>Virtual DOM is a general solution&#x2F;implementation. It&#x27;s not the only one, but I think you always need at least a tiny runtime to avoid too much DOM access (ie Svelte, Solid JS are fairly minimal)</div><br/><div id="41271228" class="c"><input type="checkbox" id="c-41271228" checked=""/><div class="controls bullet"><span class="by">meiraleal</span><span>|</span><a href="#41270820">root</a><span>|</span><a href="#41270866">parent</a><span>|</span><a href="#41270946">next</a><span>|</span><label class="collapse" for="c-41271228">[-]</label><label class="expand" for="c-41271228">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  but I think you always need at least a tiny runtime to avoid too much DOM access<p>Unless you use lit-html, which has a very efficient diffing algorithm that only updates the nodes that have changed.</div><br/><div id="41271749" class="c"><input type="checkbox" id="c-41271749" checked=""/><div class="controls bullet"><span class="by">smallnamespace</span><span>|</span><a href="#41270820">root</a><span>|</span><a href="#41271228">parent</a><span>|</span><a href="#41270946">next</a><span>|</span><label class="collapse" for="c-41271749">[-]</label><label class="expand" for="c-41271749">[3 more]</label></div><br/><div class="children"><div class="content">How is that done without a vdom?</div><br/><div id="41271821" class="c"><input type="checkbox" id="c-41271821" checked=""/><div class="controls bullet"><span class="by">meiraleal</span><span>|</span><a href="#41270820">root</a><span>|</span><a href="#41271749">parent</a><span>|</span><a href="#41270946">next</a><span>|</span><label class="collapse" for="c-41271821">[-]</label><label class="expand" for="c-41271821">[2 more]</label></div><br/><div class="children"><div class="content">Lit-html uses template literals for that<p><a href="https:&#x2F;&#x2F;lit.dev&#x2F;docs&#x2F;libraries&#x2F;standalone-templates&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lit.dev&#x2F;docs&#x2F;libraries&#x2F;standalone-templates&#x2F;</a><p>&quot;lit-html lets you write HTML templates in JavaScript using template literals with embedded JavaScript expressions. lit-html identifies the static and dynamic parts of your templates so it can efficiently update just the changed portions.&quot;</div><br/><div id="41272250" class="c"><input type="checkbox" id="c-41272250" checked=""/><div class="controls bullet"><span class="by">smallnamespace</span><span>|</span><a href="#41270820">root</a><span>|</span><a href="#41271821">parent</a><span>|</span><a href="#41270946">next</a><span>|</span><label class="collapse" for="c-41272250">[-]</label><label class="expand" for="c-41272250">[1 more]</label></div><br/><div class="children"><div class="content">A a high level there&#x27;s not much difference between template literals and JSX, they are both syntax-sugary ways to represent trees of essentially function calls.<p>&gt; efficiently update just the changed portions<p>Since actually applying each change to the real DOM is too slow, the only way to efficiently update is to batch changes and then apply the delta to the actual DOM.<p>That means we need to keep track of some state, namely the previously applied state and the current goal state, which you then compare.<p>Now, you may have noticed that we&#x27;ve just independently invented the concept of diffing. And the extra state that needed to be tracked can be given a spiffy name, like &quot;virtual DOM&quot;, since it&#x27;s like the DOM, but not the real thing.<p>So, I&#x27;m quite unconvinced by Lit-html&#x27;s claim that they are able to efficiently mutate the DOM without using a vDOM anywhere.<p>Either their method is not efficient (for example it falls over for rapid updates), or there is a data structure under the hood that is analogous to a vDOM, even if they prefer to give that data structure a different name.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41270946" class="c"><input type="checkbox" id="c-41270946" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#41270820">parent</a><span>|</span><a href="#41270866">prev</a><span>|</span><a href="#41271084">next</a><span>|</span><label class="collapse" for="c-41270946">[-]</label><label class="expand" for="c-41270946">[3 more]</label></div><br/><div class="children"><div class="content">The virtual dom makes implementing a declarative templating system easer, and declarative templates are easer for a developer to reason about, and less error prone, than having to mutate the dom directly.<p>People often mistakingly describe the vdom as faster than the dom, this is incorrect. It would be faster than throwing away the whole components dom and rebuilding, so the same templating code building a new dom, rather than a vdom that&#x27;s then diffed. Hand crafter mutations will be faster than a vdom diff, simply because the computer is doing les work, however much more error prone.</div><br/><div id="41271272" class="c"><input type="checkbox" id="c-41271272" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#41270820">root</a><span>|</span><a href="#41270946">parent</a><span>|</span><a href="#41271170">next</a><span>|</span><label class="collapse" for="c-41271272">[-]</label><label class="expand" for="c-41271272">[1 more]</label></div><br/><div class="children"><div class="content">Virtual DOM is to classical JS what garbage collection is to malloc and free.<p>Garbage collection is less efficient, but it is sometimes very difficult to figure out exactly when a piece of memory stops being used, which leads to use-after-free, double-free and memory leak bugs.<p>Same goes for classical UI approaches. In classical UI, most pieces of state are kept in at least two places, once in code and at least once in the DOM.<p>For example, in a shopping cart, the total might appear three times, implicitly in the code (as a function that sums the prices of all the items), once as the label of the &quot;open cart&quot; button in the navbar, and once as text in the &quot;your cart&quot; modal, which that button shows or hides. THe cart may be modifiable from different places, the cart modal itself, product pages, product collection pages, order history (when re-ordering recently purchased items) etc.<p>In the classical approach, you need to make sure that all modifications to the cart accurately change the state in all three places. You also need to ensure that if you remove a product from the cart using the modal and you&#x27;re currently on a page that lets you order the product in any way, the &quot;remove from cart&quot; button on that page needs to turn back into &quot;add to cart&quot;, and there may be hundreds of different such buttons, which the cart modal needs to handle somehow. It is very easy to make mistakes here and have the state in the code (array of products) fall out of sync with what the user sees on the page.<p>In React, there&#x27;s just one array of products, one function to calculate the total, and a lot of places in the code that use this array. WHenever the array changes, the pieces of the page that rely on it automatically re-render, while everything else stays the same. There&#x27;s no way for the UI and the array to fall out of sync, and there&#x27;s no need to track where the array is being used and where it&#x27;s being modified.</div><br/></div></div><div id="41271170" class="c"><input type="checkbox" id="c-41271170" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#41270820">root</a><span>|</span><a href="#41270946">parent</a><span>|</span><a href="#41271272">prev</a><span>|</span><a href="#41271084">next</a><span>|</span><label class="collapse" for="c-41271170">[-]</label><label class="expand" for="c-41271170">[1 more]</label></div><br/><div class="children"><div class="content">&gt; People often mistakingly describe the vdom as faster than the dom, this is incorrect.<p>You&#x27;ll get better performance with _carefully crafted_ DOM access, but that&#x27;s easier said than done, especially on a larger applications.<p>vDOM takes care of the &quot;carefully crafted&quot; part with some trade offs, especially if it also defers rendering and doesn&#x27;t wccess the DOM on every update.<p>So yes, it&#x27;s easier to write declarative UIs with it, but it&#x27;s also there to address common performance issues with unchecked&#x2F;eager DOM access. Even if you don&#x27;t throw away the whole tree and insert a new one, it can be very slow. Just _reading_ from the DOM is slow _and_ everything stops while that&#x27;s being done too.</div><br/></div></div></div></div><div id="41271084" class="c"><input type="checkbox" id="c-41271084" checked=""/><div class="controls bullet"><span class="by">ProofHouse</span><span>|</span><a href="#41270820">parent</a><span>|</span><a href="#41270946">prev</a><span>|</span><a href="#41271192">next</a><span>|</span><label class="collapse" for="c-41271084">[-]</label><label class="expand" for="c-41271084">[2 more]</label></div><br/><div class="children"><div class="content">Slows down your app too, sometimes. Depends how well you can work with and mutate a DOM, but if all things equal no VDOM is always faster cause no diffing.</div><br/><div id="41271095" class="c"><input type="checkbox" id="c-41271095" checked=""/><div class="controls bullet"><span class="by">ProofHouse</span><span>|</span><a href="#41270820">root</a><span>|</span><a href="#41271084">parent</a><span>|</span><a href="#41271192">next</a><span>|</span><label class="collapse" for="c-41271095">[-]</label><label class="expand" for="c-41271095">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people can benefit from offsetting mutations with rAF and dbl rAF and batching reads&#x2F;writes (FastDOM), before needing or considering a VDOM. VDOM came to prominence because of REACT and then started becoming used even when it wasn&#x27;t needed. It does serve a purpose and scenario when needed, tho</div><br/></div></div></div></div><div id="41271192" class="c"><input type="checkbox" id="c-41271192" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#41270820">parent</a><span>|</span><a href="#41271084">prev</a><span>|</span><a href="#41272012">next</a><span>|</span><label class="collapse" for="c-41271192">[-]</label><label class="expand" for="c-41271192">[1 more]</label></div><br/><div class="children"><div class="content">With vDOM I could say `x = JSX` then cache that in state, inserting it in multiple places. Switching to Solid you have to make sure to use `x = () =&gt; JSX` &amp; there&#x27;s some mental model adjustments since logic outside JSX isn&#x27;t reactive</div><br/></div></div></div></div><div id="41272012" class="c"><input type="checkbox" id="c-41272012" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#41270820">prev</a><span>|</span><a href="#41270945">next</a><span>|</span><label class="collapse" for="c-41272012">[-]</label><label class="expand" for="c-41272012">[2 more]</label></div><br/><div class="children"><div class="content">Imba is what anyone interested in this sort of thing should look at. I have no idea why it is not more popular. Maybe because JS devs falls for Faang marketing easily.<p><a href="https:&#x2F;&#x2F;imba.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;imba.io&#x2F;</a></div><br/><div id="41272853" class="c"><input type="checkbox" id="c-41272853" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#41272012">parent</a><span>|</span><a href="#41270945">next</a><span>|</span><label class="collapse" for="c-41272853">[-]</label><label class="expand" for="c-41272853">[1 more]</label></div><br/><div class="children"><div class="content">Many programmers seem to be scared of anything that doesn’t have semicolons and braces.</div><br/></div></div></div></div><div id="41270945" class="c"><input type="checkbox" id="c-41270945" checked=""/><div class="controls bullet"><span class="by">waynenilsen</span><span>|</span><a href="#41272012">prev</a><span>|</span><a href="#41271118">next</a><span>|</span><label class="collapse" for="c-41270945">[-]</label><label class="expand" for="c-41270945">[1 more]</label></div><br/><div class="children"><div class="content">This plays very nicely with the locality of behavior model of htmx</div><br/></div></div><div id="41271118" class="c"><input type="checkbox" id="c-41271118" checked=""/><div class="controls bullet"><span class="by">nashashmi</span><span>|</span><a href="#41270945">prev</a><span>|</span><a href="#41271565">next</a><span>|</span><label class="collapse" for="c-41271118">[-]</label><label class="expand" for="c-41271118">[1 more]</label></div><br/><div class="children"><div class="content">I wonder what The examples would look like in ECMAscript 5.</div><br/></div></div><div id="41271565" class="c"><input type="checkbox" id="c-41271565" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#41271118">prev</a><span>|</span><a href="#41272204">next</a><span>|</span><label class="collapse" for="c-41271565">[-]</label><label class="expand" for="c-41271565">[1 more]</label></div><br/><div class="children"><div class="content">Just out of interest I wanted to see something a little bit similar in Web Components:<p><pre><code>    &lt;html lang=&quot;en&quot;&gt;
    &lt;body&gt;
      &lt;h1&gt;Web Components Examples&lt;&#x2F;h1&gt;
      &lt;h2&gt;Counter Component&lt;&#x2F;h2&gt;
      &lt;counter-component&gt;&lt;&#x2F;counter-component&gt;
      &lt;h2&gt;Clickable Button Component&lt;&#x2F;h2&gt;
      &lt;clickable-button&gt;&lt;&#x2F;clickable-button&gt;
      &lt;h2&gt;Toggler Component&lt;&#x2F;h2&gt;
      &lt;toggler-component&gt;&lt;&#x2F;toggler-component&gt;
      &lt;script&gt;
        class CounterComponent extends HTMLElement {
          constructor() {
            super();
            this.count = 0;
            this.button = document.createElement(&#x27;button&#x27;);
            this.button.textContent = this.count;
            this.button.addEventListener(&#x27;click&#x27;, () =&gt; {
              this.count++;
              this.button.textContent = this.count;
            });
            this.attachShadow({ mode: &#x27;open&#x27; }).appendChild(this.button);
          }
        }
    
        class ClickableButton extends HTMLElement {
          constructor() {
            super();
            this.clicked = false;
            this.button = document.createElement(&#x27;button&#x27;);
            this.button.textContent = &quot;Click me!&quot;;
            this.button.addEventListener(&#x27;click&#x27;, () =&gt; {
              this.clicked = !this.clicked;
              this.button.textContent = this.clicked ? &quot;Clicked!&quot; : &quot;Click me!&quot;;
            });
            this.attachShadow({ mode: &#x27;open&#x27; }).appendChild(this.button);
          }
        }
    
        class TogglerComponent extends HTMLElement {
          constructor() {
            super();
            this.on = false;
            this.button = document.createElement(&#x27;button&#x27;);
            this.button.textContent = &quot;OFF&quot;;
            this.button.addEventListener(&#x27;click&#x27;, () =&gt; {
              this.on = !this.on;
              this.button.textContent = this.on ? &quot;ON&quot; : &quot;OFF&quot;;
            });
            this.attachShadow({ mode: &#x27;open&#x27; }).appendChild(this.button);
          }
        }
        customElements.define(&#x27;counter-component&#x27;, CounterComponent);
        customElements.define(&#x27;clickable-button&#x27;, ClickableButton);
        customElements.define(&#x27;toggler-component&#x27;, TogglerComponent);
      &lt;&#x2F;script&gt;
    &lt;&#x2F;body&gt;
    &lt;&#x2F;html&gt;</code></pre></div><br/></div></div><div id="41272204" class="c"><input type="checkbox" id="c-41272204" checked=""/><div class="controls bullet"><span class="by">EugeneOZ</span><span>|</span><a href="#41271565">prev</a><span>|</span><a href="#41272272">next</a><span>|</span><label class="collapse" for="c-41272204">[-]</label><label class="expand" for="c-41272204">[1 more]</label></div><br/><div class="children"><div class="content">As often happens with minimalistic approaches, it only looks interesting on very small and very simple examples.<p>After “How would they handle large data?” it turns into an unreadable mess.<p>Communication between elements is not covered, global deps, DOM updates scheduling, content projection, and so on - you “just don&#x27;t need it” in small demo examples, but you do need it in the real apps.</div><br/></div></div><div id="41272272" class="c"><input type="checkbox" id="c-41272272" checked=""/><div class="controls bullet"><span class="by">frabjoused</span><span>|</span><a href="#41272204">prev</a><span>|</span><a href="#41271446">next</a><span>|</span><label class="collapse" for="c-41272272">[-]</label><label class="expand" for="c-41272272">[1 more]</label></div><br/><div class="children"><div class="content">It’s already solved. It works well. Just walk away.</div><br/></div></div><div id="41271446" class="c"><input type="checkbox" id="c-41271446" checked=""/><div class="controls bullet"><span class="by">cyanydeez</span><span>|</span><a href="#41272272">prev</a><span>|</span><label class="collapse" for="c-41271446">[-]</label><label class="expand" for="c-41271446">[4 more]</label></div><br/><div class="children"><div class="content">I just don&#x27;t understand how people can configure their brains to parse html inside JavaScript</div><br/><div id="41272865" class="c"><input type="checkbox" id="c-41272865" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#41271446">parent</a><span>|</span><a href="#41272288">next</a><span>|</span><label class="collapse" for="c-41272865">[-]</label><label class="expand" for="c-41272865">[1 more]</label></div><br/><div class="children"><div class="content">If there can be JS inside HTML, why not HTML inside JS?</div><br/></div></div><div id="41272288" class="c"><input type="checkbox" id="c-41272288" checked=""/><div class="controls bullet"><span class="by">zazaulola</span><span>|</span><a href="#41271446">parent</a><span>|</span><a href="#41272865">prev</a><span>|</span><a href="#41272542">next</a><span>|</span><label class="collapse" for="c-41272288">[-]</label><label class="expand" for="c-41272288">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not alone. 
Someone suggested that the W3C should convene a Community Group to discuss JSX, but the grown guys involved in writing standards immediately scrapped the idea.</div><br/></div></div><div id="41272542" class="c"><input type="checkbox" id="c-41272542" checked=""/><div class="controls bullet"><span class="by">1attice</span><span>|</span><a href="#41271446">parent</a><span>|</span><a href="#41272288">prev</a><span>|</span><label class="collapse" for="c-41272542">[-]</label><label class="expand" for="c-41272542">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a trick to it. Kind of like one of those &#x27;magic eye&#x27; stereograms that were popular in the nineties. You sort of unfocus and boom, there it is.<p>It also reminds me of that Douglas Adams line about flying: it&#x27;s the trick of falling and completely missing the ground, so in order to do it, you can&#x27;t think about it too hard.</div><br/></div></div></div></div></div></div></div></div></div></body></html>