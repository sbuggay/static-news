<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735894856013" as="style"/><link rel="stylesheet" href="styles.css?v=1735894856013"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://brandur.org/fragments/uuid-v7-monotonicity">Postgres UUIDv7 and per-back end monotonicity</a> <span class="domain">(<a href="https://brandur.org">brandur.org</a>)</span></div><div class="subtext"><span>craigkerstiens</span> | <span>101 comments</span></div><br/><div><div id="42576212" class="c"><input type="checkbox" id="c-42576212" checked=""/><div class="controls bullet"><span class="by">kingkilr</span><span>|</span><a href="#42576848">next</a><span>|</span><label class="collapse" for="c-42576212">[-]</label><label class="expand" for="c-42576212">[40 more]</label></div><br/><div class="children"><div class="content">I would strongly implore people not to follow the example this post suggests, and write code that relies on this monotonicity.<p>The reason for this is simple: the documentation doesn&#x27;t promise this property. Moreover, even if it did, the RFC for UUIDv7 doesn&#x27;t promise this property. If you decide to depend on it, you&#x27;re setting yourself up for a bad time when PostgreSQL decides to change their implementation strategy, or you move to a different database.<p>Further, the stated motivations for this, to slightly simplify testing code, are massively under-motivating. Saving a single line of code can hardly be said to be worth it, but even if it were, this is a problem far better solved by simply writing a function that will both generate the objects and sort them.<p>As a profession, I strongly feel we need to do a better job orienting ourselves to the reality that our code has a tendency to live for a long time, and we need to optimize not for &quot;how quickly can I type it&quot;, but &quot;what will this code cost over its lifetime&quot;.</div><br/><div id="42576495" class="c"><input type="checkbox" id="c-42576495" checked=""/><div class="controls bullet"><span class="by">throw0101c</span><span>|</span><a href="#42576212">parent</a><span>|</span><a href="#42576906">next</a><span>|</span><label class="collapse" for="c-42576495">[-]</label><label class="expand" for="c-42576495">[18 more]</label></div><br/><div class="children"><div class="content">&gt; […] <i>code that relies on this monotonicity.</i> <i>The reason for this is simple: the documentation doesn&#x27;t promise this property. Moreover, even if it did, the RFC for UUIDv7 doesn&#x27;t promise this property.</i><p>The &quot;RFC for UUIDv7&quot;, RFC 9562, explicitly mentions monotonicity in §6.2 (&quot;Monotonicity and Counters&quot;):<p><pre><code>    Monotonicity (each subsequent value being greater than the last) is 
    the backbone of time-based sortable UUIDs. Normally, time-based UUIDs 
    from this document will be monotonic due to an embedded timestamp; 
    however, implementations can guarantee additional monotonicity via 
    the concepts covered in this section.
</code></pre>
* <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-monotonicity-and-counters" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-monotonic...</a><p>In the UUIDv7 definition (§5.7) it explicitly mentions the technique that Postgres employs for <i>rand_a</i>:<p><pre><code>    rand_a:
        12 bits of pseudorandom data to provide uniqueness as per
        Section 6.9 and&#x2F;or optional constructs to guarantee additional 
        monotonicity as per Section 6.2. Occupies bits 52 through 63 
        (octets 6-7).
</code></pre>
* <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-uuid-version-7" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-uuid-vers...</a><p>Note: &quot;optional constructs to guarantee additional monotonicity&quot;. Pg makes use of that option.</div><br/><div id="42576599" class="c"><input type="checkbox" id="c-42576599" checked=""/><div class="controls bullet"><span class="by">stonemetal12</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576495">parent</a><span>|</span><a href="#42576906">next</a><span>|</span><label class="collapse" for="c-42576599">[-]</label><label class="expand" for="c-42576599">[17 more]</label></div><br/><div class="children"><div class="content">&gt;explicitly mentions monotonicity<p>&gt;optional constructs<p>So it is explicitly mentioned in the RFC as optional, and Pg doesn&#x27;t state that they guaranty that option.  The point still stands, depending on optional behavior is a recipe for failure when the option is no longer taken.</div><br/><div id="42577105" class="c"><input type="checkbox" id="c-42577105" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576599">parent</a><span>|</span><a href="#42577202">next</a><span>|</span><label class="collapse" for="c-42577105">[-]</label><label class="expand" for="c-42577105">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s mentioned in the RFC as being explicitly monotonic based the time-based design.<p>Implementations that need monotonicity beyond the resolution of a timestamp-- like when you allocate 30 UUIDs at one instant in a batch-- can optionally use those additional bits for that purpose.<p>&gt; Implementations <i>SHOULD</i> employ the following methods for single-node UUID implementations that require batch UUID creation or are otherwise concerned about monotonicity with high-frequency UUID generation.<p>(And it goes on to recommend the obvious things you&#x27;d do: use a counter in those bits when assigning a batch; use more bits of time precision; etc.)<p>The comment in PostgreSQL before the implementation makes it clear that they chose the third option for this in the RFC:<p><pre><code>     * variant bits. To ensure monotonicity in scenarios of high-
     * frequency UUID generation, we employ the method &quot;Replace
     * LeftmostRandom Bits with Increased Clock Precision (Method 3)&quot;,
     * described in the RFC. ...</code></pre></div><br/><div id="42579731" class="c"><input type="checkbox" id="c-42579731" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42577105">parent</a><span>|</span><a href="#42577202">next</a><span>|</span><label class="collapse" for="c-42579731">[-]</label><label class="expand" for="c-42579731">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s mentioned in the RFC as being explicitly monotonic based the time-based design.<p>It&#x27;s explicitly partially monotonic.<p>Or as other people would call it, &quot;not monotonic&quot;.<p>People are talking past each other based on their use of the word &quot;monotonic&quot;.</div><br/><div id="42581561" class="c"><input type="checkbox" id="c-42581561" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42579731">parent</a><span>|</span><a href="#42577202">next</a><span>|</span><label class="collapse" for="c-42581561">[-]</label><label class="expand" for="c-42581561">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s explicitly monotonic, except for apps that have a very fast ID rate, in which case there are recommended approaches (the word &quot;SHOULD&quot; is used in an RFC) to make it work.  And PostgreSQL used one of these recommended approaches and documented it.</div><br/><div id="42582207" class="c"><input type="checkbox" id="c-42582207" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42581561">parent</a><span>|</span><a href="#42577202">next</a><span>|</span><label class="collapse" for="c-42582207">[-]</label><label class="expand" for="c-42582207">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s explicitly monotonic, except for apps that have a very fast ID rate<p>&quot;might generate two IDs in the same millisecond&quot; is not a very exotic occurrence.  It makes a big difference whether the rest is guaranteed or not.<p>&gt; And PostgreSQL used one of these recommended approaches and documented it.<p>Well that&#x27;s the center of the issue, right?  OP&#x27;s interpretation was that PostgreSQL did <i>not</i> document such, and so it shouldn&#x27;t be relied upon.  If it <i>is</i> a documented promise, then things are fine.<p>But is it actually in the documentation?  A source code comment saying it uses a certain method isn&#x27;t a promise that it will always use that method.</div><br/><div id="42582895" class="c"><input type="checkbox" id="c-42582895" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42582207">parent</a><span>|</span><a href="#42582914">next</a><span>|</span><label class="collapse" for="c-42582895">[-]</label><label class="expand" for="c-42582895">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Well that’s the center of the issue, right? OP’s interpretation was that PostgreSQL did not document such, and so it shouldn’t be relied upon.<p>And the correct answer is…we don’t know. We have a commit that landed and the explanation of the commit; we don’t have the documentation for the corresponding release of Postgres, because…it doesn’t exist yet. Because monoticity is an important feature for UUIDv7, it would be very odd if Postgres used an implementation that took the extra effort to use a nanosecond-level time value as the high-order portion of the variant part of the UUID instead of the minimum millisecond-level time, but <i>not</i> document that, but any assumption about what will be the documented, reliable-going-forward advertised feature is speculative until the documentation exists and is finalized.<p>OTOH, its perfectly fine to talk about what the implementation allows now, because that kind of thing is important to the decision about what should be documented and committed to going forward.</div><br/></div></div><div id="42582914" class="c"><input type="checkbox" id="c-42582914" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42582207">parent</a><span>|</span><a href="#42582895">prev</a><span>|</span><a href="#42577202">next</a><span>|</span><label class="collapse" for="c-42582914">[-]</label><label class="expand" for="c-42582914">[2 more]</label></div><br/><div class="children"><div class="content">The point of the extra bits is to allow the application developer to keep monotonicity in the &quot;not very exotic occurrence&quot; scenario. The purpose is to be monotonic. I feel like you are missing the core concept.</div><br/><div id="42583278" class="c"><input type="checkbox" id="c-42583278" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42582914">parent</a><span>|</span><a href="#42577202">next</a><span>|</span><label class="collapse" for="c-42583278">[-]</label><label class="expand" for="c-42583278">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not missing anything, the problem is a lot of people using sloppy wording or mixing up the two modes.<p>This comment thread is about the <i>guaranteed</i> level of monotonicity.  Yes, those bits exist.  But you can&#x27;t <i>depend</i> on them from something that only promises &quot;UUIDv7&quot;.  You need an <i>additional</i> promise that it&#x27;s configured that way and actually using those bits to maintain monotonicity.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42577202" class="c"><input type="checkbox" id="c-42577202" checked=""/><div class="controls bullet"><span class="by">throw0101c</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576599">parent</a><span>|</span><a href="#42577105">prev</a><span>|</span><a href="#42579068">next</a><span>|</span><label class="collapse" for="c-42577202">[-]</label><label class="expand" for="c-42577202">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>So it is explicitly mentioned in the RFC as optional</i> […]<p>The use of rand_a for <i>extra</i> monotonicity is optional. The monotonicity <i>itself</i> is not optional.<p>§5.7 states:<p><pre><code>    Alternatively, implementations MAY fill the 74 bits, 
    jointly, with a combination of the following subfields, 
    in this order from the most significant bits to the least, 
    to guarantee additional monotonicity within a millisecond:
</code></pre>
Guaranteeing <i>additional</i> monotonicity means that there is <i>already</i> a &#x27;base&#x27; level of monotonicity, and there are provisions for <i>even more</i> (&quot;additional&quot;) levels of it. This &#x27;base level&#x27; is why §6.2 states:<p><pre><code>    Monotonicity (each subsequent value being greater than the last) is 
    the backbone of time-based sortable UUIDs. Normally, time-based UUIDs 
    from this document will be monotonic due to an embedded timestamp; 
    however, implementations can guarantee additional monotonicity via 
    the concepts covered in this section.
</code></pre>
&quot;Backbone of time-based sortable UUIDs&quot;; &quot;additional monotonicity&quot;. Additional: adding to what&#x27;s already there.<p>* <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562</a></div><br/><div id="42579694" class="c"><input type="checkbox" id="c-42579694" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42577202">parent</a><span>|</span><a href="#42579633">next</a><span>|</span><label class="collapse" for="c-42579694">[-]</label><label class="expand" for="c-42579694">[1 more]</label></div><br/><div class="children"><div class="content">&quot;this monotonicity&quot; that OP suggests people not use is specifically the <i>additional</i> monotonicity.<p>Or to put it another way: OP is suggesting you don&#x27;t depend on it being properly monotonic, because the default is that it is only <i>partially</i> monotonic.</div><br/></div></div><div id="42579633" class="c"><input type="checkbox" id="c-42579633" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42577202">parent</a><span>|</span><a href="#42579694">prev</a><span>|</span><a href="#42582047">next</a><span>|</span><label class="collapse" for="c-42579633">[-]</label><label class="expand" for="c-42579633">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Normally, time-based UUIDs from this document will be monotonic due to an embedded timestamp; however, implementations can guarantee additional monotonicity via the concepts covered in this section.<p>“Normally, I am at home because I do not have a reason to go out; however, sometimes I am at home because I am sleeping.”<p>Notice how this statement does not actually mean that I am always at home.</div><br/></div></div></div></div><div id="42579068" class="c"><input type="checkbox" id="c-42579068" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576599">parent</a><span>|</span><a href="#42577202">prev</a><span>|</span><a href="#42576845">next</a><span>|</span><label class="collapse" for="c-42579068">[-]</label><label class="expand" for="c-42579068">[1 more]</label></div><br/><div class="children"><div class="content">I was recently bit doing a Postgres upgrade by the Postgres team considering statements like `select 1 group by true` fine to silently break in Postgres 15. See <a href="https:&#x2F;&#x2F;postgrespro.com&#x2F;list&#x2F;thread-id&#x2F;2661353" rel="nofollow">https:&#x2F;&#x2F;postgrespro.com&#x2F;list&#x2F;thread-id&#x2F;2661353</a> - and this behavior remains undocumented in <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;release&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;release&#x2F;</a> . It&#x27;s an absolutely incredible project, and I don&#x27;t disagree with the decision to classify it as wontfix - but it&#x27;s an anecdote to not rely on undefined behavior!</div><br/></div></div><div id="42576845" class="c"><input type="checkbox" id="c-42576845" checked=""/><div class="controls bullet"><span class="by">idconvict</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576599">parent</a><span>|</span><a href="#42579068">prev</a><span>|</span><a href="#42576990">next</a><span>|</span><label class="collapse" for="c-42576845">[-]</label><label class="expand" for="c-42576845">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;optional&quot; portion is this part of the spec, not the time part.<p>&gt; implementations can guarantee additional monotonicity via 
    the concepts covered in this section</div><br/><div id="42582910" class="c"><input type="checkbox" id="c-42582910" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576845">parent</a><span>|</span><a href="#42576990">next</a><span>|</span><label class="collapse" for="c-42582910">[-]</label><label class="expand" for="c-42582910">[1 more]</label></div><br/><div class="children"><div class="content">The “time part” is actually two different parts: the required millisecond-level ordering and the optional use of part of rand_a (which postgres does) to provide higher-resolution (nanosecond, in the postgres case) time ordering when combined with the required portion.<p>So, no, the “time part” <i>of the postgres implementation</i> is, in part, one of the options discussed in the spec, not merely the “time part” required in the spec.</div><br/></div></div></div></div><div id="42576990" class="c"><input type="checkbox" id="c-42576990" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576599">parent</a><span>|</span><a href="#42576845">prev</a><span>|</span><a href="#42577134">next</a><span>|</span><label class="collapse" for="c-42576990">[-]</label><label class="expand" for="c-42576990">[1 more]</label></div><br/><div class="children"><div class="content">Relying on an explicitly documented implementation behavior that the specification explicitly describes as an option is not an issue. Especially if the behavior is only relied on in a test, where the worst outcome is a failed testcase that is easily fixed.<p>Even if the behavior went away, UUIDs unlike serials can always be safely generated directly by the application just as well as they can be generated by the database.<p>Going straight for that would arguably be the &quot;better&quot; path, and allows mocking PRNG to get sequential IDs.</div><br/></div></div><div id="42577134" class="c"><input type="checkbox" id="c-42577134" checked=""/><div class="controls bullet"><span class="by">sbuttgereit</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576599">parent</a><span>|</span><a href="#42576990">prev</a><span>|</span><a href="#42576906">next</a><span>|</span><label class="collapse" for="c-42577134">[-]</label><label class="expand" for="c-42577134">[1 more]</label></div><br/><div class="children"><div class="content">Software is arbitrary. Any so-called &quot;guarantee&quot; is only as good as the developers and organizations maintaining a piece of software want to make it regardless of prior statements.  At some point, the practical likelihood of a documented, but not guaranteed, process being violated vs. the willful abandonment of a guarantee start to look very similar.... at which point nothing saves you.<p>Sometimes the best you can do is recognize who you&#x27;re working with today, know how they work, and be prepared for those people to be different in the future (or of a different mind) and for things to change regardless to expressed guarantees.<p>....unless we&#x27;re talking about the laws of physics... ...that&#x27;s different...</div><br/></div></div></div></div></div></div><div id="42576906" class="c"><input type="checkbox" id="c-42576906" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42576212">parent</a><span>|</span><a href="#42576495">prev</a><span>|</span><a href="#42576272">next</a><span>|</span><label class="collapse" for="c-42576906">[-]</label><label class="expand" for="c-42576906">[5 more]</label></div><br/><div class="children"><div class="content">As a counter-argument, it will inevitably turn into a spec if it becomes widely-used enough.<p>What was that saying, like: “every behavior of software eventually becomes API”</div><br/><div id="42576997" class="c"><input type="checkbox" id="c-42576997" checked=""/><div class="controls bullet"><span class="by">tomstuart</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576906">parent</a><span>|</span><a href="#42577344">next</a><span>|</span><label class="collapse" for="c-42576997">[-]</label><label class="expand" for="c-42576997">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.hyrumslaw.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hyrumslaw.com&#x2F;</a></div><br/><div id="42578430" class="c"><input type="checkbox" id="c-42578430" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576997">parent</a><span>|</span><a href="#42577344">next</a><span>|</span><label class="collapse" for="c-42578430">[-]</label><label class="expand" for="c-42578430">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that one! Thanks :)</div><br/></div></div></div></div><div id="42577344" class="c"><input type="checkbox" id="c-42577344" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576906">parent</a><span>|</span><a href="#42576997">prev</a><span>|</span><a href="#42576272">next</a><span>|</span><label class="collapse" for="c-42577344">[-]</label><label class="expand" for="c-42577344">[2 more]</label></div><br/><div class="children"><div class="content">Consider the incentives you&#x27;re setting up there. An API contract goes both ways, the vendor promises some things and not others to preserve flexibility, and the user has to abide by it to not get broken in the future. If you unilaterally ignore the contract, even plan to do so in advance, then eventually kindness and capacity to accommodate such abuse will run might run out and they may switch to an adversarial stance. See QUIC for example which is a big middle finger to middle boxes.</div><br/><div id="42578450" class="c"><input type="checkbox" id="c-42578450" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42577344">parent</a><span>|</span><a href="#42576272">next</a><span>|</span><label class="collapse" for="c-42578450">[-]</label><label class="expand" for="c-42578450">[1 more]</label></div><br/><div class="children"><div class="content">Sure, there is a risk. But, it all depends on how great and desirable the benefits are.</div><br/></div></div></div></div></div></div><div id="42576272" class="c"><input type="checkbox" id="c-42576272" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#42576212">parent</a><span>|</span><a href="#42576906">prev</a><span>|</span><a href="#42576300">next</a><span>|</span><label class="collapse" for="c-42576272">[-]</label><label class="expand" for="c-42576272">[3 more]</label></div><br/><div class="children"><div class="content">The test should do a set comparison, not an ordered list comparison, if it wants to check that the same 5 accounts were returned by the API. I think it&#x27;s as simple as that.<p>The blogpost is interesting and I appreciated learning the details of how the UUIDv7 implementation works.</div><br/><div id="42576341" class="c"><input type="checkbox" id="c-42576341" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576272">parent</a><span>|</span><a href="#42576300">next</a><span>|</span><label class="collapse" for="c-42576341">[-]</label><label class="expand" for="c-42576341">[2 more]</label></div><br/><div class="children"><div class="content">Don’t you think that depends on what you’re guaranteeing in your api? If you’re guaranteeing that your api returns the accounts ordered you need to test for that. But I do agree in general that using a set is the correct move.</div><br/><div id="42576711" class="c"><input type="checkbox" id="c-42576711" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576341">parent</a><span>|</span><a href="#42576300">next</a><span>|</span><label class="collapse" for="c-42576711">[-]</label><label class="expand" for="c-42576711">[1 more]</label></div><br/><div class="children"><div class="content">The test is a very strange example indeed. Is it testing the backend, the database or both? If the api was guaranteeing ordered values, pre-uuid7 the backend must have sorted them by other means before returning, making the test identical. If the backend is not guaranteeing order, that shouldn&#x27;t be tested either.</div><br/></div></div></div></div></div></div><div id="42576300" class="c"><input type="checkbox" id="c-42576300" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42576212">parent</a><span>|</span><a href="#42576272">prev</a><span>|</span><a href="#42576998">next</a><span>|</span><label class="collapse" for="c-42576300">[-]</label><label class="expand" for="c-42576300">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Moreover, <i>even if it did,</i> the RFC for UUIDv7 doesn&#x27;t promise this property.<p>Huh?<p>If the docs were to guarantee it, they guarantee it. Why are you looking for everything to be part of RFC UUIDv7?<p>Failure of logic.</div><br/><div id="42577060" class="c"><input type="checkbox" id="c-42577060" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576300">parent</a><span>|</span><a href="#42576998">next</a><span>|</span><label class="collapse" for="c-42577060">[-]</label><label class="expand" for="c-42577060">[1 more]</label></div><br/><div class="children"><div class="content">Their next sentence explains. Other databases might not make that guarantee, including future versions of Postgres.</div><br/></div></div></div></div><div id="42576998" class="c"><input type="checkbox" id="c-42576998" checked=""/><div class="controls bullet"><span class="by">deadbabe</span><span>|</span><a href="#42576212">parent</a><span>|</span><a href="#42576300">prev</a><span>|</span><a href="#42576251">next</a><span>|</span><label class="collapse" for="c-42576998">[-]</label><label class="expand" for="c-42576998">[5 more]</label></div><br/><div class="children"><div class="content">Most code does not live for a long time. Similar to how consumer products are built for planned obsolescence, code is also built with a specific lifespan in mind.<p>If you spend time making code bulletproof so it can run for like 100 years, you will have wasted a lot of effort for nothing when someone comes along and wipes it clean and replaces it with new code in 2 years. Requirements change, code changes, it’s the nature of business.<p>Remember any fool can build a bridge that stands, it takes an engineer to make a bridge that barely stands.</div><br/><div id="42577156" class="c"><input type="checkbox" id="c-42577156" checked=""/><div class="controls bullet"><span class="by">agilob</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576998">parent</a><span>|</span><a href="#42581141">next</a><span>|</span><label class="collapse" for="c-42577156">[-]</label><label class="expand" for="c-42577156">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Most code does not live for a long time.<p>Sure, and here I am in a third company doing cloud migration and changing our default DB from MySQL to SQL server. The pain is real, 2 year long roadmap is now 5 years longer roadmap. All because some dude negotiated a discount on cloud services. And we still develop integrations that talk to systems written for DOS.</div><br/></div></div><div id="42581141" class="c"><input type="checkbox" id="c-42581141" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576998">parent</a><span>|</span><a href="#42577156">prev</a><span>|</span><a href="#42577137">next</a><span>|</span><label class="collapse" for="c-42581141">[-]</label><label class="expand" for="c-42581141">[1 more]</label></div><br/><div class="children"><div class="content">What? Okay, so assume that most code doesn&#x27;t last. It doesn&#x27;t mean that you should purposefully make it brittle for basically no additional benefit? If as you say, it&#x27;s about making the most with as little as possible (which is what the bridge analogy usually refers to), then surely adding a single function (to actually enforce the ordering you want) to make your code more robust is one of the best examples of that?</div><br/></div></div><div id="42577137" class="c"><input type="checkbox" id="c-42577137" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576998">parent</a><span>|</span><a href="#42581141">prev</a><span>|</span><a href="#42576251">next</a><span>|</span><label class="collapse" for="c-42577137">[-]</label><label class="expand" for="c-42577137">[2 more]</label></div><br/><div class="children"><div class="content">Uh, more people work on 20-year-old codebases than you&#x27;d think.</div><br/><div id="42578908" class="c"><input type="checkbox" id="c-42578908" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42577137">parent</a><span>|</span><a href="#42576251">next</a><span>|</span><label class="collapse" for="c-42578908">[-]</label><label class="expand" for="c-42578908">[1 more]</label></div><br/><div class="children"><div class="content">And yet these people are dwarved by the number of developers crunching out generic line of business CRUD apps every day.</div><br/></div></div></div></div></div></div><div id="42576251" class="c"><input type="checkbox" id="c-42576251" checked=""/><div class="controls bullet"><span class="by">3eb7988a1663</span><span>|</span><a href="#42576212">parent</a><span>|</span><a href="#42576998">prev</a><span>|</span><a href="#42576752">next</a><span>|</span><label class="collapse" for="c-42576251">[-]</label><label class="expand" for="c-42576251">[3 more]</label></div><br/><div class="children"><div class="content">I too am missing the win on this. It is breaking the spec, and does not seem like it offers a significant advantage. In the eventual event where you have a collection of UUID7 you are only ever going to be able to rely on the millisecond precision anyway.</div><br/><div id="42576316" class="c"><input type="checkbox" id="c-42576316" checked=""/><div class="controls bullet"><span class="by">sbuttgereit</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576251">parent</a><span>|</span><a href="#42576582">next</a><span>|</span><label class="collapse" for="c-42576316">[-]</label><label class="expand" for="c-42576316">[1 more]</label></div><br/><div class="children"><div class="content">You say it&#x27;s breaking the spec, but is it?<p>From <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9562.html#name-uuid-version-7" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9562.html#name-uuid-versio...</a>:<p>&quot;UUIDv7 values are created by allocating a Unix timestamp in
   milliseconds in the most significant 48 bits and filling the
   remaining 74 bits, excluding the required version and variant bits,
   with random bits for each new UUIDv7 generated to provide uniqueness
   as per Section 6.9.  Alternatively, implementations MAY fill the 74
   bits, jointly, with a combination of the following subfields, in this
   order from the most significant bits to the least, to guarantee
   additional monotonicity within a millisecond:<p><pre><code>   1.  An OPTIONAL sub-millisecond timestamp fraction (12 bits at
       maximum) as per Section 6.2 (Method 3).

   2.  An OPTIONAL carefully seeded counter as per Section 6.2 (Method 1
       or 2).

   3.  Random data for each new UUIDv7 generated for any remaining
       space.&quot;
</code></pre>
Which the referenced &quot;method 3&quot; is:<p>&quot;Replace Leftmost Random Bits with Increased Clock Precision (Method 3):<p>For UUIDv7, which has millisecond timestamp precision, it is possible to use additional clock precision available on the system to substitute for up to 12 random bits immediately following the timestamp. This can provide values that are time ordered with sub-millisecond precision, using however many bits are appropriate in the implementation environment. With this method, the additional time precision bits MUST follow the timestamp as the next available bit in the rand_a field for UUIDv7.&quot;</div><br/></div></div><div id="42576582" class="c"><input type="checkbox" id="c-42576582" checked=""/><div class="controls bullet"><span class="by">throw0101c</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576251">parent</a><span>|</span><a href="#42576316">prev</a><span>|</span><a href="#42576752">next</a><span>|</span><label class="collapse" for="c-42576582">[-]</label><label class="expand" for="c-42576582">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It is breaking the spec</i> […]<p>As per a sibling comment, it is not breaking the spec. The comment in the Pg code even cites the spec that says what to do (and is quoted in the post):<p><pre><code>     * Generate UUID version 7 per RFC 9562, with the given timestamp.
     *
     * UUID version 7 consists of a Unix timestamp in milliseconds (48
     * bits) and 74 random bits, excluding the required version and
     * variant bits. To ensure monotonicity in scenarios of high-
     * frequency UUID generation, we employ the method &quot;Replace
     * LeftmostRandom Bits with Increased Clock Precision (Method 3)&quot;,
     * described in the RFC. […]</code></pre></div><br/></div></div></div></div><div id="42576752" class="c"><input type="checkbox" id="c-42576752" checked=""/><div class="controls bullet"><span class="by">braiamp</span><span>|</span><a href="#42576212">parent</a><span>|</span><a href="#42576251">prev</a><span>|</span><a href="#42576848">next</a><span>|</span><label class="collapse" for="c-42576752">[-]</label><label class="expand" for="c-42576752">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think most people will heed this warning. I warned people in a programming forum that Python ordering of objects by insertion time was a implementation detail, because it&#x27;s not guaranteed by any PEP [0]. I could literally write a PEP compliant Python interpreter and could blow up in someone&#x27;s code because they rely on the CPython interpreter behavior.<p>[0]: <a href="https:&#x2F;&#x2F;mail.python.org&#x2F;pipermail&#x2F;python-dev&#x2F;2017-December&#x2F;151283.html" rel="nofollow">https:&#x2F;&#x2F;mail.python.org&#x2F;pipermail&#x2F;python-dev&#x2F;2017-December&#x2F;1...</a></div><br/><div id="42576961" class="c"><input type="checkbox" id="c-42576961" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576752">parent</a><span>|</span><a href="#42576959">next</a><span>|</span><label class="collapse" for="c-42576961">[-]</label><label class="expand" for="c-42576961">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I warned people in a programming forum that Python ordering of objects by insertion time was a implementation detail, because it&#x27;s not guaranteed by any PEP<p>PEPs do not provide a spec for Python, they neither cover the initial base language before the PEP process started, nor were all subsequent language changes made through PEPs.  The closest thing Python has to a cross-implementation standard is the Python Language Reference for a particular version, treating as excluded anything explicitly noted as a CPython implementation detail. Dictionaries being insertion-ordered went from a CPython implementation detail in 3.6 to guaranteed language feature in 3.7+.</div><br/></div></div><div id="42576959" class="c"><input type="checkbox" id="c-42576959" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42576212">root</a><span>|</span><a href="#42576752">parent</a><span>|</span><a href="#42576961">prev</a><span>|</span><a href="#42576848">next</a><span>|</span><label class="collapse" for="c-42576959">[-]</label><label class="expand" for="c-42576959">[1 more]</label></div><br/><div class="children"><div class="content">That definitely <i>was</i> true, and I use to jitter my code a little to deliberately find and break tests that depended on any particular ordering.<p>It&#x27;s now explicitly documented to be true, and you can officially rely on it. From <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html#dict" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html#dict</a>:<p>&gt; Changed in version 3.7: Dictionary order is guaranteed to be insertion order.<p>That link documents the Python language&#x27;s semantics, not the behavior of any particular interpreter.</div><br/></div></div></div></div></div></div><div id="42576848" class="c"><input type="checkbox" id="c-42576848" checked=""/><div class="controls bullet"><span class="by">mmerickel</span><span>|</span><a href="#42576212">prev</a><span>|</span><a href="#42576248">next</a><span>|</span><label class="collapse" for="c-42576848">[-]</label><label class="expand" for="c-42576848">[2 more]</label></div><br/><div class="children"><div class="content">Remember even if timestamps may be generated using a monotonically increasing value that does not mean they were committed in the same order to the database. It is an entirely separate problem if you are trying to actually determine what rows are &quot;new&quot; versus &quot;previously seen&quot; for things like cursor-based APIs and background job processing. This problem exists even with things like a serial&#x2F;autoincrement primary key.</div><br/><div id="42577477" class="c"><input type="checkbox" id="c-42577477" checked=""/><div class="controls bullet"><span class="by">shalabhc</span><span>|</span><a href="#42576848">parent</a><span>|</span><a href="#42576248">next</a><span>|</span><label class="collapse" for="c-42577477">[-]</label><label class="expand" for="c-42577477">[1 more]</label></div><br/><div class="children"><div class="content">+1<p>What could be useful here is if postgres provided a way to determine the latest frozen uuid. This could be a few ms behind the last committed uuid but should guarantee that no new rows will land before the frozen uuid. Then we can use a single cursor track previously seen.</div><br/></div></div></div></div><div id="42576248" class="c"><input type="checkbox" id="c-42576248" checked=""/><div class="controls bullet"><span class="by">fngjdflmdflg</span><span>|</span><a href="#42576848">prev</a><span>|</span><a href="#42579149">next</a><span>|</span><label class="collapse" for="c-42576248">[-]</label><label class="expand" for="c-42576248">[15 more]</label></div><br/><div class="children"><div class="content">&gt;The Postgres patch solves the problem by repurposing 12 bits of the UUID’s random component to increase the precision of the timestamp down to nanosecond granularity [...]<p>&gt;It makes a repeated UUID between processes more likely, but there’s still 62 bits of randomness left to make use of, so collisions remain vastly unlikely.<p>Does it? Even though the number of random bits has decreased, the time interval to create such a duplicate has also decreased, namely to an interval of one nanosecond.</div><br/><div id="42576330" class="c"><input type="checkbox" id="c-42576330" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#42576248">parent</a><span>|</span><a href="#42577456">next</a><span>|</span><label class="collapse" for="c-42576330">[-]</label><label class="expand" for="c-42576330">[11 more]</label></div><br/><div class="children"><div class="content">I could imagine that certain nanoseconds might be vastly more likely than other nanoseconds.<p>For example, imagine you have a router that sends network packets out at the start of each microsecond, synced to wall time.<p>Or the OS scheduler always wakes processes up on a millisecond timer tick or some polling loop.<p>Now, when those packets are received by a postgres server and processed, the time to do that is probably fairly consistent - meaning that X nanoseconds past the microsecond you probably get most records being created.</div><br/><div id="42576494" class="c"><input type="checkbox" id="c-42576494" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42576330">parent</a><span>|</span><a href="#42577456">next</a><span>|</span><label class="collapse" for="c-42576494">[-]</label><label class="expand" for="c-42576494">[10 more]</label></div><br/><div class="children"><div class="content">But only one nanosecond slower or faster and you get another set of 4.611 billion billion random IDs. I think random variations in buffer depths and CPU speeds will easily introduce hundreds of nanoseconds of timing variations. syncing any two things to less than 1 nanosecond is incredibly hard and doesn&#x27;t happen by accident.</div><br/><div id="42576585" class="c"><input type="checkbox" id="c-42576585" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42576494">parent</a><span>|</span><a href="#42577223">next</a><span>|</span><label class="collapse" for="c-42576585">[-]</label><label class="expand" for="c-42576585">[5 more]</label></div><br/><div class="children"><div class="content">The important part is the events in time aren&#x27;t going to be as random as the actual random source. The chances of an actual collision remain low but the distribution of events over time is a weaker (in relative terms) source of random bits compared to proper &quot;random&quot; sources which won&#x27;t have obvious bias at all.</div><br/><div id="42577252" class="c"><input type="checkbox" id="c-42577252" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42576585">parent</a><span>|</span><a href="#42577223">next</a><span>|</span><label class="collapse" for="c-42577252">[-]</label><label class="expand" for="c-42577252">[4 more]</label></div><br/><div class="children"><div class="content">I am sure there is bias but 1 nanosecond is an incredibly narrow window. It really would be an interesting experiment to evaluate the optimal balance of bits for timestamp and for random value.
What about hostname and even process ID? Snowflake IDs are 63 bits long with 41 bits as a millisecond timestamp, 10 bits as a machine ID, and 12 bits as a sequential counter.</div><br/><div id="42579410" class="c"><input type="checkbox" id="c-42579410" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42577252">parent</a><span>|</span><a href="#42578585">next</a><span>|</span><label class="collapse" for="c-42579410">[-]</label><label class="expand" for="c-42579410">[2 more]</label></div><br/><div class="children"><div class="content">I suppose that would depend entirely on how you measure what optimal is. Optimal randomness is 128 bits from the best random source and 0 bits from anything else, like time. Optimal &quot;just random enough for my use case but no more so I can fit other information in the value&quot; depends entirely on the requirement of your use case (more specifically, not just &quot;for databases&quot; but &quot;for my database to... on the hardware... in which the access is... on the presumed growth...&quot; and so on). For picking a &quot;good enough&quot; value 12 bits is probably as reasonable as one will find generic reason for.</div><br/></div></div><div id="42578585" class="c"><input type="checkbox" id="c-42578585" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42577252">parent</a><span>|</span><a href="#42579410">prev</a><span>|</span><a href="#42577223">next</a><span>|</span><label class="collapse" for="c-42578585">[-]</label><label class="expand" for="c-42578585">[1 more]</label></div><br/><div class="children"><div class="content">Similarly for direct comparison, ULID has 48-bit timestamps, also at the millisecond, and 80 random bits.<p>Also to compare, the ULID spec technique for monotonicity is to take a single random value and then start incrementing the lowest bits, trading random entropy for direct &quot;nearness&quot;, one after another. Versus the rand_a approach is effectively using the most significant bits, but keeping more random entropy.</div><br/></div></div></div></div></div></div><div id="42577223" class="c"><input type="checkbox" id="c-42577223" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42576494">parent</a><span>|</span><a href="#42576585">prev</a><span>|</span><a href="#42577456">next</a><span>|</span><label class="collapse" for="c-42577223">[-]</label><label class="expand" for="c-42577223">[4 more]</label></div><br/><div class="children"><div class="content">We&#x27;re not talking about nanoseconds of real time; we&#x27;re talking about nanoseconds as measured by the CPU doing the processing.  Nanoseconds are not likely to be a uniform variate.</div><br/><div id="42577302" class="c"><input type="checkbox" id="c-42577302" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42577223">parent</a><span>|</span><a href="#42577456">next</a><span>|</span><label class="collapse" for="c-42577302">[-]</label><label class="expand" for="c-42577302">[3 more]</label></div><br/><div class="children"><div class="content">Yes and they are also not likely to be so non-uniform that more than 6.411 billion billion events all happen in one nanosecond.</div><br/><div id="42577523" class="c"><input type="checkbox" id="c-42577523" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42577302">parent</a><span>|</span><a href="#42577456">next</a><span>|</span><label class="collapse" for="c-42577523">[-]</label><label class="expand" for="c-42577523">[2 more]</label></div><br/><div class="children"><div class="content">Note it&#x27;s not that number, but roughly the square root of that number, that matters.<p>And they might be quite non-uniform.  If the scheduler tick and the nanosecond clock are synchronous, you could end up with a few thousand popular values instead of a billion.<p>It&#x27;s not a real concern today, and probably won&#x27;t be a real concern in 10 years, but it&#x27;s not so far removed from possibility that no one has to think about it.</div><br/><div id="42577649" class="c"><input type="checkbox" id="c-42577649" checked=""/><div class="controls bullet"><span class="by">UltraSane</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42577523">parent</a><span>|</span><a href="#42577456">next</a><span>|</span><label class="collapse" for="c-42577649">[-]</label><label class="expand" for="c-42577649">[1 more]</label></div><br/><div class="children"><div class="content">Good point about the square root of the random part. I guess that is why the 63 bit Snowflake ID uses a sequential counter.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42577456" class="c"><input type="checkbox" id="c-42577456" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#42576248">parent</a><span>|</span><a href="#42576330">prev</a><span>|</span><a href="#42576319">next</a><span>|</span><label class="collapse" for="c-42577456">[-]</label><label class="expand" for="c-42577456">[2 more]</label></div><br/><div class="children"><div class="content">Imagine if you were generating 16 UUIDs per nanosecond, every nanosecond.<p>According to [1] due to the birthday paradox, the probability of a collision in any given nanosecond would be 3E−17 which of course sounds pretty low<p>But there are 3.154e+16 nanoseconds in a year - and if you get out your high-precision calculator, it&#x27;ll tell you there&#x27;s a 61.41% chance of a collision in a year.<p>Of course you might very well say &quot;Who needs 16 UUIDs per nanosecond anyway?&quot;<p>[1] <a href="https:&#x2F;&#x2F;www.bdayprob.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bdayprob.com&#x2F;</a></div><br/><div id="42579069" class="c"><input type="checkbox" id="c-42579069" checked=""/><div class="controls bullet"><span class="by">Horffupolde</span><span>|</span><a href="#42576248">root</a><span>|</span><a href="#42577456">parent</a><span>|</span><a href="#42576319">next</a><span>|</span><label class="collapse" for="c-42579069">[-]</label><label class="expand" for="c-42579069">[1 more]</label></div><br/><div class="children"><div class="content">So what if there’s a collision? If the column is UNIQUE at most it’ll ROLLBACK on INSERT. 16 INSERTS per nanosecond is 16 billion TPS. At that scale you’ll have other problems.</div><br/></div></div></div></div><div id="42576319" class="c"><input type="checkbox" id="c-42576319" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42576248">parent</a><span>|</span><a href="#42577456">prev</a><span>|</span><a href="#42579149">next</a><span>|</span><label class="collapse" for="c-42576319">[-]</label><label class="expand" for="c-42576319">[1 more]</label></div><br/><div class="children"><div class="content">Depends if you think sub-millisecond locality is significant.</div><br/></div></div></div></div><div id="42579149" class="c"><input type="checkbox" id="c-42579149" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42576248">prev</a><span>|</span><a href="#42579936">next</a><span>|</span><label class="collapse" for="c-42579149">[-]</label><label class="expand" for="c-42579149">[3 more]</label></div><br/><div class="children"><div class="content">I implemented this in pure Python a few days ago in case anyone finds it helpful, here it is: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;pirate&#x2F;7e44387c12f434a77072d50c52a3d18e" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;pirate&#x2F;7e44387c12f434a77072d50c52a3d...</a><p>My implementation supports graceful degradation between nanosecond scale resolution, microsecond, and millisecond, by using 12 bits for each and filling up the leftmost bits of rand_a and rand_b. Not all environments provide high resolution system clocks with no drift, so it&#x27;s is important to maintain monotonicity when generating IDs with a low-res timestamp as input. You still want the bits that would&#x27;ve held the nanosecond value to be monotonic.<p>Neither of the existing uuid_utils and uuid7 python libs that can generate UUID7s support this monotonicity property.<p>Am planning on using this for ArchiveBox append-only &quot;snapshot&quot; records, which are intrinsically linked to time, so it&#x27;s a good use-case imo.<p>There&#x27;s another great resource here that I think is one of the best explainers of UUIDv7: <a href="https:&#x2F;&#x2F;antonz.org&#x2F;uuidv7&#x2F;" rel="nofollow">https:&#x2F;&#x2F;antonz.org&#x2F;uuidv7&#x2F;</a><p>Whatever you do, don&#x27;t implement the cursed 36-bit whole-second based time UUIDv7 variant that you occasionally see on StackOverflow &#x2F; blog posts, stick to 48!</div><br/><div id="42581870" class="c"><input type="checkbox" id="c-42581870" checked=""/><div class="controls bullet"><span class="by">tomComb</span><span>|</span><a href="#42579149">parent</a><span>|</span><a href="#42579936">next</a><span>|</span><label class="collapse" for="c-42581870">[-]</label><label class="expand" for="c-42581870">[2 more]</label></div><br/><div class="children"><div class="content">This looks great, thanks.   But I think gists are better for unimportant stuff - for this I think it deserves its own repo.</div><br/><div id="42582237" class="c"><input type="checkbox" id="c-42582237" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42579149">root</a><span>|</span><a href="#42581870">parent</a><span>|</span><a href="#42579936">next</a><span>|</span><label class="collapse" for="c-42582237">[-]</label><label class="expand" for="c-42582237">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the ArchiveBox git repo and I may give it it&#x27;s own library eventually, but for quick linking it&#x27;s easier to read &#x2F; less dependent on the rest of that codebase as a standalone script.</div><br/></div></div></div></div></div></div><div id="42579936" class="c"><input type="checkbox" id="c-42579936" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#42579149">prev</a><span>|</span><a href="#42577613">next</a><span>|</span><label class="collapse" for="c-42579936">[-]</label><label class="expand" for="c-42579936">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The Postgres patch solves the problem by repurposing 12 bits of the UUID’s random component to increase the precision of the timestamp down to nanosecond granularity (filling rand_a above), which in practice is too precise to contain two UUIDv7s generated in the same process.<p>A millisecond divided by 4096 is not a nanosecond.  It&#x27;s about 250 nanoseconds.</div><br/></div></div><div id="42577613" class="c"><input type="checkbox" id="c-42577613" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#42579936">prev</a><span>|</span><a href="#42576293">next</a><span>|</span><label class="collapse" for="c-42577613">[-]</label><label class="expand" for="c-42577613">[2 more]</label></div><br/><div class="children"><div class="content">Ordering for UUIDv7s in the same millisecond is super useful when some rows represent actions and others reactions.<p>I have used this guarantee for events generated on clients.  It really simplifies a lot of reasoning.</div><br/></div></div><div id="42576293" class="c"><input type="checkbox" id="c-42576293" checked=""/><div class="controls bullet"><span class="by">dotdi</span><span>|</span><a href="#42577613">prev</a><span>|</span><a href="#42583009">next</a><span>|</span><label class="collapse" for="c-42576293">[-]</label><label class="expand" for="c-42576293">[6 more]</label></div><br/><div class="children"><div class="content">My org has been using ULID[0] extensively for a few years, and generally we&#x27;ve been quite happy with it. After initially dabbing with a few implementations, I reimplemented the spec in Kotlin, and this has been working out quite well for us. We will open-source our implementation in the following weeks.<p>ULID does specifically require generated IDs to be monotonically increasing as opposed to what the RFC for UUIDv7 states, which is a big deal IMHO.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec">https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec</a></div><br/><div id="42577689" class="c"><input type="checkbox" id="c-42577689" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#42576293">parent</a><span>|</span><a href="#42578965">next</a><span>|</span><label class="collapse" for="c-42577689">[-]</label><label class="expand" for="c-42577689">[4 more]</label></div><br/><div class="children"><div class="content">Having used a lot of the ULID variants that the UUIDv7 spec cites as prior art, including the ULID spec you link to, I&#x27;ve gotta say that UUIDv7 has some real advantages.<p>The biggest advantage is that it is hex.  Haven&#x27;t yet met a database system that doesn&#x27;t have functions for substr and from_hex etc, meaning you can extract the time part using vanilla sql.<p>ULID and others that use custom variants of base32 or base62 or whatever are just about impossible to wrangle with normal tooling.<p>Your future selfs will thank you for being able to manipulate it in whatever database you use in the future to analyse old logs or import whatever data you generate today.</div><br/><div id="42579005" class="c"><input type="checkbox" id="c-42579005" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42576293">root</a><span>|</span><a href="#42577689">parent</a><span>|</span><a href="#42577865">next</a><span>|</span><label class="collapse" for="c-42579005">[-]</label><label class="expand" for="c-42579005">[1 more]</label></div><br/><div class="children"><div class="content">Additionally, v7 UUIDs can be generated simultaneously on the client-side by multiple threads without waiting for an oracle to release the next available ID. That&#x27;s quite important for parallel processing. Otherwise, you might as well use an autoincrement BIGINT.</div><br/></div></div><div id="42577865" class="c"><input type="checkbox" id="c-42577865" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#42576293">root</a><span>|</span><a href="#42577689">parent</a><span>|</span><a href="#42579005">prev</a><span>|</span><a href="#42578965">next</a><span>|</span><label class="collapse" for="c-42577865">[-]</label><label class="expand" for="c-42577865">[2 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t they stored as 16 bytes in binary?  How to format it later as text is then your choice.</div><br/><div id="42578939" class="c"><input type="checkbox" id="c-42578939" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#42576293">root</a><span>|</span><a href="#42577865">parent</a><span>|</span><a href="#42578965">next</a><span>|</span><label class="collapse" for="c-42578939">[-]</label><label class="expand" for="c-42578939">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s that eternal push&#x2F;pull &quot;war&quot; between &quot;we need a sproc that can report this directly from the SQL server&quot; and &quot;please don&#x27;t do things directly on the SQL server because you&#x27;ll route around important application code&quot; and &quot;it&#x27;s a feature not a bug that you can&#x27;t just look things up by ID in the DB without a little bit of extra work&quot;.<p>I did work on a project using ULIDs in SQL Server. They were stored in uniqueidentifier fields with a complex byte swap from ULID to fake-UUID to get better storage&#x2F;indexing out of SQL Server [1]. There was an attempt to use SQL Functions to display&#x2F;search the ULID form directly in the database, but it was never as bug free as the C# byte order code and so it was definitely not recommended doing it directly in the DB and that if a &quot;report&quot; was missing it should be a part of the application (which was already almost nothing but a bloated &quot;reporting&quot; tool) or in a related &quot;configuration&quot; application. It did feel more like a feature than a bug because it did keep some meddling and drama out of the DB. I also see the arguments for why in some different types of applications it makes debugging a lot harder and those arguments make sense and it is definitely a trade-off to consider.<p>[1] The rabbit hole into SQL Server&#x27;s ancient weird UUID sort order: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20190426-00&#x2F;?p=102450" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20190426-00&#x2F;?p=10...</a></div><br/></div></div></div></div></div></div><div id="42578965" class="c"><input type="checkbox" id="c-42578965" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42576293">parent</a><span>|</span><a href="#42577689">prev</a><span>|</span><a href="#42583009">next</a><span>|</span><label class="collapse" for="c-42578965">[-]</label><label class="expand" for="c-42578965">[1 more]</label></div><br/><div class="children"><div class="content">ULID guarantees monotonicity only per process, and it requires ID generation to be serialized. I find the promise quite misleading because of that. You might as well use a wide-enough integer with the current timestamp + random as baseline for the same purpose, but I wouldn&#x27;t recommend that either.</div><br/></div></div></div></div><div id="42583009" class="c"><input type="checkbox" id="c-42583009" checked=""/><div class="controls bullet"><span class="by">hardwaresofton</span><span>|</span><a href="#42576293">prev</a><span>|</span><a href="#42579949">next</a><span>|</span><label class="collapse" for="c-42583009">[-]</label><label class="expand" for="c-42583009">[1 more]</label></div><br/><div class="children"><div class="content">Been waiting for UUIDv7 for years -- maybe it&#x27;s time to archive pg_idkit[0], or maybe instead just switch the UUIDv7 version to do the native thing rather than the Rust code.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;VADOSWARE&#x2F;pg_idkit">https:&#x2F;&#x2F;github.com&#x2F;VADOSWARE&#x2F;pg_idkit</a></div><br/></div></div><div id="42579949" class="c"><input type="checkbox" id="c-42579949" checked=""/><div class="controls bullet"><span class="by">dfee</span><span>|</span><a href="#42583009">prev</a><span>|</span><a href="#42576359">next</a><span>|</span><label class="collapse" for="c-42579949">[-]</label><label class="expand" for="c-42579949">[1 more]</label></div><br/><div class="children"><div class="content">I have an implementation function that computes N v7 UUIDs, sorts them, and returns them. This makes testing possible.<p><pre><code>    Collection&lt;UUID&gt; generate(final int count);
</code></pre>
I also have an interface that I can back with a RNG that generates auto incrementing values, sorts for testing, I have the experience of ints, but for production, my non-timestamp component is random.</div><br/></div></div><div id="42576359" class="c"><input type="checkbox" id="c-42576359" checked=""/><div class="controls bullet"><span class="by">lordofgibbons</span><span>|</span><a href="#42579949">prev</a><span>|</span><a href="#42577844">next</a><span>|</span><label class="collapse" for="c-42576359">[-]</label><label class="expand" for="c-42576359">[2 more]</label></div><br/><div class="children"><div class="content">What benefit does this have over something like Twitter&#x27;s Snowflake, which can be used to generate distributed monotonically increasing IDs without synchronization?<p>We&#x27;ve been using an implementation of it in Go for many years in production without issues.</div><br/><div id="42579121" class="c"><input type="checkbox" id="c-42579121" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#42576359">parent</a><span>|</span><a href="#42577844">next</a><span>|</span><label class="collapse" for="c-42579121">[-]</label><label class="expand" for="c-42579121">[1 more]</label></div><br/><div class="children"><div class="content">UUIDv7 interoperates with all the other versions of UUID. The v7 support in Postgres doesn&#x27;t add a new column type, it makes the existing column type more powerful&#x2F;capable. Applications that had been using UUIDv4 everywhere can get cheap Snowflake-like benefits in existing code just from switching the generator function. Most languages have a GUID or UUID class&#x2F;struct that is compatibly upgradable from v4 to v7, too.</div><br/></div></div></div></div><div id="42577844" class="c"><input type="checkbox" id="c-42577844" checked=""/><div class="controls bullet"><span class="by">Glyptodon</span><span>|</span><a href="#42576359">prev</a><span>|</span><a href="#42577882">next</a><span>|</span><label class="collapse" for="c-42577844">[-]</label><label class="expand" for="c-42577844">[1 more]</label></div><br/><div class="children"><div class="content">On one hand I too am looking forward to more widespread use of UUIDv7, but on the other I don&#x27;t really get the problem this is solving for their spec. If you care about timestamp ordering I don&#x27;t think doing it in a way that forces you to fake a PK if you insert an earlier dated record at a future point makes sense. But I guess I&#x27;m implicitly assuming that human meaningful dates differ from insertion times in many domains.</div><br/></div></div><div id="42577882" class="c"><input type="checkbox" id="c-42577882" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42577844">prev</a><span>|</span><a href="#42576256">next</a><span>|</span><label class="collapse" for="c-42577882">[-]</label><label class="expand" for="c-42577882">[6 more]</label></div><br/><div class="children"><div class="content">I maintain that people are too eager to use UUIDv7 to begin with.  It&#x27;s a dessert topping and a floor wax.<p>Let&#x27;s say you need an opaque unique handle, and a timestamp, and a monotonically increasing row ID.  Common enough.  Do they have to be the same thing? <i>Should</i> they be the same thing?  Because to me that sounds like three things: an autoincrementing primary key, a UUIDv4, and a nanosecond timestamp.<p>Is it always ok that the &#x27;opaque&#x27; unique ID isn&#x27;t opaque at all, that it&#x27;s carrying around a timestamp?  Will that allow correlating things which maybe you didn&#x27;t want hostiles to correlate?  Are you 100% sure that you&#x27;ll never want, or need, to re-timestamp data without changing its global ID?<p>Maybe you do need these things unnormalized and conflated.  Do you though?  At least ask the question.</div><br/><div id="42581841" class="c"><input type="checkbox" id="c-42581841" checked=""/><div class="controls bullet"><span class="by">peferron</span><span>|</span><a href="#42577882">parent</a><span>|</span><a href="#42581078">next</a><span>|</span><label class="collapse" for="c-42581841">[-]</label><label class="expand" for="c-42581841">[1 more]</label></div><br/><div class="children"><div class="content">You can keep all three and still use UUIDv7 as a performance improvement in certain contexts due to data locality.</div><br/></div></div><div id="42581078" class="c"><input type="checkbox" id="c-42581078" checked=""/><div class="controls bullet"><span class="by">fastball</span><span>|</span><a href="#42577882">parent</a><span>|</span><a href="#42581841">prev</a><span>|</span><a href="#42579206">next</a><span>|</span><label class="collapse" for="c-42581078">[-]</label><label class="expand" for="c-42581078">[3 more]</label></div><br/><div class="children"><div class="content">Also if you have a nanosecond timestamp, do you actually need a monotonically increasing row ID? What for?</div><br/><div id="42581967" class="c"><input type="checkbox" id="c-42581967" checked=""/><div class="controls bullet"><span class="by">peferron</span><span>|</span><a href="#42577882">root</a><span>|</span><a href="#42581078">parent</a><span>|</span><a href="#42579206">next</a><span>|</span><label class="collapse" for="c-42581967">[-]</label><label class="expand" for="c-42581967">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps as a tie breaker if you insert multiple rows in a table within one transaction? In this situation, the timestamp returned by e.g. `now()` refers to the start of the transaction, which can cause it to be reused multiple times.</div><br/><div id="42582590" class="c"><input type="checkbox" id="c-42582590" checked=""/><div class="controls bullet"><span class="by">fastball</span><span>|</span><a href="#42577882">root</a><span>|</span><a href="#42581967">parent</a><span>|</span><a href="#42579206">next</a><span>|</span><label class="collapse" for="c-42582590">[-]</label><label class="expand" for="c-42582590">[1 more]</label></div><br/><div class="children"><div class="content">I meant in a context with a random ID and a timestamp.<p>If you need to retrieve rows by time&#x2F;order, you use the timestamp. If you need a row by ID, you use the ID.<p>The use-cases where you actually need to know which row was inserted first seem exceedingly rare (mostly financial &#x2F; auditing applications), and even then can probably be handled with separate transactions (as you touch on).</div><br/></div></div></div></div></div></div><div id="42579206" class="c"><input type="checkbox" id="c-42579206" checked=""/><div class="controls bullet"><span class="by">user3939382</span><span>|</span><a href="#42577882">parent</a><span>|</span><a href="#42581078">prev</a><span>|</span><a href="#42576256">next</a><span>|</span><label class="collapse" for="c-42579206">[-]</label><label class="expand" for="c-42579206">[1 more]</label></div><br/><div class="children"><div class="content">Re-timestamp would be a new one for me. What’s a conceivable use case? An NTP fault?</div><br/></div></div></div></div><div id="42578052" class="c"><input type="checkbox" id="c-42578052" checked=""/><div class="controls bullet"><span class="by">scrollaway</span><span>|</span><a href="#42576256">prev</a><span>|</span><a href="#42580089">next</a><span>|</span><label class="collapse" for="c-42578052">[-]</label><label class="expand" for="c-42578052">[1 more]</label></div><br/><div class="children"><div class="content">UUID7 is excellent.<p>I want to share a django library I wrote a little while back which allows for prefixed identity fields, in the same style as Stripe&#x27;s ID fields (obj_XXXXXXXXX):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jleclanche&#x2F;django-prefixed-identity-field&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;jleclanche&#x2F;django-prefixed-identity-field...</a><p>This gives a PrefixedIdentityField(prefix=&quot;obj_&quot;), which is backed by uuid7 and base58. In the database, the IDs are stored as UUIDs, which makes them an efficient field -- they are transformed into prefixed IDs when coming out of the database, which makes them perfect for APIs.<p>(I know, no documentation .. if someone wants to use this, feel free to file issues to ask questions, I&#x27;d love to help)</div><br/></div></div><div id="42580089" class="c"><input type="checkbox" id="c-42580089" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#42578052">prev</a><span>|</span><a href="#42576697">next</a><span>|</span><label class="collapse" for="c-42580089">[-]</label><label class="expand" for="c-42580089">[1 more]</label></div><br/><div class="children"><div class="content">This post makes me think (keep thinking) if we can use a solution that I used for another project in another context: using a Cryptographic Feistel Network to compute UUIDS so they are reversible if you need to know the original order. Each entity uses another key for the generation but if they know the keys they can know the order of the other party. Basically is using an existing cryptographic function if the block size is the same and if not adaping it to a specific block size via a Feistel Network.</div><br/></div></div><div id="42576697" class="c"><input type="checkbox" id="c-42576697" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#42580089">prev</a><span>|</span><a href="#42576202">next</a><span>|</span><label class="collapse" for="c-42576697">[-]</label><label class="expand" for="c-42576697">[1 more]</label></div><br/><div class="children"><div class="content">The naming of &quot;rand_a&quot; and &quot;rand_b&quot; in the spec is a bit misleading. They don&#x27;t have to be generated randomly. I&#x27;m sure there&#x27;s a historical reason for it.<p>&quot;extra_&quot; or &quot;distinct_&quot; would be a more accurate prefix for UUIDv7.<p>UUIDv7 is actually quite a flexible standard due to these two underspecified fields. I&#x27;m glad Postgres took advantage of that!</div><br/></div></div><div id="42576069" class="c"><input type="checkbox" id="c-42576069" checked=""/><div class="controls bullet"><span class="by">urronglol</span><span>|</span><a href="#42576202">prev</a><span>|</span><label class="collapse" for="c-42576069">[-]</label><label class="expand" for="c-42576069">[15 more]</label></div><br/><div class="children"><div class="content">What is a v7 UUID. Why do we need more than 1. uuid from a random seed and 2. one derived from that and a timestamp (orderable)</div><br/><div id="42576085" class="c"><input type="checkbox" id="c-42576085" checked=""/><div class="controls bullet"><span class="by">cube2222</span><span>|</span><a href="#42576069">parent</a><span>|</span><a href="#42576193">next</a><span>|</span><label class="collapse" for="c-42576085">[-]</label><label class="expand" for="c-42576085">[1 more]</label></div><br/><div class="children"><div class="content">UUID v7 is what you numbered #2.<p>For the others, it’s best to read up on Wikipedia[0]. I believe they all have their unique use-cases and tradeoffs.<p>E.g. including information about which node of the system generated an ID.<p>[0]: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Universally_unique_identifier" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Universally_unique_identifie...</a></div><br/></div></div><div id="42576193" class="c"><input type="checkbox" id="c-42576193" checked=""/><div class="controls bullet"><span class="by">chimpontherun</span><span>|</span><a href="#42576069">parent</a><span>|</span><a href="#42576085">prev</a><span>|</span><a href="#42576084">next</a><span>|</span><label class="collapse" for="c-42576193">[-]</label><label class="expand" for="c-42576193">[1 more]</label></div><br/><div class="children"><div class="content">As it is usual in many areas of human endeavor, newcomers to the field tend to criticize design decisions that were made before them, only to re-invent what was already invented.<p>Sometimes it leads to improvements in the field, via rejection of the accumulated legacy crud, or just simply affording a new perspective.  Most other times it&#x27;s a well-intentioned, but low-effort noise.<p>I, personally, do it myself.  This is how I learn.</div><br/></div></div><div id="42576084" class="c"><input type="checkbox" id="c-42576084" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#42576069">parent</a><span>|</span><a href="#42576193">prev</a><span>|</span><a href="#42576155">next</a><span>|</span><label class="collapse" for="c-42576084">[-]</label><label class="expand" for="c-42576084">[3 more]</label></div><br/><div class="children"><div class="content">UUID v7 is the latter, whereas v4 is the former.<p>All the other versions are somewhat legacy, and you shouldn&#x27;t use them in new systems (besides v8, which is &quot;custom format UUID&quot;, if you need that.)</div><br/><div id="42576174" class="c"><input type="checkbox" id="c-42576174" checked=""/><div class="controls bullet"><span class="by">elehack</span><span>|</span><a href="#42576069">root</a><span>|</span><a href="#42576084">parent</a><span>|</span><a href="#42576155">next</a><span>|</span><label class="collapse" for="c-42576174">[-]</label><label class="expand" for="c-42576174">[2 more]</label></div><br/><div class="children"><div class="content">UUID v5 is quite useful if you want to deterministically convert external identifiers into UUIDS — define a namespace UUID for each potential identifier source (to keep them separate), then use that to derive a V5 UUID from the external identifier.  It&#x27;s very useful for idempotent data imports.</div><br/><div id="42577132" class="c"><input type="checkbox" id="c-42577132" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#42576069">root</a><span>|</span><a href="#42576174">parent</a><span>|</span><a href="#42576155">next</a><span>|</span><label class="collapse" for="c-42577132">[-]</label><label class="expand" for="c-42577132">[1 more]</label></div><br/><div class="children"><div class="content">Both UUIDv3 and UUIDv5 are prohibited for some use cases in some countries (including the US), which is something to be aware of. Unfortunately, no one has created an updated standard UUID that uses a hash function that is not broken. While useful it is not always an option.</div><br/></div></div></div></div></div></div><div id="42576155" class="c"><input type="checkbox" id="c-42576155" checked=""/><div class="controls bullet"><span class="by">mind-blight</span><span>|</span><a href="#42576069">parent</a><span>|</span><a href="#42576084">prev</a><span>|</span><a href="#42576274">next</a><span>|</span><label class="collapse" for="c-42576155">[-]</label><label class="expand" for="c-42576155">[1 more]</label></div><br/><div class="children"><div class="content">A deterministic uuid based off of a hash of bits is also very useful (UUID5). I&#x27;ve used that for deduping records from multiple sources</div><br/></div></div></div></div></div></div></div></div></div></body></html>