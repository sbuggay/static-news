<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692694862317" as="style"/><link rel="stylesheet" href="styles.css?v=1692694862317"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ergomake/layerform/blob/main/blog/terraform-states.md">Manipulating Terraform states for fun, profit, and reusability</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>lucasfcosta</span> | <span>9 comments</span></div><br/><div><div id="37220217" class="c"><input type="checkbox" id="c-37220217" checked=""/><div class="controls bullet"><span class="by">confiq</span><span>|</span><a href="#37219653">next</a><span>|</span><label class="collapse" for="c-37220217">[-]</label><label class="expand" for="c-37220217">[1 more]</label></div><br/><div class="children"><div class="content">hmm, we did something similar using workspaces in terraform. If I would know about this before I might reevaluate it.<p>It would be cool if we could transfer from workspaces to layerform</div><br/></div></div><div id="37219653" class="c"><input type="checkbox" id="c-37219653" checked=""/><div class="controls bullet"><span class="by">danw1979</span><span>|</span><a href="#37220217">prev</a><span>|</span><a href="#37219827">next</a><span>|</span><label class="collapse" for="c-37219653">[-]</label><label class="expand" for="c-37219653">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You could also try using the count and for_each meta-arguments, but there&#x27;s only so much you can do until complexity hits you in the head. And let&#x27;s be honest, if something is called a &quot;meta-argument&quot;, it&#x27;s probably not a good idea.<p>Let’s actually be honest: here’s the workable solution -built into the language- to the problem you’re describing and you’re waving it away to justify whatever hack it is we’re about to be presented with.</div><br/><div id="37219698" class="c"><input type="checkbox" id="c-37219698" checked=""/><div class="controls bullet"><span class="by">danw1979</span><span>|</span><a href="#37219653">parent</a><span>|</span><a href="#37219827">next</a><span>|</span><label class="collapse" for="c-37219698">[-]</label><label class="expand" for="c-37219698">[1 more]</label></div><br/><div class="children"><div class="content">It gets worse…<p>&gt; Besides the practical advantages of not having to modify .tf files every time someone needs a new bucket, this approach also completely detaches the concept of a desired state with the concept of an actual state.<p>Yeah, who wanted their infrastructure in version control anyway.<p>But seriously, if you want a new bucket without _all the hassle_ of using Terraform, just use the CDK or maybe even a CLI one-liner ?</div><br/></div></div></div></div><div id="37219827" class="c"><input type="checkbox" id="c-37219827" checked=""/><div class="controls bullet"><span class="by">mnahkies</span><span>|</span><a href="#37219653">prev</a><span>|</span><a href="#37219703">next</a><span>|</span><label class="collapse" for="c-37219827">[-]</label><label class="expand" for="c-37219827">[1 more]</label></div><br/><div class="children"><div class="content">This feels brittle to me. I&#x27;d stick to creating layers by having separate root modules with their own state files (eg: in the example you could have a kubernetes root module that was shared across developers, and a buckets root module for the S3 buckets)<p>You&#x27;d then typically have multiple state files per root module applied with different tfvars to create multiple copies of the same infrastructure (eg: dev&#x2F;stage&#x2F;prod). Workspaces can help with this, especially when using terraform cloud.<p>As other comments have mentioned you can use outputs to share data between state modules, and to make this nicer you can wrap the remote state blocks in a module generated from the outputs so that you can get intelisense&#x2F;autocomplete (though it&#x27;s a bit annoying that you can&#x27;t plan speculatively across state files where output changes are involved)<p>This page goes into a bit more detail about separating components of your infrastructure into discrete state files and talks about when (terraform cli) workspaces may or may not be appropriate <a href="https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;cli&#x2F;workspaces" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.hashicorp.com&#x2F;terraform&#x2F;cli&#x2F;workspaces</a><p>In terms of creating the buckets per developer - I think there&#x27;s a bigger question of do they need a bucket each or some larger subset of the infrastructure and this should guide how you organise things. It&#x27;ll need to tie into your strategy around production infrastructure (eg: single Vs multi tenancy, and how you want to manage deploying to different regions).<p>An aside, but I&#x27;d probably argue that for development purposes sharing a bucket but having your applications accept a bucket prefix (giving each developer a namespace of sorts) in addition to a bucket name is simpler, and lends itself to quicker ephemeral deployments that avoid the need to change underlying infrastructure</div><br/></div></div><div id="37219703" class="c"><input type="checkbox" id="c-37219703" checked=""/><div class="controls bullet"><span class="by">cellarmation</span><span>|</span><a href="#37219827">prev</a><span>|</span><a href="#37219367">next</a><span>|</span><label class="collapse" for="c-37219703">[-]</label><label class="expand" for="c-37219703">[1 more]</label></div><br/><div class="children"><div class="content">This is a really nice write up and a clear explanation of a real organisational problem with terraform. This seems more like a design pattern to me though, I dont quite see the need for a specific tool?<p>Terraform has the ability to work with remote tfstate files, reference resources in other tfstate files via terraform_remote_state and unique instances can be labelled via a tfvar ID as a pre&#x2F;post fix. Is this a polished wrapper around those mechanisms, or is there more going on as well?</div><br/></div></div><div id="37219367" class="c"><input type="checkbox" id="c-37219367" checked=""/><div class="controls bullet"><span class="by">dygd</span><span>|</span><a href="#37219703">prev</a><span>|</span><a href="#37219763">next</a><span>|</span><label class="collapse" for="c-37219367">[-]</label><label class="expand" for="c-37219367">[2 more]</label></div><br/><div class="children"><div class="content">A minor thing, but the article says that the Terraform AWS provider uses AWS CLI to manage resources. That&#x27;s not the case, it uses aws-go-sdk to directly talk to the AWS APIs.</div><br/></div></div></div></div></div></div></div></body></html>