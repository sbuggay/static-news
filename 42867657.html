<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738227667500" as="style"/><link rel="stylesheet" href="styles.css?v=1738227667500"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.instantdb.com/essays/pg_upgrade">A major Postgres upgrade with zero downtime</a> <span class="domain">(<a href="https://www.instantdb.com">www.instantdb.com</a>)</span></div><div class="subtext"><span>stopachka</span> | <span>50 comments</span></div><br/><div><div id="42871912" class="c"><input type="checkbox" id="c-42871912" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42871836">next</a><span>|</span><label class="collapse" for="c-42871912">[-]</label><label class="expand" for="c-42871912">[2 more]</label></div><br/><div class="children"><div class="content">This is impressive!  I know others are questioning the &quot;no downtime&quot; bit, but that is why service level objectives exist -- because it really depends on the customer experience.<p>If you managed to have a cutover with no noticeable dip in business metrics (aka the users didn&#x27;t notice) then I&#x27;d call that a no-downtime upgrade!<p>Very clever on the improvement over Lyft&#x27;s methods.  Thanks for the writeup.  Now maybe someone can get it down from 3 seconds of pausing. :)</div><br/><div id="42873435" class="c"><input type="checkbox" id="c-42873435" checked=""/><div class="controls bullet"><span class="by">honestSysAdmin</span><span>|</span><a href="#42871912">parent</a><span>|</span><a href="#42871836">next</a><span>|</span><label class="collapse" for="c-42873435">[-]</label><label class="expand" for="c-42873435">[1 more]</label></div><br/><div class="children"><div class="content">&gt; then I&#x27;d call that a no-downtime upgrade!<p>It&#x27;d be really convenient for me, well not me but others, if we could tell our customers this. However, those of us running DBaaS do have to offer an actual no-downtime upgrade.</div><br/></div></div></div></div><div id="42871836" class="c"><input type="checkbox" id="c-42871836" checked=""/><div class="controls bullet"><span class="by">darth_avocado</span><span>|</span><a href="#42871912">prev</a><span>|</span><a href="#42871909">next</a><span>|</span><label class="collapse" for="c-42871836">[-]</label><label class="expand" for="c-42871836">[5 more]</label></div><br/><div class="children"><div class="content">Pause all writes &gt; let 16 to catch up &gt; resume writes on 16<p>Isn’t that….. downtime? Unless you mean downtime to be only when reads are also not available.</div><br/><div id="42871935" class="c"><input type="checkbox" id="c-42871935" checked=""/><div class="controls bullet"><span class="by">stopachka</span><span>|</span><a href="#42871836">parent</a><span>|</span><a href="#42871909">next</a><span>|</span><label class="collapse" for="c-42871935">[-]</label><label class="expand" for="c-42871935">[4 more]</label></div><br/><div class="children"><div class="content">We count downtime if a service is unavailable and drops requests. In this case, since the pause took about 3.5 seconds, we were able to service all requests.</div><br/><div id="42874131" class="c"><input type="checkbox" id="c-42874131" checked=""/><div class="controls bullet"><span class="by">darth_avocado</span><span>|</span><a href="#42871836">root</a><span>|</span><a href="#42871935">parent</a><span>|</span><a href="#42873552">next</a><span>|</span><label class="collapse" for="c-42874131">[-]</label><label class="expand" for="c-42874131">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. If that was the case, I’m curious why you had to write custom code. Would RDS proxy not work?<p>The way we usually upgrade is create a new upgraded cluster, replicate all data to new cluster, pause writes and redirect RDS proxy to the new cluster. And that usually takes a few seconds.</div><br/></div></div><div id="42873552" class="c"><input type="checkbox" id="c-42873552" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42871836">root</a><span>|</span><a href="#42871935">parent</a><span>|</span><a href="#42874131">prev</a><span>|</span><a href="#42871909">next</a><span>|</span><label class="collapse" for="c-42873552">[-]</label><label class="expand" for="c-42873552">[2 more]</label></div><br/><div class="children"><div class="content">By that definition you can have any length pause and still claim zero downtime.</div><br/><div id="42873994" class="c"><input type="checkbox" id="c-42873994" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#42871836">root</a><span>|</span><a href="#42873552">parent</a><span>|</span><a href="#42871909">next</a><span>|</span><label class="collapse" for="c-42873994">[-]</label><label class="expand" for="c-42873994">[1 more]</label></div><br/><div class="children"><div class="content">Only if nothing has timeouts. Likely components somewhere in the stack have timeouts so you&#x27;re bound by that</div><br/></div></div></div></div></div></div></div></div><div id="42871909" class="c"><input type="checkbox" id="c-42871909" checked=""/><div class="controls bullet"><span class="by">honestSysAdmin</span><span>|</span><a href="#42871836">prev</a><span>|</span><a href="#42874999">next</a><span>|</span><label class="collapse" for="c-42871909">[-]</label><label class="expand" for="c-42871909">[5 more]</label></div><br/><div class="children"><div class="content">Zero-downtime Postgres upgrades have been kind of normalized, at least in the environments I have been exposed to, with pgcat<p><pre><code>  https:&#x2F;&#x2F;github.com&#x2F;postgresml&#x2F;pgcat</code></pre></div><br/><div id="42874659" class="c"><input type="checkbox" id="c-42874659" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42871909">parent</a><span>|</span><a href="#42871989">next</a><span>|</span><label class="collapse" for="c-42874659">[-]</label><label class="expand" for="c-42874659">[1 more]</label></div><br/><div class="children"><div class="content">Indenting with 2 spaces is for code formatting, which is why the URL isn&#x27;t a link.  Don&#x27;t indent it if you want a link:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;postgresml&#x2F;pgcat">https:&#x2F;&#x2F;github.com&#x2F;postgresml&#x2F;pgcat</a></div><br/></div></div><div id="42871989" class="c"><input type="checkbox" id="c-42871989" checked=""/><div class="controls bullet"><span class="by">stopachka</span><span>|</span><a href="#42871909">parent</a><span>|</span><a href="#42874659">prev</a><span>|</span><a href="#42872597">next</a><span>|</span><label class="collapse" for="c-42871989">[-]</label><label class="expand" for="c-42871989">[2 more]</label></div><br/><div class="children"><div class="content">Is there some resource that explains how to do a major version upgrade with pgcat? Would love to take a look</div><br/><div id="42872111" class="c"><input type="checkbox" id="c-42872111" checked=""/><div class="controls bullet"><span class="by">honestSysAdmin</span><span>|</span><a href="#42871909">root</a><span>|</span><a href="#42871989">parent</a><span>|</span><a href="#42872597">next</a><span>|</span><label class="collapse" for="c-42872111">[-]</label><label class="expand" for="c-42872111">[1 more]</label></div><br/><div class="children"><div class="content">As far as I know, there is not. I could probably write something up.</div><br/></div></div></div></div><div id="42872597" class="c"><input type="checkbox" id="c-42872597" checked=""/><div class="controls bullet"><span class="by">wswope</span><span>|</span><a href="#42871909">parent</a><span>|</span><a href="#42871989">prev</a><span>|</span><a href="#42874999">next</a><span>|</span><label class="collapse" for="c-42872597">[-]</label><label class="expand" for="c-42872597">[1 more]</label></div><br/><div class="children"><div class="content">This is really cool&#x2F;useful to know about - thanks for dropping the link!</div><br/></div></div></div></div><div id="42874999" class="c"><input type="checkbox" id="c-42874999" checked=""/><div class="controls bullet"><span class="by">n_u</span><span>|</span><a href="#42871909">prev</a><span>|</span><a href="#42871057">next</a><span>|</span><label class="collapse" for="c-42874999">[-]</label><label class="expand" for="c-42874999">[2 more]</label></div><br/><div class="children"><div class="content">They say the &quot;stop the world&quot; approach that causes more downtime is<p><pre><code>  Turn off all writes.
  Wait for 16 to catch up
  Enable writes again — this time they all go to 16
</code></pre>
and instead they used a better algorithm:<p><pre><code>  Pause all writes.
  Wait for 16 to catch up. 
  Resume writes on 16.
</code></pre>
These seem pretty similar.<p>1. What is the difference in the algorithm? Is it just that in the &quot;stop the world&quot; approach the client sees their txns fail until &quot;wait for 16 to catch up&quot; is done? Whereas in the latter approach the client never sees their txns fail, they just have a bit more latency?<p>2. Why does the second approach result in less downtime?</div><br/><div id="42875356" class="c"><input type="checkbox" id="c-42875356" checked=""/><div class="controls bullet"><span class="by">stopachka</span><span>|</span><a href="#42874999">parent</a><span>|</span><a href="#42871057">next</a><span>|</span><label class="collapse" for="c-42875356">[-]</label><label class="expand" for="c-42875356">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in the &quot;stop the world&quot; approach the client sees their txns fail until &quot;wait for 16 to catch up&quot; is done? Whereas in the latter approach the client never sees their txns fail, they just have a bit more latency?<p>Yes, this is the main difference. For &quot;stop the world&quot;, we imagined a simpler algorithm: instead of a script, we could manually toggle a switch for example.<p>However, by writing the script, the user only experiences a bit more latency, rather than failed transactions.</div><br/></div></div></div></div><div id="42871057" class="c"><input type="checkbox" id="c-42871057" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#42874999">prev</a><span>|</span><a href="#42871882">next</a><span>|</span><label class="collapse" for="c-42871057">[-]</label><label class="expand" for="c-42871057">[22 more]</label></div><br/><div class="children"><div class="content">The title is pretty misleading. They&#x27;re not even running Postgres, but AWS Aurora, which is Postgres compatible, but is not Postgres.<p>Also, pausing queries does count as downtime. The system was unavailable for that period of time.</div><br/><div id="42871127" class="c"><input type="checkbox" id="c-42871127" checked=""/><div class="controls bullet"><span class="by">stopachka</span><span>|</span><a href="#42871057">parent</a><span>|</span><a href="#42871997">next</a><span>|</span><label class="collapse" for="c-42871127">[-]</label><label class="expand" for="c-42871127">[13 more]</label></div><br/><div class="children"><div class="content">&gt; The title is pretty misleading. They&#x27;re not even running Postgres, but AWS Aurora, which is Postgres compatible, but is not Postgres.<p>For what it&#x27;s worth, every command ran works on normal Postgres. Hence we didn&#x27;t think it mattered to mention Aurora specifically in the title.<p>&gt; Also, pausing queries does count as downtime.<p>If a query takes a bit longer to respond, I don&#x27;t think that counts as downtime. From the perspective of the user, they couldn&#x27;t distinguish this migration event from some blip of slightly slower queries.</div><br/><div id="42872034" class="c"><input type="checkbox" id="c-42872034" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871127">parent</a><span>|</span><a href="#42871566">next</a><span>|</span><label class="collapse" for="c-42872034">[-]</label><label class="expand" for="c-42872034">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If a query takes a bit longer to respond, I don&#x27;t think that counts as downtime. From the perspective of the user, they couldn&#x27;t distinguish this migration event from some blip of slightly slower queries.<p>It comes down to defining Service Level Objectives (SLOs) that are meaningful to your users. For one system I worked on, latency was important, and so one SLO was &quot;99.999% of &lt;a certain class of&gt; requests with a deadline &gt;=1s should succeed with latency &lt;1s&quot;, so if this affected more than 0.0001% of requests in &lt;time interval defined in our SLO&gt;, we&#x27;d have called it an outage. But I&#x27;ve also worked on systems with looser SLOs where this would have been fine.</div><br/><div id="42872127" class="c"><input type="checkbox" id="c-42872127" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42872034">parent</a><span>|</span><a href="#42871566">next</a><span>|</span><label class="collapse" for="c-42872127">[-]</label><label class="expand" for="c-42872127">[1 more]</label></div><br/><div class="children"><div class="content">Not only that but I think you also need to take upstream systems into account. With a reasonably robust frontend that handles transient issues and retries reasonably, I think it&#x27;s ok to say &quot;no downtime&quot;</div><br/></div></div></div></div><div id="42871566" class="c"><input type="checkbox" id="c-42871566" checked=""/><div class="controls bullet"><span class="by">RadiozRadioz</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871127">parent</a><span>|</span><a href="#42872034">prev</a><span>|</span><a href="#42871267">next</a><span>|</span><label class="collapse" for="c-42871566">[-]</label><label class="expand" for="c-42871566">[1 more]</label></div><br/><div class="children"><div class="content">Completely depends on what the &quot;user&quot; is. Are they a human, or a machine that explicitly requires timings within a particular threshold?</div><br/></div></div><div id="42871267" class="c"><input type="checkbox" id="c-42871267" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871127">parent</a><span>|</span><a href="#42871566">prev</a><span>|</span><a href="#42871431">next</a><span>|</span><label class="collapse" for="c-42871267">[-]</label><label class="expand" for="c-42871267">[1 more]</label></div><br/><div class="children"><div class="content">It depends if it feels like an outage</div><br/></div></div><div id="42871431" class="c"><input type="checkbox" id="c-42871431" checked=""/><div class="controls bullet"><span class="by">awesome_dude</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871127">parent</a><span>|</span><a href="#42871267">prev</a><span>|</span><a href="#42871997">next</a><span>|</span><label class="collapse" for="c-42871431">[-]</label><label class="expand" for="c-42871431">[8 more]</label></div><br/><div class="children"><div class="content">&gt; If a query takes a bit longer to respond, I don&#x27;t think that counts as downtime<p>&quot;We&#x27;re sorry that your query took 7 hours to be responded to, but it wasn&#x27;t an outage - honest&quot;</div><br/><div id="42871656" class="c"><input type="checkbox" id="c-42871656" checked=""/><div class="controls bullet"><span class="by">stopachka</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871431">parent</a><span>|</span><a href="#42872478">next</a><span>|</span><label class="collapse" for="c-42871656">[-]</label><label class="expand" for="c-42871656">[5 more]</label></div><br/><div class="children"><div class="content">We would count 7 hours as downtime too. Our pause was less than 5 seconds.</div><br/><div id="42871950" class="c"><input type="checkbox" id="c-42871950" checked=""/><div class="controls bullet"><span class="by">libraryofbabel</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871656">parent</a><span>|</span><a href="#42871718">next</a><span>|</span><label class="collapse" for="c-42871950">[-]</label><label class="expand" for="c-42871950">[2 more]</label></div><br/><div class="children"><div class="content">Nice job, then! Technical downtime that’s virtually undetectable to users is a big win. In fact, “less than 5 seconds of downtime” in the title would actually make me want to read the article more as I tend to be suspicious of “zero downtime” claims for database upgrades, whereas &lt;5s is clearly almost as good as zero and actually quantified :)</div><br/><div id="42872150" class="c"><input type="checkbox" id="c-42872150" checked=""/><div class="controls bullet"><span class="by">awesome_dude</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871950">parent</a><span>|</span><a href="#42871718">next</a><span>|</span><label class="collapse" for="c-42872150">[-]</label><label class="expand" for="c-42872150">[1 more]</label></div><br/><div class="children"><div class="content">Yeah - a quantifiable amount in the headline would change the likelihood of the article being taken seriously - it goes from &quot;No downtime? I call BS&quot; to &quot;Less than 5 seconds, that seems reasonable, and worth investigating&quot;</div><br/></div></div></div></div><div id="42871718" class="c"><input type="checkbox" id="c-42871718" checked=""/><div class="controls bullet"><span class="by">ElijahLynn</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871656">parent</a><span>|</span><a href="#42871950">prev</a><span>|</span><a href="#42871851">next</a><span>|</span><label class="collapse" for="c-42871718">[-]</label><label class="expand" for="c-42871718">[1 more]</label></div><br/><div class="children"><div class="content">Less than 5 seconds seems pretty reasonable to me to call it zero down time.</div><br/></div></div><div id="42871851" class="c"><input type="checkbox" id="c-42871851" checked=""/><div class="controls bullet"><span class="by">tossandthrow</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871656">parent</a><span>|</span><a href="#42871718">prev</a><span>|</span><a href="#42872478">next</a><span>|</span><label class="collapse" for="c-42871851">[-]</label><label class="expand" for="c-42871851">[1 more]</label></div><br/><div class="children"><div class="content">5 seconds pause on queries would make our app server drop connections and throw errors under cyclical high load - which would result in a incident.</div><br/></div></div></div></div><div id="42872478" class="c"><input type="checkbox" id="c-42872478" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871431">parent</a><span>|</span><a href="#42871656">prev</a><span>|</span><a href="#42871997">next</a><span>|</span><label class="collapse" for="c-42872478">[-]</label><label class="expand" for="c-42872478">[2 more]</label></div><br/><div class="children"><div class="content">Strong energy of &quot;someone brushed up against me and that&#x27;s assault&quot; going on here</div><br/></div></div></div></div></div></div><div id="42871997" class="c"><input type="checkbox" id="c-42871997" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#42871057">parent</a><span>|</span><a href="#42871127">prev</a><span>|</span><a href="#42871517">next</a><span>|</span><label class="collapse" for="c-42871997">[-]</label><label class="expand" for="c-42871997">[3 more]</label></div><br/><div class="children"><div class="content">AWS Aurora Postgres is a forked Postgres with a different storage engine. Sure you are technically correct, but there are many things called &quot;Postgres compatible&quot; that are very much less Postgres that AWS Aurora Postgres (like for example CockroachDB).</div><br/><div id="42872098" class="c"><input type="checkbox" id="c-42872098" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871997">parent</a><span>|</span><a href="#42871517">next</a><span>|</span><label class="collapse" for="c-42872098">[-]</label><label class="expand" for="c-42872098">[2 more]</label></div><br/><div class="children"><div class="content">Iirc AWS explicitly calls out they still use upstream Postgres query engine and some other parts. It very much _is_ Postgres but not 100% pure upstream Postgres.</div><br/><div id="42872249" class="c"><input type="checkbox" id="c-42872249" checked=""/><div class="controls bullet"><span class="by">SahAssar</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42872098">parent</a><span>|</span><a href="#42871517">next</a><span>|</span><label class="collapse" for="c-42872249">[-]</label><label class="expand" for="c-42872249">[1 more]</label></div><br/><div class="children"><div class="content">Yep, for example that is how they advertise protocol, feature and language compatibility.</div><br/></div></div></div></div></div></div><div id="42871517" class="c"><input type="checkbox" id="c-42871517" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42871057">parent</a><span>|</span><a href="#42871997">prev</a><span>|</span><a href="#42871669">next</a><span>|</span><label class="collapse" for="c-42871517">[-]</label><label class="expand" for="c-42871517">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They&#x27;re not even running Postgres, but AWS Aurora<p>But everything described is also PostgreSQL compatible.<p>&gt; downtime<p>Context switching pauses execution too FYI.</div><br/></div></div><div id="42871669" class="c"><input type="checkbox" id="c-42871669" checked=""/><div class="controls bullet"><span class="by">unethical_ban</span><span>|</span><a href="#42871057">parent</a><span>|</span><a href="#42871517">prev</a><span>|</span><a href="#42871882">next</a><span>|</span><label class="collapse" for="c-42871669">[-]</label><label class="expand" for="c-42871669">[4 more]</label></div><br/><div class="children"><div class="content">They reduced their potential downtime from 60s to what I assume is only a few seconds (they don&#x27;t state in the article).<p>If there is not noticeable user impact or unavailability of services (this is unique to each service in existence) then there is no downtime.</div><br/><div id="42871808" class="c"><input type="checkbox" id="c-42871808" checked=""/><div class="controls bullet"><span class="by">stopachka</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871669">parent</a><span>|</span><a href="#42871882">next</a><span>|</span><label class="collapse" for="c-42871808">[-]</label><label class="expand" for="c-42871808">[3 more]</label></div><br/><div class="children"><div class="content">&gt; they don&#x27;t state in the article<p>Thank you for pointing this out. I updated the essay to mention how long the pause took explicitly:<p>After about a 3.5 second pause [^13], the failover function completed smoothly! We had a new Postgres instance serving requests, and best of all, nobody noticed.<p>[^13]: About 2.5 seconds to let active queries complete, and about 1 second for the replica to catch up</div><br/><div id="42874284" class="c"><input type="checkbox" id="c-42874284" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42871808">parent</a><span>|</span><a href="#42871882">next</a><span>|</span><label class="collapse" for="c-42874284">[-]</label><label class="expand" for="c-42874284">[2 more]</label></div><br/><div class="children"><div class="content">What is the <i>[^13]</i> notation?  Is it different than a *?</div><br/><div id="42874738" class="c"><input type="checkbox" id="c-42874738" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42871057">root</a><span>|</span><a href="#42874284">parent</a><span>|</span><a href="#42871882">next</a><span>|</span><label class="collapse" for="c-42874738">[-]</label><label class="expand" for="c-42874738">[1 more]</label></div><br/><div class="children"><div class="content">They copy&#x2F;pasted from the article, that&#x27;s how they&#x27;re formatting footnote links.  Article has 15 footnotes and that&#x27;s number 13.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42871882" class="c"><input type="checkbox" id="c-42871882" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42871057">prev</a><span>|</span><a href="#42873907">next</a><span>|</span><label class="collapse" for="c-42871882">[-]</label><label class="expand" for="c-42871882">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t believe they took the time to make such an amazing write-up. With formatting and everything. Normally I just grab whatever broken crayon is closest and scribble on the back of an overdue bill &quot;don&#x27;t fsck up next time&quot;</div><br/></div></div><div id="42873907" class="c"><input type="checkbox" id="c-42873907" checked=""/><div class="controls bullet"><span class="by">wenbin</span><span>|</span><a href="#42871882">prev</a><span>|</span><a href="#42873065">next</a><span>|</span><label class="collapse" for="c-42873907">[-]</label><label class="expand" for="c-42873907">[1 more]</label></div><br/><div class="children"><div class="content">Awesome!<p>The best we’ve achieved is 0 downtime for read operations and less than 1 minute downtime for write ops [1]<p>Achieving 0 downtime for write ops is super hard!<p>[1] <a href="https:&#x2F;&#x2F;www.listennotes.com&#x2F;blog&#x2F;a-practical-way-to-upgrade-postgres-major-49&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.listennotes.com&#x2F;blog&#x2F;a-practical-way-to-upgrade-...</a></div><br/></div></div><div id="42873065" class="c"><input type="checkbox" id="c-42873065" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42873907">prev</a><span>|</span><a href="#42875383">next</a><span>|</span><label class="collapse" for="c-42873065">[-]</label><label class="expand" for="c-42873065">[7 more]</label></div><br/><div class="children"><div class="content">I have to wonder – are they using a connection pooler? I&#x27;m leaning towards no, since what they did in code can be natively done with PgBouncer, PgCat, et al. That would also explain the last footnote:<p>&gt; The big bottleneck is all the active connections<p>For anyone who is unaware, Postgres (and Aurora-compatible Postgres, which sucks but has a great marketing team) uses a process per connection, unlike MySQL (and others, I think) which use a thread per connection. This is inevitably the bottleneck at scale, long before anything else.<p>I did feel for them here:<p>&gt; We couldn’t create a blue-green deployment when the master DB had active replication slots. <i>The AWS docs did not mention this.</i> [emphasis mine]<p>The docs also used to explicitly say that you could run limited DDL, like creating or dropping indices, on the Green DB. I found this to be untrue in practice, notified them, and I see they&#x27;ve since updated their docs. A painful problem to discover though, especially when it&#x27;s a huge DB that took a long time to create the B&#x2F;G in the first place.</div><br/><div id="42873231" class="c"><input type="checkbox" id="c-42873231" checked=""/><div class="controls bullet"><span class="by">stopachka</span><span>|</span><a href="#42873065">parent</a><span>|</span><a href="#42874043">next</a><span>|</span><label class="collapse" for="c-42873231">[-]</label><label class="expand" for="c-42873231">[3 more]</label></div><br/><div class="children"><div class="content">&gt; are they using a connection pooler<p>We use Hikari [1] an in-process connection pooler. We didn&#x27;t opt for pgbouncer at al, because we didn&#x27;t want to add the extra infra yet.<p>&gt; since what they did in code can be natively done with PgBouncer, PgCat, et al.<p>Can you point me to a reference I could look at, about doing a major version upgrade with PgBouncer et al? My understanding is that we would still need to write a script to switch masters, similar to what we wrote.<p>&gt; The big bottleneck is all the active connections<p>The active connections we were referring too were websocket connections; we haven&#x27;t had problems with PG connections.<p>Right now the algorithm we use to find affected queries and notify websockets starts to falter when the number of active websocket connections on one machine get too high. We&#x27;re working on improving it in the coming weeks.<p>I updated the footnote to clarify that it was about websocket connections.<p>&gt; I did feel for them here:<p>Thank you! That part was definitely the most frustrating.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;brettwooldridge&#x2F;HikariCP">https:&#x2F;&#x2F;github.com&#x2F;brettwooldridge&#x2F;HikariCP</a></div><br/><div id="42873510" class="c"><input type="checkbox" id="c-42873510" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42873065">root</a><span>|</span><a href="#42873231">parent</a><span>|</span><a href="#42874043">next</a><span>|</span><label class="collapse" for="c-42873510">[-]</label><label class="expand" for="c-42873510">[2 more]</label></div><br/><div class="children"><div class="content">I’m not sure about a reference, other than their docs [0]. Basically, you’d modify the config to point to the new servers, issue PAUSE to PgBouncer to gracefully drain connections, then RELOAD to pick up the new config, then RESUME to accept new traffic.<p>This would result in client errors while paused, though, so perhaps not quite the same. To me, a few seconds of downtime is fine, but everyone has their own opinions. EDIT: you could of course also modify your client code (if it doesn’t already) to gracefully retry connections, which would effectively make this zero downtime.<p>ProxySQL (which I think now supports Postgres) has a global delay option where you can effectively make clients think that the query is just taking a long time; meanwhile, you can do the same sequence as outlined.<p>If you had HA Bouncers (which hopefully you would), you could cheat a little as you eluded to in the post, and have one still allow read queries to hit the old DB while cutting over writes on the other one, so the impact wouldn’t be as large.<p>[0]: <a href="https:&#x2F;&#x2F;www.pgbouncer.org&#x2F;usage.html" rel="nofollow">https:&#x2F;&#x2F;www.pgbouncer.org&#x2F;usage.html</a></div><br/><div id="42874709" class="c"><input type="checkbox" id="c-42874709" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42873065">root</a><span>|</span><a href="#42873510">parent</a><span>|</span><a href="#42874043">next</a><span>|</span><label class="collapse" for="c-42874709">[-]</label><label class="expand" for="c-42874709">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This would result in client errors while paused, though, so perhaps not quite the same.<p>What?  Docs say:<p>&gt; New client connections to a paused database will wait until RESUME is called.<p>Which fits what I remember when I was testing pgbouncer as part of automatic failover ages ago, if the connection from pgbouncer to the database dropped it would block until it reconnected without the app erroring.</div><br/></div></div></div></div></div></div><div id="42874043" class="c"><input type="checkbox" id="c-42874043" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#42873065">parent</a><span>|</span><a href="#42873231">prev</a><span>|</span><a href="#42875383">next</a><span>|</span><label class="collapse" for="c-42874043">[-]</label><label class="expand" for="c-42874043">[3 more]</label></div><br/><div class="children"><div class="content">Curious what you don&#x27;t like about Aurora? We&#x27;ve found it to generally be better than the older PG offering since it uses clustered storage, you don&#x27;t pay storage per replica. Additionally, you can pay 30% more per instance for unlimited IOPs<p>Serverless is generally a non starter unless you have a really really spikey workload</div><br/><div id="42874355" class="c"><input type="checkbox" id="c-42874355" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42873065">root</a><span>|</span><a href="#42874043">parent</a><span>|</span><a href="#42874231">next</a><span>|</span><label class="collapse" for="c-42874355">[-]</label><label class="expand" for="c-42874355">[1 more]</label></div><br/><div class="children"><div class="content">As a disclaimer, I generally dislike most managed offerings of anything, because I don’t think you get nearly the value out of them for the price hike (and performance drop). For DBs especially, I don’t see the value, but I’m also a DBRE with extensive Linux experience, so the maintenance side doesn’t bother me.<p>For Aurora in general, here’s a short list:<p>* Since the storage is separated, and farther than even EBS, latency is worse. Local, on-hardware NVMe is blindingly fast, enough that you can often forget that it isn’t RAM.<p>* I’ve yet to see Aurora perform better; MySQL or Postgres variants. My 13 year old Dell R620s literally outperform them; I’ve tested it.<p>* The claimed benefit of being able to take a DB up to 128 TiB is a. an artificial limit that they’ve made worse by denying the same to RDS b. difficult to reach in practice, because of a bunch of gotchas like fixed-size temporary storage, which can make it impossible to do online DDL of large tables.<p>* For the MySQL variant, they removed the change buffer entirely (since storage is distributed, it was necessary for their design), which dramatically slows down writes to tables with secondary indices.<p>* It’s not open-source. I can and have pored through Postgres and MySQL source code, built debug builds, etc. to figure out why something was happening.</div><br/></div></div><div id="42874231" class="c"><input type="checkbox" id="c-42874231" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#42873065">root</a><span>|</span><a href="#42874043">parent</a><span>|</span><a href="#42874355">prev</a><span>|</span><a href="#42875383">next</a><span>|</span><label class="collapse" for="c-42874231">[-]</label><label class="expand" for="c-42874231">[1 more]</label></div><br/><div class="children"><div class="content">Aurora has been excellent in my experience. Many operational problems (eg managing replica lag) disappear</div><br/></div></div></div></div></div></div><div id="42875383" class="c"><input type="checkbox" id="c-42875383" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#42873065">prev</a><span>|</span><a href="#42874141">next</a><span>|</span><label class="collapse" for="c-42875383">[-]</label><label class="expand" for="c-42875383">[1 more]</label></div><br/><div class="children"><div class="content">I wonder why they didn&#x27;t use synchronous_commit option. That would eliminate replication lag and allow for real zero-downtime.</div><br/></div></div><div id="42874141" class="c"><input type="checkbox" id="c-42874141" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#42875383">prev</a><span>|</span><a href="#42874080">next</a><span>|</span><label class="collapse" for="c-42874141">[-]</label><label class="expand" for="c-42874141">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t it tried it, but in another post recently someone mentioned enabling synchronous replication after the clone is up to date<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;warm-standby.html#SYNCHRONOUS-REPLICATION" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;warm-standby.html#SY...</a></div><br/></div></div><div id="42874080" class="c"><input type="checkbox" id="c-42874080" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#42874141">prev</a><span>|</span><a href="#42873897">next</a><span>|</span><label class="collapse" for="c-42874080">[-]</label><label class="expand" for="c-42874080">[1 more]</label></div><br/><div class="children"><div class="content">When I see instantdb in the domain on here I always know it&#x27;s going to be a good read :)<p>Nicely done!</div><br/></div></div></div></div></div></div></div></body></html>