<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723021276192" as="style"/><link rel="stylesheet" href="styles.css?v=1723021276192"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.paradedb.com/pages/elasticsearch_vs_postgres">Full text search over Postgres: Elasticsearch vs. alternatives</a> <span class="domain">(<a href="https://blog.paradedb.com">blog.paradedb.com</a>)</span></div><div class="subtext"><span>philippemnoel</span> | <span>84 comments</span></div><br/><div><div id="41173986" class="c"><input type="checkbox" id="c-41173986" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41178898">next</a><span>|</span><label class="collapse" for="c-41173986">[-]</label><label class="expand" for="c-41173986">[31 more]</label></div><br/><div class="children"><div class="content">The BM25 thing is actually a really big deal.<p>BM25 is similar to TF&#x2F;IDF. In both cases, the key idea is to consider statistics of the overall corpus as part of relevance calculations. If the user searches for &quot;charities in new orleans&quot; in a corpus where &quot;new orleans&quot; is only represented in a few documents, those should clearly rank highly. If the corpus has &quot;new orleans&quot; in almost every document then the term &quot;charity&quot; is more important.<p>PostgreSQL FTS cannot do this, because it doesn&#x27;t maintain statistics for word frequencies across the entire corpus. This severely limits what it can implement in terms of relevance scoring - each result is scored based purely on if the search terms are present or not.<p>For comparison, SQLite FTS (which a lot of people are unaware of) actually does implement full index statistics, and SQLite FTS5 implements BM25 out of the box.</div><br/><div id="41174792" class="c"><input type="checkbox" id="c-41174792" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#41173986">parent</a><span>|</span><a href="#41174469">next</a><span>|</span><label class="collapse" for="c-41174792">[-]</label><label class="expand" for="c-41174792">[17 more]</label></div><br/><div class="children"><div class="content">The problem with BM25 in a database, is that is can have unexpected outcomes for some common use cases.<p>Take multi-tenancy.<p>What if user 1 has many more documents than user 2, and uses &quot;new orleans&quot; a lot. But user 2 does not. User 2 does the search.<p>The db will first use FTS, and then filter. So user 1 will bias the results of user 2. Perhaps enough for user 2 to discover what words are in user 1 corpus.</div><br/><div id="41176431" class="c"><input type="checkbox" id="c-41176431" checked=""/><div class="controls bullet"><span class="by">retakeming</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174792">parent</a><span>|</span><a href="#41174942">next</a><span>|</span><label class="collapse" for="c-41176431">[-]</label><label class="expand" for="c-41176431">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re a Postgres pg_search user, partial indexes (<a href="https:&#x2F;&#x2F;docs.paradedb.com&#x2F;search&#x2F;full-text&#x2F;index#partial-bm25-index">https:&#x2F;&#x2F;docs.paradedb.com&#x2F;search&#x2F;full-text&#x2F;index#partial-bm2...</a>) can solve.</div><br/><div id="41176996" class="c"><input type="checkbox" id="c-41176996" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41176431">parent</a><span>|</span><a href="#41174942">next</a><span>|</span><label class="collapse" for="c-41176996">[-]</label><label class="expand" for="c-41176996">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re creating one Postgres index per user, you&#x27;re going to have a bad time really fast.</div><br/><div id="41178340" class="c"><input type="checkbox" id="c-41178340" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41176996">parent</a><span>|</span><a href="#41174942">next</a><span>|</span><label class="collapse" for="c-41178340">[-]</label><label class="expand" for="c-41178340">[1 more]</label></div><br/><div class="children"><div class="content">Would eat up inodes? Not sure how these work, does it create separate files for each one?</div><br/></div></div></div></div></div></div><div id="41174942" class="c"><input type="checkbox" id="c-41174942" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174792">parent</a><span>|</span><a href="#41176431">prev</a><span>|</span><a href="#41174816">next</a><span>|</span><label class="collapse" for="c-41174942">[-]</label><label class="expand" for="c-41174942">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Take multi-tenancy.<p>Using a SQLite DB per tenant is a good alternative to handle that: <a href="https:&#x2F;&#x2F;turso.tech&#x2F;" rel="nofollow">https:&#x2F;&#x2F;turso.tech&#x2F;</a></div><br/><div id="41176979" class="c"><input type="checkbox" id="c-41176979" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174942">parent</a><span>|</span><a href="#41174816">next</a><span>|</span><label class="collapse" for="c-41176979">[-]</label><label class="expand" for="c-41176979">[2 more]</label></div><br/><div class="children"><div class="content">SQLite has full text search with BM25?</div><br/><div id="41177262" class="c"><input type="checkbox" id="c-41177262" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41176979">parent</a><span>|</span><a href="#41174816">next</a><span>|</span><label class="collapse" for="c-41177262">[-]</label><label class="expand" for="c-41177262">[1 more]</label></div><br/><div class="children"><div class="content">Yes! <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;fts5.html</a></div><br/></div></div></div></div></div></div><div id="41174816" class="c"><input type="checkbox" id="c-41174816" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174792">parent</a><span>|</span><a href="#41174942">prev</a><span>|</span><a href="#41175306">next</a><span>|</span><label class="collapse" for="c-41174816">[-]</label><label class="expand" for="c-41174816">[4 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t that affect BM25 with a solution like Elasticsearch as well? Or is that smart enough to apply filters to the corpus statistics before calculating relevance?<p>You could solve that in SQLite by giving each user their own separate FTS table - not impossibly complex, but would grow increasingly messy if you have 10s of thousands of users.</div><br/><div id="41175085" class="c"><input type="checkbox" id="c-41175085" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174816">parent</a><span>|</span><a href="#41175306">next</a><span>|</span><label class="collapse" for="c-41175085">[-]</label><label class="expand" for="c-41175085">[3 more]</label></div><br/><div class="children"><div class="content">One way to address this in Elasticsearch would be to put each customers documents in their own index. Other than that, as far as I can tell it&#x27;s not smart enough to apply filters first.<p>Also, shards can affect BM25 scoring: <a href="https:&#x2F;&#x2F;www.elastic.co&#x2F;blog&#x2F;practical-bm25-part-1-how-shards-affect-relevance-scoring-in-elasticsearch" rel="nofollow">https:&#x2F;&#x2F;www.elastic.co&#x2F;blog&#x2F;practical-bm25-part-1-how-shards...</a></div><br/><div id="41176443" class="c"><input type="checkbox" id="c-41176443" checked=""/><div class="controls bullet"><span class="by">nemo44x</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41175085">parent</a><span>|</span><a href="#41175306">next</a><span>|</span><label class="collapse" for="c-41176443">[-]</label><label class="expand" for="c-41176443">[2 more]</label></div><br/><div class="children"><div class="content">It’s why you need “enough” data. Generally the distribution of teens is a power-law distribution. There’s a set of common terms and a very long tail of other terms. This will be the case across every shard if you do in fact have enough data per shard. This becomes a factor in certain distributed aggregations as well. YMMV of course.<p>In general you trade accuracy for speed. You tend to get a lot of speed for just a small amount of accuracy sacrifice.</div><br/><div id="41178350" class="c"><input type="checkbox" id="c-41178350" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41176443">parent</a><span>|</span><a href="#41175306">next</a><span>|</span><label class="collapse" for="c-41178350">[-]</label><label class="expand" for="c-41178350">[1 more]</label></div><br/><div class="children"><div class="content">Oh sure, but it is a side channel attack to be aware of.</div><br/></div></div></div></div></div></div></div></div><div id="41175306" class="c"><input type="checkbox" id="c-41175306" checked=""/><div class="controls bullet"><span class="by">Guillaume86</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174792">parent</a><span>|</span><a href="#41174816">prev</a><span>|</span><a href="#41177030">next</a><span>|</span><label class="collapse" for="c-41175306">[-]</label><label class="expand" for="c-41175306">[1 more]</label></div><br/><div class="children"><div class="content">It could be solved with an index partitioning feature, no idea if it already exists somewhere...</div><br/></div></div><div id="41177030" class="c"><input type="checkbox" id="c-41177030" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174792">parent</a><span>|</span><a href="#41175306">prev</a><span>|</span><a href="#41174469">next</a><span>|</span><label class="collapse" for="c-41177030">[-]</label><label class="expand" for="c-41177030">[5 more]</label></div><br/><div class="children"><div class="content">AWS offers a solution which is OpenSearch serverless <i>collections</i>. A dedicated collection can be spun up for each user&#x2F;tenant, e.g. «thing1-user345», «thing2-user123», instead of co-mingling the «user123» and «user345» in the same collection index. It increases the overall overhead but with the infrastructure repeatability, courtesy of IaaC, it is easy to roll out and process&#x2F;consume «thing1-user123» and «thing2-user123» as discrete datasets.<p>Tangentially related. I have been finding multi-tenancy to have become more of a liability at worst or a nuisance at best due to the increasingly frequent customer demands to satisfy the data sovereignity, data confidentiality (each tenant wants their own, non-shared cryptography keys etc), data privacy, compliance, the right to forget&#x2F;GDPR and similar requiremenets. For anything more complex than an anonymous online flower shop, it is simpler to partition the whole thing off – for each customer&#x2F;tenant.</div><br/><div id="41178682" class="c"><input type="checkbox" id="c-41178682" checked=""/><div class="controls bullet"><span class="by">urban_winter</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41177030">parent</a><span>|</span><a href="#41177827">next</a><span>|</span><label class="collapse" for="c-41178682">[-]</label><label class="expand" for="c-41178682">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For anything more complex than an anonymous online flower shop, it is simpler to partition the whole thing off – for each customer&#x2F;tenant.<p>Is this really a viable approach at the scale of B2B SaaS like Salesforce (or, contextually, Algolia)? They would end up with literally 10s of 1000s of DBs. That is surely cost-prohibitive.</div><br/></div></div><div id="41177827" class="c"><input type="checkbox" id="c-41177827" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41177030">parent</a><span>|</span><a href="#41178682">prev</a><span>|</span><a href="#41174469">next</a><span>|</span><label class="collapse" for="c-41177827">[-]</label><label class="expand" for="c-41177827">[3 more]</label></div><br/><div class="children"><div class="content">Any idea how “OpenSearch <i>serverless</i> collections” are implemented? I’m guessing that a “collection” is basically an ElasticSearch index, and “serverless” refers to some method of serializing&#x2F;loading it on-demand with some cold start tradeoffs?</div><br/><div id="41178515" class="c"><input type="checkbox" id="c-41178515" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41177827">parent</a><span>|</span><a href="#41174469">next</a><span>|</span><label class="collapse" for="c-41178515">[-]</label><label class="expand" for="c-41178515">[2 more]</label></div><br/><div class="children"><div class="content">Basically opensearch and elasticsearch both offer serverless modes now. They work differently because all this was developed post fork. But they do similar things. The Elastic implementation is in early access mode right now, so it is not released yet. I saw a demo of this at one of their meetups in June. I think Opensearch actually moved a bit faster than Elastic on this after Elastic announced that they were working on this a few years ago.<p>The aim with both is to not have users worry about cluster sizes or cluster management any more, which from an operational point of view is a huge gain because most companies using this stuff aren&#x27;t very good at doing that properly and the consequences are poor performance, outages, and even data loss when data volume grows.<p>Serverless essentially decouples indexing and querying traffic. All the nodes are transient and use their local disk only as a cache. Data at rest lives in S3 which becomes the single source of truth. So, if a new node comes up, it simply loads it&#x27;s state from there and it doesn&#x27;t have to coordinate with other nodes. There&#x27;s no more possibility for a cluster to go red either. If a node goes down, it just gets replaced. Basically this makes use of the notion that lucene index segments are immutable after they are written to. There&#x27;s a cleanup process running in the background that merges segments to clean things up but basically that just means you get a new file that then needs to be loaded by query nodes. I&#x27;m not 100% sure how write nodes coordinate segment creation and management. But I assume it involves using some kind of queueing.<p>So you get horizontal scalability for both reads and writes and you no longer have to worry about managing cluster state.<p>The tradeoff is that you have a bit increased latency before query nodes can see your incoming data because it has to hit S3 as part of the indexing process before read nodes can pick up new segments. Think multiple seconds before new data becomes visible. Both solutions are best suited for time series type use cases but they can also support regular search use cases. Any kind of use case where the same documents get updated regularly or where reading your own writes matters, things are not going to be great.<p>Amazon&#x27;s implementation of course probably leverages a lot of their cloud stuff. Elastics implementation will eventually be available in their cloud solution on all supported cloud providers. Self hosting this is going to be challenging with either solution. So that&#x27;s another tradeoff.</div><br/><div id="41178599" class="c"><input type="checkbox" id="c-41178599" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41178515">parent</a><span>|</span><a href="#41174469">next</a><span>|</span><label class="collapse" for="c-41178599">[-]</label><label class="expand" for="c-41178599">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the detailed response and insight. This is a great example of when meetups and in-person networking&#x2F;collaboration can help you stay ahead of the curve.<p>It does sound like the solution glosses over some cold start problems that will surface with increasing regularity for more fragmented indexes. For example if you have one index per tenant (imagine GitHub search has one public index and then additionally one index per authenticated user containing only repos they are authorized to read), then each user will experience a cold start on their first authenticated search.<p>I bet these tradeoffs are not so bad, and in practice, are worth the savings. But I will be curious to follow the developments here and to see the limitations more clearly quantified.<p>(Also this doesn’t address the writes but I’m sure that’s solvable.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41174469" class="c"><input type="checkbox" id="c-41174469" checked=""/><div class="controls bullet"><span class="by">beardedetim</span><span>|</span><a href="#41173986">parent</a><span>|</span><a href="#41174792">prev</a><span>|</span><a href="#41178376">next</a><span>|</span><label class="collapse" for="c-41174469">[-]</label><label class="expand" for="c-41174469">[2 more]</label></div><br/><div class="children"><div class="content">BM25 is definitely a big deal when you&#x27;re doing FTS. It&#x27;s one of the reasons I&#x27;ve switched to Arango as my DB for the project I&#x27;m working on that needs FTS. The fact it also comes with graphs means I don&#x27;t need to bang my head against CTEs either.<p>Not saying Arango can replace Postgres but for my needs, it&#x27;s a much better fit AND it offers the FTS that I need out of the box.</div><br/><div id="41175238" class="c"><input type="checkbox" id="c-41175238" checked=""/><div class="controls bullet"><span class="by">philippemnoel</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174469">parent</a><span>|</span><a href="#41178376">next</a><span>|</span><label class="collapse" for="c-41175238">[-]</label><label class="expand" for="c-41175238">[1 more]</label></div><br/><div class="children"><div class="content">Arango is sweet! We&#x27;ve actually talked to many people who switched from Postgres to Arango because of its better FTS. This was one of the reasons for creating ParadeDB in the first place. Many of the users who made this switch wished they could have stayed in Postgres without compromising on FTS.</div><br/></div></div></div></div><div id="41178376" class="c"><input type="checkbox" id="c-41178376" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#41173986">parent</a><span>|</span><a href="#41174469">prev</a><span>|</span><a href="#41174677">next</a><span>|</span><label class="collapse" for="c-41178376">[-]</label><label class="expand" for="c-41178376">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while since I used tools in this space.  Some questions:<p>Where does AI&#x2F;semantic search&#x2F;vector DBs fit into the state of the art today?  Is it generally a total replacement for traditional text search tools like elastic, or does it sit side by side?  Most, but not all, use-cases I can think of would prefer semantic search, but what are the considerations here?</div><br/><div id="41178432" class="c"><input type="checkbox" id="c-41178432" checked=""/><div class="controls bullet"><span class="by">evv555</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41178376">parent</a><span>|</span><a href="#41174677">next</a><span>|</span><label class="collapse" for="c-41178432">[-]</label><label class="expand" for="c-41178432">[1 more]</label></div><br/><div class="children"><div class="content">bm25 is often used along side vector search with a reciprocal rerank algorithm.</div><br/></div></div></div></div><div id="41174677" class="c"><input type="checkbox" id="c-41174677" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#41173986">parent</a><span>|</span><a href="#41178376">prev</a><span>|</span><a href="#41175176">next</a><span>|</span><label class="collapse" for="c-41174677">[-]</label><label class="expand" for="c-41174677">[3 more]</label></div><br/><div class="children"><div class="content">I wish SQLite FTS had a nicer to use API. Last time I looked (a few months ago) it was very confusing and not very user friendly.</div><br/><div id="41174783" class="c"><input type="checkbox" id="c-41174783" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174677">parent</a><span>|</span><a href="#41175176">next</a><span>|</span><label class="collapse" for="c-41174783">[-]</label><label class="expand" for="c-41174783">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve built a bunch of Python (and CLI) code to try and help make that work better: <a href="https:&#x2F;&#x2F;sqlite-utils.datasette.io&#x2F;en&#x2F;stable&#x2F;python-api.html#full-text-search" rel="nofollow">https:&#x2F;&#x2F;sqlite-utils.datasette.io&#x2F;en&#x2F;stable&#x2F;python-api.html#...</a><p><pre><code>    import sqlite_utils
    
    db = sqlite_utils.Database(&quot;news.db&quot;)
    db[&quot;articles&quot;].enable_fts([&quot;headline&quot;, &quot;body&quot;])
    results = list(db[&quot;articles&quot;].search(&quot;softball&quot;))
</code></pre>
Or with the CLI tool: <a href="https:&#x2F;&#x2F;sqlite-utils.datasette.io&#x2F;en&#x2F;stable&#x2F;cli.html#configuring-full-text-search" rel="nofollow">https:&#x2F;&#x2F;sqlite-utils.datasette.io&#x2F;en&#x2F;stable&#x2F;cli.html#configu...</a><p><pre><code>    sqlite-utils enable-fts news.db articles headline body
    sqlite-utils search news.db articles softball</code></pre></div><br/><div id="41175001" class="c"><input type="checkbox" id="c-41175001" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41174783">parent</a><span>|</span><a href="#41175176">next</a><span>|</span><label class="collapse" for="c-41175001">[-]</label><label class="expand" for="c-41175001">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool, maybe I can use it as a reference. Thank you!</div><br/></div></div></div></div></div></div><div id="41175176" class="c"><input type="checkbox" id="c-41175176" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#41173986">parent</a><span>|</span><a href="#41174677">prev</a><span>|</span><a href="#41177339">next</a><span>|</span><label class="collapse" for="c-41175176">[-]</label><label class="expand" for="c-41175176">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve learned information retrieval in university before ever using any full text search engine and I was honestly kinda surprised that most engines are literal textbook implementations. IR was one of those courses where I definitely expected the SotA to be further out than the third slide deck.</div><br/><div id="41177851" class="c"><input type="checkbox" id="c-41177851" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41175176">parent</a><span>|</span><a href="#41175215">next</a><span>|</span><label class="collapse" for="c-41177851">[-]</label><label class="expand" for="c-41177851">[1 more]</label></div><br/><div class="children"><div class="content">That’s probably because SotA in IR is proprietary implementations like Google Search, the most bread-and-butter trade secrets of their business. So they’re not publishing that (at least in any holistic manner, and even if they did, it’s not like one product could implement all its functionality including the complexities around the periphery). And what you’re left with is some pretty decent parity between industry and academic SotA, same as a lot of other areas of CS (databases, decentralized systems, etc). If anything, in most cases, implementation lags behind academic theory.</div><br/></div></div><div id="41175215" class="c"><input type="checkbox" id="c-41175215" checked=""/><div class="controls bullet"><span class="by">jhanschoo</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41175176">parent</a><span>|</span><a href="#41177851">prev</a><span>|</span><a href="#41177339">next</a><span>|</span><label class="collapse" for="c-41175215">[-]</label><label class="expand" for="c-41175215">[2 more]</label></div><br/><div class="children"><div class="content">It kind of is now if you count deep-learning based solutions to an information need haha</div><br/><div id="41175289" class="c"><input type="checkbox" id="c-41175289" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41175215">parent</a><span>|</span><a href="#41177339">next</a><span>|</span><label class="collapse" for="c-41175289">[-]</label><label class="expand" for="c-41175289">[1 more]</label></div><br/><div class="children"><div class="content">That is true</div><br/></div></div></div></div></div></div><div id="41177339" class="c"><input type="checkbox" id="c-41177339" checked=""/><div class="controls bullet"><span class="by">SigmundA</span><span>|</span><a href="#41173986">parent</a><span>|</span><a href="#41175176">prev</a><span>|</span><a href="#41178898">next</a><span>|</span><label class="collapse" for="c-41177339">[-]</label><label class="expand" for="c-41177339">[2 more]</label></div><br/><div class="children"><div class="content">There was some work toward this, not sure about its current status: <a href="https:&#x2F;&#x2F;github.com&#x2F;postgrespro&#x2F;rum">https:&#x2F;&#x2F;github.com&#x2F;postgrespro&#x2F;rum</a><p>Badly needed.</div><br/><div id="41177557" class="c"><input type="checkbox" id="c-41177557" checked=""/><div class="controls bullet"><span class="by">philippemnoel</span><span>|</span><a href="#41173986">root</a><span>|</span><a href="#41177339">parent</a><span>|</span><a href="#41178898">next</a><span>|</span><label class="collapse" for="c-41177557">[-]</label><label class="expand" for="c-41177557">[1 more]</label></div><br/><div class="children"><div class="content">RUM indices are a nice improvements, but they&#x27;re not in Postgres core and likely won&#x27;t ever be :( If you&#x27;re looking for Elastic-level FTS in Postgres, your best bet is likely to overengineer pgvector+tsvector or simply to use ParadeDB pg_search</div><br/></div></div></div></div></div></div><div id="41178898" class="c"><input type="checkbox" id="c-41178898" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41173986">prev</a><span>|</span><a href="#41179406">next</a><span>|</span><label class="collapse" for="c-41178898">[-]</label><label class="expand" for="c-41178898">[2 more]</label></div><br/><div class="children"><div class="content">If you care about search quality, postgres ends up being fairly limited. I&#x27;ve done stuff with it; it&#x27;s alright for really simple stuff. But it&#x27;s the wrong tool for the job generally.<p>If the order of the search results matters to you, you might want something that gives you some more tools to control that. And if you are not measuring search quality to begin with, you probably don&#x27;t care enough to even know that you are missing the tools to do a better job.<p>I consult clients on this stuff professionally and I&#x27;ve seen companies do all sorts of silly shit. Mostly it&#x27;s because they simply lack the in house expertise which is usually how they end up talking to me.<p>I&#x27;ve actually had to sit clients down and explain them their own business model. Usually I come in for some technical problem and then end up talking to product managers or senior managers about stuff like this because usually the real problem is at that level. The technical issues are just a symptom.<p>Here&#x27;s a discussion I had with a client fairly recently (paraphrasing&#x2F;exaggerating, obviously):<p>&quot;Me: So your business model is that your users find shit on your web site (it has a very prominent search box at the top) and then some transaction happens that causes you to make money? Customer: yes. Me: so you make more money if your search works better and users find stuff they want. Customer: yes, we want to make more money! Me: congratulations, you are a search company! Customer: LOL whut?! Me: So, why aren&#x27;t you doing the kinds of things that other search companies do to ensure you maximize profit? Like measuring how good your search is or generally giving a shit whether users can actually find what they are looking for. Customer: uhhhhh ???? Me: where&#x27;s your search team? Customer: oh we don&#x27;t have one, you do it! Me: how did you end up with what you currently have. Customer: oh that guy (some poor, overworked dev) over there picked solution X 3 years ago and we never gave it a second thought.&quot;<p>Honestly, some companies can&#x27;t be helped and this was an example of a company that was kind of hopelessly flailing around and doing very sub optimal things at all levels in the company. And wasting lots of time and money in the process. Not realizing your revenue and competitiveness are literally defined by your search quality is never a good sign. You take different decisions if you do.</div><br/><div id="41179341" class="c"><input type="checkbox" id="c-41179341" checked=""/><div class="controls bullet"><span class="by">porsager</span><span>|</span><a href="#41178898">parent</a><span>|</span><a href="#41179406">next</a><span>|</span><label class="collapse" for="c-41179341">[-]</label><label class="expand" for="c-41179341">[1 more]</label></div><br/><div class="children"><div class="content">I certainly get the sentiment of your comment, but I&#x27;d be much more interested to hear your take on ParadeDB which the post is about?</div><br/></div></div></div></div><div id="41179406" class="c"><input type="checkbox" id="c-41179406" checked=""/><div class="controls bullet"><span class="by">sgift</span><span>|</span><a href="#41178898">prev</a><span>|</span><a href="#41173742">next</a><span>|</span><label class="collapse" for="c-41179406">[-]</label><label class="expand" for="c-41179406">[1 more]</label></div><br/><div class="children"><div class="content">Solr. The correct answer is Solr. All the search features of Elasticsearch (both are built on Lucene, which provides the actual search implementation) without the problems that Elastic (the company) or Elasticsearch (the product) brings with it. 99% of companies using Elasticsearch would be far better of with Solr.</div><br/></div></div><div id="41173742" class="c"><input type="checkbox" id="c-41173742" checked=""/><div class="controls bullet"><span class="by">ashconnor</span><span>|</span><a href="#41179406">prev</a><span>|</span><a href="#41174496">next</a><span>|</span><label class="collapse" for="c-41173742">[-]</label><label class="expand" for="c-41173742">[4 more]</label></div><br/><div class="children"><div class="content">Facets are possible in Postgres but it looks complex:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20200815141031&#x2F;https:&#x2F;&#x2F;roamanalytics.com&#x2F;2019&#x2F;04&#x2F;16&#x2F;faceted-search-with-postgres-using-tsvector&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20200815141031&#x2F;https:&#x2F;&#x2F;roamanaly...</a><p>pg_search [0] not to be confused with the ruby gem of the same name [1]:<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;paradedb&#x2F;paradedb&#x2F;tree&#x2F;dev&#x2F;pg_search#overview">https:&#x2F;&#x2F;github.com&#x2F;paradedb&#x2F;paradedb&#x2F;tree&#x2F;dev&#x2F;pg_search#over...</a><p>[1] - <a href="https:&#x2F;&#x2F;github.com&#x2F;Casecommons&#x2F;pg_search">https:&#x2F;&#x2F;github.com&#x2F;Casecommons&#x2F;pg_search</a></div><br/><div id="41174004" class="c"><input type="checkbox" id="c-41174004" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41173742">parent</a><span>|</span><a href="#41174801">next</a><span>|</span><label class="collapse" for="c-41174004">[-]</label><label class="expand" for="c-41174004">[2 more]</label></div><br/><div class="children"><div class="content">I implemented faceted search on my own blog entirely on top of PostgreSQL. It works well, but that&#x27;s because my blog has only 11,348 documents total.<p>Notes on how I built that here: <a href="https:&#x2F;&#x2F;simonwillison.net&#x2F;2017&#x2F;Oct&#x2F;5&#x2F;django-postgresql-faceted-search&#x2F;" rel="nofollow">https:&#x2F;&#x2F;simonwillison.net&#x2F;2017&#x2F;Oct&#x2F;5&#x2F;django-postgresql-facet...</a></div><br/><div id="41177243" class="c"><input type="checkbox" id="c-41177243" checked=""/><div class="controls bullet"><span class="by">przemub</span><span>|</span><a href="#41173742">root</a><span>|</span><a href="#41174004">parent</a><span>|</span><a href="#41174801">next</a><span>|</span><label class="collapse" for="c-41177243">[-]</label><label class="expand" for="c-41177243">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a lot of posts for a blog :)</div><br/></div></div></div></div><div id="41174801" class="c"><input type="checkbox" id="c-41174801" checked=""/><div class="controls bullet"><span class="by">bdzr</span><span>|</span><a href="#41173742">parent</a><span>|</span><a href="#41174004">prev</a><span>|</span><a href="#41174496">next</a><span>|</span><label class="collapse" for="c-41174801">[-]</label><label class="expand" for="c-41174801">[1 more]</label></div><br/><div class="children"><div class="content">Faceting over even small result sets and producing the relevant counts is really hard for postgres, and caching tends to be impossible due to the combinatorics of the problem. There&#x27;s some discussion around supporting better indexing options here that is relevant: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;message-id&#x2F;CAJqPDh9o%3DoxRP%3DxZhbCzzAs4Vr5hNUkYLMspGee%2B%3DmgbqG3tAg%40mail.gmail.com" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;message-id&#x2F;CAJqPDh9o%3DoxRP%3DxZh...</a>. Practically, <a href="https:&#x2F;&#x2F;github.com&#x2F;cybertec-postgresql&#x2F;pgfaceting">https:&#x2F;&#x2F;github.com&#x2F;cybertec-postgresql&#x2F;pgfaceting</a> is the best bet for people who must use postgres even though it still uses a manual maintenance step.</div><br/></div></div></div></div><div id="41174496" class="c"><input type="checkbox" id="c-41174496" checked=""/><div class="controls bullet"><span class="by">samsk</span><span>|</span><a href="#41173742">prev</a><span>|</span><a href="#41173846">next</a><span>|</span><label class="collapse" for="c-41174496">[-]</label><label class="expand" for="c-41174496">[6 more]</label></div><br/><div class="children"><div class="content">For internet user facing full-text search I would always prefer to use a separate tool and not a SQL database, because<p>- the fulltext tool, can and should hold only &#x27;active&#x27; data<p>- as it has only active data, data size is usually much much smaller<p>- as data size is smaller, it better fits in RAM<p>- as data size is smaller, it can be probably run on poorer HW the full ACID db<p>- as the indexed data are mostly read-only, the VM where it runs can be relatively easily cloned (never seen a corruption till now)<p>- as FTS tools are usually schema-less, there is no outage during schema changes (compared to doing changes in ACID db)<p>- as the indexed data are mostly read-only, the can be easily backup-ed<p>- as the backups are smaller, restoring a backup can be very fast<p>- and there is no such thing as database upgrade outage, you just spin a new version, feed it with new data and than change the backends<p>- functionality and extensibility<p>There is probably more, but if one doesn&#x27;t needs to do a fulltext search on whole database (and you usually don&#x27;t), than its IMHO better to use separate tool, that doesn&#x27;t comes with all the ACID constraints.
Probably only downside is that you need to format data for the FTS and index them, but if you want run a serious full-text search, you will have to take almost the same steps in the database.<p>On a 15y old side project, I use SOLR for full-text search, serving 20-30k&#x2F;request per day on a cheap VM, and PostgreSQL is used as primary data source.
The PostgreSQL has had several longer outages - during major upgrades, because of disk corruption, because of failed schema migrations, because of &#x27;problems&#x27; between the chair and keyboard etc...
During that outages the full-text search always worked - it didn&#x27;t had most recent data, but most users probably never noticed.</div><br/><div id="41174772" class="c"><input type="checkbox" id="c-41174772" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#41174496">parent</a><span>|</span><a href="#41174815">next</a><span>|</span><label class="collapse" for="c-41174772">[-]</label><label class="expand" for="c-41174772">[3 more]</label></div><br/><div class="children"><div class="content">playing devils avocate<p>&gt; the fulltext tool, can and should hold only &#x27;active&#x27; data<p>very possible with postgres, too. instead of augmenting your primary table to support search, you would have a secondary&#x2F;ephemeral table serving search duties<p>&gt; as data size is smaller, it better fits in RAM<p>likewise, a standalone table for search helps here, containing only the relevant fields and attributes. this can be further optimized by using partial indexes.<p>&gt; as FTS tools are usually schema-less, there is no outage during schema changes (compared to doing changes in ACID db)<p>postgresql can be used in this manner by using json&#x2F;jsonb fields. instead of defining every field, just define one field and drop whatever you want in it.<p>&gt; as the indexed data are mostly read-only, the can be easily backup-ed<p>same for postgres. the search table can be exported very easily as parquet, csv, etc.<p>&gt; as the backups are smaller, restoring a backup can be very fast<p>tbh regardless of underlying mechanism, if your search index is based on upstream data it is likely easier to just rebuild it versus restoring a backup of throwaway data.<p>&gt; The PostgreSQL has had several longer outages - during major upgrades, because of disk corruption, because of failed schema migrations, because of &#x27;problems&#x27; between the chair and keyboard etc...<p>to be fair, these same issues can happen with elasticsearch or any other tool.<p>how big was your data in solr?</div><br/><div id="41175675" class="c"><input type="checkbox" id="c-41175675" checked=""/><div class="controls bullet"><span class="by">samsk</span><span>|</span><a href="#41174496">root</a><span>|</span><a href="#41174772">parent</a><span>|</span><a href="#41174815">next</a><span>|</span><label class="collapse" for="c-41175675">[-]</label><label class="expand" for="c-41175675">[2 more]</label></div><br/><div class="children"><div class="content">PostgreSQL is over 90GB, SOLR is under 1GB.<p>The PostgreSQL has to handle writes, reports, etc..., so I doubt it will cache as efficiently as full-text engine, you&#x27;ll need to have full or partial replicas to distribute the load.<p>And, yes, I agree, almost all of this can be done with separate search table(s), but this table(s) will still live in a &#x27;crowded house&#x27;, so again replicas will be probably necessary at some point.<p>And using replicas brings new set of problems and costs ;-)<p>One client used MySQL for fulltext search, it was a single beefy RDS server, costing well over $1k per month and the costs kept raising. It was replaced with a single ~$100 EC2 machine running Meilisearch.</div><br/><div id="41179066" class="c"><input type="checkbox" id="c-41179066" checked=""/><div class="controls bullet"><span class="by">conradfr</span><span>|</span><a href="#41174496">root</a><span>|</span><a href="#41175675">parent</a><span>|</span><a href="#41174815">next</a><span>|</span><label class="collapse" for="c-41179066">[-]</label><label class="expand" for="c-41179066">[1 more]</label></div><br/><div class="children"><div class="content">Meilisearch is good, probably sufficient for a vast majority of use cases.<p>In fact self hosting it is so easy and performant that I wonder how their paid saas is doing.</div><br/></div></div></div></div></div></div><div id="41174815" class="c"><input type="checkbox" id="c-41174815" checked=""/><div class="controls bullet"><span class="by">sidmitra</span><span>|</span><a href="#41174496">parent</a><span>|</span><a href="#41174772">prev</a><span>|</span><a href="#41173846">next</a><span>|</span><label class="collapse" for="c-41174815">[-]</label><label class="expand" for="c-41174815">[2 more]</label></div><br/><div class="children"><div class="content">While agreeing somewhat with the post above, the answer isn&#x27;t really so black and white but depends on your context, i.e. scale, app-complexity, search needs, data size etc.<p>&gt;the fulltext tool, can and should hold only &#x27;active&#x27; data<p>Same can be said about your DB. You can create separate tables, partitions to hold only active data. I assume materialized views are also there(but never used them for FTS). You can even choose to create a separate postgres instance but only use it for FTS data.
The reason to do that might be to avoid coupling your business logic to another ORM&#x2F;DSL and having your team t learn another query language and its gotchas.<p>&gt; as data size is smaller, it better fits in RAM<p>&gt; as data size is smaller, it better fits in RAM<p>&gt; as the indexed data are mostly read-only, the VM where it runs can be relatively easily cloned<p>&gt; as the indexed data are mostly read-only, the can be easily backup-ed<p>&gt; as the backups are smaller, restoring a backup can be very fast<p>Once the pg tables are separate and relevant indexing, i assume PG can also keep most data in memory.
There isn&#x27;t anything stopping you from using a different instance of PG for FTS if needed.<p>&gt; as FTS tools are usually schema-less, there is no outage during schema changes<p>True. But in practice for example ES does have schema(mappings, columns, indexes), and will have you re-index your rows&#x2F;data in some cases rebuild your index entirely to be safe. There are field types and your querying will depend on the field types you choose. i remember even SOLR did, because i had to figure out Geospatial field types to do those queries, but haven&#x27;t used it in a decade so can&#x27;t say how things stand now.<p><a href="https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;current&#x2F;mapping-types.html" rel="nofollow">https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;curr...</a><p>While the OPs point stands, in a sufficiently complex FTS search project you&#x27;ll need all of the features and you&#x27;ll have to deal with the following on search oriented DBs<p>- Schema migrations or some async jobs to re-index data. Infact it was worse than postgres because atleast in RDBMS migrations are well understood. In ES devs would change field types and expect everything to work without realizing only the new data was getting it. So we had to re-index entire indexes sometimes to get around this for each change in schema.<p>- At scale you&#x27;ll have to tap into WAL logs via CDC&#x2F;Debezium to ensure your data in your search index is up-to-date and no rows were missed. Which means dealing with robust queues&#x2F;pub-sub.<p>- A whole another ORM or DSL for elasticsearch. If you don&#x27;t use these, your queries will soon start to become a mish-mash of string concats or f-strings which is even worse for maintainability.<p><a href="https:&#x2F;&#x2F;elasticsearch-py.readthedocs.io&#x2F;en&#x2F;v8.14.0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;elasticsearch-py.readthedocs.io&#x2F;en&#x2F;v8.14.0&#x2F;</a>
<a href="https:&#x2F;&#x2F;elasticsearch-dsl.readthedocs.io&#x2F;en&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;elasticsearch-dsl.readthedocs.io&#x2F;en&#x2F;latest&#x2F;</a><p>- Unless your search server is directly serving browser traffic, you&#x27;ll add additional latency traversing hops. In some cases meilisearch, typesense might work here.<p>I usually recommend engineers(starting out on a new search product feature) to start with FTS on postgres and jump to another search DB as and when needed. FTS support has improved greatly on python frameworks like Django. I&#x27;ve made the other choice of jumping too soon to a separate search DB and come to regret it because it needed me to either build abstractions on top or use DSL sdk, then ensure the data in both is &quot;synced&quot; up and maintain observability&#x2F;telemetry on this new DB and so on. The time&#x2F;effort investment was not linear is and the ROI wasn&#x27;t in the same range for the use-case i was working on.<p>I actually got more mileage out of search by just dumping small CSV datasets into S3 and downloading them in the browser and doing FTS client side via JS libs. This basically got me zero latency search, albeit for small enough per-user datasets.</div><br/><div id="41175860" class="c"><input type="checkbox" id="c-41175860" checked=""/><div class="controls bullet"><span class="by">samsk</span><span>|</span><a href="#41174496">root</a><span>|</span><a href="#41174815">parent</a><span>|</span><a href="#41173846">next</a><span>|</span><label class="collapse" for="c-41175860">[-]</label><label class="expand" for="c-41175860">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it always depends on application and purpose.<p>But once you will have to deal with a real FTS load, as you say, you have to use separate instances and replication, use materialized views etc.. and you find your self almost halfway to implementing ETL pipeline and because of replicas, with more complicated setup than having a FTS tool. And than somebody finds out what vector search is, and ask you if there is an PG extension for it (yes it is).<p>So IMHO with FTS in database, you&#x27;ll probably have to deal with the almost same problems as with external FTS (materialized views, triggers, reindexing, replication, migrations) but without all its features, and with constrains of ACID database (locks, transactions, writes)...<p>Btw. I&#x27;ve SOLR right behind the OpenResty, so no hops. With database there would  be one more hop and bunch of SQL queries, because it doesn&#x27;t speaks HTTP (although I&#x27;m sure there is an PG extension for that ;-)</div><br/></div></div></div></div></div></div><div id="41173846" class="c"><input type="checkbox" id="c-41173846" checked=""/><div class="controls bullet"><span class="by">radpanda</span><span>|</span><a href="#41174496">prev</a><span>|</span><a href="#41175776">next</a><span>|</span><label class="collapse" for="c-41173846">[-]</label><label class="expand" for="c-41173846">[20 more]</label></div><br/><div class="children"><div class="content">&gt; Because Elasticsearch is not a reliable data store, organizations that use Postgres typically extract, transform, and load (ETL) data from Postgres to Elasticsearch<p>I’ll admit haven’t kept up with this but is it still the case that Elasticsearch is “not a reliable data store”?<p>I remember there used to be a line in the Elasticsearch docs saying that Elasticseach shouldn’t be your primary data store or something to that effect. At some point they removed that verbiage, seemingly indicating more confidence in their reliability but I still hear people sticking with the previous guidance.</div><br/><div id="41174846" class="c"><input type="checkbox" id="c-41174846" checked=""/><div class="controls bullet"><span class="by">willio58</span><span>|</span><a href="#41173846">parent</a><span>|</span><a href="#41175728">next</a><span>|</span><label class="collapse" for="c-41174846">[-]</label><label class="expand" for="c-41174846">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what the author was referring to, but in our stack ES is the only non-serverless tech we have to work with. I know there&#x27;s a lot of hate in HN around serverless for many reasons but for us for several years, we&#x27;ve been able to scale without any worry of our systems being affected performance-wise (I know this won&#x27;t last forever).<p>ES is not this way, we have to manage our nodes ourselves and figure out &quot;that one node is failing, why?&quot; type questions. I hear they&#x27;re working on a serverless version, but honestly, I think we will be leaving ES before that happens.</div><br/><div id="41175806" class="c"><input type="checkbox" id="c-41175806" checked=""/><div class="controls bullet"><span class="by">maxxxxxx</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41174846">parent</a><span>|</span><a href="#41177485">next</a><span>|</span><label class="collapse" for="c-41175806">[-]</label><label class="expand" for="c-41175806">[2 more]</label></div><br/><div class="children"><div class="content">Elastic’s serverless offering went GA recently: <a href="https:&#x2F;&#x2F;www.elastic.co&#x2F;elasticsearch&#x2F;serverless" rel="nofollow">https:&#x2F;&#x2F;www.elastic.co&#x2F;elasticsearch&#x2F;serverless</a></div><br/><div id="41176836" class="c"><input type="checkbox" id="c-41176836" checked=""/><div class="controls bullet"><span class="by">farsa</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41175806">parent</a><span>|</span><a href="#41177485">next</a><span>|</span><label class="collapse" for="c-41176836">[-]</label><label class="expand" for="c-41176836">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still in technical preview.</div><br/></div></div></div></div><div id="41177485" class="c"><input type="checkbox" id="c-41177485" checked=""/><div class="controls bullet"><span class="by">easton</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41174846">parent</a><span>|</span><a href="#41175806">prev</a><span>|</span><a href="#41175995">next</a><span>|</span><label class="collapse" for="c-41177485">[-]</label><label class="expand" for="c-41177485">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that one node is failing, why<p>We have a similar experience except we’re using AWS’ version, so any inquiry as to what happened ends with support saying “maybe if you upgrade your nodes this won’t happen again? idk”</div><br/></div></div><div id="41175995" class="c"><input type="checkbox" id="c-41175995" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41174846">parent</a><span>|</span><a href="#41177485">prev</a><span>|</span><a href="#41175728">next</a><span>|</span><label class="collapse" for="c-41175995">[-]</label><label class="expand" for="c-41175995">[1 more]</label></div><br/><div class="children"><div class="content">What are you considering replacing it with for full-text search?</div><br/></div></div></div></div><div id="41175728" class="c"><input type="checkbox" id="c-41175728" checked=""/><div class="controls bullet"><span class="by">amai</span><span>|</span><a href="#41173846">parent</a><span>|</span><a href="#41174846">prev</a><span>|</span><a href="#41174354">next</a><span>|</span><label class="collapse" for="c-41175728">[-]</label><label class="expand" for="c-41175728">[1 more]</label></div><br/><div class="children"><div class="content">Just read the article: „Elasticsearch’s lack of ACID transactions and MVCC can lead to data inconsistencies and loss, while its lack of relational properties and real-time consistency makes many database queries challenging.“</div><br/></div></div><div id="41174354" class="c"><input type="checkbox" id="c-41174354" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#41173846">parent</a><span>|</span><a href="#41175728">prev</a><span>|</span><a href="#41178597">next</a><span>|</span><label class="collapse" for="c-41174354">[-]</label><label class="expand" for="c-41174354">[1 more]</label></div><br/><div class="children"><div class="content">It got a lot better in the ~7 series IIRC when they added checksums to the on-disk files.  I don&#x27;t know if you still have to recover corruptions by hand, or whether the correct file gets copied in from a replica.<p>The replication protocols and leader election were IMO not battle-hardened or likely to pass Aphyr-style testing.  It was pretty easy to get into a state where the source of truth was unclear.<p>Source: Ran an Elasticsearch hosting company in the 2010&#x27;s.  A little out of the loop, but not sure much has changed.</div><br/></div></div><div id="41178597" class="c"><input type="checkbox" id="c-41178597" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41173846">parent</a><span>|</span><a href="#41174354">prev</a><span>|</span><a href="#41173931">next</a><span>|</span><label class="collapse" for="c-41178597">[-]</label><label class="expand" for="c-41178597">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been abusing it as a data store for many years. I don&#x27;t recommend it but not because of a lack of reliability. It&#x27;s actually fine but you need to know what you are doing and it&#x27;s not exactly an optimal solution from a performance point of view.<p>The main issue is not lack of robustness but the fact that there are no transactions and it doesn&#x27;t scale very well on the write side unless you use bulk inserts. You can work around some of the limitations with things like optimistic locking to guarantee that you aren&#x27;t overwriting your own writes. Doing that requires a bit of boiler plate. For applications with low amounts of writes, it&#x27;s actually not horrible if you do that. Otherwise, if you make sure you do regular backups (with snapshots), you should be fine. Additionally, you need to size your cluster properly. Things get bad when you run low on memory or disk. But that&#x27;s true for any database.<p>If you are interested in doing this, my open source kotlin client for Elasticsearch and Opensearch (I support both) has an IndexRepository class which makes all this very easy to use and encapsulates a lot of the trickery and bookkeeping you need to do to get optimistic locking. I also have a very easy to use way to do bulk indexing that takes care of all the bookkeeping, retries, etc. without requiring a lot of boiler plate. And of course because this is Kotlin, it comes with nice to use kotlin DSLs.<p>You can emulate what it does with other clients for other languages but I&#x27;m not really aware of a lot of other projects that make this as easy. Frankly, most clients are a bit bare bones and require a lot of boiler plate. Getting rid of boiler plate was the key motivation for me to create this library.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jillesvangurp&#x2F;kt-search">https:&#x2F;&#x2F;github.com&#x2F;jillesvangurp&#x2F;kt-search</a></div><br/></div></div><div id="41173931" class="c"><input type="checkbox" id="c-41173931" checked=""/><div class="controls bullet"><span class="by">wordofx</span><span>|</span><a href="#41173846">parent</a><span>|</span><a href="#41178597">prev</a><span>|</span><a href="#41177822">next</a><span>|</span><label class="collapse" for="c-41173931">[-]</label><label class="expand" for="c-41173931">[10 more]</label></div><br/><div class="children"><div class="content">ES is just unreliable. Can be running smoothly for a year and boom it falls over and you’re left scratching your head.</div><br/><div id="41178679" class="c"><input type="checkbox" id="c-41178679" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41173931">parent</a><span>|</span><a href="#41176916">next</a><span>|</span><label class="collapse" for="c-41178679">[-]</label><label class="expand" for="c-41178679">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using and supporting ES (and OS lately) for well over a decade. Mostly its fine but a lot of users struggle with sizing their clusters properly (which is costly). Elasticsearch falling over is what happens when you don&#x27;t do that. It scales fine until it doesn&#x27;t and then you hit a brick wall and things get ugly.<p>Additionally, many companies learn the hard way that dynamic mapping is a bad idea because you might end up with hundreds of fields and a lot of memory overhead and garbage collection. I&#x27;ve fixed more than a few situations like this for clients that ended up with hundreds or thousands of fields, many shards and indices. Usually it&#x27;s because they are just dumping a lot of data in there without thinking about how to optimize that for what they need.<p>A properly architected setup is not going to fall over randomly. But you need to know what you are doing and there are a lot of clients that I help that clearly don&#x27;t have the in house expertise to do this properly and are a bit out of their depth.</div><br/></div></div><div id="41176916" class="c"><input type="checkbox" id="c-41176916" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41173931">parent</a><span>|</span><a href="#41178679">prev</a><span>|</span><a href="#41177495">next</a><span>|</span><label class="collapse" for="c-41176916">[-]</label><label class="expand" for="c-41176916">[3 more]</label></div><br/><div class="children"><div class="content">A problem here is that ES (and Solr too) are pathological with respect to garbage collection.<p>To make generational GC efficient, you want to have very short lived objects, or objects that live forever.  Lots of moderately long-lived objects is the worst case scenario, as it causes permanent fragmentation of the old GC generation.<p>Lucene generally churns through a lot of strings while indexing, but it also builds a lot of caches that live on-heap for a few minutes.  Because the minor GCs come fast and furious due to indexing, that means you have caches that last just long enough to get evicted into the old generation, only to become useless shortly thereafter.<p>The end result looks like a slow burning memory leak.  I&#x27;ve seen the worst cases take down servers every hour or two, but this can accumulate over time on a slower fuse as well.</div><br/><div id="41177336" class="c"><input type="checkbox" id="c-41177336" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41176916">parent</a><span>|</span><a href="#41177495">next</a><span>|</span><label class="collapse" for="c-41177336">[-]</label><label class="expand" for="c-41177336">[2 more]</label></div><br/><div class="children"><div class="content">Can this be fixed with alternative GC’s or tuning?</div><br/><div id="41178145" class="c"><input type="checkbox" id="c-41178145" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41177336">parent</a><span>|</span><a href="#41177495">next</a><span>|</span><label class="collapse" for="c-41178145">[-]</label><label class="expand" for="c-41178145">[1 more]</label></div><br/><div class="children"><div class="content">It might be better by now with the newer GC options (ZGC, G1, Azul).  For a while those had their own problems, but I&#x27;m a little out of the loop.<p>Tuning the older options wasn&#x27;t really all that beneficial.  We tried tuning, then running a custom build of OpenJDK to mess with the survivor space (which isn&#x27;t that tunable via config), then ultimately settled on more aggressive (i.e. weekly) rolling restarts of servers.</div><br/></div></div></div></div></div></div><div id="41177495" class="c"><input type="checkbox" id="c-41177495" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41173931">parent</a><span>|</span><a href="#41176916">prev</a><span>|</span><a href="#41174346">next</a><span>|</span><label class="collapse" for="c-41177495">[-]</label><label class="expand" for="c-41177495">[1 more]</label></div><br/><div class="children"><div class="content">This seems to be a Lucene&#x2F;SOLR problem. I used Lucene&#x2F;SOLR years ago, and it died so often that we just auto-indexed nightly and had a re-index button in the UI.</div><br/></div></div><div id="41174346" class="c"><input type="checkbox" id="c-41174346" checked=""/><div class="controls bullet"><span class="by">cyberes</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41173931">parent</a><span>|</span><a href="#41177495">prev</a><span>|</span><a href="#41177822">next</a><span>|</span><label class="collapse" for="c-41174346">[-]</label><label class="expand" for="c-41174346">[4 more]</label></div><br/><div class="children"><div class="content">That exact scenario just happened to me a few days ago.</div><br/><div id="41174519" class="c"><input type="checkbox" id="c-41174519" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41174346">parent</a><span>|</span><a href="#41176033">next</a><span>|</span><label class="collapse" for="c-41174519">[-]</label><label class="expand" for="c-41174519">[2 more]</label></div><br/><div class="children"><div class="content">What would you consider as replacement</div><br/><div id="41175526" class="c"><input type="checkbox" id="c-41175526" checked=""/><div class="controls bullet"><span class="by">alexpeng</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41174519">parent</a><span>|</span><a href="#41176033">next</a><span>|</span><label class="collapse" for="c-41175526">[-]</label><label class="expand" for="c-41175526">[1 more]</label></div><br/><div class="children"><div class="content">SingleStore is pretty good at ES use cases. Low latency, scalability, real time ingest, full text search + millisecond query times.</div><br/></div></div></div></div><div id="41176033" class="c"><input type="checkbox" id="c-41176033" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41173846">root</a><span>|</span><a href="#41174346">parent</a><span>|</span><a href="#41174519">prev</a><span>|</span><a href="#41177822">next</a><span>|</span><label class="collapse" for="c-41176033">[-]</label><label class="expand" for="c-41176033">[1 more]</label></div><br/><div class="children"><div class="content">How did you fix it? What happened?</div><br/></div></div></div></div></div></div><div id="41177822" class="c"><input type="checkbox" id="c-41177822" checked=""/><div class="controls bullet"><span class="by">IamLoading</span><span>|</span><a href="#41173846">parent</a><span>|</span><a href="#41173931">prev</a><span>|</span><a href="#41175776">next</a><span>|</span><label class="collapse" for="c-41177822">[-]</label><label class="expand" for="c-41177822">[1 more]</label></div><br/><div class="children"><div class="content">They publicly track their resillency efforts here<p><a href="https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;resiliency&#x2F;master&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;resiliency&#x2F;mas...</a><p>&gt;7 its become quite reliable. It comes down to how you manage and maintain the cluster</div><br/></div></div></div></div><div id="41175776" class="c"><input type="checkbox" id="c-41175776" checked=""/><div class="controls bullet"><span class="by">amai</span><span>|</span><a href="#41173846">prev</a><span>|</span><a href="#41178631">next</a><span>|</span><label class="collapse" for="c-41175776">[-]</label><label class="expand" for="c-41175776">[3 more]</label></div><br/><div class="children"><div class="content">Alternatives to both are<p><a href="https:&#x2F;&#x2F;www.meilisearch.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.meilisearch.com&#x2F;</a><p><a href="https:&#x2F;&#x2F;typesense.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;typesense.org&#x2F;</a><p>and maybe<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Sygil-Dev&#x2F;whoosh-reloaded">https:&#x2F;&#x2F;github.com&#x2F;Sygil-Dev&#x2F;whoosh-reloaded</a></div><br/><div id="41177174" class="c"><input type="checkbox" id="c-41177174" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#41175776">parent</a><span>|</span><a href="#41178631">next</a><span>|</span><label class="collapse" for="c-41177174">[-]</label><label class="expand" for="c-41177174">[2 more]</label></div><br/><div class="children"><div class="content">Manticore is seldom mentioned around here but it seems to be a really good alternative [1]. The fact that is the search engine Craigslist uses gives them a lot of credibility.<p>This may be a bit silly, but I wonder if the design of their blog and website makes them look a bit &quot;old fashioned&quot; or something.<p>--<p>1: <a href="https:&#x2F;&#x2F;manticoresearch.com&#x2F;blog&#x2F;manticore-alternative-to-elasticsearch&#x2F;" rel="nofollow">https:&#x2F;&#x2F;manticoresearch.com&#x2F;blog&#x2F;manticore-alternative-to-el...</a></div><br/><div id="41178017" class="c"><input type="checkbox" id="c-41178017" checked=""/><div class="controls bullet"><span class="by">pqdbr</span><span>|</span><a href="#41175776">root</a><span>|</span><a href="#41177174">parent</a><span>|</span><a href="#41178631">next</a><span>|</span><label class="collapse" for="c-41178017">[-]</label><label class="expand" for="c-41178017">[1 more]</label></div><br/><div class="children"><div class="content">Funny you mentioned because I also get that vibe from the Manticore website. We do judge books by their covers afterall.</div><br/></div></div></div></div></div></div><div id="41179225" class="c"><input type="checkbox" id="c-41179225" checked=""/><div class="controls bullet"><span class="by">glintik</span><span>|</span><a href="#41178631">prev</a><span>|</span><a href="#41177032">next</a><span>|</span><label class="collapse" for="c-41179225">[-]</label><label class="expand" for="c-41179225">[1 more]</label></div><br/><div class="children"><div class="content">Postgres has very limited features related to FTS, so it is useful only for very simple cases or for very limited budget. Elasticsearch is stable enough(but good devops and devs needed) and has numerous of features. Anyway Elasticsearch is not a &quot;plug and play&quot; solution and requires much work to be done for good search quality. Why I know this all? I&#x27;m running ecommerce search startup, based on Elasticsearch as primary storage.</div><br/></div></div><div id="41177032" class="c"><input type="checkbox" id="c-41177032" checked=""/><div class="controls bullet"><span class="by">alanwli</span><span>|</span><a href="#41179225">prev</a><span>|</span><a href="#41178657">next</a><span>|</span><label class="collapse" for="c-41177032">[-]</label><label class="expand" for="c-41177032">[3 more]</label></div><br/><div class="children"><div class="content">Always great to see Postgres-based alternatives.<p>One clarification question - the blog post lists &quot;lack of ACID transactions and MVCC can lead to data inconsistencies and loss, while its lack of relational properties and real-time consistency makes many database queries challenging&quot; as the bad for ElasticSearch. What is pg_bm25&#x27;s consistency model? It had been mentioned previously as offering &quot;weak consistency&quot; [0], which I interpret to have the same problems with transactions, MVCC, etc?<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37864089">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37864089</a></div><br/><div id="41177666" class="c"><input type="checkbox" id="c-41177666" checked=""/><div class="controls bullet"><span class="by">retakeming</span><span>|</span><a href="#41177032">parent</a><span>|</span><a href="#41178657">next</a><span>|</span><label class="collapse" for="c-41177666">[-]</label><label class="expand" for="c-41177666">[2 more]</label></div><br/><div class="children"><div class="content">Good question. That was from a very old version of pg_bm25 (since renamed to pg_search). BM25 indexes are now strongly consistent.</div><br/><div id="41178506" class="c"><input type="checkbox" id="c-41178506" checked=""/><div class="controls bullet"><span class="by">alanwli</span><span>|</span><a href="#41177032">root</a><span>|</span><a href="#41177666">parent</a><span>|</span><a href="#41178657">next</a><span>|</span><label class="collapse" for="c-41178506">[-]</label><label class="expand" for="c-41178506">[1 more]</label></div><br/><div class="children"><div class="content">Nice! I&#x27;ve seen other extensions that don&#x27;t have transactional semantics, which runs counter to the norm for PG.<p>So since it was previously weakly consistent due to performance reasons, how does strong consistency affect transactional inserts&#x2F;updates latency?</div><br/></div></div></div></div></div></div><div id="41178657" class="c"><input type="checkbox" id="c-41178657" checked=""/><div class="controls bullet"><span class="by">izietto</span><span>|</span><a href="#41177032">prev</a><span>|</span><a href="#41177755">next</a><span>|</span><label class="collapse" for="c-41178657">[-]</label><label class="expand" for="c-41178657">[1 more]</label></div><br/><div class="children"><div class="content">Is this distributed as a PostgreSQL extension as well?</div><br/></div></div><div id="41177755" class="c"><input type="checkbox" id="c-41177755" checked=""/><div class="controls bullet"><span class="by">killme2008</span><span>|</span><a href="#41178657">prev</a><span>|</span><a href="#41174022">next</a><span>|</span><label class="collapse" for="c-41177755">[-]</label><label class="expand" for="c-41177755">[1 more]</label></div><br/><div class="children"><div class="content">I believe the primary issue with using full-text search in PostgreSQL is its performance and scalability limitations.<p>Elasticsearch&#x2F;OpenSearch offers more than just search functionality; they come with extensive ecosystems, including ELK for logging and processors for ETL pipelines. These platforms are powerful and provide out-of-the-box solutions for developers. However, as the article mentioned, scaling them up or out can be costly.<p>ParadeDB looks like is based on tantivy(<a href="https:&#x2F;&#x2F;github.com&#x2F;quickwit-oss&#x2F;tantivy">https:&#x2F;&#x2F;github.com&#x2F;quickwit-oss&#x2F;tantivy</a>) which is an impressive project. We leverage it to implement full-text indexing for GreptimeDB too (<a href="https:&#x2F;&#x2F;github.com&#x2F;GreptimeTeam&#x2F;greptimedb">https:&#x2F;&#x2F;github.com&#x2F;GreptimeTeam&#x2F;greptimedb</a>). Nevertheless, building full-text indexes with Tantivy is still resource-intensive. This is why Grafana Loki, which only indexes tags instead of building full-text indexes, is popular in the observability space. In GreptimeDB, we offer users the flexibility to choose whether to build full-text indexes for text fields, while always creating inverted indexes for tags.</div><br/></div></div><div id="41175513" class="c"><input type="checkbox" id="c-41175513" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#41174022">prev</a><span>|</span><a href="#41176502">next</a><span>|</span><label class="collapse" for="c-41175513">[-]</label><label class="expand" for="c-41175513">[2 more]</label></div><br/><div class="children"><div class="content">Are there success cases of using ElasticSearch&#x2F;OpenSearch as the primary data store in production? Just curious.</div><br/><div id="41178026" class="c"><input type="checkbox" id="c-41178026" checked=""/><div class="controls bullet"><span class="by">j0ba</span><span>|</span><a href="#41175513">parent</a><span>|</span><a href="#41176502">next</a><span>|</span><label class="collapse" for="c-41178026">[-]</label><label class="expand" for="c-41178026">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using it for a small real estate app for like ~8 years. Zero problems, works like a dream. I use MySQL for some app-user data, but most of the bulk data is on ES.<p>Solo dev running a 3 node cluster on Hetzner.</div><br/></div></div></div></div><div id="41176502" class="c"><input type="checkbox" id="c-41176502" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#41175513">prev</a><span>|</span><a href="#41177619">next</a><span>|</span><label class="collapse" for="c-41176502">[-]</label><label class="expand" for="c-41176502">[3 more]</label></div><br/><div class="children"><div class="content">Solr still seems to be an option</div><br/><div id="41176884" class="c"><input type="checkbox" id="c-41176884" checked=""/><div class="controls bullet"><span class="by">4RealFreedom</span><span>|</span><a href="#41176502">parent</a><span>|</span><a href="#41176804">next</a><span>|</span><label class="collapse" for="c-41176884">[-]</label><label class="expand" for="c-41176884">[1 more]</label></div><br/><div class="children"><div class="content">Just upgraded an old system to solr 9. I&#x27;ve been very impressed with it.</div><br/></div></div><div id="41176804" class="c"><input type="checkbox" id="c-41176804" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#41176502">parent</a><span>|</span><a href="#41176884">prev</a><span>|</span><a href="#41177619">next</a><span>|</span><label class="collapse" for="c-41176804">[-]</label><label class="expand" for="c-41176804">[1 more]</label></div><br/><div class="children"><div class="content">Solr and ElasticSearch are both based on Lucene.</div><br/></div></div></div></div><div id="41177619" class="c"><input type="checkbox" id="c-41177619" checked=""/><div class="controls bullet"><span class="by">coding123</span><span>|</span><a href="#41176502">prev</a><span>|</span><a href="#41174844">next</a><span>|</span><label class="collapse" for="c-41177619">[-]</label><label class="expand" for="c-41177619">[2 more]</label></div><br/><div class="children"><div class="content">The analytical part is what usually makes the Elasticsearch (or opensearch) the choice - it&#x27;s not that you have to search just the text, its that with that text you need to show 5 different categories some of the top values and the number of occurrences and permutations thereof if the user decides to clicky clicky and filter it more.</div><br/><div id="41178022" class="c"><input type="checkbox" id="c-41178022" checked=""/><div class="controls bullet"><span class="by">pqdbr</span><span>|</span><a href="#41177619">parent</a><span>|</span><a href="#41174844">next</a><span>|</span><label class="collapse" for="c-41178022">[-]</label><label class="expand" for="c-41178022">[1 more]</label></div><br/><div class="children"><div class="content">How does Elasticsearch (or the ELK stack) would help implement what you described?</div><br/></div></div></div></div><div id="41174844" class="c"><input type="checkbox" id="c-41174844" checked=""/><div class="controls bullet"><span class="by">corytheboyd</span><span>|</span><a href="#41177619">prev</a><span>|</span><label class="collapse" for="c-41174844">[-]</label><label class="expand" for="c-41174844">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We’ve talked to many companies who have tried and regretted their decision to use Elasticsearch as their primary data store<p>oh no…</div><br/></div></div></div></div></div></div></div></body></html>