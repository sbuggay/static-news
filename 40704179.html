<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718701258927" as="style"/><link rel="stylesheet" href="styles.css?v=1718701258927"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://futhark-lang.org/blog/2024-06-17-automap.html">NumPy-style broadcasting in Futhark</a> <span class="domain">(<a href="https://futhark-lang.org">futhark-lang.org</a>)</span></div><div class="subtext"><span>zfnmxt</span> | <span>18 comments</span></div><br/><div><div id="40713949" class="c"><input type="checkbox" id="c-40713949" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#40714384">next</a><span>|</span><label class="collapse" for="c-40713949">[-]</label><label class="expand" for="c-40713949">[12 more]</label></div><br/><div class="children"><div class="content">I’d strongly suggest <i>not</i> going the Numpy route, and instead reading about broadcast in julia [1]. In many contexts, it’s very important to distinguish between the element-wise application of a function, and a function that is applied to an entire array. A classic example would be the matrix exponential[2], versus the element-wise exponential of a matrix.<p>In julia the former is `exp(M)`, and the latter is `exp.(M)`<p>[1] <a href="https:&#x2F;&#x2F;julialang.org&#x2F;blog&#x2F;2017&#x2F;01&#x2F;moredots&#x2F;" rel="nofollow">https:&#x2F;&#x2F;julialang.org&#x2F;blog&#x2F;2017&#x2F;01&#x2F;moredots&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Matrix_exponential" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Matrix_exponential</a></div><br/><div id="40714427" class="c"><input type="checkbox" id="c-40714427" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#40713949">parent</a><span>|</span><a href="#40714083">next</a><span>|</span><label class="collapse" for="c-40714427">[-]</label><label class="expand" for="c-40714427">[4 more]</label></div><br/><div class="children"><div class="content">I actually think Julia&#x27;s behaviour (partially) copied from matlab is bad. I had to review a lot of matlab&#x2F;Julia simulation code write by PhD&#x2F;grad students (as well as my own) and most of the time when things somehow are not working debugging becomes a task of &quot;find the missing dot&quot;. If they would have decided on a more obvious symbol (the dot is really just way too easy to overlook) for broadcasting it would be much better, but I still much prefer that broadcast and matrix operation would use entirely different operators&#x2F;named functions. Instead we have the case that a little annotation can dramatically change the behaviour of the code (the matrix exponential is in fact a great example).<p>That said I mainly work with fields and calculus so I might be biased because the majority of operations are broadcast and I only rarely use matrix operations.</div><br/><div id="40715052" class="c"><input type="checkbox" id="c-40715052" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40714427">parent</a><span>|</span><a href="#40715192">next</a><span>|</span><label class="collapse" for="c-40715052">[-]</label><label class="expand" for="c-40715052">[2 more]</label></div><br/><div class="children"><div class="content">The nice thing is that if this dot-approach (or some other syntax with a similar effect) were implemented in Futhark, then because Futhark is statically-typed, all mismatches would be compile-time errors. Those are very hard to overlook :)</div><br/><div id="40715159" class="c"><input type="checkbox" id="c-40715159" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40715052">parent</a><span>|</span><a href="#40715192">next</a><span>|</span><label class="collapse" for="c-40715159">[-]</label><label class="expand" for="c-40715159">[1 more]</label></div><br/><div class="children"><div class="content">In the very common case of square matrices, I think the dotted and non-dotted operations are generally both valid?</div><br/></div></div></div></div><div id="40715192" class="c"><input type="checkbox" id="c-40715192" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40714427">parent</a><span>|</span><a href="#40715052">prev</a><span>|</span><a href="#40714083">next</a><span>|</span><label class="collapse" for="c-40715192">[-]</label><label class="expand" for="c-40715192">[1 more]</label></div><br/><div class="children"><div class="content">&gt; most of the time when things somehow are not working debugging becomes a task of &quot;find the missing dot&quot;. If they would have decided on a more obvious symbo<p>I guess you could use your editor’s highlight-regexp function to make the dots more obvious during debugging :)<p>I personally like the dots because they’re so unintrusive, but I work in a field where most operations are matrix operations, so perhaps you’re right…</div><br/></div></div></div></div><div id="40714083" class="c"><input type="checkbox" id="c-40714083" checked=""/><div class="controls bullet"><span class="by">zfnmxt</span><span>|</span><a href="#40713949">parent</a><span>|</span><a href="#40714427">prev</a><span>|</span><a href="#40714080">next</a><span>|</span><label class="collapse" for="c-40714083">[-]</label><label class="expand" for="c-40714083">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d actually say what we did in Futhark is more similar to what Julia does (in the sense that the dot operator is syntactic sugar for Julia&#x27;s `broadcast`) than what NumPy does---I wrote &quot;NumPy-style&quot; in the title just because I figured that&#x27;s what most people would be familiar with. A more accurate title might be &quot;Rank-polymorphic function applications in Futhark&quot;.<p>Ultimately it&#x27;s quite different from both languages, though. Futhark has a strict static type system and we figure out how to broadcast completely statically without runtime information (NumPy and Julia both do it dynamically). This is really the main challenge that the system addresses and it permits you to have broadcasting in an ML&#x2F;Hindley-Milner&#x2F;Haskell-style type system along with full type inference and all the usual jazz and goodies.<p>Our system also doesn&#x27;t have anything to do with vectorization&#x2F;performance optimizations---in Futhark, `[1,2,3] + [4,5,6]` is just syntactic sugar for `map (+) [1,2,3] [4,5,6]` (which is how you&#x27;d write it without broadcasting), where `map` is already a parallel construct. So broadcasting in Futhark is literally just syntactic sugar for constructs that are inherently parallel, anyway---anything you can express with broadcasting can already be written in stock Futhark and there&#x27;s no &quot;magic&quot; going on. Broadcasting in Futhark just means that some `map`s can be implicit, rather than explicit.<p>So it&#x27;s a very disciplined and transparent (since it&#x27;s static you can ask the compiler to show you exactly how the broadcasting will work) approach to broadcasting that the user has a lot of control over.<p>&gt; it’s very important to distinguish between the element-wise application of a function, and a function that is applied to an entire array<p>Broadcasting in Futhark isn&#x27;t inherently &quot;element-wise&quot; in the sense of descending through all the ranks of an argument until you get to the scalar level. It tries to actually use the fewest number of `map`s to get a rank-correct function application, so there&#x27;s a preference for applying a function to higher-dimensional elements over scalars. This might sound non-intuitive&#x2F;confusing, but it actually almost always aligns with what the programmer intended.<p>All it really does is use the minimal number of `map`s (and `rep`s) to massage a function and an argument with a rank mismatch into something that makes sense (or is rank correct)---it doesn&#x27;t even have a notion of scalars, only rank differences!</div><br/><div id="40714232" class="c"><input type="checkbox" id="c-40714232" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40714083">parent</a><span>|</span><a href="#40714080">next</a><span>|</span><label class="collapse" for="c-40714232">[-]</label><label class="expand" for="c-40714232">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Futhark has a strict static type system and we figure out how to broadcast completely statically without runtime information (NumPy and Julia both do it dynamically).<p>Julia’s broadcast doesnt do anything dynamic. If you know the input types of a broadcast expression, you know the output type.<p>&gt; Broadcasting in Futhark isn&#x27;t inherently &quot;element-wise&quot; in the sense of descending through all the ranks of an argument until you get to the scalar level.<p>Julia’s broadcast doesnt do that either. One dot is one level deep.<p>Julia also doesn&#x27;t really have a concept of scalars (in fact, our number types are actually zero-dimensional, one-element iterables). When I said ‘elementwise’ I just meant each element of a container, which can in turn be a container.</div><br/><div id="40714328" class="c"><input type="checkbox" id="c-40714328" checked=""/><div class="controls bullet"><span class="by">zfnmxt</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40714232">parent</a><span>|</span><a href="#40714080">next</a><span>|</span><label class="collapse" for="c-40714328">[-]</label><label class="expand" for="c-40714328">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Julia’s broadcast doesnt do anything dynamic.<p>When is a broadcast expression transformed (and fused) into vectorized code?<p>&gt; If you know the input types of a broadcast expression, you know the output type.<p>Do you always (statically) know the input types? In Futhark, due to parametric polymorphism, you don&#x27;t necessarily know the input types.<p>&gt; Julia’s broadcast doesnt do that either. One dot is one level deep.<p>Doesn&#x27;t something like `[[1,2,3]] .+ 4` go two levels deep? Or have I misunderstood something?</div><br/><div id="40714506" class="c"><input type="checkbox" id="c-40714506" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40714328">parent</a><span>|</span><a href="#40714080">next</a><span>|</span><label class="collapse" for="c-40714506">[-]</label><label class="expand" for="c-40714506">[2 more]</label></div><br/><div class="children"><div class="content">&gt; When is a broadcast expression transformed (and fused) into vectorized code?<p>A broadcast expression is dealt with during lowering from expression trees to the  linear IR. The trick is that it just turns into function calls. When you write<p><pre><code>    a .+ f.(b)
</code></pre>
that turns into<p><pre><code>    materialize(broadcasted(+, a, broadcasted(f, b))
</code></pre>
where the broadcasted calls are lazy, uninstantiated representations of the call. The `materialize` function then performs the fusion.<p>As long as you write type-inferrable code, the handling and fusion will all happen during compile time with no dynamism.<p>&gt; Do you always (statically) know the input types? In Futhark, due to parametric polymorphism, you don&#x27;t necessarily know the input types.<p>A method in julia always knows its concrete input types when it is called. Julia basically works by stitching together chunks of static code. So if something dynamic happens in the middle of your program, the compiler just waits until the the types are known at runtime and then resumes, and compiles new static code as far forward as its able to analyze the program.<p>If your program is fully inferrable, then the whole program is compiled &#x27;just-ahead-of-time&#x27; when you first call the outermost function.<p>&gt; Doesn&#x27;t something like `[[1,2,3]] .+ 4` go two levels deep? Or have I misunderstood something?<p>No, that would error in julia.</div><br/><div id="40714736" class="c"><input type="checkbox" id="c-40714736" checked=""/><div class="controls bullet"><span class="by">zfnmxt</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40714506">parent</a><span>|</span><a href="#40714080">next</a><span>|</span><label class="collapse" for="c-40714736">[-]</label><label class="expand" for="c-40714736">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No, that would error in julia.<p>Okay, but &#x27;[[1,2,3] [4,5,6]] .+ 4` does work! Looks like Julia distinguishes between a two-dimensional array and an array of arrays (which Futhark does not). To me, it feels like semantically &#x27;[[1,2,3] [4,5,6]] .+ 4` is two levels deep even if operationally it has some underlying flat representation. (But I&#x27;m not familiar with Julia&#x27;s programming model.)<p>&gt;  The trick is that it just turns into function calls.<p>Ah, okay. I think `a .+ f.(b)` can roughly be understood in Futhark as `map^N (+) a (rep^M (map^Q f (rep^S b)))` where `map^N` means do N `map`s and you can locally determine N, M, Q, S from the input types. We actually essentially had this in our very first prototype of AUTOMAP but found it insufficient for our purposes because it doesn&#x27;t play nice with arguments whose types aren&#x27;t fully known (i.e., that have type variables) and we cannot wait until runtime to figure out those types.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40714080" class="c"><input type="checkbox" id="c-40714080" checked=""/><div class="controls bullet"><span class="by">lalaithion</span><span>|</span><a href="#40713949">parent</a><span>|</span><a href="#40714083">prev</a><span>|</span><a href="#40714384">next</a><span>|</span><label class="collapse" for="c-40714080">[-]</label><label class="expand" for="c-40714080">[2 more]</label></div><br/><div class="children"><div class="content">Futhark is a statically typed language, so it can’t have the same ambiguity.</div><br/><div id="40714241" class="c"><input type="checkbox" id="c-40714241" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#40713949">root</a><span>|</span><a href="#40714080">parent</a><span>|</span><a href="#40714384">next</a><span>|</span><label class="collapse" for="c-40714241">[-]</label><label class="expand" for="c-40714241">[1 more]</label></div><br/><div class="children"><div class="content">What ambiguity?</div><br/></div></div></div></div></div></div><div id="40714384" class="c"><input type="checkbox" id="c-40714384" checked=""/><div class="controls bullet"><span class="by">enisberk</span><span>|</span><a href="#40713949">prev</a><span>|</span><a href="#40714399">next</a><span>|</span><label class="collapse" for="c-40714384">[-]</label><label class="expand" for="c-40714384">[2 more]</label></div><br/><div class="children"><div class="content">This is really cool work! Congrats on both the paper and the graduation! A long time ago, I worked on optimizing broadcast operations on GPUs [1]. Coming up with a strategy that promises high throughput across different array dimensionalities is quite challenging. I am looking forward to reading your work.<p>[1]<a href="https:&#x2F;&#x2F;scholar.google.com&#x2F;citations?view_op=view_citation&amp;hl=en&amp;user=AH-sLEkAAAAJ&amp;citation_for_view=AH-sLEkAAAAJ:u5HHmVD_uO8C" rel="nofollow">https:&#x2F;&#x2F;scholar.google.com&#x2F;citations?view_op=view_citation&amp;h...</a></div><br/><div id="40714514" class="c"><input type="checkbox" id="c-40714514" checked=""/><div class="controls bullet"><span class="by">zfnmxt</span><span>|</span><a href="#40714384">parent</a><span>|</span><a href="#40714399">next</a><span>|</span><label class="collapse" for="c-40714514">[-]</label><label class="expand" for="c-40714514">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Congrats on both the paper and the graduation!<p>Thanks! Although I still have to actually graduate and the paper is in review, so maybe your congratulations are a bit premature! :)<p>&gt; A long time ago, I worked on optimizing broadcast operations on GPUs [1].<p>Something similar happens in Futhark, actually. When something like `[1,2,3] + 4` is elaborated to `map (+) [1,2,3] (rep 4)`, the `rep` is eliminated by pushing the `4` into the `map`: `map (+4) [1,2,3]`. Futhark ultimately then compiles it to efficient CUDA&#x2F;OpenCL&#x2F;whatever.</div><br/></div></div></div></div><div id="40714856" class="c"><input type="checkbox" id="c-40714856" checked=""/><div class="controls bullet"><span class="by">stabbles</span><span>|</span><a href="#40714399">prev</a><span>|</span><label class="collapse" for="c-40714856">[-]</label><label class="expand" for="c-40714856">[2 more]</label></div><br/><div class="children"><div class="content">Somewhat confusing to see a matrix represented as an array of arrays, it will never be fast.</div><br/><div id="40714907" class="c"><input type="checkbox" id="c-40714907" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#40714856">parent</a><span>|</span><label class="collapse" for="c-40714907">[-]</label><label class="expand" for="c-40714907">[1 more]</label></div><br/><div class="children"><div class="content">This is in the surface language only: Futhark&#x27;s arrays must be &quot;rectangular&quot; (if you have an array of arrays, the subarrays are mandated to be equally-sized; this is statically checked in most cases, and when it can&#x27;t, it becomes a runtime check), and thus they are represented as a single, <i>actual</i> multi-dimensional array.</div><br/></div></div></div></div></div></div></div></div></div></body></html>