<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722243658788" as="style"/><link rel="stylesheet" href="styles.css?v=1722243658788"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://msreekan.com/2014/01/15/sdcard/">SDcard wear leveling and translation layers (2014)</a>Â <span class="domain">(<a href="https://msreekan.com">msreekan.com</a>)</span></div><div class="subtext"><span>goodburb</span> | <span>13 comments</span></div><br/><div><div id="41098854" class="c"><input type="checkbox" id="c-41098854" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#41098407">next</a><span>|</span><label class="collapse" for="c-41098854">[-]</label><label class="expand" for="c-41098854">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; For example, lets consider that we wrote to the sector 1024 on the SDCARD, and this address got initially mapped to physical sector 1024 itself on flash. Later we overwrite the contents, but this time write cannot go to the same physical address because it needs to be erased before programmed again.</i><p>Maybe someone here will know the answer to something I&#x27;ve been wondering for a while: When appending to a file with writes smaller than a sector, does this remapping process trigger every time? Or is the controller smart enough that it can append without remapping, even though to overwrite would need remapping?<p>Obviously for an SD card used for saving photos or videos you could write a sector at a time - but for an SD card in a temperature logger or similar, your appends might be a lot smaller.</div><br/><div id="41098967" class="c"><input type="checkbox" id="c-41098967" checked=""/><div class="controls bullet"><span class="by">st_goliath</span><span>|</span><a href="#41098854">parent</a><span>|</span><a href="#41098407">next</a><span>|</span><label class="collapse" for="c-41098967">[-]</label><label class="expand" for="c-41098967">[1 more]</label></div><br/><div class="children"><div class="content">Pages that are already written cannot be overwritten, at least not without a full block erase, so it has to do a remap.<p>Directly logging to an SD card (i.e. lots of small writes) is the fastest way to destroy it.</div><br/></div></div></div></div><div id="41098407" class="c"><input type="checkbox" id="c-41098407" checked=""/><div class="controls bullet"><span class="by">st_goliath</span><span>|</span><a href="#41098854">prev</a><span>|</span><a href="#41098745">next</a><span>|</span><label class="collapse" for="c-41098407">[-]</label><label class="expand" for="c-41098407">[5 more]</label></div><br/><div class="children"><div class="content">At a conference, I once met somebody who said his team had the joy of dismantling broken SD cards and figuring out <i>why</i> they broke.<p>One of the anecdotes I distinctly recall was about a batch of cards that (for obvious cost saving reasons) used the actual data flash to store its own firmware as well.<p>IIRC due to a bug in the wear leveling accounting, once the card got sufficiently full, the wear leveling code ended up partially overwriting the firmware itself.</div><br/><div id="41098494" class="c"><input type="checkbox" id="c-41098494" checked=""/><div class="controls bullet"><span class="by">billpg</span><span>|</span><a href="#41098407">parent</a><span>|</span><a href="#41098621">next</a><span>|</span><label class="collapse" for="c-41098494">[-]</label><label class="expand" for="c-41098494">[3 more]</label></div><br/><div class="children"><div class="content">I recall once having an SD card with a mysterious file in the root folder with system and hidden attributes on it. I decided to delete the file and some time later (months), the card suddenly stopped working.<p>It maybe stopped working once the OS decided the bytes were available for use (which it would only have done without the file marking that space as unavailable) and overwrote that section. I suspect defragmenting or otherwise moving the file about for whatever reason would have had the same effect.</div><br/><div id="41098584" class="c"><input type="checkbox" id="c-41098584" checked=""/><div class="controls bullet"><span class="by">karamanolev</span><span>|</span><a href="#41098407">root</a><span>|</span><a href="#41098494">parent</a><span>|</span><a href="#41098621">next</a><span>|</span><label class="collapse" for="c-41098584">[-]</label><label class="expand" for="c-41098584">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t a regular filesystem format of the card have the same effect - wipe the file? Wouldn&#x27;t such SD cards be fatally flawed for most applications? My camera, drone, etc. all format the cards.</div><br/><div id="41098697" class="c"><input type="checkbox" id="c-41098697" checked=""/><div class="controls bullet"><span class="by">billpg</span><span>|</span><a href="#41098407">root</a><span>|</span><a href="#41098584">parent</a><span>|</span><a href="#41098621">next</a><span>|</span><label class="collapse" for="c-41098697">[-]</label><label class="expand" for="c-41098697">[1 more]</label></div><br/><div class="children"><div class="content">I vaguely recall thinking the file was just some sort of serial number or stock tracking metadata when I deleted it. It might have instead failed for quite mundane reasons such as low quality manufacture. I don&#x27;t know.<p>Exposing the firmware in this fashion would be a bad idea for all of these reasons. It is a good thing that SD card manufacturers don&#x27;t do this any more, if they ever did.</div><br/></div></div></div></div></div></div><div id="41098621" class="c"><input type="checkbox" id="c-41098621" checked=""/><div class="controls bullet"><span class="by">Sakos</span><span>|</span><a href="#41098407">parent</a><span>|</span><a href="#41098494">prev</a><span>|</span><a href="#41098745">next</a><span>|</span><label class="collapse" for="c-41098621">[-]</label><label class="expand" for="c-41098621">[1 more]</label></div><br/><div class="children"><div class="content">Man, I&#x27;d love to work in that team for a year. I&#x27;ve had so many SD cards fail on me (most recently a 1TB SanDisk Extreme which was used in my Steam Deck) and it feels like most of them are junk.</div><br/></div></div></div></div><div id="41098745" class="c"><input type="checkbox" id="c-41098745" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#41098407">prev</a><span>|</span><a href="#41095507">next</a><span>|</span><label class="collapse" for="c-41098745">[-]</label><label class="expand" for="c-41098745">[3 more]</label></div><br/><div class="children"><div class="content">I am really disappointed by SD card reliability.    It seems even a little wear and the whole thing slows down massively and eventually throws read&#x2F;write errors.<p>I would like to see a card design which, instead of failing when there is flash wear, instead just gets smaller.<p>For compatibility with existing OS&#x27;s, that would take the form of a self-partition-resizing sd card.  It would understand fat32, ext3, NTFS, afs etc, and when the card is next powered up the partition would be slightly smaller and files physically at the &#x27;end&#x27; would be moved inwards.<p>For newer OS&#x27;s, a new API could be introduced which tells the OS &#x27;this card is smaller now, please give me some blocks to mark as unavailable&#x27;.<p>The now-smaller card can use the removed-and-worn-out blocks to store error correction data for the remaining blocks.    Ie. Additional error correction data on top of the data already stored within each page.<p>That effectively dramatically increases the lifespan of each page, at the cost of reduced IO performance.</div><br/><div id="41098861" class="c"><input type="checkbox" id="c-41098861" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41098745">parent</a><span>|</span><a href="#41095507">next</a><span>|</span><label class="collapse" for="c-41098861">[-]</label><label class="expand" for="c-41098861">[2 more]</label></div><br/><div class="children"><div class="content">Is there any Linux compatible file system which will be mounted redundantly without any special mount options?<p>So that for instance a 64 gigabyte would have a filesystem with 32 gigabyte space but with a lot of redundancy?<p>I know there are many ways to achieve similar outcomes but all I know of relies on knowing beforehand how to mount the thing.</div><br/><div id="41098916" class="c"><input type="checkbox" id="c-41098916" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#41098745">root</a><span>|</span><a href="#41098861">parent</a><span>|</span><a href="#41095507">next</a><span>|</span><label class="collapse" for="c-41098916">[-]</label><label class="expand" for="c-41098916">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately because of the way the SD card - computer interface works, storing everything twice on the same card doesn&#x27;t actually get you much more reliability.<p>The card is unaware of which bits of data are duplicates, and therefore can easily end up storing both copies of some data on areas of the physical flash that are weak - and this is even more likely considering they will probably be written around the same timestamp.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>