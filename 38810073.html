<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703926864451" as="style"/><link rel="stylesheet" href="styles.css?v=1703926864451"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://koka-lang.github.io/koka/doc/index.html">Koka: Strongly typed functional-style language with effect types and handlers</a> <span class="domain">(<a href="https://koka-lang.github.io">koka-lang.github.io</a>)</span></div><div class="subtext"><span>nateb2022</span> | <span>41 comments</span></div><br/><div><div id="38812959" class="c"><input type="checkbox" id="c-38812959" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#38813549">next</a><span>|</span><label class="collapse" for="c-38812959">[-]</label><label class="expand" for="c-38812959">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Koka tracks the (side) effects of every function in its type, where pure and effectful computations are distinguished. The precise effect typing gives Koka rock-solid semantics backed by well-studied category theory, which makes Koka particularly easy to reason about for both humans and compilers.<p>Pretty comical to hear the words &quot;easy to reason about&quot; and &quot;category theory&quot; in the same sentence.<p>With apologies to the Haskellers, any time &quot;category theory&quot; is mentioned I feel myself shying away, prior experience teaching me that those words mean &quot;you will spend the majority of your time working around the type system &quot;; and, &quot;we have more data types than individual bits of data that those types describe&quot;.<p>A little type system goes a long way, and there&#x27;s such a thing as too much in my opinion.<p>I was initially interested because of algebraic effects in the language because I&#x27;m told they&#x27;re basically the same as common lisp conditions. I really liked learning about conditions and I wish they were in more languages. I must confess I am less interested now.</div><br/><div id="38812973" class="c"><input type="checkbox" id="c-38812973" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#38812959">parent</a><span>|</span><a href="#38813484">next</a><span>|</span><label class="collapse" for="c-38812973">[-]</label><label class="expand" for="c-38812973">[2 more]</label></div><br/><div class="children"><div class="content">Category theory is not the headline news here, it&#x27;s safety without sacrificing performance by using a new technique to compile to binaries without a runtime or garbage collector, with potentially better deallocation performance than Rust, and functional-looking code like `array.map(func)` which performs as fast as a for-loop thanks to advanced analysis.</div><br/><div id="38813050" class="c"><input type="checkbox" id="c-38813050" checked=""/><div class="controls bullet"><span class="by">djtango</span><span>|</span><a href="#38812959">root</a><span>|</span><a href="#38812973">parent</a><span>|</span><a href="#38813484">next</a><span>|</span><label class="collapse" for="c-38813050">[-]</label><label class="expand" for="c-38813050">[1 more]</label></div><br/><div class="children"><div class="content">thanks for this, it wasn&#x27;t immediately obvious to me why the headline example was traversing a list but doing that fast without GC is cool</div><br/></div></div></div></div><div id="38813484" class="c"><input type="checkbox" id="c-38813484" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#38812959">parent</a><span>|</span><a href="#38812973">prev</a><span>|</span><a href="#38813549">next</a><span>|</span><label class="collapse" for="c-38813484">[-]</label><label class="expand" for="c-38813484">[1 more]</label></div><br/><div class="children"><div class="content">Algebraic effects are not basically the same as Common Lisp conditions.</div><br/></div></div></div></div><div id="38813549" class="c"><input type="checkbox" id="c-38813549" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#38812959">prev</a><span>|</span><a href="#38811141">next</a><span>|</span><label class="collapse" for="c-38813549">[-]</label><label class="expand" for="c-38813549">[2 more]</label></div><br/><div class="children"><div class="content">Interestingly, this seems to be sponsored by Microsoft Research, which has also heavily supported the development of and research on Haskell.<p>(Source: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;project&#x2F;koka&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;project&#x2F;koka&#x2F;</a>)</div><br/><div id="38813776" class="c"><input type="checkbox" id="c-38813776" checked=""/><div class="controls bullet"><span class="by">ed_blackburn</span><span>|</span><a href="#38813549">parent</a><span>|</span><a href="#38811141">next</a><span>|</span><label class="collapse" for="c-38813776">[-]</label><label class="expand" for="c-38813776">[1 more]</label></div><br/><div class="children"><div class="content">Did they not effectively acqui-hire or plain hire the pony lang team too?</div><br/></div></div></div></div><div id="38811141" class="c"><input type="checkbox" id="c-38811141" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38813549">prev</a><span>|</span><a href="#38813638">next</a><span>|</span><label class="collapse" for="c-38811141">[-]</label><label class="expand" for="c-38811141">[3 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>Koka: A fast functional programming language with algebraic effects</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38421003">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38421003</a> - Nov 2023 (2 comments)<p><i>The Koka Programming Language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28335043">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28335043</a> - Aug 2021 (2 comments)<p><i>Koka: A Functional Language with Effects</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27710267">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27710267</a> - July 2021 (12 comments)<p><i>A Tour of Koka (an elegant programming language with Algebraic Effects)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26292411">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26292411</a> - Feb 2021 (1 comment)<p><i>An Introduction to the Koka Programming Language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14647415">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14647415</a> - June 2017 (1 comment)<p><i>Koka – A function-oriented programming language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10131071">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10131071</a> - Aug 2015 (10 comments)<p><i>Koka a function oriented language with effect inference</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=4407415">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=4407415</a> - Aug 2012 (1 comment)</div><br/><div id="38812233" class="c"><input type="checkbox" id="c-38812233" checked=""/><div class="controls bullet"><span class="by">anfelor</span><span>|</span><a href="#38811141">parent</a><span>|</span><a href="#38811763">next</a><span>|</span><label class="collapse" for="c-38812233">[-]</label><label class="expand" for="c-38812233">[1 more]</label></div><br/><div class="children"><div class="content">Some of the research behind Koka was discussed at:<p><i>FP2: Fully In-Place Functional Programming [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36471591">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36471591</a> - July 2023 (24 comments)<p><i>Perceus: Garbage Free Reference Counting with Reuse [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25464354">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25464354</a> - Dec 2020 (44 comments)<p><i>Implementing Algebraic Effects in C</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14887341">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14887341</a> - July 2017 (21 comments)</div><br/></div></div><div id="38811763" class="c"><input type="checkbox" id="c-38811763" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38811141">parent</a><span>|</span><a href="#38812233">prev</a><span>|</span><a href="#38813638">next</a><span>|</span><label class="collapse" for="c-38811763">[-]</label><label class="expand" for="c-38811763">[1 more]</label></div><br/><div class="children"><div class="content">Nice to finally see this get some attention on the front page.</div><br/></div></div></div></div><div id="38813638" class="c"><input type="checkbox" id="c-38813638" checked=""/><div class="controls bullet"><span class="by">mrobot</span><span>|</span><a href="#38811141">prev</a><span>|</span><a href="#38811041">next</a><span>|</span><label class="collapse" for="c-38813638">[-]</label><label class="expand" for="c-38813638">[1 more]</label></div><br/><div class="children"><div class="content">I was confused because the reference counting in the &quot;Why Koka&quot; part (section 2) of the book [1] seemed mismatched, so i looked it up in their reference counting TR [2]. It turns out it uses a seemingly novel approach to reference counting where any function you pass a reference to is responsible for decrementing and possibly freeing that reference. If you need to pass a reference to two functions you have to dup it once.<p>This makes it possible for fold to free all the Cons cells as it is mapping over it. The reuse analysis is cool, too, with in-place updates of structures that won&#x27;t be referenced again.<p>[1] <a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html</a>
[2] <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;publication&#x2F;perceus-garbage-free-reference-counting-with-reuse&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;publication&#x2F;perceus...</a>  (see section 2.2)</div><br/></div></div><div id="38811041" class="c"><input type="checkbox" id="c-38811041" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#38813638">prev</a><span>|</span><a href="#38811815">next</a><span>|</span><label class="collapse" for="c-38811041">[-]</label><label class="expand" for="c-38811041">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Effect handlers let you define advanced control abstractions, like exceptions, async&#x2F;await, iterators, parsers, ambient state, or probabilistic programs, as a user library in a typed and composable way.<p>&gt; Perceus is an advanced compilation method for reference counting. This lets Koka compile directly to C code without needing a garbage collector or runtime system! This also gives Koka excellent performance in practice.<p>Effectful functional language that compiles to C? Sounds great.</div><br/><div id="38811753" class="c"><input type="checkbox" id="c-38811753" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38811041">parent</a><span>|</span><a href="#38811502">next</a><span>|</span><label class="collapse" for="c-38811753">[-]</label><label class="expand" for="c-38811753">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve only played around with it a little bit, but it really is a cool language.<p>I particularly enjoyed this presentation, which is what sold it to me as a good idea worth spending some time on: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;6OFhD_mHtKA" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;6OFhD_mHtKA</a><p>OCaml 5.0 also interestingly includes an effect handler system: <a href="https:&#x2F;&#x2F;v2.ocaml.org&#x2F;manual&#x2F;effects.html" rel="nofollow">https:&#x2F;&#x2F;v2.ocaml.org&#x2F;manual&#x2F;effects.html</a></div><br/><div id="38811892" class="c"><input type="checkbox" id="c-38811892" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#38811041">root</a><span>|</span><a href="#38811753">parent</a><span>|</span><a href="#38811502">next</a><span>|</span><label class="collapse" for="c-38811892">[-]</label><label class="expand" for="c-38811892">[2 more]</label></div><br/><div class="children"><div class="content">I’ve been following the road to OCaml 5 and the effect system is nice, but getting to have effects <i>without</i> bringing in a garbage collector seems quite special. I’m working on a C-WASM wrapper library, and one issue I struggle with in C code is dealing with async IO outside the WASM module. I haven’t looked deep into the FFI story of this new language but it would directly solve this problem that currently needs the ASYNCIFY Binaryen transform which adds a 2x size increase and 50% performance penalty. Can Koka call C in an effect? Can it suspend a stack if C calls into it? I can presumably drop koka into my existing C-WASM project with a few new Makefile rules. These are definitely places OCaml can’t go; by compiling to C Koka makes these advanced FP features much more attainable (at least, for me).</div><br/><div id="38812440" class="c"><input type="checkbox" id="c-38812440" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#38811041">root</a><span>|</span><a href="#38811892">parent</a><span>|</span><a href="#38811502">next</a><span>|</span><label class="collapse" for="c-38812440">[-]</label><label class="expand" for="c-38812440">[1 more]</label></div><br/><div class="children"><div class="content">They have a C library for writing effect handlers in C, so you could potentially just use that directly:<p><a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;nodec&#x2F;api&#x2F;group__effect.html" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;nodec&#x2F;api&#x2F;group__effect.html</a><p>On GitHub:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;libhandler">https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;libhandler</a><p>I believe it grew out of this prior work:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14887341">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14887341</a></div><br/></div></div></div></div></div></div><div id="38811502" class="c"><input type="checkbox" id="c-38811502" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#38811041">parent</a><span>|</span><a href="#38811753">prev</a><span>|</span><a href="#38811815">next</a><span>|</span><label class="collapse" for="c-38811502">[-]</label><label class="expand" for="c-38811502">[3 more]</label></div><br/><div class="children"><div class="content">Also, as a Lisp programmer, I absolutely loved reading the section at <a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-handlers" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-handlers</a> - it&#x27;s essentially like using the Common Lisp condition system, making me feel at home, except it&#x27;s more generalized (e.g. masking individual condition handlers is not generally possible in CL) and also working in a strongly statically typed environment.</div><br/><div id="38812185" class="c"><input type="checkbox" id="c-38812185" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38811041">root</a><span>|</span><a href="#38811502">parent</a><span>|</span><a href="#38811757">next</a><span>|</span><label class="collapse" for="c-38812185">[-]</label><label class="expand" for="c-38812185">[1 more]</label></div><br/><div class="children"><div class="content">In CL, you can control the visibility of restarts. In the restart-bind construct, there is a :test-function which serves as a predicate that determines whether the restart is visible. (Unfortunately, this function is referred to as a <i>condition</i>).<p>While restarts can be visible or not, I believe there is no such mechanism for handlers. However, handlers can be effectively invisible&#x2F;transparent by declining to handle a condition, which they can do simply by returning instead of perpetrating a non-local transfer.<p>Also, there doesn&#x27;t seem to be an API in Common Lisp for calculating the handlers visible at a given point for a condition of a given type. So that means that the ability of a handler to decline a condition is pretty much as good as a visibility mechanism.</div><br/></div></div><div id="38811757" class="c"><input type="checkbox" id="c-38811757" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38811041">root</a><span>|</span><a href="#38811502">parent</a><span>|</span><a href="#38812185">prev</a><span>|</span><a href="#38811815">next</a><span>|</span><label class="collapse" for="c-38811757">[-]</label><label class="expand" for="c-38811757">[1 more]</label></div><br/><div class="children"><div class="content">As far as I understand the PL theory involved, it&#x27;s statically-typed delimited continuation, which I think is even more general than the CL condition system.</div><br/></div></div></div></div></div></div><div id="38811815" class="c"><input type="checkbox" id="c-38811815" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38811041">prev</a><span>|</span><a href="#38812457">next</a><span>|</span><label class="collapse" for="c-38811815">[-]</label><label class="expand" for="c-38811815">[5 more]</label></div><br/><div class="children"><div class="content">For those who&#x27;ve used effectful languages, how much of a spaghetti code mess do they create, potentially? That&#x27;s basically my only worry with effects that can be suspended and resumed at basically any point and any location in the codebase.</div><br/><div id="38812678" class="c"><input type="checkbox" id="c-38812678" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#38811815">parent</a><span>|</span><a href="#38812457">next</a><span>|</span><label class="collapse" for="c-38812678">[-]</label><label class="expand" for="c-38812678">[4 more]</label></div><br/><div class="children"><div class="content">Preemptive multitasking is an effect handler implemented by the operating system. There are very few instances where you have to worry about process switching by the OS, basically only when you have a handle to a resource outside of your process.<p>A similar constraint will apply to algebraic effects, which is why they&#x27;re algebraic: only if your code directly depends on some effect will you have to care about effects.</div><br/><div id="38812688" class="c"><input type="checkbox" id="c-38812688" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38811815">root</a><span>|</span><a href="#38812678">parent</a><span>|</span><a href="#38812457">next</a><span>|</span><label class="collapse" for="c-38812688">[-]</label><label class="expand" for="c-38812688">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite understand, let&#x27;s say I have a bunch of effects in my code, all depending on one another. Will that make a mess? If so, how does one avoid that, or is that an inherent issue in algebraic effects systems?</div><br/><div id="38813042" class="c"><input type="checkbox" id="c-38813042" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#38811815">root</a><span>|</span><a href="#38812688">parent</a><span>|</span><a href="#38812730">next</a><span>|</span><label class="collapse" for="c-38813042">[-]</label><label class="expand" for="c-38813042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t quite understand, let&#x27;s say I have a bunch of effects in my code, all depending on one another. Will that make a mess?<p>It depends entirely on what those effects and dependencies actually are. If you really want to, you can use an effect system as a dynamically scoped imperative language, just like you can write all your Haskell code in `IO` or use exceptions for control-flow in C++. The value proposition is that you have to do it on purpose.</div><br/></div></div><div id="38812730" class="c"><input type="checkbox" id="c-38812730" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38811815">root</a><span>|</span><a href="#38812688">parent</a><span>|</span><a href="#38813042">prev</a><span>|</span><a href="#38812457">next</a><span>|</span><label class="collapse" for="c-38812730">[-]</label><label class="expand" for="c-38812730">[1 more]</label></div><br/><div class="children"><div class="content">You mean a situation where the effect handler for effect A invokes effect B? I wonder if the compiler is able to detect and prevent &quot;circular&quot; event invocations.</div><br/></div></div></div></div></div></div></div></div><div id="38812457" class="c"><input type="checkbox" id="c-38812457" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#38811815">prev</a><span>|</span><a href="#38812140">next</a><span>|</span><label class="collapse" for="c-38812457">[-]</label><label class="expand" for="c-38812457">[1 more]</label></div><br/><div class="children"><div class="content">Such a thought provoking language. Docs are a good read, and reach a standard that few production languages come close to.</div><br/></div></div><div id="38812140" class="c"><input type="checkbox" id="c-38812140" checked=""/><div class="controls bullet"><span class="by">scns</span><span>|</span><a href="#38812457">prev</a><span>|</span><a href="#38812628">next</a><span>|</span><label class="collapse" for="c-38812140">[-]</label><label class="expand" for="c-38812140">[2 more]</label></div><br/><div class="children"><div class="content">Dot Selection looks neat, no pipeline operator needed. Enables extension functions a la Kotlin too.</div><br/><div id="38812982" class="c"><input type="checkbox" id="c-38812982" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#38812140">parent</a><span>|</span><a href="#38812628">next</a><span>|</span><label class="collapse" for="c-38812982">[-]</label><label class="expand" for="c-38812982">[1 more]</label></div><br/><div class="children"><div class="content">Also known as Uniform Function Call Syntax (UFCS).</div><br/></div></div></div></div><div id="38812628" class="c"><input type="checkbox" id="c-38812628" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#38812140">prev</a><span>|</span><a href="#38811035">next</a><span>|</span><label class="collapse" for="c-38812628">[-]</label><label class="expand" for="c-38812628">[4 more]</label></div><br/><div class="children"><div class="content">Does anyone here have any experience with Koka? I&#x27;ve been following the language from afar for a while but I have yet to read an account of what it&#x27;s like to use it in practice.</div><br/><div id="38813639" class="c"><input type="checkbox" id="c-38813639" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#38812628">parent</a><span>|</span><a href="#38812865">next</a><span>|</span><label class="collapse" for="c-38813639">[-]</label><label class="expand" for="c-38813639">[1 more]</label></div><br/><div class="children"><div class="content">Last time I tried to use it (which was quite long ago), it barely had a print function, making it pretty much unusable.</div><br/></div></div><div id="38812865" class="c"><input type="checkbox" id="c-38812865" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#38812628">parent</a><span>|</span><a href="#38813639">prev</a><span>|</span><a href="#38811035">next</a><span>|</span><label class="collapse" for="c-38812865">[-]</label><label class="expand" for="c-38812865">[2 more]</label></div><br/><div class="children"><div class="content">It is self-proclaimed as a &quot;research Language&quot; on the homepage, which has kept me away so far.</div><br/><div id="38813010" class="c"><input type="checkbox" id="c-38813010" checked=""/><div class="controls bullet"><span class="by">Hugsun</span><span>|</span><a href="#38812628">root</a><span>|</span><a href="#38812865">parent</a><span>|</span><a href="#38811035">next</a><span>|</span><label class="collapse" for="c-38813010">[-]</label><label class="expand" for="c-38813010">[1 more]</label></div><br/><div class="children"><div class="content">I share this sentiment, although I have wondered if they&#x27;re being overly conservative with this statement.</div><br/></div></div></div></div></div></div><div id="38811035" class="c"><input type="checkbox" id="c-38811035" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#38812628">prev</a><span>|</span><a href="#38811862">next</a><span>|</span><label class="collapse" for="c-38811035">[-]</label><label class="expand" for="c-38811035">[8 more]</label></div><br/><div class="children"><div class="content">What are the practical advantages of Koka over say “IO a” or “Async&lt;‘t&gt;” in other languages?</div><br/><div id="38811498" class="c"><input type="checkbox" id="c-38811498" checked=""/><div class="controls bullet"><span class="by">spicebox</span><span>|</span><a href="#38811035">parent</a><span>|</span><a href="#38811046">next</a><span>|</span><label class="collapse" for="c-38811498">[-]</label><label class="expand" for="c-38811498">[2 more]</label></div><br/><div class="children"><div class="content">Monads don’t compose, effects do. ‘IO a’ works great until until you need to add another effect, for example ‘Maybe’. Then you need to bring in monad transformers and create your own monad combining the two, then rewrite all your code to lift the effects from one monad to the other. And you have to do this every time you want to add a new effect.</div><br/><div id="38813256" class="c"><input type="checkbox" id="c-38813256" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#38811035">root</a><span>|</span><a href="#38811498">parent</a><span>|</span><a href="#38811046">next</a><span>|</span><label class="collapse" for="c-38813256">[-]</label><label class="expand" for="c-38813256">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention you need monadic and nonmonadic versions of every higher order function (or so it feels like) - map &#x2F; mapM, fold &#x2F; foldM, etc.<p>This is even worse in Rust, which requires you to have a separate implementation for every effect as well (since it doesn&#x27;t have higher kinded types)</div><br/></div></div></div></div><div id="38811046" class="c"><input type="checkbox" id="c-38811046" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#38811035">parent</a><span>|</span><a href="#38811498">prev</a><span>|</span><a href="#38811478">next</a><span>|</span><label class="collapse" for="c-38811046">[-]</label><label class="expand" for="c-38811046">[4 more]</label></div><br/><div class="children"><div class="content">Monads need to wrap each other, effects are more composable</div><br/><div id="38811178" class="c"><input type="checkbox" id="c-38811178" checked=""/><div class="controls bullet"><span class="by">TheMatten</span><span>|</span><a href="#38811035">root</a><span>|</span><a href="#38811046">parent</a><span>|</span><a href="#38811478">next</a><span>|</span><label class="collapse" for="c-38811178">[-]</label><label class="expand" for="c-38811178">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Monads need to wrap each other, effects are more composable<p>It&#x27;s really trickier than algebraic effects make it seem though. Haskell-ish &quot;monad transfomers&quot; as a stack of wrappers may pick concrete ordering of effects in advance (e.g. there&#x27;s difference between `State&lt;S, Result&lt;E, T&gt;&gt;` and `Result&lt;E, State&lt;S, T&gt;&gt;`, using Rust syntax), but effect systems like one in Koka either have to do the same decision by using specific order of interpreters, or by sticking to single possible ordering, e.g. using one, more powerful monad. And then there&#x27;re questions around higher order effects - that is, effects with operations that take effectful arguments - because they have to be able to &quot;weave&quot; other effects through themselves while preserving their behaviour, and this weaving seems to be dependent on concrete choice of effects, thus not being easily composable. In a sense, languages like Koka or Unison have to be restricted in some way, giving up on some types of effects. I&#x27;m not saying that&#x27;s a bad thing though, it&#x27;s still a improvement over having single effect (IO) or no effects at all.</div><br/><div id="38811480" class="c"><input type="checkbox" id="c-38811480" checked=""/><div class="controls bullet"><span class="by">spicebox</span><span>|</span><a href="#38811035">root</a><span>|</span><a href="#38811178">parent</a><span>|</span><a href="#38811478">next</a><span>|</span><label class="collapse" for="c-38811480">[-]</label><label class="expand" for="c-38811480">[2 more]</label></div><br/><div class="children"><div class="content">Being able to change the ordering of effects on the fly is a benefit of algebraic-effect systems. As you mentioned `State&lt;S, Result&lt;E, T&gt;&gt;` and `Result&lt;E, State&lt;S, T&gt;&gt;`have very different effects. Algebraic-effects let you switch between the two behaviors when you run the effects, whereas with monad transformers you have to refactor all your code to use `State&lt;S, Result&lt;E, T&gt;&gt;` instead of `Result&lt;E, State&lt;S, T&gt;&gt;` or vice-versa</div><br/><div id="38813504" class="c"><input type="checkbox" id="c-38813504" checked=""/><div class="controls bullet"><span class="by">shirogane86x</span><span>|</span><a href="#38811035">root</a><span>|</span><a href="#38811480">parent</a><span>|</span><a href="#38811478">next</a><span>|</span><label class="collapse" for="c-38813504">[-]</label><label class="expand" for="c-38813504">[1 more]</label></div><br/><div class="children"><div class="content">You can recover the ability to reorder effects by using MTL-style type classes, so you could write that as M&lt;T&gt; where M: MonadState&lt;S&gt; + MonadError&lt;E&gt;, in rust-ish syntax. But that makes the number of trait&#x2F;typeclass implementation for each transformer explode (given a trait and a type for each transformer, it&#x27;s O(N^2)), whereas algebraic effect systems don&#x27;t really have that issue. I also have a hunch that algebraic effects(or, well, delimited continuations in general) are probably easier to optimize than monad transformers, too.</div><br/></div></div></div></div></div></div></div></div><div id="38811478" class="c"><input type="checkbox" id="c-38811478" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#38811035">parent</a><span>|</span><a href="#38811046">prev</a><span>|</span><a href="#38811862">next</a><span>|</span><label class="collapse" for="c-38811478">[-]</label><label class="expand" for="c-38811478">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s much easier to adapt existing code. There&#x27;s no need to rewrite code to use monadic binds.</div><br/></div></div></div></div><div id="38811862" class="c"><input type="checkbox" id="c-38811862" checked=""/><div class="controls bullet"><span class="by">cranberryturkey</span><span>|</span><a href="#38811035">prev</a><span>|</span><label class="collapse" for="c-38811862">[-]</label><label class="expand" for="c-38811862">[3 more]</label></div><br/><div class="children"><div class="content">does this support WASM?</div><br/><div id="38811905" class="c"><input type="checkbox" id="c-38811905" checked=""/><div class="controls bullet"><span class="by">nateb2022</span><span>|</span><a href="#38811862">parent</a><span>|</span><label class="collapse" for="c-38811905">[-]</label><label class="expand" for="c-38811905">[2 more]</label></div><br/><div class="children"><div class="content">yes, use `--target=wasm`</div><br/><div id="38812449" class="c"><input type="checkbox" id="c-38812449" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#38811862">root</a><span>|</span><a href="#38811905">parent</a><span>|</span><label class="collapse" for="c-38812449">[-]</label><label class="expand" for="c-38812449">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that wasm doesn&#x27;t allow for stack switching yet. How does koka implements effects in wasm? Heap allocated stack frames?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>