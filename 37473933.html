<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694509266329" as="style"/><link rel="stylesheet" href="styles.css?v=1694509266329"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.metalevel.at/prolog/facets">The Power of Prolog</a> <span class="domain">(<a href="https://www.metalevel.at">www.metalevel.at</a>)</span></div><div class="subtext"><span>_benj</span> | <span>33 comments</span></div><br/><div><div id="37478144" class="c"><input type="checkbox" id="c-37478144" checked=""/><div class="controls bullet"><span class="by">philjohn</span><span>|</span><a href="#37477551">next</a><span>|</span><label class="collapse" for="c-37478144">[-]</label><label class="expand" for="c-37478144">[2 more]</label></div><br/><div class="children"><div class="content">I remember learning Prolog during my degree in AI + Comp Sci about 25 years ago. Our NLP module used it heavily.<p>It was frustrating and annoying at first, but once you get comfortable, surprisingly fun (and also a great intro to recursion, as that&#x27;s the only way to iterate).</div><br/><div id="37478350" class="c"><input type="checkbox" id="c-37478350" checked=""/><div class="controls bullet"><span class="by">ggambetta</span><span>|</span><a href="#37478144">parent</a><span>|</span><a href="#37477551">next</a><span>|</span><label class="collapse" for="c-37478350">[-]</label><label class="expand" for="c-37478350">[1 more]</label></div><br/><div class="children"><div class="content">Similar experience. It was frustrating and annoying at first for me too, because I was trying to write imperative code in Prolog syntax. But once the new paradigm <i>clicked</i> in my head, OMG, I started loving it. That moment of enlightenment alone was well worth taking that class :)</div><br/></div></div></div></div><div id="37477551" class="c"><input type="checkbox" id="c-37477551" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#37478144">prev</a><span>|</span><a href="#37477882">next</a><span>|</span><label class="collapse" for="c-37477551">[-]</label><label class="expand" for="c-37477551">[18 more]</label></div><br/><div class="children"><div class="content">Prolog is awesome and I recommend learning it if only for kicks and experiencing foreign programming paradigm. Many concepts are expressed in a completely  different and (when paradigm &quot;kicks in&quot;) are arguably much simpler.<p>E.g. in Prolog you don&#x27;t usually operate on collection but instead provide information what the collection item actually is and then let the implementation figure it out. Drawing dependency tree is an effect of 3 rules: what is an entity, how to figure out that entity X and Y have relation, how to represent it.<p>I have 2 gripes with it, though. One is that it&#x27;s difficult and thus it&#x27;s hard to convince people to learn&#x2F;use it. Second - I didn&#x27;t yet found way to seamlessly integrate it into other apps (I know that FFI is an option, but it doesn&#x27;t convince me as production ready).<p>For the last couple months I&#x27;ve been looking for some more &quot;production&quot; Prolog alternatives but what I found so far (LispWorks, Franz Allegro CL) costs a kidney and is not integration friendly.<p>If anyone has success integrating Prolog in modern software please share, I&#x27;m really curious.
I&#x27;m also looking for some GUI solutions in it as XPCE doesn&#x27;t work on Mac :(<p>Oh, and check out the Swish for online notebook:
<a href="https:&#x2F;&#x2F;swish.swi-prolog.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;swish.swi-prolog.org</a></div><br/><div id="37478277" class="c"><input type="checkbox" id="c-37478277" checked=""/><div class="controls bullet"><span class="by">vintagedave</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37478309">next</a><span>|</span><label class="collapse" for="c-37478277">[-]</label><label class="expand" for="c-37478277">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If anyone has success integrating Prolog in modern software please share<p>This doesn&#x27;t directly answer you, but Prolog was used by David Hovell the Windows NT network configuration to enforce consistency [1][2].<p>I&#x27;ve heard it&#x27;s been removed since, so doesn&#x27;t count as &quot;modern&quot;. It&#x27;s a _beautiful_ application of Prolog though.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36821871">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36821871</a> which leads to <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20030218034509&#x2F;http:&#x2F;&#x2F;www.research.microsoft.com&#x2F;research&#x2F;dtg&#x2F;davidhov&#x2F;pap.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20030218034509&#x2F;http:&#x2F;&#x2F;www.resear...</a> -- very worth reading!
[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14046420">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14046420</a></div><br/></div></div><div id="37478309" class="c"><input type="checkbox" id="c-37478309" checked=""/><div class="controls bullet"><span class="by">anon____</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37478277">prev</a><span>|</span><a href="#37477817">next</a><span>|</span><label class="collapse" for="c-37478309">[-]</label><label class="expand" for="c-37478309">[1 more]</label></div><br/><div class="children"><div class="content">Racket has Racklog:<p>&gt; Racklog is an embedding of Prolog-style logic programming in Racket. “Embedding” means you don’t lose Racket: You can use Prolog-style and conventional Racket code fragments alongside each other. Racklog contains the full repertoire of Prolog features, including meta-logical and second-order (“set”) predicates, leaving out only those features that could more easily and more efficiently be done with Racket subexpressions.<p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;racklog&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;racklog&#x2F;index.html</a><p>Racket also has GUI, and basically everything else you may need.</div><br/></div></div><div id="37477817" class="c"><input type="checkbox" id="c-37477817" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37478309">prev</a><span>|</span><a href="#37478026">next</a><span>|</span><label class="collapse" for="c-37477817">[-]</label><label class="expand" for="c-37477817">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If anyone has success integrating Prolog in modern software please share, I&#x27;m really curious.<p>Not sure if these count but:<p>- Gerrit&#x27;s submit predicates are configured in Prolog. (Edit: deprecated!)<p>- An internal product I worked with at Google is built around a Datalog knowledge base that gets codegen&#x27;d. Then you can query it directly or use a UI to generate queries.<p>Both of these seem to work nicely but they&#x27;re pretty limited use cases.<p>My experience with Prolog at university was that it was pretty fun but there&#x27;s just no way I would wanna use it for anything that isn&#x27;t inherently Prolog-shaped. As soon as we were implementing nontrivial stuff in it the abstraction leaked like a sieve and you felt mostly like you were hacking against the backtracking algorithm rather than taking any actual advantage of the language.</div><br/></div></div><div id="37478026" class="c"><input type="checkbox" id="c-37478026" checked=""/><div class="controls bullet"><span class="by">maweki</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37477817">prev</a><span>|</span><a href="#37477969">next</a><span>|</span><label class="collapse" for="c-37478026">[-]</label><label class="expand" for="c-37478026">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I didn&#x27;t yet found way to seamlessly integrate it into other apps (I know that FFI is an option, but it doesn&#x27;t convince me as production ready).<p>There is indeed an issue with side-effects that doesn&#x27;t work well with the backtracking semantics. And I am not sure there&#x27;s a good solution for it. Other LP languages, like Curry, just forbid side-effects under nondeterminism and you have to collect and handle them using an implementation of effect-handlers if they aren&#x27;t at the top level. That&#x27;s a quite restrictive solution that needs a lot of discipline, a good architecture, and framework support.<p>But Prolog, doing side-effects whenever, wherever such a side-effect-entailing predicate is encountered as a proof goal doesn&#x27;t work either and you&#x27;re bound to make your life very difficult. Even if you are careful, the code that you produce, just looks like imperative code. So nothing really gained here from using Prolog.<p>I&#x27;m still looking&#x2F;researching about solutions inbetween. Without too too much success.</div><br/><div id="37478328" class="c"><input type="checkbox" id="c-37478328" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#37477551">root</a><span>|</span><a href="#37478026">parent</a><span>|</span><a href="#37477969">next</a><span>|</span><label class="collapse" for="c-37478328">[-]</label><label class="expand" for="c-37478328">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you can review Quantum Prolog&#x27;s optional reification of the regular Prolog database in order to be able to backtrack over assert&#x2F;retract and other destructive predicates to represent actions in eg. robotic planning. Works basically like a call&#x2F;1 variant where the Prolog database to evaluate against is specified as argument rather than assumed as implicit global default, with the database a freely manipulatable list term of facts or even rules. See [1].<p>[1]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;container-planning-demo&#x2F;part2.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;container-planning-demo&#x2F;part2....</a></div><br/></div></div></div></div><div id="37477969" class="c"><input type="checkbox" id="c-37477969" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37478026">prev</a><span>|</span><a href="#37478089">next</a><span>|</span><label class="collapse" for="c-37477969">[-]</label><label class="expand" for="c-37477969">[1 more]</label></div><br/><div class="children"><div class="content">While there are solutions based on foreign function interfaces and host calling conventions for particular Prologs, you&#x27;d basically integrate the kind of apps envisioned&#x2F;demoed on the Quantum Prolog site [1] like you would any other modern subsystem - as a SaaS  and&#x2F;or via containers.<p>Let&#x27;s say you have a Prolog optimization app for your business domain, such as an elaborate version of the container ship scheduling problem discussed on the site [2]. Traditionally you&#x27;d generate Prolog facts encoding the problem instance, and then invoke Prolog to solve the problem and output one or more found solutions. A variant of this expecting a certain directory structure with facts&#x2F;rules to exist is used by the Aleph machine learning package also demoed on the site [3]. This is popular and very flexible because of Prolog&#x27;s ultra-flexible term datatypes.<p>Alternatively, you can implement, in Prolog itself, a small wrapper to parse a JSON representation of your problem instance, where &quot;implement&quot; doesn&#x27;t really describe it since basic JSON parsing using Prolog&#x27;s built-in operator precedence parser is as easy as<p><pre><code>    :- op(600, xfy, :).
    
    MyJSON =
      { &quot;this&quot;: &quot;bla&quot;,
        &quot;that&quot;: 100,
        &quot;L&quot;: [ 1, &quot;two&quot;, 3 ] }
</code></pre>
but applied to standard input using term reading, provided your Prolog has curly braces (should come with ISO DCGs). The in-browser variant of Quantum Prolog [4] emits JSON right away.<p>An API&#x2F;language binding to call Prolog from a particular host environment is less suited for the kind of apps discussed on the Quantum Prolog site since these tend to be longer-running, and potentially parallelized workloads. But let&#x27;s say a multiplayer game universe represented as Prolog database (or <i>maybe</i> a highly interactive solution viewer&#x2F;picker under very particular circumstances) might need a different integration model.<p>[1]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;container-planning-demo&#x2F;part1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;container-planning-demo&#x2F;part1....</a><p>[3]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;bioinformatics-demo&#x2F;part1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;bioinformatics-demo&#x2F;part1.html</a><p>[4]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;browser-demo&#x2F;browser-demo.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;quantumprolog.sgml.io&#x2F;browser-demo&#x2F;browser-demo.html</a></div><br/></div></div><div id="37478089" class="c"><input type="checkbox" id="c-37478089" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37477969">prev</a><span>|</span><a href="#37478123">next</a><span>|</span><label class="collapse" for="c-37478089">[-]</label><label class="expand" for="c-37478089">[2 more]</label></div><br/><div class="children"><div class="content">Clojure has a Prolog library written for it called core.logic. I definitely didn&#x27;t know Prolog well enough to make good use of all the esoteric function names but it seemed cool.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.logic">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.logic</a></div><br/></div></div><div id="37478123" class="c"><input type="checkbox" id="c-37478123" checked=""/><div class="controls bullet"><span class="by">chuchana</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37478089">prev</a><span>|</span><a href="#37477679">next</a><span>|</span><label class="collapse" for="c-37478123">[-]</label><label class="expand" for="c-37478123">[1 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s not Prolog, but since you mention Lisp: have you checked out Screamer (<a href="https:&#x2F;&#x2F;nikodemus.github.io&#x2F;screamer&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nikodemus.github.io&#x2F;screamer&#x2F;</a>)?</div><br/></div></div><div id="37477679" class="c"><input type="checkbox" id="c-37477679" checked=""/><div class="controls bullet"><span class="by">pipo234</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37478123">prev</a><span>|</span><a href="#37477889">next</a><span>|</span><label class="collapse" for="c-37477679">[-]</label><label class="expand" for="c-37477679">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked a couple of years developing supply chain optimization software in C++ using ILOG constraint propagation software (Solver, now owned by IBM). At the time we considered BinProlog. It had built range propagation, compiled to native x86 and had descent FFI interop.<p>Nevertheless seems to have been abandoned in favour of SWI prolog and GNU toolchain.<p>Not sure about GUIs; I would consider that a very different expertise. We used our own canvas C++ rendering engine and some horrible integrated 4GL devtool call &quot;4D&quot;, or &quot;Fourth Dimension&quot;.<p><a href="https:&#x2F;&#x2F;www.tomshw.it&#x2F;data&#x2F;images&#x2F;2&#x2F;0&#x2F;4&#x2F;3&#x2F;infor-advanced-scheduling-19643f201a247ba8ee38058f679d40a5d.jpg" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.tomshw.it&#x2F;data&#x2F;images&#x2F;2&#x2F;0&#x2F;4&#x2F;3&#x2F;infor-advanced-sch...</a></div><br/></div></div><div id="37477889" class="c"><input type="checkbox" id="c-37477889" checked=""/><div class="controls bullet"><span class="by">hooby</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37477679">prev</a><span>|</span><a href="#37477814">next</a><span>|</span><label class="collapse" for="c-37477889">[-]</label><label class="expand" for="c-37477889">[1 more]</label></div><br/><div class="children"><div class="content">I had to do a little bit of Prolog back in University, decades ago, and it broke my head.<p>I managed to actually solve all the programming tasks we were given (and as I was the only one to do so among my peers, many copied my solutions) - but if anyone then asked me to explain how I did it, I was at a loss. I basically stared at the screen until some sort of intuition hit, and if that didn&#x27;t work, repeat the process until it does...<p>I guess the paradigm never really &quot;kicked in&quot; for me ;)</div><br/></div></div><div id="37477814" class="c"><input type="checkbox" id="c-37477814" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37477889">prev</a><span>|</span><a href="#37477875">next</a><span>|</span><label class="collapse" for="c-37477814">[-]</label><label class="expand" for="c-37477814">[1 more]</label></div><br/><div class="children"><div class="content">You may be interested in Shen. It has this KLambda kernel language that can be implemented by a host platform, which then gives you the entire Shen language that includes a Prolog. I recently learned about this.</div><br/></div></div><div id="37477875" class="c"><input type="checkbox" id="c-37477875" checked=""/><div class="controls bullet"><span class="by">OrangeRange</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37477814">prev</a><span>|</span><a href="#37477743">next</a><span>|</span><label class="collapse" for="c-37477875">[-]</label><label class="expand" for="c-37477875">[2 more]</label></div><br/><div class="children"><div class="content">When working in Java a couple of years ago I once ran into a random Prolog error. Turns out that the XML parser used by a large subset of the Java world is written in Prolog<p>(Hint: the error came from an Apache lib, just like in this link: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;3030903&#x2F;content-is-not-allowed-in-prolog-when-parsing-perfectly-valid-xml-on-gae" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;3030903&#x2F;content-is-not-a...</a>)</div><br/><div id="37478010" class="c"><input type="checkbox" id="c-37478010" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#37477551">root</a><span>|</span><a href="#37477875">parent</a><span>|</span><a href="#37477743">next</a><span>|</span><label class="collapse" for="c-37478010">[-]</label><label class="expand" for="c-37478010">[1 more]</label></div><br/><div class="children"><div class="content">Nope, that&#x27;s a misunderstanding on your part I&#x27;m afraid. The &quot;prolog&quot; in that error message&#x2F;SO question refers to an XML prolog, which is the part in an SGML&#x2F;XML document up to the first content element ie. an XML declaration and a DTD, both optional.</div><br/></div></div></div></div><div id="37477743" class="c"><input type="checkbox" id="c-37477743" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#37477551">parent</a><span>|</span><a href="#37477875">prev</a><span>|</span><a href="#37477994">next</a><span>|</span><label class="collapse" for="c-37477743">[-]</label><label class="expand" for="c-37477743">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Prolog is awesome and I recommend learning it if only for kicks and experiencing foreign programming paradigm. Many concepts are expressed in a completely different and (when paradigm &quot;kicks in&quot;) are arguably much simpler.<p>Seconded. Probably the biggest mind-explosion type experience as a programmer in my entire life. Even something simple like building a Sudoku solver is insanely fun IMO.</div><br/><div id="37477830" class="c"><input type="checkbox" id="c-37477830" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#37477551">root</a><span>|</span><a href="#37477743">parent</a><span>|</span><a href="#37477994">next</a><span>|</span><label class="collapse" for="c-37477830">[-]</label><label class="expand" for="c-37477830">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Prolog was the only time I&#x27;ve been very much mindblown when learning programming languages. Erlang&#x2F;Elixir is a close follow-up, but that was more of the seamless nature of it all and not really the ideas like Prolog.</div><br/></div></div></div></div></div></div><div id="37477882" class="c"><input type="checkbox" id="c-37477882" checked=""/><div class="controls bullet"><span class="by">hendler</span><span>|</span><a href="#37477551">prev</a><span>|</span><a href="#37477602">next</a><span>|</span><label class="collapse" for="c-37477882">[-]</label><label class="expand" for="c-37477882">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love a new way to write first order logic programs.<p>I tried to generate prolog from natural language using GPT4 with sometimes interesting results.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;HumanAssistedIntelligence&#x2F;logical">https:&#x2F;&#x2F;github.com&#x2F;HumanAssistedIntelligence&#x2F;logical</a></div><br/></div></div><div id="37477602" class="c"><input type="checkbox" id="c-37477602" checked=""/><div class="controls bullet"><span class="by">pipo234</span><span>|</span><a href="#37477882">prev</a><span>|</span><a href="#37477566">next</a><span>|</span><label class="collapse" for="c-37477602">[-]</label><label class="expand" for="c-37477602">[5 more]</label></div><br/><div class="children"><div class="content">Curious to learn whether Prolog is still an integral part for contemporary CS (proposition, predicate) Logic curriculum, natural language parsing, etc. I suppose that the built-in backtracking was the most controversial aspect, so maybe attention has shifted to Erlang, Haskell or esoteric languages like (wild) life?<p>Anyone currently in education care to comment?</div><br/><div id="37478348" class="c"><input type="checkbox" id="c-37478348" checked=""/><div class="controls bullet"><span class="by">maweki</span><span>|</span><a href="#37477602">parent</a><span>|</span><a href="#37478190">next</a><span>|</span><label class="collapse" for="c-37478348">[-]</label><label class="expand" for="c-37478348">[1 more]</label></div><br/><div class="children"><div class="content">Both my B.Sc.&#x2F;Ma.Sc. and Phd institutions (Germany) currently teach Prolog as an elective. One does it as a Bachelor&#x27;s course of symbolic AI and the other does it as a master&#x27;s course in Logic Programming and Deductive Databases (together with Datalog).</div><br/></div></div><div id="37478190" class="c"><input type="checkbox" id="c-37478190" checked=""/><div class="controls bullet"><span class="by">ekojs</span><span>|</span><a href="#37477602">parent</a><span>|</span><a href="#37478348">prev</a><span>|</span><a href="#37477779">next</a><span>|</span><label class="collapse" for="c-37478190">[-]</label><label class="expand" for="c-37478190">[1 more]</label></div><br/><div class="children"><div class="content">I recently did a stint as a TA for my university&#x27;s undergraduate Prolog course. It&#x27;s pretty much an elective here with the main goal of introducing students to a a different paradigm. Applications of Prolog for natural language were discussed but not the main focus. I reckon that the FP course (using Haskell) touch more about parsing (using parser combinators) than the Prolog course.</div><br/></div></div><div id="37477779" class="c"><input type="checkbox" id="c-37477779" checked=""/><div class="controls bullet"><span class="by">rpigab</span><span>|</span><a href="#37477602">parent</a><span>|</span><a href="#37478190">prev</a><span>|</span><a href="#37477566">next</a><span>|</span><label class="collapse" for="c-37477779">[-]</label><label class="expand" for="c-37477779">[2 more]</label></div><br/><div class="children"><div class="content">As a student, I learned Prolog and Caml in a master&#x27;s in CS in France, in 2015, though the languages we were most likely to use like Java and C had much more hours of class. I think the teachers, who are also researchers, rarely update the technologies they teach because it&#x27;s often what they learned when they started teaching.</div><br/><div id="37478149" class="c"><input type="checkbox" id="c-37478149" checked=""/><div class="controls bullet"><span class="by">pipo234</span><span>|</span><a href="#37477602">root</a><span>|</span><a href="#37477779">parent</a><span>|</span><a href="#37477566">next</a><span>|</span><label class="collapse" for="c-37478149">[-]</label><label class="expand" for="c-37478149">[1 more]</label></div><br/><div class="children"><div class="content">That sounds very familiar. ;-) (For the similar reasons I learned Pascal, Modula 2, Ada when I ought to have learned about C++, Java)<p>If <i>you</i> were a teacher now, having to explain about predicate logic and proof automation, would you choose teaching Prolog? If not, which language would you choose?</div><br/></div></div></div></div></div></div><div id="37477566" class="c"><input type="checkbox" id="c-37477566" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37477602">prev</a><span>|</span><a href="#37478326">next</a><span>|</span><label class="collapse" for="c-37477566">[-]</label><label class="expand" for="c-37477566">[4 more]</label></div><br/><div class="children"><div class="content">I’ve had a few use cases for a Prolog-suitable solution over the past decade, but there doesn’t seem to be an easily embeddable Prolog system available, or maybe there wasn’t a couple years ago. I needed a small library without IPC, sockets, forking, watchdogs, etc. Python and node bindings are a gigantic bonus.</div><br/><div id="37478224" class="c"><input type="checkbox" id="c-37478224" checked=""/><div class="controls bullet"><span class="by">grose</span><span>|</span><a href="#37477566">parent</a><span>|</span><a href="#37477707">next</a><span>|</span><label class="collapse" for="c-37478224">[-]</label><label class="expand" for="c-37478224">[1 more]</label></div><br/><div class="children"><div class="content">For Node, check out trealla-js: <a href="https:&#x2F;&#x2F;github.com&#x2F;guregu&#x2F;trealla-js">https:&#x2F;&#x2F;github.com&#x2F;guregu&#x2F;trealla-js</a>. I tried to make it as easy to embed as possible.</div><br/></div></div><div id="37477707" class="c"><input type="checkbox" id="c-37477707" checked=""/><div class="controls bullet"><span class="by">pipo234</span><span>|</span><a href="#37477566">parent</a><span>|</span><a href="#37478224">prev</a><span>|</span><a href="#37478326">next</a><span>|</span><label class="collapse" for="c-37477707">[-]</label><label class="expand" for="c-37477707">[2 more]</label></div><br/><div class="children"><div class="content">IMHO Prolog is mostly a way of thinking, of designing your software. Making a blazingly fast compiler is an art, but the basic interpreter at the heart of prolog is fairly straight forward to design yourself. Prolog isn&#x27;t as old as LISP, but keep in mind it had useful applications on contemporary hardware in the 1970s.<p>If you&#x27;re interested in doing Prolog with Python, have a look at projects like:
<a href="https:&#x2F;&#x2F;github.com&#x2F;photonlines&#x2F;Python-Prolog-Interpreter">https:&#x2F;&#x2F;github.com&#x2F;photonlines&#x2F;Python-Prolog-Interpreter</a></div><br/><div id="37478036" class="c"><input type="checkbox" id="c-37478036" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#37477566">root</a><span>|</span><a href="#37477707">parent</a><span>|</span><a href="#37478326">next</a><span>|</span><label class="collapse" for="c-37478036">[-]</label><label class="expand" for="c-37478036">[1 more]</label></div><br/><div class="children"><div class="content">I worked with a guy that was doing natural language analysis of some sort in Prolog for a contract (we worked at a game development studio, so this was entirely external).<p>I asked him how he actually used it and he basically said what you wrote here: He implemented his own interpreter (in C#) and limited backtracking considerably (as far as I understood) in order to make it useful performance-wise for their use case.</div><br/></div></div></div></div></div></div><div id="37478326" class="c"><input type="checkbox" id="c-37478326" checked=""/><div class="controls bullet"><span class="by">2-718-281-828</span><span>|</span><a href="#37477566">prev</a><span>|</span><a href="#37478018">next</a><span>|</span><label class="collapse" for="c-37478326">[-]</label><label class="expand" for="c-37478326">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently trying to learn Prolog. Reason is because I attempt to reignite my enthusiasm for IT by going back to the roots. And the joy of learning new programming languages &#x2F; paradigms was what brought me into the field more than 20 years ago.<p>I find Prolog very challenging for several reasons. I identified 3 levels of difficulty with it:<p>1) Syntax<p>2) Reasoning and Paradigm<p>3) Implementation<p>1) is things like &quot;\=&quot; for not equal. Those are mostly just inconveniences and Prolog&#x27;s age is showing there. But I still don&#x27;t have a firm grip on the pattern matching of lists.<p>2) is the whole stuff around switching mentally from functions to predicates. I often find myself trapped in trying to reason functionally and if I was very proficient in functional programming that might even work. But so far I&#x27;m still at the level of trying to wrap my head around the fact that there no return values and that sequencing via comma (which is actually a conjunction - AND) will be evaluated &quot;kind of&quot; procedural by serial evaluation. This makes it seem familiar but conflicts with the actual paradigm.<p>3) is the most critiqued aspect of it. There are many Prolog implementations it but they all seem to suffer from the same problems. Like Prolog getting lost in some tree which forces the developer to understand what the interpreter is doing to help it find the right branch. Also the aforementioned confusion that logically (A AND B) is identical to (B AND A) but in Prolog isn&#x27;t and can make the subtle difference between the program finishing successfully or running until memory is consumed.<p>In my opinion there is reason why Prolog is one of those subjects that are brought up here again and again and again but without any justification with regard to something about it being &quot;news&quot;. It&#x27;s a very fascinating paradigm and I find it very sad that it doesn&#x27;t really get any attention today. Just check the list of literature about it - there&#x27;s almost nothing and what there is either old or distinctively academic.<p>One reason clearly is the lack of convenient interfacing to other languages. Because even a Prolog genius would probably admit that there is no point in trying to implement anything IO with it.<p>I&#x27;m working through Learn Prolog Now. Which is a good book. Already ordered Prolog in Adventures. I could see several projects for it that would be a natural fit but I already anticipate that eventually my enthusiasm will fade at the point where I&#x27;m forced to dig into SWI as soon as I leave the toy level. SWI is also kind of weird. It seems to be the best choice but there are surprisingly trivial aspects about it that I find very unsatisfying (I can load a DB with &quot;[filename].&quot; but I cannot purge it before loading another DB without restarting the session ... or does somebody know how that&#x27;s done?). That&#x27;s basically what I observe as far as my as well as other people&#x27;s experience goes with it: very promising and exciting but eventually disappointing. It shouldn&#x27;t be like that.<p>I also believe that symbolic AI &#x2F; Prolog and deep learning could very well benefit from each other.</div><br/></div></div></div></div></div></div></div></body></html>