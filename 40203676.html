<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714467680628" as="style"/><link rel="stylesheet" href="styles.css?v=1714467680628"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lcamtuf.substack.com/p/that-time-i-built-an-ld_preload-worm">I Built an Ld_preload Worm</a> <span class="domain">(<a href="https://lcamtuf.substack.com">lcamtuf.substack.com</a>)</span></div><div class="subtext"><span>zdw</span> | <span>34 comments</span></div><br/><div><div id="40207076" class="c"><input type="checkbox" id="c-40207076" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#40206238">next</a><span>|</span><label class="collapse" for="c-40207076">[-]</label><label class="expand" for="c-40207076">[2 more]</label></div><br/><div class="children"><div class="content">This is a nice POC, but would be detected pretty fast in &quot;real world&quot;.<p>That &quot;printf&quot; hiding hook seems to be specifically tailored to one command (bash&#x27;s &quot;set&quot;? &quot;env&quot;?). Any other command to look at environment which does not use printf would show LD_PRELOAD just fine. I, for example, routinely use &quot;strings&quot; to examine environ of desktop processes - try intercepting <i>that</i>. There is also sorted(os.environ.keys()) from Python, and env dump at the start of CI jobs...<p>Not to mention that even if variable itself is perfectly hidden, the preload action itself is visible. LD_PRELOAD-ed libraries show up in &quot;ldd&quot; output, and in &quot;strace&quot; output as well, and in &quot;gdb&quot; outputs.<p>The &quot;propagation&quot; part is just appending to ~&#x2F;.bash_profile, which is trivially discoverable as well. You can &quot;cat&quot; the file and it&#x27;d be right there, or if you have some sort of VCS for you dotfiles, they will flag file as having been changed.<p>With enough imagination, you can figure a way to bypass <i>most</i> of those detection method.. but that &quot;most&quot; is not going to be enough. In the hypothetical example of xz-like attack, you only need one slip-up for such worm to be quickly detected, brought to light, and countermeasures brought up.<p>(targeted attacks are much scarier, but they aren&#x27;t likely to use such a crude method anyway... even PATH mangling is more subtle that that!)</div><br/><div id="40207543" class="c"><input type="checkbox" id="c-40207543" checked=""/><div class="controls bullet"><span class="by">wolfendin</span><span>|</span><a href="#40207076">parent</a><span>|</span><a href="#40206238">next</a><span>|</span><label class="collapse" for="c-40207543">[-]</label><label class="expand" for="c-40207543">[1 more]</label></div><br/><div class="children"><div class="content">The real world of 2024, or the real world when this software was written?</div><br/></div></div></div></div><div id="40206238" class="c"><input type="checkbox" id="c-40206238" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40207076">prev</a><span>|</span><a href="#40206520">next</a><span>|</span><label class="collapse" for="c-40206238">[-]</label><label class="expand" for="c-40206238">[19 more]</label></div><br/><div class="children"><div class="content">The xz debacle made me keenly aware of what a weak point the linker is, and now I kinda want a system that doesn&#x27;t have a dynamic linker at all.</div><br/><div id="40206400" class="c"><input type="checkbox" id="c-40206400" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#40206238">parent</a><span>|</span><a href="#40207079">next</a><span>|</span><label class="collapse" for="c-40206400">[-]</label><label class="expand" for="c-40206400">[1 more]</label></div><br/><div class="children"><div class="content">The linker is a convenient way to get your code to run in the right place, but the linker runs in userspace, and your code can do anything the linker does. E.g. you can scan function tables, remap pages r&#x2F;w, and interpose functions.<p>The OpenBSD folks have some good ideas against these issues, although they are targeted at things like ROP exploits. E.g. pledge, which disables certain syscalls, and immutable memory maps (<a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-tech&amp;m=166203784715942" rel="nofollow">https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-tech&amp;m=166203784715942</a>).<p>A really scary version of the xz backdoor is if it had an entire implementation of openssh in its own ctor function. Then it wouldn&#x27;t even need to interpose anything. It&#x27;s way harder to get rid of ctors.</div><br/></div></div><div id="40207079" class="c"><input type="checkbox" id="c-40207079" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40206238">parent</a><span>|</span><a href="#40206400">prev</a><span>|</span><a href="#40207123">next</a><span>|</span><label class="collapse" for="c-40207079">[-]</label><label class="expand" for="c-40207079">[2 more]</label></div><br/><div class="children"><div class="content">You might want static linking, but static link semantics are still stuck in 1978.  We really need to teach the static linker a bunch of tricks that the dynamic linker knows.<p>Also, as u&#x2F;singron notes, a debugger can do to a statically linked executable everything that TFA&#x27;s unicorns.so can do.  Static linking only makes that a wee bit harder, not that much harder, and recall that once a unicorns executable is published then the fact that static linking made it harder up to that time becomes completely irrelevant.</div><br/><div id="40207558" class="c"><input type="checkbox" id="c-40207558" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40207079">parent</a><span>|</span><a href="#40207123">next</a><span>|</span><label class="collapse" for="c-40207558">[-]</label><label class="expand" for="c-40207558">[1 more]</label></div><br/><div class="children"><div class="content">Meanwhile in Windows land, &quot;static linking&quot; is very much a thing, but it means you dynamically link only to the basic Windows API libraries (Kernel32, User32, Gdi32, Ole32, Advapi32, etc...).<p>You can&#x27;t have a windows program that doesn&#x27;t have some way to import API functions.  System call numbers are shuffled with every version change of Windows.</div><br/></div></div></div></div><div id="40207123" class="c"><input type="checkbox" id="c-40207123" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#40206238">parent</a><span>|</span><a href="#40207079">prev</a><span>|</span><a href="#40207953">next</a><span>|</span><label class="collapse" for="c-40207123">[-]</label><label class="expand" for="c-40207123">[1 more]</label></div><br/><div class="children"><div class="content">The general idea works fine without static linker though... Just replace LD_PRELOAD manipulation with PATH manipulation, and create wrapper binaries for common apps.<p>Slightly more detectable, but not by much.</div><br/></div></div><div id="40207953" class="c"><input type="checkbox" id="c-40207953" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40206238">parent</a><span>|</span><a href="#40207123">prev</a><span>|</span><a href="#40206331">next</a><span>|</span><label class="collapse" for="c-40207953">[-]</label><label class="expand" for="c-40207953">[1 more]</label></div><br/><div class="children"><div class="content">You are confusing the loader with the linker. The loader is the problem, always was. Just think of ldd exploits</div><br/></div></div><div id="40206331" class="c"><input type="checkbox" id="c-40206331" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40206238">parent</a><span>|</span><a href="#40207953">prev</a><span>|</span><a href="#40206602">next</a><span>|</span><label class="collapse" for="c-40206331">[-]</label><label class="expand" for="c-40206331">[11 more]</label></div><br/><div class="children"><div class="content">I’ve been convinced static linking is the way to go for a number of years. The benefits of dynamic linking don’t make sense anymore imo</div><br/><div id="40206724" class="c"><input type="checkbox" id="c-40206724" checked=""/><div class="controls bullet"><span class="by">tssge</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40206331">parent</a><span>|</span><a href="#40207463">next</a><span>|</span><label class="collapse" for="c-40206724">[-]</label><label class="expand" for="c-40206724">[7 more]</label></div><br/><div class="children"><div class="content">On single user systems, sure. However multi user systems can benefit greatly from dynamic linking; some highly multi user systems become impossible to create at all with only static linking (RAM demand becomes too great).<p>Dynamic linking also leads to better CPU cache utilization and thus higher performance; provided if multiple applications are actually utilizing the dynamically linked library. While RAM is somewhat abundant these days, L1&#x2F;L2&#x2F;L3 cache on your CPU most definitely isn&#x27;t.<p>Application startup times are also of higher performance when part of the code is already in memory.<p>EDIT: Let me elaborate a bit on what I mean by &quot;benefiting greatly&quot; with a real world example.<p>I have a system with around 300 tenants with a minimum of 500 PHP processes online at any given time. A single PHP process is able to load 70MB worth of dynamically linked libraries (PHP extensions) if so chosen by the tenant. I&#x27;ll just skip libc and other such libraries to give static linking a chance.<p>With dynamic linking, the maximum memory requirement is 70MB for said extensions.<p>With static linking, the maximum memory requirement is 35GB for said extensions.<p>Dynamic linking thus leads to 99,8% cost saving on memory usage. Bear in mind this is at minimum load: static linking requirements will scale linearly with load.<p>Not to even get started on the performance benefits this brings...</div><br/><div id="40207111" class="c"><input type="checkbox" id="c-40207111" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40206724">parent</a><span>|</span><a href="#40207030">next</a><span>|</span><label class="collapse" for="c-40207111">[-]</label><label class="expand" for="c-40207111">[1 more]</label></div><br/><div class="children"><div class="content">When the changes to Solaris 10 got pushed that removed static link archives for the OS&#x2F;Net core, and which replaced all the statically-linked &#x2F;bin executables with dynamically-linked versions, boot times improved drastically owing to less I&#x2F;O being needed because of the sharing.</div><br/></div></div><div id="40207030" class="c"><input type="checkbox" id="c-40207030" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40206724">parent</a><span>|</span><a href="#40207111">prev</a><span>|</span><a href="#40207463">next</a><span>|</span><label class="collapse" for="c-40207030">[-]</label><label class="expand" for="c-40207030">[5 more]</label></div><br/><div class="children"><div class="content">Are these extensions standard across your users, or are they user supplied?<p>If the former is the case, in a world where dynamic linking wasn&#x27;t &quot;the way things were done&quot;, you&#x27;d just just statically link them <i>all</i> into the PHP interpreters binary, and then only run the code to actually start them for the users that want them. Linux shares memory between the different instances of the same executable the same way it does between different instances of a shared library, there should  be no difference in cost. Today, I doubt php supports this, particularly the &quot;only run the code to actually start them&quot; part, but in principle it&#x27;s a lot simpler than dynamic linking to do that.<p>If the latter is the case, how are you getting any savings today?</div><br/><div id="40207050" class="c"><input type="checkbox" id="c-40207050" checked=""/><div class="controls bullet"><span class="by">tssge</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40207030">parent</a><span>|</span><a href="#40207463">next</a><span>|</span><label class="collapse" for="c-40207050">[-]</label><label class="expand" for="c-40207050">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Are these extensions standard across your users, or are they user supplied?<p>These extensions are standard PHP extensions, so they are the same for each process and user. Extensions like MySQL driver, Postgres driver, ImageMagick bindings and such.<p>You are correct that no savings would be possible if these were different across each user.</div><br/><div id="40207567" class="c"><input type="checkbox" id="c-40207567" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40207050">parent</a><span>|</span><a href="#40207463">next</a><span>|</span><label class="collapse" for="c-40207567">[-]</label><label class="expand" for="c-40207567">[3 more]</label></div><br/><div class="children"><div class="content">&gt; These extensions are standard PHP extensions, so they are the same for each process and user.<p>Then with static linking, the maximum memory requirement is 70MB for said extensions (statically linked into the PHP executable).</div><br/><div id="40208335" class="c"><input type="checkbox" id="c-40208335" checked=""/><div class="controls bullet"><span class="by">tssge</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40207567">parent</a><span>|</span><a href="#40207463">next</a><span>|</span><label class="collapse" for="c-40208335">[-]</label><label class="expand" for="c-40208335">[2 more]</label></div><br/><div class="children"><div class="content">Are you basically saying there is no difference in memory usage when comparing static linking and dynamic linking? Any links to more info on the matter?<p>I tested this on the machine with a static executable I compiled it looks to me that memory is not shared when statically linked. I thought the point of dynamic linking anyways was to save memory by sharing it (and disk space, though these days we have more than enough for executable code).<p>Though it could be just that I misunderstand the output of smaps_rollup.</div><br/><div id="40208618" class="c"><input type="checkbox" id="c-40208618" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40208335">parent</a><span>|</span><a href="#40207463">next</a><span>|</span><label class="collapse" for="c-40208618">[-]</label><label class="expand" for="c-40208618">[1 more]</label></div><br/><div class="children"><div class="content">Multiple executions of the same executable will share the code pages, so assuming all the users are executing the same binary on disk, the memory should be shared. Shared libraries only give you additional deduplication in the case that multiple binaries are loading the same shared libraries.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40207463" class="c"><input type="checkbox" id="c-40207463" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40206331">parent</a><span>|</span><a href="#40206724">prev</a><span>|</span><a href="#40206569">next</a><span>|</span><label class="collapse" for="c-40207463">[-]</label><label class="expand" for="c-40207463">[2 more]</label></div><br/><div class="children"><div class="content">I go back and forth on this.<p>On MacOS, I do like that the UI libraries for all applications are shipped with the OS. When the OS updates, the UI for all installed programs updates to include the new look and feel. Apple can also update them to change the way that applications render to the screen.<p>These libraries are quite large, and they probably shouldn&#x27;t be shipped with every application. If they were, it would make it a lot harder to compile an app to work with multiple versions of macos. Apps would probably break a lot more when the OS updates.<p>For shell scripts and such, I agree and I&#x27;d be happier if everything was statically linked.<p>My biggest criticism of dynamic linking is how ridiculous the situation is on debian and similar OSes. Imagine if I make some software with rust (or javascript or python or something). My software might pull in 20-100 dependencies from cargo, npm, pip, etc. If I want my software to appear in apt, the debian maintainers insist on adding a mirror of all of those dependencies into apt. So apt sort of maintains a crappy, out of date mirror of a bunch of other language-specific package managers. And as far as I know, they do this work by hand - adding misery to misery.<p>Nobody wants that. Least of all the software developers - who will get bug reports for their own software compiled with mysteriously out-of-date dependencies that they aren&#x27;t testing themselves. Its horrible.</div><br/><div id="40208690" class="c"><input type="checkbox" id="c-40208690" checked=""/><div class="controls bullet"><span class="by">AnonymousPlanet</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40207463">parent</a><span>|</span><a href="#40206569">next</a><span>|</span><label class="collapse" for="c-40208690">[-]</label><label class="expand" for="c-40208690">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand what you think pip, npm etc. have to do with dynamic linking. Those libraries get loaded in the respective interpreter, the linker doesn&#x27;t come into action at all. And security wise npm, pip and the likes are nightmares waiting to be exploited xz style. No static linking will save you from it.</div><br/></div></div></div></div><div id="40206569" class="c"><input type="checkbox" id="c-40206569" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40206331">parent</a><span>|</span><a href="#40207463">prev</a><span>|</span><a href="#40206602">next</a><span>|</span><label class="collapse" for="c-40206569">[-]</label><label class="expand" for="c-40206569">[1 more]</label></div><br/><div class="children"><div class="content">Awoken</div><br/></div></div></div></div><div id="40206602" class="c"><input type="checkbox" id="c-40206602" checked=""/><div class="controls bullet"><span class="by">jiveturkey</span><span>|</span><a href="#40206238">parent</a><span>|</span><a href="#40206331">prev</a><span>|</span><a href="#40206520">next</a><span>|</span><label class="collapse" for="c-40206602">[-]</label><label class="expand" for="c-40206602">[2 more]</label></div><br/><div class="children"><div class="content">Could you expand on how xz took advantage of the dynamic loader (I think that&#x27;s why you most likely meant)?<p>If you built your binary statically against the compromised version of xz, you&#x27;d still suffer wouldn&#x27;t you? Or did it depend on dynamic linking in some way? I&#x27;m not really that familiar with the mechanism it used, so sorry if that&#x27;s a basic question.<p>So, eg an entire distro built statically would still have been fully compromised. And without dynamic libs, you wouldn&#x27;t be able to just update the single lib, you&#x27;d have to update everything. So to the extent your own software is statically linked, your own software may be fine (because you never picked up the new update) but you are still vulnerable if the statically linked system had the bad lib linked in.</div><br/><div id="40206909" class="c"><input type="checkbox" id="c-40206909" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40206238">root</a><span>|</span><a href="#40206602">parent</a><span>|</span><a href="#40206520">next</a><span>|</span><label class="collapse" for="c-40206909">[-]</label><label class="expand" for="c-40206909">[1 more]</label></div><br/><div class="children"><div class="content">The xz hack used an ifunc resolver to load its payload, where the ifunc resolver is a function that the dynamic loader calls to figure out what the address of a symbol should be (i.e., to make something dependent on the current hardware capabilities).</div><br/></div></div></div></div></div></div><div id="40206520" class="c"><input type="checkbox" id="c-40206520" checked=""/><div class="controls bullet"><span class="by">timtzm</span><span>|</span><a href="#40206238">prev</a><span>|</span><a href="#40205887">next</a><span>|</span><label class="collapse" for="c-40206520">[-]</label><label class="expand" for="c-40206520">[6 more]</label></div><br/><div class="children"><div class="content">I still want dynamic linking, but only a few trusted library files would be allowed to make system calls. Like libc. Sorry but golang would have to change to use libc.<p>This breaks the ABI, but it breaks it for naughty programs the most.</div><br/><div id="40208621" class="c"><input type="checkbox" id="c-40208621" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#40206520">parent</a><span>|</span><a href="#40206749">next</a><span>|</span><label class="collapse" for="c-40208621">[-]</label><label class="expand" for="c-40208621">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but only a few trusted library files would be allowed to make system calls. Like libc<p>This is impossible (without having to do libc.so.7) on Linux, as:<p><pre><code>    $ nm -D &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 | grep syscall
    000000000011b520 T syscall
</code></pre>
<a href="https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;glibc&#x2F;glibc-2.39&#x2F;source&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;syscall.c#L23" rel="nofollow">https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;glibc&#x2F;glibc-2.39&#x2F;source&#x2F;sysdeps&#x2F;u...</a></div><br/></div></div><div id="40206749" class="c"><input type="checkbox" id="c-40206749" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40206520">parent</a><span>|</span><a href="#40208621">prev</a><span>|</span><a href="#40206562">next</a><span>|</span><label class="collapse" for="c-40206749">[-]</label><label class="expand" for="c-40206749">[2 more]</label></div><br/><div class="children"><div class="content">OpenBSD does this; it’s not very useful unless you have strong CFI to prevent people from doing a return-oriented attack into those libraries that are in your address space. And also note that there is a lot that you can without system calls to mess with stuff :)</div><br/><div id="40208008" class="c"><input type="checkbox" id="c-40208008" checked=""/><div class="controls bullet"><span class="by">jdsalaro</span><span>|</span><a href="#40206520">root</a><span>|</span><a href="#40206749">parent</a><span>|</span><a href="#40206562">next</a><span>|</span><label class="collapse" for="c-40208008">[-]</label><label class="expand" for="c-40208008">[1 more]</label></div><br/><div class="children"><div class="content">&gt; CFI<p>They&#x27;re referring to Control Flow Integrity [1]<p>[1] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Control-flow_integrity" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Control-flow_integrity</a></div><br/></div></div></div></div><div id="40206562" class="c"><input type="checkbox" id="c-40206562" checked=""/><div class="controls bullet"><span class="by">jiveturkey</span><span>|</span><a href="#40206520">parent</a><span>|</span><a href="#40206749">prev</a><span>|</span><a href="#40205887">next</a><span>|</span><label class="collapse" for="c-40206562">[-]</label><label class="expand" for="c-40206562">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure how it&#x27;s relevant exactly to TFA. The mechanism of propagation is an existing feature of libdl that uses an environment variable. With this worm, the loader still runs exactly as before, from libc and libdl.<p>As to restricting syscalls from certain calling libraries, macOS has this via entitlements, and I believe OpenBSD and&#x2F;or NetBSD has this in some form as well.</div><br/><div id="40206758" class="c"><input type="checkbox" id="c-40206758" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40206520">root</a><span>|</span><a href="#40206562">parent</a><span>|</span><a href="#40205887">next</a><span>|</span><label class="collapse" for="c-40206758">[-]</label><label class="expand" for="c-40206758">[1 more]</label></div><br/><div class="children"><div class="content">Entitlements cannot protect against things in your own process. They are always used to gate clients either across a kernel-user or XPC boundary.</div><br/></div></div></div></div></div></div><div id="40205887" class="c"><input type="checkbox" id="c-40205887" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#40206520">prev</a><span>|</span><a href="#40207598">next</a><span>|</span><label class="collapse" for="c-40205887">[-]</label><label class="expand" for="c-40205887">[4 more]</label></div><br/><div class="children"><div class="content">Isn’t this still actually wormable to some degree? Just among system you have access too. But imagine if any of those at all are shared…</div><br/><div id="40207107" class="c"><input type="checkbox" id="c-40207107" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#40205887">parent</a><span>|</span><a href="#40207115">next</a><span>|</span><label class="collapse" for="c-40207107">[-]</label><label class="expand" for="c-40207107">[2 more]</label></div><br/><div class="children"><div class="content">This can only propagate to other users if you are superuser on host and used &quot;sudo&quot;.<p>So yes, they will definitely propagate for a bit, but they won&#x27;t go very far unless it&#x27;s a very unusual environment.</div><br/><div id="40207374" class="c"><input type="checkbox" id="c-40207374" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#40205887">root</a><span>|</span><a href="#40207107">parent</a><span>|</span><a href="#40207115">next</a><span>|</span><label class="collapse" for="c-40207374">[-]</label><label class="expand" for="c-40207374">[1 more]</label></div><br/><div class="children"><div class="content">Shared lab machines come to mind! Often many people have sudo and sometimes there is just one shared account.</div><br/></div></div></div></div><div id="40207115" class="c"><input type="checkbox" id="c-40207115" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40205887">parent</a><span>|</span><a href="#40207107">prev</a><span>|</span><a href="#40207598">next</a><span>|</span><label class="collapse" for="c-40207115">[-]</label><label class="expand" for="c-40207115">[1 more]</label></div><br/><div class="children"><div class="content">TFA&#x27;s unicorns.so would still work today.</div><br/></div></div></div></div><div id="40207598" class="c"><input type="checkbox" id="c-40207598" checked=""/><div class="controls bullet"><span class="by">lukaszwojtow</span><span>|</span><a href="#40205887">prev</a><span>|</span><a href="#40207794">next</a><span>|</span><label class="collapse" for="c-40207598">[-]</label><label class="expand" for="c-40207598">[1 more]</label></div><br/><div class="children"><div class="content">Old lcamtuf is back!</div><br/></div></div></div></div></div></div></div></body></html>