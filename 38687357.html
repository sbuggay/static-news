<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702976459616" as="style"/><link rel="stylesheet" href="styles.css?v=1702976459616"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.highgo.ca/2023/12/18/new-in-postgresql-16-bi-directional-logical-replication/">PostgreSQL 16 Bi-Directional Logical Replication</a> <span class="domain">(<a href="https://www.highgo.ca">www.highgo.ca</a>)</span></div><div class="subtext"><span>alexzeitler</span> | <span>41 comments</span></div><br/><div><div id="38688756" class="c"><input type="checkbox" id="c-38688756" checked=""/><div class="controls bullet"><span class="by">perlgeek</span><span>|</span><a href="#38692643">next</a><span>|</span><label class="collapse" for="c-38688756">[-]</label><label class="expand" for="c-38688756">[19 more]</label></div><br/><div class="children"><div class="content">The description of preconditions seems a bit incomplete.<p>To me it seems you need to avoid certain constructs, like UNIQUE constraints. Otherwise you might have a local insert plus a replicated one, both the same value in the unique column, and different nodes reject different inserts.</div><br/><div id="38688887" class="c"><input type="checkbox" id="c-38688887" checked=""/><div class="controls bullet"><span class="by">smilliken</span><span>|</span><a href="#38688756">parent</a><span>|</span><a href="#38691216">next</a><span>|</span><label class="collapse" for="c-38688887">[-]</label><label class="expand" for="c-38688887">[17 more]</label></div><br/><div class="children"><div class="content">Agreed. Also exclusion constraints (a generalization of unique constraints). Also foreign key constraints, because one database might delete a record simultaneously with another database adding a reference to it.</div><br/><div id="38689144" class="c"><input type="checkbox" id="c-38689144" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38688887">parent</a><span>|</span><a href="#38691216">next</a><span>|</span><label class="collapse" for="c-38689144">[-]</label><label class="expand" for="c-38689144">[16 more]</label></div><br/><div class="children"><div class="content">Deleting from a database is a sucker&#x27;s bet.  If you add to a record and mark it dead there are fewer semantic problems to deal with.<p>Partial indexes give you approximately the same speedup as deletes.</div><br/><div id="38689878" class="c"><input type="checkbox" id="c-38689878" checked=""/><div class="controls bullet"><span class="by">arthurcolle</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38689144">parent</a><span>|</span><a href="#38691087">next</a><span>|</span><label class="collapse" for="c-38689878">[-]</label><label class="expand" for="c-38689878">[10 more]</label></div><br/><div class="children"><div class="content">Why is this comment greyed out? Seems like a reasonable comment</div><br/><div id="38690143" class="c"><input type="checkbox" id="c-38690143" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38689878">parent</a><span>|</span><a href="#38690015">next</a><span>|</span><label class="collapse" for="c-38690143">[-]</label><label class="expand" for="c-38690143">[5 more]</label></div><br/><div class="children"><div class="content">HN is not immune to forgetting things we used to have consensus on.<p>There&#x27;s always someone who is prepared to downvote, literally or figuratively, something that will eventually be the solution to some problem they created in production.<p>When I get downvoted for ideas and not demeanor, 2&#x2F;3rds of the time it&#x27;s just job security.</div><br/><div id="38690552" class="c"><input type="checkbox" id="c-38690552" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690143">parent</a><span>|</span><a href="#38690015">next</a><span>|</span><label class="collapse" for="c-38690552">[-]</label><label class="expand" for="c-38690552">[4 more]</label></div><br/><div class="children"><div class="content">Neutral party here: not the case, on your end, the mind-reading distracts from hearing the voice of Chesterton talking about his fence.<p>c.f. sibling comment written 10 minutes before yours, several trivial things.<p>More concretely from a downvoter:
1. I want _nothing_ to do with user data. Nothing. Toxic nuclear waste. The idea of keeping the waste on hand needs strong justification.<p>2. The idea of &quot;just leave the rows but mark is_deleted&quot; has a fundamental distate to a profession where O(n) is a constant worry.<p>3. The breezy way it dismisses this as an obvious solution that ~eveyone agrees suggets a small breadth of experience. That&#x27;s not bad! But then we&#x27;re at Chesterton&#x27;s fence.<p>In summary, you can get downvoted for ruling out someone else&#x27;s concrete lived experience, not just because your dangerous ideas threaten their paycheck (I don&#x27;t even have a job!)</div><br/><div id="38690618" class="c"><input type="checkbox" id="c-38690618" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690552">parent</a><span>|</span><a href="#38690929">next</a><span>|</span><label class="collapse" for="c-38690618">[-]</label><label class="expand" for="c-38690618">[1 more]</label></div><br/><div class="children"><div class="content">The lived experience you talk about is that this is a difficult problem without a solution, not a different solution that I dismissed. What I dismissed is the problem.<p>How do we solve X? You don&#x27;t solve X, you solve Y. The XY problem, not Chesterton&#x27;s Fence.<p>Not sure I follow you entirely on user data. There&#x27;s user data that absolutely requires an audit trail, like subscriptions or orders. There&#x27;s user data that might start out as null and eventually transition to an inane value, like avatar or self-description. You don&#x27;t need complex merge rules for that data. It possibly only happens when their account is being hacked and that&#x27;s not the data you need in that particular situation, yeah?</div><br/></div></div><div id="38690929" class="c"><input type="checkbox" id="c-38690929" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690552">parent</a><span>|</span><a href="#38690618">prev</a><span>|</span><a href="#38690015">next</a><span>|</span><label class="collapse" for="c-38690929">[-]</label><label class="expand" for="c-38690929">[2 more]</label></div><br/><div class="children"><div class="content">Couldn’t you just mark a deletion timestamp and then lazily delete later as part of a GC operation?</div><br/><div id="38691196" class="c"><input type="checkbox" id="c-38691196" checked=""/><div class="controls bullet"><span class="by">chrismarlow9</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690929">parent</a><span>|</span><a href="#38690015">next</a><span>|</span><label class="collapse" for="c-38691196">[-]</label><label class="expand" for="c-38691196">[1 more]</label></div><br/><div class="children"><div class="content">In larger systems you&#x27;re pretty much forced to do it this way or face an ugly realization once you scale. Delete from s3 is an example.<p>Under the hood most db&#x27;s do this as well (vacuum, repair database, etc).<p>At this point I&#x27;ve learned this lesson the hard way enough that I&#x27;d need to hear some really good reasons to NOT do it this way.</div><br/></div></div></div></div></div></div></div></div><div id="38690015" class="c"><input type="checkbox" id="c-38690015" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38689878">parent</a><span>|</span><a href="#38690143">prev</a><span>|</span><a href="#38691087">next</a><span>|</span><label class="collapse" for="c-38690015">[-]</label><label class="expand" for="c-38690015">[4 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t vote it down but there&#x27;s huge tradeoffs here:<p>1. Row bloat.<p>2. Bad plan estimation due to bloat.<p>3. Needing filtered indexes for anything that&#x27;s a row based unique constraint.<p>4. All history in one table means changing schemas is a PITA, and you&#x27;re backfilling stuff that&#x27;s not real.<p>5. There&#x27;s more but that&#x27;s just off the top.</div><br/><div id="38690157" class="c"><input type="checkbox" id="c-38690157" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690015">parent</a><span>|</span><a href="#38691087">next</a><span>|</span><label class="collapse" for="c-38690157">[-]</label><label class="expand" for="c-38690157">[3 more]</label></div><br/><div class="children"><div class="content">1. Most of the problem with row &#x27;bloat&#x27; is complexity of indexes, row deletion increases the number of required indexes, and lack of those indexes is a footgun<p>2. Got a citation for that? Pretty sure #3 makes that not true, but I&#x27;m open to be educated.<p>3. Yes, and? You&#x27;re going to have those indexes anyway. That&#x27;s the point.<p>4. You don&#x27;t have to have all rows in a single table just because you took delete out of any user-facing query logic.<p>5. I think you need some more examples.</div><br/><div id="38690243" class="c"><input type="checkbox" id="c-38690243" checked=""/><div class="controls bullet"><span class="by">arthurcolle</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690157">parent</a><span>|</span><a href="#38691438">next</a><span>|</span><label class="collapse" for="c-38690243">[-]</label><label class="expand" for="c-38690243">[1 more]</label></div><br/><div class="children"><div class="content">I agree with all of your comments - this is why I asked initial question because literally all his initial comments seems perfectly valid. I appreciate the discourse, and I work on this stuff every day so I was just confused</div><br/></div></div><div id="38691438" class="c"><input type="checkbox" id="c-38691438" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690157">parent</a><span>|</span><a href="#38690243">prev</a><span>|</span><a href="#38691087">next</a><span>|</span><label class="collapse" for="c-38691438">[-]</label><label class="expand" for="c-38691438">[1 more]</label></div><br/><div class="children"><div class="content">And the number of rows in the table, effectively bloating it for all time.<p>Deleting rows should generally be via the same type of query patterns you use to find them, or that&#x27;s pretty weird.<p>I think #4 is something that most people dont implement - ime they just tombstone in their own table, and then all of the other problems are pretty rampant.<p>Having separate indexes for deletes might be a thing, but taking a history of every change to a thing in a relational way is still a big pain because of the schema cost, merging changes in an audit table when its really a slowly changing dimension is really weird to most query patterns.<p>To #2 - it depends on your query engine, but if every query does have filtered indexes there&#x27;s still a cost to having two tables in one table (ignoring #4)</div><br/></div></div></div></div></div></div></div></div><div id="38691087" class="c"><input type="checkbox" id="c-38691087" checked=""/><div class="controls bullet"><span class="by">azlev</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38689144">parent</a><span>|</span><a href="#38689878">prev</a><span>|</span><a href="#38690226">next</a><span>|</span><label class="collapse" for="c-38691087">[-]</label><label class="expand" for="c-38691087">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t word that way. Delete records is how SQL works. Also it&#x27;s wiser to move old information to a separate database instead of paying maintenance costs of old or dead records. There are a lot of gotchas in keep old data, like GDPR.</div><br/></div></div><div id="38690226" class="c"><input type="checkbox" id="c-38690226" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38689144">parent</a><span>|</span><a href="#38691087">prev</a><span>|</span><a href="#38691216">next</a><span>|</span><label class="collapse" for="c-38690226">[-]</label><label class="expand" for="c-38690226">[4 more]</label></div><br/><div class="children"><div class="content">Another option is an audit log that tracks all changes to a record.</div><br/><div id="38690250" class="c"><input type="checkbox" id="c-38690250" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690226">parent</a><span>|</span><a href="#38691216">next</a><span>|</span><label class="collapse" for="c-38690250">[-]</label><label class="expand" for="c-38690250">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to do row deletions and an audit log table, but do you see a lot of people who do both? I haven&#x27;t. It&#x27;s easier to keep a FK to the mutable table.</div><br/><div id="38690506" class="c"><input type="checkbox" id="c-38690506" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690250">parent</a><span>|</span><a href="#38691216">next</a><span>|</span><label class="collapse" for="c-38690506">[-]</label><label class="expand" for="c-38690506">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but do you see a lot of people who do both?<p>Yes, pretty sure it’s very common. That doesn’t make it the greatest design, common doesn’t mean good.</div><br/><div id="38690632" class="c"><input type="checkbox" id="c-38690632" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38688756">root</a><span>|</span><a href="#38690506">parent</a><span>|</span><a href="#38691216">next</a><span>|</span><label class="collapse" for="c-38690632">[-]</label><label class="expand" for="c-38690632">[1 more]</label></div><br/><div class="children"><div class="content">I have too much scar tissue around accidental table scans caused by the fact that foreign key constraints don&#x27;t implicitly create an index. If you think logarithmic insertion time is bad for your p95 times, try quadratic times on delete operations gone horribly wrong.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38691216" class="c"><input type="checkbox" id="c-38691216" checked=""/><div class="controls bullet"><span class="by">rvdginste</span><span>|</span><a href="#38688756">parent</a><span>|</span><a href="#38688887">prev</a><span>|</span><a href="#38692643">next</a><span>|</span><label class="collapse" for="c-38691216">[-]</label><label class="expand" for="c-38691216">[1 more]</label></div><br/><div class="children"><div class="content">Would I be wrong in thinking that this &quot;bi-directional logical replication&quot; is only usable in a very limited number of use cases? As you mention, unique constraints pose a problem, and a lot of tables would have unique constraints to protect business keys?<p>The article references another article on this, the refers to the PostgreSQL documentation:<p>- conflicts [1]<p>- restrictions [2]<p>You need to be very aware of the limitations to decide whether this is usable in a specific context. I don&#x27;t think this is really intended to be used for &quot;bi-directional&quot; logical replication.<p>[1] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;logical-replication-conflicts.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;logical-replication-...</a><p>[2] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;logical-replication-restrictions.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;logical-replication-...</a></div><br/></div></div></div></div><div id="38692643" class="c"><input type="checkbox" id="c-38692643" checked=""/><div class="controls bullet"><span class="by">kroolik</span><span>|</span><a href="#38688756">prev</a><span>|</span><a href="#38688883">next</a><span>|</span><label class="collapse" for="c-38692643">[-]</label><label class="expand" for="c-38692643">[1 more]</label></div><br/><div class="children"><div class="content">I find the explanation of logical and physical replication to be weird. Seems like only logical replication transfers changes.<p>I have always thought physical replication is replicating using WAL logs, which is a stream of changes. The logical replication would execute the queries on the replicating nodes, leaving WAL management to the replica.<p>This is also the reason why physical replication requires same pg versions (there may be diffs to the physical format of data in WAL), whilst logical replication uses domain language, which is independent from physical layout.</div><br/></div></div><div id="38688883" class="c"><input type="checkbox" id="c-38688883" checked=""/><div class="controls bullet"><span class="by">egamirorrim</span><span>|</span><a href="#38692643">prev</a><span>|</span><a href="#38690271">next</a><span>|</span><label class="collapse" for="c-38688883">[-]</label><label class="expand" for="c-38688883">[16 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know that this article tackled the real elephant in the room for bi-di replication. What happens when the same insert happens on both primaries at once, who wins?</div><br/><div id="38688947" class="c"><input type="checkbox" id="c-38688947" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#38688883">parent</a><span>|</span><a href="#38691386">next</a><span>|</span><label class="collapse" for="c-38688947">[-]</label><label class="expand" for="c-38688947">[3 more]</label></div><br/><div class="children"><div class="content">They will each apply the insert locally. Then they will attempt to replicate that insert to each other. Each will attempt to apply the replicated conflicting insert, which will cause an error and halt replication for both nodes.<p>If you update the same data on both nodes, this is a recipe for almost certain disaster. Postgres is not a distributed database and this doesn&#x27;t make it one.</div><br/><div id="38689277" class="c"><input type="checkbox" id="c-38689277" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38688947">parent</a><span>|</span><a href="#38691386">next</a><span>|</span><label class="collapse" for="c-38689277">[-]</label><label class="expand" for="c-38689277">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, read the docs here [1] and really does not seem like this would be a good system to work with.  To make something fault tolerant you have to have a side subscription running watching for server errors so you can resolve these conflicts when they arise.<p>pglogical gave you the option to determine the winner of a conflicting write (which I think is preferable).  The inbuilt postgres stuff seems like it&#x27;d be rife with potential errors.<p>[1] <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;16&#x2F;logical-replication-conflicts.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;16&#x2F;logical-replication-confl...</a></div><br/><div id="38690751" class="c"><input type="checkbox" id="c-38690751" checked=""/><div class="controls bullet"><span class="by">brianwawok</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38689277">parent</a><span>|</span><a href="#38691386">next</a><span>|</span><label class="collapse" for="c-38690751">[-]</label><label class="expand" for="c-38690751">[1 more]</label></div><br/><div class="children"><div class="content">I assume you just go very basic. All updates to table X go to database Y. Don’t have all the clients slamming different databases with updates to the same stuff.<p>Not ideal but would still help with some scale stuff.</div><br/></div></div></div></div></div></div><div id="38691386" class="c"><input type="checkbox" id="c-38691386" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#38688883">parent</a><span>|</span><a href="#38688947">prev</a><span>|</span><a href="#38689015">next</a><span>|</span><label class="collapse" for="c-38691386">[-]</label><label class="expand" for="c-38691386">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s not what this is for. This is more for &quot;I have one DC in US and one in EU, and so on, with completely different customers, but if I need to I can access the data from any region anywhere&quot;.</div><br/><div id="38693031" class="c"><input type="checkbox" id="c-38693031" checked=""/><div class="controls bullet"><span class="by">collaborative</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38691386">parent</a><span>|</span><a href="#38689015">next</a><span>|</span><label class="collapse" for="c-38693031">[-]</label><label class="expand" for="c-38693031">[1 more]</label></div><br/><div class="children"><div class="content">Everyone in the thread including myself were thinking about failover and scale applications, but your post is the right answer</div><br/></div></div></div></div><div id="38689015" class="c"><input type="checkbox" id="c-38689015" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38688883">parent</a><span>|</span><a href="#38691386">prev</a><span>|</span><a href="#38689051">next</a><span>|</span><label class="collapse" for="c-38689015">[-]</label><label class="expand" for="c-38689015">[5 more]</label></div><br/><div class="children"><div class="content">Right: Is the idea here that you use UUIDs for inserted rows, hence avoiding duplicate inserts?<p>But what happens if multiple updates or deletes target the same existing row?</div><br/><div id="38690354" class="c"><input type="checkbox" id="c-38690354" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38689015">parent</a><span>|</span><a href="#38690194">next</a><span>|</span><label class="collapse" for="c-38690354">[-]</label><label class="expand" for="c-38690354">[2 more]</label></div><br/><div class="children"><div class="content">I would assume the intended use-case is a &quot;pseudo-sharded&quot; cluster.<p>In an actually-sharded cluster, some scheme (e.g. a hash ring) directs writes to particular shards, and so any given row only lives on one shard.<p>In a pseudo-sharded cluster, you still direct writes to different &quot;shards&quot; — but all the pseudo-shards also mirror each-other&#x27;s data, so every pseudo-shard actually has a complete dataset. But each row is still only <i>owned</i> by one particular shard; when updating that row, you must update it through that shard. All the data not owned by the shard, should be treated as a read-only&#x2F;immutable cache on that shard of the other shards&#x27; data.<p>Personally, though, if I were setting something like this up, rather than bi-di logical replication on a single table, I&#x27;d just partition the table with one partition per shard, and then have the &quot;owning&quot; shard be the publisher for that partition and the rest of the shards be subscribers for that partition. Same effect, much less implementation complexity and much less risk.</div><br/><div id="38690670" class="c"><input type="checkbox" id="c-38690670" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38690354">parent</a><span>|</span><a href="#38690194">next</a><span>|</span><label class="collapse" for="c-38690670">[-]</label><label class="expand" for="c-38690670">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like a smart model for thinking about this, thanks.</div><br/></div></div></div></div><div id="38690194" class="c"><input type="checkbox" id="c-38690194" checked=""/><div class="controls bullet"><span class="by">crest</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38689015">parent</a><span>|</span><a href="#38690354">prev</a><span>|</span><a href="#38689542">next</a><span>|</span><label class="collapse" for="c-38690194">[-]</label><label class="expand" for="c-38690194">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a column with a server id could work? Can you have a schema differing only in the default value for a server id column or would it be replicated as &quot;insert default value&quot;?</div><br/></div></div></div></div><div id="38689051" class="c"><input type="checkbox" id="c-38689051" checked=""/><div class="controls bullet"><span class="by">grogers</span><span>|</span><a href="#38688883">parent</a><span>|</span><a href="#38689015">prev</a><span>|</span><a href="#38690400">next</a><span>|</span><label class="collapse" for="c-38689051">[-]</label><label class="expand" for="c-38689051">[2 more]</label></div><br/><div class="children"><div class="content">In the MySQL world, bidirectional replication is common, but with at-most-one of the two being writable (the replication user can still write even if the secondary is read-only). Maybe they meant it to be similar and not truly multi-master? It does seem like a glaring omission given they talk about having two primaries.</div><br/><div id="38690676" class="c"><input type="checkbox" id="c-38690676" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38689051">parent</a><span>|</span><a href="#38690400">next</a><span>|</span><label class="collapse" for="c-38690676">[-]</label><label class="expand" for="c-38690676">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like circular replication that was possible back in MySQL 3.x using asynchronous replication, and generally not recommended for primary-primary setups.<p>I can&#x27;t speak for others but to my mind Galera or Group Replication are the &quot;modern&quot; solutions to multi-primary MySQL replication. Both are considered virtually-synchronous, and thus actively prevent conflicting queries from succeeding.</div><br/></div></div></div></div><div id="38690400" class="c"><input type="checkbox" id="c-38690400" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#38688883">parent</a><span>|</span><a href="#38689051">prev</a><span>|</span><a href="#38690247">next</a><span>|</span><label class="collapse" for="c-38690400">[-]</label><label class="expand" for="c-38690400">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the way to use this is to have two nodes but only one of which receives traffic at any one time. With an active-active setup like that, the failover process can be swift.<p>However, this is kind of a tough thing to do right -- how do really know that only one is receiving traffic? -- and I wonder if there are many cases where it is a compelling alternative to an ordinary failover setup.</div><br/></div></div><div id="38690247" class="c"><input type="checkbox" id="c-38690247" checked=""/><div class="controls bullet"><span class="by">Horffupolde</span><span>|</span><a href="#38688883">parent</a><span>|</span><a href="#38690400">prev</a><span>|</span><a href="#38690271">next</a><span>|</span><label class="collapse" for="c-38690247">[-]</label><label class="expand" for="c-38690247">[2 more]</label></div><br/><div class="children"><div class="content">You use shard-compatible ids like snowflake.</div><br/><div id="38690421" class="c"><input type="checkbox" id="c-38690421" checked=""/><div class="controls bullet"><span class="by">dhduebnnsj</span><span>|</span><a href="#38688883">root</a><span>|</span><a href="#38690247">parent</a><span>|</span><a href="#38690271">next</a><span>|</span><label class="collapse" for="c-38690421">[-]</label><label class="expand" for="c-38690421">[1 more]</label></div><br/><div class="children"><div class="content">I assumed the above poster was referring to business rules - ie you can only have 1 person per table. DB 1 seats person A, DB 2 seats person B, when they replicate there’s a constraint that fails.<p>I’m not sure how ids like that would resolve this.</div><br/></div></div></div></div></div></div><div id="38690271" class="c"><input type="checkbox" id="c-38690271" checked=""/><div class="controls bullet"><span class="by">MarvinYork</span><span>|</span><a href="#38688883">prev</a><span>|</span><a href="#38690588">next</a><span>|</span><label class="collapse" for="c-38690271">[-]</label><label class="expand" for="c-38690271">[2 more]</label></div><br/><div class="children"><div class="content">Could this handle more than two databases with this technique or would it generate the mentioned loop when a third database sends the data to multiple databases?</div><br/><div id="38690298" class="c"><input type="checkbox" id="c-38690298" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#38690271">parent</a><span>|</span><a href="#38690588">next</a><span>|</span><label class="collapse" for="c-38690298">[-]</label><label class="expand" for="c-38690298">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the implementation distinguishes between a replication client and a user&#x2F;app client specifically to prevent multiple query invocations. Network latency and CAP tradeoffs still apply of course, but you can absolutely scale well beyond two instances with this.</div><br/></div></div></div></div><div id="38690588" class="c"><input type="checkbox" id="c-38690588" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38690271">prev</a><span>|</span><label class="collapse" for="c-38690588">[-]</label><label class="expand" for="c-38690588">[2 more]</label></div><br/><div class="children"><div class="content">&#x2F;? postgres replication 
<a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;query=postgresql%20replication&amp;sort=byDate&amp;type=story" rel="nofollow noreferrer">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;que...</a><p>&quot;Pgactive: Active-Active Replication Extension for PostgreSQL on Amazon RDS&quot; (2023) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37838223">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37838223</a><p>&#x2F;? &quot;pgactive&quot; site:github.com
<a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=%22pgactive%22+site%3Agithub.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=%22pgactive%22+site%3Agithub...</a><p>cloudnative-pg&#x2F;cloudnative-pg: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;cloudnative-pg&#x2F;cloudnative-pg">https:&#x2F;&#x2F;github.com&#x2F;cloudnative-pg&#x2F;cloudnative-pg</a> :<p>&gt; <i>primary&#x2F;standby</i><p>cloudnative-pg &gt; Logical replication #13: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;cloudnative-pg&#x2F;cloudnative-pg&#x2F;issues&#x2F;13">https:&#x2F;&#x2F;github.com&#x2F;cloudnative-pg&#x2F;cloudnative-pg&#x2F;issues&#x2F;13</a><p>&#x2F;? logical replication:<p><a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=logical+replication" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=logical+replication</a><p>pgadmin docs &gt; Publication Dialog; logical replication: <a href="https:&#x2F;&#x2F;www.pgadmin.org&#x2F;docs&#x2F;pgadmin4&#x2F;development&#x2F;publication_dialog.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pgadmin.org&#x2F;docs&#x2F;pgadmin4&#x2F;development&#x2F;publicatio...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;dalibo&#x2F;pg_activity#faq">https:&#x2F;&#x2F;github.com&#x2F;dalibo&#x2F;pg_activity#faq</a> ; pip install `pg_activity[psychopg]` :<p>&gt; FAQ: <i>I can&#x27;t see my queries only TPS is shown</i><p>(How) Do any ~pg_top tools delineate logical replication activity?<p>pgcenter &gt; PostgreSQL statistics [virtual tables] (and also &#x2F;proc)
<a href="https:&#x2F;&#x2F;github.com&#x2F;lesovsky&#x2F;pgcenter#postgresql-statistics">https:&#x2F;&#x2F;github.com&#x2F;lesovsky&#x2F;pgcenter#postgresql-statistics</a><p>...<p>&quot;Show HN: ElectricSQL, Postgres to SQLite active-active sync for local-first apps&quot; (2023) from the creators of CRDTs <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37590257">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37590257</a><p>electric-sql&#x2F;electric: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;electric-sql&#x2F;electric">https:&#x2F;&#x2F;github.com&#x2F;electric-sql&#x2F;electric</a> :<p>&gt; <i>ElectricSQL is a local-first software platform that makes it easy to develop high-quality, modern apps with instant reactivity, realtime multi-user collaboration and conflict-free offline support.</i><p>&gt; Local-first <i>is a new development paradigm where your app code talks directly to an embedded local database and data syncs in the background via active-active database replication. Because the app code talks directly to a local database, apps feel instant. Because data syncs in the background via active-active replication it naturally supports multi-user collaboration and conflict-free offline</i><p>&quot;SQLedge: Replicate Postgres to SQLite on the Edge&quot; (2023) 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37067980">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37067980</a> ; gh-ost, dolt, <i>sqldiff</i><p>&#x2F;?hnlog ctrl-f Consistenc, Consensus :<p>- &quot;A few notes on message passing&quot; <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26535969">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26535969</a> :<p>&gt; <i>The C in CAP theorem is for Consistency [3][4].</i> [...]<p>&gt; <i>[3] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Consistency_model" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Consistency_model</a> </i><p>&gt; <i>[4] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CAP_theorem" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CAP_theorem</a> </i></div><br/><div id="38693192" class="c"><input type="checkbox" id="c-38693192" checked=""/><div class="controls bullet"><span class="by">MarvinYork</span><span>|</span><a href="#38690588">parent</a><span>|</span><label class="collapse" for="c-38693192">[-]</label><label class="expand" for="c-38693192">[1 more]</label></div><br/><div class="children"><div class="content">Are you ok?</div><br/></div></div></div></div></div></div></div></div></div></body></html>