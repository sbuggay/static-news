<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704358854790" as="style"/><link rel="stylesheet" href="styles.css?v=1704358854790"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://katelynsills.com/law/the-curious-case-of-md5/">The Curious Case of MD5</a> <span class="domain">(<a href="https://katelynsills.com">katelynsills.com</a>)</span></div><div class="subtext"><span>w4lker</span> | <span>86 comments</span></div><br/><div><div id="38861511" class="c"><input type="checkbox" id="c-38861511" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38863004">next</a><span>|</span><label class="collapse" for="c-38861511">[-]</label><label class="expand" for="c-38861511">[13 more]</label></div><br/><div class="children"><div class="content">The unsatisfying answer to this is probably that it just doesn&#x27;t matter. It&#x27;s not as if evidence chain of custody is assured cryptographically; it&#x27;s assured by rules and regulations and an adversarial system. If you tried to submit as evidence a forged document vouchsafed with a colliding MD5 hash, you&#x27;d be putting your own freedom at risk, because the forgery will be straightforwardly detectable  (the real document won&#x27;t have hash colliding artifacts in it).<p>None of this is to say that the legal profession shouldn&#x27;t move to SHA2; it should.</div><br/><div id="38862527" class="c"><input type="checkbox" id="c-38862527" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#38861511">parent</a><span>|</span><a href="#38861546">next</a><span>|</span><label class="collapse" for="c-38862527">[-]</label><label class="expand" for="c-38862527">[4 more]</label></div><br/><div class="children"><div class="content">You say to use SHA2, but TFA says to use SHA3 or Blake. I think your recommendation is the better one, but I feel like teasing out why because it&#x27;s interesting.<p>Firstly ... the NIST recommendation TFA links doesn&#x27;t just recommend SHA-3, it actually says &quot;Federal agencies should use SHA-2 or SHA-3 as an alternative to SHA-1.&quot; SHA-2 and SHA-3 are both valid and recommended hash functions by NIST. And while 3 is higher than 2, and SHA-3 is newer, in this case it doesn&#x27;t mean &quot;better&quot;. Being based on Keccak and a sponge construction, SHA-3 provides &quot;diversity&quot; more than &quot;improvement&quot;.<p>Secondly ... SHA2 is widely implemented in existing hardware, and it&#x27;s just currently more efficient (and likely to remain so). So why waste power, especially on something you&#x27;ll be doing in bulk.<p>O.k., so that&#x27;s why SHA-2 and not SHA-3. But Blake is worth avoiding IMO ... because the FISMA says that for Federal work, you have to use one of what NIST recommends in FIPS. Obviously the legal profession needs to be able to practice in Federal courts (Article III and administrative) ... so if you&#x27;re going to pick a new standard, pick one of those (but not SHA-3!).<p>Lastly, and this is really an aside ... it&#x27;s not uncommon for some folks to think SHA3 and SHA384 are the same thing, but they are not. SHA384 is just a variant of SHA-2 with a 384-bit digest length and correspondingly improved security margin. Other Federal standards, like CNSA, separately recommend SHA384 as a good minimum ... so it can be confusing and I think it&#x27;s understandable why some people think this is what SHA3 is just short for.</div><br/><div id="38864634" class="c"><input type="checkbox" id="c-38864634" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38862527">parent</a><span>|</span><a href="#38862791">next</a><span>|</span><label class="collapse" for="c-38864634">[-]</label><label class="expand" for="c-38864634">[1 more]</label></div><br/><div class="children"><div class="content">SHA-3 (also BLAKE2 or BLAKE3) is definitely more secure for very large documents than SHA-2.<p>The security (i.e. the difficulty in finding collisions) decreases with the length of the document for SHA-2 and it stays constant for SHA-3.<p>Nevertheless, it is unlikely that typical legal documents are big enough for this to matter, except when the hashes would be e.g. for entire seized HDDs or SSDs, so SHA-2 is an acceptable choice for replacing MD5.<p>The only reason why SHA-3 has not become widespread is that it, like also AES, requires hardware support for good performance, but for some reason Intel has not added an SHA-3 instruction to the x86 ISA. Arrow Lake S, expected to be launched at the end of this year, will add support for SHA-512 and for the Chinese standard hashes, but there is still no intention to add SHA-3 (like Arm already did).<p>Both AES and SHA-3 are not recommendable on CPUs without dedicated instructions, due to low performance, but with hardware support they become faster than any alternatives. The difference between them is that now only the cheaper microcontrollers lack AES support, while SHA-3 support is still seldom encountered.</div><br/></div></div><div id="38862791" class="c"><input type="checkbox" id="c-38862791" checked=""/><div class="controls bullet"><span class="by">akerl_</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38862527">parent</a><span>|</span><a href="#38864634">prev</a><span>|</span><a href="#38861546">next</a><span>|</span><label class="collapse" for="c-38862791">[-]</label><label class="expand" for="c-38862791">[2 more]</label></div><br/><div class="children"><div class="content">It feels like you&#x27;re just hunting for complexity a bit here. Any of SHA2, SHA3, or Blake are viable options.<p>I&#x27;d only let NIST and FIPS drive my crypto choices if I was being actively forced to do so by a government use case, and even so I&#x27;d be praying for the day that FIPS joins us in the modern era and stops tethering us to acronyms they could enumerate a decade ago.</div><br/><div id="38862829" class="c"><input type="checkbox" id="c-38862829" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38862791">parent</a><span>|</span><a href="#38861546">next</a><span>|</span><label class="collapse" for="c-38862829">[-]</label><label class="expand" for="c-38862829">[1 more]</label></div><br/><div class="children"><div class="content">He&#x27;s hunting for complexity because it&#x27;s interesting to talk about!</div><br/></div></div></div></div></div></div><div id="38861546" class="c"><input type="checkbox" id="c-38861546" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#38861511">parent</a><span>|</span><a href="#38862527">prev</a><span>|</span><a href="#38862281">next</a><span>|</span><label class="collapse" for="c-38861546">[-]</label><label class="expand" for="c-38861546">[7 more]</label></div><br/><div class="children"><div class="content">This is more or less what I learned when I worked on forensics software, the kind that was supposed to maintain this kind of chain of custody&#x2F;integrity. Like most things that touch the legal system, the presumption is that dishonesty or unsoundness in the chain of custody is fundamentally a legal problem with legal recourses, not something that can be solved with math.</div><br/><div id="38861906" class="c"><input type="checkbox" id="c-38861906" checked=""/><div class="controls bullet"><span class="by">graypegg</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38861546">parent</a><span>|</span><a href="#38862281">next</a><span>|</span><label class="collapse" for="c-38861906">[-]</label><label class="expand" for="c-38861906">[6 more]</label></div><br/><div class="children"><div class="content">I quite like the licensing trick Nintendo used on the gameboy as an example of this. [0]<p>Essentially, the gameboy expected a bitmap of the Nintendo logo to be present on the cartridge rom, and was shown on screen at boot. It had to match a version stored on the gameboy itself or else the game wouldn’t start.<p>The thinking (that I’m not sure was ever tested) was that someone producing a game that tried to trick consumers into thinking it was an official Nintendo product, would be liable for damages in a trademark lawsuit. Since the game would never start without an official Nintendo logo, the hope was to make the legal system enforce Nintendo’s licensing scheme.<p>[0] <a href="https:&#x2F;&#x2F;catskull.net&#x2F;gameboy-boot-screen-logo.html" rel="nofollow">https:&#x2F;&#x2F;catskull.net&#x2F;gameboy-boot-screen-logo.html</a></div><br/><div id="38861951" class="c"><input type="checkbox" id="c-38861951" checked=""/><div class="controls bullet"><span class="by">bentley</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38861906">parent</a><span>|</span><a href="#38862133">next</a><span>|</span><label class="collapse" for="c-38861951">[-]</label><label class="expand" for="c-38861951">[1 more]</label></div><br/><div class="children"><div class="content">The thinking was tested (in U.S. jurisdiction) in <i>Sega v. Accolade</i>. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sega_v._Accolade" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sega_v._Accolade</a><p>The court sensibly ruled that using technical means to force competitors to display your trademark against their will doesn’t mean you can then claim they’re infringing that trademark.</div><br/></div></div><div id="38862133" class="c"><input type="checkbox" id="c-38862133" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38861906">parent</a><span>|</span><a href="#38861951">prev</a><span>|</span><a href="#38861975">next</a><span>|</span><label class="collapse" for="c-38862133">[-]</label><label class="expand" for="c-38862133">[3 more]</label></div><br/><div class="children"><div class="content">Apple tried this too with Dont Steal Mac OS X.kext, which uses a haiku with a copyright message as the key to decrypt certain executables like the Finder. I don&#x27;t think it had any real-world impact.</div><br/><div id="38864509" class="c"><input type="checkbox" id="c-38864509" checked=""/><div class="controls bullet"><span class="by">radarsat1</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38862133">parent</a><span>|</span><a href="#38862314">next</a><span>|</span><label class="collapse" for="c-38864509">[-]</label><label class="expand" for="c-38864509">[1 more]</label></div><br/><div class="children"><div class="content">Also reminds me of MODULE_LICENSE and EXPORT_SYMBOL_GPL in the Linux kernel.<p><a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;process&#x2F;license-rules.html" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;process&#x2F;license-rules...</a></div><br/></div></div><div id="38862314" class="c"><input type="checkbox" id="c-38862314" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#38861511">root</a><span>|</span><a href="#38862133">parent</a><span>|</span><a href="#38864509">prev</a><span>|</span><a href="#38861975">next</a><span>|</span><label class="collapse" for="c-38862314">[-]</label><label class="expand" for="c-38862314">[1 more]</label></div><br/><div class="children"><div class="content">Pretty rich considering their history with sosumi.</div><br/></div></div></div></div></div></div></div></div><div id="38862281" class="c"><input type="checkbox" id="c-38862281" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#38861511">parent</a><span>|</span><a href="#38861546">prev</a><span>|</span><a href="#38863004">next</a><span>|</span><label class="collapse" for="c-38862281">[-]</label><label class="expand" for="c-38862281">[1 more]</label></div><br/><div class="children"><div class="content">I would say the system understands MD5 being broken, but more of usability issue the system is leaving a backdoor to keep itself safe, comes to mind how the system got threatened about Epstein and went over and under in order to keep him free, society should be worried about legal system having backdoors</div><br/></div></div></div></div><div id="38863004" class="c"><input type="checkbox" id="c-38863004" checked=""/><div class="controls bullet"><span class="by">tgamblin</span><span>|</span><a href="#38861511">prev</a><span>|</span><a href="#38863267">next</a><span>|</span><label class="collapse" for="c-38863004">[-]</label><label class="expand" for="c-38863004">[3 more]</label></div><br/><div class="children"><div class="content">The article mentions the key detail: MD5 is broken for cryptography (collisions) but not for second preimage attacks.  I was hoping there would be <i>some</i> discussion of just how much more difficult the latter is. It is <i>extremely</i> difficult.<p>Let’s ignore that no second preimage attack is currently known  for MD5. The software the author links to has a FAQ that links to a paper that lays out the second preimage complexity for MD4:<p><a href="https:&#x2F;&#x2F;who.paris.inria.fr&#x2F;Gaetan.Leurent&#x2F;files&#x2F;MD4_FSE08.pdf" rel="nofollow">https:&#x2F;&#x2F;who.paris.inria.fr&#x2F;Gaetan.Leurent&#x2F;files&#x2F;MD4_FSE08.pd...</a><p>It takes 2^102 hashes to brute force this for MD4, which is weaker than MD5. A bitcoin Antminer K7 will set you back $2,000, and it gets 58 TH&#x2F;s for sha256, which is slower than MD5 or MD4. Let’s ignore that MD5 is more complex than MD4, and let’s say conservatively that similar hardware might be twice as fast for MD5 (SHA256 is really only 20-30% slower on a cpu). It’ll take 2^102&#x2F;58e12&#x2F;2&#x2F;60&#x2F;60&#x2F;24&#x2F;365, or about 1.4 billion years to do a second preimage attack with current hardware. So you could do that 3 times before the sun dies.<p>If you want to reduce that to 1.4 years, you could maybe buy a billion K7’s for $2 trillion. And each requires 2.8kW so you’ll need to find 2.8 terawatts somewhere. That’s 34 trillion kWh for 1.4 years. US yearly energy consumption is 4 trillion kWh.<p>It will be a while, probably decades or more, before there’s a tractable second preimage attack here.<p>Yes, there are stronger hashes out there than MD5, but for file verification (which is what it’s being used for) it’s <i>fine</i>. Safe, even. The legal folks should probably switch someday, and it’ll probably be convenient to do so since many crypto libraries won’t even let you use MD5 unless you pass a “not for security” argument.<p>But there’s no crisis. They can take their time.</div><br/><div id="38864694" class="c"><input type="checkbox" id="c-38864694" checked=""/><div class="controls bullet"><span class="by">hannob</span><span>|</span><a href="#38863004">parent</a><span>|</span><a href="#38864482">next</a><span>|</span><label class="collapse" for="c-38864694">[-]</label><label class="expand" for="c-38864694">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The article mentions the key detail: MD5 is broken for cryptography (collisions) but not for second preimage attacks.<p>The problem with this argument is that people often don&#x27;t properly understanding the security requirements of systems. I can&#x27;t count the number of times I&#x27;ve seen people say &quot;md5 is fine for use case xyz&quot; where in some counterintuitive way it wasn&#x27;t fine.<p>And tbh, I don&#x27;t understand the urge of people to defend broken hash functions. Just use a safe one, even if you think you &quot;don&#x27;t need it&quot;. It doesn&#x27;t have any downsides to choose a secure hash function, and it&#x27;s far easier to do that than to actually show that you &quot;don&#x27;t need it&quot; (instead of just having a feeling you don&#x27;t need it).<p>For the unlikely event that you think that the performance matters (which is unlikely, as cryptographic hash functions are so fast that it&#x27;s really hard to build anything where the diff. between md5 and sha256 matters), even that&#x27;s covered: blake3 is faster than md5.</div><br/></div></div><div id="38864482" class="c"><input type="checkbox" id="c-38864482" checked=""/><div class="controls bullet"><span class="by">gojomo</span><span>|</span><a href="#38863004">parent</a><span>|</span><a href="#38864694">prev</a><span>|</span><a href="#38863267">next</a><span>|</span><label class="collapse" for="c-38864482">[-]</label><label class="expand" for="c-38864482">[1 more]</label></div><br/><div class="children"><div class="content">Second preimage attacks aren&#x27;t the only threat in a forensics environment.<p>Also, hand-wavy extrapolations from Bitcoin miners aren&#x27;t a reliable estimate of how fast &amp; energy-efficient dedicated MD5 hardware could become.</div><br/></div></div></div></div><div id="38863267" class="c"><input type="checkbox" id="c-38863267" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#38863004">prev</a><span>|</span><a href="#38861709">next</a><span>|</span><label class="collapse" for="c-38863267">[-]</label><label class="expand" for="c-38863267">[6 more]</label></div><br/><div class="children"><div class="content">Sigh, been having this conversation in a related codebase. Md5 is just as fine as any other generic hash function if its being used as a non-unique key, which for many cases replacing it with one of the more &quot;secure&quot; alternatives does nothing except for the fact that the resulting hashes are frequently longer, thereby further reducing the statistical chance of an accidental collision. For something like a document store, duplication system, etc, simply taking the extra step of doing a binary comparison against the text associated with the hash assures that accidental (or intentional) collisions are handled. With the bonus that you probably get to either publish a paper or detect someone trying to attack the system should the text comparison fail.<p>And given the history of cryptographic hashes, i&#x27;m even more convinced that anyone depending on sha3&#x2F;whatever being better than md5&#x2F;etc over the next 10-20 years is fooling themselves.<p>Now would I use it in a secure boot chain&#x2F;etc as a stamp of uniqueness? Probably not.</div><br/><div id="38864731" class="c"><input type="checkbox" id="c-38864731" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#38863267">parent</a><span>|</span><a href="#38864331">next</a><span>|</span><label class="collapse" for="c-38864731">[-]</label><label class="expand" for="c-38864731">[1 more]</label></div><br/><div class="children"><div class="content">Supposing I did want to use the file hash as a unique key and I really don&#x27;t want to do a byte for byte comparison... And I care about speed but not so much about bad actors, what should I use?</div><br/></div></div><div id="38864331" class="c"><input type="checkbox" id="c-38864331" checked=""/><div class="controls bullet"><span class="by">marshray</span><span>|</span><a href="#38863267">parent</a><span>|</span><a href="#38864731">prev</a><span>|</span><a href="#38863895">next</a><span>|</span><label class="collapse" for="c-38864331">[-]</label><label class="expand" for="c-38864331">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Md5 is just as fine as any other generic hash function if its being used as a non-unique key<p>MD5 brings the feature that you&#x27;ll forever be explaining why you chose a function that had already been broken for 30 years when other options were readily available.</div><br/></div></div><div id="38863895" class="c"><input type="checkbox" id="c-38863895" checked=""/><div class="controls bullet"><span class="by">jochem9</span><span>|</span><a href="#38863267">parent</a><span>|</span><a href="#38864331">prev</a><span>|</span><a href="#38861709">next</a><span>|</span><label class="collapse" for="c-38863895">[-]</label><label class="expand" for="c-38863895">[3 more]</label></div><br/><div class="children"><div class="content">The chances of having an accidental hash collision are really small.<p>I have build data warehouses with md5 as the hashing algorithm to generate keys from natural keys. Did some back of the envelope calculations back then and found that the chance of a hash collision was minute. Don&#x27;t remember the exact numbers, but somewhere in the 100s of years if I was generating keys every second.<p>This could btw very well be a thing with large volumes of data, but in many systems this absolutely not a worry.</div><br/><div id="38864432" class="c"><input type="checkbox" id="c-38864432" checked=""/><div class="controls bullet"><span class="by">brohee</span><span>|</span><a href="#38863267">root</a><span>|</span><a href="#38863895">parent</a><span>|</span><a href="#38861709">next</a><span>|</span><label class="collapse" for="c-38864432">[-]</label><label class="expand" for="c-38864432">[2 more]</label></div><br/><div class="children"><div class="content">The chance of a random collision is minute but if someone is actually building collisions the system is broken. DVC uses MD5 of file for reduplication for example and when you purposely inject files withe the same MD5 (which take seconds to build) the result is data loss.</div><br/><div id="38864557" class="c"><input type="checkbox" id="c-38864557" checked=""/><div class="controls bullet"><span class="by">Moru</span><span>|</span><a href="#38863267">root</a><span>|</span><a href="#38864432">parent</a><span>|</span><a href="#38861709">next</a><span>|</span><label class="collapse" for="c-38864557">[-]</label><label class="expand" for="c-38864557">[1 more]</label></div><br/><div class="children"><div class="content">md5 is faster due to being older and made for older hardware so I guess that is why it&#x27;s in use for things like that. All deduplicating tools I have used first check for file length before it even tries to do a checksum so I guess that would take care of some problems. It&#x27;s harder to find a collision if you have to keep the filesize the same.</div><br/></div></div></div></div></div></div></div></div><div id="38861709" class="c"><input type="checkbox" id="c-38861709" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#38863267">prev</a><span>|</span><a href="#38864683">next</a><span>|</span><label class="collapse" for="c-38861709">[-]</label><label class="expand" for="c-38861709">[2 more]</label></div><br/><div class="children"><div class="content">If you could just throw anyone who forged a digital signature in prison, you&#x27;d keep using MD5, too.<p>The reason why people like us keep changing everything for security is specifically because we have no access to justice. Computer crimes are international and difficult to prosecute, so you might as well drop an algorithm like a hot potato if anyone - even just nation state actors - could break it. We build our rules out of code because we do not have access to the material they make laws out of.<p>That being said, continuing to use MD5 is utterly inexcusable.</div><br/><div id="38864564" class="c"><input type="checkbox" id="c-38864564" checked=""/><div class="controls bullet"><span class="by">Moru</span><span>|</span><a href="#38861709">parent</a><span>|</span><a href="#38864683">next</a><span>|</span><label class="collapse" for="c-38864564">[-]</label><label class="expand" for="c-38864564">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is a thing. My arguments have bene shot down with a handwaving several times. &quot;But that would be a crime so then we call our lawyers&quot;. Feels like it would be cheaper to just use something secure than to pay a lawyer :-)</div><br/></div></div></div></div><div id="38864683" class="c"><input type="checkbox" id="c-38864683" checked=""/><div class="controls bullet"><span class="by">xpil</span><span>|</span><a href="#38861709">prev</a><span>|</span><a href="#38861650">next</a><span>|</span><label class="collapse" for="c-38864683">[-]</label><label class="expand" for="c-38864683">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, DBT is still using MD5 as the default algorithm for generating row identifiers.</div><br/></div></div><div id="38861650" class="c"><input type="checkbox" id="c-38861650" checked=""/><div class="controls bullet"><span class="by">krallja</span><span>|</span><a href="#38864683">prev</a><span>|</span><a href="#38862630">next</a><span>|</span><label class="collapse" for="c-38861650">[-]</label><label class="expand" for="c-38861650">[1 more]</label></div><br/><div class="children"><div class="content">I actually picked SHA256 for the path-prefix feature in <a href="https:&#x2F;&#x2F;jacob.jkrall.net&#x2F;benfords-law" rel="nofollow">https:&#x2F;&#x2F;jacob.jkrall.net&#x2F;benfords-law</a> for “NIST compliance.” That is, I didn’t ever want to answer “yes” to a potential customer’s CISO security surveys question like “does your application use any non-NIST-approved hashing functions?”<p>It’s frankly broken that evidence-handling doesn’t have to follow the government&#x27;s advice about hash function selection!</div><br/></div></div><div id="38862630" class="c"><input type="checkbox" id="c-38862630" checked=""/><div class="controls bullet"><span class="by">tneely</span><span>|</span><a href="#38861650">prev</a><span>|</span><a href="#38861824">next</a><span>|</span><label class="collapse" for="c-38862630">[-]</label><label class="expand" for="c-38862630">[5 more]</label></div><br/><div class="children"><div class="content">We still see heavy use of MD5 in genomics as well. It&#x27;s effectively used to generate a single identifier that can be used to reference a specific genome assembly. There have been discussions and attempts to move to other, more secure algorithms, but the community and its tooling is too deeply entrenched in using the MD5 for the reference that it would take a herculean effort to change.<p>I&#x27;m personally of the opinion that it doesn&#x27;t matter. MD5 is fine for genomics. The chances of valid genome files colliding is still extremely low, and there&#x27;s not really any relevant attack space. Replacing one assembly file with another will just break someone&#x27;s analysis pipeline, and most likely in a very clear obvious way.</div><br/><div id="38862743" class="c"><input type="checkbox" id="c-38862743" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#38862630">parent</a><span>|</span><a href="#38861824">next</a><span>|</span><label class="collapse" for="c-38862743">[-]</label><label class="expand" for="c-38862743">[4 more]</label></div><br/><div class="children"><div class="content">&gt; there&#x27;s not really any relevant attack space.<p>Then why use a cryptographic hash at all?  much better hashes out there that only strive for distribution&#x2F;avalanche.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Non-cryptographic_hash_function" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Non-cryptographic_hash_functio...</a></div><br/><div id="38862864" class="c"><input type="checkbox" id="c-38862864" checked=""/><div class="controls bullet"><span class="by">drisden84</span><span>|</span><a href="#38862630">root</a><span>|</span><a href="#38862743">parent</a><span>|</span><a href="#38864278">next</a><span>|</span><label class="collapse" for="c-38862864">[-]</label><label class="expand" for="c-38862864">[1 more]</label></div><br/><div class="children"><div class="content">MD5 has&#x2F;had a well-known &quot;media&quot; surface - lawyers&#x2F;genomics folks had heard of it. Libraries had it as an accessible function (command line utilities, even).<p>Sure, there are better non-cryptographic hashes, but, again the concern of lawyers and genomics folk is neither security nor efficiency - simplicity and &quot;works most of the time&quot; are the two metrics at stake.<p>If either laywers or genomics folks cared about document forgery of this nature (spoiler, they don&#x27;t), they would move to something like SHA3. If they had a need for high-scalability hash algorithms (spoiler, they don&#x27;t), they would switch to another faster algorithm.<p>This is a concept I understand security folks struggle to understand - sometimes we _just don&#x27;t care_. And we never should.<p>Maybe, something a struggling security enthusiast could understand - a video game.<p>If you implement e.g. a caesar cipher, you can have fun, accessible puzzle. Implementing AES in your game as a puzzle, while much harder, fails desperately at the &quot;accessibility&quot; metric. In your single player game, if you want to see some &quot;identifying hash&quot;, if you see an md5 one, that&#x27;s enough. No, you should not worry about people forging documents for your ad-hoc identification system, if you don&#x27;t have people attempting to forge in-game items. Maybe its even a <i>feature</i> that you need to forge such a hash, as a way to solve a puzzle.</div><br/></div></div><div id="38864278" class="c"><input type="checkbox" id="c-38864278" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38862630">root</a><span>|</span><a href="#38862743">parent</a><span>|</span><a href="#38862864">prev</a><span>|</span><a href="#38863019">next</a><span>|</span><label class="collapse" for="c-38864278">[-]</label><label class="expand" for="c-38864278">[1 more]</label></div><br/><div class="children"><div class="content">Because they’re known to be collision resistant (it’s a primary requirement), whereas non-cryptographic hashes are not, so now you need to evaluate each function individually for this property which is a hassle. And an unnecessary one, I doubt the computation of the hash is what genomics are bound on.</div><br/></div></div><div id="38863019" class="c"><input type="checkbox" id="c-38863019" checked=""/><div class="controls bullet"><span class="by">tneely</span><span>|</span><a href="#38862630">root</a><span>|</span><a href="#38862743">parent</a><span>|</span><a href="#38864278">prev</a><span>|</span><a href="#38861824">next</a><span>|</span><label class="collapse" for="c-38863019">[-]</label><label class="expand" for="c-38863019">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s fair - it doesn&#x27;t need to be cryptographic. But someone back in the day decided MD5 was what they wanted and it stuck. It always raises alarms with pen testers and security scans at work, and each time we have to explain that the cryptographic security is irrelevant; it&#x27;s just some unfortunate genomics standard we need to support.</div><br/></div></div></div></div></div></div><div id="38861824" class="c"><input type="checkbox" id="c-38861824" checked=""/><div class="controls bullet"><span class="by">throwaway89201</span><span>|</span><a href="#38862630">prev</a><span>|</span><a href="#38861278">next</a><span>|</span><label class="collapse" for="c-38861824">[-]</label><label class="expand" for="c-38861824">[2 more]</label></div><br/><div class="children"><div class="content">Another unfortunately place where MD5 is widely used: pirate libraries such as Library Genesis and Anna&#x27;s Archive. While content is distributed at large in torrents with SHA1-summed shards, and Anna&#x27;s Archive at least offers some structured metadata which would allow to slowly migrate away from MD5, files are still indexed using MD5 as primary key, and any other kind of file hash is nowhere to be found.<p>Pirate libraries are particularly important to preserve our cultural heritage in a transparent and trustworthy way. A role that traditional libraries sadly cannot fulfill due to draconian copyright laws, especially around digital books.  With archive.org as notable exception.</div><br/><div id="38862959" class="c"><input type="checkbox" id="c-38862959" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38861824">parent</a><span>|</span><a href="#38861278">next</a><span>|</span><label class="collapse" for="c-38862959">[-]</label><label class="expand" for="c-38862959">[1 more]</label></div><br/><div class="children"><div class="content">It should be noted that md5 is probably still secure for this usecase (maybe you could do a bait and switch with a specificly prepared file, but you can&#x27;t force a collision with a non-evil file)<p>Still, they should switch. Sha1 is not good either.</div><br/></div></div></div></div><div id="38861278" class="c"><input type="checkbox" id="c-38861278" checked=""/><div class="controls bullet"><span class="by">kozak</span><span>|</span><a href="#38861824">prev</a><span>|</span><a href="#38864478">next</a><span>|</span><label class="collapse" for="c-38861278">[-]</label><label class="expand" for="c-38861278">[9 more]</label></div><br/><div class="children"><div class="content">I still use MD5 as a 128-bit checksum algorithm that is fast and universally supported and compatible everywhere. In this role it&#x27;s still useful, just don&#x27;t expect it to be a cryptographic hash anymore.</div><br/><div id="38861493" class="c"><input type="checkbox" id="c-38861493" checked=""/><div class="controls bullet"><span class="by">ms512</span><span>|</span><a href="#38861278">parent</a><span>|</span><a href="#38861461">next</a><span>|</span><label class="collapse" for="c-38861493">[-]</label><label class="expand" for="c-38861493">[2 more]</label></div><br/><div class="children"><div class="content">When you don&#x27;t have a need for a cryptographic digest, it&#x27;s important to think of the channel&#x27;s bit error distribution in selecting a checksum algorithm.<p>Different checksum algorithms can provide better error detection for specific channel error models (potentially even with fewer bits). Non-cryptographic checksums are typically designed for various failure models like a burst of corrupt bits, trading off what they do&#x2F;don&#x27;t detect to better match detection of corruption in the data they will protect.<p>For example, if you know that there will be at most one bit flip in your message, a single bit checksum (parity check) is sufficient to identify that an error occurred, regardless of your message size. (Note that this is an illustrative example only, since, typically, messages have a certain number of errors for a certain number of message bits -- the expected number of errors depends on the size of the message.)</div><br/><div id="38862912" class="c"><input type="checkbox" id="c-38862912" checked=""/><div class="controls bullet"><span class="by">drisden84</span><span>|</span><a href="#38861278">root</a><span>|</span><a href="#38861493">parent</a><span>|</span><a href="#38861461">next</a><span>|</span><label class="collapse" for="c-38862912">[-]</label><label class="expand" for="c-38862912">[1 more]</label></div><br/><div class="children"><div class="content">&quot;When you don&#x27;t have a need for a cryptographic digest, it&#x27;s important to think of the channel&#x27;s bit error distribution in selecting a checksum algorithm.&quot;<p>Important real-life-facts.<p>There was no &quot;give-me-an-appropriate-hash&quot; function.<p>There <i>was</i>:<p>md5sum yourfile.txt<p>Nobody wants to think about &quot;channel&#x27;s bit error distribution&quot; in a non-security critical context. In fact, its irrelevant, and possibly a usability issue.</div><br/></div></div></div></div><div id="38861461" class="c"><input type="checkbox" id="c-38861461" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#38861278">parent</a><span>|</span><a href="#38861493">prev</a><span>|</span><a href="#38862345">next</a><span>|</span><label class="collapse" for="c-38861461">[-]</label><label class="expand" for="c-38861461">[5 more]</label></div><br/><div class="children"><div class="content">While I see the point, what starts as a checksum can easily become relied upon for security over time, after all, checking whether bits have been modified accidentally on purpose, is a subtle distinction in many systems.<p>SHA256 is also near universally supported and doesn’t have this drawback. The only cases where MD5 would be available and SHA256 wouldn’t, is systems that are out of security support anyway, where there are bigger problems to contend with.</div><br/><div id="38861490" class="c"><input type="checkbox" id="c-38861490" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#38861278">root</a><span>|</span><a href="#38861461">parent</a><span>|</span><a href="#38863178">next</a><span>|</span><label class="collapse" for="c-38861490">[-]</label><label class="expand" for="c-38861490">[3 more]</label></div><br/><div class="children"><div class="content">SHA256 is something like 30 percent slower than MD5.<p>I&#x27;d suggest using Adler (what zlib does) for a simple and fast checksum. Then that should, one hopes, be painfully obvious to be a bad fit for anything security related.</div><br/><div id="38862828" class="c"><input type="checkbox" id="c-38862828" checked=""/><div class="controls bullet"><span class="by">AlienRobot</span><span>|</span><a href="#38861278">root</a><span>|</span><a href="#38861490">parent</a><span>|</span><a href="#38863178">next</a><span>|</span><label class="collapse" for="c-38862828">[-]</label><label class="expand" for="c-38862828">[2 more]</label></div><br/><div class="children"><div class="content">In Python the Adler library returns a 32 bit checksum. It works pretty well when you&#x27;re comparing one file to another file. It doesn&#x27;t work pretty well if you want to, for example, create a quick fingerprint that (tries to) uniquely identify tens of thousands of files.<p>On StackOverflow I saw someone say that they got hash collisions in MD5 (128 bit) after hashing around 20k files.<p>When I tried making something similar I figured if I added the size of the file in bytes to the hash that would decrease the number of hash collisions since you would need a permutation of bytes in a set of bytes of same size to generate the same MD5 hash to get a collision. Still feels random and unavoidable in the greater scheme of things, though.</div><br/><div id="38862873" class="c"><input type="checkbox" id="c-38862873" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#38861278">root</a><span>|</span><a href="#38862828">parent</a><span>|</span><a href="#38863178">next</a><span>|</span><label class="collapse" for="c-38862873">[-]</label><label class="expand" for="c-38862873">[1 more]</label></div><br/><div class="children"><div class="content">When making a dupe detector some decades ago, I kept the filesize outside of the hash.<p>No need to compute the hash until there&#x27;s at least two files with the same size.</div><br/></div></div></div></div></div></div><div id="38863178" class="c"><input type="checkbox" id="c-38863178" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#38861278">root</a><span>|</span><a href="#38861461">parent</a><span>|</span><a href="#38861490">prev</a><span>|</span><a href="#38862345">next</a><span>|</span><label class="collapse" for="c-38863178">[-]</label><label class="expand" for="c-38863178">[1 more]</label></div><br/><div class="children"><div class="content">This happened to me. Users initially couldn&#x27;t directly control the content being hashed, because it contained a random element (via UUID). Later, the API surface expanded.<p>Luckily, my personal rule is to default to a cryptographic hash unless I can convince myself that cryptographic robustness will never matter and performance definitely will matter, rather than the other way around.<p>In this specific case all users were internal to the company, so it wouldn&#x27;t have really mattered if it was vulnerable. But it could just have easily been an external user-facing thing.</div><br/></div></div></div></div><div id="38862345" class="c"><input type="checkbox" id="c-38862345" checked=""/><div class="controls bullet"><span class="by">charlieyu1</span><span>|</span><a href="#38861278">parent</a><span>|</span><a href="#38861461">prev</a><span>|</span><a href="#38864478">next</a><span>|</span><label class="collapse" for="c-38862345">[-]</label><label class="expand" for="c-38862345">[1 more]</label></div><br/><div class="children"><div class="content">You may as well use CRC32 or Alder32.</div><br/></div></div></div></div><div id="38864478" class="c"><input type="checkbox" id="c-38864478" checked=""/><div class="controls bullet"><span class="by">tcper</span><span>|</span><a href="#38861278">prev</a><span>|</span><a href="#38862901">next</a><span>|</span><label class="collapse" for="c-38864478">[-]</label><label class="expand" for="c-38864478">[1 more]</label></div><br/><div class="children"><div class="content">In other industries, MD5 collision is the most minor problem, it just works, and God know when&#x2F;how they encounter collision, so just use it.</div><br/></div></div><div id="38862901" class="c"><input type="checkbox" id="c-38862901" checked=""/><div class="controls bullet"><span class="by">OhMeadhbh</span><span>|</span><a href="#38864478">prev</a><span>|</span><a href="#38864115">next</a><span>|</span><label class="collapse" for="c-38862901">[-]</label><label class="expand" for="c-38862901">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a difference between finding a collision and finding a second pre-image.  While I agree you shouldn&#x27;t use MD5, and absolutely don&#x27;t use a signature algorithm which uses it, finding a second pre-image is harder than finding an arbitrary collision with MD5.<p>An &quot;arbitrary collision&quot; here means you can find two inputs (pre-images) which hash to the same thing.  Like you ran some code and discovered that &quot;SDFKLHKLJxchjasdfgklhjaskdhjlf9&quot; hashed to the same thing as &quot;klhkasdfhjkl899078790&quot;.  Finding a second pre-image means you start with one message, like &quot;ALL QUIET. REMAIN CALM.&quot; and figured out that &quot;ATTACK AT DAWN 051928&quot; hashes to the same MIC.<p>I can&#x27;t believe I&#x27;m defending using MD5.  But... finding second pre-images is still hard.  Sasaki &amp; Aoki say it&#x27;s got a complexity of around 2^116.9 and requires 11 * 2^45  words of memory (thought 1400Tb isn&#x27;t <i>THAT</i> outlandish these days.)<p>Still... statements like &quot;finding a second pre-image is hard&quot; don&#x27;t age well and will guarantee a tractable second pre-image attack will be published tomorrow.<p>But... if you have a bunch of docs and you&#x27;re not signing them or asking people to trust the hash of each doc, you can (reasonably) quickly de-dup by sorting by MD5 hash and then looking for dups.  Which is how many people use MD5.  And they continue using MD5 because multiple organizations have similar lists and if you wanted to change it, you would need to get everyone to move to a different algorithm.<p>But yeah... at this point we should assume someone will publish a tractable second pre-image attack &quot;any day now&quot; and get to work migrating from MD5 to MD5 : Next Generation.  But good luck getting more than 2 people to agree to what the next preferred hash algorithm should be.</div><br/><div id="38862933" class="c"><input type="checkbox" id="c-38862933" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38862901">parent</a><span>|</span><a href="#38864115">next</a><span>|</span><label class="collapse" for="c-38862933">[-]</label><label class="expand" for="c-38862933">[2 more]</label></div><br/><div class="children"><div class="content">So if the document is evidence , then its probably created by the attacker. This seems like a setup where collision is more relavent than 2nd preimage.</div><br/><div id="38864170" class="c"><input type="checkbox" id="c-38864170" checked=""/><div class="controls bullet"><span class="by">OhMeadhbh</span><span>|</span><a href="#38862901">root</a><span>|</span><a href="#38862933">parent</a><span>|</span><a href="#38864115">next</a><span>|</span><label class="collapse" for="c-38864170">[-]</label><label class="expand" for="c-38864170">[1 more]</label></div><br/><div class="children"><div class="content">How so?</div><br/></div></div></div></div></div></div><div id="38864115" class="c"><input type="checkbox" id="c-38864115" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#38862901">prev</a><span>|</span><a href="#38861865">next</a><span>|</span><label class="collapse" for="c-38864115">[-]</label><label class="expand" for="c-38864115">[1 more]</label></div><br/><div class="children"><div class="content">Despite official statements about MD5, the leading e-discovery software provider uses sha256: <a href="https:&#x2F;&#x2F;help.relativity.com&#x2F;9.0&#x2F;Content&#x2F;Relativity&#x2F;Processing&#x2F;De-duplication_considerations.htm#:~:text=Relativity%20calculates%20the%20SHA256%20hash,loose%20files%20to%20identify%20duplicates" rel="nofollow">https:&#x2F;&#x2F;help.relativity.com&#x2F;9.0&#x2F;Content&#x2F;Relativity&#x2F;Processin...</a>.<p>And it is unclear if that is in any way unusual.</div><br/></div></div><div id="38861865" class="c"><input type="checkbox" id="c-38861865" checked=""/><div class="controls bullet"><span class="by">callalex</span><span>|</span><a href="#38864115">prev</a><span>|</span><a href="#38862246">next</a><span>|</span><label class="collapse" for="c-38861865">[-]</label><label class="expand" for="c-38861865">[3 more]</label></div><br/><div class="children"><div class="content">This is the same legal system that still uses polygraphs as “lie defectors” and known-junk DNA matching tests as fact, so this isn’t exactly shocking.</div><br/><div id="38861871" class="c"><input type="checkbox" id="c-38861871" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#38861865">parent</a><span>|</span><a href="#38862246">next</a><span>|</span><label class="collapse" for="c-38861871">[-]</label><label class="expand" for="c-38861871">[2 more]</label></div><br/><div class="children"><div class="content">What court has admitted polygraph test results into evidence? Surely, none in the US.</div><br/><div id="38862007" class="c"><input type="checkbox" id="c-38862007" checked=""/><div class="controls bullet"><span class="by">randombits0</span><span>|</span><a href="#38861865">root</a><span>|</span><a href="#38861871">parent</a><span>|</span><a href="#38862246">next</a><span>|</span><label class="collapse" for="c-38862007">[-]</label><label class="expand" for="c-38862007">[1 more]</label></div><br/><div class="children"><div class="content">They are often used in pre-employment screening for sensitive government jobs.  Yes, it would be illegal for a private employer to do this.</div><br/></div></div></div></div></div></div><div id="38862246" class="c"><input type="checkbox" id="c-38862246" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#38861865">prev</a><span>|</span><a href="#38863349">next</a><span>|</span><label class="collapse" for="c-38862246">[-]</label><label class="expand" for="c-38862246">[6 more]</label></div><br/><div class="children"><div class="content">The history of this makes it hard to convince people to supersede hashes based on the fact that they can be collided. If the legal community had switched to SHA-1 at the point that MD5 was found to be weak for collisions they would have had to consider switching over to SHA-2 10 years later. From their perspective they dodged a bullet.<p>There ends up being a usability issue here. An MD5 hash is only 128 bits long. So 32 hex digits. A SHA-2 hash is going to be 256 bits. Or 64 hex digits. Manually comparing 64 hex digits is in practice much harder than twice as hard as comparing 32 hex digits. People get lost in the middle. If you chop down your 256 bit hash to 128 bits then due to birthday collisions you can probably brute force a collision anyway (you end up only having to do something like 2^64 operations). So there ends up being a usability argument for specifying that your system has to be able to be secure in the face of collisions. At that point you could then further argue that you will just stick with MD5.</div><br/><div id="38862971" class="c"><input type="checkbox" id="c-38862971" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#38862246">parent</a><span>|</span><a href="#38862362">next</a><span>|</span><label class="collapse" for="c-38862971">[-]</label><label class="expand" for="c-38862971">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There ends up being a usability issue here. An MD5 hash is only 128 bits long. So 32 hex digits. A SHA-2 hash is going to be 256 bits. Or 64 hex digits. Manually comparing 64 hex digits is in practice much harder than twice as hard as comparing 32 hex digits. People get lost in the middle.<p>Comparing MD5 and SHA-2 for visual human diffing is like comparing a stick of dynamite to a landmine when trying to pop a pimple; any potential safety differences are trivial once you start using something in a fundamentally unsafe way.</div><br/></div></div><div id="38862362" class="c"><input type="checkbox" id="c-38862362" checked=""/><div class="controls bullet"><span class="by">wuiheerfoj</span><span>|</span><a href="#38862246">parent</a><span>|</span><a href="#38862971">prev</a><span>|</span><a href="#38863349">next</a><span>|</span><label class="collapse" for="c-38862362">[-]</label><label class="expand" for="c-38862362">[4 more]</label></div><br/><div class="children"><div class="content">Running 2^64 SHA1 ops on a GPU takes 15 years, so I think finding
a reasonable collision for that half using SHA2&#x2F;3 is not as trivial as you suggest:<p><a href="https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;84520&#x2F;how-long-would-it-take-to-brute-force-a-32-or-16-bit-integer-and-which-type-of-p" rel="nofollow">https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;84520&#x2F;how-long-wo...</a></div><br/><div id="38862512" class="c"><input type="checkbox" id="c-38862512" checked=""/><div class="controls bullet"><span class="by">moyix</span><span>|</span><a href="#38862246">root</a><span>|</span><a href="#38862362">parent</a><span>|</span><a href="#38863349">next</a><span>|</span><label class="collapse" for="c-38862512">[-]</label><label class="expand" for="c-38862512">[3 more]</label></div><br/><div class="children"><div class="content">Since that post was published, the 4090 came out, which can (according to this hashcat benchmark [1]) do 50,638.7 million SHA1 hashes per second, so now it would only take a single 4090 GPU 11.55 years. Or you could buy 12 of them and do it in a year, etc. So it&#x27;s definitely not <i>cheap</i> but 15 years is definitely an overestimate (and presumably GPUs will keep getting faster...).<p>SHA2-256 is &quot;only&quot; 21975.5 MH&#x2F;s so you&#x27;d have to double the number of GPUs or amount of time.<p>[1] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;Chick3nman&#x2F;32e662a5bb63bc4f51b847bb422222fd" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;Chick3nman&#x2F;32e662a5bb63bc4f51b847bb4...</a></div><br/><div id="38862913" class="c"><input type="checkbox" id="c-38862913" checked=""/><div class="controls bullet"><span class="by">gruez</span><span>|</span><a href="#38862246">root</a><span>|</span><a href="#38862512">parent</a><span>|</span><a href="#38863349">next</a><span>|</span><label class="collapse" for="c-38862913">[-]</label><label class="expand" for="c-38862913">[2 more]</label></div><br/><div class="children"><div class="content">Generating 2^64 hashes isn&#x27;t guaranteed to produce a collision, and even if a collision did exist in that set, you&#x27;re not going to find it by getting a bunch of GPUs to compute 2^64 hashes. There&#x27;s a huge difference between a haystack that maybe contains a needle, and a needle that&#x27;s been pulled from the haystack and presented to you. To actually find and identify the collisions you&#x27;ll need to hook those GPUs up to some sort of storage&#x2F;retrieval system. Just to store 2^64 128-bit hashes would take 295.1 exabytes. That&#x27;s an order of magnitude more storage than NSA&#x27;s utah datacenter[1].<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Utah_Data_Center" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Utah_Data_Center</a></div><br/><div id="38862972" class="c"><input type="checkbox" id="c-38862972" checked=""/><div class="controls bullet"><span class="by">moyix</span><span>|</span><a href="#38862246">root</a><span>|</span><a href="#38862913">parent</a><span>|</span><a href="#38863349">next</a><span>|</span><label class="collapse" for="c-38862972">[-]</label><label class="expand" for="c-38862972">[1 more]</label></div><br/><div class="children"><div class="content">You can generate pairs of hashes for random inputs and check for collision without storing all of the outputs, no?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38863349" class="c"><input type="checkbox" id="c-38863349" checked=""/><div class="controls bullet"><span class="by">CaliforniaKarl</span><span>|</span><a href="#38862246">prev</a><span>|</span><a href="#38862391">next</a><span>|</span><label class="collapse" for="c-38863349">[-]</label><label class="expand" for="c-38863349">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been wondering, is there a term for a type of attack like this:<p>Given a message M, length function L(), and MD5 hash function H(); is there an attack which can generate message M&#x27;, such that H(M)==H(M&#x27;) _and_ L(M)==L(M&#x27;)?<p>In other words: Two different messages, both of the same length, with the same hash?<p>It&#x27;s almost like a chosen prefix collision attack, but with no prefix (so P is empty) and a given message (M is known, M&#x27; is up to the attacker).<p>I ask because I frequently use GridFTP for data transfer, and it uses both the file length and the MD5 has to verify that files were transferred correctly.</div><br/><div id="38863416" class="c"><input type="checkbox" id="c-38863416" checked=""/><div class="controls bullet"><span class="by">abhibeckert</span><span>|</span><a href="#38863349">parent</a><span>|</span><a href="#38863375">next</a><span>|</span><label class="collapse" for="c-38863416">[-]</label><label class="expand" for="c-38863416">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know anything about GridFTP - but there&#x27;s a <i>huge</i> difference between verifying if files were &quot;transferred correctly&quot; and verifying that files were transferred without being tampered with by a malicious party.<p>MD5 is fine for the first task, and totally unacceptable for the second.</div><br/></div></div><div id="38863375" class="c"><input type="checkbox" id="c-38863375" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#38863349">parent</a><span>|</span><a href="#38863416">prev</a><span>|</span><a href="#38862391">next</a><span>|</span><label class="collapse" for="c-38863375">[-]</label><label class="expand" for="c-38863375">[1 more]</label></div><br/><div class="children"><div class="content">That is still an attack on the second preimage or a collision resistance properties of the hash function. Most collisions do work this way, for example see [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;corkami&#x2F;collisions">https:&#x2F;&#x2F;github.com&#x2F;corkami&#x2F;collisions</a></div><br/></div></div></div></div><div id="38863201" class="c"><input type="checkbox" id="c-38863201" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#38862391">prev</a><span>|</span><a href="#38863031">next</a><span>|</span><label class="collapse" for="c-38863201">[-]</label><label class="expand" for="c-38863201">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, use of MD5 has been been found in court to make evidence <i>less</i> convincing.  <a href="https:&#x2F;&#x2F;www.schneier.com&#x2F;blog&#x2F;archives&#x2F;2005&#x2F;08&#x2F;the_md5_defense.html" rel="nofollow">https:&#x2F;&#x2F;www.schneier.com&#x2F;blog&#x2F;archives&#x2F;2005&#x2F;08&#x2F;the_md5_defen...</a><p>To the article, what tptacek said.</div><br/></div></div><div id="38863031" class="c"><input type="checkbox" id="c-38863031" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38863201">prev</a><span>|</span><a href="#38861402">next</a><span>|</span><label class="collapse" for="c-38863031">[-]</label><label class="expand" for="c-38863031">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wondered what would happen if some black hat made all their payloads have the same hash in the hopes that if it ever went to court the confusion would hinder the proceedings.<p>Like i get that md5 is essentially a unique identifier and not meant to protect against malicious interference but if all the exhibits had the same identifier surely that would confuse people.</div><br/></div></div><div id="38861402" class="c"><input type="checkbox" id="c-38861402" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#38863031">prev</a><span>|</span><a href="#38862194">next</a><span>|</span><label class="collapse" for="c-38861402">[-]</label><label class="expand" for="c-38861402">[12 more]</label></div><br/><div class="children"><div class="content">MD5 is incredibly broken.  The PDF file PoC||GTFO 0x14  (<a href="https:&#x2F;&#x2F;dl.packetstormsecurity.net&#x2F;mag&#x2F;pocgtfo&#x2F;pocorgtfo14.pdf" rel="nofollow">https:&#x2F;&#x2F;dl.packetstormsecurity.net&#x2F;mag&#x2F;pocgtfo&#x2F;pocorgtfo14.p...</a>, 42MB large) is a PDF file that can be also run in a NES emulator, and will display its own MD5 hash.  The MD5 hash is also shown in the pdf document itself.  (Don&#x27;t download it from archive.org, their copy is altered)<p>The fact that any document can contain its own MD5 hash embedded in there should be hugely concerning enough.<p>The hash also happens to start with 5EAF00D.</div><br/><div id="38861495" class="c"><input type="checkbox" id="c-38861495" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38861402">parent</a><span>|</span><a href="#38861526">next</a><span>|</span><label class="collapse" for="c-38861495">[-]</label><label class="expand" for="c-38861495">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a GIF MD5-quine here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13823704">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13823704</a><p>And a PNG version too: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32956964">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32956964</a><p>But no one has made an exclusively plaintext (ASCII) MD5-quine yet, and I suspect doing so may be impossible given the characteristics of collision blocks.</div><br/><div id="38861601" class="c"><input type="checkbox" id="c-38861601" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#38861402">root</a><span>|</span><a href="#38861495">parent</a><span>|</span><a href="#38861526">next</a><span>|</span><label class="collapse" for="c-38861601">[-]</label><label class="expand" for="c-38861601">[2 more]</label></div><br/><div class="children"><div class="content">How is it impossible? I would think an MD5 quine exists with probability approaching 1 as the size of the document grows to infinity. Think about the reduced problem:<p>1. a document containing &quot;1&quot;, whose hash begins with &quot;1&quot;<p>2. a document containing &quot;12&quot;, whose hash begins with &quot;12&quot;<p>3. a document containing &quot;123&quot;, whose hash begins with &quot;123&quot;<p>#1 is certain to exist. #2 exists, but would take 16x as long to brute force. #3 would take 16x longer again. If this pattern doesn&#x27;t continue until 2^128, where would it stop, and why?<p>All hashes can be brute forced this way, even secure ones SHA-2. Its security relies on the fact that the earth doesn&#x27;t contain enough computing power to execute a brute force attack within the universe&#x27;s lifetime.</div><br/><div id="38861948" class="c"><input type="checkbox" id="c-38861948" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38861402">root</a><span>|</span><a href="#38861601">parent</a><span>|</span><a href="#38861526">next</a><span>|</span><label class="collapse" for="c-38861948">[-]</label><label class="expand" for="c-38861948">[1 more]</label></div><br/><div class="children"><div class="content"><i>as the size of the document grows to infinity.</i><p>Therein lies the problem.<p>Also the fact that it would need to be constrained to 7-bit ASCII only, and on top of that be &quot;valid&quot; in its natural language. It&#x27;s a neat trick to make two documents look completely different with the same hash, but looking at the techniques which are required, they all rely on a binary file format and copious amounts of data which are effectively &quot;hidden&quot; --- all of which do not apply to a text file.</div><br/></div></div></div></div></div></div><div id="38861526" class="c"><input type="checkbox" id="c-38861526" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#38861402">parent</a><span>|</span><a href="#38861495">prev</a><span>|</span><a href="#38862014">next</a><span>|</span><label class="collapse" for="c-38861526">[-]</label><label class="expand" for="c-38861526">[1 more]</label></div><br/><div class="children"><div class="content">It might be the case that the more complicated the artifact you&#x27;re trying to forge is, the easier the MD5 forgery gets; the challenge with doing hash forgeries is that you lose control of some of the values and placement of bytes, which is more noticeable&#x2F;disruptive in a short document than in a file that is a bunch of (seekable, error-recovering) formats at once.<p>(I&#x27;ve never tried to built one of these, so I could be just totally wrong here).</div><br/></div></div><div id="38862014" class="c"><input type="checkbox" id="c-38862014" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#38861402">parent</a><span>|</span><a href="#38861526">prev</a><span>|</span><a href="#38862846">next</a><span>|</span><label class="collapse" for="c-38862014">[-]</label><label class="expand" for="c-38862014">[4 more]</label></div><br/><div class="children"><div class="content">&gt; a PDF file that can be also run in a NES emulator, and will display its own MD5 hash. The MD5 hash is also shown in the pdf document itself.<p>By that logic, SHA 256 is also broken:<p><pre><code>  $ cat &gt;sha256.py
  from hashlib import sha256
  s = &#x27;from hashlib import sha256\ns = %r\nprint sha256(s%%s).hexdigest()\n&#x27;
  print sha256(s%s).hexdigest()
  $ sha256sum sha256.py
  14cc85c420ced317fdb73e9403ac3f6e1d96d19c70ae0dce8da9b8d96fa0b4d3  sha256.py
  $ python sha256.py
  14cc85c420ced317fdb73e9403ac3f6e1d96d19c70ae0dce8da9b8d96fa0b4d3
</code></pre>
(Yes, PDF is turing complete. Yes, that&#x27;s terrible. No, it doesn&#x27;t have anything to do with hash function deficiencies; it&#x27;s turing complete on (malicious) purpose, just like webpages with javascript.)</div><br/><div id="38862043" class="c"><input type="checkbox" id="c-38862043" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#38861402">root</a><span>|</span><a href="#38862014">parent</a><span>|</span><a href="#38862846">next</a><span>|</span><label class="collapse" for="c-38862043">[-]</label><label class="expand" for="c-38862043">[3 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t be silly here, the MD5 is clearly in the plaintext here, and the NES ROM is only the first 40k of the file.  It is not able to scan itself and print out a hash that way.</div><br/><div id="38862113" class="c"><input type="checkbox" id="c-38862113" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#38861402">root</a><span>|</span><a href="#38862043">parent</a><span>|</span><a href="#38862846">next</a><span>|</span><label class="collapse" for="c-38862113">[-]</label><label class="expand" for="c-38862113">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the MD5 is clearly in the plaintext here<p>Alright, I&#x27;ll bite: at what byte offset in the binary file contents does a trivial encoding[0] of the MD5 hash occur?<p>&gt; the NES ROM is only the first 40k of the file. It is not able to scan itself and print out a hash that way.<p>It is possible to encode the effects of multiple blocks of arbitrary[1] data on a hash function internal state (independently of <i>what</i> state you start in) in much less space than that data actually takes up, although I&#x27;ll grant that actually doing so is somewhat impressive in it&#x27;s own right, so I don&#x27;t have a trivial translation to SHA 256 immediately ready to post.<p>Edit: tracked down my saved version:<p><pre><code>  $ md5sum pocorgtfo14.pdf
  5eaf00d25c14232555a51a50b126746c  pocorgtfo14.pdf
  $ grep -aoi 5eaf00d pocorgtfo14.pdf || echo not found
  not found
  $ # using ...b126746c because 5eaf00... has a nul
  $ grep -aoF $(printf &#x27;\xb1\x26\x74\x6c&#x27;) pocorgtfo14.pdf || echo not found
  not found
</code></pre>
The MD5 is definitely not <i>clearly</i> in the plaintext here, though it could be only mildly unclear.<p>0: Eg, I&#x27;d accept 31 34 63 63 38 35 63 34 ... as an encoding of 14cc85c4... from above.<p>1: Including random&#x2F;incompressible data.</div><br/><div id="38862999" class="c"><input type="checkbox" id="c-38862999" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38861402">root</a><span>|</span><a href="#38862113">parent</a><span>|</span><a href="#38862846">next</a><span>|</span><label class="collapse" for="c-38862999">[-]</label><label class="expand" for="c-38862999">[1 more]</label></div><br/><div class="children"><div class="content">I dont know about that specific file, but pdf usually gzips its component parts so i wouldn&#x27;t expect naive grepping to work.</div><br/></div></div></div></div></div></div></div></div><div id="38862846" class="c"><input type="checkbox" id="c-38862846" checked=""/><div class="controls bullet"><span class="by">AlienRobot</span><span>|</span><a href="#38861402">parent</a><span>|</span><a href="#38862014">prev</a><span>|</span><a href="#38861562">next</a><span>|</span><label class="collapse" for="c-38862846">[-]</label><label class="expand" for="c-38862846">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The fact that any document can contain its own MD5 hash embedded in there should be hugely concerning enough.<p>I think that&#x27;s pretty amazing, to be honest.</div><br/></div></div></div></div><div id="38862194" class="c"><input type="checkbox" id="c-38862194" checked=""/><div class="controls bullet"><span class="by">chias</span><span>|</span><a href="#38861402">prev</a><span>|</span><a href="#38863598">next</a><span>|</span><label class="collapse" for="c-38862194">[-]</label><label class="expand" for="c-38862194">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that there are no known attacks against MD5 HMACs, which look identical to MD5 hashes.</div><br/><div id="38862633" class="c"><input type="checkbox" id="c-38862633" checked=""/><div class="controls bullet"><span class="by">notahomosapien</span><span>|</span><a href="#38862194">parent</a><span>|</span><a href="#38863598">next</a><span>|</span><label class="collapse" for="c-38862633">[-]</label><label class="expand" for="c-38862633">[2 more]</label></div><br/><div class="children"><div class="content">Quantum computers will severely break MD5 and SHA-1, so they&#x27;d be broken even if they are used with HMAC. Use SHA2-256 unless you need quantum-resistant collision resistance, in which case you should use SHA2-384. Use HMAC-SHA2-* with an 256-bit key if you want to prevent length extension attacks.</div><br/><div id="38862981" class="c"><input type="checkbox" id="c-38862981" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38862194">root</a><span>|</span><a href="#38862633">parent</a><span>|</span><a href="#38863598">next</a><span>|</span><label class="collapse" for="c-38862981">[-]</label><label class="expand" for="c-38862981">[1 more]</label></div><br/><div class="children"><div class="content">Severely break is a bit of a  overstatement.<p>It will make a speed up, but its not like shor&#x27;s algorithm - you need a really powerful quantum computer before md5 comes under threat.<p>But to be clear. Md5 is broken do not use.</div><br/></div></div></div></div></div></div><div id="38863598" class="c"><input type="checkbox" id="c-38863598" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#38862194">prev</a><span>|</span><a href="#38861687">next</a><span>|</span><label class="collapse" for="c-38863598">[-]</label><label class="expand" for="c-38863598">[1 more]</label></div><br/><div class="children"><div class="content">I worked for years as the tech guy for a document imaging company. We worked a few gigs for the Serious Fraud Office in the UK. So, while I&#x27;m not a lawyer, I bumped into this stuff a fair bit.<p>The point is that evidence is an agreement between the two sides in a case, and it&#x27;s not an absolute thing.<p>If you have the original document that was signed by both parties, great. If you have a scan (using a lossless compression format) of the document and proof that the original was destroyed, great. If you have a scan but no proof of destruction, still great. If you have a photograph of the document and no proof, still great. If you have a vague recollection of what was in the document, still great. All of these are &quot;great&quot; if the other side accepts that they are accurate depictions of the original. If they don&#x27;t accept that, then there&#x27;s an argument about what the original document contained and the provenance of the evidence, and only then does the actual quality matter. Original document with wet signature is hard to argue with (but not impossible - wet signatures can be forged). The further away from that, the easier it is to argue that the document presented is not accurate and should not be accepted as evidence.<p>Knowing that it&#x27;s possible to use collisions to create false evidence doesn&#x27;t matter if no-one contests that the evidence is false. It only becomes significant if one side says that the document has been tampered with, and that&#x27;s not that common. The side claiming it was tampered with would have to present their version of the document, and their version of events that allowed the document to be tampered with, and so on. The judge would make a ruling about which version of the document was considered the &quot;real&quot; one and the case would continue. Obviously there are edge cases where the whole trial verdict hinges on which version of the document is the correct one, but they&#x27;re edge cases. And in those cases you could-re-hash the documents involved and double-check with one was right, etc.<p>In the OP&#x27;s example, where a letter of recommendation has the same hash as a authorisation letter, this is only going to matter if one side says the accused was authorised and the other says they weren&#x27;t. The authorisation letter will be produced by one side, and the recommendation letter produced by the other, and there&#x27;ll be an argument about which was the original document. The fact that they have the same hash isn&#x27;t really relevant. It&#x27;s a minor point of interest given that these are two clearly different documents saying different things.<p>In the specific cases for the SFO that I worked on, the SFO descended on the accused&#x27;s offices like locusts, sweeping every single document into carefully numbered bags. We scanned the documents in secure facilities, stored the originals in secure facilities, stored the resulting images in secure storage, and deleted any cache or copies. My professional opinion is that it would be impossible for anyone to create two documents prior to the SFO&#x27;s investigation that would create an intentional MD5 collision in the evidence used in court. And, even if they somehow did, it wouldn&#x27;t matter because both documents would be in evidence bags in storage and could be recovered to be examined by the court.<p>Obviously, from a black&#x2F;white technical point of view, using a better hash algorithm would be better. But I can see why the legal profession is reluctant to adopt the new thing; it&#x27;s a hassle and it will only affect a tiny amount of cases, if any.</div><br/></div></div><div id="38861687" class="c"><input type="checkbox" id="c-38861687" checked=""/><div class="controls bullet"><span class="by">ipython</span><span>|</span><a href="#38863598">prev</a><span>|</span><a href="#38861442">next</a><span>|</span><label class="collapse" for="c-38861687">[-]</label><label class="expand" for="c-38861687">[5 more]</label></div><br/><div class="children"><div class="content">I read through this hoping to have a reasonable discussion of the difference between preimage attacks (see <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Preimage_attack" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Preimage_attack</a>) and was disappointed when I did not see the topic mentioned once. :(<p>It is much more computationally feasible to create two inputs from scratch that hash to the same value than to forge an existing documents hash (the threat model I’m assuming they’re discussing in relation to the law).<p>As far as I know I am not aware of a demonstrated second preimage attack on md5. Not saying to keep using it, just trying to not spread fud.<p>Edit: I do see second preimage is mentioned about 3&#x2F;4 of the way through the article. I confess that I did stop reading and started skimming before then.</div><br/><div id="38862515" class="c"><input type="checkbox" id="c-38862515" checked=""/><div class="controls bullet"><span class="by">evouga</span><span>|</span><a href="#38861687">parent</a><span>|</span><a href="#38862622">prev</a><span>|</span><a href="#38861973">next</a><span>|</span><label class="collapse" for="c-38862515">[-]</label><label class="expand" for="c-38862515">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s simply that the blog author and commentators have an unrealistic threat model when it comes to how the legal profession uses MD5s.<p>After the first high-profile case where authenticity of evidence gets called into question because a seized electronic document was deliberately doctored to allow for a hash collision (if that ever happens), there will be a will to change to something new.</div><br/><div id="38862755" class="c"><input type="checkbox" id="c-38862755" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#38861687">root</a><span>|</span><a href="#38862515">parent</a><span>|</span><a href="#38861973">next</a><span>|</span><label class="collapse" for="c-38862755">[-]</label><label class="expand" for="c-38862755">[1 more]</label></div><br/><div class="children"><div class="content">I doubt it, legal types won&#x27;t see this as a math problem[1], but a legal problem (forging documents)<p>[1] unless I&#x27;m missing something, this boils down to: &quot;given f(x: string) =&gt; y, how can I minimize the odds that you can generate an X for a desired Y&quot;</div><br/></div></div></div></div><div id="38861973" class="c"><input type="checkbox" id="c-38861973" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38861687">parent</a><span>|</span><a href="#38862515">prev</a><span>|</span><a href="#38861442">next</a><span>|</span><label class="collapse" for="c-38861973">[-]</label><label class="expand" for="c-38861973">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if you haven&#x27;t already noticed, crypto is just a religion at this point, propagated by the &quot;experts&quot; who don&#x27;t actually think and actively silence dissent.</div><br/></div></div></div></div></div></div></div></div></div></body></html>