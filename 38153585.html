<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699261260895" as="style"/><link rel="stylesheet" href="styles.css?v=1699261260895"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gpuweb.github.io/gpuweb/explainer/">W3C Community Group Draft Report – WebGPU Explainer</a> <span class="domain">(<a href="https://gpuweb.github.io">gpuweb.github.io</a>)</span></div><div class="subtext"><span>Emigre_</span> | <span>30 comments</span></div><br/><div><div id="38156219" class="c"><input type="checkbox" id="c-38156219" checked=""/><div class="controls bullet"><span class="by">astlouis44</span><span>|</span><a href="#38157454">next</a><span>|</span><label class="collapse" for="c-38156219">[-]</label><label class="expand" for="c-38156219">[2 more]</label></div><br/><div class="children"><div class="content">My team is bringing Unreal Engine 5 to WebGPU, to enable next generation browser games and 3D web applications.</div><br/><div id="38156439" class="c"><input type="checkbox" id="c-38156439" checked=""/><div class="controls bullet"><span class="by">dindresto</span><span>|</span><a href="#38156219">parent</a><span>|</span><a href="#38157454">next</a><span>|</span><label class="collapse" for="c-38156439">[-]</label><label class="expand" for="c-38156439">[1 more]</label></div><br/><div class="children"><div class="content">As an official backend, or just for a specific game?</div><br/></div></div></div></div><div id="38159157" class="c"><input type="checkbox" id="c-38159157" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#38157454">prev</a><span>|</span><a href="#38155153">next</a><span>|</span><label class="collapse" for="c-38159157">[-]</label><label class="expand" for="c-38159157">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Each error scope stores only the first error it captures; any further errors it captures are silently ignored.&quot; is one of the worst design decisions I&#x27;ve ever seen. That means if code is expecting <i>one</i> error to occur, any unexpected errors that occur after it in the scope are unobservable. The only way to handle that would be to push&#x2F;pop tons of scopes.<p>How hard is it to make an array of errors instead of a single slot? What&#x27;s the upside of this other than laziness?</div><br/><div id="38160209" class="c"><input type="checkbox" id="c-38160209" checked=""/><div class="controls bullet"><span class="by">xnorswap</span><span>|</span><a href="#38159157">parent</a><span>|</span><a href="#38159554">next</a><span>|</span><label class="collapse" for="c-38160209">[-]</label><label class="expand" for="c-38160209">[1 more]</label></div><br/><div class="children"><div class="content">The worst?<p>No, that belongs to VB:<p>&gt; On Error Resume Next<p>Literally, &quot;Ignore the error, and continue as if nothing bad had happened&quot;.<p>That&#x27;s the worst design decision ever when it comes to error handling.<p>Only storing the first error is bad, but that&#x27;s why they describe it as a problem with WebGL that they solve in WebGPU by using a stack.</div><br/></div></div><div id="38159554" class="c"><input type="checkbox" id="c-38159554" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#38159157">parent</a><span>|</span><a href="#38160209">prev</a><span>|</span><a href="#38155153">next</a><span>|</span><label class="collapse" for="c-38159554">[-]</label><label class="expand" for="c-38159554">[1 more]</label></div><br/><div class="children"><div class="content">These kinds of errors are usually programmer errors that cause literally hundreds of downstream errors because they put an object later used by other code in an invalid state. In these cases only the first error is particularly useful, the rest are just noise.</div><br/></div></div></div></div><div id="38155153" class="c"><input type="checkbox" id="c-38155153" checked=""/><div class="controls bullet"><span class="by">drfuchs</span><span>|</span><a href="#38159157">prev</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38155153">[-]</label><label class="expand" for="c-38155153">[14 more]</label></div><br/><div class="children"><div class="content">Great.  Now how do I call this API from WASM without any intervening JavaScript?</div><br/><div id="38155378" class="c"><input type="checkbox" id="c-38155378" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#38155153">parent</a><span>|</span><a href="#38155312">next</a><span>|</span><label class="collapse" for="c-38155378">[-]</label><label class="expand" for="c-38155378">[6 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll need <i>some</i> JavaScript to instantiate the WASM module and pass in a set of imported functions for using WebGPU. After passing in the capabilities it can be all WASM from there.</div><br/><div id="38155591" class="c"><input type="checkbox" id="c-38155591" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155378">parent</a><span>|</span><a href="#38155312">next</a><span>|</span><label class="collapse" for="c-38155591">[-]</label><label class="expand" for="c-38155591">[5 more]</label></div><br/><div class="children"><div class="content">Afaik, there&#x27;s no means to pass in imported functions right now.<p>Rust has a very extensive bindgen to make it kind of look like you can, but it&#x27;s really a huge payload of js running on the page&#x27;s main-thread that&#x27;s converting back and forth. At significant cost.<p>We just shipped garbage collection, which is one precondition to actually being able to pass things around (so things passed in can participate properly in gc). Next is component-model, which allows for passing non-trivial objects around; currently it&#x27;s just primitives like numbers that can be passed. After that goes in, hopefully it won&#x27;t be long before we have host-object bridging, where platform objects can be sent across. <a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;component-model">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;component-model</a></div><br/><div id="38155632" class="c"><input type="checkbox" id="c-38155632" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155591">parent</a><span>|</span><a href="#38155312">next</a><span>|</span><label class="collapse" for="c-38155632">[-]</label><label class="expand" for="c-38155632">[4 more]</label></div><br/><div class="children"><div class="content">You can pass around arbitrary JS objects via the (ref extern) type. The (import &quot;module&quot; &quot;name&quot; ...) form can be used to declare an imported thing (function, global, memory, table.) I don&#x27;t do Rust so I don&#x27;t know what the limitations are with Rust on WASM right now but speaking just about core WASM stuff all the basic pieces are there now.</div><br/><div id="38156029" class="c"><input type="checkbox" id="c-38156029" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155632">parent</a><span>|</span><a href="#38155312">next</a><span>|</span><label class="collapse" for="c-38156029">[-]</label><label class="expand" for="c-38156029">[3 more]</label></div><br/><div class="children"><div class="content">Afaik, no. What you are talking about is the future, not anything available on any platforms today.<p>Right now, different runtimes don&#x27;t have any way to communicate what type an object or function is. That&#x27;s what component model is trying to figure out. Without that, there&#x27;s not really a way for a ref to do anyone any good, as far as I know.<p>If you can link any docs or examples, that&#x27;d be great. I feel like it&#x27;s been a long long long wait, &amp; I&#x27;ve been very eager. But if I&#x27;m mistaken, and passing stuff across boundaries is possible, that&#x27;d be amazing to see.</div><br/><div id="38157820" class="c"><input type="checkbox" id="c-38157820" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38156029">parent</a><span>|</span><a href="#38157929">next</a><span>|</span><label class="collapse" for="c-38157820">[-]</label><label class="expand" for="c-38157820">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Right now, different runtimes don&#x27;t have any way to communicate what type an object or function is. That&#x27;s what component model is trying to figure out. Without that, there&#x27;s not really a way for a ref to do anyone any good, as far as I know.<p>All of that seems like more of a convenience than a necessity: even with just the current implementation of host references, it&#x27;s perfectly possible to track objects purely through indices into a big table, using reference-counting on the module&#x27;s side, with no JS assistance necessary.<p>In fact, wasm-bindgen has already implemented support for tracking JS objects as host references in this way, via the --reference-types flag [0]. I&#x27;ve tried out this flag with their WebGL example, and the shims are indeed very minimal: JS objects passed as input aruments go directly into the target functions, without any sort of decoding or lookups. However, JS objects as outputs are still inserted into the table by the shims (calling back into the module to get a free index), which I presume is just a limitation of Rust not being able to express a host reference stored in a local while calling another function.<p>So overall, there&#x27;s no fundamental issue blocking native functions (or methods, through a bound Function.prototype.call) from being called from WASM with no shims at all, as long as the module can implement any sort of basic index allocator. Though I&#x27;d imagine sufficiently-simple shims would get compiled down to hardly anything regardless, in case that turns out to be more performant than Function.prototype.call.<p>[0] <a href="https:&#x2F;&#x2F;rustwasm.github.io&#x2F;wasm-bindgen&#x2F;reference&#x2F;reference-types.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rustwasm.github.io&#x2F;wasm-bindgen&#x2F;reference&#x2F;reference-...</a></div><br/></div></div><div id="38157929" class="c"><input type="checkbox" id="c-38157929" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38156029">parent</a><span>|</span><a href="#38157820">prev</a><span>|</span><a href="#38155312">next</a><span>|</span><label class="collapse" for="c-38157929">[-]</label><label class="expand" for="c-38157929">[1 more]</label></div><br/><div class="children"><div class="content">Part of the security model of WASM is that guest values are opaque to the host and host values are opaque to the guest. You can get a lot of mileage out of (ref extern) right now. Like if you import document.createTextNode you know the extern ref you get back is a text node and you can wrap the extern up as such in your WASM program. I have wrapped a subset of the DOM and Canvas APIs and made several small programs like a classic todo list example and a small retro video game rendered to canvas. I&#x27;ve been able to create elements, assign event handlers, use setTimeout&#x2F;requestAnimationFrame, etc. all from within WASM. So while additional proposals could add more useful reference types (such as (ref string) from the stringref proposal) you can already do a lot with the types that are there now that reference types + GC are part of core WASM.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38155312" class="c"><input type="checkbox" id="c-38155312" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38155153">parent</a><span>|</span><a href="#38155378">prev</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38155312">[-]</label><label class="expand" for="c-38155312">[7 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t.<p>Maybe when reference types eventually become a thing.</div><br/><div id="38155363" class="c"><input type="checkbox" id="c-38155363" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155312">parent</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38155363">[-]</label><label class="expand" for="c-38155363">[6 more]</label></div><br/><div class="children"><div class="content">WASM GC reference types are rolling out to stable browser releases now. Chrome 119 just shipped with them enabled by default.</div><br/><div id="38155710" class="c"><input type="checkbox" id="c-38155710" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155363">parent</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38155710">[-]</label><label class="expand" for="c-38155710">[5 more]</label></div><br/><div class="children"><div class="content">Those ones are unrelated to exposing browser APIs directly to WASM code.<p>Setup is still required.</div><br/><div id="38155767" class="c"><input type="checkbox" id="c-38155767" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155710">parent</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38155767">[-]</label><label class="expand" for="c-38155767">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite understand what you mean. WASM modules don&#x27;t have direct access to <i>anything</i>. They have to be granted capabilities from by the host. Are you referring to optimizations that various engines do where they recognize well-known imports like Math.sin and compile things such that they don&#x27;t invoke JS at all?</div><br/><div id="38155903" class="c"><input type="checkbox" id="c-38155903" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155767">parent</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38155903">[-]</label><label class="expand" for="c-38155903">[3 more]</label></div><br/><div class="children"><div class="content">Exactly, hence it is currently impossible to use WebGPU without JavaScript&#x27;s help.<p>There are some proposals regarding exposing the browser IDL to WASM via reference types, but it is far from happening.</div><br/><div id="38156302" class="c"><input type="checkbox" id="c-38156302" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38155903">parent</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38156302">[-]</label><label class="expand" for="c-38156302">[2 more]</label></div><br/><div class="children"><div class="content">You need the host (whatever it is) to provide the capabilities to WASM. On the web, the host environment is JS. Browser engines are free to optimize well-known imports with or without any new proposals. I guess I just don&#x27;t really see the issue...</div><br/><div id="38159559" class="c"><input type="checkbox" id="c-38159559" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38155153">root</a><span>|</span><a href="#38156302">parent</a><span>|</span><a href="#38155424">next</a><span>|</span><label class="collapse" for="c-38159559">[-]</label><label class="expand" for="c-38159559">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that currently this is impossible <i>&quot;Now how do I call this API from WASM without any intervening JavaScript?&quot;</i>.<p>Now the Web IDL bindings have evolved to some kind of reference types, and that is what I was talking about, not GC reference types.<p><a href="https:&#x2F;&#x2F;www.w3.org&#x2F;2018&#x2F;12&#x2F;games-workshop&#x2F;slides&#x2F;08-web-idl-bindings.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.w3.org&#x2F;2018&#x2F;12&#x2F;games-workshop&#x2F;slides&#x2F;08-web-idl-...</a><p><a href="https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2019&#x2F;08&#x2F;webassembly-interface-types&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2019&#x2F;08&#x2F;webassembly-interface-type...</a><p><a href="https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;introduction.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;introduction.ht...</a><p>However I did the mistake to keep calling them reference types, when in reality they are now called component model.<p>As for the browser, yeah that is what matters for WebGPU, outside of the browser there are so many middleware options with much better tooling (GPU debuggers for Web 3D still aren&#x27;t a thing 10 years later, besides poor SpectorJS), and access to latest hardware features, instead of what was the state of the art in 2015.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38155424" class="c"><input type="checkbox" id="c-38155424" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#38155153">prev</a><span>|</span><label class="collapse" for="c-38155424">[-]</label><label class="expand" for="c-38155424">[9 more]</label></div><br/><div class="children"><div class="content">Soon, even our game engines will be written in JavaScript: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_SCfNhyIo_U">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_SCfNhyIo_U</a><p>Snark aside, the best resource I&#x27;ve found for learning WebGPU is: <a href="https:&#x2F;&#x2F;webgpufundamentals.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;webgpufundamentals.org&#x2F;</a></div><br/><div id="38158545" class="c"><input type="checkbox" id="c-38158545" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#38155424">parent</a><span>|</span><a href="#38157458">next</a><span>|</span><label class="collapse" for="c-38158545">[-]</label><label class="expand" for="c-38158545">[1 more]</label></div><br/><div class="children"><div class="content">I thought that video was going to be The Birth &amp; Death of JavaScript<p><a href="https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;the-birth-and-death-of-javascript" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;the-birth-and-death...</a></div><br/></div></div><div id="38157458" class="c"><input type="checkbox" id="c-38157458" checked=""/><div class="controls bullet"><span class="by">AshleysBrain</span><span>|</span><a href="#38155424">parent</a><span>|</span><a href="#38158545">prev</a><span>|</span><a href="#38155719">next</a><span>|</span><label class="collapse" for="c-38157458">[-]</label><label class="expand" for="c-38157458">[1 more]</label></div><br/><div class="children"><div class="content">We are building a full game engine and editor fully in JavaScript [1], and we&#x27;ve got WebGPU support too [2].<p>[1] <a href="https:&#x2F;&#x2F;www.construct.net" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.construct.net</a><p>[2] <a href="https:&#x2F;&#x2F;www.construct.net&#x2F;en&#x2F;blogs&#x2F;construct-official-blog-1&#x2F;introducing-constructs-new-1768" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.construct.net&#x2F;en&#x2F;blogs&#x2F;construct-official-blog-1...</a></div><br/></div></div><div id="38155719" class="c"><input type="checkbox" id="c-38155719" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38155424">parent</a><span>|</span><a href="#38157458">prev</a><span>|</span><a href="#38159059">next</a><span>|</span><label class="collapse" for="c-38155719">[-]</label><label class="expand" for="c-38155719">[5 more]</label></div><br/><div class="children"><div class="content">WebGPU will always have the issue to lang behind native capabilities.<p>It is good enough if aiming to PS3 like games, though.</div><br/><div id="38155897" class="c"><input type="checkbox" id="c-38155897" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#38155424">root</a><span>|</span><a href="#38155719">parent</a><span>|</span><a href="#38159059">next</a><span>|</span><label class="collapse" for="c-38155897">[-]</label><label class="expand" for="c-38155897">[4 more]</label></div><br/><div class="children"><div class="content">Any WGPU users among us? How does native and web performance, with the same graphics code, compare?</div><br/><div id="38155937" class="c"><input type="checkbox" id="c-38155937" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38155424">root</a><span>|</span><a href="#38155897">parent</a><span>|</span><a href="#38159059">next</a><span>|</span><label class="collapse" for="c-38155937">[-]</label><label class="expand" for="c-38155937">[3 more]</label></div><br/><div class="children"><div class="content">Whatever WGPU might do in addition to WebGPU is naturally going beyond the standard features a browser is expected to provide, thus no different from any other graphics middleware.</div><br/><div id="38156014" class="c"><input type="checkbox" id="c-38156014" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#38155424">root</a><span>|</span><a href="#38155937">parent</a><span>|</span><a href="#38159059">next</a><span>|</span><label class="collapse" for="c-38156014">[-]</label><label class="expand" for="c-38156014">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s heavily sandboxed, and there are other overheads to get around.</div><br/><div id="38159627" class="c"><input type="checkbox" id="c-38159627" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38155424">root</a><span>|</span><a href="#38156014">parent</a><span>|</span><a href="#38159059">next</a><span>|</span><label class="collapse" for="c-38159627">[-]</label><label class="expand" for="c-38159627">[1 more]</label></div><br/><div class="children"><div class="content">And has 2015 state of the art hardware as inspiration, in 10 years time we might finally get mesh shaders and raytracing, looking at how long it took to get OpenGL ES 3.1 compute shaders available.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>