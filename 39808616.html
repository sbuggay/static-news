<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711357261539" as="style"/><link rel="stylesheet" href="styles.css?v=1711357261539"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.atnnn.com/p/operator-larrow/">C++ left arrow operator (2016)</a> <span class="domain">(<a href="https://www.atnnn.com">www.atnnn.com</a>)</span></div><div class="subtext"><span>layer8</span> | <span>91 comments</span></div><br/><div><div id="39811702" class="c"><input type="checkbox" id="c-39811702" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811815">next</a><span>|</span><label class="collapse" for="c-39811702">[-]</label><label class="expand" for="c-39811702">[24 more]</label></div><br/><div class="children"><div class="content">The C++ pointer-to-member is a fairly confusing concept. What it actually is is a pair - a pointer to the instance of the struct, and a pointer to a function in that struct.<p>D calls these <i>delegates</i>, and generalizes it to being a pair consisting of a &quot;context pointer&quot; and a &quot;pointer to a function&quot;. The neato thing is these do not have to be struct or class member functions. They can be nested functions, where the the &quot;context pointer&quot; is a pointer to the stack frame of the caller. I.e., a pointer to the closure.<p>Hence, these become lambdas.<p>Lamdas and pointers-to-nested functions are completely interchangeable with pointers to members. The caller does not know the difference.<p>In fact, lambdas are far, far more commonly used in D than pointers-to-members.</div><br/><div id="39812597" class="c"><input type="checkbox" id="c-39812597" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#39811702">parent</a><span>|</span><a href="#39812482">next</a><span>|</span><label class="collapse" for="c-39812597">[-]</label><label class="expand" for="c-39812597">[6 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t correct. C++ pointer to member&#x27;s do not carry any instance information. They are more complex than plain pointers because they will still do proper virtual dispatching in the presence of multiple inheritance which requires more machinery than a plain function pointer, but this has absolutely nothing to do with keeping a pointer to an instance&#x2F;<i>this</i>.</div><br/><div id="39812998" class="c"><input type="checkbox" id="c-39812998" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812597">parent</a><span>|</span><a href="#39812783">next</a><span>|</span><label class="collapse" for="c-39812998">[-]</label><label class="expand" for="c-39812998">[1 more]</label></div><br/><div class="children"><div class="content">You are correct, what I wrote is unclear. See my other posts in this thread.</div><br/></div></div><div id="39812783" class="c"><input type="checkbox" id="c-39812783" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812597">parent</a><span>|</span><a href="#39812998">prev</a><span>|</span><a href="#39812482">next</a><span>|</span><label class="collapse" for="c-39812783">[-]</label><label class="expand" for="c-39812783">[4 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The C++ pointer-to-member is a fairly confusing concept. What it actually is is a pair - a pointer to the instance of the struct, and a pointer to a function in that struct.<p>&gt; This isn&#x27;t correct. C++ pointer to member&#x27;s do not carry any instance information.<p>Mr. Bright&#x27;s description is correct from the perspective of pointer-to-member&#x27;s use, not when declared nor instantiated.<p>Given Mr. Bright&#x27;s role in creating Zortech C, Zortech C++, amongst other compilers, and having used the two specifically mentioned personally, I believe he has a proven understanding of C&#x2F;C++ compiler implementations.<p>Since one can interpret Mr. Bright&#x27;s statement in the form of usage or definition, the former seems most applicable when viewed in the context of the remaining text.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Digital_Mars" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Digital_Mars</a></div><br/><div id="39812906" class="c"><input type="checkbox" id="c-39812906" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812783">parent</a><span>|</span><a href="#39813042">next</a><span>|</span><label class="collapse" for="c-39812906">[-]</label><label class="expand" for="c-39812906">[1 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s just incorrect and no amount of pandering to his authority will change that.<p>People make mistakes and this is one of them, it&#x27;s not the end of the world. Avoid the temptation to believe false information just because you happen to worship someone, it reflects poorly on your ability to critically judge information.</div><br/></div></div><div id="39813042" class="c"><input type="checkbox" id="c-39813042" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812783">parent</a><span>|</span><a href="#39812906">prev</a><span>|</span><a href="#39812482">next</a><span>|</span><label class="collapse" for="c-39813042">[-]</label><label class="expand" for="c-39813042">[2 more]</label></div><br/><div class="children"><div class="content">He&#x27;s the eccentric D guy who used to argue on IRC 20 years ago about how D is superior because the C++ standard doesn&#x27;t require any C++ standard library to be present. If he says something weird, just nod and continue what you were doing.</div><br/><div id="39813476" class="c"><input type="checkbox" id="c-39813476" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39813042">parent</a><span>|</span><a href="#39812482">next</a><span>|</span><label class="collapse" for="c-39813476">[-]</label><label class="expand" for="c-39813476">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never been on internet relay chat.</div><br/></div></div></div></div></div></div></div></div><div id="39812482" class="c"><input type="checkbox" id="c-39812482" checked=""/><div class="controls bullet"><span class="by">boguscoder</span><span>|</span><a href="#39811702">parent</a><span>|</span><a href="#39812597">prev</a><span>|</span><a href="#39812947">next</a><span>|</span><label class="collapse" for="c-39812482">[-]</label><label class="expand" for="c-39812482">[8 more]</label></div><br/><div class="children"><div class="content">C++ pointers-to-members have no standard structure and are implementation defined. But in no implementations they have pointers to instances inside them. If that was the case Why would you need an instance (again) pointer&#x2F;reference to use pointer-to-member? 
In most implementations they  just encode an offset</div><br/><div id="39812531" class="c"><input type="checkbox" id="c-39812531" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812482">parent</a><span>|</span><a href="#39812947">next</a><span>|</span><label class="collapse" for="c-39812531">[-]</label><label class="expand" for="c-39812531">[7 more]</label></div><br/><div class="children"><div class="content">The pointer to instance part is the `this` pointer.<p>&gt; C++ pointers-to-members have no standard structure and are implementation defined.<p>A missed opportunity, though every C++ compiler I&#x27;ve examined did it the same way.</div><br/><div id="39812614" class="c"><input type="checkbox" id="c-39812614" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812531">parent</a><span>|</span><a href="#39812580">next</a><span>|</span><label class="collapse" for="c-39812614">[-]</label><label class="expand" for="c-39812614">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The pointer to instance part is the `this` pointer.<p>What do you mean?  The this pointer isn’t computed until you try to call the pointer-to-member-function.</div><br/><div id="39812816" class="c"><input type="checkbox" id="c-39812816" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812614">parent</a><span>|</span><a href="#39812843">next</a><span>|</span><label class="collapse" for="c-39812816">[-]</label><label class="expand" for="c-39812816">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The pointer to instance part is the `this` pointer.<p>&gt; What do you mean? The this pointer isn’t computed until you try to call the pointer-to-member-function.<p>Think of it from a compiler writer&#x27;s perspective.<p>The implicit parameter when using a pointer-to-member function is the function pointer itself.  The `this` (instance) pointer must be passed explicitly when invoking it (along with whatever other parameters the function requires).<p>Ergo:<p>&gt;&gt; The pointer to instance part is the `this` pointer.</div><br/><div id="39812949" class="c"><input type="checkbox" id="c-39812949" checked=""/><div class="controls bullet"><span class="by">lallysingh</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812816">parent</a><span>|</span><a href="#39812843">next</a><span>|</span><label class="collapse" for="c-39812949">[-]</label><label class="expand" for="c-39812949">[1 more]</label></div><br/><div class="children"><div class="content">Pointer to what, exactly?  It doesn&#x27;t make sense for it to be an object instance pointer, because you can use the same pointer to member on several different objects instances.  If one instance&#x27;s pointer was embedded in the pointer-to-member, it wouldn&#x27;t work for other instances.<p>I have no idea what the format of a pointer-to-member is.  It sure looks like a small closure.</div><br/></div></div></div></div><div id="39812843" class="c"><input type="checkbox" id="c-39812843" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812614">parent</a><span>|</span><a href="#39812816">prev</a><span>|</span><a href="#39812580">next</a><span>|</span><label class="collapse" for="c-39812843">[-]</label><label class="expand" for="c-39812843">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39812834">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39812834</a> for a more complete explanation.</div><br/></div></div></div></div><div id="39812580" class="c"><input type="checkbox" id="c-39812580" checked=""/><div class="controls bullet"><span class="by">boguscoder</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812531">parent</a><span>|</span><a href="#39812614">prev</a><span>|</span><a href="#39812947">next</a><span>|</span><label class="collapse" for="c-39812580">[-]</label><label class="expand" for="c-39812580">[2 more]</label></div><br/><div class="children"><div class="content">But again, ‘this’ pointer is not in any way stored inside pointer-to-member. Caller has to provide one</div><br/></div></div></div></div></div></div><div id="39812947" class="c"><input type="checkbox" id="c-39812947" checked=""/><div class="controls bullet"><span class="by">vintagedave</span><span>|</span><a href="#39811702">parent</a><span>|</span><a href="#39812482">prev</a><span>|</span><a href="#39812565">next</a><span>|</span><label class="collapse" for="c-39812947">[-]</label><label class="expand" for="c-39812947">[1 more]</label></div><br/><div class="children"><div class="content">Delphi captures the pointer-to-instance and pointer-to-function concept too. It uses them for event handlers: delegating behaviour to other classes. To do that, method pointers are often a &#x27;fat pointer&#x27;: the pair of object instance and function.<p><pre><code>    type TMethodPtr = procedure(x : Integer) of object; &#x2F;&#x2F; &#x27;of object&#x27; means an OO method pointer, not procedural
    var p : TMethodPtr = foo.bar; &#x2F;&#x2F; Captures both foo and bar
    p(4); &#x2F;&#x2F; Calls foo.bar(4)
</code></pre>
Fun: you can use them in C++ too in C++Builder&#x27;s dialect via the rather ugly syntax,<p><pre><code>    void(__closure * myClosure)(int); &#x2F;&#x2F; myClosure can point to a method taking an int, returning void
    myClosure = pObj-&gt;func; &#x2F;&#x2F; Assigng myClosure; this captures both pObj and the address of func
    myClosure(4); &#x2F;&#x2F; Call it: this calls pObj-&gt;func(4)
</code></pre>
Syntax aside, they&#x27;re neat because they match type safety by the method signature not by the type of the object on which they&#x27;re called (which lets yu use them to delegate to any classes, not just ones inheriting from specific ancestors.) This bypasses contravariance constraints too.<p>More info with a discussion on C++: <a href="https:&#x2F;&#x2F;www.codeproject.com&#x2F;Articles&#x2F;44874&#x2F;C-Delegates-and-Borland-s-C-Builder-Event-Handling" rel="nofollow">https:&#x2F;&#x2F;www.codeproject.com&#x2F;Articles&#x2F;44874&#x2F;C-Delegates-and-B...</a></div><br/></div></div><div id="39812565" class="c"><input type="checkbox" id="c-39812565" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#39811702">parent</a><span>|</span><a href="#39812947">prev</a><span>|</span><a href="#39811815">next</a><span>|</span><label class="collapse" for="c-39812565">[-]</label><label class="expand" for="c-39812565">[8 more]</label></div><br/><div class="children"><div class="content">C# calls them delegates too, as does Virgil. Virgil uses the fat pointer trick so to avoid any heap allocations. In Virgil,<p><pre><code>    class C {
        def m() -&gt; int { return 33; }
    }
    var x = C.new();            &#x2F;&#x2F; allocate a new C
    var y: void -&gt; int = x.m;   &#x2F;&#x2F; delegate bound to x and m
    var z: C -&gt; int = C.m;      &#x2F;&#x2F; C.m method is first-class, takes an object
    var t = z(x);               &#x2F;&#x2F; equivalent to x.m();
</code></pre>
I never understood why C++ and other languages had such ugly syntax for such obvious concepts.</div><br/><div id="39812656" class="c"><input type="checkbox" id="c-39812656" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812565">parent</a><span>|</span><a href="#39812591">next</a><span>|</span><label class="collapse" for="c-39812656">[-]</label><label class="expand" for="c-39812656">[6 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak to Virgil, never used it, but C++ features try their best to adhere to the principle that you don&#x27;t pay for what you don&#x27;t use. It&#x27;s not perfect but pointer to member functions in C++ use the simplest implementation that is possible for that given functionality. In C# delegates can not be unbound from instance variables, they must be bound at the point of creation. In C++ that is not the case which makes C++ pointer to members much more flexible.<p>It looks like in Virgil you can have both bound and unbound pointers. You are welcome to correct me but I suspect it&#x27;s implemented in such a way that you are always paying the cost of having a bound function pointer even if you only ever use it as an unbound function pointer. This would violate the principle I mentioned.<p>In C++ if you don&#x27;t mind always paying that cost, you are welcome to use std::function and it will work just as it does in the example you gave:<p><pre><code>    std::function&lt;ReturnType (Arg1, Arg2, ...)&gt;</code></pre></div><br/><div id="39812735" class="c"><input type="checkbox" id="c-39812735" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812656">parent</a><span>|</span><a href="#39812834">next</a><span>|</span><label class="collapse" for="c-39812735">[-]</label><label class="expand" for="c-39812735">[2 more]</label></div><br/><div class="children"><div class="content">In Virgil every first-class function is a represented as a fat pointer, i.e. two words[1], for both bound and unbound delegates. It&#x27;s simple to understand, the syntax is clean, and it always works the way you expect it to. It doesn&#x27;t create garbage and basically means you use two registers instead of one. The unbound version even does a proper virtual dispatch for you.<p>I understand C++&#x27;s intention, but it&#x27;s doing no one any favors here and makes it really hard to build proper abstractions. Pointers to members are clunky, hard to use, and easy to screw up. AFAIU it&#x27;s <i>possible</i> that a pointer to a member to be a single simple function pointer, but not guaranteed, and you shouldn&#x27;t rely on it. It seems like a very bad tradeoff. std::function is considerably more heavyweight (and according to this <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;13503511&#x2F;sizeof-of-stdfunctionvoidint-type" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;13503511&#x2F;sizeof-of-stdfu...</a> might be arbitrarily large); i.e. it&#x27;s slow in practice and people avoid it.<p>[1] For programs less than 4GB combined code and heap, the two pointers can be packed into a single 64-bit word (though the compiler doesn&#x27;t do this currently).</div><br/><div id="39812894" class="c"><input type="checkbox" id="c-39812894" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812735">parent</a><span>|</span><a href="#39812834">next</a><span>|</span><label class="collapse" for="c-39812894">[-]</label><label class="expand" for="c-39812894">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The unbound version even does a proper virtual dispatch for you--in C++ you can break class invariants by skipping a virtual dispatch by using a member pointer.<p>This is not true, the C++ version does the proper virtual dispatch.<p>&gt;I understand C++&#x27;s intention, but it&#x27;s doing no one any favors here and makes it really hard to build proper abstractions.<p>std::function is a perfectly fine abstraction built on-top of the lower level primitives if you don&#x27;t care about always paying a performance penalty. As someone who writes performance sensitive code, I do care so I try to avoid that penalty.<p>&gt;std::function is considerably more heavyweight (and according to this <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;13503511&#x2F;sizeof-of-stdfu" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;13503511&#x2F;sizeof-of-stdfu</a>... might be arbitrarily large);<p>Of course std::function can allocate arbitrarily large amounts of memory, so can Virgil&#x27;s implementation. The sizeof(std::function) is always fixed, but because it can capture arbitrarily functions which themselves can carry arbitrarily large state, then so too must std::function also have the potential to allocate arbitrarily large amounts of memory.<p>In C++ people avoid std::function because as you said it&#x27;s slow, and people tend to not use C++ for programs that can be slow, this goes back to the principle of not having to pay for what you don&#x27;t use. In other languages you don&#x27;t get that choice, you basically are required to pay the worst case cost even if you never use it.</div><br/></div></div></div></div><div id="39812834" class="c"><input type="checkbox" id="c-39812834" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812656">parent</a><span>|</span><a href="#39812735">prev</a><span>|</span><a href="#39812591">next</a><span>|</span><label class="collapse" for="c-39812834">[-]</label><label class="expand" for="c-39812834">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In C++ that is not the case which makes C++ pointer to members much more flexible.<p>Here&#x27;s an article describing how to achieve the same effect in D:<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;b68.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;b68.html</a></div><br/><div id="39812933" class="c"><input type="checkbox" id="c-39812933" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812834">parent</a><span>|</span><a href="#39812591">next</a><span>|</span><label class="collapse" for="c-39812933">[-]</label><label class="expand" for="c-39812933">[2 more]</label></div><br/><div class="children"><div class="content">Adding a trampoline means making the calls slower.<p>Even if the lambda were to inline the call, it still would be a completely different location in the executable image.</div><br/><div id="39812993" class="c"><input type="checkbox" id="c-39812993" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812933">parent</a><span>|</span><a href="#39812591">next</a><span>|</span><label class="collapse" for="c-39812993">[-]</label><label class="expand" for="c-39812993">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s almost never used. The delegate version is almost universally used.<p>&gt; Even if the lambda were to inline the call, it still would be a completely different location in the executable image.<p>Not sure what you mean. Inlined code is not in a different location, it&#x27;s right where one is executing! Also, optimizers are pretty darned good these days.</div><br/></div></div></div></div></div></div></div></div><div id="39812591" class="c"><input type="checkbox" id="c-39812591" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#39811702">root</a><span>|</span><a href="#39812565">parent</a><span>|</span><a href="#39812656">prev</a><span>|</span><a href="#39811815">next</a><span>|</span><label class="collapse" for="c-39812591">[-]</label><label class="expand" for="c-39812591">[1 more]</label></div><br/><div class="children"><div class="content">Also, FWIW, Virgil doesn&#x27;t have &quot;pointer to member&quot; for fields; it does have a first-class getter for fields, but not a setter:<p><pre><code>    class C {
        var f: int;
    }
    var x = C.new();
    var g: C -&gt; int = C.f; &#x2F;&#x2F; C.f is a getter method for f
    var z: int = g(x);</code></pre></div><br/></div></div></div></div></div></div><div id="39811815" class="c"><input type="checkbox" id="c-39811815" checked=""/><div class="controls bullet"><span class="by">psyclobe</span><span>|</span><a href="#39811702">prev</a><span>|</span><a href="#39811113">next</a><span>|</span><label class="collapse" for="c-39811815">[-]</label><label class="expand" for="c-39811815">[1 more]</label></div><br/><div class="children"><div class="content">C++ is a never ending series of complexities that lead to incredible use cases</div><br/></div></div><div id="39811113" class="c"><input type="checkbox" id="c-39811113" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#39811815">prev</a><span>|</span><a href="#39811119">next</a><span>|</span><label class="collapse" for="c-39811113">[-]</label><label class="expand" for="c-39811113">[1 more]</label></div><br/><div class="children"><div class="content">Love code made for kicks. Also the other articles on the blog are super different one from the other!</div><br/></div></div><div id="39811119" class="c"><input type="checkbox" id="c-39811119" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#39811113">prev</a><span>|</span><a href="#39813296">next</a><span>|</span><label class="collapse" for="c-39811119">[-]</label><label class="expand" for="c-39811119">[8 more]</label></div><br/><div class="children"><div class="content">This is pretty evil :-D</div><br/><div id="39811299" class="c"><input type="checkbox" id="c-39811299" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#39811119">parent</a><span>|</span><a href="#39813296">next</a><span>|</span><label class="collapse" for="c-39811299">[-]</label><label class="expand" for="c-39811299">[7 more]</label></div><br/><div class="children"><div class="content">But is it as evil as?<p><pre><code>    delete this;
</code></pre>
<a href="https:&#x2F;&#x2F;isocpp.org&#x2F;wiki&#x2F;faq&#x2F;freestore-mgmt#delete-this" rel="nofollow">https:&#x2F;&#x2F;isocpp.org&#x2F;wiki&#x2F;faq&#x2F;freestore-mgmt#delete-this</a></div><br/><div id="39811449" class="c"><input type="checkbox" id="c-39811449" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#39811119">root</a><span>|</span><a href="#39811299">parent</a><span>|</span><a href="#39812629">next</a><span>|</span><label class="collapse" for="c-39811449">[-]</label><label class="expand" for="c-39811449">[2 more]</label></div><br/><div class="children"><div class="content">It certainly has its use cases, e.g. classes with intrusive reference count, where the &quot;release&quot; method would destroy the object once the refcount has reached 0.</div><br/><div id="39812663" class="c"><input type="checkbox" id="c-39812663" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39811119">root</a><span>|</span><a href="#39811449">parent</a><span>|</span><a href="#39812629">next</a><span>|</span><label class="collapse" for="c-39812663">[-]</label><label class="expand" for="c-39812663">[1 more]</label></div><br/><div class="children"><div class="content">Is that really a good use case?  Suppose you have:<p><pre><code>    struct foo {
        atomic&lt;int&gt; refcount;
    
        &#x2F;&#x2F; other stuff
    };
</code></pre>
You can pass around a pointer, COM-style, and call -&gt;Release as needed. But you can be a lot less error-prone by passing around a smart pointer that understands the intrusive refcount and handles releasing. At which point you get something like &#x27;delete ptr&#x27; in a destructor, not &#x27;delete this&#x27; in a Release function.</div><br/></div></div></div></div><div id="39812629" class="c"><input type="checkbox" id="c-39812629" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39811119">root</a><span>|</span><a href="#39811299">parent</a><span>|</span><a href="#39811449">prev</a><span>|</span><a href="#39812319">next</a><span>|</span><label class="collapse" for="c-39812629">[-]</label><label class="expand" for="c-39812629">[2 more]</label></div><br/><div class="children"><div class="content">In a language with affine types (i.e. real move semantics, like Rust but not like C++), destroying this is safe. OTOH <i>deleting</i>, as in freeing memory under the assumption that it was allocated in a particular manner, is only safe if you can somehow enforce that it was allocated that way.</div><br/><div id="39812945" class="c"><input type="checkbox" id="c-39812945" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#39811119">root</a><span>|</span><a href="#39812629">parent</a><span>|</span><a href="#39812319">next</a><span>|</span><label class="collapse" for="c-39812945">[-]</label><label class="expand" for="c-39812945">[1 more]</label></div><br/><div class="children"><div class="content">which you can by making the constructor private.</div><br/></div></div></div></div><div id="39812319" class="c"><input type="checkbox" id="c-39812319" checked=""/><div class="controls bullet"><span class="by">wheybags</span><span>|</span><a href="#39811119">root</a><span>|</span><a href="#39811299">parent</a><span>|</span><a href="#39812629">prev</a><span>|</span><a href="#39813296">next</a><span>|</span><label class="collapse" for="c-39812319">[-]</label><label class="expand" for="c-39812319">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big fan of:<p><pre><code>    this-&gt;~MyClass();
    new (this) MyClass();
</code></pre>
I have unironically used this</div><br/><div id="39812670" class="c"><input type="checkbox" id="c-39812670" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#39811119">root</a><span>|</span><a href="#39812319">parent</a><span>|</span><a href="#39813296">next</a><span>|</span><label class="collapse" for="c-39812670">[-]</label><label class="expand" for="c-39812670">[1 more]</label></div><br/><div class="children"><div class="content">I hope you are confident that this doesn’t point to an instance of a derived class.</div><br/></div></div></div></div></div></div></div></div><div id="39813296" class="c"><input type="checkbox" id="c-39813296" checked=""/><div class="controls bullet"><span class="by">classified</span><span>|</span><a href="#39811119">prev</a><span>|</span><a href="#39813056">next</a><span>|</span><label class="collapse" for="c-39813296">[-]</label><label class="expand" for="c-39813296">[1 more]</label></div><br/><div class="children"><div class="content">Shocking, and very creative. I like it.</div><br/></div></div><div id="39813056" class="c"><input type="checkbox" id="c-39813056" checked=""/><div class="controls bullet"><span class="by">pharrington</span><span>|</span><a href="#39813296">prev</a><span>|</span><a href="#39811321">next</a><span>|</span><label class="collapse" for="c-39813056">[-]</label><label class="expand" for="c-39813056">[1 more]</label></div><br/><div class="children"><div class="content">yes, C++, the original comedy programming language.</div><br/></div></div><div id="39811321" class="c"><input type="checkbox" id="c-39811321" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#39813056">prev</a><span>|</span><a href="#39812218">next</a><span>|</span><label class="collapse" for="c-39811321">[-]</label><label class="expand" for="c-39811321">[8 more]</label></div><br/><div class="children"><div class="content">See also the long right arrow, or &quot;goes to&quot; operator --&gt; (<a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;1642028&#x2F;what-is-the-operator-in-c-c" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;1642028&#x2F;what-is-the-oper...</a>)</div><br/><div id="39811543" class="c"><input type="checkbox" id="c-39811543" checked=""/><div class="controls bullet"><span class="by">alejohausner</span><span>|</span><a href="#39811321">parent</a><span>|</span><a href="#39811720">next</a><span>|</span><label class="collapse" for="c-39811543">[-]</label><label class="expand" for="c-39811543">[4 more]</label></div><br/><div class="children"><div class="content">There’s also the “comes from” operator:<p>while (x &lt;  —  - 10) {
…
}<p>In fact, you can make arrows longer:<p>while (x &lt;—  —  —  —  - 10)<p>And you can make thicker arrows with plus signs:<p>while (x ++++&gt; 10)<p>(hmmm… the HN text formatter is fighting me.  Those are all minus signs)</div><br/><div id="39812097" class="c"><input type="checkbox" id="c-39812097" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39811321">root</a><span>|</span><a href="#39811543">parent</a><span>|</span><a href="#39813483">next</a><span>|</span><label class="collapse" for="c-39812097">[-]</label><label class="expand" for="c-39812097">[1 more]</label></div><br/><div class="children"><div class="content">HN doesn&#x27;t do that. It is your browser or (more likely) the standard text input of your OS.</div><br/></div></div><div id="39813483" class="c"><input type="checkbox" id="c-39813483" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39811321">root</a><span>|</span><a href="#39811543">parent</a><span>|</span><a href="#39812097">prev</a><span>|</span><a href="#39811651">next</a><span>|</span><label class="collapse" for="c-39813483">[-]</label><label class="expand" for="c-39813483">[1 more]</label></div><br/><div class="children"><div class="content">I like the ...___... operator when your code is sinking.</div><br/></div></div><div id="39811651" class="c"><input type="checkbox" id="c-39811651" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#39811321">root</a><span>|</span><a href="#39811543">parent</a><span>|</span><a href="#39813483">prev</a><span>|</span><a href="#39811720">next</a><span>|</span><label class="collapse" for="c-39811651">[-]</label><label class="expand" for="c-39811651">[1 more]</label></div><br/><div class="children"><div class="content">Prepend two spaces to turn a paragraph into a code block which leaves the text as is.<p>Not code --<p><pre><code>  Code -- (“  Code --”)</code></pre></div><br/></div></div></div></div><div id="39811720" class="c"><input type="checkbox" id="c-39811720" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#39811321">parent</a><span>|</span><a href="#39811543">prev</a><span>|</span><a href="#39812218">next</a><span>|</span><label class="collapse" for="c-39811720">[-]</label><label class="expand" for="c-39811720">[3 more]</label></div><br/><div class="children"><div class="content">See also: the tadpole operator (<a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20150525-00&#x2F;?p=45044" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20150525-00&#x2F;?p=45...</a>)<p>Returns x+1 or x-1 depending on the direction the tadpole swims (-~x to increment  x and or ~-x to decrement x). For a short moment I believed this was a real thing, because my programming font has a special ligature for ~- and -~.</div><br/><div id="39811914" class="c"><input type="checkbox" id="c-39811914" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#39811321">root</a><span>|</span><a href="#39811720">parent</a><span>|</span><a href="#39812491">next</a><span>|</span><label class="collapse" for="c-39811914">[-]</label><label class="expand" for="c-39811914">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually useful in a code golf context, because &quot;x * -~y&quot; is two characters shorter than &quot;x * (y + 1)&quot;.</div><br/></div></div><div id="39812491" class="c"><input type="checkbox" id="c-39812491" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39811321">root</a><span>|</span><a href="#39811720">parent</a><span>|</span><a href="#39811914">prev</a><span>|</span><a href="#39812218">next</a><span>|</span><label class="collapse" for="c-39812491">[-]</label><label class="expand" for="c-39812491">[1 more]</label></div><br/><div class="children"><div class="content">Note that &quot;increment&quot; and &quot;decrement&quot; normally refer to changing the value of a variable (what ++ and -- do). It would have been funny if C had defined -~= and ~-= as the increment and decrement operators.</div><br/></div></div></div></div></div></div><div id="39812218" class="c"><input type="checkbox" id="c-39812218" checked=""/><div class="controls bullet"><span class="by">travisd</span><span>|</span><a href="#39811321">prev</a><span>|</span><a href="#39811121">next</a><span>|</span><label class="collapse" for="c-39812218">[-]</label><label class="expand" for="c-39812218">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I hate it!</div><br/></div></div><div id="39811121" class="c"><input type="checkbox" id="c-39811121" checked=""/><div class="controls bullet"><span class="by">dzogchen</span><span>|</span><a href="#39812218">prev</a><span>|</span><a href="#39811077">next</a><span>|</span><label class="collapse" for="c-39811121">[-]</label><label class="expand" for="c-39811121">[42 more]</label></div><br/><div class="children"><div class="content">Operator overloading is one of those things that needs to be done with good taste.</div><br/><div id="39811341" class="c"><input type="checkbox" id="c-39811341" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#39811121">parent</a><span>|</span><a href="#39811978">next</a><span>|</span><label class="collapse" for="c-39811341">[-]</label><label class="expand" for="c-39811341">[4 more]</label></div><br/><div class="children"><div class="content">One of the most magnificent abuses of operator overloading ever: multi-dimensional analog literals (<a href="http:&#x2F;&#x2F;www.eelis.net&#x2F;C++&#x2F;analogliterals.xhtml" rel="nofollow">http:&#x2F;&#x2F;www.eelis.net&#x2F;C++&#x2F;analogliterals.xhtml</a>)</div><br/><div id="39811515" class="c"><input type="checkbox" id="c-39811515" checked=""/><div class="controls bullet"><span class="by">Q6T46nT668w6i3m</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811341">parent</a><span>|</span><a href="#39812058">next</a><span>|</span><label class="collapse" for="c-39811515">[-]</label><label class="expand" for="c-39811515">[1 more]</label></div><br/><div class="children"><div class="content">I don’t hate this! The author is, despite their sarcasm, correct—sometimes integers are insufficiently expressive. It’s the C++ equivalent of geometry in the Wolfram Language.</div><br/></div></div><div id="39812058" class="c"><input type="checkbox" id="c-39812058" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811341">parent</a><span>|</span><a href="#39811515">prev</a><span>|</span><a href="#39811442">next</a><span>|</span><label class="collapse" for="c-39812058">[-]</label><label class="expand" for="c-39812058">[1 more]</label></div><br/><div class="children"><div class="content">This could potentially be extended to UML diagrams to express program logic (or at least to generate SVG versions).</div><br/></div></div><div id="39811442" class="c"><input type="checkbox" id="c-39811442" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811341">parent</a><span>|</span><a href="#39812058">prev</a><span>|</span><a href="#39811978">next</a><span>|</span><label class="collapse" for="c-39811442">[-]</label><label class="expand" for="c-39811442">[1 more]</label></div><br/><div class="children"><div class="content">Truly marvellous!</div><br/></div></div></div></div><div id="39811978" class="c"><input type="checkbox" id="c-39811978" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#39811121">parent</a><span>|</span><a href="#39811341">prev</a><span>|</span><a href="#39811174">next</a><span>|</span><label class="collapse" for="c-39811978">[-]</label><label class="expand" for="c-39811978">[13 more]</label></div><br/><div class="children"><div class="content">Extreme take, but the older I get the more I start thinking that the very concept of operators was a mistake, overloadable or otherwise, especially in a systems language. Even for something as simple as addition there&#x27;s just too many actual operations that I might want to invoke (wrap on overflow, saturate on overflow, crash on overflow, raise exception on overflow, flag on overflow so I can raise later, return boolean to indicate overflow, return tuple of wrapped result and overflowed remainder on overflow).</div><br/><div id="39812048" class="c"><input type="checkbox" id="c-39812048" checked=""/><div class="controls bullet"><span class="by">wwalexander</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811978">parent</a><span>|</span><a href="#39812430">next</a><span>|</span><label class="collapse" for="c-39812048">[-]</label><label class="expand" for="c-39812048">[8 more]</label></div><br/><div class="children"><div class="content">Perhaps operators could <i>only</i> be overloaded, without any defined by the language itself. Then projects could define useful operators for their specific case to make things more terse&#x2F;infix&#x2F;etc. while still requiring awareness of their implementation.</div><br/><div id="39812229" class="c"><input type="checkbox" id="c-39812229" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812048">parent</a><span>|</span><a href="#39812728">next</a><span>|</span><label class="collapse" for="c-39812229">[-]</label><label class="expand" for="c-39812229">[5 more]</label></div><br/><div class="children"><div class="content">No. Haskell made me decide that operators should not be definable by users. It is truly a miserable affair to read terse point free code riddled with operators from a half dozen libraries ( or one overly clever library ).<p>Cleverness is a register that is easy to overflow, and too many don&#x27;t have to good taste to avoid doing so.<p>Give me names every time.</div><br/><div id="39812549" class="c"><input type="checkbox" id="c-39812549" checked=""/><div class="controls bullet"><span class="by">wwalexander</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812229">parent</a><span>|</span><a href="#39812445">next</a><span>|</span><label class="collapse" for="c-39812549">[-]</label><label class="expand" for="c-39812549">[1 more]</label></div><br/><div class="children"><div class="content">That’s a good point. I suppose I was imagining something like internal-only operators that could be defined within the scope of a single module but not exported; though I suppose with any sufficiently large module with enough orthogonal pieces you’d still run into arcane and overly-terse operators.</div><br/></div></div><div id="39812445" class="c"><input type="checkbox" id="c-39812445" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812229">parent</a><span>|</span><a href="#39812549">prev</a><span>|</span><a href="#39812271">next</a><span>|</span><label class="collapse" for="c-39812445">[-]</label><label class="expand" for="c-39812445">[2 more]</label></div><br/><div class="children"><div class="content">It depends on what you tries to do.<p>Doing linear algebra without any operator overloading is just unreadable</div><br/><div id="39812510" class="c"><input type="checkbox" id="c-39812510" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812445">parent</a><span>|</span><a href="#39812271">next</a><span>|</span><label class="collapse" for="c-39812510">[-]</label><label class="expand" for="c-39812510">[1 more]</label></div><br/><div class="children"><div class="content">I think GP meant users should not be able to define new operators (as is possible and fairly common in Haskell), but may still be allowed to overload the existing operators.</div><br/></div></div></div></div><div id="39812271" class="c"><input type="checkbox" id="c-39812271" checked=""/><div class="controls bullet"><span class="by">hollerith</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812229">parent</a><span>|</span><a href="#39812445">prev</a><span>|</span><a href="#39812728">next</a><span>|</span><label class="collapse" for="c-39812271">[-]</label><label class="expand" for="c-39812271">[1 more]</label></div><br/><div class="children"><div class="content">Do you consider them as bad as user-definable Lisp or Scheme macros?</div><br/></div></div></div></div><div id="39812728" class="c"><input type="checkbox" id="c-39812728" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812048">parent</a><span>|</span><a href="#39812229">prev</a><span>|</span><a href="#39812237">next</a><span>|</span><label class="collapse" for="c-39812728">[-]</label><label class="expand" for="c-39812728">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t make &quot;operators&quot; a special case - make them just functions following the normal rules. Scala gets close to this (though sadly it still has some operator precedence rules). To define a function called &quot;plus&quot;, you do &quot;def plus&quot; (or &quot;fun plus&quot; or whatever your syntax is). To define a function called &quot;+&quot; you do &quot;def +&quot;. It&#x27;s so much nicer and more consistent. Yes, some library authors abuse it to write functions or classes with dumb names, but you can write dumb names with letters as well.</div><br/></div></div><div id="39812237" class="c"><input type="checkbox" id="c-39812237" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812048">parent</a><span>|</span><a href="#39812728">prev</a><span>|</span><a href="#39812430">next</a><span>|</span><label class="collapse" for="c-39812237">[-]</label><label class="expand" for="c-39812237">[1 more]</label></div><br/><div class="children"><div class="content">And each library will end up with its own semantics.</div><br/></div></div></div></div><div id="39812430" class="c"><input type="checkbox" id="c-39812430" checked=""/><div class="controls bullet"><span class="by">whiterknight</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811978">parent</a><span>|</span><a href="#39812048">prev</a><span>|</span><a href="#39812286">next</a><span>|</span><label class="collapse" for="c-39812430">[-]</label><label class="expand" for="c-39812430">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately life is complex and all of those semantics are useful. You have to read and write documentation and follow well established conventions (like math).</div><br/><div id="39812762" class="c"><input type="checkbox" id="c-39812762" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812430">parent</a><span>|</span><a href="#39812286">next</a><span>|</span><label class="collapse" for="c-39812762">[-]</label><label class="expand" for="c-39812762">[2 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s the problem, even the mathematical operations in programming languages don&#x27;t follow the established conventions of mathematics. And even mathematics overloads operators all the time to mean subtly different things. And even if it didn&#x27;t, mathematics notation was optimized over centuries for terseness, <i>not</i> for readability, so optimizing programming languages for familiarity with mathematics is optimizing for the wrong thing anyway. We can do better than standard mathematic notation, and that &quot;better&quot; probably looks like &quot;just use properly-named methods or functions that communicate their intent in plain English, not in forbidding moon-runes&quot;.</div><br/><div id="39813043" class="c"><input type="checkbox" id="c-39813043" checked=""/><div class="controls bullet"><span class="by">whiterknight</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812762">parent</a><span>|</span><a href="#39812286">next</a><span>|</span><label class="collapse" for="c-39813043">[-]</label><label class="expand" for="c-39813043">[1 more]</label></div><br/><div class="children"><div class="content">That’s my point.<p>symbols and names are merely suggestive mnemonic devices. They can’t ever specify actual behaviors.<p>Accept it and supplement with English. That’s what math does. You have to read the context.<p>&gt; optimized to tersness<p>That is a form of readability.  If you think there is a conflict you need to explain mathematicians wouldn’t care about readability.</div><br/></div></div></div></div></div></div><div id="39812286" class="c"><input type="checkbox" id="c-39812286" checked=""/><div class="controls bullet"><span class="by">phaedrus</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811978">parent</a><span>|</span><a href="#39812430">prev</a><span>|</span><a href="#39811174">next</a><span>|</span><label class="collapse" for="c-39812286">[-]</label><label class="expand" for="c-39812286">[1 more]</label></div><br/><div class="children"><div class="content">This is especially well illustrated by the &lt;&lt; operator for ostreams in C++.</div><br/></div></div></div></div><div id="39811174" class="c"><input type="checkbox" id="c-39811174" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#39811121">parent</a><span>|</span><a href="#39811978">prev</a><span>|</span><a href="#39811707">next</a><span>|</span><label class="collapse" for="c-39811174">[-]</label><label class="expand" for="c-39811174">[22 more]</label></div><br/><div class="children"><div class="content">Honestly I can&#x27;t think of many notable abuses of operator overloading in C++.<p>The worst is probably the original idea to overload the bit shift operators for stream I&#x2F;O, something which never really caught on outside the standard library.</div><br/><div id="39811238" class="c"><input type="checkbox" id="c-39811238" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39811509">next</a><span>|</span><label class="collapse" for="c-39811238">[-]</label><label class="expand" for="c-39811238">[1 more]</label></div><br/><div class="children"><div class="content">Agree. Meanwhile there are flagship C++ libraries like Eigen where it&#x27;s indispensable. C++ has mistakes but operator overloading isn&#x27;t one of them.</div><br/></div></div><div id="39811509" class="c"><input type="checkbox" id="c-39811509" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39811238">prev</a><span>|</span><a href="#39811256">next</a><span>|</span><label class="collapse" for="c-39811509">[-]</label><label class="expand" for="c-39811509">[5 more]</label></div><br/><div class="children"><div class="content">I remember a university project where I used the &gt;&gt; (and &lt;&lt;) operators to &quot;send&quot; data between services.<p>The code was a simulation of a parallel system with multiple services that sent messages between them, or something like that. Instead of using serviceA.send(&quot;hello&quot;,serviceB) you had something like serviceA &gt;&gt; &quot;hello&quot; &gt;&gt; serviceB.<p>I really loved that (my classmates not so much)</div><br/><div id="39812111" class="c"><input type="checkbox" id="c-39812111" checked=""/><div class="controls bullet"><span class="by">lioeters</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811509">parent</a><span>|</span><a href="#39812061">next</a><span>|</span><label class="collapse" for="c-39812111">[-]</label><label class="expand" for="c-39812111">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of the ChucK operator.<p><pre><code>  SinOsc b =&gt; Gain g =&gt; BiQuad f =&gt; dac;
</code></pre>
<a href="https:&#x2F;&#x2F;chuck.stanford.edu&#x2F;doc&#x2F;language&#x2F;oper.html#chuck" rel="nofollow">https:&#x2F;&#x2F;chuck.stanford.edu&#x2F;doc&#x2F;language&#x2F;oper.html#chuck</a></div><br/></div></div><div id="39812061" class="c"><input type="checkbox" id="c-39812061" checked=""/><div class="controls bullet"><span class="by">puffybuf</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811509">parent</a><span>|</span><a href="#39812111">prev</a><span>|</span><a href="#39811256">next</a><span>|</span><label class="collapse" for="c-39812061">[-]</label><label class="expand" for="c-39812061">[3 more]</label></div><br/><div class="children"><div class="content">I did something similar as a student, making my own exception class with std::ostream:<p>throw exceptionC() &lt;&lt; &quot;error code: &quot; &lt;&lt; t;<p>I often found myself having to format error strings for exceptions, so I thought I could just do it like cout in one line. I know now this is bad for i18n strings.</div><br/><div id="39812733" class="c"><input type="checkbox" id="c-39812733" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812061">parent</a><span>|</span><a href="#39812107">next</a><span>|</span><label class="collapse" for="c-39812733">[-]</label><label class="expand" for="c-39812733">[1 more]</label></div><br/><div class="children"><div class="content">Why would you prefer that over:<p><pre><code>  throw exceptionC(&quot;error code: &quot;, t);
</code></pre>
?<p>Ever since perfect forwarding I&#x27;ve been using this pattern to get out of arrow hell:<p><pre><code>  template &lt;typename Arg, typename...Args&gt;
  string to_string(Arg &amp;&amp;arg, Args &amp;&amp;...args) {
    stringstream buf;
    buf &lt;&lt; arg;
    ((buf &lt;&lt; std::forward&lt;Args&gt;(args)), ...);
    return buf.str();
  }</code></pre></div><br/></div></div><div id="39812107" class="c"><input type="checkbox" id="c-39812107" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812061">parent</a><span>|</span><a href="#39812733">prev</a><span>|</span><a href="#39811256">next</a><span>|</span><label class="collapse" for="c-39812107">[-]</label><label class="expand" for="c-39812107">[1 more]</label></div><br/><div class="children"><div class="content">Googletest does this: <a href="http:&#x2F;&#x2F;google.github.io&#x2F;googletest&#x2F;primer.html#assertions" rel="nofollow">http:&#x2F;&#x2F;google.github.io&#x2F;googletest&#x2F;primer.html#assertions</a></div><br/></div></div></div></div></div></div><div id="39811256" class="c"><input type="checkbox" id="c-39811256" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39811509">prev</a><span>|</span><a href="#39811510">next</a><span>|</span><label class="collapse" for="c-39811256">[-]</label><label class="expand" for="c-39811256">[1 more]</label></div><br/><div class="children"><div class="content">There could be a couple of examples in Boost like Boost Spirit [0]. Qt had some like putting stuff in containers with bitshift operator. There was a GUI toolkit that used + operator to put widgets on a window.<p>[0] <a href="https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_78_0&#x2F;libs&#x2F;spirit&#x2F;doc&#x2F;html&#x2F;spirit&#x2F;introduction.html" rel="nofollow">https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_78_0&#x2F;libs&#x2F;spirit&#x2F;doc&#x2F;html&#x2F;s...</a></div><br/></div></div><div id="39811510" class="c"><input type="checkbox" id="c-39811510" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39811256">prev</a><span>|</span><a href="#39811570">next</a><span>|</span><label class="collapse" for="c-39811510">[-]</label><label class="expand" for="c-39811510">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen operator* overloaded to return RAII guards, including ones for RCU, and operator() overloaded for so many things that should just be lambdas it&#x27;s hilarious</div><br/><div id="39811580" class="c"><input type="checkbox" id="c-39811580" checked=""/><div class="controls bullet"><span class="by">DrFalkyn</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811510">parent</a><span>|</span><a href="#39811570">next</a><span>|</span><label class="collapse" for="c-39811580">[-]</label><label class="expand" for="c-39811580">[4 more]</label></div><br/><div class="children"><div class="content">Yeah the () overload was for functors, the old school way of doing closures before lambdas.</div><br/><div id="39811905" class="c"><input type="checkbox" id="c-39811905" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811580">parent</a><span>|</span><a href="#39811570">next</a><span>|</span><label class="collapse" for="c-39811905">[-]</label><label class="expand" for="c-39811905">[3 more]</label></div><br/><div class="children"><div class="content">It was certainly how I learned to do it, but lambdas have been around for over a decade and I still see people writing functors. The only use case I&#x27;ve seen where it made sense is for things like coroutines.</div><br/><div id="39812324" class="c"><input type="checkbox" id="c-39812324" checked=""/><div class="controls bullet"><span class="by">ksherlock</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811905">parent</a><span>|</span><a href="#39811570">next</a><span>|</span><label class="collapse" for="c-39812324">[-]</label><label class="expand" for="c-39812324">[2 more]</label></div><br/><div class="children"><div class="content">For std::visit() (std::variant.visit in c++26 I see) which is the visitor pattern, you can use a functor with multiple visit types or roll your own overload() template to merge multiple lambdas into one class.<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;variant&#x2F;visit" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;variant&#x2F;visit</a><p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;variant&#x2F;visit2" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;variant&#x2F;visit2</a></div><br/><div id="39812851" class="c"><input type="checkbox" id="c-39812851" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39812324">parent</a><span>|</span><a href="#39811570">next</a><span>|</span><label class="collapse" for="c-39812851">[-]</label><label class="expand" for="c-39812851">[1 more]</label></div><br/><div class="children"><div class="content">But why would I want to do this instead of just having multiple lambdas that capture the same values by reference, or using shared_ptr and synchronization? I can see lifetimes of the data being an issue, but you shouldn&#x27;t be calling std::visit in a way where that could cause a problem without synchronization anyway.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39811570" class="c"><input type="checkbox" id="c-39811570" checked=""/><div class="controls bullet"><span class="by">barosl</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39811510">prev</a><span>|</span><a href="#39811351">next</a><span>|</span><label class="collapse" for="c-39811570">[-]</label><label class="expand" for="c-39811570">[2 more]</label></div><br/><div class="children"><div class="content">&gt; to overload the bit shift operators for stream I&#x2F;O<p>MFC extends this idea to network programming, allowing the use of shift operators to send and receive data.</div><br/><div id="39812595" class="c"><input type="checkbox" id="c-39812595" checked=""/><div class="controls bullet"><span class="by">wolfspider</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811570">parent</a><span>|</span><a href="#39811351">next</a><span>|</span><label class="collapse" for="c-39812595">[-]</label><label class="expand" for="c-39812595">[1 more]</label></div><br/><div class="children"><div class="content">MFC also has CComPtrBase which uses &amp; to represent pointer lifetimes to COM objects such as while(pEnum-&gt;Next(1, &amp;pFilter, &amp;cFetched) == S_OK). Especially fun when debugging DirectShow filtergraphs someone made in the UI completely. There is more of an explanation here: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20221010-00&#x2F;?p=107269" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20221010-00&#x2F;?p=10...</a></div><br/></div></div></div></div><div id="39811351" class="c"><input type="checkbox" id="c-39811351" checked=""/><div class="controls bullet"><span class="by">rwbt</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39811570">prev</a><span>|</span><a href="#39812231">next</a><span>|</span><label class="collapse" for="c-39811351">[-]</label><label class="expand" for="c-39811351">[1 more]</label></div><br/><div class="children"><div class="content">The soon to be standard C++26 Reflection library?</div><br/></div></div><div id="39812231" class="c"><input type="checkbox" id="c-39812231" checked=""/><div class="controls bullet"><span class="by">garaetjjte</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39811351">prev</a><span>|</span><a href="#39811332">next</a><span>|</span><label class="collapse" for="c-39812231">[-]</label><label class="expand" for="c-39812231">[1 more]</label></div><br/><div class="children"><div class="content">operator&#x2F; for concatenating path components in std::filesystem</div><br/></div></div><div id="39811332" class="c"><input type="checkbox" id="c-39811332" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811174">parent</a><span>|</span><a href="#39812231">prev</a><span>|</span><a href="#39811707">next</a><span>|</span><label class="collapse" for="c-39811332">[-]</label><label class="expand" for="c-39811332">[5 more]</label></div><br/><div class="children"><div class="content">Continuation passing monads form the basis of a perfectly valid and usable software architecture and programming pattern.<p>In the case of ostream and operator&lt;&lt;, this pattern reduces the number of intermediate objects that would otherwise be constructed.<p>If you object to iostream on religious or stylistic grounds, there&#x27;s always fmt which is more like Go or Python string interpolation.[0]<p>0. <a href="https:&#x2F;&#x2F;fmt.dev" rel="nofollow">https:&#x2F;&#x2F;fmt.dev</a></div><br/><div id="39811368" class="c"><input type="checkbox" id="c-39811368" checked=""/><div class="controls bullet"><span class="by">rwbt</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811332">parent</a><span>|</span><a href="#39812602">next</a><span>|</span><label class="collapse" for="c-39811368">[-]</label><label class="expand" for="c-39811368">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you object to iostream on religious or stylistic grounds,<p>No I object to it on usability grounds. It took more than 30 years for the committee to admit it but C++ now has typesafe std::print&#x2F;std::format finally, after admonishing programmers for using `printf` in C.</div><br/></div></div><div id="39812602" class="c"><input type="checkbox" id="c-39812602" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811332">parent</a><span>|</span><a href="#39811368">prev</a><span>|</span><a href="#39811376">next</a><span>|</span><label class="collapse" for="c-39812602">[-]</label><label class="expand" for="c-39812602">[1 more]</label></div><br/><div class="children"><div class="content">Which part of operator&lt;&lt; involves continuations, let alone continuation passing monads?</div><br/></div></div><div id="39811376" class="c"><input type="checkbox" id="c-39811376" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811332">parent</a><span>|</span><a href="#39812602">prev</a><span>|</span><a href="#39811707">next</a><span>|</span><label class="collapse" for="c-39811376">[-]</label><label class="expand" for="c-39811376">[2 more]</label></div><br/><div class="children"><div class="content">But it is achievable without operator overloading, isn&#x27;t it? There is also a reason why format strings seem to be more popular among the crowd.</div><br/><div id="39811452" class="c"><input type="checkbox" id="c-39811452" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39811121">root</a><span>|</span><a href="#39811376">parent</a><span>|</span><a href="#39811707">next</a><span>|</span><label class="collapse" for="c-39811452">[-]</label><label class="expand" for="c-39811452">[1 more]</label></div><br/><div class="children"><div class="content">Streams have numerous design problems (e.g. representation is managed by the stream, not the thing you’re printing) making the shift operator syntax the least of the problems.</div><br/></div></div></div></div></div></div></div></div><div id="39811707" class="c"><input type="checkbox" id="c-39811707" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#39811121">parent</a><span>|</span><a href="#39811174">prev</a><span>|</span><a href="#39812132">next</a><span>|</span><label class="collapse" for="c-39811707">[-]</label><label class="expand" for="c-39811707">[1 more]</label></div><br/><div class="children"><div class="content">That was a very cheeky comment, and fully agreed.<p>I&#x27;m on the permissive side (Haskell and Lenseful Haskell at that!), but make it consistent and principled and it&#x27;s usually fine.</div><br/></div></div></div></div><div id="39811077" class="c"><input type="checkbox" id="c-39811077" checked=""/><div class="controls bullet"><span class="by">rryugciuf</span><span>|</span><a href="#39811121">prev</a><span>|</span><a href="#39811286">next</a><span>|</span><label class="collapse" for="c-39811077">[-]</label><label class="expand" for="c-39811077">[2 more]</label></div><br/><div class="children"><div class="content">Oh my</div><br/></div></div><div id="39811286" class="c"><input type="checkbox" id="c-39811286" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#39811077">prev</a><span>|</span><label class="collapse" for="c-39811286">[-]</label><label class="expand" for="c-39811286">[1 more]</label></div><br/><div class="children"><div class="content"><i>Haskell, F#, and Scala enter the chat to lend a hand with custom operators.</i></div><br/></div></div></div></div></div></div></div></body></html>