<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722762051907" as="style"/><link rel="stylesheet" href="styles.css?v=1722762051907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2024/08/01/primitive-recursive-functions.html">Primitive Recursive Functions for a Working Programmer</a> <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>ingve</span> | <span>48 comments</span></div><br/><div><div id="41151523" class="c"><input type="checkbox" id="c-41151523" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#41147078">next</a><span>|</span><label class="collapse" for="c-41151523">[-]</label><label class="expand" for="c-41151523">[1 more]</label></div><br/><div class="children"><div class="content">Self-promotion: <a href="https:&#x2F;&#x2F;www.nayuki.io&#x2F;page&#x2F;primitive-recursive-functions" rel="nofollow">https:&#x2F;&#x2F;www.nayuki.io&#x2F;page&#x2F;primitive-recursive-functions</a></div><br/></div></div><div id="41147078" class="c"><input type="checkbox" id="c-41147078" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41151523">prev</a><span>|</span><a href="#41146508">next</a><span>|</span><label class="collapse" for="c-41147078">[-]</label><label class="expand" for="c-41147078">[5 more]</label></div><br/><div class="children"><div class="content">The conclusion to the article has some pretty good points regarding configuration languages; I wonder if any present language satisfies all or most of those points.</div><br/><div id="41147463" class="c"><input type="checkbox" id="c-41147463" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41147078">parent</a><span>|</span><a href="#41147124">next</a><span>|</span><label class="collapse" for="c-41147463">[-]</label><label class="expand" for="c-41147463">[1 more]</label></div><br/><div class="children"><div class="content">While imperative, and not &#x27;pure&#x27; even C was created to set upper bound of the number of iterations of every loop being known before entering, thus PR<p>Dennis Ritchie&#x27;s research at MIT was focused on what he called loop programming.<p>The complexity of loop programs - ALBERT R. MEYER and DENNIS M. RITCHIE<p><a href="https:&#x2F;&#x2F;people.csail.mit.edu&#x2F;meyer&#x2F;meyer-ritchie.pdf" rel="nofollow">https:&#x2F;&#x2F;people.csail.mit.edu&#x2F;meyer&#x2F;meyer-ritchie.pdf</a><p>Structured programming, the paradigm that almost every modern programmer follows by default is really pushing you to primitive recursive functions.<p>That almost universal acceptance of structured programming compared to the other two types, pop and functional, is why people are confused about Dykstra&#x27;s goto is harmful paper.<p>While primitive recursive functions don&#x27;t contain the entire set of computable functions, they do contain almost all intuitive ones that are guaranteed to HALT (total).<p>Unfortunately there are some real needs for languages to support loops that have an indeterminate number of iterations when you enter the loop, but it is a foot gun that is avoidable by only using them when required.<p>Even COBOL was modernized with unrestricted goto being moved to the ALTER command.<p>I can&#x27;t think of a modern, useful language that doesn&#x27;t allow for PR functions.<p>But even in C, if you avoid &#x27;while&#x27;, explicitly avoid fall through, etc... you will produce code that almost always is a total functions that will always HALT.<p>There are cases like even type inference in ML, which is pathological in that it is way cheaper than the complexity class, thus worth the risk, despite not being total functions that make it hard for a language to restrict those use cases.<p>So I would say that with a pragmatic approach, all languages support defaults that support most of the points, but imposed constraints that enforce them would seriously constrain the utility of the language.<p>If you review even the hated SOLID and Clean frameworks, they&#x27;re pushing you towards this model too IMHO.<p>I think the universal acceptance of structured programming, makes this easy to forget or even fail to teach.  But as an old neck beard, we were taught the risks of WHILE etc...</div><br/></div></div><div id="41147124" class="c"><input type="checkbox" id="c-41147124" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41147078">parent</a><span>|</span><a href="#41147463">prev</a><span>|</span><a href="#41146508">next</a><span>|</span><label class="collapse" for="c-41147124">[-]</label><label class="expand" for="c-41147124">[3 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s pick Dhall and see if it fails any of the points. It seems closest.</div><br/><div id="41148863" class="c"><input type="checkbox" id="c-41148863" checked=""/><div class="controls bullet"><span class="by">talideon</span><span>|</span><a href="#41147078">root</a><span>|</span><a href="#41147124">parent</a><span>|</span><a href="#41146508">next</a><span>|</span><label class="collapse" for="c-41148863">[-]</label><label class="expand" for="c-41148863">[2 more]</label></div><br/><div class="children"><div class="content">Skylark also. It&#x27;s essentially Python with anything more than primitive recursive functions cut out.</div><br/><div id="41149288" class="c"><input type="checkbox" id="c-41149288" checked=""/><div class="controls bullet"><span class="by">extrabajs</span><span>|</span><a href="#41147078">root</a><span>|</span><a href="#41148863">parent</a><span>|</span><a href="#41146508">next</a><span>|</span><label class="collapse" for="c-41149288">[-]</label><label class="expand" for="c-41149288">[1 more]</label></div><br/><div class="children"><div class="content">One point that the article is trying to make is that even something in PRF can give rise to a very long-running computation.</div><br/></div></div></div></div></div></div></div></div><div id="41146508" class="c"><input type="checkbox" id="c-41146508" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#41147078">prev</a><span>|</span><a href="#41147566">next</a><span>|</span><label class="collapse" for="c-41146508">[-]</label><label class="expand" for="c-41146508">[9 more]</label></div><br/><div class="children"><div class="content">Just tackling the first part, about restricted languages being better for some applications:<p>Isn’t the advantage that an upper bound on the number of steps required can be computed statically?<p>This means we can refuse to compute things that violate some limit and give back a meaningful error, for all possible inputs.<p>Whereas with the <i>Turing complete plus Runtime Limit</i> approach, we might pick a limit that is too low for some inputs we care about. We won’t know until we run the computation and hit the limit! We see this sometimes with C++ template recursion.<p>I might be totally confused here so I hope some more knowledgable can weigh in :)</div><br/><div id="41146634" class="c"><input type="checkbox" id="c-41146634" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41146508">parent</a><span>|</span><a href="#41147293">next</a><span>|</span><label class="collapse" for="c-41146634">[-]</label><label class="expand" for="c-41146634">[1 more]</label></div><br/><div class="children"><div class="content">Accurately predicting fuel usage for a blockchain computation?  It&#x27;s probably interesting to others but not to me.<p>I&#x27;d be more interested in using it just as another hammer in the tool-belt to squash bugs that got past earlier hammers (static type-checking, no nulls, no mutations, etc.)<p>Terminating in finite time can&#x27;t prove correctness, but if I declare that my code will terminate in finite time and my compiler disagrees, I&#x27;d certainly believe my code is incorrect.</div><br/></div></div><div id="41147293" class="c"><input type="checkbox" id="c-41147293" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41146508">parent</a><span>|</span><a href="#41146634">prev</a><span>|</span><a href="#41148049">next</a><span>|</span><label class="collapse" for="c-41147293">[-]</label><label class="expand" for="c-41147293">[3 more]</label></div><br/><div class="children"><div class="content">I use 10x the reasonable computation amount, ever since a coworker used a number closer to 3x and real workloads hit that limit a few years later. I figure giving a bad workflow several times longer to fail is still measured in milliseconds and doesn’t hurt that much.<p>But I usually run into this problem when someone has treated the problem domain as a DAG but can’t enforce the Acyclic part. But modeling your problem as a DAG is reminiscent of Dark Galadriel, when she contemplates taking the arming from Frodo - All Shall Love Me and Despair. The people who make them are always way prouder of themselves than they deserve to be.<p>Eventually your customers who were attracted by the expensive and complex solution to their problems run out of money, and their problems seem a lot smaller to them. Then you are left - literally - with an app that cannot be made cheap enough per operation to keep their business.</div><br/><div id="41150185" class="c"><input type="checkbox" id="c-41150185" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#41146508">root</a><span>|</span><a href="#41147293">parent</a><span>|</span><a href="#41149523">next</a><span>|</span><label class="collapse" for="c-41150185">[-]</label><label class="expand" for="c-41150185">[1 more]</label></div><br/><div class="children"><div class="content">3 is roughly half of ten logarithmically. And in any business that uses software (to co duct the business) you always want engineering to keep in mind the doubling time, or if the business is shrinking. A lot of efficiency decisions are driven by doubling time. I worked where we had doubling time of 90 days when I started and there keeping everything scaled up so that your idle capacity was. On more than half made sense. When it had increased to a couple years, then your could tighten down to n&#x2F;n+1 utilization. If it is shrinking, first of all that&#x27;s a problem, but also you can make the infra much cheaper pretty easily, if the code is still modifiable.</div><br/></div></div><div id="41149523" class="c"><input type="checkbox" id="c-41149523" checked=""/><div class="controls bullet"><span class="by">gopher_space</span><span>|</span><a href="#41146508">root</a><span>|</span><a href="#41147293">parent</a><span>|</span><a href="#41150185">prev</a><span>|</span><a href="#41148049">next</a><span>|</span><label class="collapse" for="c-41149523">[-]</label><label class="expand" for="c-41149523">[1 more]</label></div><br/><div class="children"><div class="content">&gt; treated the problem domain as a DAG but can’t enforce the Acyclic part.<p>Would you mind talking about this for a bit?  I&#x27;m missing a lot of context.</div><br/></div></div></div></div><div id="41148049" class="c"><input type="checkbox" id="c-41148049" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41146508">parent</a><span>|</span><a href="#41147293">prev</a><span>|</span><a href="#41149548">next</a><span>|</span><label class="collapse" for="c-41148049">[-]</label><label class="expand" for="c-41148049">[1 more]</label></div><br/><div class="children"><div class="content">And what if that upper bound is an extremely loose upper bound? Say a deterministic quick sort has an upper bound that&#x27;s quadratic in input size even though typically it&#x27;s linearithmic? Do you refuse the computation of quick sort then? Or more dramatically consider the Hindley–Milner algorithm which has an upper bound of exponential time even though in practice it runs in linear time?</div><br/></div></div><div id="41149548" class="c"><input type="checkbox" id="c-41149548" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41146508">parent</a><span>|</span><a href="#41148049">prev</a><span>|</span><a href="#41147566">next</a><span>|</span><label class="collapse" for="c-41149548">[-]</label><label class="expand" for="c-41149548">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about &quot;computed statically&quot; but yeah I think the only advantage to drastically limiting the capabilities of a language (as in many new configuration languages, CEL, etc.) is that you can have a sort of computation limit that isn&#x27;t <i>data dependent</i>.<p>But I struggle to think of a single situation in which that&#x27;s a real hard requirement. How many systems are there that can&#x27;t give a &quot;query took too long&quot; error?</div><br/><div id="41150190" class="c"><input type="checkbox" id="c-41150190" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#41146508">root</a><span>|</span><a href="#41149548">parent</a><span>|</span><a href="#41147566">next</a><span>|</span><label class="collapse" for="c-41150190">[-]</label><label class="expand" for="c-41150190">[2 more]</label></div><br/><div class="children"><div class="content">Well if the query is from an adversary it has undesirable results.</div><br/><div id="41151740" class="c"><input type="checkbox" id="c-41151740" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41146508">root</a><span>|</span><a href="#41150190">parent</a><span>|</span><a href="#41147566">next</a><span>|</span><label class="collapse" for="c-41151740">[-]</label><label class="expand" for="c-41151740">[1 more]</label></div><br/><div class="children"><div class="content">Like what? Can you give an example?</div><br/></div></div></div></div></div></div></div></div><div id="41147566" class="c"><input type="checkbox" id="c-41147566" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#41146508">prev</a><span>|</span><a href="#41146722">next</a><span>|</span><label class="collapse" for="c-41147566">[-]</label><label class="expand" for="c-41147566">[2 more]</label></div><br/><div class="children"><div class="content">I am a CUE developer. CUE is primitive recursive. It also happens to fulfill your desired criteria for a &quot;good&quot; configuration language.</div><br/><div id="41149229" class="c"><input type="checkbox" id="c-41149229" checked=""/><div class="controls bullet"><span class="by">4ad</span><span>|</span><a href="#41147566">parent</a><span>|</span><a href="#41146722">next</a><span>|</span><label class="collapse" for="c-41149229">[-]</label><label class="expand" for="c-41149229">[1 more]</label></div><br/><div class="children"><div class="content">For fun, here is CUE simulating an arbitrary but finite number of steps of Rule 110[0]: <a href="https:&#x2F;&#x2F;cuelang.org&#x2F;play&#x2F;?id=Ityqia88Mvq#w=function&amp;i=cue&amp;f=export&amp;o=cue" rel="nofollow">https:&#x2F;&#x2F;cuelang.org&#x2F;play&#x2F;?id=Ityqia88Mvq#w=function&amp;i=cue&amp;f=...</a><p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110</a></div><br/></div></div></div></div><div id="41146722" class="c"><input type="checkbox" id="c-41146722" checked=""/><div class="controls bullet"><span class="by">ch0ic3</span><span>|</span><a href="#41147566">prev</a><span>|</span><a href="#41146673">next</a><span>|</span><label class="collapse" for="c-41146722">[-]</label><label class="expand" for="c-41146722">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;m struggling with the mini rant &#x2F; motivation of the article:<p>&gt; Typically, not being Turing-complete is extolled as a virtue or even a requirement in specific domains. I claim that most such discussions are misinformed — that not being Turing complete doesn’t actually mean what folks want it to mean<p>Why are those discussion misinformed?  Most formal analysis tools (Coq, Isabelle, Agda(?)) usually require a proof that a function terminates.  This is I think is equivalent to proving that it is total implying it is primitive recursive?</div><br/><div id="41147597" class="c"><input type="checkbox" id="c-41147597" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41146722">parent</a><span>|</span><a href="#41147115">next</a><span>|</span><label class="collapse" for="c-41147597">[-]</label><label class="expand" for="c-41147597">[5 more]</label></div><br/><div class="children"><div class="content">As you are talking about formal proofs, and not the scientific counterexamples modern programming uses:<p>Proving a function is total in the general case is a NP total search problem.<p>IIRC this is equivalent to NP with a co-NP oracle, or the second level on the PH hierarchy, aka expensive if even possible even in many small problems.<p>Most of those tools work best if you structure your programs to be total, of which structural programing with only FOR or iteration count limited WHILE&#x2F;recursion are some the most common methods.<p>While just related to SAT, look at the tractable forms of Schaefer&#x27;s dichotomy theorem is the most accessible lens I can think of.</div><br/><div id="41148079" class="c"><input type="checkbox" id="c-41148079" checked=""/><div class="controls bullet"><span class="by">BalinKing</span><span>|</span><a href="#41146722">root</a><span>|</span><a href="#41147597">parent</a><span>|</span><a href="#41147115">next</a><span>|</span><label class="collapse" for="c-41148079">[-]</label><label class="expand" for="c-41148079">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Proving a function is total in the general case is a NP total search problem.<p>My intuition suggests this should be undecidable—could you elaborate on the difference between this and the halting problem?</div><br/><div id="41148619" class="c"><input type="checkbox" id="c-41148619" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#41146722">root</a><span>|</span><a href="#41148079">parent</a><span>|</span><a href="#41148502">next</a><span>|</span><label class="collapse" for="c-41148619">[-]</label><label class="expand" for="c-41148619">[2 more]</label></div><br/><div class="children"><div class="content">Halt is a decision problem, TFNP is a combinatorial problem constructed of decision problems.<p>The HALT decider is a total Turing machine that represents a total function.<p>I am struggling to explain this in a rigorous fashion, and there are many open problems.<p>NP is where the answer &quot;yes&quot; is verifiable in polynomial time.<p>co-NP is where the answer &quot;no&quot; is verifiable in polynomial time.<p>NP is equivalent to second order predicts logic where the second term is existential &#x27;there exists..&#x27;<p>co-NP is equivalent to second order predicts logic where the second term is universal &#x27;for any&#x27;<p>We know P=co-P, or that the yes and no answers are both truthy.<p>We think that NP!=co-NP<p>Many useful problems are semi-decidable or recursively enumerable.<p>Determining if a computable function is total is not semi-decidable.<p>It is the subtle difference between proving a TM halts for any input vs  halts for each input.<p>Termination analysis is the field of trying to figure out if it halts for each input. It is actually harder than HALT, being on the second level of PH on the co-NP side.<p>If that granularity isn&#x27;t important to you, I personally don&#x27;t think there is much of a risk in using the decidable metric as a lens.<p>Just remember that something is decidable if and only if both it and its complement are semi-decidable.<p>Semi-decidable problems often have practical applications even without resorting to approximations etc ...</div><br/><div id="41151139" class="c"><input type="checkbox" id="c-41151139" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#41146722">root</a><span>|</span><a href="#41148619">parent</a><span>|</span><a href="#41148502">next</a><span>|</span><label class="collapse" for="c-41151139">[-]</label><label class="expand" for="c-41151139">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure this really addresses GP&#x27;s question, which I share.<p>You claimed in GGP that deciding whether a function is total is a TFNP problem. In particular, that would make it decidable. But the counter-claim is that deciding whether a function is total is actually an undecidable problem.<p>I&#x27;ve also examined a definition of TFNP and I don&#x27;t see how it is related to the problem of deciding if a function is total. Rather, the definition seems to require that the function in question be total.</div><br/></div></div></div></div><div id="41148502" class="c"><input type="checkbox" id="c-41148502" checked=""/><div class="controls bullet"><span class="by">colevee</span><span>|</span><a href="#41146722">root</a><span>|</span><a href="#41148079">parent</a><span>|</span><a href="#41148619">prev</a><span>|</span><a href="#41147115">next</a><span>|</span><label class="collapse" for="c-41148502">[-]</label><label class="expand" for="c-41148502">[1 more]</label></div><br/><div class="children"><div class="content">Your intuition is right. The total functions are not even a provable set. So they are definitely not recursive or even FNP; never mind TFNP. Provability of the total functions would imply decidability of an even harder problem than the halting problem: whether a given Turing machine halts on _all_ inputs.<p>The halting problem only asks: given a TM and input, will the TM halt on that input? That problem is actually semi-decidable&#x2F;provable: we just run the machine. If the answer is yes, then at some point it will halt!</div><br/></div></div></div></div></div></div><div id="41147115" class="c"><input type="checkbox" id="c-41147115" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41146722">parent</a><span>|</span><a href="#41147597">prev</a><span>|</span><a href="#41146844">next</a><span>|</span><label class="collapse" for="c-41147115">[-]</label><label class="expand" for="c-41147115">[1 more]</label></div><br/><div class="children"><div class="content">Possibly there are more ways to be non-Turing-complete than being a nice total terminating function. For instance,  an infinite loop is neither capable of universal computation nor is terminating.</div><br/></div></div><div id="41146844" class="c"><input type="checkbox" id="c-41146844" checked=""/><div class="controls bullet"><span class="by">bmillwood</span><span>|</span><a href="#41146722">parent</a><span>|</span><a href="#41147115">prev</a><span>|</span><a href="#41147411">next</a><span>|</span><label class="collapse" for="c-41146844">[-]</label><label class="expand" for="c-41146844">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This is I think is equivalent to proving that it is total implying it is primitive recursive?<p>No, as the article shows there are functions which terminate that aren&#x27;t primitive recursive, and indeed Agda and (probably?) the others can prove termination for some (but necessarily not all) terminating non-primitive-recursive functions.<p>I think the misinformation that the article is complaining about is something like (my paraphrase):<p>&gt; &quot;Turing completeness&quot; means &quot;can do computation&quot; while &quot;non-Turing complete&quot; means both &quot;can&#x27;t do computation&quot; and &quot;has nice configuration-language properties&quot;<p>The article points out:<p>- you can be non-Turing complete and still do lots of computationally-expensive &#x2F; tricky work<p>- your configuration language probably wants much stricter limits than merely being non-Turing complete</div><br/><div id="41147389" class="c"><input type="checkbox" id="c-41147389" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#41146722">root</a><span>|</span><a href="#41146844">parent</a><span>|</span><a href="#41147411">next</a><span>|</span><label class="collapse" for="c-41147389">[-]</label><label class="expand" for="c-41147389">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think the misinformation that the article is complaining about is something like (my paraphrase):<p>&gt; &gt; &quot;Turing completeness&quot; means &quot;can do computation&quot; while &quot;non-Turing complete&quot; means both &quot;can&#x27;t do computation&quot; and &quot;has nice configuration-language properties&quot;<p>&quot;Turing complete&quot; means it can do <i>any</i> computation a Turing machine can. That is absolutely more power than is desired about 99.99% of the time. You almost always want your algorithms to contain no infinite loops.<p>(Algorithms. Not IO loops. Those are different, and the process of taking outside input while the program is running is outside the scope of what a Turing machine talks about anyway.)<p>Turing completeness is an ergonomics hack, and one with a decently successful history. But it&#x27;s no panacea, and if we could find an ergonomic way to get rid of it, that would be a win.<p>Yes, even if we didn&#x27;t also enforce primitive recursion. Sure, it&#x27;s nice to know you&#x27;re also not accidentally running Ackerman&#x27;s function, but to be honest... I&#x27;ve had many more accidental infinite loops than accidental Ackerman&#x27;s functions in my code. By approximately 10,000 to 0.<p>No system can ever prevent all errors. So let&#x27;s focus on preventing the most common current ones.</div><br/><div id="41150167" class="c"><input type="checkbox" id="c-41150167" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#41146722">root</a><span>|</span><a href="#41147389">parent</a><span>|</span><a href="#41147411">next</a><span>|</span><label class="collapse" for="c-41150167">[-]</label><label class="expand" for="c-41150167">[1 more]</label></div><br/><div class="children"><div class="content">First thing I do when I am learning a new high level language is write Ackermann function and see what happens. Also write out plus and mult and expt in terms of +=1. I have seen people with O(n^4) code when they could have easily used O(log n) but never seen an Ackermann in the wild.</div><br/></div></div></div></div></div></div><div id="41147411" class="c"><input type="checkbox" id="c-41147411" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41146722">parent</a><span>|</span><a href="#41146844">prev</a><span>|</span><a href="#41147227">next</a><span>|</span><label class="collapse" for="c-41147411">[-]</label><label class="expand" for="c-41147411">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t got to the end of it but I assume this was motivated by some configuration languages using &quot;not Turing complete&quot; as a feature, when the feature they <i>really</i> want to advertise is &quot;reasonably bounded execution time&quot;.<p>It came up recently in this discussion about CEL:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40954652">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40954652</a></div><br/></div></div></div></div><div id="41146673" class="c"><input type="checkbox" id="c-41146673" checked=""/><div class="controls bullet"><span class="by">Exuma</span><span>|</span><a href="#41146722">prev</a><span>|</span><label class="collapse" for="c-41146673">[-]</label><label class="expand" for="c-41146673">[18 more]</label></div><br/><div class="children"><div class="content">[flagged]</div><br/><div id="41150741" class="c"><input type="checkbox" id="c-41150741" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41146773">next</a><span>|</span><label class="collapse" for="c-41150741">[-]</label><label class="expand" for="c-41150741">[1 more]</label></div><br/><div class="children"><div class="content">&quot;<i>Please don&#x27;t complain about tangential annoyances [...] They&#x27;re too common to be interesting.</i>&quot;<p>&quot;<i>Please don&#x27;t pick the most provocative thing in an article or post to complain about in the thread. Find something interesting to respond to instead.</i>&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div><div id="41146773" class="c"><input type="checkbox" id="c-41146773" checked=""/><div class="controls bullet"><span class="by">lgas</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41150741">prev</a><span>|</span><a href="#41146997">next</a><span>|</span><label class="collapse" for="c-41146773">[-]</label><label class="expand" for="c-41146773">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;lose&quot; and &quot;loose&quot;<p>&gt; They dont even sound or look anything alike...<p>You really don&#x27;t think those two words look anything alike?</div><br/></div></div><div id="41146997" class="c"><input type="checkbox" id="c-41146997" checked=""/><div class="controls bullet"><span class="by">soup_bud</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41146773">prev</a><span>|</span><a href="#41147557">next</a><span>|</span><label class="collapse" for="c-41146997">[-]</label><label class="expand" for="c-41146997">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure that the author&#x27;s first language is not English :) doesn&#x27;t seem like an unreasonable mistake to make to me</div><br/><div id="41147540" class="c"><input type="checkbox" id="c-41147540" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41146997">parent</a><span>|</span><a href="#41147250">next</a><span>|</span><label class="collapse" for="c-41147540">[-]</label><label class="expand" for="c-41147540">[1 more]</label></div><br/><div class="children"><div class="content">You may be right, but I think this is a mistake that native speakers are more likely to make. This is just anecdotal, so don&#x27;t take me too seriously...<p>Mistakes like &quot;your&quot; instead of &quot;you&#x27;re&quot; and &quot;should of&quot; instead of &quot;should have&quot; seem to be very common for people who learned english by listening instead of reding (native speakers). The words sound the same, so they get switched.<p>On the other hand, as a non-native, I struggle with phrasal verbs, such as &quot;get in&quot; vs &quot;get on&quot;, &quot;get out&quot; vs &quot;get off&quot;, and so on. These may be very different concepts in English, but not for my native language, so I don&#x27;t always choose the correct one.</div><br/></div></div><div id="41147250" class="c"><input type="checkbox" id="c-41147250" checked=""/><div class="controls bullet"><span class="by">ffhhj</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41146997">parent</a><span>|</span><a href="#41147540">prev</a><span>|</span><a href="#41147557">next</a><span>|</span><label class="collapse" for="c-41147250">[-]</label><label class="expand" for="c-41147250">[1 more]</label></div><br/><div class="children"><div class="content">And haven&#x27;t discovered that LLMs can proofread text.</div><br/></div></div></div></div><div id="41147557" class="c"><input type="checkbox" id="c-41147557" checked=""/><div class="controls bullet"><span class="by">dabacaba</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41146997">prev</a><span>|</span><a href="#41147543">next</a><span>|</span><label class="collapse" for="c-41147557">[-]</label><label class="expand" for="c-41147557">[1 more]</label></div><br/><div class="children"><div class="content">Says someone who can&#x27;t even spell &quot;don&#x27;t&quot; correctly. Though this doesn&#x27;t really bother me at all.</div><br/></div></div><div id="41147543" class="c"><input type="checkbox" id="c-41147543" checked=""/><div class="controls bullet"><span class="by">globalnode</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41147557">prev</a><span>|</span><a href="#41148264">next</a><span>|</span><label class="collapse" for="c-41147543">[-]</label><label class="expand" for="c-41147543">[2 more]</label></div><br/><div class="children"><div class="content">Getting &quot;then&quot;&#x2F;&quot;than&quot; mixed up is a HUGE red flag.</div><br/><div id="41149040" class="c"><input type="checkbox" id="c-41149040" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41147543">parent</a><span>|</span><a href="#41148264">next</a><span>|</span><label class="collapse" for="c-41149040">[-]</label><label class="expand" for="c-41149040">[1 more]</label></div><br/><div class="children"><div class="content">Why? Its never a problem in spoken language, so their is no reason its a real problem in written language either.(misspellings intended)</div><br/></div></div></div></div><div id="41148264" class="c"><input type="checkbox" id="c-41148264" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41147543">prev</a><span>|</span><a href="#41146799">next</a><span>|</span><label class="collapse" for="c-41148264">[-]</label><label class="expand" for="c-41148264">[3 more]</label></div><br/><div class="children"><div class="content">Article LGTM.  Maybe it was fixed in the last 4 hours.</div><br/><div id="41151156" class="c"><input type="checkbox" id="c-41151156" checked=""/><div class="controls bullet"><span class="by">slater</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41148264">parent</a><span>|</span><a href="#41146799">next</a><span>|</span><label class="collapse" for="c-41151156">[-]</label><label class="expand" for="c-41151156">[2 more]</label></div><br/><div class="children"><div class="content">&quot;loosing&quot; -&gt; &quot;losing&quot;, second paragraph.</div><br/><div id="41151948" class="c"><input type="checkbox" id="c-41151948" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41151156">parent</a><span>|</span><a href="#41146799">next</a><span>|</span><label class="collapse" for="c-41151948">[-]</label><label class="expand" for="c-41151948">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div></div></div><div id="41146799" class="c"><input type="checkbox" id="c-41146799" checked=""/><div class="controls bullet"><span class="by">ffhhj</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41148264">prev</a><span>|</span><a href="#41146750">next</a><span>|</span><label class="collapse" for="c-41146799">[-]</label><label class="expand" for="c-41146799">[4 more]</label></div><br/><div class="children"><div class="content">Its. It&#x27;s.</div><br/><div id="41146830" class="c"><input type="checkbox" id="c-41146830" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41146799">parent</a><span>|</span><a href="#41146750">next</a><span>|</span><label class="collapse" for="c-41146830">[-]</label><label class="expand" for="c-41146830">[3 more]</label></div><br/><div class="children"><div class="content">They&#x27;re &#x2F; their.</div><br/><div id="41147468" class="c"><input type="checkbox" id="c-41147468" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41146830">parent</a><span>|</span><a href="#41146750">next</a><span>|</span><label class="collapse" for="c-41147468">[-]</label><label class="expand" for="c-41147468">[2 more]</label></div><br/><div class="children"><div class="content">Less &#x2F; fewer.</div><br/><div id="41148245" class="c"><input type="checkbox" id="c-41148245" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#41146673">root</a><span>|</span><a href="#41147468">parent</a><span>|</span><a href="#41146750">next</a><span>|</span><label class="collapse" for="c-41148245">[-]</label><label class="expand" for="c-41148245">[1 more]</label></div><br/><div class="children"><div class="content">Further&#x2F;farther</div><br/></div></div></div></div></div></div></div></div><div id="41146750" class="c"><input type="checkbox" id="c-41146750" checked=""/><div class="controls bullet"><span class="by">ramses0</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41146799">prev</a><span>|</span><a href="#41147915">next</a><span>|</span><label class="collapse" for="c-41146750">[-]</label><label class="expand" for="c-41146750">[1 more]</label></div><br/><div class="children"><div class="content">Good. Food. Flood.<p>Lews. Lows. Luse. Loose. Lose.</div><br/></div></div><div id="41147915" class="c"><input type="checkbox" id="c-41147915" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#41146673">parent</a><span>|</span><a href="#41146750">prev</a><span>|</span><label class="collapse" for="c-41147915">[-]</label><label class="expand" for="c-41147915">[1 more]</label></div><br/><div class="children"><div class="content">This specific error is common amongst non-native English speakers.</div><br/></div></div></div></div></div></div></div></div></div></body></html>