<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="apple-mobile-web-app-capable" content="yes"/><link rel="preload" href="styles.css?v=1682488128755" as="style"/><link rel="stylesheet" href="styles.css?v=1682488128755"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tavianator.com/2023/futex.html">You could have invented futexes</a>Â <span class="domain">(<a href="https://tavianator.com">tavianator.com</a>)</span></div><div class="subtext"><span>dmarto</span> | <span>26 comments</span></div><br/><div><div id="35709314" class="c"><input type="checkbox" id="c-35709314" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#35709430">next</a><span>|</span><label class="collapse" for="c-35709314">[-]</label><label class="expand" for="c-35709314">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more like UNIX and Linux being way behind on threading technology. User space mutexes were in QNX over two decades ago. And on the UNIVAC 1108 half a century ago.[1] Here&#x27;s a implementation from 1972, by John Walker.<p><pre><code>    .         DIJKSTRA P FUNCTION
    .
    .
    .         LA,U      A0,&lt;QUEUE&gt;
    .         LMJ       X11,P
    .         &lt;RETURN&gt;                      X5 DESTROYED
    .
    P*        TS        QHEAD,A0            LOCK THE QUEUE
              LX        X5,QN,A0            LOAD QUEUE COUNT
              ANX,U     X5,1                BACK UP THE COUNT
              SX        X5,QN,A0            REPLACE THE COUNT IN THE QUEUE
              TN        X5                  DO WE NEED TO DEACTIVATE HIM ?
              J         PDONE               NO.  SKIP DEACTIVATION
              ON        TSQ=0
              LX        X5,QHL,A0           LOAD BACK LINK OF QUEUE
              SX        X5,QHL,X4           PUT INTO BACK LINK OF ACTIVITY
              SX        X4,QFL,X5           CHAIN ACTIVITY TO LAST ACTIVITY
              SA        A0,QFL,X4           CHAIN HEAD TO NEW ACTIVITY
              SX        X4,QHL,A0           MAKE THE NEW ACTIVITY LAST ON QUEUE
              CTS       QHEAD,A0            RELEASE PROTECTION ON QUEUE HEAD
    SCHDACT*  DACT$     .                   DEACTIVATE PROCESS
              OFF
              ON        TSQ
              C$TSQ     QHEAD,A0            WAIT FOR C$TSA
              OFF
              J         0,X11               RETURN AFTER ACTIVATION
    .
    PDONE     CTS       QHEAD,A0            UNLOCK THE QUEUE
              J         0,X11               RETURN
</code></pre>
And that followed Djykstra&#x27;s paper, published in Dutch in the late 1960s.<p>[1] <a href="https:&#x2F;&#x2F;www.fourmilab.ch&#x2F;documents&#x2F;univac&#x2F;fang&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.fourmilab.ch&#x2F;documents&#x2F;univac&#x2F;fang&#x2F;</a></div><br/></div></div><div id="35709430" class="c"><input type="checkbox" id="c-35709430" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#35709314">prev</a><span>|</span><a href="#35709066">next</a><span>|</span><label class="collapse" for="c-35709430">[-]</label><label class="expand" for="c-35709430">[1 more]</label></div><br/><div class="children"><div class="content">Hashing an address to map to a wait queue was done by early Unix kernels.<p>The address was called a &quot;wait channel&quot; (wchan for short).<p>There was no object declared at the address; any object or function could be waited on.<p>The <i>ps</i> utility still has a field called &quot;wchan&quot; you can select, which tells you where the process is waiting.<p>Hashing is basically way to add properties to an object (identified by an address) without physically extending the structure located at that address.<p>We can give any address a wait queue, for instance.<p>E.g. Javascript object properties are like this. If we have some <i>futex</i> object in Javascript, and give it a futex.waitQueue property, it&#x27;s basically the same: the futex thing is hashed somehow to access that property.<p>The main point of futexes is efficiency in the face of user&#x2F;kernel separation. Futexes are intended to be used in a  double-checked pattern, avoiding a call into the kernel. User space can check the state of the futex memory location and avoid calling wait. The wait operation in the kernel will do the same check again (this time atomically) possibly avoiding the wait.. If that weren&#x27;t done, there would be a lost-wakeup problem in the use of mutexes.<p>Futexes are fast in the uncontended case; hence the F. Fast means in the context of the expensive user&#x2F;kernel boundary. You would never need futexes without such a boundary; they are not used in the kernel. Futexes inside a single protection space are indeed a non-invention; the invention is the idea that something outside of the protected space can inspect the value and act on it.</div><br/></div></div><div id="35709066" class="c"><input type="checkbox" id="c-35709066" checked=""/><div class="controls bullet"><span class="by">RustyRussell</span><span>|</span><a href="#35709430">prev</a><span>|</span><a href="#35709076">next</a><span>|</span><label class="collapse" for="c-35709066">[-]</label><label class="expand" for="c-35709066">[7 more]</label></div><br/><div class="children"><div class="content">Oh, blast from the past!<p>The original futex code used physical addresses, and pinned the page, which is simple: if you can share memory somehow, you can use a futex.<p>Of course, most people use pthreads and increasingly the idea of a Linux userspace locking primitive gave way to a glibc-pthread accelerator...</div><br/><div id="35709141" class="c"><input type="checkbox" id="c-35709141" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#35709066">parent</a><span>|</span><a href="#35709076">next</a><span>|</span><label class="collapse" for="c-35709141">[-]</label><label class="expand" for="c-35709141">[6 more]</label></div><br/><div class="children"><div class="content"><i>if you can share memory somehow, you can use a futex.</i><p>If you can share memory <i>and you have coherent caches</i> you can use a futex.  (In particular, many embedded systems have weaker cache coherency than x86, so &quot;it works on my laptop&quot; is not enough!)<p>In the worst case, without coherent caches you may need to do a cache shootdown IPI, which means entering the kernel anyway.</div><br/><div id="35709277" class="c"><input type="checkbox" id="c-35709277" checked=""/><div class="controls bullet"><span class="by">RustyRussell</span><span>|</span><a href="#35709066">root</a><span>|</span><a href="#35709141">parent</a><span>|</span><a href="#35709076">next</a><span>|</span><label class="collapse" for="c-35709277">[-]</label><label class="expand" for="c-35709277">[5 more]</label></div><br/><div class="children"><div class="content">Um, does Linux run on such systems? There&#x27;s a broad assumption that atomic ops work efficiently (or at least, that was true when I dropped out 7 years ago...)</div><br/><div id="35709535" class="c"><input type="checkbox" id="c-35709535" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#35709066">root</a><span>|</span><a href="#35709277">parent</a><span>|</span><a href="#35709076">next</a><span>|</span><label class="collapse" for="c-35709535">[-]</label><label class="expand" for="c-35709535">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not the right person to ask about this, but some ARM systems definitely have weaker coherence than x86 -- in FreeBSD we have a whole bunch of memory barrier primitives which compile away to nothing on x86 because they exist only for weaker platforms.<p>I have a vague recollection that it&#x27;s something to do with whether caches snoop the memory bus for reads of lines they &quot;own&quot; but I could be mistaken.  Whatever it was, there were cases where buggy code meant that a core could read a stale value from memory for <i>multiple seconds</i> after another core wrote to the same address.</div><br/><div id="35709680" class="c"><input type="checkbox" id="c-35709680" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#35709066">root</a><span>|</span><a href="#35709535">parent</a><span>|</span><a href="#35709704">next</a><span>|</span><label class="collapse" for="c-35709680">[-]</label><label class="expand" for="c-35709680">[1 more]</label></div><br/><div class="children"><div class="content">The terminology is that x86 has a Total Store Order memory model, while ARM doesn&#x27;t; acquire operations on x86 imply that all relaxed store operations on the core that released are also visible to the reader, which is not true on ARM unless the released value has a data dependency, or until you execute a memory barrier.<p>ARM still has a <i>coherent</i> cache, however. Basically every modern OS and program depends on having a coherent data cache (though ARM doesn&#x27;t keep i-cache and d-cache coherent with each other, which basically only comes in play with self-modifying code)</div><br/></div></div><div id="35709704" class="c"><input type="checkbox" id="c-35709704" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#35709066">root</a><span>|</span><a href="#35709535">parent</a><span>|</span><a href="#35709680">prev</a><span>|</span><a href="#35709760">next</a><span>|</span><label class="collapse" for="c-35709704">[-]</label><label class="expand" for="c-35709704">[1 more]</label></div><br/><div class="children"><div class="content">The details are hazy for me but all relevant CPUs have coherent caches, but not all make the same ordering guarantees.<p>x86 has &quot;total store ordering&quot;, meaning stores made by core 1 will always be observed in-order by core 2. ARM doesn&#x27;t make that guarantee.<p>In practice it doesn&#x27;t matter for writing correct programs unless you write assembly: even if the CPU has total store ordering, the compiler is allowed to reorder stores unless you put an appropriate barrier in the high-level language source.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35709076" class="c"><input type="checkbox" id="c-35709076" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#35709066">prev</a><span>|</span><a href="#35708808">next</a><span>|</span><label class="collapse" for="c-35709076">[-]</label><label class="expand" for="c-35709076">[9 more]</label></div><br/><div class="children"><div class="content">Thanks for writing this up -- I&#x27;ll be coming back to it when I need to implement  mutexes.<p>As an aside -- it would be interesting to see what the analog on Windows is.  I know from experience the platform-provided mutex implementation on win32 is horrendously slow, and it would be nice to know if it&#x27;s even possible on that platform to implement a &#x27;real&#x27; mutex that doesn&#x27;t suck.  Anyone know of a reference implementation of mutexes on Windows?</div><br/><div id="35709577" class="c"><input type="checkbox" id="c-35709577" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#35709076">parent</a><span>|</span><a href="#35709153">next</a><span>|</span><label class="collapse" for="c-35709577">[-]</label><label class="expand" for="c-35709577">[1 more]</label></div><br/><div class="children"><div class="content">The Win32 mutex is slow because it&#x27;s also usable across processes.<p>If you don&#x27;t need cross-process sync, you should really be using a Critical Section instead. The kernel-level interface, which is largely undocumented, is I believe either an Event object or a Keyed Event on later versions.<p>There&#x27;s some interesting related discussion on that here: <a href="https:&#x2F;&#x2F;microsoft.public.win32.programmer.kernel.narkive.com&#x2F;2F2a5Nin&#x2F;question-about-win32-critical-section-implementation" rel="nofollow">https:&#x2F;&#x2F;microsoft.public.win32.programmer.kernel.narkive.com...</a><p><i>Anyone know of a reference implementation of mutexes on Windows?</i><p>Look in the WINE source.</div><br/></div></div><div id="35709153" class="c"><input type="checkbox" id="c-35709153" checked=""/><div class="controls bullet"><span class="by">overthrow</span><span>|</span><a href="#35709076">parent</a><span>|</span><a href="#35709577">prev</a><span>|</span><a href="#35709281">next</a><span>|</span><label class="collapse" for="c-35709153">[-]</label><label class="expand" for="c-35709153">[1 more]</label></div><br/><div class="children"><div class="content">Windows has an analogue to futexes called WaitOnAddress.[1] Zig&#x27;s stdlib claims SRW locks are faster than a futex-based implementation.[2] But the futex-based implementation a few lines down that should run fine on Windows since it uses the cross-platform futex abstraction, so it wouldn&#x27;t be hard to benchmark.<p>[1]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;synchapi&#x2F;nf-synchapi-waitonaddress" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;api&#x2F;synchapi...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;295b8ca467da36cd1066395e7f50b6245f456573&#x2F;lib&#x2F;std&#x2F;Thread&#x2F;Mutex.zig#L118">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;295b8ca467da36cd1066395e...</a></div><br/></div></div><div id="35709281" class="c"><input type="checkbox" id="c-35709281" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#35709076">parent</a><span>|</span><a href="#35709153">prev</a><span>|</span><a href="#35709129">next</a><span>|</span><label class="collapse" for="c-35709281">[-]</label><label class="expand" for="c-35709281">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that EnterCriticalSection on Windows already doesn&#x27;t enter the kernel on the non-contended case. So very often these are used instead of the mutex kernel object.</div><br/></div></div><div id="35709129" class="c"><input type="checkbox" id="c-35709129" checked=""/><div class="controls bullet"><span class="by">johncolanduoni</span><span>|</span><a href="#35709076">parent</a><span>|</span><a href="#35709281">prev</a><span>|</span><a href="#35709136">next</a><span>|</span><label class="collapse" for="c-35709129">[-]</label><label class="expand" for="c-35709129">[2 more]</label></div><br/><div class="children"><div class="content">itâs called WaitOnAddress: <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20170601-00&#x2F;?p=96265" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20170601-00&#x2F;?p=96...</a></div><br/><div id="35709733" class="c"><input type="checkbox" id="c-35709733" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#35709076">root</a><span>|</span><a href="#35709129">parent</a><span>|</span><a href="#35709136">next</a><span>|</span><label class="collapse" for="c-35709733">[-]</label><label class="expand" for="c-35709733">[1 more]</label></div><br/><div class="children"><div class="content">That blog slightly misrepresents futex. Or perhaps it&#x27;s outdated. It&#x27;s written as if futexes can only be used with a 1&#x2F;0&#x2F;negative protocol, but that&#x27;s not true. The values used are up to user space.</div><br/></div></div></div></div><div id="35709136" class="c"><input type="checkbox" id="c-35709136" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#35709076">parent</a><span>|</span><a href="#35709129">prev</a><span>|</span><a href="#35709126">next</a><span>|</span><label class="collapse" for="c-35709136">[-]</label><label class="expand" for="c-35709136">[1 more]</label></div><br/><div class="children"><div class="content">Refer to &#x27;futexes are tricky&#x27;, which shows how to build a mutex with a futexâ&lt;<a href="https:&#x2F;&#x2F;www.akkadia.org&#x2F;drepper&#x2F;futex.pdf" rel="nofollow">https:&#x2F;&#x2F;www.akkadia.org&#x2F;drepper&#x2F;futex.pdf</a>&gt;âwindows futexes are named WaitOnAddress, WakeByAddressSingle, and WakeByAddressAll.<p>(That said, I think I heard somewhere that windows mutexes are decent now?)</div><br/></div></div><div id="35709126" class="c"><input type="checkbox" id="c-35709126" checked=""/><div class="controls bullet"><span class="by">mastax</span><span>|</span><a href="#35709076">parent</a><span>|</span><a href="#35709136">prev</a><span>|</span><a href="#35708808">next</a><span>|</span><label class="collapse" for="c-35709126">[-]</label><label class="expand" for="c-35709126">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if this is the &quot;best&quot; recommendation, but it&#x27;s the one I know.<p><a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;parking_lot" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;parking_lot</a><p>IIRC the only platform specific part is the thread parking logic, so I&#x27;d assume it&#x27;s pretty fast on Windows in the common case.</div><br/><div id="35709776" class="c"><input type="checkbox" id="c-35709776" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#35709076">root</a><span>|</span><a href="#35709126">parent</a><span>|</span><a href="#35708808">next</a><span>|</span><label class="collapse" for="c-35709776">[-]</label><label class="expand" for="c-35709776">[1 more]</label></div><br/><div class="children"><div class="content">The rust standard library has incorporated a lot of parking_lot.  On platforms that have futex-like primatives (like linux and windows) it uses those. But I think it uses a parking lot implementation if the OS doesn&#x27;t support such an operation.</div><br/></div></div></div></div></div></div><div id="35708808" class="c"><input type="checkbox" id="c-35708808" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#35709076">prev</a><span>|</span><a href="#35709693">next</a><span>|</span><label class="collapse" for="c-35708808">[-]</label><label class="expand" for="c-35708808">[6 more]</label></div><br/><div class="children"><div class="content">Omg the multi-threaded code examples are amazing. The active line is highlighted. Amazingly illuminating, so so good.</div><br/><div id="35708887" class="c"><input type="checkbox" id="c-35708887" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#35708808">parent</a><span>|</span><a href="#35709693">next</a><span>|</span><label class="collapse" for="c-35708887">[-]</label><label class="expand" for="c-35708887">[5 more]</label></div><br/><div class="children"><div class="content">Question: do people find that sort of animation easier to grok than showing the interleaving visually, as I do at <a href="https:&#x2F;&#x2F;outerproduct.net&#x2F;boring&#x2F;2023-01-27_trans-locks.html#table" rel="nofollow">https:&#x2F;&#x2F;outerproduct.net&#x2F;boring&#x2F;2023-01-27_trans-locks.html#...</a>?  I prefer the latter, because it lets me see everything at once, but may switch to the former presentation style if other people prefer it.</div><br/><div id="35709047" class="c"><input type="checkbox" id="c-35709047" checked=""/><div class="controls bullet"><span class="by">TechBro8615</span><span>|</span><a href="#35708808">root</a><span>|</span><a href="#35708887">parent</a><span>|</span><a href="#35709037">next</a><span>|</span><label class="collapse" for="c-35709047">[-]</label><label class="expand" for="c-35709047">[2 more]</label></div><br/><div class="children"><div class="content">Not that it would apply in this particular case, but my all-time favorite visualization of concurrency is this 2016 blog post called &quot;Visualizing Concurrency in Go&quot; [0]. So good.<p>[0] <a href="https:&#x2F;&#x2F;divan.dev&#x2F;posts&#x2F;go_concurrency_visualize&#x2F;" rel="nofollow">https:&#x2F;&#x2F;divan.dev&#x2F;posts&#x2F;go_concurrency_visualize&#x2F;</a></div><br/><div id="35709108" class="c"><input type="checkbox" id="c-35709108" checked=""/><div class="controls bullet"><span class="by">rektide</span><span>|</span><a href="#35708808">root</a><span>|</span><a href="#35709047">parent</a><span>|</span><a href="#35709037">next</a><span>|</span><label class="collapse" for="c-35709108">[-]</label><label class="expand" for="c-35709108">[1 more]</label></div><br/><div class="children"><div class="content">Using time to represent time is a pretty helpful &amp; intuitive strategy, very nicely on display in this example &amp; the submission.<p>It does require some waiting around to see how things develop (versus the at-a-glance approach) but it really feels so very graspable &amp; clear to me.</div><br/></div></div></div></div><div id="35709037" class="c"><input type="checkbox" id="c-35709037" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#35708808">root</a><span>|</span><a href="#35708887">parent</a><span>|</span><a href="#35709047">prev</a><span>|</span><a href="#35709040">next</a><span>|</span><label class="collapse" for="c-35709037">[-]</label><label class="expand" for="c-35709037">[1 more]</label></div><br/><div class="children"><div class="content">FWIW coming from some random stranger on the internet, I like the animations.  They&#x27;re short enough that even though all the information isn&#x27;t on the screen at once, I can remember&#x2F;interpret the whole thing after it&#x27;s run once.  I could also imagine for demonstrating longer-running bugs (of more than just a few instructions) a user-controlled slider might be nice.</div><br/></div></div><div id="35709040" class="c"><input type="checkbox" id="c-35709040" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#35708808">root</a><span>|</span><a href="#35708887">parent</a><span>|</span><a href="#35709037">prev</a><span>|</span><a href="#35709693">next</a><span>|</span><label class="collapse" for="c-35709040">[-]</label><label class="expand" for="c-35709040">[1 more]</label></div><br/><div class="children"><div class="content">The answer is almost certainly yes. For both directions of the question. Few things have a single visualization that is the best.</div><br/></div></div></div></div></div></div><div id="35709693" class="c"><input type="checkbox" id="c-35709693" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35708808">prev</a><span>|</span><label class="collapse" for="c-35709693">[-]</label><label class="expand" for="c-35709693">[1 more]</label></div><br/><div class="children"><div class="content">Why write workarounds instead of simply using arrays of 64 byte atomic structures for your data?<p>That way you avoid cache misses and cache invalidation at the same time. And your software can run at full speed across multiple threads&#x2F;cores.</div><br/></div></div></div></div></div></div></div></body></html>