<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707123658250" as="style"/><link rel="stylesheet" href="styles.css?v=1707123658250"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.ethanheilman.com/x/21/index.html">How many IP addresses can a DNS query return? (2015)</a> <span class="domain">(<a href="https://www.ethanheilman.com">www.ethanheilman.com</a>)</span></div><div class="subtext"><span>EthanHeilman</span> | <span>22 comments</span></div><br/><div><div id="39258463" class="c"><input type="checkbox" id="c-39258463" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#39258533">next</a><span>|</span><label class="collapse" for="c-39258463">[-]</label><label class="expand" for="c-39258463">[1 more]</label></div><br/><div class="children"><div class="content">Rather than reinvent the wheel, one place I worked used SRV records for service discovery. Unlike A recrods, SRV records can have host names, so the limit is a lot lower, and they hit it. They might have even hit it twice when a client is UDP-only.</div><br/></div></div><div id="39258533" class="c"><input type="checkbox" id="c-39258533" checked=""/><div class="controls bullet"><span class="by">afraca</span><span>|</span><a href="#39258463">prev</a><span>|</span><a href="#39255375">next</a><span>|</span><label class="collapse" for="c-39258533">[-]</label><label class="expand" for="c-39258533">[2 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s the monday morning blues (can&#x27;t seem to think), but how does this work for DOH&#x2F;DOT?</div><br/><div id="39258701" class="c"><input type="checkbox" id="c-39258701" checked=""/><div class="controls bullet"><span class="by">simoncion</span><span>|</span><a href="#39258533">parent</a><span>|</span><a href="#39255375">next</a><span>|</span><label class="collapse" for="c-39258701">[-]</label><label class="expand" for="c-39258701">[1 more]</label></div><br/><div class="children"><div class="content">The RFC for DNS-over-TLS [0] seems to indicate that tunneling DNS requests through a TLS channel has no effect on the potential size of the payload returned.<p>Who the hell knows what DNS-over-HTTP does?<p>[0] &lt;<a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7858" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc7858</a>&gt;</div><br/></div></div></div></div><div id="39255375" class="c"><input type="checkbox" id="c-39255375" checked=""/><div class="controls bullet"><span class="by">SushiHippie</span><span>|</span><a href="#39258533">prev</a><span>|</span><a href="#39254622">next</a><span>|</span><label class="collapse" for="c-39255375">[-]</label><label class="expand" for="c-39255375">[3 more]</label></div><br/><div class="children"><div class="content">Another similar article with a bit more details:<p><a href="https:&#x2F;&#x2F;www.netmeister.org&#x2F;blog&#x2F;dns-size.html" rel="nofollow">https:&#x2F;&#x2F;www.netmeister.org&#x2F;blog&#x2F;dns-size.html</a></div><br/><div id="39257332" class="c"><input type="checkbox" id="c-39257332" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39255375">parent</a><span>|</span><a href="#39256250">next</a><span>|</span><label class="collapse" for="c-39257332">[-]</label><label class="expand" for="c-39257332">[1 more]</label></div><br/><div class="children"><div class="content">&quot;And the maximum size of an IP packet is 16 bit (via the IPv4 total length &#x2F; IPv6 payload length). And that is now our limiting factor: 65536 bytes for DNS overhead + payload.&quot;<p>While they conclude the right size, this is incorrect. They seem to overlook that TCP DNS header has its own 2 byte length field (it&#x27;s a 14 byte header). That is the limiting factor, nothing to do with the lower layers. If the DNS message itself is over 65514 it will <i>require</i> multiple IP packets due to TCP overhead and in practice MTU sizes are almost never over 9000 and usually &lt;1500, so it&#x27;s going to be split up at much lower sizes.<p>&quot;&#x27;What about jumbo frames?&#x27; That doesn&#x27;t really buy us anything, either, because TCP itself is also limited to 16 bits, albeit semi-indirectly via the 16-bit urgent pointer&quot;<p>This isn&#x27;t correct either. The urgent pointer (it&#x27;s own can of worms) is completely ignored in non URG packets.</div><br/></div></div><div id="39256250" class="c"><input type="checkbox" id="c-39256250" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39255375">parent</a><span>|</span><a href="#39257332">prev</a><span>|</span><a href="#39254622">next</a><span>|</span><label class="collapse" for="c-39256250">[-]</label><label class="expand" for="c-39256250">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Discussed at the time:<p><i>What’s the maximum size of a DNS response?</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32254434">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32254434</a> - July 2022 (31 comments)</div><br/></div></div></div></div><div id="39254622" class="c"><input type="checkbox" id="c-39254622" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#39255375">prev</a><span>|</span><a href="#39255469">next</a><span>|</span><label class="collapse" for="c-39254622">[-]</label><label class="expand" for="c-39254622">[13 more]</label></div><br/><div class="children"><div class="content">The article asserts &quot;A large DNS response must fit into a single TCP packet.&quot; but skips the source on that one. I know that&#x27;s true of UDP but is it really in the standard for TCP?</div><br/><div id="39255423" class="c"><input type="checkbox" id="c-39255423" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#39254622">parent</a><span>|</span><a href="#39256424">next</a><span>|</span><label class="collapse" for="c-39255423">[-]</label><label class="expand" for="c-39255423">[8 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an excellent question! When I was writing that I was pretty deep in DNS code and standards I think I just understood that as a rule of DNS. Or at the least, I believed I understood.  Looking back a decade later I can&#x27;t find any standard which supports my statement. However lots of other secondary sources seem to agree with me.<p>&quot;In these situations, the client needs to re-transmit over TCP for which the size limit is 64000 bytes&quot; [0]<p>&quot;The first response via UDP is, no surprise, truncated, so we retry via TCP. But now the DNS result delivered via TCP is also truncated! That is, the DNS server has determined that the result will not fit into the maximum response size. Why is that?<p>&quot;Our payload is 4096 * 16 = 65536 bytes RDATA, which should fit into the DNS packet, which uses a two byte RDLENGTH field. But we also need to again account for the overhead noted above: 12 bytes DNS header, 36 bytes for the query, 11 bytes additional records, and 16 bytes for each A record, yielding (4096 * 16) + 12 + 36 + 11 = 65595 bytes in total. And the maximum size of an IP packet is 16 bit (via the IPv4 total length &#x2F; IPv6 payload length). And that is now our limiting factor: 65536 bytes for DNS overhead + payload.&quot;<p>My best guess is that DNS just makes the assumption that everything needs to fit in a single IP packet and it doesn&#x27;t care if it is UDP or TCP.<p>It is worth investigating if you have spare time.<p>[0]: <a href="https:&#x2F;&#x2F;www.infoblox.com&#x2F;dns-security-resource-center&#x2F;dns-security-faq&#x2F;is-dns-tcp-or-udp-port-53&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.infoblox.com&#x2F;dns-security-resource-center&#x2F;dns-se...</a><p>[1]: <a href="https:&#x2F;&#x2F;www.netmeister.org&#x2F;blog&#x2F;dns-size.html" rel="nofollow">https:&#x2F;&#x2F;www.netmeister.org&#x2F;blog&#x2F;dns-size.html</a></div><br/><div id="39257147" class="c"><input type="checkbox" id="c-39257147" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39255423">parent</a><span>|</span><a href="#39256679">next</a><span>|</span><label class="collapse" for="c-39257147">[-]</label><label class="expand" for="c-39257147">[1 more]</label></div><br/><div class="children"><div class="content">I think that second reference has a couple errors, and this has nothing to do with IP packets (datagrams).<p>As js2 notes, the entire DNS message has to be prefixed with a 2 byte field (and they seem to have omitted that in their diagram at the top of the page, the DNS header is 14 bytes, not 12 for TCP). <i>That</i> is the limiting factor. The DNS server doesn&#x27;t really care what the underlying limits of the TCP stack are or whether the response fits in a single IP datagram (that likely needs to be split up).<p>As they seem to figure out the actual limit is RD payload + <i>DNS</i> overhead &lt;= 64k bytes. What they are forgetting is that the TCP segment overhead means that this maximum wouldn&#x27;t fit in a single IP datagram anyhow. Since the minimum TCP header size is 20 bytes any DNS message &gt;65514 bytes will have to be split.<p>In practice none of this matters though as the OS had better make the TCP maximum segment size less than the MTU to avoid fragmentation, often something 1460 or less.
Any DNS query substantially over that is going to be going in multiple IP datagrams.</div><br/></div></div><div id="39256679" class="c"><input type="checkbox" id="c-39256679" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39255423">parent</a><span>|</span><a href="#39257147">prev</a><span>|</span><a href="#39257296">next</a><span>|</span><label class="collapse" for="c-39256679">[-]</label><label class="expand" for="c-39256679">[2 more]</label></div><br/><div class="children"><div class="content">RFC 1035:<p>&gt; Messages sent over TCP connections use server port 53 (decimal). The message is prefixed with a two byte length field which gives the message length, excluding the two byte length field. This length field allows the low-level processing to assemble a complete message before beginning to parse it.<p><a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc1035#section-4.2.2" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc1035#section-4.2.2</a></div><br/><div id="39257254" class="c"><input type="checkbox" id="c-39257254" checked=""/><div class="controls bullet"><span class="by">EthanHeilman</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39256679">parent</a><span>|</span><a href="#39257296">next</a><span>|</span><label class="collapse" for="c-39257254">[-]</label><label class="expand" for="c-39257254">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div><div id="39257296" class="c"><input type="checkbox" id="c-39257296" checked=""/><div class="controls bullet"><span class="by">jiveturkey</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39255423">parent</a><span>|</span><a href="#39256679">prev</a><span>|</span><a href="#39256424">next</a><span>|</span><label class="collapse" for="c-39257296">[-]</label><label class="expand" for="c-39257296">[4 more]</label></div><br/><div class="children"><div class="content">&gt; My best guess is that DNS just makes the assumption that everything needs to fit in a single IP packet and it doesn&#x27;t care if it is UDP or TCP.<p>It&#x27;s not an assumption, it&#x27;s a requirement. &quot;Legacy&quot; DNS has no provision for a response to exceed a single IP packet size. The assumption part is that this is adequate for a DNS response. Before DNSSEC, it was.<p>I believe DoH and friends don&#x27;t have this restriction.<p>EDIT: too late to delete but this is wrong. see child comments.</div><br/><div id="39257377" class="c"><input type="checkbox" id="c-39257377" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39257296">parent</a><span>|</span><a href="#39256424">next</a><span>|</span><label class="collapse" for="c-39257377">[-]</label><label class="expand" for="c-39257377">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not an assumption, it&#x27;s a requirement.<p>Where is this requirement? A DNS server responding over a TCP socket has no idea of the underlying IP datagram size. In a typical Ethernet, the TCP MSS will be 1460 bytes so the IP packets will all be under 1500 bytes. You certainly can get regular TCP DNS responses bigger than 1460 bytes.
See elsewhere in this thread, &quot;legacy&quot; RFC1035 DNS over TCP has a 16-bit message prefix which limits the total <i>DNS</i> message to 64kiB.
A valid maximum DNS TCP response can exceed (the almost entirely theoretical) max IP packet size by 22 bytes, FWIW.</div><br/><div id="39257442" class="c"><input type="checkbox" id="c-39257442" checked=""/><div class="controls bullet"><span class="by">jiveturkey</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39257377">parent</a><span>|</span><a href="#39256424">next</a><span>|</span><label class="collapse" for="c-39257442">[-]</label><label class="expand" for="c-39257442">[2 more]</label></div><br/><div class="children"><div class="content">An IP packet can be much larger than a single TCP segment. It can be up to 65536 bytes. IP doesn&#x27;t have datagrams, it has packets. Well, technically it does have datagrams but what I&#x27;m getting at is that with fragmentation (let&#x27;s say you have broken PMTUD) an IP packet can be split up.<p>That said, terminology confusion aside, you are still correct and I was wrong. The response can indeed be larger than a single IP packet. 65536 + IP overhead, split across as many IP packets as needed (doesn&#x27;t have to be a single very large fragmented packet).<p>I will delete my response!</div><br/><div id="39257557" class="c"><input type="checkbox" id="c-39257557" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39257442">parent</a><span>|</span><a href="#39256424">next</a><span>|</span><label class="collapse" for="c-39257557">[-]</label><label class="expand" for="c-39257557">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Well, technically it does have datagrams but what I&#x27;m getting at is that with fragmentation (let&#x27;s say you have broken PMTUD) an IP packet can be split up.<p>Of course, but in the happy usual case your network stack should be starting off with a TCP MSS &lt;= MTU + overhead and the IP datagrams will not be fragmented.<p>I used the term &quot;datagram&quot; because to higher layers like TCP, it is formally specified this way. I&#x27;m not too concerned about pedantry (except to avoid confusion) but this is the literal RFC9293 text: &quot;The application byte-stream is conveyed over the network via TCP segments, with each TCP segment sent as an Internet Protocol (IP) datagram. &quot;</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39256424" class="c"><input type="checkbox" id="c-39256424" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39254622">parent</a><span>|</span><a href="#39255423">prev</a><span>|</span><a href="#39256627">next</a><span>|</span><label class="collapse" for="c-39256424">[-]</label><label class="expand" for="c-39256424">[2 more]</label></div><br/><div class="children"><div class="content">The phrase &quot;TCP packet&quot; itself should raise some doubts on correctness, because TCP is a stream and not message-oriented protocol.</div><br/></div></div><div id="39256627" class="c"><input type="checkbox" id="c-39256627" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39254622">parent</a><span>|</span><a href="#39256424">prev</a><span>|</span><a href="#39255469">next</a><span>|</span><label class="collapse" for="c-39256627">[-]</label><label class="expand" for="c-39256627">[2 more]</label></div><br/><div class="children"><div class="content">TCP absolutely does have packets, it&#x27;s just that by convention userland is supposed to ignore them and proxies are allowed to change the boundaries.<p>If you control enough of the network and set the right socket options, you <i>can</i> observe them being preserved though! And as a result of this observation, people ignorant of the convention have written programs that most people now consider &quot;buggy&quot;.</div><br/><div id="39257073" class="c"><input type="checkbox" id="c-39257073" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#39254622">root</a><span>|</span><a href="#39256627">parent</a><span>|</span><a href="#39255469">next</a><span>|</span><label class="collapse" for="c-39257073">[-]</label><label class="expand" for="c-39257073">[1 more]</label></div><br/><div class="children"><div class="content">TCP itself doesn&#x27;t have packets with a size field though, it has segments. If speaking informally and everyone is on the same page, maybe it&#x27;s OK to say. But this might be a good place to be pedantic, since there is confusion. The 64 KiB limit for TCP&#x2F;IP is due to the 16-bit size field of the IP header. Crucially, TCP segments themselves don&#x27;t have a size field (hence TCP only works over a lower layer that encodes size). TCP segments have a 16-bit window size, but that can be increased by TCP window scale option.
So TCP&#x2F;IP has a 64 kbyte limit, but TCP itself does not. There was a proposed RFC for IPv6 &quot;jumbograms&quot; but that never gained adoption.<p>In the end, this 64k limitation being discussed comes from the DNS protocol itself where it encodes the length as a message prefix, this isn&#x27;t related to TCP or IP.</div><br/></div></div></div></div></div></div><div id="39255469" class="c"><input type="checkbox" id="c-39255469" checked=""/><div class="controls bullet"><span class="by">Kab1r</span><span>|</span><a href="#39254622">prev</a><span>|</span><label class="collapse" for="c-39255469">[-]</label><label class="expand" for="c-39255469">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t we do better with records for the root zone (`.`) instead of `a.io`?</div><br/><div id="39255659" class="c"><input type="checkbox" id="c-39255659" checked=""/><div class="controls bullet"><span class="by">amself</span><span>|</span><a href="#39255469">parent</a><span>|</span><label class="collapse" for="c-39255659">[-]</label><label class="expand" for="c-39255659">[1 more]</label></div><br/><div class="children"><div class="content">This is mentioned in the tweet at the end of the post</div><br/></div></div></div></div></div></div></div></div></div></body></html>