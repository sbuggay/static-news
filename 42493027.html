<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735117255275" as="style"/><link rel="stylesheet" href="styles.css?v=1735117255275"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yoric.github.io/post/rust-refinement-types/">What would it take to add refinement types to Rust?</a> <span class="domain">(<a href="https://yoric.github.io">yoric.github.io</a>)</span></div><div class="subtext"><span>Yoric</span> | <span>65 comments</span></div><br/><div><div id="42505187" class="c"><input type="checkbox" id="c-42505187" checked=""/><div class="controls bullet"><span class="by">amenghra</span><span>|</span><a href="#42505296">next</a><span>|</span><label class="collapse" for="c-42505187">[-]</label><label class="expand" for="c-42505187">[8 more]</label></div><br/><div class="children"><div class="content">Units might seem simple but they have a ton of edge cases. Do you want to be able to add inches and feet? Be careful about potential precision&#x2F;rounding issues. What is the unit for a temperature delta? You can’t simply keep the original unit (eg C or F) because conversion from F to C is a different rule than ΔF to ΔC. Etc.<p>Units do prevent bugs in programs, so they have an important role to play. But they also need to be designed very carefully.<p>Java adopted units via JSR 385 (<a href="https:&#x2F;&#x2F;belief-driven-design.com&#x2F;java-measurement-jsr-385-210f2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;belief-driven-design.com&#x2F;java-measurement-jsr-385-21...</a>)</div><br/><div id="42505574" class="c"><input type="checkbox" id="c-42505574" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42505187">parent</a><span>|</span><a href="#42505296">next</a><span>|</span><label class="collapse" for="c-42505574">[-]</label><label class="expand" for="c-42505574">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Do you want to be able to add inches and feet?<p>This probably doesn&#x27;t have to be too complicated; the usual answer for Rust is &quot;no&quot;. Rust doesn&#x27;t even let you &quot;just&quot; add two unsigned integers of different sizes. Following that design, I would imagine units would require an explicit &quot;turn feet into inches&quot; or the other way around.</div><br/><div id="42506143" class="c"><input type="checkbox" id="c-42506143" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#42505187">root</a><span>|</span><a href="#42505574">parent</a><span>|</span><a href="#42505752">next</a><span>|</span><label class="collapse" for="c-42506143">[-]</label><label class="expand" for="c-42506143">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s where Scala shines. I wrote about this here a bit: <a href="https:&#x2F;&#x2F;valentin.willscher.de&#x2F;posts&#x2F;contextual-syntax&#x2F;" rel="nofollow">https:&#x2F;&#x2F;valentin.willscher.de&#x2F;posts&#x2F;contextual-syntax&#x2F;</a><p>Rust is heavily inspired by Scala, but I guess achieving something like the examples in my post is difficult. I really hope Rust finds one way or another to make it work. Because simply forbidding everything all the time isn&#x27;t even the safest way - it drives many people to just avoid it altogether and use unsafe code.</div><br/></div></div><div id="42505752" class="c"><input type="checkbox" id="c-42505752" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42505187">root</a><span>|</span><a href="#42505574">parent</a><span>|</span><a href="#42506143">prev</a><span>|</span><a href="#42505296">next</a><span>|</span><label class="collapse" for="c-42505752">[-]</label><label class="expand" for="c-42505752">[5 more]</label></div><br/><div class="children"><div class="content">Might be annoying if you’re working with floating point but given that each conversion introduces error, it’s probably good to be explicit and recommend internally to be consistent</div><br/><div id="42505899" class="c"><input type="checkbox" id="c-42505899" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42505187">root</a><span>|</span><a href="#42505752">parent</a><span>|</span><a href="#42505296">next</a><span>|</span><label class="collapse" for="c-42505899">[-]</label><label class="expand" for="c-42505899">[4 more]</label></div><br/><div class="children"><div class="content">Thanks to generics you could theoretically work with whatever underlying type makes the most sense for your use-case.<p><pre><code>    let v1 : Inches&lt;Ratio&gt; = Ratio::new(5, 8).into();
    let v2 : Inches&lt;Ratio&gt; = Ratio::new(3, 8).into();

    let v3 : Feet&lt;_&gt; = (v1 + v2).into();

    assert_equal!(v3, Ratio::new(1, 12));</code></pre></div><br/><div id="42506840" class="c"><input type="checkbox" id="c-42506840" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42505187">root</a><span>|</span><a href="#42505899">parent</a><span>|</span><a href="#42507357">next</a><span>|</span><label class="collapse" for="c-42506840">[-]</label><label class="expand" for="c-42506840">[2 more]</label></div><br/><div class="children"><div class="content">no that&#x27;s not the point.  if you let rust automagically decide when and where to apply conversions you could easily wind up in a situation where you have more operations than you need, which increases numerical error, and <i>also</i> be a bitch to uncover or refactor to minimize conversions.</div><br/><div id="42507044" class="c"><input type="checkbox" id="c-42507044" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42505187">root</a><span>|</span><a href="#42506840">parent</a><span>|</span><a href="#42507357">next</a><span>|</span><label class="collapse" for="c-42507044">[-]</label><label class="expand" for="c-42507044">[1 more]</label></div><br/><div class="children"><div class="content">Rust doesn’t automatically apply conversions, full stop.<p>And with a thoughtful approach to the API, you could avoid numerical error entirely by using integral types.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42505296" class="c"><input type="checkbox" id="c-42505296" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#42505187">prev</a><span>|</span><a href="#42505261">next</a><span>|</span><label class="collapse" for="c-42505296">[-]</label><label class="expand" for="c-42505296">[10 more]</label></div><br/><div class="children"><div class="content">I find the idea of being able to specify numerical types with arbitrary ranges very appealing.<p>In Pascal these are called range types, e.g.<p>month: 1..12<p>would define an integer where the type system would ensure that it is always between 1 and 12.<p>Apart from Ada this seems to be an alien concept to all other languages. The concept of a &quot;range type&quot; also seems to have other meanings.<p>What is the Pascal &quot;range type&quot; properly called in type theory and what is its relationship to refinement types?</div><br/><div id="42505664" class="c"><input type="checkbox" id="c-42505664" checked=""/><div class="controls bullet"><span class="by">3eb7988a1663</span><span>|</span><a href="#42505296">parent</a><span>|</span><a href="#42505639">next</a><span>|</span><label class="collapse" for="c-42505664">[-]</label><label class="expand" for="c-42505664">[1 more]</label></div><br/><div class="children"><div class="content">Nim calls these subranges <a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;manual.html#types-subrange-types" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org&#x2F;docs&#x2F;manual.html#types-subrange-types</a><p><pre><code>  Subrange = range[0..5]
  PositiveFloat = range[0.0..Inf]</code></pre></div><br/></div></div><div id="42505639" class="c"><input type="checkbox" id="c-42505639" checked=""/><div class="controls bullet"><span class="by">frogulis</span><span>|</span><a href="#42505296">parent</a><span>|</span><a href="#42505664">prev</a><span>|</span><a href="#42507567">next</a><span>|</span><label class="collapse" for="c-42505639">[-]</label><label class="expand" for="c-42505639">[1 more]</label></div><br/><div class="children"><div class="content">Anybody correct me if I&#x27;m wrong -- in Pascal these subranges can specify the size of the variable in memory and check compile-type assignment to a literal value, but don&#x27;t (can&#x27;t) do much else.<p>There&#x27;s the concept of dependent types in e.g. Idris which lets us correctly do this sort of range check throughout the program (not just on literal assignment) but it comes with strict requirements on what the compiler can allow, such as no unbounded recursion, because checking dependent types is roughly equivalent to running the program.</div><br/></div></div><div id="42507567" class="c"><input type="checkbox" id="c-42507567" checked=""/><div class="controls bullet"><span class="by">evertedsphere</span><span>|</span><a href="#42505296">parent</a><span>|</span><a href="#42505639">prev</a><span>|</span><a href="#42505521">next</a><span>|</span><label class="collapse" for="c-42507567">[-]</label><label class="expand" for="c-42507567">[1 more]</label></div><br/><div class="children"><div class="content">it is a refinement type over the base number type, where the predicate constrains the number to lie in an interval<p>e.g. { x:Int8 | 1 ≤ x ≤ 12 }</div><br/></div></div><div id="42505521" class="c"><input type="checkbox" id="c-42505521" checked=""/><div class="controls bullet"><span class="by">bspammer</span><span>|</span><a href="#42505296">parent</a><span>|</span><a href="#42507567">prev</a><span>|</span><a href="#42505364">next</a><span>|</span><label class="collapse" for="c-42505521">[-]</label><label class="expand" for="c-42505521">[4 more]</label></div><br/><div class="children"><div class="content">I frequently wish I had a natural number type. So many programs would benefit from the type system guaranteeing that numbers are never negative.</div><br/><div id="42505878" class="c"><input type="checkbox" id="c-42505878" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42505296">root</a><span>|</span><a href="#42505521">parent</a><span>|</span><a href="#42506625">next</a><span>|</span><label class="collapse" for="c-42505878">[-]</label><label class="expand" for="c-42505878">[1 more]</label></div><br/><div class="children"><div class="content">Rust has this one - though the ergonomics are a little awkward. Its called NonZero:<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;num&#x2F;type.NonZeroU32.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;num&#x2F;type.NonZeroU32.html</a></div><br/></div></div><div id="42506625" class="c"><input type="checkbox" id="c-42506625" checked=""/><div class="controls bullet"><span class="by">archargelod</span><span>|</span><a href="#42505296">root</a><span>|</span><a href="#42505521">parent</a><span>|</span><a href="#42505878">prev</a><span>|</span><a href="#42505649">next</a><span>|</span><label class="collapse" for="c-42506625">[-]</label><label class="expand" for="c-42506625">[1 more]</label></div><br/><div class="children"><div class="content">Nim has Natural and Positive (signed int) types that checked at compile and runtime. You can also define arbitrary range types for any ordinal type, for example enums:<p><pre><code>  type
    Month = enum Jan, Feb, Mar, Apr, May, ...
    SpringMonth = range[Mar..May]
  
  var m: SpringMonth = Mar
</code></pre>
It will raise under&#x2F;overflow exception if value falls out of range.</div><br/></div></div><div id="42505649" class="c"><input type="checkbox" id="c-42505649" checked=""/><div class="controls bullet"><span class="by">frogulis</span><span>|</span><a href="#42505296">root</a><span>|</span><a href="#42505521">parent</a><span>|</span><a href="#42506625">prev</a><span>|</span><a href="#42505364">next</a><span>|</span><label class="collapse" for="c-42505649">[-]</label><label class="expand" for="c-42505649">[1 more]</label></div><br/><div class="children"><div class="content">Easy enough to write in some languages... as long as you only need to support addition and multiplication, or a very limited set of numbers.</div><br/></div></div></div></div><div id="42505364" class="c"><input type="checkbox" id="c-42505364" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42505296">parent</a><span>|</span><a href="#42505521">prev</a><span>|</span><a href="#42505261">next</a><span>|</span><label class="collapse" for="c-42505364">[-]</label><label class="expand" for="c-42505364">[2 more]</label></div><br/><div class="children"><div class="content">&gt; an integer where the type system would ensure that it is always between 1 and 12<p>How does Pascal handle overflow&#x2F;underflow? E.g. Month 10 + Month 11 = Month 21?</div><br/><div id="42507584" class="c"><input type="checkbox" id="c-42507584" checked=""/><div class="controls bullet"><span class="by">eddsolves</span><span>|</span><a href="#42505296">root</a><span>|</span><a href="#42505364">parent</a><span>|</span><a href="#42505261">next</a><span>|</span><label class="collapse" for="c-42507584">[-]</label><label class="expand" for="c-42507584">[1 more]</label></div><br/><div class="children"><div class="content">I assume modulo?</div><br/></div></div></div></div></div></div><div id="42505261" class="c"><input type="checkbox" id="c-42505261" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#42505296">prev</a><span>|</span><a href="#42507596">next</a><span>|</span><label class="collapse" for="c-42505261">[-]</label><label class="expand" for="c-42505261">[1 more]</label></div><br/><div class="children"><div class="content">I would love to see refinement types added to Rust.<p>They are very handy for preventing errors and expressing intent in Ada:<p><a href="https:&#x2F;&#x2F;learn.adacore.com&#x2F;courses&#x2F;Ada_For_The_CPP_Java_Developer&#x2F;chapters&#x2F;05_Type_System.html" rel="nofollow">https:&#x2F;&#x2F;learn.adacore.com&#x2F;courses&#x2F;Ada_For_The_CPP_Java_Devel...</a></div><br/></div></div><div id="42507596" class="c"><input type="checkbox" id="c-42507596" checked=""/><div class="controls bullet"><span class="by">eddsolves</span><span>|</span><a href="#42505261">prev</a><span>|</span><a href="#42503693">next</a><span>|</span><label class="collapse" for="c-42507596">[-]</label><label class="expand" for="c-42507596">[1 more]</label></div><br/><div class="children"><div class="content">I think liquid Haskell is a great example of refinement types?<p><a href="https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell&#x2F;</a></div><br/></div></div><div id="42503693" class="c"><input type="checkbox" id="c-42503693" checked=""/><div class="controls bullet"><span class="by">nmilo</span><span>|</span><a href="#42507596">prev</a><span>|</span><a href="#42505438">next</a><span>|</span><label class="collapse" for="c-42503693">[-]</label><label class="expand" for="c-42503693">[2 more]</label></div><br/><div class="children"><div class="content">It should be easier now with const generics, I know the popular C++ library looks like Value&lt;Unit, T, L, M, ...&gt; where the letters are numbers representing the dimension of time, length, mass, etc. So m&#x2F;s^2 would always be Value&lt;f64, -2, 1, 0, ...&gt;. By keeping it normalized you don&#x27;t need Equivalent or whatever</div><br/></div></div><div id="42505438" class="c"><input type="checkbox" id="c-42505438" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#42503693">prev</a><span>|</span><a href="#42503561">next</a><span>|</span><label class="collapse" for="c-42505438">[-]</label><label class="expand" for="c-42505438">[4 more]</label></div><br/><div class="children"><div class="content">As a related concept, we&#x27;ve talked about adding &quot;pattern types&quot; to Rust: `Result&lt;T&gt; is Err(_)` (the type of a Result that you&#x27;ve just confirmed is an `Err`, so you don&#x27;t have to handle the `Ok` case), or `u32 is 1..` (equivalent to `NonZero&lt;u32&gt;` but more flexible).</div><br/><div id="42505706" class="c"><input type="checkbox" id="c-42505706" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#42505438">parent</a><span>|</span><a href="#42503561">next</a><span>|</span><label class="collapse" for="c-42505706">[-]</label><label class="expand" for="c-42505706">[3 more]</label></div><br/><div class="children"><div class="content">Is the former different from a hypothetical Result::Err type (I don&#x27;t know if you&#x27;d spell that Result::Err&lt;T&gt; or Result::&lt;T&gt;::Err)?</div><br/><div id="42505736" class="c"><input type="checkbox" id="c-42505736" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#42505438">root</a><span>|</span><a href="#42505706">parent</a><span>|</span><a href="#42505724">next</a><span>|</span><label class="collapse" for="c-42505736">[-]</label><label class="expand" for="c-42505736">[1 more]</label></div><br/><div class="children"><div class="content">Different solutions to the same problem. Pattern types are more general than enum variant types.</div><br/></div></div><div id="42505724" class="c"><input type="checkbox" id="c-42505724" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#42505438">root</a><span>|</span><a href="#42505706">parent</a><span>|</span><a href="#42505736">prev</a><span>|</span><a href="#42503561">next</a><span>|</span><label class="collapse" for="c-42505724">[-]</label><label class="expand" for="c-42505724">[1 more]</label></div><br/><div class="children"><div class="content">Same concept, but generalized to any type, not just enums.</div><br/></div></div></div></div></div></div><div id="42503561" class="c"><input type="checkbox" id="c-42503561" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42505438">prev</a><span>|</span><a href="#42503571">next</a><span>|</span><label class="collapse" for="c-42503561">[-]</label><label class="expand" for="c-42503561">[13 more]</label></div><br/><div class="children"><div class="content">The author didn&#x27;t mention this, but maybe there could be a type (unit) canonicalization step that always produces the same reduced&#x2F;simplified type for any equivalent set of Mul&#x2F;Divs?  So that you don&#x27;t need the later equivalency check.<p>E.g. with the article&#x27;s example, where &#x27;a&#x27; is Meters and &#x27;b&#x27; is Seconds, &#x27;a&#x2F;(b*b)&#x27; and &#x27;a&#x2F;b&#x2F;b&#x27; both have type &#x27;Div&lt;Meters, Mul&lt;Seconds, Seconds&gt;&gt;&#x27; instead of one having the type &#x27;Div&lt;Div&lt;Meters, Seconds&gt;, Seconds&gt;&#x27;.<p>For only Muls and Divs you can basically just have a histogram of units to powers (e.g., m&#x2F;s^2 =&gt; m: 1, s: -2) which uniquely represent equivalent types.</div><br/><div id="42504418" class="c"><input type="checkbox" id="c-42504418" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42503561">parent</a><span>|</span><a href="#42505246">next</a><span>|</span><label class="collapse" for="c-42504418">[-]</label><label class="expand" for="c-42504418">[9 more]</label></div><br/><div class="children"><div class="content">James Gosling looked at this and wrote about it at the time. It can be a bit mind bending. Especially with units named after people.<p>If you’re looking at statistics for current or power the type system might try to convert it to joules even though you wanted to look at average wattage.</div><br/><div id="42505156" class="c"><input type="checkbox" id="c-42505156" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42504418">parent</a><span>|</span><a href="#42504759">next</a><span>|</span><label class="collapse" for="c-42505156">[-]</label><label class="expand" for="c-42505156">[1 more]</label></div><br/><div class="children"><div class="content">I do not understand, average wattage&#x2F;power would be integration of wattage (joules) divided by time (so back to watts), it’s still watts? Under what implementation would you end up with joules that isn’t just oddly broken in general?<p>I guess I could see a naive implementation (confusing integration&#x2F;sampling and discrete summation) going the <i>other</i> way, erroneously ending up with a nonsensical W&#x2F;s.<p>Also don’t understand what it has to do with eponyms, which are just substitutes for base units, either your DA works or not, no?
Average wattage is kg⋅m²⋅s⁻³ not kg⋅m²⋅s⁻² (joules) or kg⋅m²⋅s⁻⁴</div><br/></div></div><div id="42504759" class="c"><input type="checkbox" id="c-42504759" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42504418">parent</a><span>|</span><a href="#42505156">prev</a><span>|</span><a href="#42505246">next</a><span>|</span><label class="collapse" for="c-42504759">[-]</label><label class="expand" for="c-42504759">[7 more]</label></div><br/><div class="children"><div class="content">Yeah, but equivalent units with different names is sort of only a display&#x2F;formatting issue, right?</div><br/><div id="42505255" class="c"><input type="checkbox" id="c-42505255" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42504759">parent</a><span>|</span><a href="#42506582">next</a><span>|</span><label class="collapse" for="c-42505255">[-]</label><label class="expand" for="c-42505255">[4 more]</label></div><br/><div class="children"><div class="content">This is a matter of perspective.<p>For example the unit Sievert is an official SI unit despite being just J&#x2F;kg. This is because confusing equivalent dose and absorbed dose, which also has the unit of J&#x2F;kg, could be very dangerous.<p>Note, that this is different from J sometimes being written as Ws. While there are informal conventions, when we use J and when Ws, using the unconventional one would not be technically wrong because 1 J is simply 1 Ws, whereas 1 Sv is not necessarily 1 J&#x2F;kg when the later is an absorbed dose.<p>I think one could reasonably disagree with these decisions but that is how the SI people see it.</div><br/><div id="42505723" class="c"><input type="checkbox" id="c-42505723" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42505255">parent</a><span>|</span><a href="#42505632">next</a><span>|</span><label class="collapse" for="c-42505723">[-]</label><label class="expand" for="c-42505723">[1 more]</label></div><br/><div class="children"><div class="content">Sievert is more of a &quot;newtype&quot; in Rust&#x2F;Haskell terminology than a separate unit. Likewise for radians and moles.</div><br/></div></div><div id="42505632" class="c"><input type="checkbox" id="c-42505632" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42505255">parent</a><span>|</span><a href="#42505723">prev</a><span>|</span><a href="#42506582">next</a><span>|</span><label class="collapse" for="c-42505632">[-]</label><label class="expand" for="c-42505632">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is a matter of perspective.<p>I&#x27;d make a stronger statement here; this is a specific example of when having units is most powerful. When even though two things are expressed in some common form, they nevertheless represent something different.<p>&gt; Yeah, but equivalent units with different names is sort of only a display&#x2F;formatting issue, right?<p>This could be said of two u32s as well.</div><br/><div id="42507197" class="c"><input type="checkbox" id="c-42507197" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42505632">parent</a><span>|</span><a href="#42506582">next</a><span>|</span><label class="collapse" for="c-42507197">[-]</label><label class="expand" for="c-42507197">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  When even though two things are expressed in some common form, they nevertheless represent something different.<p>This is where people go wrong trying to DRY and other refactors. Slightly forced example but<p><pre><code>  function averagePerClassroom(total) { return total &#x2F; 30; } &#x2F;&#x2F; 30 kids per class
  function averagePerMonth(total) { return total &#x2F; 30; }  &#x2F;&#x2F; assume 30
</code></pre>
&quot;Oh, the function body is the same therefore lets refactor this into an &quot;averagePer&quot; function&quot; expect its two completely different concepts and once the code calculates the actual days per month or once classes are no longer 30 people suddenly things need to be un-refactored, or what I see more often, is just branching off inside the new single function based on an argument flag. Horrible.</div><br/></div></div></div></div></div></div><div id="42506582" class="c"><input type="checkbox" id="c-42506582" checked=""/><div class="controls bullet"><span class="by">amalcon</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42504759">parent</a><span>|</span><a href="#42505255">prev</a><span>|</span><a href="#42505321">next</a><span>|</span><label class="collapse" for="c-42506582">[-]</label><label class="expand" for="c-42506582">[1 more]</label></div><br/><div class="children"><div class="content">A joule, notably, is a newton-meter.  Torque is also measured in newton-meters, but the meters are perpendicular to the newtons.<p>Adding energy to torque is rarely going to be intentional.</div><br/></div></div></div></div></div></div><div id="42505246" class="c"><input type="checkbox" id="c-42505246" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42503561">parent</a><span>|</span><a href="#42504418">prev</a><span>|</span><a href="#42503571">next</a><span>|</span><label class="collapse" for="c-42505246">[-]</label><label class="expand" for="c-42505246">[3 more]</label></div><br/><div class="children"><div class="content">A simple way to do this is to store a vector of the powers.<p>For example momentum is kilogram * meter &#x2F; second, which is MASS^1 * LENGTH^1 * TIME^-1<p>As a vector, this can be represented as (1,1,-1) where the positions are M, L, T respectively.<p>In that format velocity is represented as (0,1,-1), acceleration is (0,1,-2), etc...<p>This is automatically canonicalised and much easier to manipulate than a tree of operations.<p>Of course, this assumes uniform units such as CGS or MKS in something sane like the metric system. Conversion back and forth is generally straightforward, as long as the types encode the system used. E.g.: CGS&lt;1,1,-1&gt; and MKS&lt;1,1,-1&gt; both represent momentum, but at different scales.<p>Imperial also works, and other base units can be added to extend the system. This can include things like current, temperature, moles, etc...<p>See: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dimensional_analysis" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dimensional_analysis</a></div><br/><div id="42505614" class="c"><input type="checkbox" id="c-42505614" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42505246">parent</a><span>|</span><a href="#42503571">next</a><span>|</span><label class="collapse" for="c-42505614">[-]</label><label class="expand" for="c-42505614">[2 more]</label></div><br/><div class="children"><div class="content">&gt; This is automatically canonicalised and much easier to manipulate than a tree of operations.<p>As long as the vector is sorted by unit, yeah.  With that caveat, it&#x27;s the same idea.</div><br/><div id="42505696" class="c"><input type="checkbox" id="c-42505696" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42503561">root</a><span>|</span><a href="#42505614">parent</a><span>|</span><a href="#42503571">next</a><span>|</span><label class="collapse" for="c-42505696">[-]</label><label class="expand" for="c-42505696">[1 more]</label></div><br/><div class="children"><div class="content">It’s a positional system with the same basic measurement units always at the same index locations.</div><br/></div></div></div></div></div></div></div></div><div id="42503571" class="c"><input type="checkbox" id="c-42503571" checked=""/><div class="controls bullet"><span class="by">jph</span><span>|</span><a href="#42503561">prev</a><span>|</span><a href="#42505503">next</a><span>|</span><label class="collapse" for="c-42503571">[-]</label><label class="expand" for="c-42503571">[5 more]</label></div><br/><div class="children"><div class="content">Type refinements are a great concept and I&#x27;d love to see them in Rust. And double-refinement types are great for helping with conversions, such as with Rust From&#x2F;Into, and potentially a dynamic converter function.<p>Examples of double-refinements that I&#x27;d like:<p>- Common units like Length:Meter and Length:Foot.<p>- Color bits like Color:RGB24 and Color:CYMK24.<p>- Worldwide currency like Money:USD and Money:GBP with a converter function that knows exchange rates.<p>- Human languages like String:English vs String:Cymraeg with a converter function that knows translations.</div><br/><div id="42505128" class="c"><input type="checkbox" id="c-42505128" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#42503571">parent</a><span>|</span><a href="#42505091">next</a><span>|</span><label class="collapse" for="c-42505128">[-]</label><label class="expand" for="c-42505128">[2 more]</label></div><br/><div class="children"><div class="content">&gt; - Worldwide currency like Money:USD and Money:GBP with a converter function that knows exchange rates.<p>Exchange rates vary over time, so you&#x27;d arguably need a type which includes a timestamp (e.g. &quot;USD 1000 at 2024-12-25&quot;).<p>And that&#x27;s ignoring all these other complexities such as the spread, different currency converters offering differing rates, unofficial and multiple official rates in countries with currency controls (e.g. Argentina), hedging, etc</div><br/><div id="42505344" class="c"><input type="checkbox" id="c-42505344" checked=""/><div class="controls bullet"><span class="by">jaza</span><span>|</span><a href="#42503571">root</a><span>|</span><a href="#42505128">parent</a><span>|</span><a href="#42505091">next</a><span>|</span><label class="collapse" for="c-42505344">[-]</label><label class="expand" for="c-42505344">[1 more]</label></div><br/><div class="children"><div class="content">Plus, perhaps the biggest complexity of all is that the currency rates are often not free, particularly if you want &quot;live pricing&quot; (updated every few seconds), and particularly if it&#x27;s for commercial use. And, the fact that they may or may not be free, also illustrates well the fact that there are no definitive rates, there are only &quot;rates according to X&quot;.</div><br/></div></div></div></div><div id="42505091" class="c"><input type="checkbox" id="c-42505091" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42503571">parent</a><span>|</span><a href="#42505128">prev</a><span>|</span><a href="#42505503">next</a><span>|</span><label class="collapse" for="c-42505091">[-]</label><label class="expand" for="c-42505091">[2 more]</label></div><br/><div class="children"><div class="content">The currency converter is the odd one out because it context dependent. (Time, contract, etc)</div><br/><div id="42505347" class="c"><input type="checkbox" id="c-42505347" checked=""/><div class="controls bullet"><span class="by">0xFF0123</span><span>|</span><a href="#42503571">root</a><span>|</span><a href="#42505091">parent</a><span>|</span><a href="#42505503">next</a><span>|</span><label class="collapse" for="c-42505347">[-]</label><label class="expand" for="c-42505347">[1 more]</label></div><br/><div class="children"><div class="content">Similar to time with a timezone?</div><br/></div></div></div></div></div></div><div id="42505503" class="c"><input type="checkbox" id="c-42505503" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#42503571">prev</a><span>|</span><a href="#42504726">next</a><span>|</span><label class="collapse" for="c-42505503">[-]</label><label class="expand" for="c-42505503">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d really like to have them. If I&#x27;m writing an algorithm that maps interval (0, 1) of probabilities onto different intervals of u32 integers, and probabilites are also represented as integers (an integer part of p*2^n), I will want to have different units for those integer probabilites and their mapped values. I don&#x27;t want to mix them accidentally and to add probability and a mapped probability accidentally. Probably I dont want to add cumulative probability and a probability, though I&#x27;m not really sure about that, because sometimes I want to add (for example when calculating cumulative probabilities) and I want to compare them. Though maybe it will work with some exotic rules, like CumProb-CumProb -&gt; Prob, while CumProb+CumProb is forbidden?<p>And there are more examples of that, I can have probabilities from different distributions, I don&#x27;t want to add them accidentally, though multiplications of them is all over the place, so let it be. Of course I have no hope that any language could deal with the explosion of types that are needed to represent this, but if compiler just gave me f64 as a result of multiplication of probabilites, I&#x27;d be happy.<p>It can be done in Rust on case by case bases, but it is a lot of boilerplate. The issue is the typedef IntProb = u32, treat IntProb like an alias to u32 and rustc converts these types into each other silently like C compiler converts int to char. One can do struct IntProb(u32), but then it would be needed to implement traits like Add, Mul, Cmp and so on, which is possible but it is too much work. If it was possible to force rustc to treat typedef MyType = {NumericType} as a distinct numeric type that requires explicit conversion into NumericType, while retaining all the traits of NumericType, just substituting in them NumericType with MyType, it would be great.<p>I think, that all the complexities described in the article stem from the attempt to create an universal instrument that can do everything and to keep bees. The real difficulty is to pick a small subset of wants, that will cover 80% of needs, while being really simple. I see no issues with occasional .into::&lt;Length&lt;f64&gt;&gt;(), like I see no issues with (my_struc.index as usize), if I keep index as u8 to spare memory, but use it as usize of course. I see no need in different units for the same quantity, because in any case I&#x27;d want to convert everything into the same uniform units before I start adding and multiplying. But I&#x27;d like to have restrictions on available operations between different types, and I&#x27;d like to have a possibility to add optional dynamic checks for type value, that I could turn on for a debug build and turn off for a release one. For example, I&#x27;d like to check that any probability p fits into [0, 1].</div><br/></div></div><div id="42504726" class="c"><input type="checkbox" id="c-42504726" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#42505503">prev</a><span>|</span><a href="#42504615">next</a><span>|</span><label class="collapse" for="c-42504726">[-]</label><label class="expand" for="c-42504726">[8 more]</label></div><br/><div class="children"><div class="content">If I understand this properly, I’ve needed this in typescript a lot.<p>I can make `type uuid = string` for self documentation, but a lot of plugins will just label it “string” and developers can (and have) mistakenly put some other identifier, like the robot’s hostname.<p>Of course we validate at the API but it’d be more skookum if we could prevent accidental wiring together of front-end components that make this error.<p>String literals help a ton. Gosh they’re wonderful to care about the shape of a string in the type system. But sometimes I really want to say “strict uuid” as in “I don’t care if it quacks like a duck, it’s not called duck.”</div><br/><div id="42506536" class="c"><input type="checkbox" id="c-42506536" checked=""/><div class="controls bullet"><span class="by">feznyng</span><span>|</span><a href="#42504726">parent</a><span>|</span><a href="#42504808">next</a><span>|</span><label class="collapse" for="c-42506536">[-]</label><label class="expand" for="c-42506536">[1 more]</label></div><br/><div class="children"><div class="content">As spockz pointed out, you’re looking for the new type pattern. Rust supports this explicitly but you’ve got to do some workarounds to get it in typescript.<p><a href="https:&#x2F;&#x2F;kubyshkin.name&#x2F;posts&#x2F;newtype-in-typescript&#x2F;" rel="nofollow">https:&#x2F;&#x2F;kubyshkin.name&#x2F;posts&#x2F;newtype-in-typescript&#x2F;</a><p>Unfortunately doesn’t help much when you’re dealing with functions from packages someone else has typed.</div><br/></div></div><div id="42504808" class="c"><input type="checkbox" id="c-42504808" checked=""/><div class="controls bullet"><span class="by">mcfedr</span><span>|</span><a href="#42504726">parent</a><span>|</span><a href="#42506536">prev</a><span>|</span><a href="#42505097">next</a><span>|</span><label class="collapse" for="c-42504808">[-]</label><label class="expand" for="c-42504808">[5 more]</label></div><br/><div class="children"><div class="content">Check out what are often called tagged types.<p>You basically define a `type A = string &amp;{a: SomeSymbol}`<p>And then have a type assertion function that just returns true, and you have control over the places A can come from</div><br/><div id="42504964" class="c"><input type="checkbox" id="c-42504964" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42504726">root</a><span>|</span><a href="#42504808">parent</a><span>|</span><a href="#42505148">next</a><span>|</span><label class="collapse" for="c-42504964">[-]</label><label class="expand" for="c-42504964">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s the standard way if you want implicit compat with the base type, so you can pass a value of type `A` to a function expecting a `string`. An other name for this pattern is &quot;branded types&quot;.</div><br/></div></div><div id="42505148" class="c"><input type="checkbox" id="c-42505148" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#42504726">root</a><span>|</span><a href="#42504808">parent</a><span>|</span><a href="#42504964">prev</a><span>|</span><a href="#42504838">next</a><span>|</span><label class="collapse" for="c-42505148">[-]</label><label class="expand" for="c-42505148">[1 more]</label></div><br/><div class="children"><div class="content">I really like the Effect schema library for tagged types. I’m not sure how well it works for primitives, though.</div><br/></div></div><div id="42504838" class="c"><input type="checkbox" id="c-42504838" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#42504726">root</a><span>|</span><a href="#42504808">parent</a><span>|</span><a href="#42505148">prev</a><span>|</span><a href="#42505097">next</a><span>|</span><label class="collapse" for="c-42504838">[-]</label><label class="expand" for="c-42504838">[2 more]</label></div><br/><div class="children"><div class="content">Ah yeah I remember poking at that. I should review it again. I think at the time it felt like a bit of a hack, but maybe some features of the past years of TS updates have helped.<p>I assume the idea is to lie to the type system about the existence of the symbol, and at runtime it is just a string.</div><br/><div id="42506742" class="c"><input type="checkbox" id="c-42506742" checked=""/><div class="controls bullet"><span class="by">TOGoS</span><span>|</span><a href="#42504726">root</a><span>|</span><a href="#42504838">parent</a><span>|</span><a href="#42505097">next</a><span>|</span><label class="collapse" for="c-42506742">[-]</label><label class="expand" for="c-42506742">[1 more]</label></div><br/><div class="children"><div class="content">To me it feels like less of a hack if I can make the type declaration not a lie.  e.g.<p><pre><code>   type FooID = string &amp; { typeName? : &quot;FooID&quot; }
</code></pre>
Read as &#x27;of course this thing doesn&#x27;t have a typeName[1] property, since it&#x27;s a string, but if it <i>did</i> have the property, the value would be &quot;FooID&quot;&#x27;.  You can then cast between FooID and string, but not between FooID and some other type that declares a typeName property.<p>[1] I actually tend to use &#x27;classRef&#x27; with an RDFish long name for the type, but that makes examples longer and isn&#x27;t the point.</div><br/></div></div></div></div></div></div><div id="42505097" class="c"><input type="checkbox" id="c-42505097" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#42504726">parent</a><span>|</span><a href="#42504808">prev</a><span>|</span><a href="#42504615">next</a><span>|</span><label class="collapse" for="c-42505097">[-]</label><label class="expand" for="c-42505097">[1 more]</label></div><br/><div class="children"><div class="content">Haskell has had this with `newtype` for ages. Type safety without runtime overhead.</div><br/></div></div></div></div><div id="42504615" class="c"><input type="checkbox" id="c-42504615" checked=""/><div class="controls bullet"><span class="by">marxisttemp</span><span>|</span><a href="#42504726">prev</a><span>|</span><a href="#42506058">next</a><span>|</span><label class="collapse" for="c-42504615">[-]</label><label class="expand" for="c-42504615">[5 more]</label></div><br/><div class="children"><div class="content">Could someone clarify to me the different between dependent types and refinement types?</div><br/><div id="42504990" class="c"><input type="checkbox" id="c-42504990" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#42504615">parent</a><span>|</span><a href="#42505178">next</a><span>|</span><label class="collapse" for="c-42504990">[-]</label><label class="expand" for="c-42504990">[1 more]</label></div><br/><div class="children"><div class="content">Refinements embed a predicate that elements of the new type must pass.<p><pre><code>    def Nat = Int: (|x| -&gt; x &gt;= 0)
</code></pre>
Dependent types allow types to be computed from functions (and depend on arguments, otherwise it seems they become just weird constants),<p><pre><code>    def Five(as_type: String) -&gt; NumericType(as_type):
      match as_type:
        &quot;string&quot; =&gt; &quot;five&quot;
        &quot;int&quot; =&gt; 5
        &quot;float&quot; =&gt; 5.0f
        &quot;double&quot; =&gt; 5.0d
        _ =&gt; panic()  &#x2F;&#x2F; Unnecessary if you refine `as_type` from a String to an enum or a fixed set of strings.

</code></pre>
Dependent types seem weird, but they help making types first-class (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mOtKD7ml0NU&amp;t=325s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mOtKD7ml0NU&amp;t=325s</a>) and gaining types like `Array&lt;T, N&gt;` that allow ensuring things are the right length, and define append&#x2F;extend properly.</div><br/></div></div><div id="42505178" class="c"><input type="checkbox" id="c-42505178" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#42504615">parent</a><span>|</span><a href="#42504990">prev</a><span>|</span><a href="#42505027">next</a><span>|</span><label class="collapse" for="c-42505178">[-]</label><label class="expand" for="c-42505178">[1 more]</label></div><br/><div class="children"><div class="content">Dependent types typically refers to type systems where a type can depend on a term. The canonical example is &quot;Vector n&quot; where n is some expression that evaluates to a natural number.<p>Refinement types typically(1) refers to a type systems that lets you create a subtype of a type through refining (qualifying) with a predicate or constraint on the shape. Examples {x \in int | is_even x } or { x \in List | len(x) = 1 }<p>Refinement types can be very powerful but that may well make type checking undecidable (think of a type of Turing machines, and the refinement that keeps only the ones that halt). By being careful about the logic used in the refinements, one may retain decidability.<p>(1) The article seems to have a different idea of what a refinement type is: quote &quot;a type system that does its work after another type system has already done its work&quot;.<p>I am not going to play orthodox guardian of type theory terminology here, yet to me personally, it does seem unfortunate to use that term. The author seems to really want a form of type-level computation, which could be interesting if it could be rigorously specified and it&#x27;s relation to the existing type level reduction clarified.</div><br/></div></div><div id="42505027" class="c"><input type="checkbox" id="c-42505027" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#42504615">parent</a><span>|</span><a href="#42505178">prev</a><span>|</span><a href="#42505388">next</a><span>|</span><label class="collapse" for="c-42505027">[-]</label><label class="expand" for="c-42505027">[1 more]</label></div><br/><div class="children"><div class="content">Dependent types can make type constructors generic over _values_ (instead of only types). Refinement types keep the separation between types and values, but they let you wrap an existing type to enforce extra constraints or semantics. Another example of refinement are pattern types where you can attach a match pattern that is enforced to pass.</div><br/></div></div><div id="42505388" class="c"><input type="checkbox" id="c-42505388" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#42504615">parent</a><span>|</span><a href="#42505027">prev</a><span>|</span><a href="#42506058">next</a><span>|</span><label class="collapse" for="c-42505388">[-]</label><label class="expand" for="c-42505388">[1 more]</label></div><br/><div class="children"><div class="content">You could just read the first paragraph of TFA?</div><br/></div></div></div></div></div></div></div></div></div></body></html>