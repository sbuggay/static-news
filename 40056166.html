<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713603652411" as="style"/><link rel="stylesheet" href="styles.css?v=1713603652411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.cs.cmu.edu/~rwh/pfpl/supplements/ulc.pdf">Church&#x27;s λ-Calculus (2023) [pdf]</a> <span class="domain">(<a href="http://www.cs.cmu.edu">www.cs.cmu.edu</a>)</span></div><div class="subtext"><span>jstrieb</span> | <span>28 comments</span></div><br/><div><div id="40093124" class="c"><input type="checkbox" id="c-40093124" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#40094811">next</a><span>|</span><label class="collapse" for="c-40093124">[-]</label><label class="expand" for="c-40093124">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got Harper&#x27;s <i>Practical Foundations for Programming Languages</i> and it&#x27;s a great book—he writes clearly and succinctly.<p>Knowing the lambda calculus helped me one time when I was working as a software engineer: I had just added functions to a little DSL interpreter that was going to make it easy to customize behavior of our product to different customers. (It wasn&#x27;t ever going to be <i>used</i> by customers directly; it was primarily a tool for the internal team.) It was at this point that I realized we <i>needed</i> some kind of execution time-out: since we could encode functions, we could write down e.g. the Y combinator or the omega combinator and we could get non-terminating programs in this DSL.<p>Now I work as a programming languages researcher, so the lambda calculus has direct application to my day job.<p>Those curious might be interested in ISWIM, [1,2] which is an extension of the lambda calculus with an arbitrary set of operators. Like the lambda calculus, this is an abstract language. However, you can add numbers and other operators, and ISWIM-like languages are often used to illustrate new ideas in programming languages.<p>Syntax is incidental. Boil the syntax away from languages and reduce them to their distilled semantics to get out the <i>essential</i> differences—this is the kind of thing that the lambda calculus makes easy.<p>I highly recommend reading Landin&#x27;s <i>The Next 700 Programming Languages</i> [2] as it is a great, short, clear read.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISWIM" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISWIM</a>
[2]: <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~crary&#x2F;819-f09&#x2F;Landin66.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~crary&#x2F;819-f09&#x2F;Landin66.pdf</a></div><br/><div id="40095369" class="c"><input type="checkbox" id="c-40095369" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40093124">parent</a><span>|</span><a href="#40094811">next</a><span>|</span><label class="collapse" for="c-40095369">[-]</label><label class="expand" for="c-40095369">[1 more]</label></div><br/><div class="children"><div class="content">It appears there are a few like the opening post, e.g. <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rwh&#x2F;courses&#x2F;oplss&#x2F;tlc-semeq.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rwh&#x2F;courses&#x2F;oplss&#x2F;tlc-semeq.pdf</a>. This suggests the book will be worth the time, thank you for mentioning it.</div><br/></div></div></div></div><div id="40094811" class="c"><input type="checkbox" id="c-40094811" checked=""/><div class="controls bullet"><span class="by">renonce</span><span>|</span><a href="#40093124">prev</a><span>|</span><a href="#40093222">next</a><span>|</span><label class="collapse" for="c-40094811">[-]</label><label class="expand" for="c-40094811">[2 more]</label></div><br/><div class="children"><div class="content">One invention that drew me to this topic was Binary Lambda Calculus, invented by John Tromp (“Tromp” as in Tromp-Taylor Rules). It’s just a direct binary encoding of a lambda calculus term, but it gives you a concrete and concise representation which is useful for evaluating the complexity of an expression. I encountered it when viewing <a href="https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;questions&#x2F;6430&#x2F;shortest-terminating-program-whose-output-size-exceeds-grahams-number" rel="nofollow">https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;questions&#x2F;6430&#x2F;shortest-t...</a> and found that this language was the one that could write the most precise representation of a very large number with the fewest bits possible. I later learned that Graham’s number could be encoded in 120 bits (maybe 3~4 less), much more concise than equivalent mathematical language, and I’ve since been drawn into the field of googology. It was fascinating.</div><br/><div id="40095633" class="c"><input type="checkbox" id="c-40095633" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40094811">parent</a><span>|</span><a href="#40093222">next</a><span>|</span><label class="collapse" for="c-40095633">[-]</label><label class="expand" for="c-40095633">[1 more]</label></div><br/><div class="children"><div class="content">That Stack Exchange thread shows you can exceed Graham&#x27;s number with the 49 bit lambda term (λ 1 1) (λ 1 (1 (λ λ 1 2 (λ λ 2 (2 1))))), or graphically<p><pre><code>    ┬─┬ ┬─┬──────────
    └─┤ │ │ ──┬──────
      │ │ │ ┬─┼──────
      │ │ │ └─┤ ┬─┬──
      │ │ │   │ ┼─┼─┬
      │ │ │   │ │ ├─┘
      │ │ │   │ ├─┘
      │ │ │   ├─┘
      │ │ ├───┘
      │ ├─┘      
      └─┘        
</code></pre>
Related: <a href="https:&#x2F;&#x2F;oeis.org&#x2F;A333479" rel="nofollow">https:&#x2F;&#x2F;oeis.org&#x2F;A333479</a></div><br/></div></div></div></div><div id="40093222" class="c"><input type="checkbox" id="c-40093222" checked=""/><div class="controls bullet"><span class="by">an-allen</span><span>|</span><a href="#40094811">prev</a><span>|</span><a href="#40093230">next</a><span>|</span><label class="collapse" for="c-40093222">[-]</label><label class="expand" for="c-40093222">[4 more]</label></div><br/><div class="children"><div class="content">When I took Fundamentals of Programming Languages 20 years ago - I nearly failed the class. Lambda calculus was simply too esoteric for me to appreciate and much less understand intuitively.<p>Fast forward 20 years, and I see the fundamentals of Alonzo Church’s system in every computation problem I encounter. It’s one of those concepts that age like wine. The only other concept I put on the same level is Shannons “informational entropy” and maybe Wolfram’s Ruliad.</div><br/><div id="40094467" class="c"><input type="checkbox" id="c-40094467" checked=""/><div class="controls bullet"><span class="by">_delirium</span><span>|</span><a href="#40093222">parent</a><span>|</span><a href="#40093230">next</a><span>|</span><label class="collapse" for="c-40094467">[-]</label><label class="expand" for="c-40094467">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of interesting that the history is in the order it is. I could completely imagine it being reversed: first, 1000 programming languages are invented, then later, in an attempt to put order to this madness, and understand whether some of them are in a fundamental sense equivalent to others or not, you invent minimalist languages like Turing machines or the lambda calculus, and start developing a theory of reductions.<p>Kind of odd that the Turing machines and lambda calculus predate almost all the others! I mean there are good reasons for it, especially if you try to put yourself in a 1930s mathematics mindset (which is why it actually happened that way), but it is, I&#x27;d submit, a bit surprising to learn from a 2020s perspective if you didn&#x27;t already know it.</div><br/><div id="40095638" class="c"><input type="checkbox" id="c-40095638" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#40093222">root</a><span>|</span><a href="#40094467">parent</a><span>|</span><a href="#40095328">next</a><span>|</span><label class="collapse" for="c-40095638">[-]</label><label class="expand" for="c-40095638">[1 more]</label></div><br/><div class="children"><div class="content">Before LC there were combinators [1].<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Combinatory_logic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Combinatory_logic</a><p>These are even more primitive.</div><br/></div></div><div id="40095328" class="c"><input type="checkbox" id="c-40095328" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40093222">root</a><span>|</span><a href="#40094467">parent</a><span>|</span><a href="#40095638">prev</a><span>|</span><a href="#40093230">next</a><span>|</span><label class="collapse" for="c-40095328">[-]</label><label class="expand" for="c-40095328">[1 more]</label></div><br/><div class="children"><div class="content">Interesting thought. Perhaps we&#x27;ll discover a language that is in some way of higher order than Turing complete.</div><br/></div></div></div></div></div></div><div id="40093230" class="c"><input type="checkbox" id="c-40093230" checked=""/><div class="controls bullet"><span class="by">dexwiz</span><span>|</span><a href="#40093222">prev</a><span>|</span><label class="collapse" for="c-40093230">[-]</label><label class="expand" for="c-40093230">[19 more]</label></div><br/><div class="children"><div class="content">There has to be some programmer rite of passage involving learning lambda calculus. I went through this a few years ago when something similar was posted. I learned the notation, marveled at its dual simplicity and completeness, and and did a few exercises. But I came out the other side none the wiser. I think I was looking for some great epiphany on the nature of computation. Alas, it eluded me in the end. It was fun but ultimately useless for me.</div><br/><div id="40093715" class="c"><input type="checkbox" id="c-40093715" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40093230">parent</a><span>|</span><a href="#40094676">next</a><span>|</span><label class="collapse" for="c-40093715">[-]</label><label class="expand" for="c-40093715">[12 more]</label></div><br/><div class="children"><div class="content">I love theory, and I also really like lambda calculus, but I feel like this sentiment applies to most theory, particularly stuff after undergrad.<p>I spent a not-insignificant amount of time learning how to do proofs with Isabelle.  I learned a lot about inductive proofs, set theory, meta-logic, and challenged myself to prove a lot of the stuff I had previous taken for granted (e.g. proving that different sorts refine each other).  I enjoyed it, and similarly was convinced that this was going to be some life-changing thing that changes my career trajectory and...<p>Nothing changed.  No one in charge of companies gives a shit about theory.  They all <i>claim</i> that they love theory, they <i>claim</i> that they are very research focused, they <i>claim</i> that they value all the time you spent learning this stuff, but in reality they really just want you to change the color of buttons, or change the format of dates, or add a field to a JSON. It sometimes feels like no software engineer but me actually <i>wants</i> to learn any math, and will refuse to touch anything even resembling it.<p>And I&#x27;m not picking on Isabelle here; I&#x27;ve had similar results trying to pitch TLA+ and Coq and Agda for some of the more error-prone parts of the codebase, with different sales-pitches, and without fail the managers will <i>always</i> say that they &quot;will look into it&quot;, and promptly do absolutely nothing.  The first two times a manager said that, I believed them, but after that I realized that they&#x27;re just trying to shut me up and tell me &quot;no&quot; politely.<p>It was enough to depress me, and it still kind of does.<p>I still think learning stuff for fun is worth it, but I&#x27;d be lying if I told you if I knew why.</div><br/><div id="40094202" class="c"><input type="checkbox" id="c-40094202" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40093715">parent</a><span>|</span><a href="#40094715">next</a><span>|</span><label class="collapse" for="c-40094202">[-]</label><label class="expand" for="c-40094202">[2 more]</label></div><br/><div class="children"><div class="content">I use the deep theory experience a ton when designing software or systems. But I don&#x27;t do an actual proof hardly ever. Being able to reason about a problem and intuit the extent of what&#x27;s technologically possible to solve is insanely useful. But in most places that I work everyone around me can do that too, so we&#x27;re constantly battling program managers and C suite guys &#x2F; gals who just don&#x27;t see why everything is so slow, difficult, un-scalable, unpredictable, etc. They want a stupid thing that works half the time, and they&#x27;ll just turn the camera off the other half of the time.</div><br/><div id="40094807" class="c"><input type="checkbox" id="c-40094807" checked=""/><div class="controls bullet"><span class="by">catgary</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40094202">parent</a><span>|</span><a href="#40094715">next</a><span>|</span><label class="collapse" for="c-40094807">[-]</label><label class="expand" for="c-40094807">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I’m currently an ML scientist but I regularly run into shit where I have no clue how you’d solve the problem without having a compilers&#x2F;functional programming background.</div><br/></div></div></div></div><div id="40094715" class="c"><input type="checkbox" id="c-40094715" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40093715">parent</a><span>|</span><a href="#40094202">prev</a><span>|</span><a href="#40094099">next</a><span>|</span><label class="collapse" for="c-40094715">[-]</label><label class="expand" for="c-40094715">[3 more]</label></div><br/><div class="children"><div class="content">I did a lot of math before I began learning programming. This was my experience:<p>Recursion? Oh you mean proof by induction?<p>Cryptography? Oh you mean number theory?<p>Neural networks? Oh you mean calculus?<p>Almost everything I learn while programming can be associated with some theory I learnt before for math.</div><br/><div id="40095537" class="c"><input type="checkbox" id="c-40095537" checked=""/><div class="controls bullet"><span class="by">yobbo</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40094715">parent</a><span>|</span><a href="#40094936">next</a><span>|</span><label class="collapse" for="c-40095537">[-]</label><label class="expand" for="c-40095537">[1 more]</label></div><br/><div class="children"><div class="content">Those things are not equivalent.<p>But schools typically teach these things as a &quot;theory part&quot; and as &quot;practice&#x2F;application part&quot; (for example by &quot;syncing&#x2F;sequencing&quot; courses if possible) which helps with both relevance and &quot;getting it&quot;.</div><br/></div></div><div id="40094936" class="c"><input type="checkbox" id="c-40094936" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40094715">parent</a><span>|</span><a href="#40095537">prev</a><span>|</span><a href="#40094099">next</a><span>|</span><label class="collapse" for="c-40094936">[-]</label><label class="expand" for="c-40094936">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kind of what annoys me though; it&#x27;s almost like the <i>word</i> &quot;math&quot; is toxic to people. When I try explaining a correspondence between something that they&#x27;re doing via code, and how maybe learning a bit of the mathematics behind it might be useful, people kind of just roll their eyes, acting like I asked them to go get three PhDs, and acting like it&#x27;s just one of those weird &quot;Tombert things&quot;.<p>I don&#x27;t know anything about neural networks yet (though I really need to get on that), but I have noticed the other two examples you mentioned as well; recursion is more or less applied inductive proofs, a lot of crypto boils to number theory.<p>My dream is to some day convince a manager to give me budget to spend a few weeks designing a new system and proving correctness with TLA+.  I&#x27;m not saying it&#x27;s terribly likely, but a man can dream.</div><br/></div></div></div></div><div id="40094099" class="c"><input type="checkbox" id="c-40094099" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40093715">parent</a><span>|</span><a href="#40094715">prev</a><span>|</span><a href="#40093832">next</a><span>|</span><label class="collapse" for="c-40094099">[-]</label><label class="expand" for="c-40094099">[1 more]</label></div><br/><div class="children"><div class="content">But now you can write your own json parser</div><br/></div></div><div id="40093832" class="c"><input type="checkbox" id="c-40093832" checked=""/><div class="controls bullet"><span class="by">hnoyrnndd</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40093715">parent</a><span>|</span><a href="#40094099">prev</a><span>|</span><a href="#40094676">next</a><span>|</span><label class="collapse" for="c-40093832">[-]</label><label class="expand" for="c-40093832">[5 more]</label></div><br/><div class="children"><div class="content">A friend of mine worked at Rockwell Collins and wrote proofs, and theorem provers, all day.<p>If you work on webshit like me you won’t get to use these skills much.<p>(On the other hand, recursing over the structure of JSON-like data often feels like 80% of the job, so I think the skills come into play at least a tiny bit).</div><br/><div id="40093874" class="c"><input type="checkbox" id="c-40093874" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40093832">parent</a><span>|</span><a href="#40094676">next</a><span>|</span><label class="collapse" for="c-40093874">[-]</label><label class="expand" for="c-40093874">[4 more]</label></div><br/><div class="children"><div class="content">I work on web-adjacent-shit, mostly data processing stuff in Kafka that eventually ends up on the web.<p>I don&#x27;t get to recurse over JSON, occasionally I get to design a system from scratch and that&#x27;s more fun, but it&#x27;s usually not more complicated than &quot;draw boxes that point to other boxes and&#x2F;or cylinders on screen&quot;. Sometimes I draw a picture of cloud.<p>I like my job just fine, it&#x27;s a decent job, and I like my managers and coworkers as well, but it&#x27;s just disappointing that enthusiasm for math and theory is what got me to this stage of my career, but I never really got to use it, and I don&#x27;t see that ever really changing for me.<p>Maybe I will write a paper at some point at least.</div><br/><div id="40095305" class="c"><input type="checkbox" id="c-40095305" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40093874">parent</a><span>|</span><a href="#40094676">next</a><span>|</span><label class="collapse" for="c-40095305">[-]</label><label class="expand" for="c-40095305">[3 more]</label></div><br/><div class="children"><div class="content">Yeah I am at the same place. Considering going for a phd because at this point I cant muster any kind of interest in corporate tech.</div><br/><div id="40095405" class="c"><input type="checkbox" id="c-40095405" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40095305">parent</a><span>|</span><a href="#40094676">next</a><span>|</span><label class="collapse" for="c-40095405">[-]</label><label class="expand" for="c-40095405">[2 more]</label></div><br/><div class="children"><div class="content">From experience, that has its own share of frustrations as well. You get to work in theory and that’s fun, but if you decide to do a PhD while also working a desk job, I recommend you <i>do not</i> tell your employers.<p>I made the mistake of telling an employer, and whenever I made any mistake in my work, no matter how small,  the employer would immediately say that the PhD work is distracting me, and my focus not BigCo.<p>My PhD is on an indefinite hiatus right now, because it’s something I am questioning the utility of right now.</div><br/><div id="40095541" class="c"><input type="checkbox" id="c-40095541" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40095405">parent</a><span>|</span><a href="#40094676">next</a><span>|</span><label class="collapse" for="c-40095541">[-]</label><label class="expand" for="c-40095541">[1 more]</label></div><br/><div class="children"><div class="content">That sucks. I cant imagine trying to work a job and do a phd at the dame time. That would take out any joy of it for me.<p>I can definitely see a lot of utility depending on what you do research in. I bet a lot of ML doctoretes are making big bucks, but that&#x27;s relatively niche.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40094676" class="c"><input type="checkbox" id="c-40094676" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#40093230">parent</a><span>|</span><a href="#40093715">prev</a><span>|</span><a href="#40094309">next</a><span>|</span><label class="collapse" for="c-40094676">[-]</label><label class="expand" for="c-40094676">[4 more]</label></div><br/><div class="children"><div class="content">The &quot;utility&quot; of the lambda calculus, in my opinion, comes down to Church&#x27;s original choice of terminology. He did not call the things denoted by lambda &quot;functions&quot;; rather, they were <i>abstractions</i>. What makes the lambda calculus so cool is that it lets us see that abstraction is the root of all computation, at least through one perspective (as opposed to the Turing point of view). Learning the lambda calculus directly will allow you to appreciate functions (&quot;abstractions&quot;) and use them more effectively; you can reason about their computation and composition.</div><br/><div id="40095271" class="c"><input type="checkbox" id="c-40095271" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40094676">parent</a><span>|</span><a href="#40094309">next</a><span>|</span><label class="collapse" for="c-40095271">[-]</label><label class="expand" for="c-40095271">[3 more]</label></div><br/><div class="children"><div class="content">I dont quite think of functions and abstractions as the same. Abstractions seem to do more with having a self referential property. Though I suppose that can be seen as the identity function f-&gt;f.<p>IIRC Church was heavily influenced by Turing and vice versa.</div><br/><div id="40095492" class="c"><input type="checkbox" id="c-40095492" checked=""/><div class="controls bullet"><span class="by">dexwiz</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40095271">parent</a><span>|</span><a href="#40094309">next</a><span>|</span><label class="collapse" for="c-40095492">[-]</label><label class="expand" for="c-40095492">[2 more]</label></div><br/><div class="children"><div class="content">Turning was Church’s student.</div><br/><div id="40095678" class="c"><input type="checkbox" id="c-40095678" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40093230">root</a><span>|</span><a href="#40095492">parent</a><span>|</span><a href="#40094309">next</a><span>|</span><label class="collapse" for="c-40095678">[-]</label><label class="expand" for="c-40095678">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s amazing how often Turing gets miss-spelled as Turning. Is that because of overzealous spell checkers?</div><br/></div></div></div></div></div></div></div></div><div id="40094309" class="c"><input type="checkbox" id="c-40094309" checked=""/><div class="controls bullet"><span class="by">mjh2539</span><span>|</span><a href="#40093230">parent</a><span>|</span><a href="#40094676">prev</a><span>|</span><a href="#40093514">next</a><span>|</span><label class="collapse" for="c-40094309">[-]</label><label class="expand" for="c-40094309">[1 more]</label></div><br/><div class="children"><div class="content">I used it in a graduate course on formal semantics (<a href="https:&#x2F;&#x2F;www.wiley.com&#x2F;en-us&#x2F;Semantics+in+Generative+Grammar-p-9780631197133);" rel="nofollow">https:&#x2F;&#x2F;www.wiley.com&#x2F;en-us&#x2F;Semantics+in+Generative+Grammar-...</a> after I graduated I wanted to learn how to program so I googled &quot;lambda calculus programming language&quot; and found Haskell. That was ten years ago. Though I rarely use Haskell anymore, the lambda calculus still holds a special place.</div><br/></div></div><div id="40093514" class="c"><input type="checkbox" id="c-40093514" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#40093230">parent</a><span>|</span><a href="#40094309">prev</a><span>|</span><label class="collapse" for="c-40093514">[-]</label><label class="expand" for="c-40093514">[1 more]</label></div><br/><div class="children"><div class="content">You will probably be wanting unlambda then. an implementation of the lambda calculus without the lambda forms.<p><a href="http:&#x2F;&#x2F;www.madore.org&#x2F;~david&#x2F;programs&#x2F;unlambda&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.madore.org&#x2F;~david&#x2F;programs&#x2F;unlambda&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>