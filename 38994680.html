<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705309267003" as="style"/><link rel="stylesheet" href="styles.css?v=1705309267003"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thechipletter.substack.com/p/leaving-arizona">Leaving Arizona – the Story of the Motorola 6800 part 2 and creation of the 6502</a> <span class="domain">(<a href="https://thechipletter.substack.com">thechipletter.substack.com</a>)</span></div><div class="subtext"><span>zdw</span> | <span>21 comments</span></div><br/><div><div id="38998719" class="c"><input type="checkbox" id="c-38998719" checked=""/><div class="controls bullet"><span class="by">PeterStuer</span><span>|</span><a href="#38996496">next</a><span>|</span><label class="collapse" for="c-38998719">[-]</label><label class="expand" for="c-38998719">[1 more]</label></div><br/><div class="children"><div class="content">I had both a Z80 (Sinclair Spectrum) and a 6502 (Commodore 64) machine.<p>For programming, the Z80 was by far the more elegant instruction set.<p>In the next generation, I conciderd the Motorolla 68000 to be the &#x27;feels good&#x27; successor of the Z80, and Intel&#x27;s 8086 the &#x27;chaotic mess&#x27; heir of the 6502.</div><br/></div></div><div id="38996496" class="c"><input type="checkbox" id="c-38996496" checked=""/><div class="controls bullet"><span class="by">Scubabear68</span><span>|</span><a href="#38998719">prev</a><span>|</span><a href="#38997654">next</a><span>|</span><label class="collapse" for="c-38996496">[-]</label><label class="expand" for="c-38996496">[8 more]</label></div><br/><div class="children"><div class="content">My memory is dim on this (having last done 6502 assembly almost 40 years ago), but the extreme lack of registers on the 6502 meant many programs were a tedious, endless parade of lda, sta instructions.</div><br/><div id="38997620" class="c"><input type="checkbox" id="c-38997620" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#38996496">parent</a><span>|</span><a href="#38998526">next</a><span>|</span><label class="collapse" for="c-38997620">[-]</label><label class="expand" for="c-38997620">[2 more]</label></div><br/><div class="children"><div class="content">I think of it as having a nice set of 256 “registers”, in the zero page at addresses 0-255. I think of the A register as kind of an intermediate location for data that is going from memory to the ALU or the ALU to memory. The article says as much:<p>&gt; In effect the 6502’s ‘page zero’ in memory provides a large number of ‘pseudo’ 8 and 16-bit registers, slower than real registers, but still faster and more versatile than having to use other parts of memory. A skilled programmer making effective use of ‘page zero’ could write code that was fast when compared to other 8-bit designs.<p>I haven’t done a lot of 6502, though. I learned Basic on the Apple II when I was young but moved to Think Pascal, HyperCard, and CodeWarrior on the Mac.</div><br/><div id="38998410" class="c"><input type="checkbox" id="c-38998410" checked=""/><div class="controls bullet"><span class="by">bogantech</span><span>|</span><a href="#38996496">root</a><span>|</span><a href="#38997620">parent</a><span>|</span><a href="#38998526">next</a><span>|</span><label class="collapse" for="c-38998410">[-]</label><label class="expand" for="c-38998410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think of it as having a nice set of 256 “registers”, in the zero page at addresses 0-255.<p>It becomes a pain making sure the monitor&#x2F;bios and any programs don&#x27;t stomp on each others zero page locations though.<p>Then if you start daydreaming about multitasking you have to worry about shoveling the contents off somewhere else whenever you switch tasks.<p>The 65816 at least can relocate zero page &amp; the stack but if you&#x27;re going 16 bit you&#x27;re better off going M68K</div><br/></div></div></div></div><div id="38998526" class="c"><input type="checkbox" id="c-38998526" checked=""/><div class="controls bullet"><span class="by">artemonster</span><span>|</span><a href="#38996496">parent</a><span>|</span><a href="#38997620">prev</a><span>|</span><a href="#38997064">next</a><span>|</span><label class="collapse" for="c-38998526">[-]</label><label class="expand" for="c-38998526">[1 more]</label></div><br/><div class="children"><div class="content">I loved the simplicity of it. This was my first assembly that I have learned (at 15) and I had SO MUCH FUN with it. Maybe this is &quot;first love&quot; bias, but nothing else compared with the fun factor later on (AVR, PIC, X86, RISC-V)</div><br/></div></div><div id="38997064" class="c"><input type="checkbox" id="c-38997064" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#38996496">parent</a><span>|</span><a href="#38998526">prev</a><span>|</span><a href="#38997007">next</a><span>|</span><label class="collapse" for="c-38997064">[-]</label><label class="expand" for="c-38997064">[2 more]</label></div><br/><div class="children"><div class="content">Not only that, but X and Y registers were slightly different too. You could use one for indexing in a certain way, but not the other (it&#x27;s been 30 years for me, but still the memory is hazy).<p>There were no 16-bit registers a la Z80 either.</div><br/><div id="38997641" class="c"><input type="checkbox" id="c-38997641" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#38996496">root</a><span>|</span><a href="#38997064">parent</a><span>|</span><a href="#38997007">next</a><span>|</span><label class="collapse" for="c-38997641">[-]</label><label class="expand" for="c-38997641">[1 more]</label></div><br/><div class="children"><div class="content">The main difference between X and Y is in the indirect addressing modes.<p>You can use X as an index when you are looping through an array of pointers.<p>You can use Y as an index when you are looping through an array, where you have a pointer to the beginning of that array.<p>There are also a couple operations that always use X as a source or destination. There’s TXS&#x2F;TSX, but no TYS&#x2F;TSY.<p><a href="https:&#x2F;&#x2F;www.masswerk.at&#x2F;6502&#x2F;6502_instruction_set.html" rel="nofollow">https:&#x2F;&#x2F;www.masswerk.at&#x2F;6502&#x2F;6502_instruction_set.html</a></div><br/></div></div></div></div><div id="38997007" class="c"><input type="checkbox" id="c-38997007" checked=""/><div class="controls bullet"><span class="by">pstuart</span><span>|</span><a href="#38996496">parent</a><span>|</span><a href="#38997064">prev</a><span>|</span><a href="#38997654">next</a><span>|</span><label class="collapse" for="c-38997007">[-]</label><label class="expand" for="c-38997007">[2 more]</label></div><br/><div class="children"><div class="content">It was the first CPU I learned assembly on, also 40 years ago ;-) Yes, the constrained registers made things challenging but I have positive memories about the experience.<p>I was introduced to Chuck Peddle ~20 years ago at a friend&#x27;s wedding and got a chance to talk with him (it was kind of like meeting a rock star for me). What stuck with me was him recounting that his travels to Sri Lanka for a business there convinced him that the bustling cities in south east asia were breeding grounds for a pending viral disaster that would cover the globe thanks to advances in air travel.<p>When Covid came along I felt like he was somewhat validated but fortunately not to the degree he had forecasted.</div><br/><div id="38998239" class="c"><input type="checkbox" id="c-38998239" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38996496">root</a><span>|</span><a href="#38997007">parent</a><span>|</span><a href="#38997654">next</a><span>|</span><label class="collapse" for="c-38998239">[-]</label><label class="expand" for="c-38998239">[1 more]</label></div><br/><div class="children"><div class="content">Well, for all we know, Covid came out of China and did not hit South East Asia any harder than any other region.  (Even more so, if you control for wealth, I guess?)</div><br/></div></div></div></div></div></div><div id="38997654" class="c"><input type="checkbox" id="c-38997654" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#38996496">prev</a><span>|</span><a href="#38997215">next</a><span>|</span><label class="collapse" for="c-38997654">[-]</label><label class="expand" for="c-38997654">[10 more]</label></div><br/><div class="children"><div class="content">To me, The 6502 kind of represented best-of-breed but a bit of a dead end. I couldn&#x27;t see a 16-32 bit story. It&#x27;s like it hit the spot, and stopped growing.<p>The 6800 begat the 68000.  It had virtual memory management. That launched ten or more models of workstation and hit the magic &#x27;3M&#x27; window: a MIP, a Megabyte of memory and a Million pixels. 68000 led to SPARC because Sun decided to go into the RISC business itself.<p>I used Motorola workstations alongside Sun, for a Cray-1 project I was on the periphery of: they were the ones Cray shipped to us, passing the Cray-1 on from another customer (Boeing) and they were fine, if remarkably (physically) large machines. Like they&#x27;d got the idea of &quot;this is a workstation&quot; in the Microvax era, and never quite shrunk down.<p>I had a 6502 box (the Acorn Atom, a precursor to the BBC micro) and I used others, But I kind of wished the 6800&#x2F;0 series had been bigger, and we&#x27;d been in that world more than Intel. it was nicer. it felt nicer. It felt like an instruction set Gordon Bell would have liked. It made sense if you came from a pdp-11.<p>Maybe I&#x27;m addicted to network byte order computers.</div><br/><div id="38998436" class="c"><input type="checkbox" id="c-38998436" checked=""/><div class="controls bullet"><span class="by">repelsteeltje</span><span>|</span><a href="#38997654">parent</a><span>|</span><a href="#38997867">next</a><span>|</span><label class="collapse" for="c-38998436">[-]</label><label class="expand" for="c-38998436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s like [6502] hit the spot, and stopped growing.<p>Indeed. In fact, Acorn played around with a couple of successor candidates like national semiconductor 32016 (and even Intel 80186) using the BBC micro&#x27;s Tube interface before they finally have up and developed the ARM chip.<p>In a sense, ARM (initially <i>Acorn</i> RISC machine) is &quot;the true&quot; 6502 successor. Having done assembly on both BASIC II and V (on Archimedes) the legacy in arm2 Isa was quite evident.</div><br/></div></div><div id="38997867" class="c"><input type="checkbox" id="c-38997867" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#38997654">parent</a><span>|</span><a href="#38998436">prev</a><span>|</span><a href="#38997685">next</a><span>|</span><label class="collapse" for="c-38997867">[-]</label><label class="expand" for="c-38997867">[5 more]</label></div><br/><div class="children"><div class="content">i really don&#x27;t think the 6800 begat the 68000 - they have almost nothing in common, architecture-wise. on the other hand, the intel 8080 certainly connected to the 8086 and in fact a lot of 8086 programs were mechanically translated, at least in part, from the 8080 (and z80).</div><br/><div id="38998711" class="c"><input type="checkbox" id="c-38998711" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#38997654">root</a><span>|</span><a href="#38997867">parent</a><span>|</span><a href="#38997909">next</a><span>|</span><label class="collapse" for="c-38998711">[-]</label><label class="expand" for="c-38998711">[1 more]</label></div><br/><div class="children"><div class="content">They actually have many details in common, including some suboptimal choices, like the handling of the flags, but those are not due to 68000 being derived from 6800, as there was no such direct connection, but due to the fact that both the 6800 and the 68000 ISAs have been strongly influenced by the DEC PDP-11, which was the most popular minicomputer during the seventies.</div><br/></div></div><div id="38997909" class="c"><input type="checkbox" id="c-38997909" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#38997654">root</a><span>|</span><a href="#38997867">parent</a><span>|</span><a href="#38998711">prev</a><span>|</span><a href="#38997685">next</a><span>|</span><label class="collapse" for="c-38997909">[-]</label><label class="expand" for="c-38997909">[3 more]</label></div><br/><div class="children"><div class="content">Look I get this, its not like one is backwards compatible to the other. But the 68000 exists because Motorola were invested in the 6800 and saw a path onward, albiet leapfrogging to 32 bits, and deliberately not doing backwards compat ISA.<p>Intel and Zilog took another path. Their path in some ways, was the wiser course because IBM jumped on the Intel model and .. here we are. Zilog couldn&#x27;t make it work as well for them as Intel did.</div><br/><div id="38998170" class="c"><input type="checkbox" id="c-38998170" checked=""/><div class="controls bullet"><span class="by">Tor3</span><span>|</span><a href="#38997654">root</a><span>|</span><a href="#38997909">parent</a><span>|</span><a href="#38997685">next</a><span>|</span><label class="collapse" for="c-38998170">[-]</label><label class="expand" for="c-38998170">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really get that. The 6800 begat the 6809, and that was the connection to the 6800. When Motorola made the 68000 they decided to begin with a clean slate, there&#x27;s really nothing in connection with the 6800 except the numbering scheme and both being big endian.  If you want to use the word &#x27;begat&#x27; then it fits Intel much more. Intel made the 8086, and Mensch made the 65816, both went for backwards compatibility (source or architecture) to some extent (which gave us segments and other negative artifacts).<p>So yes we agree on the facts, it&#x27;s just so strange that you in your previous post said that the &quot;6800 begat the 68000&quot; - if anything, it didn&#x27;t. All the companies went ahead with 16- and &#x2F; or 32-bit CPUs, the difference is that Motorola broke away from their 8-bit past while doing so.</div><br/><div id="38998208" class="c"><input type="checkbox" id="c-38998208" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38997654">root</a><span>|</span><a href="#38998170">parent</a><span>|</span><a href="#38997685">next</a><span>|</span><label class="collapse" for="c-38998208">[-]</label><label class="expand" for="c-38998208">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the difference is that Motorola broke away from their 8-bit past while doing so.<p>And then they did it again with the PowerPC (and the 88000 prior to that) which had very little in common with the 68k.</div><br/></div></div></div></div></div></div></div></div><div id="38997685" class="c"><input type="checkbox" id="c-38997685" checked=""/><div class="controls bullet"><span class="by">classichasclass</span><span>|</span><a href="#38997654">parent</a><span>|</span><a href="#38997867">prev</a><span>|</span><a href="#38997883">next</a><span>|</span><label class="collapse" for="c-38997685">[-]</label><label class="expand" for="c-38997685">[2 more]</label></div><br/><div class="children"><div class="content">Oh, I bet you&#x27;d have loved the TMS 9900. Tons of registers with switchable windows, mini-computer oriented ... and big-endian.</div><br/><div id="38997721" class="c"><input type="checkbox" id="c-38997721" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#38997654">root</a><span>|</span><a href="#38997685">parent</a><span>|</span><a href="#38997883">next</a><span>|</span><label class="collapse" for="c-38997721">[-]</label><label class="expand" for="c-38997721">[1 more]</label></div><br/><div class="children"><div class="content">Looks good, but from a business perspective, another dead end -What I read says TI decided to get out of the general CPU business. Probably it means they couldn&#x27;t find somebody interested in buying into this ISA and chipset to sustain their investment in developing it, where they had solid business in the other specialised spaces.<p>Yes, heaps of registers which map into the address space means (I am guessing) simple C compiler and Unix porting, once virtual memory is there. I wonder why nobody ran with it?</div><br/></div></div></div></div><div id="38997883" class="c"><input type="checkbox" id="c-38997883" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#38997654">parent</a><span>|</span><a href="#38997685">prev</a><span>|</span><a href="#38997215">next</a><span>|</span><label class="collapse" for="c-38997883">[-]</label><label class="expand" for="c-38997883">[1 more]</label></div><br/><div class="children"><div class="content">I wonder what might have been if MOS had shipped a 16-bit 6502 in 1980 instead of WDC shipping one in 1985.</div><br/></div></div></div></div><div id="38997215" class="c"><input type="checkbox" id="c-38997215" checked=""/><div class="controls bullet"><span class="by">FullyFunctional</span><span>|</span><a href="#38997654">prev</a><span>|</span><label class="collapse" for="c-38997215">[-]</label><label class="expand" for="c-38997215">[1 more]</label></div><br/><div class="children"><div class="content">I like this story as it goes a long way to explain why the 6502 is the way it is.  Having grown up with both Z80 and 6502 essentially in parallel, I&#x27;ll be the contrarian who never liked either, but will admit that it would have been hard to do better than 6502 did in the given area constraints.  (Z80 however could have done so much better - the 128+ bits of architectural state could have been used far better and even have allowed a 16-bit architecture).</div><br/></div></div></div></div></div></div></div></body></html>