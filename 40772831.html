<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719392515377" as="style"/><link rel="stylesheet" href="styles.css?v=1719392515377"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://reasonableapproximation.net/2019/05/05/hindley-milner.html">A reckless introduction to Hindley-Milner type inference (2019)</a> <span class="domain">(<a href="https://reasonableapproximation.net">reasonableapproximation.net</a>)</span></div><div class="subtext"><span>nequo</span> | <span>39 comments</span></div><br/><div><div id="40789756" class="c"><input type="checkbox" id="c-40789756" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40792904">next</a><span>|</span><label class="collapse" for="c-40789756">[-]</label><label class="expand" for="c-40789756">[18 more]</label></div><br/><div class="children"><div class="content">I think this article would be better if it ignored the issue of proving termination.<p>Proving that a program terminates <i>eventually</i> is a very weak guarantee, since it could be a program that terminates after a million years. This matters mostly for proof languages, where it’s useful to write proofs about functions that you <i>never run.</i> If the function provably terminates, you can assume that whatever value it returns exists, without calculating it.<p>For a possibly long-running job like a SQL query, a static guarantee that it terminates eventually is almost certainly not what you want. You’re going to need to test its performance, and ideally have a timeout and a way of handling the timeout. If you want to get fancy, a progress bar and cancel button might be nice.<p>Edit:<p>Compilers need to run fast for the programs we actually write. A type system that possibly doesn’t terminate under unusual conditions isn’t that big a deal, as long as people don’t write code like that. Hopefully you get a decent error message.<p>Compare with memory use. We don’t want compilers to use excessive amounts of memory, but don’t need static guarantees about memory use.</div><br/><div id="40794944" class="c"><input type="checkbox" id="c-40794944" checked=""/><div class="controls bullet"><span class="by">philh</span><span>|</span><a href="#40789756">parent</a><span>|</span><a href="#40790211">next</a><span>|</span><label class="collapse" for="c-40794944">[-]</label><label class="expand" for="c-40794944">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t necessarily disagree. But I do think there&#x27;s something to be said for knowing that my sql query is &quot;just&quot; slow, not trapped in an infinite loop. Not confident, but I feel like debugging &quot;why is this query so slow that it hasn&#x27;t returned yet&quot; seems easier than debugging &quot;why has this slow-or-maybe-nonterminating query not returned yet&quot;.</div><br/></div></div><div id="40790211" class="c"><input type="checkbox" id="c-40790211" checked=""/><div class="controls bullet"><span class="by">dmkolobov</span><span>|</span><a href="#40789756">parent</a><span>|</span><a href="#40794944">prev</a><span>|</span><a href="#40791041">next</a><span>|</span><label class="collapse" for="c-40790211">[-]</label><label class="expand" for="c-40790211">[4 more]</label></div><br/><div class="children"><div class="content">The problem with “not writing code like that” is that eventually someone does.<p>At work we use a home-grown Haskell-like language with “row types” which can be split into disjoint sets of fields in order to represent joins and the like.<p>It works well in most cases, but it’s very easy to forget a type annotation and trigger unmanageable build-times. Often times, it is not obvious where something needs to be annotated. Sure, we can act as human time-outs, but the productivity loss can be substantial, especially for a newcomer to the language.</div><br/><div id="40790329" class="c"><input type="checkbox" id="c-40790329" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40790211">parent</a><span>|</span><a href="#40790477">next</a><span>|</span><label class="collapse" for="c-40790329">[-]</label><label class="expand" for="c-40790329">[2 more]</label></div><br/><div class="children"><div class="content">The solution to &quot;eventually someone does&quot; is &quot;add a timeout, and when you hit that timeout give them an error so they can fix their code&quot;.<p>There&#x27;s no practical difference between exponential and infinite time, you need to do this for bad exponential time cases anyways.<p>Many langauges type systems (Java, Typescript, C++, Rust, ...) really <i>aren&#x27;t</i> guaranteed to terminate in the absence of a timeout either. They&#x27;re (the type systems) turing complete, you can write infinite loops that the compiler can&#x27;t know are infinite loops. This makes no practical difference relative to languages which &quot;merely&quot; have exponential time type systems, because with an exponential time type system you&#x27;re alread accepting the risk that typechecking might not terminate before the heat death of the universe.</div><br/><div id="40790482" class="c"><input type="checkbox" id="c-40790482" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40790329">parent</a><span>|</span><a href="#40790477">next</a><span>|</span><label class="collapse" for="c-40790482">[-]</label><label class="expand" for="c-40790482">[1 more]</label></div><br/><div class="children"><div class="content">A timeout (or recursion&#x2F;expansion depth limit) could be useful to give the human some specifics about what went wrong.  But humans generally kill compilations that take much longer than usual.  If it took 20 seconds before, and now it&#x27;s run for 10 minutes and hasn&#x27;t finished, I&#x27;m probably going to control-C it (or whatever), and then diff against the previous code to try to figure out what went wrong.</div><br/></div></div></div></div><div id="40790477" class="c"><input type="checkbox" id="c-40790477" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40790211">parent</a><span>|</span><a href="#40790329">prev</a><span>|</span><a href="#40791041">next</a><span>|</span><label class="collapse" for="c-40790477">[-]</label><label class="expand" for="c-40790477">[1 more]</label></div><br/><div class="children"><div class="content">Yes, making it possible to reason locally about compiler performance can be pretty helpful. It’s one reason I like to have type declarations for public API’s. Also, hitting an implementation-defined limit (that you can raise) for unreasonable constructs might result in better errors than just continuing to run, but slowly.<p>A termination guarantee for type checking doesn’t really help.</div><br/></div></div></div></div><div id="40791041" class="c"><input type="checkbox" id="c-40791041" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#40789756">parent</a><span>|</span><a href="#40790211">prev</a><span>|</span><a href="#40790475">next</a><span>|</span><label class="collapse" for="c-40791041">[-]</label><label class="expand" for="c-40791041">[6 more]</label></div><br/><div class="children"><div class="content">I second this, for programs to terminate <i>eventually</i>, is not a good goal to pursue. In practice if you need termination, you will need bounded termination, which solves your eventual termination problem completely.<p>I don&#x27;t understand why people talk so much about eventual termination.</div><br/><div id="40791557" class="c"><input type="checkbox" id="c-40791557" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40791041">parent</a><span>|</span><a href="#40791617">next</a><span>|</span><label class="collapse" for="c-40791557">[-]</label><label class="expand" for="c-40791557">[4 more]</label></div><br/><div class="children"><div class="content">Think of it not like proofs but like tests, i.e. it catches bad stuff.<p>Having static types is a low cost solution that catches a lot of possible bugs.  Purity catches another bunch of bugs.  No-nulls catches even more.  At this point you can kinda start trusting function names and type signatures to do what they say on the box (often said about Haskell).  Likewise, if it compiles, it probably does the right thing.<p>So where&#x27;s the next gap in Haskell that lets bugs through?  I&#x27;d argue that (eventual) termination would be that next step.  If you say a function has type a-&gt;a (for all a), it only admits one possible implementation... except for bad ones, like &#x27;undefined&#x27; or an infinite recursion - both of which termination would catch for you.</div><br/><div id="40793385" class="c"><input type="checkbox" id="c-40793385" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40791557">parent</a><span>|</span><a href="#40791617">next</a><span>|</span><label class="collapse" for="c-40793385">[-]</label><label class="expand" for="c-40793385">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  If you say a function has type a-&gt;a (for all a), it only admits one possible implementation... except for bad ones, like &#x27;undefined&#x27; or an infinite recursion - both of which termination would catch for you.<p>To be super-pedantic, it only admits one possible denotation, assuming termination. There are an infinite number of implementations that waste finite time on something useless before returning the argument. We usually don&#x27;t talk about those, because... Why would you write code that does that? But it&#x27;s worth keeping in mind as an edge case in this sort of discussion.</div><br/><div id="40797344" class="c"><input type="checkbox" id="c-40797344" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40793385">parent</a><span>|</span><a href="#40796260">next</a><span>|</span><label class="collapse" for="c-40797344">[-]</label><label class="expand" for="c-40797344">[1 more]</label></div><br/><div class="children"><div class="content">Are there any examples of such a function (a-&gt;a) which <i>will eventually terminate</i>, but <i>cannot</i> be optimised away at compile-time?</div><br/></div></div><div id="40796260" class="c"><input type="checkbox" id="c-40796260" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40793385">parent</a><span>|</span><a href="#40797344">prev</a><span>|</span><a href="#40791617">next</a><span>|</span><label class="collapse" for="c-40796260">[-]</label><label class="expand" for="c-40796260">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some useful cousins to the sleep() function in that family.</div><br/></div></div></div></div></div></div><div id="40791617" class="c"><input type="checkbox" id="c-40791617" checked=""/><div class="controls bullet"><span class="by">shiandow</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40791041">parent</a><span>|</span><a href="#40791557">prev</a><span>|</span><a href="#40790475">next</a><span>|</span><label class="collapse" for="c-40791617">[-]</label><label class="expand" for="c-40791617">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very easy to write programs solving some unsolvable problem that don&#x27;t terminate.</div><br/></div></div></div></div><div id="40790475" class="c"><input type="checkbox" id="c-40790475" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40789756">parent</a><span>|</span><a href="#40791041">prev</a><span>|</span><a href="#40793379">next</a><span>|</span><label class="collapse" for="c-40790475">[-]</label><label class="expand" for="c-40790475">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Proving that a program terminates eventually is a very weak guarantee, since it could be a program that terminates after a million years. This matters mostly for proof languages, where it’s useful to write proofs about functions that you never run. If the function provably terminates, you can assume that whatever value it returns exists, without calculating it.</i><p>In practical algorithms of significance, we can often do much better than this, proving both termination, and the time complexity of that termination. For instance, a DFA of a regular language will terminate in O(n) of the length of the haystack, and we also have a bound for the time it takes to construct that DFA.<p>Sometimes, as you&#x27;re alluding to, we know something terminates, but the time complexity is impractical: exhaustive naïve search for Traveling Salesman will, in principle, halt.  This is, itself, useful information.<p>The article claims (I believe correctly) not just that H-M inference halts, but that it does so in &quot;near-linear&quot; time. That&#x27;s a much tighter bound than merely proving termination.</div><br/><div id="40791012" class="c"><input type="checkbox" id="c-40791012" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40790475">parent</a><span>|</span><a href="#40791055">next</a><span>|</span><label class="collapse" for="c-40791012">[-]</label><label class="expand" for="c-40791012">[1 more]</label></div><br/><div class="children"><div class="content">Complexity sometimes is still too little, because the constants can overwhelm your O(n) for all n that you care about in practice. Or rather, complexity can&#x27;t help you to select between two competing O(n) algorithms<p>However, without a precise cost model of your operations (say, you just know each operation has a bounded time and such they are each O(1 ) but nothing beyond that), that&#x27;s often the best you can do<p>There&#x27;s something called resource aware computation that can do more finer grained bounds on the runtime and memory usage of functions (and other resource usage like stack space so you can prove you always use less than 8MB or whatever number) not only complexity but also the constants. With the right cost model you <i>could</i> model CPU and memory latencies and other things like CPU port usage, cache usage etc, but there&#x27;s an interplay with the optimizer here (this could even be used to spot performance regressions of compiler codegen even without running any benchmark)</div><br/></div></div><div id="40791055" class="c"><input type="checkbox" id="c-40791055" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40790475">parent</a><span>|</span><a href="#40791012">prev</a><span>|</span><a href="#40790497">next</a><span>|</span><label class="collapse" for="c-40791055">[-]</label><label class="expand" for="c-40791055">[1 more]</label></div><br/><div class="children"><div class="content">If &quot;near-linear&quot; time was a bound it would be, but it&#x27;s not. HM type inference is exptime-complete. Near-linear here is just &quot;most programs people actually write type check in something close to linear time&quot;.</div><br/></div></div><div id="40790497" class="c"><input type="checkbox" id="c-40790497" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40789756">root</a><span>|</span><a href="#40790475">parent</a><span>|</span><a href="#40791055">prev</a><span>|</span><a href="#40793379">next</a><span>|</span><label class="collapse" for="c-40790497">[-]</label><label class="expand" for="c-40790497">[1 more]</label></div><br/><div class="children"><div class="content">Yes, agreed.</div><br/></div></div></div></div><div id="40793379" class="c"><input type="checkbox" id="c-40793379" checked=""/><div class="controls bullet"><span class="by">marssaxman</span><span>|</span><a href="#40789756">parent</a><span>|</span><a href="#40790475">prev</a><span>|</span><a href="#40790038">next</a><span>|</span><label class="collapse" for="c-40793379">[-]</label><label class="expand" for="c-40793379">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think this article would be better if it ignored the issue of proving termination.<p>I agree; that part went on so long that I got bored and stopped reading before the article actually got around to saying anything about type inference.</div><br/></div></div></div></div><div id="40792904" class="c"><input type="checkbox" id="c-40792904" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#40789756">prev</a><span>|</span><a href="#40790325">next</a><span>|</span><label class="collapse" for="c-40792904">[-]</label><label class="expand" for="c-40792904">[1 more]</label></div><br/><div class="children"><div class="content">Here are my notes on writing a type checker&#x2F;type inferrer in case anyone is interested: <a href="https:&#x2F;&#x2F;lambdaland.org&#x2F;posts&#x2F;2022-07-27_how_to_write_a_type_checker&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lambdaland.org&#x2F;posts&#x2F;2022-07-27_how_to_write_a_type_...</a></div><br/></div></div><div id="40790325" class="c"><input type="checkbox" id="c-40790325" checked=""/><div class="controls bullet"><span class="by">abeppu</span><span>|</span><a href="#40792904">prev</a><span>|</span><a href="#40789288">next</a><span>|</span><label class="collapse" for="c-40790325">[-]</label><label class="expand" for="c-40790325">[9 more]</label></div><br/><div class="children"><div class="content">Can someone familiar with the territory recommend a better or complementary resource of similar level of approachability?<p>The intro here flags that the author i) is not happy with the post in its current form, ii) was resynthesized from wikipedia &quot;without particularly putting in the effort to check my own understanding&quot;, which doesn&#x27;t inspire confidence.<p>And then when you do get into the content, stuff <i>looks</i> incorrect, but a non-expert reader, given the caveats in the intro, should be on the lookout for errors but isn&#x27;t equipped to identify them with confidence. E.g. the very first inference rule included is described as:<p>&gt; if you have a variable x declared to have some polytype π, and if the monotype μ is a specialisation of π, then x can be judged to have type μ<p>... but I <i>think</i> this should be &quot;π is a specialization of μ&quot;.<p>Basically, I think this is the kind of material where detail matters, where errors seriously impede understanding, and a resource where the reader&#x2F;learner has to be on guard second-guessing the author is a bad intro resource. But surely there are better ones out there.</div><br/><div id="40794750" class="c"><input type="checkbox" id="c-40794750" checked=""/><div class="controls bullet"><span class="by">philh</span><span>|</span><a href="#40790325">parent</a><span>|</span><a href="#40791648">next</a><span>|</span><label class="collapse" for="c-40794750">[-]</label><label class="expand" for="c-40794750">[1 more]</label></div><br/><div class="children"><div class="content">For whatever it&#x27;s worth, when I first wrote this I submitted it to &#x2F;r&#x2F;haskell (<a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;cs7jyu&#x2F;a_reckless_introduction_to_hindleymilner_type&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;cs7jyu&#x2F;a_reckless_...</a>) and it doesn&#x27;t look like there were any corrections from that; and since then I&#x27;ve implemented an HM type checker and don&#x27;t remember finding anything that made me think &quot;oh, I was wrong about ...&quot;.<p>So I&#x27;m more confident in the essay than I was at the time. But yeah, getting put on guard by those caveats doesn&#x27;t seem ideal for intro material. (But if I hadn&#x27;t had them and I&#x27;d gotten something wrong, that would also not have been ideal...)<p>For writing the type checker, &quot;write you a haskell&quot; that someone else linked was really helpful, and so was a paper called &quot;typing haskell in haskell&quot;: <a href="https:&#x2F;&#x2F;web.cecs.pdx.edu&#x2F;~mpj&#x2F;thih&#x2F;thih.pdf" rel="nofollow">https:&#x2F;&#x2F;web.cecs.pdx.edu&#x2F;~mpj&#x2F;thih&#x2F;thih.pdf</a></div><br/></div></div><div id="40791648" class="c"><input type="checkbox" id="c-40791648" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40790325">parent</a><span>|</span><a href="#40794750">prev</a><span>|</span><a href="#40790476">next</a><span>|</span><label class="collapse" for="c-40791648">[-]</label><label class="expand" for="c-40791648">[1 more]</label></div><br/><div class="children"><div class="content">This is nice and genuinely entertaining <a href="https:&#x2F;&#x2F;youtu.be&#x2F;IOiZatlZtGU" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;IOiZatlZtGU</a>
(Propositions as types by phil wadler).  Its true focus is the 1-1 mapping between type systems and logic systems, but it&#x27;s well worth the watch.<p>This is good reading - it demystifies the funny typing rules in their mathematical form.
<a href="https:&#x2F;&#x2F;legacy-blog.akgupta.ca&#x2F;blog&#x2F;2013&#x2F;05&#x2F;14&#x2F;so-you-still-dont-understand-hindley-milner&#x2F;" rel="nofollow">https:&#x2F;&#x2F;legacy-blog.akgupta.ca&#x2F;blog&#x2F;2013&#x2F;05&#x2F;14&#x2F;so-you-still-...</a><p>(Neither of these tell you how to implement the checker yourself though)</div><br/></div></div><div id="40790476" class="c"><input type="checkbox" id="c-40790476" checked=""/><div class="controls bullet"><span class="by">nathanrf</span><span>|</span><a href="#40790325">parent</a><span>|</span><a href="#40791648">prev</a><span>|</span><a href="#40790794">next</a><span>|</span><label class="collapse" for="c-40790476">[-]</label><label class="expand" for="c-40790476">[1 more]</label></div><br/><div class="children"><div class="content">The quoted paragraph is correct as written. E.g. if<p>f: ∀A, B. A -&gt; B -&gt; A<p>Then we have poly type π = &quot;∀A, B. A -&gt; B -&gt; A&quot;.<p>The monotype μ = Str -&gt; Int -&gt; Str is a specialization of π, so we are also permitted to judge that f has type μ.<p>The type specialization operator &quot;looks backwards&quot;, where we write sorta &quot;π ≤ μ&quot; because there&#x27;s a kind of &quot;subtyping&quot; relationship (though most HM type systems don&#x27;t actually contain subtyping) - anywhere that a term of type μ is used, a term of type π can be used instead because it can be specialized to μ.<p>I think this is a good complementary article: <a href="https:&#x2F;&#x2F;boxbase.org&#x2F;entries&#x2F;2018&#x2F;mar&#x2F;5&#x2F;hindley-milner&#x2F;" rel="nofollow">https:&#x2F;&#x2F;boxbase.org&#x2F;entries&#x2F;2018&#x2F;mar&#x2F;5&#x2F;hindley-milner&#x2F;</a> (it also links to three more academic sources for more context&#x2F;detail)</div><br/></div></div><div id="40790794" class="c"><input type="checkbox" id="c-40790794" checked=""/><div class="controls bullet"><span class="by">shpongled</span><span>|</span><a href="#40790325">parent</a><span>|</span><a href="#40790476">prev</a><span>|</span><a href="#40792844">next</a><span>|</span><label class="collapse" for="c-40790794">[-]</label><label class="expand" for="c-40790794">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Types and Programming Languages&quot; by Benjamin Pierce is an excellent textbook (and approachable, even to people without formal CS education) that covers type inference and introduces a lot of the nomenclature&#x2F;formalism gradually.</div><br/><div id="40795773" class="c"><input type="checkbox" id="c-40795773" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#40790325">root</a><span>|</span><a href="#40790794">parent</a><span>|</span><a href="#40792844">next</a><span>|</span><label class="collapse" for="c-40795773">[-]</label><label class="expand" for="c-40795773">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m trying to go through TAPL, and maybe it&#x27;s me, but I find its extremely terse and lacks a lot of examples I would find useful</div><br/><div id="40796572" class="c"><input type="checkbox" id="c-40796572" checked=""/><div class="controls bullet"><span class="by">shpongled</span><span>|</span><a href="#40790325">root</a><span>|</span><a href="#40795773">parent</a><span>|</span><a href="#40792844">next</a><span>|</span><label class="collapse" for="c-40796572">[-]</label><label class="expand" for="c-40796572">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if it will be useful to you, but I worked up dependency-free parsers&#x2F;type checkers in Rust for the &quot;languages&quot; defined in most of the chapters (at least the ones I cared about) <a href="https:&#x2F;&#x2F;github.com&#x2F;lazear&#x2F;types-and-programming-languages">https:&#x2F;&#x2F;github.com&#x2F;lazear&#x2F;types-and-programming-languages</a></div><br/></div></div></div></div></div></div><div id="40792844" class="c"><input type="checkbox" id="c-40792844" checked=""/><div class="controls bullet"><span class="by">efnx</span><span>|</span><a href="#40790325">parent</a><span>|</span><a href="#40790794">prev</a><span>|</span><a href="#40794926">next</a><span>|</span><label class="collapse" for="c-40792844">[-]</label><label class="expand" for="c-40792844">[1 more]</label></div><br/><div class="children"><div class="content">It will never be finished but Stephen Diehl’s “Write you a Haskell” is great.<p><a href="http:&#x2F;&#x2F;dev.stephendiehl.com&#x2F;fun&#x2F;" rel="nofollow">http:&#x2F;&#x2F;dev.stephendiehl.com&#x2F;fun&#x2F;</a></div><br/></div></div><div id="40794926" class="c"><input type="checkbox" id="c-40794926" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#40790325">parent</a><span>|</span><a href="#40792844">prev</a><span>|</span><a href="#40789288">next</a><span>|</span><label class="collapse" for="c-40794926">[-]</label><label class="expand" for="c-40794926">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ... but I think this should be &quot;π is a specialization of μ&quot;.<p>Can we reflect on how this person was so wary of reading the article for fear of being misled (instead of just reading it and afterwards reflecting&#x2F;evaluating) because they were so sure it must be wrong (for whatever reasons) and it turns they themselves were wrong. This is called irony and dunning krueger.</div><br/></div></div></div></div><div id="40789288" class="c"><input type="checkbox" id="c-40789288" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#40790325">prev</a><span>|</span><label class="collapse" for="c-40789288">[-]</label><label class="expand" for="c-40789288">[10 more]</label></div><br/><div class="children"><div class="content">I encountered HM a lot in my working life as a programmer. I did not expect that when I first encountered the names.<p>From the article:<p>&gt; HM type systems can&#x27;t implement heterogenous lists [...]
&gt; [well it does when wrapping the elements in a sum type, but then]
&gt; it can only accept types you know about in advance.
&gt; [which makes it] a massive pain to work with.<p>Sorry, I totally disagree... Heterogeneous lists without the sum types are a massive pain! Maybe it is easier for the initial development effort, but if you need to maintain code with heterogeneous lists (or dynamically typed code in general) the pain will come at some point and likely when already in production.<p>I much rather fix compile errors than runtime errors. And a massive thanks to Hindley and Milner for advancing type systems!<p>Found their photos in gratitude just now:<p><a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;J-Hindley" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;J-Hindley</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robin_Milner" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robin_Milner</a></div><br/><div id="40790680" class="c"><input type="checkbox" id="c-40790680" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#40789288">parent</a><span>|</span><a href="#40794843">next</a><span>|</span><label class="collapse" for="c-40790680">[-]</label><label class="expand" for="c-40790680">[3 more]</label></div><br/><div class="children"><div class="content">They&#x27;re only a pain if you need to know the run-time types of the elements. If you&#x27;re just operating on them through a narrowly defined interface, that&#x27;s just dynamic polymorphism, which is indeed more flexible with regards to future expandability, as long as you define the interface appropriately.</div><br/><div id="40794914" class="c"><input type="checkbox" id="c-40794914" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#40789288">root</a><span>|</span><a href="#40790680">parent</a><span>|</span><a href="#40794294">prev</a><span>|</span><a href="#40794843">next</a><span>|</span><label class="collapse" for="c-40794914">[-]</label><label class="expand" for="c-40794914">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as long as you define the interface appropriately<p>Well, if you have an interface that all entries adhere to it is not a heterogeneous list in my book. In Haskell that could be achieve without a sum type wrapper, but with a type class.<p><a href="https:&#x2F;&#x2F;fluoridealert.org&#x2F;key-topics&#x2F;tsca-fluoride-lawsuit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fluoridealert.org&#x2F;key-topics&#x2F;tsca-fluoride-lawsuit&#x2F;</a></div><br/></div></div></div></div><div id="40794843" class="c"><input type="checkbox" id="c-40794843" checked=""/><div class="controls bullet"><span class="by">philh</span><span>|</span><a href="#40789288">parent</a><span>|</span><a href="#40790680">prev</a><span>|</span><label class="collapse" for="c-40794843">[-]</label><label class="expand" for="c-40794843">[6 more]</label></div><br/><div class="children"><div class="content">I think my position is:<p>Native heterogeneous lists will often be convenient, and sometimes when you&#x27;ve used them they&#x27;re going to turn out in retrospect to have been a bad idea but sometimes they&#x27;ll be just fine, especially if they stay fairly locally scoped. I haven&#x27;t done any serious work in a language that supports them for years, so I don&#x27;t have a strong opinion about how often each of those cases happens.<p>But if you decide you want heterogeneous lists, but your language doesn&#x27;t support them, so you try to implement that with a sum type, then that&#x27;s basically always going to be a massive pain.</div><br/><div id="40796662" class="c"><input type="checkbox" id="c-40796662" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#40789288">root</a><span>|</span><a href="#40794843">parent</a><span>|</span><a href="#40794925">next</a><span>|</span><label class="collapse" for="c-40796662">[-]</label><label class="expand" for="c-40796662">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s an example use case where heterogeneous lists turn out to be fine <i>but</i> can&#x27;t be modelled with eg the OCaml difflist technique, eg <a href="https:&#x2F;&#x2F;github.com&#x2F;yawaramin&#x2F;re-web&#x2F;blob&#x2F;0d6c62fb432f85cc43757c46849df8b75985199b&#x2F;ReWebTest&#x2F;FormTest.ml#L9">https:&#x2F;&#x2F;github.com&#x2F;yawaramin&#x2F;re-web&#x2F;blob&#x2F;0d6c62fb432f85cc437...</a> ?</div><br/><div id="40797536" class="c"><input type="checkbox" id="c-40797536" checked=""/><div class="controls bullet"><span class="by">philh</span><span>|</span><a href="#40789288">root</a><span>|</span><a href="#40796662">parent</a><span>|</span><a href="#40794925">next</a><span>|</span><label class="collapse" for="c-40797536">[-]</label><label class="expand" for="c-40797536">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with that technique and don&#x27;t know what&#x27;s going on from that snippet.<p>In Haskell, any time a heterogeneous list turns out to be fine, I expect to be able to model it. Often it&#x27;ll look like &quot;I&#x27;m applying a polymorphic function to every one of these list elements&quot;, and then you can either do a sum type (as discussed in the post) or an existential (which doesn&#x27;t need you to list up front all the types you might use). If the function is &quot;is negative?&quot;, it&#x27;ll look something like (untested)<p><pre><code>    data SomeNum = forall a. Num a =&gt; SomeNum a

    isNegative :: SomeNum -&gt; Bool
    isNegative (SomeNum n) = n &lt; 0

    numbers = [SomeNum (3 :: Int), SomeNum (5.2 :: Double), SomeNum valOfUnexpectedNumericType]
    anyNegative = any isNegative numbers
</code></pre>
...but it&#x27;ll often be easier to just apply the `&lt; 0` check to every element <i>before</i> putting them in the list. (If you have several functions you want to apply to them all, that&#x27;s when the existential trick becomes more useful.)<p>So you can model heterogeneous lists in this case, and it&#x27;s safer (because you can&#x27;t put in a value that can&#x27;t be compared to 0) but also less convenient. Whether that&#x27;s an improvement or not will depend on the situation.</div><br/></div></div></div></div><div id="40794925" class="c"><input type="checkbox" id="c-40794925" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#40789288">root</a><span>|</span><a href="#40794843">parent</a><span>|</span><a href="#40796662">prev</a><span>|</span><label class="collapse" for="c-40794925">[-]</label><label class="expand" for="c-40794925">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  I haven&#x27;t done any serious work in a language that supports them for years<p>Is this not silently admitting that strong types to some degree have won?<p>Don&#x27;t get me wrong: I like Clojure&#x2F;LISPs&#x2F;Ruby. But I would not choose them for a new project these days.<p>(and I do not like JS, which has them too)</div><br/><div id="40797119" class="c"><input type="checkbox" id="c-40797119" checked=""/><div class="controls bullet"><span class="by">freilanzer</span><span>|</span><a href="#40789288">root</a><span>|</span><a href="#40794925">parent</a><span>|</span><a href="#40795015">next</a><span>|</span><label class="collapse" for="c-40797119">[-]</label><label class="expand" for="c-40797119">[1 more]</label></div><br/><div class="children"><div class="content">I would definitely choose a Lisp if it had an Intellij-like IDE. Especially since the type system of CL is good, though not static, obviously. But it&#x27;s a tradeoff between having Haskell during compile time and CL during development time, for me.</div><br/></div></div><div id="40795015" class="c"><input type="checkbox" id="c-40795015" checked=""/><div class="controls bullet"><span class="by">philh</span><span>|</span><a href="#40789288">root</a><span>|</span><a href="#40794925">parent</a><span>|</span><a href="#40797119">prev</a><span>|</span><label class="collapse" for="c-40795015">[-]</label><label class="expand" for="c-40795015">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m still working at the same company as when I wrote this, and that company is still using Haskell (now mostly Typescript instead of Elm). If I did move on I&#x27;d ideally want to keep using Haskell, or failing that some other strongly typed language.<p>But I don&#x27;t expect that my own experience says much about the language ecosystem in general. I don&#x27;t particularly have an opinion on whether or not strong types have &quot;won&quot;, and I didn&#x27;t intend to comment on that question.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>