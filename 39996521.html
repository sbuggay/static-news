<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712826053866" as="style"/><link rel="stylesheet" href="styles.css?v=1712826053866"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rednafi.com/misc/etag_and_http_caching/">ETag and HTTP Caching</a> <span class="domain">(<a href="https://rednafi.com">rednafi.com</a>)</span></div><div class="subtext"><span>nalgeon</span> | <span>45 comments</span></div><br/><div><div id="39998746" class="c"><input type="checkbox" id="c-39998746" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39999803">next</a><span>|</span><label class="collapse" for="c-39998746">[-]</label><label class="expand" for="c-39998746">[16 more]</label></div><br/><div class="children"><div class="content">This is nice. It reminds of how miserable my life is.<p>— Which HTTP code I should return for my API? I already used 404, 403, but I need another one. Damn, HTTP is so old and it makes no sense.<p>— You can&#x27;t use HTTP codes like that Bob, they&#x27;re not a free choice. They&#x27;re for the protocol, not for your app.<p>— Let&#x27;s look at the list. Hm... &quot;412 Precondition Failed&quot;. Hey, it sounds nice. It fits to my use case. I&#x27;m gonna document it. It means the account is out of balance.<p>— What is this garbage? Please read the spec. This is going to make our API gateways, CDNs, everything go crazy. Can&#x27;t let you move on with this PR.<p>— Look. I documented it, made an enum with the code, it&#x27;s clean. I&#x27;m an experienced REST developer.<p>— It... it doesn&#x27;t work like that Bob. Please, read the spec.<p>— Hey, got enough approvals, &quot;412 Account Out Of Balance&quot; it is! It passes the tests.<p>For each dev that knows proper HTTP, there&#x27;s 10.000 Bobs.</div><br/><div id="39998910" class="c"><input type="checkbox" id="c-39998910" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#39998746">parent</a><span>|</span><a href="#39999176">next</a><span>|</span><label class="collapse" for="c-39998910">[-]</label><label class="expand" for="c-39998910">[3 more]</label></div><br/><div class="children"><div class="content">For the shortcoming of conveying errors strictly through HTTP status codes, consider:<p>RFC-7807, Problem Details for HTTP APIs[0]<p>From the introduction:<p><pre><code>  HTTP [RFC7230] status codes are sometimes not sufficient to convey
  enough information about an error to be helpful.  While humans behind
  Web browsers can be informed about the nature of the problem with an
  HTML [W3C.REC-html5-20141028] response body, non-human consumers of
  so-called &quot;HTTP APIs&quot; are usually not.

  This specification defines simple JSON [RFC7159] and XML
  [W3C.REC-xml-20081126] document formats to suit this purpose.  They
  are designed to be reused by HTTP APIs, which can identify distinct
  &quot;problem types&quot; specific to their needs.
</code></pre>
HTH<p>0 - <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc7807" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc7807</a></div><br/><div id="39999397" class="c"><input type="checkbox" id="c-39999397" checked=""/><div class="controls bullet"><span class="by">thecopy</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39998910">parent</a><span>|</span><a href="#39998950">next</a><span>|</span><label class="collapse" for="c-39999397">[-]</label><label class="expand" for="c-39999397">[1 more]</label></div><br/><div class="children"><div class="content">Nice one, but seems to be replaced with <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9457" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9457</a></div><br/></div></div><div id="39998950" class="c"><input type="checkbox" id="c-39998950" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39998910">parent</a><span>|</span><a href="#39999397">prev</a><span>|</span><a href="#39999176">next</a><span>|</span><label class="collapse" for="c-39998950">[-]</label><label class="expand" for="c-39998950">[1 more]</label></div><br/><div class="children"><div class="content">Good spec.</div><br/></div></div></div></div><div id="39999176" class="c"><input type="checkbox" id="c-39999176" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#39998746">parent</a><span>|</span><a href="#39998910">prev</a><span>|</span><a href="#39999418">next</a><span>|</span><label class="collapse" for="c-39999176">[-]</label><label class="expand" for="c-39999176">[3 more]</label></div><br/><div class="children"><div class="content">Ah, the eternal battle. Do you return an HTTP error code if the problem lies in the domain?<p>I think I&#x27;ve seen everything on that scale.<p>On one end:
{ status: 200, error: InsufficientFunds }<p>On the other:
- &quot;let&#x27;s use 409, it perfectly fits our use case&quot; 
+ &quot;but we don&#x27;t have useful error codes for all the other domain errors.&quot;</div><br/><div id="39999381" class="c"><input type="checkbox" id="c-39999381" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39999176">parent</a><span>|</span><a href="#39999418">next</a><span>|</span><label class="collapse" for="c-39999381">[-]</label><label class="expand" for="c-39999381">[2 more]</label></div><br/><div class="children"><div class="content">Status 200 with &quot;InsufficientFunds&quot; can be correct.<p>Let&#x27;s assume your resource is &quot;&#x2F;account&#x2F;1234&#x2F;withdraw-availability&quot;<p>It&#x27;s a hypothetical endpoint you can GET to know if you can withdraw money. You hit it, and the request is sucessful (the server understood and will inform you whether withdrawaw is available or not).<p>Let&#x27;s assume your resource is &quot;&#x2F;account&#x2F;1234&#x2F;withdraw&quot;<p>This other hypothetical endpoint you can POST a request for money withdraw. Returning 200 here means the server understood and processed your request, so a 200 that does not withdraw makes no sense.<p>The same endpoint could also return a success &quot;201&quot; accepted (the server understood the request, but it is not processed yet). In the body, there would be a link for &quot;&#x2F;withdrawaws&#x2F;48957987593845983475&#x2F;status&quot;, a resource specific to this future processing, which you can GET later (maybe 1ms later, within the same socket). This GET could also return a 200, saying that such withdrawaw was not possible (the server sucessfully understood the request and will inform you about the status of the withdrawaw).<p>For this modeling stuff, the Roy Fielding dissertation about REST is more enlightening than the spec. The spec is still needed though.</div><br/><div id="39999716" class="c"><input type="checkbox" id="c-39999716" checked=""/><div class="controls bullet"><span class="by">lstamour</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39999381">parent</a><span>|</span><a href="#39999418">next</a><span>|</span><label class="collapse" for="c-39999716">[-]</label><label class="expand" for="c-39999716">[1 more]</label></div><br/><div class="children"><div class="content">One more example, if your request contains a batch of operations, you generally have to return 200, or maybe 204, if it was successfully received and should not be retried in full. In the response body, you might give other response codes for specific errors or failures to retry in a new request. So it can easily make sense to return 200 when there are e.g. partial failures and partial success and the request was properly formatted, authorized and acted upon.</div><br/></div></div></div></div></div></div><div id="39999418" class="c"><input type="checkbox" id="c-39999418" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#39998746">parent</a><span>|</span><a href="#39999176">prev</a><span>|</span><a href="#39999101">next</a><span>|</span><label class="collapse" for="c-39999418">[-]</label><label class="expand" for="c-39999418">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, to me HTTP looks like:<p>- The first line of an HTTP request has its own format (space-separated-ish), and mixes method and URL path.<p>- The URL path in that first line has its own format and weird escaping, and mixes one path with zero-or-more key value pairs.<p>- The headers have their own format.<p>- The body has its own format.<p>Most (all?) HTTP libraries for clients and servers abstract all that mess away into a neat object that could be easily represented in JSON (or bencode if you want something simple-ish while supporting binary data), but it&#x27;s like using a nice program while knowing it&#x27;s written in C[1].<p>Of course, JSON has its own problems, but in that case at least we only need to deal with the problems of one format that supports with proper nesting, not 4 different weird formats masquerading as one.<p>[1]: Disclaimer, I don&#x27;t like Rust, so don&#x27;t take this as a RIIR thing.<p>EDIT: To be clear, I don&#x27;t agree with how Bob misuses HTTP in your example. I just find it sad that we&#x27;re locked into this weirdly complex protocol.</div><br/></div></div><div id="39999101" class="c"><input type="checkbox" id="c-39999101" checked=""/><div class="controls bullet"><span class="by">stingraycharles</span><span>|</span><a href="#39998746">parent</a><span>|</span><a href="#39999418">prev</a><span>|</span><a href="#39998856">next</a><span>|</span><label class="collapse" for="c-39999101">[-]</label><label class="expand" for="c-39999101">[3 more]</label></div><br/><div class="children"><div class="content">My coworkers insisted on always returning 200 and having the status code in JSON.<p>At least at that point it’s clearly not HTTP anymore, and it’s better than pretending to be compliant like your Bob. But something dies inside me whenever I have to work with it.</div><br/><div id="39999170" class="c"><input type="checkbox" id="c-39999170" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39999101">parent</a><span>|</span><a href="#39999146">next</a><span>|</span><label class="collapse" for="c-39999170">[-]</label><label class="expand" for="c-39999170">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say returning 200 for all successes is reasonable if the responses are simple.<p>Returning 200 for an error makes no sense. Having 400s and 500s is the simplest way to have observability over protocol behavior (think logs, error rates, etc). If you use all 200s, you&#x27;d have to re-implement observability by yourself, so you lose simplicity that you gained by ignoring those statuses.<p>It&#x27;s the same thing with caching stuff. You could implement those outside the protocol, but then you&#x27;d be writing your own protocol (trying to be smarter than decades of engineering efforts).</div><br/></div></div><div id="39999146" class="c"><input type="checkbox" id="c-39999146" checked=""/><div class="controls bullet"><span class="by">peoplefromibiza</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39999101">parent</a><span>|</span><a href="#39999170">prev</a><span>|</span><a href="#39998856">next</a><span>|</span><label class="collapse" for="c-39999146">[-]</label><label class="expand" for="c-39999146">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what SOAP and GraphQL do, they always return 200</div><br/></div></div></div></div><div id="39998856" class="c"><input type="checkbox" id="c-39998856" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#39998746">parent</a><span>|</span><a href="#39999101">prev</a><span>|</span><a href="#39999803">next</a><span>|</span><label class="collapse" for="c-39998856">[-]</label><label class="expand" for="c-39998856">[5 more]</label></div><br/><div class="children"><div class="content">Which article would you ask Bob to read to learn the right way to do it?</div><br/><div id="39998946" class="c"><input type="checkbox" id="c-39998946" checked=""/><div class="controls bullet"><span class="by">mozey</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39998856">parent</a><span>|</span><a href="#39998931">next</a><span>|</span><label class="collapse" for="c-39998946">[-]</label><label class="expand" for="c-39998946">[3 more]</label></div><br/><div class="children"><div class="content">Have to admit I&#x27;ve never used this code, and didn&#x27;t know what it was about. Quickly read up about it. So ETag is a hash of the resource. You must provide it with requests that modify the resource. If your hash doesn&#x27;t match the server hash, then 412 Precondition Failed is returned?<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Status&#x2F;412" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Status&#x2F;412</a><p><a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9110#status.412" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9110#status.412</a></div><br/><div id="39999049" class="c"><input type="checkbox" id="c-39999049" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39998946">parent</a><span>|</span><a href="#39998931">next</a><span>|</span><label class="collapse" for="c-39999049">[-]</label><label class="expand" for="c-39999049">[2 more]</label></div><br/><div class="children"><div class="content">You can provide all sorts of conditions using HTTP headers such as &quot;If-Match&quot;, &quot;If-None-Match&quot;, &quot;If-Modified-Since&quot;, &quot;If-Range&quot;, etc. The server can chose an HTTP code to indicate some sort of cache invalidation signal.<p>304 means &quot;you&#x27;re good, your cached version satisfies the conditions&quot;<p>412 means &quot;you&#x27;re not good, your cached version does not satisfy the conditions&quot;<p>412 usually applies to modifications, but it could be for reading too, in the case of ranged requests (getting a specific range of bytes from a large representation). See the &quot;Range&quot; header.<p>These are all interconected. The headers, the codes, etc. They are very useful for caching and can save a lot of bandwidth. Browsers and CDNs use them extensively. Server-to-server communcation could use them as well, but I haven&#x27;t seen popular implementations (let&#x27;s say, a web framework that provides abstraction over these mechanisms).</div><br/><div id="39999133" class="c"><input type="checkbox" id="c-39999133" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39999049">parent</a><span>|</span><a href="#39998931">next</a><span>|</span><label class="collapse" for="c-39999133">[-]</label><label class="expand" for="c-39999133">[1 more]</label></div><br/><div class="children"><div class="content">Also, other popular HTTP codes have cache implications.<p>For example, 404 implies &quot;No indication is given of whether the condition is temporary or permanent&quot;. Cache invalidation headers don&#x27;t apply to this code because a 404 means there&#x27;s something about the _resource_ and not only the _representation_ that could not be found. That client cannot cache the 404 result, not even for a fraction of a second.<p>404&#x27;s brother 410 implies &quot;This condition is expected to be considered permanent.&quot;. A client that gets a 410 can cache that result, never needing to reach the server again. It means it&#x27;s gone forever. That client can decide to never look up that URI again.<p>Very often, &quot;400 Bad Request&quot; is the best HTTP you can use if you are not sure what to use. Then, describe what the error means using other HTTP components and&#x2F;or the response body.<p>HTTP can be very simple. GET (ask for a representation) and POST (send a representation) as methods only. 200 (success), 400 (client error) and 500 (server error) as response codes only. It&#x27;s the best way to start, then move to more elaborate protocol features as you learn.</div><br/></div></div></div></div></div></div><div id="39998931" class="c"><input type="checkbox" id="c-39998931" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#39998746">root</a><span>|</span><a href="#39998856">parent</a><span>|</span><a href="#39998946">prev</a><span>|</span><a href="#39999803">next</a><span>|</span><label class="collapse" for="c-39998931">[-]</label><label class="expand" for="c-39998931">[1 more]</label></div><br/><div class="children"><div class="content">Bob has since moved on to crypto, leaving the cache invalidation eternally crippled. New Bob decided that everything is useless and wants to rewrite the whole backend using a faster language.</div><br/></div></div></div></div></div></div><div id="39999803" class="c"><input type="checkbox" id="c-39999803" checked=""/><div class="controls bullet"><span class="by">joosters</span><span>|</span><a href="#39998746">prev</a><span>|</span><a href="#39997263">next</a><span>|</span><label class="collapse" for="c-39999803">[-]</label><label class="expand" for="c-39999803">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not seen a very convincing use-case for ETags vs Last-Modified date caching.<p>In the example request, the server still has to do all of the work generating the page, in order to calculate the ETag and then determine whether or not the page has changed. In most situations, it&#x27;s simpler to have timestamps to compare against, because that gives the server a faster way to spot unmodified data.<p>e.g. you get a HTTP request for some data that you know is sourced from a particular file, or a DB table. If the client sends a If-Modified-Since (or whatever the header name is), you have a good chance to be able to check the modified time of the data source before doing any complicated data processing, and are able to send back a not modified response sooner.</div><br/></div></div><div id="39997263" class="c"><input type="checkbox" id="c-39997263" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39999803">prev</a><span>|</span><a href="#39999959">next</a><span>|</span><label class="collapse" for="c-39997263">[-]</label><label class="expand" for="c-39997263">[4 more]</label></div><br/><div class="children"><div class="content">The ETag can be _anything_.  I have an API that serves &quot;files&quot; from a backend storage system.  Whenever files are written a revision number is incremented.  This is perfect for a weak validator and so my ETags are also blisfully short and semantically useful,  typically:<p><pre><code>    ETag: W&#x2F;&quot;750&quot;
</code></pre>
This also means the API can just check the revision number and avoid pulling out and decompressing some of the larger payloads that are stored there and the implementation is absolutely minimal.  It&#x27;s a great standard.</div><br/><div id="39997412" class="c"><input type="checkbox" id="c-39997412" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#39997263">parent</a><span>|</span><a href="#39998504">next</a><span>|</span><label class="collapse" for="c-39997412">[-]</label><label class="expand" for="c-39997412">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t it be a strong validator if the files don&#x27;t change at all between revisions? Or does the revision number only increment on &quot;significant&quot; revisions?</div><br/><div id="39997463" class="c"><input type="checkbox" id="c-39997463" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39997263">root</a><span>|</span><a href="#39997412">parent</a><span>|</span><a href="#39998504">next</a><span>|</span><label class="collapse" for="c-39997463">[-]</label><label class="expand" for="c-39997463">[1 more]</label></div><br/><div class="children"><div class="content">The data does not but certain metadata elements might.  It probably could be a strong validator anyways for it&#x27;s use cases,  but I made the decision in a hurry.</div><br/></div></div></div></div><div id="39998504" class="c"><input type="checkbox" id="c-39998504" checked=""/><div class="controls bullet"><span class="by">choppaface</span><span>|</span><a href="#39997263">parent</a><span>|</span><a href="#39997412">prev</a><span>|</span><a href="#39999959">next</a><span>|</span><label class="collapse" for="c-39998504">[-]</label><label class="expand" for="c-39998504">[1 more]</label></div><br/><div class="children"><div class="content">A great standard but also provides an effective cookie-less mechanism for user tracking e.g.<p><a href="https:&#x2F;&#x2F;levelup.gitconnected.com&#x2F;no-cookies-no-problem-using-etags-for-user-tracking-3e745544176b" rel="nofollow">https:&#x2F;&#x2F;levelup.gitconnected.com&#x2F;no-cookies-no-problem-using...</a></div><br/></div></div></div></div><div id="39999959" class="c"><input type="checkbox" id="c-39999959" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#39997263">prev</a><span>|</span><a href="#39997564">next</a><span>|</span><label class="collapse" for="c-39999959">[-]</label><label class="expand" for="c-39999959">[1 more]</label></div><br/><div class="children"><div class="content">if only browsers respected this. none of browsers use ETag and If-None-Match mechanism. instead they do their own wizzardy caching...</div><br/></div></div><div id="39997564" class="c"><input type="checkbox" id="c-39997564" checked=""/><div class="controls bullet"><span class="by">ajayvk</span><span>|</span><a href="#39999959">prev</a><span>|</span><a href="#39999149">next</a><span>|</span><label class="collapse" for="c-39997564">[-]</label><label class="expand" for="c-39997564">[6 more]</label></div><br/><div class="children"><div class="content">An approach like <a href="https:&#x2F;&#x2F;github.com&#x2F;benbjohnson&#x2F;hashfs">https:&#x2F;&#x2F;github.com&#x2F;benbjohnson&#x2F;hashfs</a> allows file names to be updated at runtime to be content hashed. This removes the need for the extra &quot;304 Not Modified&quot; API calls from the client. This content hash based file renaming is usually done using a build step which renames files. For applications where the static file serving and HTTP request processing are done in the same application, this can be done in memory without a build step for file renames.<p>I am using that approach in my project <a href="https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;clace">https:&#x2F;&#x2F;github.com&#x2F;claceio&#x2F;clace</a>. It removes the need for a build step while making aggressive static file caching possible.</div><br/><div id="39997775" class="c"><input type="checkbox" id="c-39997775" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#39997564">parent</a><span>|</span><a href="#39998560">next</a><span>|</span><label class="collapse" for="c-39997775">[-]</label><label class="expand" for="c-39997775">[4 more]</label></div><br/><div class="children"><div class="content">I use content hashes for some of the images in parts of my site. And I use the IPFS scheme for it, and have the path be under &#x2F;ipfs&#x2F; or some such.<p>And so you could find the same file on IPFS if anyone served it there, as the content hash in the url tells you what to look for.<p>Even though on my side I’ve done this all completely manually, so much so that it’s literally just me calculating the IPFS hash on my machine one time and then having symlinks with those content hashes so that &#x2F;ipfs&#x2F; directory on my sites contains content that is served by their IPFS content hash, even though my server does not run an IPFS node or anything.<p>A very interesting side effect of this is that one time I loaded one of my pages, the web browser actually picked up on the pattern and offered to load those files over actual IPFS!</div><br/><div id="39998041" class="c"><input type="checkbox" id="c-39998041" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#39997564">root</a><span>|</span><a href="#39997775">parent</a><span>|</span><a href="#39998560">next</a><span>|</span><label class="collapse" for="c-39998041">[-]</label><label class="expand" for="c-39998041">[3 more]</label></div><br/><div class="children"><div class="content">Wait what?<p>Browsers now offer to load over IPFS?<p>I was wondering how you can trust an IFPS gateway, does does browser verify the file is legit using some checksum? Maybw subresource integrity supports IPFS content hashing or something? How does it generate cid anyway ?<p><a href="https:&#x2F;&#x2F;docs.ipfs.tech&#x2F;concepts&#x2F;content-addressing&#x2F;#cids-are-not-file-hashes" rel="nofollow">https:&#x2F;&#x2F;docs.ipfs.tech&#x2F;concepts&#x2F;content-addressing&#x2F;#cids-are...</a><p>How would you use SRI here to verify the cid (and not an additional out-of-band hash) make sure the gateway isn’t returning some crap to, say, inject malicious JS?</div><br/><div id="39998163" class="c"><input type="checkbox" id="c-39998163" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#39997564">root</a><span>|</span><a href="#39998041">parent</a><span>|</span><a href="#39998560">next</a><span>|</span><label class="collapse" for="c-39998163">[-]</label><label class="expand" for="c-39998163">[2 more]</label></div><br/><div class="children"><div class="content">So in my case, I am not using SRI. But I am using the CID as the name in the path.<p>Using the example file from your link, I would host it as something like<p><a href="https:&#x2F;&#x2F;mywebsite.example.com&#x2F;ipfs&#x2F;QmPK1s3pNYLi9ERiq3BDxKa4XosgWwFRQUydHUtz4YgpqB" rel="nofollow">https:&#x2F;&#x2F;mywebsite.example.com&#x2F;ipfs&#x2F;QmPK1s3pNYLi9ERiq3BDxKa4X...</a><p>And this was enough for that particular browser I was using to recognize that this file can be attempted to be retrieved directly from IPFS</div><br/><div id="39998644" class="c"><input type="checkbox" id="c-39998644" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#39997564">root</a><span>|</span><a href="#39998163">parent</a><span>|</span><a href="#39998560">next</a><span>|</span><label class="collapse" for="c-39998644">[-]</label><label class="expand" for="c-39998644">[1 more]</label></div><br/><div class="children"><div class="content">Yea but the gateway can be compromised, so that is insecure</div><br/></div></div></div></div></div></div></div></div><div id="39998560" class="c"><input type="checkbox" id="c-39998560" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#39997564">parent</a><span>|</span><a href="#39997775">prev</a><span>|</span><a href="#39999149">next</a><span>|</span><label class="collapse" for="c-39998560">[-]</label><label class="expand" for="c-39998560">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also been dissatisfied with http caching not utilizing content hashes enough. If you&#x27;re using server side templating one issue is that it&#x27;s not efficient to calculate the hash while you&#x27;re running the template, it would need to be precalculated to be efficient enough to use.<p>So I wrote <a href="https:&#x2F;&#x2F;github.com&#x2F;infogulch&#x2F;xtemplate">https:&#x2F;&#x2F;github.com&#x2F;infogulch&#x2F;xtemplate</a> to scan all assets at startup to precalculate the hash for templates that use it, and if a request comes in with a query parameter ?hash=sha384-xyz and it matches then it gives it a 1 year immutable Cache-Control header automatically. If a file x.ext has a matching x.ext.gz&#x2F;x.ext.zst&#x2F;x.ext.br file then (after hashing the content to make sure it matches) client requests that support it are sent a compressed version streamed directly from disk with sendfile2. I call this &quot;Optimal asset serving&quot; (a bit bold perhaps).</div><br/></div></div></div></div><div id="39999149" class="c"><input type="checkbox" id="c-39999149" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#39997564">prev</a><span>|</span><a href="#39997116">next</a><span>|</span><label class="collapse" for="c-39999149">[-]</label><label class="expand" for="c-39999149">[1 more]</label></div><br/><div class="children"><div class="content">I recently implemented this, great write-up. Regarding the hashing function, I’m curious about opinions. In my implementation I went for a cheap but weak cryptographic hash at first. Then I got worried that some auditor would flag it and time would be wasted convincing them to change their mind. But then I stumbled upon FNV [1], a non-cryptographic hash and part of Go’s standard library and went for it. Any thoughts?<p>[1]: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Fowler%E2%80%93Noll%E2%80%93Vo_hash_function" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Fowler%E2%80%93Noll%E2%80%93...</a></div><br/></div></div><div id="39997116" class="c"><input type="checkbox" id="c-39997116" checked=""/><div class="controls bullet"><span class="by">JaggedJax</span><span>|</span><a href="#39999149">prev</a><span>|</span><a href="#39997625">next</a><span>|</span><label class="collapse" for="c-39997116">[-]</label><label class="expand" for="c-39997116">[4 more]</label></div><br/><div class="children"><div class="content">How is the sample `calculateETag()` function generating a weak ETag? It looks like it will generate a different hash due to any JSON formatting changes.<p>It seems like generating a weak ETag would take more effort since you&#x27;d need to either ensure consistent ordering and formatting of the JSON, or generate the Etag on the content before converting it to a JSON string.</div><br/><div id="39997270" class="c"><input type="checkbox" id="c-39997270" checked=""/><div class="controls bullet"><span class="by">clessg</span><span>|</span><a href="#39997116">parent</a><span>|</span><a href="#39997625">next</a><span>|</span><label class="collapse" for="c-39997270">[-]</label><label class="expand" for="c-39997270">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because it isn&#x27;t <i>really</i> generating a weak ETag. From the article:<p>&gt; You could make the `calculateETag` function format-agnostic, so the hash stays the same if the JSON format changes but the content does not. The current `calculateETag` implementation is susceptible to format changes, and I kept it that way to keep the code shorter.<p>They seem to agree, a <i>true</i> weak ETag implementation would probably be trickier and require more code :P I&#x27;d be fascinated to see how that might work in practice, though.</div><br/><div id="39999885" class="c"><input type="checkbox" id="c-39999885" checked=""/><div class="controls bullet"><span class="by">lstamour</span><span>|</span><a href="#39997116">root</a><span>|</span><a href="#39997270">parent</a><span>|</span><a href="#39998215">next</a><span>|</span><label class="collapse" for="c-39999885">[-]</label><label class="expand" for="c-39999885">[1 more]</label></div><br/><div class="children"><div class="content">I could probably write one pretty quick, under the assumption that we are storing only JS-compatible JSON with no encoding hiccups (JSON sadly isn’t as standard as it appears at first glance…) just hash(JSON.stringify(JSON.parse(fileText))) and you’re done. This assumes the same parse and serialize methods are expected to be used at both ends, that they only normalize formatting and that you don’t have to worry about number representation doing weird things. I wouldn’t actually sort keys as sorting is technically a change in behavior and good browsers today do not re-order object keys for you, though your code can do that, of course. I considered skipping the second JSON serialize, but it makes a buffer out of an object so it’s easy enough to use. One could imagine a more efficient approach would modify the hashing to occur against buffer chunks of the JSON, but intentionally skip the whitespace. This avoids unintentional data serialization but obviously the parsing routine would have to match the recipient exactly to work correctly. And it still assumes you’re receiving oddly formatted but valid JSON, which doesn’t sound like a safe assumption to make. If your JSON varies in format I wouldn’t ever want to assume I’d be able to parse it correctly. I mean, what if a return character slips in by mistake amongst all the newlines?</div><br/></div></div><div id="39998215" class="c"><input type="checkbox" id="c-39998215" checked=""/><div class="controls bullet"><span class="by">JaggedJax</span><span>|</span><a href="#39997116">root</a><span>|</span><a href="#39997270">parent</a><span>|</span><a href="#39999885">prev</a><span>|</span><a href="#39997625">next</a><span>|</span><label class="collapse" for="c-39998215">[-]</label><label class="expand" for="c-39998215">[1 more]</label></div><br/><div class="children"><div class="content">Not sure how I missed that, thanks.</div><br/></div></div></div></div></div></div><div id="39999511" class="c"><input type="checkbox" id="c-39999511" checked=""/><div class="controls bullet"><span class="by">ulrischa</span><span>|</span><a href="#39997625">prev</a><span>|</span><a href="#39997143">next</a><span>|</span><label class="collapse" for="c-39999511">[-]</label><label class="expand" for="c-39999511">[1 more]</label></div><br/><div class="children"><div class="content">Oh this topic can cost you some years of your life</div><br/></div></div></div></div></div></div></div></body></html>