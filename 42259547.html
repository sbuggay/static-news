<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732784458451" as="style"/><link rel="stylesheet" href="styles.css?v=1732784458451"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tratt.net/laurie/blog/2024/structured_editing_and_incremental_parsing.html">Structured Editing and Incremental Parsing</a> <span class="domain">(<a href="https://tratt.net">tratt.net</a>)</span></div><div class="subtext"><span>ltratt</span> | <span>16 comments</span></div><br/><div><div id="42262042" class="c"><input type="checkbox" id="c-42262042" checked=""/><div class="controls bullet"><span class="by">bgoated01</span><span>|</span><a href="#42261179">next</a><span>|</span><label class="collapse" for="c-42262042">[-]</label><label class="expand" for="c-42262042">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not extremely familiar with the details of incremental parsing, but I have used Cursorless, a VSCode extension based on tree-sitter for voice controlled structured editing, and it is pretty powerful. You can use the structured editing when you want and also normal editing in between. Occasionally the parser will get things wrong and only change&#x2F;take&#x2F;select part of a function or what have you, but in general it&#x27;s very useful, and I tend to miss it now that I am no longer voice coding much.  I seem to remember that there was a similar extension for emacs (sans voice control). treemacs, or something? Anyone used that?<p>[0] <a href="https:&#x2F;&#x2F;www.cursorless.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cursorless.org&#x2F;</a></div><br/><div id="42262481" class="c"><input type="checkbox" id="c-42262481" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#42262042">parent</a><span>|</span><a href="#42261179">next</a><span>|</span><label class="collapse" for="c-42262481">[-]</label><label class="expand" for="c-42262481">[1 more]</label></div><br/><div class="children"><div class="content">Does anything similar exist for JetBrains IDEs, but fully open source? (Open source plugin, and open source voice recognition model running locally.)</div><br/></div></div></div></div><div id="42261179" class="c"><input type="checkbox" id="c-42261179" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42262042">prev</a><span>|</span><a href="#42261026">next</a><span>|</span><label class="collapse" for="c-42261179">[-]</label><label class="expand" for="c-42261179">[5 more]</label></div><br/><div class="children"><div class="content">Trying to use any kind of syntax highlighter with TeX is a pain in the butt. I didn&#x27;t mean LaTeX there. I mean TeX, which can rewrite it&#x27;s own lexer, and a lot of libraries work by doing so. I move in and out of TeXInfo syntax and it basically just causes most editors to sit there screaming that everything is broken.</div><br/><div id="42263335" class="c"><input type="checkbox" id="c-42263335" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42261179">parent</a><span>|</span><a href="#42261026">next</a><span>|</span><label class="collapse" for="c-42263335">[-]</label><label class="expand" for="c-42263335">[4 more]</label></div><br/><div class="children"><div class="content">Yes its pretty funny when you realise what a tiny corner of the design space of programs most users inhabit that they think things like lsp are an amazing tool instead of a weekend throwaway project.<p>What&#x27;s even funnier is how much they attack anyone who points this out.</div><br/><div id="42263430" class="c"><input type="checkbox" id="c-42263430" checked=""/><div class="controls bullet"><span class="by">foo42</span><span>|</span><a href="#42261179">root</a><span>|</span><a href="#42263335">parent</a><span>|</span><a href="#42261026">next</a><span>|</span><label class="collapse" for="c-42263430">[-]</label><label class="expand" for="c-42263430">[3 more]</label></div><br/><div class="children"><div class="content">perhaps the &quot;attacks&quot; relate to the condescending tone with which you relate your superior skills.<p>I think most people&#x27;s amazement with lsp relates to the practical benefits of such a project _not_ being thrown away but taken that last 10% (which is 90% of the work) to make it suitable for so many use cases and selling people on the idea of doing so.</div><br/><div id="42263587" class="c"><input type="checkbox" id="c-42263587" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42261179">root</a><span>|</span><a href="#42263430">parent</a><span>|</span><a href="#42261026">next</a><span>|</span><label class="collapse" for="c-42263587">[-]</label><label class="expand" for="c-42263587">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s amazing about lsp isn&#x27;t the polish, it&#x27;s that we&#x27;ve hobbled our selves so much that a tool like it is even useful.<p>Only having exposure to the algol family of languages does for your mental capabilities what a sugar only diet does for your physical capabilities. It used to be the case that all programmers had exposure to assembly&#x2F;machine code which broke them out of the worst habits algols instill. No longer.<p>Pointing out that the majority of programmers today have the mental equivalent of scurvy is somehow condescending but the corp selling false teeth along with their sugar buckets is somehow commendable.</div><br/><div id="42263719" class="c"><input type="checkbox" id="c-42263719" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42261179">root</a><span>|</span><a href="#42263587">parent</a><span>|</span><a href="#42261026">next</a><span>|</span><label class="collapse" for="c-42263719">[-]</label><label class="expand" for="c-42263719">[1 more]</label></div><br/><div class="children"><div class="content">Knowing non-algol languages won&#x27;t make editor actions any less useful for algol-like. If anything, it&#x27;ll just make you pretend that you don&#x27;t need such and as such will end up less productive than you could be.<p>And editor actions can be useful for any language which either allow you to edit things, or has more than one way to do the same thing (among a bunch of other things), which includes basically everything. Of course editor functionality isn&#x27;t a thing that&#x27;d be 100% beneficial 100% of the time, but it&#x27;s plenty above 0% if you don&#x27;t purposefully ignore it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42261026" class="c"><input type="checkbox" id="c-42261026" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#42261179">prev</a><span>|</span><a href="#42261957">next</a><span>|</span><label class="collapse" for="c-42261026">[-]</label><label class="expand" for="c-42261026">[6 more]</label></div><br/><div class="children"><div class="content">I think simpler is better when it comes to structured editing. Recursive teXt has the advantage that it proposes a simple block structure built into the text itself [1]. Of course, you will need to design your language to take advantage of this block structure.<p>[1] <a href="http:&#x2F;&#x2F;recursivetext.com" rel="nofollow">http:&#x2F;&#x2F;recursivetext.com</a></div><br/><div id="42261919" class="c"><input type="checkbox" id="c-42261919" checked=""/><div class="controls bullet"><span class="by">computably</span><span>|</span><a href="#42261026">parent</a><span>|</span><a href="#42261957">next</a><span>|</span><label class="collapse" for="c-42261919">[-]</label><label class="expand" for="c-42261919">[5 more]</label></div><br/><div class="children"><div class="content">Since Lisp has been around since 1960... Congratulations, you&#x27;re only about 64 years late.</div><br/><div id="42262259" class="c"><input type="checkbox" id="c-42262259" checked=""/><div class="controls bullet"><span class="by">practal</span><span>|</span><a href="#42261026">root</a><span>|</span><a href="#42261919">parent</a><span>|</span><a href="#42261957">next</a><span>|</span><label class="collapse" for="c-42262259">[-]</label><label class="expand" for="c-42262259">[4 more]</label></div><br/><div class="children"><div class="content">No doubt, brackets of course also convey structure. But I think indentation 
is better for visualising block structure. Inside these blocks, you can still use brackets, and errors like missing opening or closing brackets  will not spill over into other blocks.<p>And yeah, I am definitely coming for Lisp.</div><br/><div id="42263348" class="c"><input type="checkbox" id="c-42263348" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42261026">root</a><span>|</span><a href="#42262259">parent</a><span>|</span><a href="#42261957">next</a><span>|</span><label class="collapse" for="c-42263348">[-]</label><label class="expand" for="c-42263348">[3 more]</label></div><br/><div class="children"><div class="content">I wrote a racket function that would need 35 levels of indentation ten minutes ago. White space isn&#x27;t coming for lisps until we figure out 12 dimensional displays.</div><br/><div id="42263425" class="c"><input type="checkbox" id="c-42263425" checked=""/><div class="controls bullet"><span class="by">cjfd</span><span>|</span><a href="#42261026">root</a><span>|</span><a href="#42263348">parent</a><span>|</span><a href="#42261957">next</a><span>|</span><label class="collapse" for="c-42263425">[-]</label><label class="expand" for="c-42263425">[2 more]</label></div><br/><div class="children"><div class="content">Is a function that would need 35 levels of indentation a good idea? I have seen C code with about 12 levels of indentation and that was not too great.</div><br/><div id="42263558" class="c"><input type="checkbox" id="c-42263558" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42261026">root</a><span>|</span><a href="#42263425">parent</a><span>|</span><a href="#42261957">next</a><span>|</span><label class="collapse" for="c-42263558">[-]</label><label class="expand" for="c-42263558">[1 more]</label></div><br/><div class="children"><div class="content">What other languages use syntax for lisps use function applications for.<p>Viz. the array reference a[0] in algols is a function application in lisps (vector-ref a 0).<p>The same is true for everything else. Semantic white space in such a language is a terrible idea as everyone eventually finds out.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42261957" class="c"><input type="checkbox" id="c-42261957" checked=""/><div class="controls bullet"><span class="by">sudahtigabulan</span><span>|</span><a href="#42261026">prev</a><span>|</span><label class="collapse" for="c-42261957">[-]</label><label class="expand" for="c-42261957">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it is now clear to me that there is ongoing work on structured editing which either doesn’t know about incremental parsing in general, or Tim’s algorithms specifically. I hope this post serves as a useful advert to such folk<p>I&#x27;m curious about this unnamed ongoing work (that is unaware of incremental parsing).<p>Anyone know what he is referring to?</div><br/><div id="42262509" class="c"><input type="checkbox" id="c-42262509" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#42261957">parent</a><span>|</span><label class="collapse" for="c-42262509">[-]</label><label class="expand" for="c-42262509">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know specifically - but even now, i still end up having to explain to people that incremental parsing&#x2F;lexing (particularly without error recovery) is not hard, it is not really complicated, and as the author here said, Tim (et al) have made beautiful algorithms that make this stuff easy.<p>Heck, incremental lexing is even easy to explain.
For each token, track where the lexer <i>actually looked</i> in the input stream to make decisions.  Any time that part of the input stream changes, every token to actually look at the changed portion of the input stream is re-lexed, and if the result changes, keep re-lexing until the before&#x2F;after tokenstreams sync up again or you run out of input.  That&#x27;s it.<p>You can also make a dumber version that statically calculates the maximum lookahead (lookbehind if you support that too)  of the entire grammer, or the maximum possible lookahead per token, and uses that instead of tracking the actual lookahead used.  
In practice, this is often harder than just tracking the actual lookahead used.<p>In an LL system like ANTLR, incremental parsing is very similar - since it generates top-down parsers, it&#x27;s the same basic theory - track what token ranges were looked at as you parse.
During incremental update, only descend into portions of the parse tree where the token ranges looked at contain modified tokens.<p>Bottom up is trickier.
Error recovery is the meaningfully tricky part in all of this.<p>Before tree-sitter, I was constantly explaining this stuff to people (I followed the projects that these algorithms came out of - ENSEMBLE, HARMONIA, etc).
After more people get that there are ways of doing this, but you still run into people who are re-creating things we solved in pretty great ways many years ago.</div><br/></div></div></div></div></div></div></div></div></div></body></html>