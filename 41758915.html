<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728291677326" as="style"/><link rel="stylesheet" href="styles.css?v=1728291677326"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.drewolson.org/gleam-is-pragmatic/">Gleam Is Pragmatic</a> <span class="domain">(<a href="https://blog.drewolson.org">blog.drewolson.org</a>)</span></div><div class="subtext"><span>crowdhailer</span> | <span>100 comments</span></div><br/><div><div id="41760836" class="c"><input type="checkbox" id="c-41760836" checked=""/><div class="controls bullet"><span class="by">jazzypants</span><span>|</span><a href="#41763978">next</a><span>|</span><label class="collapse" for="c-41760836">[-]</label><label class="expand" for="c-41760836">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I won’t fall into the trap of trying to define Monads in this post. Instead, let’s talk about monadic-style APIs – that is, APIs that allow you to do a bunch of things one after another, with the ability to use the result of a previous computation in the next computation, and also allows some logic to happen between steps.<p>Am I crazy, or did he just give a really good definition of monads in programming? I think that it benefits by not letting itself get bogged down in Category Theory nomenclature which doesn&#x27;t actually matter when programming.</div><br/><div id="41761850" class="c"><input type="checkbox" id="c-41761850" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41760836">parent</a><span>|</span><a href="#41763981">next</a><span>|</span><label class="collapse" for="c-41761850">[-]</label><label class="expand" for="c-41761850">[1 more]</label></div><br/><div class="children"><div class="content">He described a problem people use monads to solve, not monads themselves.<p>Haskell people do talk about monadic vs. applicative combinators that are different by whether you can use the results of a previous step on the next ones. But that doesn&#x27;t have a direct relation with the actual definition of those.<p>But yes, if you are teaching a programming language that uses monads to someone, you will probably want to explain the problem they solve, not the actual structures. As most things in math, the structures become obvious once you understand the problem.</div><br/></div></div><div id="41763981" class="c"><input type="checkbox" id="c-41763981" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#41760836">parent</a><span>|</span><a href="#41761850">prev</a><span>|</span><a href="#41761583">next</a><span>|</span><label class="collapse" for="c-41763981">[-]</label><label class="expand" for="c-41763981">[1 more]</label></div><br/><div class="children"><div class="content">Not really. The big important part of monads is flattening&#x2F;unnesting the output.<p>Basically, if you can convert a `Foo&lt;T&gt;` into a `Foo&lt;U&gt;` by applying a function `T -&gt; U`, it&#x27;s a monoid. Think `map` or `fold`.<p>But if you can convert a `Foo&lt;T&gt;` into a `Foo&lt;U&gt;` by applying a function `T -&gt; Foo&lt;U&gt;`, it&#x27;s a monad. Flattening is &quot;some logic&quot;, but not any logic, it&#x27;s inherent to `Foo&lt;&gt;` itself.</div><br/></div></div><div id="41761583" class="c"><input type="checkbox" id="c-41761583" checked=""/><div class="controls bullet"><span class="by">bos</span><span>|</span><a href="#41760836">parent</a><span>|</span><a href="#41763981">prev</a><span>|</span><a href="#41762178">next</a><span>|</span><label class="collapse" for="c-41761583">[-]</label><label class="expand" for="c-41761583">[1 more]</label></div><br/><div class="children"><div class="content">No, this isn’t a good description of monads. It merely describes a case that shows up sometimes.</div><br/></div></div><div id="41762178" class="c"><input type="checkbox" id="c-41762178" checked=""/><div class="controls bullet"><span class="by">memco</span><span>|</span><a href="#41760836">parent</a><span>|</span><a href="#41761583">prev</a><span>|</span><a href="#41763978">next</a><span>|</span><label class="collapse" for="c-41762178">[-]</label><label class="expand" for="c-41762178">[3 more]</label></div><br/><div class="children"><div class="content">Yin the OOP world I’ve seen this pattern called chaining : usually either method or object chaining.</div><br/><div id="41763608" class="c"><input type="checkbox" id="c-41763608" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#41760836">root</a><span>|</span><a href="#41762178">parent</a><span>|</span><a href="#41762316">next</a><span>|</span><label class="collapse" for="c-41763608">[-]</label><label class="expand" for="c-41763608">[1 more]</label></div><br/><div class="children"><div class="content">Smalltalk (and Dart) also have &quot;cascading&quot; which is method chaining with special supporting syntax e.g. in ST you&#x27;d send four different messages to the same object with something like<p><pre><code>    scene add: sprite; 
          add: otherSprite;
          setBackGround: stage;
          start
</code></pre>
I&#x27;m not sure if it matches the &quot;reuse values from previous computation&quot; but it should since messages will affect the object, you just don&#x27;t have local variables.</div><br/></div></div><div id="41762316" class="c"><input type="checkbox" id="c-41762316" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#41760836">root</a><span>|</span><a href="#41762178">parent</a><span>|</span><a href="#41763608">prev</a><span>|</span><a href="#41763978">next</a><span>|</span><label class="collapse" for="c-41762316">[-]</label><label class="expand" for="c-41762316">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a style I really enjoy, and it&#x27;s definitely not exclusive to one language or paradigm, exactly. I see it as more of less of a kind with pipelines in Unix shells, too.<p>In Scala, a language with OOP heritage and support, plus lots of functional programming features, some of the most common methods you use in such chains <i>are</i> monads.</div><br/></div></div></div></div></div></div><div id="41763978" class="c"><input type="checkbox" id="c-41763978" checked=""/><div class="controls bullet"><span class="by">zombot</span><span>|</span><a href="#41760836">prev</a><span>|</span><a href="#41762215">next</a><span>|</span><label class="collapse" for="c-41763978">[-]</label><label class="expand" for="c-41763978">[1 more]</label></div><br/><div class="children"><div class="content">The syntax doesn&#x27;t look like it supports partial application? Big no-no. Also, no compilation to native code. Another big no-no.</div><br/></div></div><div id="41762215" class="c"><input type="checkbox" id="c-41762215" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41763978">prev</a><span>|</span><a href="#41759704">next</a><span>|</span><label class="collapse" for="c-41762215">[-]</label><label class="expand" for="c-41762215">[1 more]</label></div><br/><div class="children"><div class="content">Gleam&#x27;s 1.0 release was in May and it&#x27;s still adding major features.<p>JavaScript support looks interesting. Browsing the package repo, I don&#x27;t see how to tell which packages are supported on Erlang&#x27;s VM, when compiling to JavaScript, or both. JavaScript-specific documentation seems pretty thin so far?</div><br/></div></div><div id="41759704" class="c"><input type="checkbox" id="c-41759704" checked=""/><div class="controls bullet"><span class="by">patte</span><span>|</span><a href="#41762215">prev</a><span>|</span><a href="#41759775">next</a><span>|</span><label class="collapse" for="c-41759704">[-]</label><label class="expand" for="c-41759704">[1 more]</label></div><br/><div class="children"><div class="content">This is a very concise overview! I have made a small example chat app [1] to explore two interesting aspects of gleam: BEAM OTP and compilation to javascript (typescript actually). If anyone is interested...<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;patte&#x2F;gleam-playground">https:&#x2F;&#x2F;github.com&#x2F;patte&#x2F;gleam-playground</a></div><br/></div></div><div id="41759775" class="c"><input type="checkbox" id="c-41759775" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#41759704">prev</a><span>|</span><a href="#41759321">next</a><span>|</span><label class="collapse" for="c-41759775">[-]</label><label class="expand" for="c-41759775">[23 more]</label></div><br/><div class="children"><div class="content">Gleam looks nice but if an F# comparisons was added, I think that would come out ahead based on the authors priorities.</div><br/><div id="41760788" class="c"><input type="checkbox" id="c-41760788" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#41759775">parent</a><span>|</span><a href="#41760344">next</a><span>|</span><label class="collapse" for="c-41760788">[-]</label><label class="expand" for="c-41760788">[14 more]</label></div><br/><div class="children"><div class="content">One thing I dislike with erlang based languages (both gleam and elixir) is that they use “&lt;&gt;” for string concatenation.<p>In F#, “&lt;&gt;” is the equivalent of “!=“. Postgres also uses &lt;&gt; for inequality so my queries and f# code have that consistency.</div><br/><div id="41761314" class="c"><input type="checkbox" id="c-41761314" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41760788">parent</a><span>|</span><a href="#41762545">next</a><span>|</span><label class="collapse" for="c-41761314">[-]</label><label class="expand" for="c-41761314">[3 more]</label></div><br/><div class="children"><div class="content">Ha, ok so I gotta give one of these &quot;that&#x27;s a really strange thing to get hung up on&quot; responses.<p>Erlang and Elixir don&#x27;t overload the `+` operator.  In fact, they don&#x27;t overload ANY operators.  If you can forgive the syntactic choice of the operator itself (which I think it pretty fair considering Erlang predates Postgres by a decade and F# by two decades), this allows them to be dynamic while maintaining a pretty high level of runtime type safety.  For example, one of the &quot;subtle bugs&quot; people refer to when criticizing dynamic languages (even strongly typed dynamic languages) is the following would work when both args are given strings or numbers:<p><pre><code>    function add(a, b) { a + b }
</code></pre>
Erlang&#x2F;Elixir eliminate this particular subtle bug (and it goes beyond strings and numbers) since:<p><pre><code>    def add(a, b), do: a + b
</code></pre>
will only work on numbers and raise if given strings.</div><br/><div id="41763099" class="c"><input type="checkbox" id="c-41763099" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41761314">parent</a><span>|</span><a href="#41762134">next</a><span>|</span><label class="collapse" for="c-41763099">[-]</label><label class="expand" for="c-41763099">[1 more]</label></div><br/><div class="children"><div class="content">ML (which is the precursor to OCaml&#x2F;f#), pascal, basic, and sql use &lt;&gt;. 
If you consider that &lt;, &lt;=, etc are used as comparison operators it makes sense for &lt;&gt; to be in that camp. I actually never thought of it that way.<p>Interesting table here highlighting old programming languages <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Relational_operator#Standard_relational_operators" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Relational_operator#Standard_r...</a></div><br/></div></div><div id="41762134" class="c"><input type="checkbox" id="c-41762134" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41761314">parent</a><span>|</span><a href="#41763099">prev</a><span>|</span><a href="#41762545">next</a><span>|</span><label class="collapse" for="c-41762134">[-]</label><label class="expand" for="c-41762134">[1 more]</label></div><br/><div class="children"><div class="content">It doesn’t predate sql and certainly not it’s use in mathematics.  There are other options for concatenation so this is an unfortunate error.<p>Shouldn’t copy Erlang, otherwise might as well use it.</div><br/></div></div></div></div><div id="41762545" class="c"><input type="checkbox" id="c-41762545" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41760788">parent</a><span>|</span><a href="#41761314">prev</a><span>|</span><a href="#41762140">next</a><span>|</span><label class="collapse" for="c-41762545">[-]</label><label class="expand" for="c-41762545">[3 more]</label></div><br/><div class="children"><div class="content">&gt; One thing I dislike with erlang based languages (both gleam and elixir) is that they use “&lt;&gt;” for string concatenation.<p>Erlang doesn&#x27;t use &lt;&gt; for concatenation so it&#x27;s odd to name it in this comment, like that language and its developers have anything to do with your complaint. If it upsets you so much, lay it at the feet of the actual groups that chose &lt;&gt; for concatenation instead.</div><br/><div id="41763021" class="c"><input type="checkbox" id="c-41763021" checked=""/><div class="controls bullet"><span class="by">devmunchies</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41762545">parent</a><span>|</span><a href="#41762140">next</a><span>|</span><label class="collapse" for="c-41763021">[-]</label><label class="expand" for="c-41763021">[2 more]</label></div><br/><div class="children"><div class="content">I just assumed it was an erlang thing since elixir and gleam both do it. Now it seems even more odd that erlang doesn’t do it but they both chose it.</div><br/><div id="41763727" class="c"><input type="checkbox" id="c-41763727" checked=""/><div class="controls bullet"><span class="by">trenchgun</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41763021">parent</a><span>|</span><a href="#41762140">next</a><span>|</span><label class="collapse" for="c-41763727">[-]</label><label class="expand" for="c-41763727">[1 more]</label></div><br/><div class="children"><div class="content">- in Haskell &lt;&gt; is binary operator of a Monoid<p>- in Elixir &lt;&gt; is Binary concatenation operator. Concatenates two binaries. This seems like it might be kind of a joke, actually, purposefully confusing &quot;binary operator&quot; with &quot;an operator that takes two binaries&quot; for humorous effect?<p>- in Gleam &lt;&gt; is string concatenation operator<p>As far as I can see it, they are taking inspiration from Haskell, where &lt;&gt; denotes the monoid binary operation, one concrete example being in the monoid of Lists binary operator being list concatenation, of which String is one example.<p>But really, &lt;&gt; for inequality is also kind of dumb and nonstandard idea (from mathematical notation perspective), originating from Algol. != which C popularized is more clear, and corresponds to the mathematical symbol, of course =&#x2F;= would be even more close, but that is one more character.<p>ML originally used &lt;&gt; for inequality, following the standard (in CS) of Algol, and it was Haskell which deviated from that tradition. So F# uses still Algol tradition, but Haskell uses &#x2F;= and C and others use !=, for more mathematical and logical notation.</div><br/></div></div></div></div></div></div><div id="41762140" class="c"><input type="checkbox" id="c-41762140" checked=""/><div class="controls bullet"><span class="by">greydius</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41760788">parent</a><span>|</span><a href="#41762545">prev</a><span>|</span><a href="#41761485">next</a><span>|</span><label class="collapse" for="c-41762140">[-]</label><label class="expand" for="c-41762140">[1 more]</label></div><br/><div class="children"><div class="content">One thing I hate about F# and SQL is that they use &lt;&gt; as a &quot;not equals&quot; operator. In Haskell, &lt;&gt; is the binary operator of any Semigroup instance.</div><br/></div></div><div id="41761485" class="c"><input type="checkbox" id="c-41761485" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41760788">parent</a><span>|</span><a href="#41762140">prev</a><span>|</span><a href="#41762762">next</a><span>|</span><label class="collapse" for="c-41761485">[-]</label><label class="expand" for="c-41761485">[5 more]</label></div><br/><div class="children"><div class="content">Well binaries are &lt;&lt;&gt;&gt; so that&#x27;s consistent at least.  And &lt;&lt;&gt;&gt; is quotation marks in several languages, including French.</div><br/><div id="41763640" class="c"><input type="checkbox" id="c-41763640" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41761485">parent</a><span>|</span><a href="#41762143">next</a><span>|</span><label class="collapse" for="c-41763640">[-]</label><label class="expand" for="c-41763640">[1 more]</label></div><br/><div class="children"><div class="content">« and » are also the hyperoperators in perl6&#x2F;raku<p><a href="https:&#x2F;&#x2F;docs.perl6.org&#x2F;language&#x2F;operators#Hyper_operators" rel="nofollow">https:&#x2F;&#x2F;docs.perl6.org&#x2F;language&#x2F;operators#Hyper_operators</a></div><br/></div></div><div id="41762143" class="c"><input type="checkbox" id="c-41762143" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41761485">parent</a><span>|</span><a href="#41763640">prev</a><span>|</span><a href="#41762762">next</a><span>|</span><label class="collapse" for="c-41762143">[-]</label><label class="expand" for="c-41762143">[3 more]</label></div><br/><div class="children"><div class="content">Guillemets are not the same and have their own symbols.</div><br/><div id="41762243" class="c"><input type="checkbox" id="c-41762243" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41762143">parent</a><span>|</span><a href="#41762762">next</a><span>|</span><label class="collapse" for="c-41762243">[-]</label><label class="expand" for="c-41762243">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, ok.  Go back to 1986 and tell the Erlang team to go use Unicode guillemets</div><br/><div id="41762983" class="c"><input type="checkbox" id="c-41762983" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41762243">parent</a><span>|</span><a href="#41762762">next</a><span>|</span><label class="collapse" for="c-41762983">[-]</label><label class="expand" for="c-41762983">[1 more]</label></div><br/><div class="children"><div class="content">Gleam is from the past few years.</div><br/></div></div></div></div></div></div></div></div><div id="41762762" class="c"><input type="checkbox" id="c-41762762" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41760788">parent</a><span>|</span><a href="#41761485">prev</a><span>|</span><a href="#41760344">next</a><span>|</span><label class="collapse" for="c-41762762">[-]</label><label class="expand" for="c-41762762">[1 more]</label></div><br/><div class="children"><div class="content">Then Gleam (and others) use “|&gt;” when piping with “|” would make more sense, except that’s a bit wise OR, not to be confused with “||” which is… string concatenation (in Postgres).</div><br/></div></div></div></div><div id="41760344" class="c"><input type="checkbox" id="c-41760344" checked=""/><div class="controls bullet"><span class="by">cipehr</span><span>|</span><a href="#41759775">parent</a><span>|</span><a href="#41760788">prev</a><span>|</span><a href="#41762784">next</a><span>|</span><label class="collapse" for="c-41760344">[-]</label><label class="expand" for="c-41760344">[2 more]</label></div><br/><div class="children"><div class="content">The author links to a blog post talking about railway oriented programming in f#.. it might be fair to assume they are aware of f#</div><br/><div id="41762696" class="c"><input type="checkbox" id="c-41762696" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41760344">parent</a><span>|</span><a href="#41762784">next</a><span>|</span><label class="collapse" for="c-41762696">[-]</label><label class="expand" for="c-41762696">[1 more]</label></div><br/><div class="children"><div class="content">All the more reason to include it in the comparison.</div><br/></div></div></div></div><div id="41762784" class="c"><input type="checkbox" id="c-41762784" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#41759775">parent</a><span>|</span><a href="#41760344">prev</a><span>|</span><a href="#41761265">next</a><span>|</span><label class="collapse" for="c-41762784">[-]</label><label class="expand" for="c-41762784">[2 more]</label></div><br/><div class="children"><div class="content">I converted the example on the Gleam home page [0] to F#:<p><pre><code>    let spawn_task i =
        async {
            let n = string i
            printfn $&quot;Hello from {n}&quot;
        }

    &#x2F;&#x2F; Run loads of threads, no problem
    seq { 0..200_000 }
        |&gt; Seq.map spawn_task
        |&gt; Async.Parallel
        |&gt; Async.RunSynchronously
        |&gt; ignore
</code></pre>
The two are pretty similar, but I would give F# the nod on this one example because it doesn&#x27;t actually have to create a list of 200,000 elements, doesn&#x27;t require an explicit &quot;main&quot; function, and requires fewer brackets&#x2F;parens.<p>[0]: <a href="https:&#x2F;&#x2F;gleam.run&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gleam.run&#x2F;</a></div><br/><div id="41763671" class="c"><input type="checkbox" id="c-41763671" checked=""/><div class="controls bullet"><span class="by">jorams</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41762784">parent</a><span>|</span><a href="#41761265">next</a><span>|</span><label class="collapse" for="c-41763671">[-]</label><label class="expand" for="c-41763671">[1 more]</label></div><br/><div class="children"><div class="content">The creation of a list in the Gleam example is a choice, you could replace &#x27;list&#x27; with &#x27;iterator&#x27; and it would be lazy.</div><br/></div></div></div></div><div id="41761265" class="c"><input type="checkbox" id="c-41761265" checked=""/><div class="controls bullet"><span class="by">stonethrowaway</span><span>|</span><a href="#41759775">parent</a><span>|</span><a href="#41762784">prev</a><span>|</span><a href="#41759321">next</a><span>|</span><label class="collapse" for="c-41761265">[-]</label><label class="expand" for="c-41761265">[4 more]</label></div><br/><div class="children"><div class="content">I brought up the next logical step in pragmatism, which is that c# is adopting a lot of f# things and hence on a solid path to becoming the pragmatic language du jour, however my comment is currently at -4, probably flagged. To be fair I did skip a half-step. Maybe rabid fanboys but unlikely, probably just passionate posters that don’t see where things are headed.</div><br/><div id="41761346" class="c"><input type="checkbox" id="c-41761346" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41761265">parent</a><span>|</span><a href="#41762707">next</a><span>|</span><label class="collapse" for="c-41761346">[-]</label><label class="expand" for="c-41761346">[2 more]</label></div><br/><div class="children"><div class="content">Or maybe your &quot;no one else is smart&#x2F;brave enough to say it&quot; wrapper detracted from your message.<p>Additionally, throwing yet more syntax&#x2F;features at a language to make it pseudo-functional doesn&#x27;t appeal to everyone. A grab bag of features doesn&#x27;t an appealing language make (for some).</div><br/></div></div><div id="41762707" class="c"><input type="checkbox" id="c-41762707" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#41759775">root</a><span>|</span><a href="#41761265">parent</a><span>|</span><a href="#41761346">prev</a><span>|</span><a href="#41759321">next</a><span>|</span><label class="collapse" for="c-41762707">[-]</label><label class="expand" for="c-41762707">[1 more]</label></div><br/><div class="children"><div class="content">C# is indeed adopting some functional techniques from F#, but C# is still so bogged down with imperative cruft that the resulting combination of styles is a mess.</div><br/></div></div></div></div></div></div><div id="41759321" class="c"><input type="checkbox" id="c-41759321" checked=""/><div class="controls bullet"><span class="by">rossng</span><span>|</span><a href="#41759775">prev</a><span>|</span><a href="#41759143">next</a><span>|</span><label class="collapse" for="c-41759321">[-]</label><label class="expand" for="c-41759321">[10 more]</label></div><br/><div class="children"><div class="content">The `use` syntax is interesting - don&#x27;t recall seeing anything similar before. But I&#x27;m struggling to understand how exactly it is executed and a glance at the Gleam docs didn&#x27;t help.<p>Is the `use` statement blocking (in which case it doesn&#x27;t seem that useful)? Or does it return immediately and then await at the point of use of the value it binds?</div><br/><div id="41763935" class="c"><input type="checkbox" id="c-41763935" checked=""/><div class="controls bullet"><span class="by">cprecioso</span><span>|</span><a href="#41759321">parent</a><span>|</span><a href="#41759412">next</a><span>|</span><label class="collapse" for="c-41763935">[-]</label><label class="expand" for="c-41763935">[1 more]</label></div><br/><div class="children"><div class="content">It really reminds me of LiveScript&#x27;s &quot;back-calls&quot; [1], which were a solution for callback hell in JS.<p>1: <a href="https:&#x2F;&#x2F;livescript.net&#x2F;#:~:text=Backcalls%20are%20very%20useful" rel="nofollow">https:&#x2F;&#x2F;livescript.net&#x2F;#:~:text=Backcalls%20are%20very%20use...</a></div><br/></div></div><div id="41759412" class="c"><input type="checkbox" id="c-41759412" checked=""/><div class="controls bullet"><span class="by">jyjasdfsssd</span><span>|</span><a href="#41759321">parent</a><span>|</span><a href="#41763935">prev</a><span>|</span><a href="#41759960">next</a><span>|</span><label class="collapse" for="c-41759412">[-]</label><label class="expand" for="c-41759412">[4 more]</label></div><br/><div class="children"><div class="content">It is syntax sugar for CPS [1].<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Continuation-passing_style" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Continuation-passing_style</a><p>EDIT: I believe prior art is Koka&#x27;s with statement: <a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-with" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-with</a></div><br/><div id="41759602" class="c"><input type="checkbox" id="c-41759602" checked=""/><div class="controls bullet"><span class="by">rossng</span><span>|</span><a href="#41759321">root</a><span>|</span><a href="#41759412">parent</a><span>|</span><a href="#41759960">next</a><span>|</span><label class="collapse" for="c-41759602">[-]</label><label class="expand" for="c-41759602">[3 more]</label></div><br/><div class="children"><div class="content">Hmm, it definitely looks more interesting in combination with effect handlers. Still not sure I find it super compelling in Gleam vs just not using callbacks.</div><br/><div id="41759946" class="c"><input type="checkbox" id="c-41759946" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41759321">root</a><span>|</span><a href="#41759602">parent</a><span>|</span><a href="#41759960">next</a><span>|</span><label class="collapse" for="c-41759946">[-]</label><label class="expand" for="c-41759946">[2 more]</label></div><br/><div class="children"><div class="content">It’s a generalization of async&#x2F;await syntax in languages like JavaScript or Swift. I like that it provides a generalized syntax that could be used for coroutines, generators, or async&#x2F;await without adding any of those specifically to the language syntactically.<p>One level of callback nesting in a function is totally fine, two is a bit confusing, but if you have many async things going on do you really want 10, 15, 20 levels of nesting? What to do about loops?<p>I certainly greatly prefer async programming with async&#x2F;await languages that keep the appearance of linear function execution to stacking my callbacks and having a ton of nesting everywhere</div><br/><div id="41760601" class="c"><input type="checkbox" id="c-41760601" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#41759321">root</a><span>|</span><a href="#41759946">parent</a><span>|</span><a href="#41759960">next</a><span>|</span><label class="collapse" for="c-41760601">[-]</label><label class="expand" for="c-41760601">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like the new “capabilities” stuff in Scala.</div><br/></div></div></div></div></div></div></div></div><div id="41759960" class="c"><input type="checkbox" id="c-41759960" checked=""/><div class="controls bullet"><span class="by">taberiand</span><span>|</span><a href="#41759321">parent</a><span>|</span><a href="#41759412">prev</a><span>|</span><a href="#41759832">next</a><span>|</span><label class="collapse" for="c-41759960">[-]</label><label class="expand" for="c-41759960">[1 more]</label></div><br/><div class="children"><div class="content">The equivalent in F# is let!  (F# computation expressions are quite powerful); in  rust the ? operator. Other languages have similar features.<p>It&#x27;s syntactic sugar, but the readability is worth it</div><br/></div></div><div id="41759832" class="c"><input type="checkbox" id="c-41759832" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#41759321">parent</a><span>|</span><a href="#41759960">prev</a><span>|</span><a href="#41762157">next</a><span>|</span><label class="collapse" for="c-41759832">[-]</label><label class="expand" for="c-41759832">[1 more]</label></div><br/><div class="children"><div class="content">You can do something similar in OCaml (as an operator defined at the library level, not a specialized new syntax): <a href="https:&#x2F;&#x2F;github.com&#x2F;yawaramin&#x2F;letops&#x2F;blob&#x2F;6954adb65f1156597405149d5d0116599b1d2049&#x2F;letops.mli#L18">https:&#x2F;&#x2F;github.com&#x2F;yawaramin&#x2F;letops&#x2F;blob&#x2F;6954adb65f115659740...</a></div><br/></div></div><div id="41762157" class="c"><input type="checkbox" id="c-41762157" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41759321">parent</a><span>|</span><a href="#41759832">prev</a><span>|</span><a href="#41760427">next</a><span>|</span><label class="collapse" for="c-41762157">[-]</label><label class="expand" for="c-41762157">[1 more]</label></div><br/><div class="children"><div class="content">Everything after the line containing &#x27;&lt;-&#x27; happens in a callback.<p>Since it&#x27;s a callback, I assume it&#x27;s up to the function whether to call it, when to call it, and how many times to call it, so this can implement control statements.<p>I would guess that it also allows it to be async (when the callback isn&#x27;t called until after an I&#x2F;O operation).</div><br/></div></div><div id="41760427" class="c"><input type="checkbox" id="c-41760427" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#41759321">parent</a><span>|</span><a href="#41762157">prev</a><span>|</span><a href="#41759143">next</a><span>|</span><label class="collapse" for="c-41760427">[-]</label><label class="expand" for="c-41760427">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s similar to koka&#x27;s &#x27;with&#x27;.<p><a href="https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-with" rel="nofollow">https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-with</a></div><br/></div></div></div></div><div id="41759143" class="c"><input type="checkbox" id="c-41759143" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41759321">prev</a><span>|</span><a href="#41759087">next</a><span>|</span><label class="collapse" for="c-41759143">[-]</label><label class="expand" for="c-41759143">[4 more]</label></div><br/><div class="children"><div class="content">Wow, this is a great overview. I’ve been playing with Gleam a bit and this was really helpful. I’ll definitely refer to this later.<p>I’d like to dig into the OTP library (I’m curious if anyone has worked with it much?) and create a state chart library with it, but I’m still firmly in the “I don’t totally get it” camp with a few parts of Gleam. I don’t deny that it’s pragmatic. Maybe it’s more so that I’m not up to speed on functional patterns in general. I was for years, but took a hiatus to write code for a game engine and supporting infrastructure. It was so Wild West, but I kind of liked it in the end. Lots of impure, imperative code, haha.</div><br/><div id="41759548" class="c"><input type="checkbox" id="c-41759548" checked=""/><div class="controls bullet"><span class="by">okkdev</span><span>|</span><a href="#41759143">parent</a><span>|</span><a href="#41760720">next</a><span>|</span><label class="collapse" for="c-41759548">[-]</label><label class="expand" for="c-41759548">[2 more]</label></div><br/><div class="children"><div class="content">Most people use the OTP lib! There&#x27;s this super useful intro repo: <a href="https:&#x2F;&#x2F;github.com&#x2F;bcpeinhardt&#x2F;learn_otp_with_gleam">https:&#x2F;&#x2F;github.com&#x2F;bcpeinhardt&#x2F;learn_otp_with_gleam</a></div><br/><div id="41760025" class="c"><input type="checkbox" id="c-41760025" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41759143">root</a><span>|</span><a href="#41759548">parent</a><span>|</span><a href="#41760720">next</a><span>|</span><label class="collapse" for="c-41760025">[-]</label><label class="expand" for="c-41760025">[1 more]</label></div><br/><div class="children"><div class="content">Incredible, thank you so much! This is exactly what I need.</div><br/></div></div></div></div><div id="41760720" class="c"><input type="checkbox" id="c-41760720" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#41759143">parent</a><span>|</span><a href="#41759548">prev</a><span>|</span><a href="#41759087">next</a><span>|</span><label class="collapse" for="c-41760720">[-]</label><label class="expand" for="c-41760720">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried to get my head around functional programming and also OTP but I also just never got my head around it.<p>Functional programming seems too limiting and OTP seems more complicated than I would have hoped for a supposedly distributed concurrency system.<p>I&#x27;m sure it&#x27;s just a skill issue on my part. Right now I&#x27;m way too rust-brained. I&#x27;ve heard lots of things about gleam being good for productivity but I don&#x27;t feel unproductive writing web apps in Rust but I felt every unproductive trying to write a non-trivial web app in gleam</div><br/></div></div></div></div><div id="41759087" class="c"><input type="checkbox" id="c-41759087" checked=""/><div class="controls bullet"><span class="by">beanjuiceII</span><span>|</span><a href="#41759143">prev</a><span>|</span><a href="#41759154">next</a><span>|</span><label class="collapse" for="c-41759087">[-]</label><label class="expand" for="c-41759087">[12 more]</label></div><br/><div class="children"><div class="content">tried gleam but the fact i have to manually serialize&#x2F;deserialize things, pretty annoying, that doesn&#x27;t seem very pragmatic</div><br/><div id="41759159" class="c"><input type="checkbox" id="c-41759159" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41759087">parent</a><span>|</span><a href="#41760079">next</a><span>|</span><label class="collapse" for="c-41759159">[-]</label><label class="expand" for="c-41759159">[8 more]</label></div><br/><div class="children"><div class="content">Isn’t manual ser&#x2F;de pretty common? I like it personally. Being explicit at program boundaries usually means far fewer bugs inside the program. In JS I can pile whatever JSON I want into an object, but eventually I need to throw Zod or something at it to tame the crazy.<p>Maybe a generic “pile this data into this value and pretend it’s safe” tool might be nice for prototyping.</div><br/><div id="41759323" class="c"><input type="checkbox" id="c-41759323" checked=""/><div class="controls bullet"><span class="by">beanjuiceII</span><span>|</span><a href="#41759087">root</a><span>|</span><a href="#41759159">parent</a><span>|</span><a href="#41760079">next</a><span>|</span><label class="collapse" for="c-41759323">[-]</label><label class="expand" for="c-41759323">[7 more]</label></div><br/><div class="children"><div class="content">i dont think manual ser&#x2F;de is common at all, and languages like dart where it was used is a massive pain point for people so much that they are adding macros to the language and the first macro they add is for serialization. whats not explicit about saying hey i have a struct this is the data i expect, serialize&#x2F;deseralize in this shape, validation is a another but separate concern. in javascript you are not doing anything manually so i&#x27;m not sure why thats an example?</div><br/><div id="41759746" class="c"><input type="checkbox" id="c-41759746" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41759087">root</a><span>|</span><a href="#41759323">parent</a><span>|</span><a href="#41759752">next</a><span>|</span><label class="collapse" for="c-41759746">[-]</label><label class="expand" for="c-41759746">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit confused. How can you control how your data is serialized if not manually?  Are there languages that use some kind of magically-figures-it-out layer that negotiates the appropriate serialization on the fly?</div><br/><div id="41759815" class="c"><input type="checkbox" id="c-41759815" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#41759087">root</a><span>|</span><a href="#41759746">parent</a><span>|</span><a href="#41760781">next</a><span>|</span><label class="collapse" for="c-41759815">[-]</label><label class="expand" for="c-41759815">[2 more]</label></div><br/><div class="children"><div class="content">Many languages have some kind of macro or codegen system that allows serializing or deserializing based on type definitions. Eg (pseudocode):<p><pre><code>    @deriving(json)
    class Person:
      id: int
      name: str
</code></pre>
Would give you something like:<p><pre><code>    def parse(s: str): Person: ...
    def print(p: Person): str: ...</code></pre></div><br/><div id="41760160" class="c"><input type="checkbox" id="c-41760160" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41759087">root</a><span>|</span><a href="#41759815">parent</a><span>|</span><a href="#41760781">next</a><span>|</span><label class="collapse" for="c-41760160">[-]</label><label class="expand" for="c-41760160">[1 more]</label></div><br/><div class="children"><div class="content">I see, thanks.  I thought maybe we were talking about the choice of json vs something else being automatic and chosen at runtime.</div><br/></div></div></div></div><div id="41760781" class="c"><input type="checkbox" id="c-41760781" checked=""/><div class="controls bullet"><span class="by">googledocsftw</span><span>|</span><a href="#41759087">root</a><span>|</span><a href="#41759746">parent</a><span>|</span><a href="#41759815">prev</a><span>|</span><a href="#41759752">next</a><span>|</span><label class="collapse" for="c-41760781">[-]</label><label class="expand" for="c-41760781">[2 more]</label></div><br/><div class="children"><div class="content">C# (or more precisely .NET libraries) does it using reflection. Attributes let you adjust the behaviour.</div><br/><div id="41760898" class="c"><input type="checkbox" id="c-41760898" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41759087">root</a><span>|</span><a href="#41760781">parent</a><span>|</span><a href="#41759752">next</a><span>|</span><label class="collapse" for="c-41760898">[-]</label><label class="expand" for="c-41760898">[1 more]</label></div><br/><div class="children"><div class="content">Or with build-time source generation (because this specific pattern of reflection is AOT-unfriendly). It&#x27;s not as convenient if you are using default serializer options, but if you don&#x27;t - it ties together JsonTypeInfo&lt;T&gt; and JsonSerializerOptions, so it ends up being a slightly terser way to write it. I do prefer the Rust-style serde annotations however.<p><pre><code>  record User(string Name, DateOnly DoB);

  [JsonSerializable(typeof(User))]
  partial class SerializerContext: JsonSerializerContext;

  ...
  var user = new User(&quot;John&quot;, new(1984, 1, 1));
  var response = await http.PostAsJsonAsync(
    url, user, SerializerContext.Default.User);</code></pre></div><br/></div></div></div></div></div></div><div id="41759752" class="c"><input type="checkbox" id="c-41759752" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41759087">root</a><span>|</span><a href="#41759323">parent</a><span>|</span><a href="#41759746">prev</a><span>|</span><a href="#41760079">next</a><span>|</span><label class="collapse" for="c-41759752">[-]</label><label class="expand" for="c-41759752">[1 more]</label></div><br/><div class="children"><div class="content">Sorry I wasn’t clear; I meant to use JavaScript as an example where it isn’t manual.<p>Despite it being easy to use, I find I inevitably wind up requiring a lot of ceremony and effort to ensure it’s safe. I’m not a huge fan of automatic serialization in that it appears to work fine when sometimes it shouldn’t&#x2F;won’t. I agree that it’s a lot of effort though. I guess the question is if you want the effort up front or later on. I prefer up front, I guess.</div><br/></div></div></div></div></div></div><div id="41760079" class="c"><input type="checkbox" id="c-41760079" checked=""/><div class="controls bullet"><span class="by">__jonas</span><span>|</span><a href="#41759087">parent</a><span>|</span><a href="#41759159">prev</a><span>|</span><a href="#41761320">next</a><span>|</span><label class="collapse" for="c-41760079">[-]</label><label class="expand" for="c-41760079">[1 more]</label></div><br/><div class="children"><div class="content">I agree that the stdlib decoder functions aren&#x27;t the most ergonomic, but I think people are aware it&#x27;s a pain point and there is development in that are, these two packages for example:<p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;decode" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;decode</a><p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;toy&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;toy&#x2F;</a></div><br/></div></div><div id="41761320" class="c"><input type="checkbox" id="c-41761320" checked=""/><div class="controls bullet"><span class="by">wonger_</span><span>|</span><a href="#41759087">parent</a><span>|</span><a href="#41760079">prev</a><span>|</span><a href="#41759790">next</a><span>|</span><label class="collapse" for="c-41761320">[-]</label><label class="expand" for="c-41761320">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the complaints people have with Elm too. Json.Encode&#x2F;Decode is a pain</div><br/></div></div><div id="41759790" class="c"><input type="checkbox" id="c-41759790" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#41759087">parent</a><span>|</span><a href="#41761320">prev</a><span>|</span><a href="#41759154">next</a><span>|</span><label class="collapse" for="c-41759790">[-]</label><label class="expand" for="c-41759790">[1 more]</label></div><br/><div class="children"><div class="content">This is the biggest reason I cooled a bit on Gleam and whenever I want to do some backend stuff I&#x27;d much rather use Rust (using serde to convert to structs) or Elixir (put it in dynamic maps).<p>I wish Gleam would implement some kind of macro system, making a serde-like package possible.</div><br/></div></div></div></div><div id="41759154" class="c"><input type="checkbox" id="c-41759154" checked=""/><div class="controls bullet"><span class="by">atemerev</span><span>|</span><a href="#41759087">prev</a><span>|</span><a href="#41763310">next</a><span>|</span><label class="collapse" for="c-41759154">[-]</label><label class="expand" for="c-41759154">[21 more]</label></div><br/><div class="children"><div class="content">The greatest power of BEAM-based languages is the fully preemptive actor model. Nobody else supports it. This is a superpower, the solution of most problems with concurrent programming.<p>In Erland and Elixir, actors and actor-based concurrency hold the central place in the corresponding ecosystems, well supported by extensive documentation.<p>In Gleam, actors and OTP are an afterthought. They are there somewhere, but underdocumented and abandoned.</div><br/><div id="41759188" class="c"><input type="checkbox" id="c-41759188" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41759154">parent</a><span>|</span><a href="#41759354">next</a><span>|</span><label class="collapse" for="c-41759188">[-]</label><label class="expand" for="c-41759188">[2 more]</label></div><br/><div class="children"><div class="content">This is exactly what I want from Gleam. It does seem to be under documented and abandoned. Is there any understanding of why? Like you say, this seems like a super power. I see so much potential. A language that’s ergonomic, pragmatic as the author says, great performance, low-ish barrier to entry, etc. It seems like it could be an awesome tool for building highly reliable software that’s not so difficult to maintain.</div><br/><div id="41759209" class="c"><input type="checkbox" id="c-41759209" checked=""/><div class="controls bullet"><span class="by">cassepipe</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759188">parent</a><span>|</span><a href="#41759354">next</a><span>|</span><label class="collapse" for="c-41759209">[-]</label><label class="expand" for="c-41759209">[1 more]</label></div><br/><div class="children"><div class="content">It is a very young language that may explain the why</div><br/></div></div></div></div><div id="41759354" class="c"><input type="checkbox" id="c-41759354" checked=""/><div class="controls bullet"><span class="by">jatins</span><span>|</span><a href="#41759154">parent</a><span>|</span><a href="#41759188">prev</a><span>|</span><a href="#41761696">next</a><span>|</span><label class="collapse" for="c-41759354">[-]</label><label class="expand" for="c-41759354">[1 more]</label></div><br/><div class="children"><div class="content">this is Gleam OTP package <a href="https:&#x2F;&#x2F;github.com&#x2F;gleam-lang&#x2F;otp">https:&#x2F;&#x2F;github.com&#x2F;gleam-lang&#x2F;otp</a><p>I agree it&#x27;s underdocumented but doesn&#x27;t seem abandoned (has commits in last week)</div><br/></div></div><div id="41761696" class="c"><input type="checkbox" id="c-41761696" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#41759154">parent</a><span>|</span><a href="#41759354">prev</a><span>|</span><a href="#41760050">next</a><span>|</span><label class="collapse" for="c-41761696">[-]</label><label class="expand" for="c-41761696">[1 more]</label></div><br/><div class="children"><div class="content">Are there any articles that do a deeper dive into this?  I ask because straight up I&#x27;ve been curious about Gleam, but not enough to do a really deep dive because Elixir is too good and, like Erlang, is a very special kind of dynamic language that doesn&#x27;t leave me feel too lacking.<p>As I understand it, there have been a few &quot;high profile&quot; attempts to bring static typing to Erlang, all of which gave up when it came to typing messages.  Your comment essentially confirms my bias, but is Gleam making real strides in solving this, or is it poised to merely cater to those who demand static-typing with curly braces--everything-else-be-dammed?</div><br/></div></div><div id="41760050" class="c"><input type="checkbox" id="c-41760050" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#41759154">parent</a><span>|</span><a href="#41761696">prev</a><span>|</span><a href="#41759167">next</a><span>|</span><label class="collapse" for="c-41760050">[-]</label><label class="expand" for="c-41760050">[5 more]</label></div><br/><div class="children"><div class="content">I understand things best by comparing across different languages so don’t take this the wrong way but I wonder if you can help me understand: If say I start a goroutine in Go and give it a channel to use as a mailbox, concurrency in Go is cooperative but it’ll automatically use OS threads and yield whenever it reads from the channel. Does Erlang&#x2F;OTP do something different? If so what does it do and what are the advantages? Or is it more that the library and ecosystem are built around this model?</div><br/><div id="41760733" class="c"><input type="checkbox" id="c-41760733" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41760050">parent</a><span>|</span><a href="#41759167">next</a><span>|</span><label class="collapse" for="c-41760733">[-]</label><label class="expand" for="c-41760733">[4 more]</label></div><br/><div class="children"><div class="content">I believe go yields after every function exit.  Erlang does the same, but there are no loops (you <i>must</i> use tailcall) so you can&#x27;t lock up the CPU with a while(true).</div><br/><div id="41760849" class="c"><input type="checkbox" id="c-41760849" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41760733">parent</a><span>|</span><a href="#41760799">next</a><span>|</span><label class="collapse" for="c-41760849">[-]</label><label class="expand" for="c-41760849">[1 more]</label></div><br/><div class="children"><div class="content">Erlang gives a reductions budget to processes. After a certain number of reductions, or if a process hits a yield point (like waiting to receive a message), the process will yield allowing another process to run.<p>Go uses preemption now (since 1.14), but it didn&#x27;t always. It used to be that you could use a busy loop and that goroutine would never yield. Yield points include things like function entries, syscalls, and a few other points.</div><br/></div></div><div id="41760799" class="c"><input type="checkbox" id="c-41760799" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41760733">parent</a><span>|</span><a href="#41760849">prev</a><span>|</span><a href="#41759167">next</a><span>|</span><label class="collapse" for="c-41760799">[-]</label><label class="expand" for="c-41760799">[2 more]</label></div><br/><div class="children"><div class="content">That used to be true, but no longer, goroutines are truly preëmptive, in 10ms time slices.</div><br/><div id="41761491" class="c"><input type="checkbox" id="c-41761491" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41760799">parent</a><span>|</span><a href="#41759167">next</a><span>|</span><label class="collapse" for="c-41761491">[-]</label><label class="expand" for="c-41761491">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!</div><br/></div></div></div></div></div></div></div></div><div id="41759167" class="c"><input type="checkbox" id="c-41759167" checked=""/><div class="controls bullet"><span class="by">vereis</span><span>|</span><a href="#41759154">parent</a><span>|</span><a href="#41760050">prev</a><span>|</span><a href="#41763310">next</a><span>|</span><label class="collapse" for="c-41759167">[-]</label><label class="expand" for="c-41759167">[11 more]</label></div><br/><div class="children"><div class="content">Gleam runs on the BEAM</div><br/><div id="41759182" class="c"><input type="checkbox" id="c-41759182" checked=""/><div class="controls bullet"><span class="by">atemerev</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759167">parent</a><span>|</span><a href="#41763310">next</a><span>|</span><label class="collapse" for="c-41759182">[-]</label><label class="expand" for="c-41759182">[10 more]</label></div><br/><div class="children"><div class="content">It does. However, its actor implementation is not built upon Erlang&#x2F;OTP, and currently is “experimental” and not even mentioned on the main site.</div><br/><div id="41759289" class="c"><input type="checkbox" id="c-41759289" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759182">parent</a><span>|</span><a href="#41763310">next</a><span>|</span><label class="collapse" for="c-41759289">[-]</label><label class="expand" for="c-41759289">[9 more]</label></div><br/><div class="children"><div class="content">&gt; its actor implementation is not built upon Erlang&#x2F;OTP<p>This seems to be the opposite of pragmatic.<p>The most pragmatic approach to actors when you&#x27;re building a BEAM language would be to write bindings for OTP and be done with it. This sounds kind of like building a JVM language with no intention of providing interop with the JVM ecosystem—yeah, the VM is good, but the ecosystem is what we&#x27;re actually there for.<p>If you&#x27;re building a BEAM language, why would you attempt to reimplement OTP?</div><br/><div id="41759617" class="c"><input type="checkbox" id="c-41759617" checked=""/><div class="controls bullet"><span class="by">okkdev</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759289">parent</a><span>|</span><a href="#41759438">next</a><span>|</span><label class="collapse" for="c-41759617">[-]</label><label class="expand" for="c-41759617">[3 more]</label></div><br/><div class="children"><div class="content">Because of type safety. The OTP lib is already great, but there are still some things missing, most requested being named processes. But there is work being done to figure out how to best make it work for gleam.</div><br/><div id="41760068" class="c"><input type="checkbox" id="c-41760068" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759617">parent</a><span>|</span><a href="#41759438">next</a><span>|</span><label class="collapse" for="c-41760068">[-]</label><label class="expand" for="c-41760068">[2 more]</label></div><br/><div class="children"><div class="content">The question of type safety has come up so often here that I guess it&#x27;s worth replying:<p>That&#x27;s exactly what I mean by this not seeming pragmatic. Pragmatic would be making do with partial type safety in order to be fully compatible with OTP. That&#x27;s the much-maligned TypeScript approach, and it worked for TypeScript because it was pragmatic.<p>Now, maybe Gleam feels the need to take this approach because Elixir is already planning on filling the pragmatic gradually-typed BEAM language niche. That&#x27;s fine if so!</div><br/><div id="41763702" class="c"><input type="checkbox" id="c-41763702" checked=""/><div class="controls bullet"><span class="by">okkdev</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41760068">parent</a><span>|</span><a href="#41759438">next</a><span>|</span><label class="collapse" for="c-41763702">[-]</label><label class="expand" for="c-41763702">[1 more]</label></div><br/><div class="children"><div class="content">Type safety is one of the goals of the language I don&#x27;t see a reason to throw it out of the window now. I see what you mean, but the type system is one of the things that makes gleam pragmatic. If you really need some missing OTP feature you can super easily step into Erlang using FFI and get it. That&#x27;s one of the reasons the article doesn&#x27;t call gleam pure.</div><br/></div></div></div></div></div></div><div id="41759438" class="c"><input type="checkbox" id="c-41759438" checked=""/><div class="controls bullet"><span class="by">arcanemachiner</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759289">parent</a><span>|</span><a href="#41759617">prev</a><span>|</span><a href="#41759827">next</a><span>|</span><label class="collapse" for="c-41759438">[-]</label><label class="expand" for="c-41759438">[1 more]</label></div><br/><div class="children"><div class="content">I believe their implementation was written to support static typing (since Gleam is a statically-typed language).</div><br/></div></div><div id="41759827" class="c"><input type="checkbox" id="c-41759827" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759289">parent</a><span>|</span><a href="#41759438">prev</a><span>|</span><a href="#41760039">next</a><span>|</span><label class="collapse" for="c-41759827">[-]</label><label class="expand" for="c-41759827">[2 more]</label></div><br/><div class="children"><div class="content">I agree with the part about reusing OTP but some of the server syntax of Erlang and Elixir is not good IMHO. I never liked using those handle_* functions. Give them proper names and you cover nearly all the normal usage, which is mutating the internal state of a process (an object in other families of languages.) That would be the pragmatic choice, to lure Java, C++ programmers.</div><br/><div id="41760764" class="c"><input type="checkbox" id="c-41760764" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759827">parent</a><span>|</span><a href="#41760039">next</a><span>|</span><label class="collapse" for="c-41760764">[-]</label><label class="expand" for="c-41760764">[1 more]</label></div><br/><div class="children"><div class="content">Elixir gives you Agent, which is what you want, but for reasons, Agent is a bad choice.<p>What you&#x27;re not seeing with the handle_* functions is all the extra stuff in there that deals with, for example, &quot;what if the thing you want to access is unavailable?&quot;.  That&#x27;s not really something that for example go is able to handle so easily.</div><br/></div></div></div></div><div id="41759803" class="c"><input type="checkbox" id="c-41759803" checked=""/><div class="controls bullet"><span class="by">H12</span><span>|</span><a href="#41759154">root</a><span>|</span><a href="#41759289">parent</a><span>|</span><a href="#41760039">prev</a><span>|</span><a href="#41763310">next</a><span>|</span><label class="collapse" for="c-41759803">[-]</label><label class="expand" for="c-41759803">[1 more]</label></div><br/><div class="children"><div class="content">IIRC the re-implementation was necessary  for type-safety.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41763310" class="c"><input type="checkbox" id="c-41763310" checked=""/><div class="controls bullet"><span class="by">d--b</span><span>|</span><a href="#41759154">prev</a><span>|</span><a href="#41762499">next</a><span>|</span><label class="collapse" for="c-41763310">[-]</label><label class="expand" for="c-41763310">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t it compare mostly to F#, rather than Haskell or OCaml? The examples in the post really look like F# to me</div><br/></div></div><div id="41762499" class="c"><input type="checkbox" id="c-41762499" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#41763310">prev</a><span>|</span><a href="#41759235">next</a><span>|</span><label class="collapse" for="c-41762499">[-]</label><label class="expand" for="c-41762499">[1 more]</label></div><br/><div class="children"><div class="content">newbie here, how does gleam compare to golang, rust and python?</div><br/></div></div><div id="41759235" class="c"><input type="checkbox" id="c-41759235" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41762499">prev</a><span>|</span><a href="#41763776">next</a><span>|</span><label class="collapse" for="c-41759235">[-]</label><label class="expand" for="c-41759235">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not pragmatic if you have to import these basic libs:<p>```<p>import gleam&#x2F;dict.{type Dict}<p>import gleam&#x2F;int<p>import gleam&#x2F;io<p>import gleam&#x2F;result<p>import gleam&#x2F;string<p>```</div><br/><div id="41759265" class="c"><input type="checkbox" id="c-41759265" checked=""/><div class="controls bullet"><span class="by">eterm</span><span>|</span><a href="#41759235">parent</a><span>|</span><a href="#41763776">next</a><span>|</span><label class="collapse" for="c-41759265">[-]</label><label class="expand" for="c-41759265">[6 more]</label></div><br/><div class="children"><div class="content">Why not?<p>What&#x27;s wrong with a standard library the bits of which you want you choose to import?</div><br/><div id="41760377" class="c"><input type="checkbox" id="c-41760377" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#41759235">root</a><span>|</span><a href="#41759265">parent</a><span>|</span><a href="#41759625">next</a><span>|</span><label class="collapse" for="c-41760377">[-]</label><label class="expand" for="c-41760377">[4 more]</label></div><br/><div class="children"><div class="content">I can understand having to import the &quot;dirty&quot; parts of the stdlib, like I&#x2F;O, or the &quot;heavy&quot; parts, like Unicode or timezones. But why force someone to import every single type? Most functional languages have a prelude that covers the types every non-trivial program uses: booleans, numbers, strings, collections.</div><br/><div id="41760543" class="c"><input type="checkbox" id="c-41760543" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41759235">root</a><span>|</span><a href="#41760377">parent</a><span>|</span><a href="#41759625">next</a><span>|</span><label class="collapse" for="c-41760543">[-]</label><label class="expand" for="c-41760543">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But why force someone to import every single type?<p>That&#x27;s not importing the types, it&#x27;s importing a suite of functions related to the types.<p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;gleam_stdlib&#x2F;gleam&#x2F;int.html" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;gleam_stdlib&#x2F;gleam&#x2F;int.html</a> - gleam&#x2F;int for example. The int type is already in the language and usable, this import brings in some specific functions that are related to operations on int.</div><br/><div id="41762222" class="c"><input type="checkbox" id="c-41762222" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#41759235">root</a><span>|</span><a href="#41760543">parent</a><span>|</span><a href="#41759625">next</a><span>|</span><label class="collapse" for="c-41762222">[-]</label><label class="expand" for="c-41762222">[2 more]</label></div><br/><div class="children"><div class="content">Why not methods of the type?</div><br/><div id="41762330" class="c"><input type="checkbox" id="c-41762330" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41759235">root</a><span>|</span><a href="#41762222">parent</a><span>|</span><a href="#41759625">next</a><span>|</span><label class="collapse" for="c-41762330">[-]</label><label class="expand" for="c-41762330">[1 more]</label></div><br/><div class="children"><div class="content">The answer to &quot;why not methods&quot; would be because it doesn&#x27;t have methods.</div><br/></div></div></div></div></div></div></div></div><div id="41759625" class="c"><input type="checkbox" id="c-41759625" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#41759235">root</a><span>|</span><a href="#41759265">parent</a><span>|</span><a href="#41760377">prev</a><span>|</span><a href="#41763776">next</a><span>|</span><label class="collapse" for="c-41759625">[-]</label><label class="expand" for="c-41759625">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that it&#x27;s wrong—at least I don&#x27;t think so. It&#x27;s that it&#x27;s an example of a choice that is not pragmatic.<p>I suppose we should agree on what &quot;pragmatic&quot; even means, since it has become something of a cliché term in software engineering. To me, it roughly means &quot;reflective of common and realistic use as opposed to possible or theoretical considerations&quot;.<p>So is having to import basic functionality a pragmatic design? I would argue no. Having to import basic functionality for integers, strings, and IO is not pragmatic in the sense that most realistic programs will use these things. As such, the vast majority of ordinary programs are burdened by extra steps that don&#x27;t appear to net some other benefit.<p>Importing these very basic functionalities appeals to a more abstract or theoretical need for fine-grained control or minimalism. <i>Maybe</i> we don&#x27;t want to use integers or strings in a certain code module. <i>Maybe</i> we want to compile Gleam to a microcontroller where the code needs to be spartan and freestanding.<p>These aren&#x27;t pragmatic concerns in the context of the types of problems Gleam is designed to address.<p>To give a point of comparison, the Haskell prelude might be considered a pragmatic design choice, as can be seen from the article. It is a bundle of common or useful functionality that one expects to use in a majority of ordinary Haskell programs. One doesn&#x27;t need to &quot;import&quot; the prelude; it&#x27;s just there.<p>I don&#x27;t personally find Gleam&#x27;s design choice a bad one, and while GP was a bit flippant, I do agree that it is not an example of a pragmatic design choice.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>