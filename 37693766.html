<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695978061139" as="style"/><link rel="stylesheet" href="styles.css?v=1695978061139"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://retrocomputing.stackexchange.com/questions/27741/how-were-the-signs-for-logical-and-arithmetic-operators-decided">How were the signs for logical and arithmetic operators decided?</a> <span class="domain">(<a href="https://retrocomputing.stackexchange.com">retrocomputing.stackexchange.com</a>)</span></div><div class="subtext"><span>edent</span> | <span>35 comments</span></div><br/><div><div id="37695118" class="c"><input type="checkbox" id="c-37695118" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37695490">next</a><span>|</span><label class="collapse" for="c-37695118">[-]</label><label class="expand" for="c-37695118">[6 more]</label></div><br/><div class="children"><div class="content">Most comments there do not go far enough back in time but refer only to later languages that have inherited the operators from other earlier languages.<p>Regarding the logical operators, in mathematics, many decades before the first programming languages, the symbols were:<p><pre><code>  &quot;∧ U+2227;LOGICAL AND&quot; 
  &quot;∨ U+2228;LOGICAL OR&quot;

  Either &quot;∼ U+223C;TILDE OPERATOR&quot; or &quot;¬ U+00AC;NOT SIGN&quot;
</code></pre>
Many early programming languages, e.g. Algol 60, CPL, IBM APL\360, used these (Algol 60 used &quot;¬&quot;, McCarthy, CPL and APL used &quot;~&quot;).<p>IBM FORTRAN IV (1962) was meant to be used with IBM printers with poor character sets, so it used &quot;.AND.&quot;, &quot;.OR.&quot;, and &quot;.NOT.&quot;.<p>The next IBM language, IBM NPL (December 1964) replaced the FORTRAN IV keywords with &quot;&amp;&quot;, &quot;|&quot; and &quot;¬&quot; (because these symbols were included in the IBM EBCDIC character set, while &quot;U+2227;LOGICAL AND&quot; and &quot;U+2228;LOGICAL OR&quot; were not included).<p>The next year NPL was rebranded as PL&#x2F;I and all the languages that use &quot;&amp;&quot; and &quot;|&quot; have taken them directly or indirectly from PL&#x2F;I.<p>The languages B and C have taken their symbols and keywords from 3 sources, BCPL, PL&#x2F;I and Algol 68. The logical operators were taken from PL&#x2F;I.<p>By the time of B, ASCII had been standardized and it did not include &quot;¬ U+00AC;NOT SIGN&quot;.<p>Because of this, B had to replace in the PL&#x2F;I operators &quot;¬&quot; with an unused ASCII symbol, &quot;!&quot;.<p>In B, &quot;&amp;&quot; and &quot;|&quot; were ambiguous, depending on the context they were interpreted as either bit string operators or as &quot;McCarthy AND&quot; and &quot;McCarthy OR&quot;.<p>C has resolved the ambiguity by adding &quot;&amp;&amp;&quot; and &quot;||&quot;, and then it has added &quot;~&quot; for bit string not, which had already been used for this purpose in mathematics and in earlier programming languages.</div><br/><div id="37696580" class="c"><input type="checkbox" id="c-37696580" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#37695118">parent</a><span>|</span><a href="#37698595">next</a><span>|</span><label class="collapse" for="c-37696580">[-]</label><label class="expand" for="c-37696580">[3 more]</label></div><br/><div class="children"><div class="content">The classic ∧ ∨ symbols from mathematical logic have been used in a few languages, often spelled &#x2F;\ \&#x2F;<p>After CPL they turn up in Miranda (as the weirdly asymmetrical &amp; \&#x2F;) and in Occam<p>I thought there were more, but I can’t find them right now.</div><br/><div id="37699621" class="c"><input type="checkbox" id="c-37699621" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#37695118">root</a><span>|</span><a href="#37696580">parent</a><span>|</span><a href="#37698566">next</a><span>|</span><label class="collapse" for="c-37699621">[-]</label><label class="expand" for="c-37699621">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact: ASCII added the \ so ALGOL could write &#x2F;\ and \&#x2F;!</div><br/></div></div><div id="37698566" class="c"><input type="checkbox" id="c-37698566" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#37695118">root</a><span>|</span><a href="#37696580">parent</a><span>|</span><a href="#37699621">prev</a><span>|</span><a href="#37698595">next</a><span>|</span><label class="collapse" for="c-37698566">[-]</label><label class="expand" for="c-37698566">[1 more]</label></div><br/><div class="children"><div class="content">TLA+ also uses that convention (along with the temporal logic operators [] and &lt;&gt;, and some other unusual conventions like #=).</div><br/></div></div></div></div><div id="37698595" class="c"><input type="checkbox" id="c-37698595" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37695118">parent</a><span>|</span><a href="#37696580">prev</a><span>|</span><a href="#37696472">next</a><span>|</span><label class="collapse" for="c-37698595">[-]</label><label class="expand" for="c-37698595">[1 more]</label></div><br/><div class="children"><div class="content">I like how Python resolves ambiguity.<p>When you see English text, it works at a high level on objects.  If you see ASCII characters, it looks like C, you know you&#x27;re messing with low level granular elements like you might commonly do in C.</div><br/></div></div></div></div><div id="37695490" class="c"><input type="checkbox" id="c-37695490" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#37695118">prev</a><span>|</span><a href="#37695851">next</a><span>|</span><label class="collapse" for="c-37695490">[-]</label><label class="expand" for="c-37695490">[8 more]</label></div><br/><div class="children"><div class="content">A lot of math symbols are accidental and owe their existence to circumstances of writing, book publishing, typewriter or later computer keyboard.  Very few have any kind of history that helps understand their meaning.<p>Just a few examples: &quot;lambda&quot; in &quot;lambda calculus&quot; was originally the caret sign, which, by convention was used on typewriters because those didn&#x27;t have Greek letters.  Whether Alonzo Church actually wanted the Greek letter or the caret symbol is not known (and he, himself, probably wouldn&#x27;t care), but if you look at the manuscript, it uses &quot;^&quot;.<p>Minus sign was an attempt to create a sign &quot;opposite to plus&quot;, whereas the plus sign was a contraction of Latin &quot;at&quot; (ampersand is another way in which Latin &quot;at&quot; made it into modern typesetting).  Multiplication was also an attempt to manipulate the plus sign.  And so was division (the horizontal line between two dots, and subsequent mutation into just two dots making a &quot;:&quot; sign).<p>Asterisk, which used plenty in different mathematical contexts was actually a punctuation sign. Early Roman writing didn&#x27;t use spaces between words, instead they put dots between them.  It was <i>the only</i> punctuation sign they used, so no commas, periods, question marks etc.  All that stuff came almost a thousand years later.<p>A bunch of logical signs were invented by Frege and later popularized &#x2F; amended by Wittgenstein.  These were completely artificial and didn&#x27;t derive from anything.  I don&#x27;t think the authors ever explained why they chose any specific shapes, but my guess would be that they were looking for something visually distinct enough for a small alphabet they created and arbitrarily assigned symbols to operations.</div><br/><div id="37696070" class="c"><input type="checkbox" id="c-37696070" checked=""/><div class="controls bullet"><span class="by">joe_the_user</span><span>|</span><a href="#37695490">parent</a><span>|</span><a href="#37697613">next</a><span>|</span><label class="collapse" for="c-37696070">[-]</label><label class="expand" for="c-37696070">[5 more]</label></div><br/><div class="children"><div class="content">Interesting post but I think you&#x27;re wrong in the following sentence:<p><i>A bunch of logical signs were invented by Frege and later popularized &#x2F; amended by Wittgenstein.</i><p>Jan Von Plato goes into this in The Great Formal Machinery Works. Frege&#x27;s notation never become popular - his notation involved lines from one part of an expression to another (!) and is fairly incomprehensible. A more or less modern system of symbols of mathematical logic was created by Russel and Whitehead in Principia Mathematica extending the symbols of Peano (but using the <i>ideas</i> of Frege). Russel and Whitehead syntax, (&quot;there exists&quot; and &quot;for all&quot; symbol) was taken up by Hilbert and the Gottingen school which crafted a lot of the basic theories of mathematical logic. Von Plato doesn&#x27;t refer to Wittgenstein influencing notation and I don&#x27;t think he did - he was a popular but idiosyncratic philosopher, not a mathematician.<p>Von Plato&#x27;s history of mathematical logic in Great Formal Machinery... is fascinating.<p>Edit: Wikipedia describes Frege&#x27;s notation. You have draw lines connecting expressions, an approach that quickly gets unwieldy. I believe that only Frege used Frege&#x27;s notation. Wittgenstein refers to Frege but that&#x27;s it.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Begriffsschrift" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Begriffsschrift</a></div><br/><div id="37700090" class="c"><input type="checkbox" id="c-37700090" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#37695490">root</a><span>|</span><a href="#37696070">parent</a><span>|</span><a href="#37696522">next</a><span>|</span><label class="collapse" for="c-37700090">[-]</label><label class="expand" for="c-37700090">[2 more]</label></div><br/><div class="children"><div class="content">That Wikipedia section is uncharacteristically bad. It doesn’t even define or explain the notation, it’s just some examples and a long quote. I’m sure that there was more to it than that.</div><br/><div id="37700564" class="c"><input type="checkbox" id="c-37700564" checked=""/><div class="controls bullet"><span class="by">Hendrikto</span><span>|</span><a href="#37695490">root</a><span>|</span><a href="#37700090">parent</a><span>|</span><a href="#37696522">next</a><span>|</span><label class="collapse" for="c-37700564">[-]</label><label class="expand" for="c-37700564">[1 more]</label></div><br/><div class="children"><div class="content">The German version has more details and better explanations.</div><br/></div></div></div></div><div id="37696522" class="c"><input type="checkbox" id="c-37696522" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#37695490">root</a><span>|</span><a href="#37696070">parent</a><span>|</span><a href="#37700090">prev</a><span>|</span><a href="#37697613">next</a><span>|</span><label class="collapse" for="c-37696522">[-]</label><label class="expand" for="c-37696522">[2 more]</label></div><br/><div class="children"><div class="content">To the best of my knowledge, Wittgenstein lived with Russel for quite some time and was a very influential force in writing the Principa.  I believe I saw a lot of prototypes of the modern logical symbols in his Traktatus.<p>I also believe that Russel traveled to meet Frege in his quest for writing the book.  He definitely saw his work even before it was published &#x2F; had private conversations with him face-to-face.  Not sure how much of the invented language made it into Principia, but the author was definitely familiar with Frege&#x27;s work.</div><br/><div id="37697663" class="c"><input type="checkbox" id="c-37697663" checked=""/><div class="controls bullet"><span class="by">joe_the_user</span><span>|</span><a href="#37695490">root</a><span>|</span><a href="#37696522">parent</a><span>|</span><a href="#37697613">next</a><span>|</span><label class="collapse" for="c-37697663">[-]</label><label class="expand" for="c-37697663">[1 more]</label></div><br/><div class="children"><div class="content">All I know is Von Plato and some random readings in foundations for my degree, but this[1] seems to indicate Russel met Wittgenstein after Principia was completed.<p><i>I also believe that Russel traveled to meet Frege in his quest for writing the book.</i><p>No doubt, as I said above, Principia was very influenced by Frege&#x27;s ideas. But it absolutely did not use Frege&#x27;s notation(which was a disaster as I describe above). Von Plato really emphasizes how much of an advance the notation of Principia was. And seriously, it&#x27;s remarkable how new modern mathematical logic notation is, it didn&#x27;t have true modern form &#x27;till the 20s or 30s.<p>[1] &quot;It was October 1911, volume one of Principia Mathematica was newly out, and Bertrand Russell, fellow of Trinity College, Cambridge, was having his tea when a young man suddenly appeared. He introduced himself as &quot;Loot&#x27;vig Vit&#x27;gun-shteyne&quot;. <a href="https:&#x2F;&#x2F;www.independent.co.uk&#x2F;life-style&#x2F;when-ludwig-wittgenstein-met-bertrand-russell-1596995.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.independent.co.uk&#x2F;life-style&#x2F;when-ludwig-wittgen...</a></div><br/></div></div></div></div></div></div><div id="37697613" class="c"><input type="checkbox" id="c-37697613" checked=""/><div class="controls bullet"><span class="by">_0ffh</span><span>|</span><a href="#37695490">parent</a><span>|</span><a href="#37696070">prev</a><span>|</span><a href="#37699462">next</a><span>|</span><label class="collapse" for="c-37697613">[-]</label><label class="expand" for="c-37697613">[1 more]</label></div><br/><div class="children"><div class="content">Minor nitpick: &quot;And&quot; in latin is &quot;et&quot;, as in &quot;et al.&quot;.</div><br/></div></div><div id="37699462" class="c"><input type="checkbox" id="c-37699462" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#37695490">parent</a><span>|</span><a href="#37697613">prev</a><span>|</span><a href="#37695851">next</a><span>|</span><label class="collapse" for="c-37699462">[-]</label><label class="expand" for="c-37699462">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the plus sign was a contraction of Latin &quot;at&quot; (ampersand is another way in which Latin &quot;at&quot; made it into modern typesetting)<p>An ampersand is <i>et</i> [and], not <i>at</i> [but]. There are still current forms of the symbol that are transparently just a T attached to an E.<p>I was about to ask how the plus sign could possibly be related to the word &quot;but&quot;, but I&#x27;m guessing you meant that it derives from <i>et</i> too?</div><br/></div></div></div></div><div id="37695851" class="c"><input type="checkbox" id="c-37695851" checked=""/><div class="controls bullet"><span class="by">vincent-manis</span><span>|</span><a href="#37695490">prev</a><span>|</span><a href="#37696317">next</a><span>|</span><label class="collapse" for="c-37695851">[-]</label><label class="expand" for="c-37695851">[1 more]</label></div><br/><div class="children"><div class="content">Bob Bemer, one of the principals of the development of ASCII, argued that the backslash should be incorporated so that “and” (∧) could be written as &#x2F;\ and “or” (∨) as \&#x2F;. The logic signs are derived from the Latin ac (or atque, “and”) and vel (“or”), respectively.</div><br/></div></div><div id="37696317" class="c"><input type="checkbox" id="c-37696317" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#37695851">prev</a><span>|</span><a href="#37699317">next</a><span>|</span><label class="collapse" for="c-37696317">[-]</label><label class="expand" for="c-37696317">[3 more]</label></div><br/><div class="children"><div class="content">I asked a question about the origins of the XOR operator a while back.<p>Ken Thompson was emailed by the accepted answerer and provided a response, in fact!<p><a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;331388&#x2F;why-was-the-caret-used-for-xor-instead-of-exponentiation" rel="nofollow noreferrer">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;3313...</a></div><br/><div id="37701045" class="c"><input type="checkbox" id="c-37701045" checked=""/><div class="controls bullet"><span class="by">aap_</span><span>|</span><a href="#37696317">parent</a><span>|</span><a href="#37696716">next</a><span>|</span><label class="collapse" for="c-37701045">[-]</label><label class="expand" for="c-37701045">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure XOR&#x2F;^ was added by Ken himself because it is not in his original B language and while the earliest C compiler can parse it, it can&#x27;t generate code for it. I think it was Steve Johnson or Dennis Ritchie. Now B originally <i>did</i> have a ^ but that stood for OR because | was in the lower case region of ASCII.</div><br/></div></div><div id="37696716" class="c"><input type="checkbox" id="c-37696716" checked=""/><div class="controls bullet"><span class="by">totoglazer</span><span>|</span><a href="#37696317">parent</a><span>|</span><a href="#37701045">prev</a><span>|</span><a href="#37699317">next</a><span>|</span><label class="collapse" for="c-37696716">[-]</label><label class="expand" for="c-37696716">[1 more]</label></div><br/><div class="children"><div class="content">Also for ampersand! <a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;252023&#x2F;why-does-c-use-the-asterisk-for-pointers" rel="nofollow noreferrer">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;2520...</a></div><br/></div></div></div></div><div id="37699317" class="c"><input type="checkbox" id="c-37699317" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37696317">prev</a><span>|</span><a href="#37697455">next</a><span>|</span><label class="collapse" for="c-37699317">[-]</label><label class="expand" for="c-37699317">[1 more]</label></div><br/><div class="children"><div class="content">No mention of APL here or on retrocomputing. We had a decwriter at uni in the 70s&#x2F;80s timeframe with APL key caps which was always the last terminal available to login to the Dec-10.<p>IMP (the Edinburgh programming language behind EMAS) used %op% notation which is very like early Fortran .and.<p>To repeat my comment from  the earlier posting, 7 bit ASCII and upper case only terminals meant limited symbols were available universally. Using &quot;.&quot; for multiplication would have made parsing decimal fractions and floating point numbers significantly harder despite the commonplace availability of full-stop in the character set to hand. Thus use of<p><pre><code>  a . b
</code></pre>
as the nearest available notation to<p><pre><code>  a • b
</code></pre>
(Using unavailable characters of the time, • not being in 
7 bit ASCII) So<p><pre><code>  a * b 
</code></pre>
Seems logical. Remember that six bit byte notation was also in use for BCD. Even less characters.<p>ASCII is a neologism for IA5 and the Baudot codes available before ASCII happened. People who worked on that standardisation process are still around, and active as are people who worked on early Fortran if not the ground states.</div><br/></div></div><div id="37697455" class="c"><input type="checkbox" id="c-37697455" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#37699317">prev</a><span>|</span><a href="#37695364">next</a><span>|</span><label class="collapse" for="c-37697455">[-]</label><label class="expand" for="c-37697455">[1 more]</label></div><br/><div class="children"><div class="content">Smalltalk uses ^ for return and _ for assignment (aliased to := in esentially all implementations for obvious practical reasons) because in draft version of ASCII these two characters were ↑ and ←.</div><br/></div></div><div id="37695364" class="c"><input type="checkbox" id="c-37695364" checked=""/><div class="controls bullet"><span class="by">bazoom42</span><span>|</span><a href="#37697455">prev</a><span>|</span><a href="#37698220">next</a><span>|</span><label class="collapse" for="c-37695364">[-]</label><label class="expand" for="c-37695364">[3 more]</label></div><br/><div class="children"><div class="content">Before ASCII, languages didn’t necessarily mandate what characters to use for operators and other symbols. They defined an abstract syntax, but left it to the implemention for a particular machine what chracters to use for a given symbol, because of the large variation in keyboards and character sets across machines.<p>I believe Algol and BCPL did it like that, and C was one of the first languages to specify the exact characters to use for its symbols.</div><br/><div id="37696343" class="c"><input type="checkbox" id="c-37696343" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#37695364">parent</a><span>|</span><a href="#37698220">next</a><span>|</span><label class="collapse" for="c-37696343">[-]</label><label class="expand" for="c-37696343">[2 more]</label></div><br/><div class="children"><div class="content">More than that; ALGOL-68, for instance, allowed for translating keywords into different national languages, IIRC.</div><br/><div id="37700783" class="c"><input type="checkbox" id="c-37700783" checked=""/><div class="controls bullet"><span class="by">bazoom42</span><span>|</span><a href="#37695364">root</a><span>|</span><a href="#37696343">parent</a><span>|</span><a href="#37698220">next</a><span>|</span><label class="collapse" for="c-37700783">[-]</label><label class="expand" for="c-37700783">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is the same feature. The “abstract token” like “if” is used in the language specification and BNF but in the compiler implementation it could be represented by different characters.</div><br/></div></div></div></div></div></div><div id="37698220" class="c"><input type="checkbox" id="c-37698220" checked=""/><div class="controls bullet"><span class="by">aragonite</span><span>|</span><a href="#37695364">prev</a><span>|</span><a href="#37700461">next</a><span>|</span><label class="collapse" for="c-37698220">[-]</label><label class="expand" for="c-37698220">[3 more]</label></div><br/><div class="children"><div class="content">I find it unfortunate that so many programming languages (e.g. JavaScript and Python) that purport to support Unicode identifiers actually exclude the most visually distinctive Unicode characters (i.e. symbols and some emojis) from being used in identifiers, on the entirely specious grounds that they are not Unicode word characters. For example, there are legitimate reasons why one might want to use the mathematical symbols for intersection and union as names of functions, or use circled letters&#x2F;numbers as&#x2F;in variable names, but you can&#x27;t do these things because those are symbols and not Unicode word characters.<p>If you are going to allow Unicode, you should just default to the simplest, most easily memorizable rule (i.e. allow all characters except for ASCII non-word characters). Trying to be helpful by excluding characters <i>you</i> cannot imagine why anyone else might want to use just makes the rule harder to memorize and limits the class of well-former identifiers for no good reason.</div><br/><div id="37699476" class="c"><input type="checkbox" id="c-37699476" checked=""/><div class="controls bullet"><span class="by">marssaxman</span><span>|</span><a href="#37698220">parent</a><span>|</span><a href="#37700461">next</a><span>|</span><label class="collapse" for="c-37699476">[-]</label><label class="expand" for="c-37699476">[2 more]</label></div><br/><div class="children"><div class="content">I once adapted a pre-Unicode compiler (for a weakly-specified dialect of Basic) to accept non-ASCII identifiers in exactly the fashion you suggest. It worked fine, because almost nobody took advantage of the feature, and the myriad avenues for confusion went unexplored. I would not make the same choice today.</div><br/><div id="37699936" class="c"><input type="checkbox" id="c-37699936" checked=""/><div class="controls bullet"><span class="by">aragonite</span><span>|</span><a href="#37698220">root</a><span>|</span><a href="#37699476">parent</a><span>|</span><a href="#37700461">next</a><span>|</span><label class="collapse" for="c-37699936">[-]</label><label class="expand" for="c-37699936">[1 more]</label></div><br/><div class="children"><div class="content">Ha! In a way I think that lends support to my suggestion. Allowing all non-ASCII Unicode characters has both positives and negatives. But the negatives are largely negligible, for precisely the reason you mention: most people will not take advantage of that feature (Swift, for example, allows emoji identifiers, but it&#x27;s extremely rare to find emoji identifiers in actual Swift source code), so the potential for confusion is minimized. On the other hand, the positives (for a small minority of programmers who prefer them) are very real.</div><br/></div></div></div></div></div></div><div id="37695423" class="c"><input type="checkbox" id="c-37695423" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#37700461">prev</a><span>|</span><a href="#37695277">next</a><span>|</span><label class="collapse" for="c-37695423">[-]</label><label class="expand" for="c-37695423">[2 more]</label></div><br/><div class="children"><div class="content">In an ideal world, of course, symmetric operators would have symmetric symbols, non-symmetric operators asymmetric symbols ... and antisymmetric operators what kinds of symbols?</div><br/><div id="37697876" class="c"><input type="checkbox" id="c-37697876" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#37695423">parent</a><span>|</span><a href="#37695277">next</a><span>|</span><label class="collapse" for="c-37697876">[-]</label><label class="expand" for="c-37697876">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and antisymmetric operators what kinds of symbols?<p>Probably horizontally (flip-)asymmetric but 180-degree rotationally symmetric. With negation-like operators being vertically flip-symmetric.</div><br/></div></div></div></div><div id="37695277" class="c"><input type="checkbox" id="c-37695277" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#37695423">prev</a><span>|</span><a href="#37695383">next</a><span>|</span><label class="collapse" for="c-37695277">[-]</label><label class="expand" for="c-37695277">[2 more]</label></div><br/><div class="children"><div class="content">I had been guessing * made its way into character sets because of its business use as a line fill for printed checks. (for those of you not alive in the 20th century, see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheque" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cheque</a> )<p>Edit: then again, it&#x27;s in the 0x28-0x2F range along with + - and &#x2F;, which suggests it was already thought of as mathematical as early as 1963...<p>Edit 2: it doesn&#x27;t seem to occur in ITA-2, and in FIELDATA it&#x27;s alongside punctuation like &amp; $ ( and %.</div><br/><div id="37695461" class="c"><input type="checkbox" id="c-37695461" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37695277">parent</a><span>|</span><a href="#37695383">next</a><span>|</span><label class="collapse" for="c-37695461">[-]</label><label class="expand" for="c-37695461">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps for the reason proposed by you, the IBM typewriters had &quot;*&quot; but they did not have &quot;× U+00D7;MULTIPLICATION SIGN&quot;.<p>This has forced the choice of &quot;*&quot; for multiplication in Fortran, in 1956. All the other languages that use &quot;*&quot; have taken it from Fortran. There are only a few exceptions, like Algol 60 and APL\360, which used &quot;×&quot;, because they did not care about what the standard IBM printers supported.<p>The ASCII encoding is irrelevant, it was chosen more than a decade later and the earlier character sets had encoded &quot;*&quot; in completely other locations.</div><br/></div></div></div></div><div id="37695383" class="c"><input type="checkbox" id="c-37695383" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37695277">prev</a><span>|</span><a href="#37695365">next</a><span>|</span><label class="collapse" for="c-37695383">[-]</label><label class="expand" for="c-37695383">[2 more]</label></div><br/><div class="children"><div class="content">Fortran has .and. and .or. for logical operators, which is pretty easy to remember.<p>&amp; seems pretty obvious, of course they couldn’t have known at the time that logical operations should probably be given priority over bitwise ones.<p>| is an odd symbol. They don’t really justify it in the stack overflow answer, just mention where it came from.<p>Unix pipe, conditional probability, and or. I guess a vertical line is naturally going to be very popular though.</div><br/><div id="37695639" class="c"><input type="checkbox" id="c-37695639" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37695383">parent</a><span>|</span><a href="#37695365">next</a><span>|</span><label class="collapse" for="c-37695639">[-]</label><label class="expand" for="c-37695639">[1 more]</label></div><br/><div class="children"><div class="content">The early character sets that were available in teletypes and line printers were not selected with the purpose of writing mathematical notation, but with the purpose of writing &quot;business correspondence&quot;.<p>Because of this, the authors of most early programming languages, with the exception of APL\360 and of some European programming languages, which were not restricted to the IBM business-oriented character sets, had to replace the traditional mathematical symbols with whatever &quot;business&quot; characters were more suitable.<p>There is nothing odd about &quot;|&quot;. It was included in the &quot;business&quot; symbols, for drawing tables. Among the few available symbols, it was doubtless the most appropriate choice for &quot;OR&quot;.</div><br/></div></div></div></div></div></div></div></div></div></body></html>