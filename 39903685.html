<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712221254621" as="style"/><link rel="stylesheet" href="styles.css?v=1712221254621"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.swtch.com/xz-script">The xz attack shell script</a> <span class="domain">(<a href="https://research.swtch.com">research.swtch.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>292 comments</span></div><br/><div><div id="39915022" class="c"><input type="checkbox" id="c-39915022" checked=""/><div class="controls bullet"><span class="by">mittermayr</span><span>|</span><a href="#39911156">next</a><span>|</span><label class="collapse" for="c-39915022">[-]</label><label class="expand" for="c-39915022">[20 more]</label></div><br/><div class="children"><div class="content">As a developer, this amazes me, and it just shows what — to me — feels like a top-tier attack method, is probably only entry-to-mid level complexity for the folks working at that stage. Some of the things I see posted here on HN are well above this level, so I&#x27;d assume for the right kind of money (or other incentives), this is only the beginning of what&#x27;s possible. And, if you think of ALL the packages and ALL the many millions of libraries on GitHub, this vector is SO EFFECTIVE, there will be hundreds of cases like it uncovered in the next few months, I am certain of it.<p>I worry about all the con&#x2F;pro-sumer hardware makers, from Philips Hue to Alexas, from the SumUps to the camera makers, from Netgear to TP-Link. All their products are packed with open-source libraries. And I am 100% certain that most of their dev teams do not spend time scanning these for obscure injection vectors.</div><br/><div id="39916323" class="c"><input type="checkbox" id="c-39916323" checked=""/><div class="controls bullet"><span class="by">jimkoen</span><span>|</span><a href="#39915022">parent</a><span>|</span><a href="#39927158">next</a><span>|</span><label class="collapse" for="c-39916323">[-]</label><label class="expand" for="c-39916323">[12 more]</label></div><br/><div class="children"><div class="content">&gt; And I am 100% certain that most of their dev teams do not spend time scanning these for obscure injection vectors.<p>This rationale baffles me, it feels that the dependency-hell circlejerk crowd is working on making OSS maintainers look even more bad with this scenario.<p>Any given commercial operation that claims any credibility for itself does supply chain analysis before adopting a dependency. This is, among other things why ordinarily you&#x27;d pay RedHat to maintain a stable Linux Release for you and why projects such as FreeBSD severely limit the software they ship in the default install.<p>If you are affected by this mess, I&#x27;m sorry to say, but it&#x27;s your fault. If you are worried about developers of software you use for free, as in free beer, going rogue, either put in incentives for them to not do that (i.e. pay them) or fork the project and implement your own security measures on top of what&#x27;s already there.<p>If you&#x27;re worried that you could encounter exploits from dependencies in commercial software you use, you should negotiate a contract that includes compensation from damages from supply chain attacks.<p>If you&#x27;re unwilling to do that, sorry mate, you&#x27;re just unprofessional.<p>Inb4: Yes, I am really trying to say that you should check the supply chain of even your most basic dependencies such as SSH.</div><br/><div id="39919222" class="c"><input type="checkbox" id="c-39919222" checked=""/><div class="controls bullet"><span class="by">finaard</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39916323">parent</a><span>|</span><a href="#39921301">next</a><span>|</span><label class="collapse" for="c-39919222">[-]</label><label class="expand" for="c-39919222">[5 more]</label></div><br/><div class="children"><div class="content">Unfortunately that&#x27;s &quot;industry standard&quot; nowadays. I lost count how often I had that discussion over the last two decades.<p>Just look at stuff like pip, npm or pretty much any &quot;modern&quot; package manager in use by developers - they&#x27;re all pretty much designed to pull in a shitload of arbitrary unaudited and in some causes unauditable dependencies.<p>And nobody wants to listen. That&#x27;s why I prefer to work in heavily regulated areas nowadays - that way I can shorten that discussion with &quot;yeah, but regulatory requirements don&#x27;t let us do that, sorry&quot;<p>The absolute basic should be having a local archive of dependencies which at least received a basic sanity check, and updates or additions to that should review changes being added. CI gets access to that cache, but by itself does not have network access to make sure no random crap gets pulled into the build. You&#x27;d be surprised how many popular build systems can&#x27;t do that at all, or only with a lot of workarounds.</div><br/><div id="39924166" class="c"><input type="checkbox" id="c-39924166" checked=""/><div class="controls bullet"><span class="by">pknopf</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39919222">parent</a><span>|</span><a href="#39925124">next</a><span>|</span><label class="collapse" for="c-39924166">[-]</label><label class="expand" for="c-39924166">[3 more]</label></div><br/><div class="children"><div class="content">Package managers that use git are less prone to this kinda of attack (goland, rust).</div><br/><div id="39924294" class="c"><input type="checkbox" id="c-39924294" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39924166">parent</a><span>|</span><a href="#39925124">next</a><span>|</span><label class="collapse" for="c-39924294">[-]</label><label class="expand" for="c-39924294">[2 more]</label></div><br/><div class="children"><div class="content">Cargo does not “use git.”</div><br/><div id="39924711" class="c"><input type="checkbox" id="c-39924711" checked=""/><div class="controls bullet"><span class="by">AnyTimeTraveler</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39924294">parent</a><span>|</span><a href="#39925124">next</a><span>|</span><label class="collapse" for="c-39924711">[-]</label><label class="expand" for="c-39924711">[1 more]</label></div><br/><div class="children"><div class="content">What they meant was probably, that you have the option to rely entirely on using git repositories for your dependencies or even just paths to other projects on your disk.<p>You can also setup your own dependency registry and only work with that.</div><br/></div></div></div></div></div></div><div id="39925124" class="c"><input type="checkbox" id="c-39925124" checked=""/><div class="controls bullet"><span class="by">jimkoen</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39919222">parent</a><span>|</span><a href="#39924166">prev</a><span>|</span><a href="#39921301">next</a><span>|</span><label class="collapse" for="c-39925124">[-]</label><label class="expand" for="c-39925124">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they&#x27;re all pretty much designed to pull in a shitload of arbitrary unaudited and in some causes unauditable dependencies.<p>No they&#x27;re not. The dependency circle jerk went so far to prompt NPM to display all subsequent dependencies on each libraries page.<p>The issue lies with the industry as a whole exploiting the work of OSS developers for their own gain and having the audacity to complain when these volunteers won&#x27;t additionally do a security audit for free.</div><br/></div></div></div></div><div id="39921301" class="c"><input type="checkbox" id="c-39921301" checked=""/><div class="controls bullet"><span class="by">Dunedan</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39916323">parent</a><span>|</span><a href="#39919222">prev</a><span>|</span><a href="#39921845">next</a><span>|</span><label class="collapse" for="c-39921301">[-]</label><label class="expand" for="c-39921301">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Any given commercial operation that claims any credibility for itself does supply chain analysis before adopting a dependency. This is, among other things why ordinarily you&#x27;d pay RedHat to maintain a stable Linux Release for you and why projects such as FreeBSD severely limit the software they ship in the default install.<p>That sounds like you assume RedHat would&#x27;ve caught the vulnerability in xz-utils, before shipping it in the next release of RHEL. I&#x27;m not so sure about that, as there is only so much you can do in terms of supply chain analysis and such a sophisticated vulnerability can be pretty hard to spot. Also mind that it only got discovered by accident after all.</div><br/><div id="39923414" class="c"><input type="checkbox" id="c-39923414" checked=""/><div class="controls bullet"><span class="by">tcmart14</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39921301">parent</a><span>|</span><a href="#39925134">next</a><span>|</span><label class="collapse" for="c-39923414">[-]</label><label class="expand" for="c-39923414">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if RedHat would have caught it. But the benefit of Red Hat is, they would be the one to fall on the sword. Your product is built on RHEL. This happens. You get to shift blame to RHEL and RedHat would eat it. The positive is, after the dust has settled Red Hat could choose to sort of adopt the compromised piece (invest engineering effort and take it over) or take some stewardship (keeping an eye on it and maybe give a hand to whoever is maintaining it after).</div><br/><div id="39924496" class="c"><input type="checkbox" id="c-39924496" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39923414">parent</a><span>|</span><a href="#39925134">next</a><span>|</span><label class="collapse" for="c-39924496">[-]</label><label class="expand" for="c-39924496">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, but what? What does “shifting the blame” mean here? Ever heard of “it’s not my fault but it’s my problem?”.<p>It really sounds like you’re speaking from the perspective of a hypothetical employee looking to not get PIPd or whatever.<p>GP is talking about something quite different, and you’ve run off taking some sort of great personal offence to someone dare implying that there are downsides to open source, not even that it’s worse overall, but that there are downsides.<p>Chill.</div><br/><div id="39925157" class="c"><input type="checkbox" id="c-39925157" checked=""/><div class="controls bullet"><span class="by">jimkoen</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39924496">parent</a><span>|</span><a href="#39925134">next</a><span>|</span><label class="collapse" for="c-39925157">[-]</label><label class="expand" for="c-39925157">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re right though, the benefit of paying absurd amounts to your linux vendor is raking in certs that you can use with your insurance provider to cover your a** in case something like this happens. That&#x27;s the sole reason of certs after all. Though I&#x27;d like to figure out if RedHat really is going to eat it if push comes to shove.</div><br/></div></div></div></div></div></div><div id="39925134" class="c"><input type="checkbox" id="c-39925134" checked=""/><div class="controls bullet"><span class="by">jimkoen</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39921301">parent</a><span>|</span><a href="#39923414">prev</a><span>|</span><a href="#39921845">next</a><span>|</span><label class="collapse" for="c-39925134">[-]</label><label class="expand" for="c-39925134">[1 more]</label></div><br/><div class="children"><div class="content">I said &quot;ordinarily&quot;. I meant &quot;this is what you&#x27;d expect from them by paying them&quot;. Obviously this is a big fauxpas on their end and I&#x27;d reconsider using their services after this scenario. After all, security hardening upstream packages is among the reasons you&#x27;re supposed to use them.</div><br/></div></div></div></div><div id="39921845" class="c"><input type="checkbox" id="c-39921845" checked=""/><div class="controls bullet"><span class="by">rlpb</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39916323">parent</a><span>|</span><a href="#39921301">prev</a><span>|</span><a href="#39927158">next</a><span>|</span><label class="collapse" for="c-39921845">[-]</label><label class="expand" for="c-39921845">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more than an individual or an organisation. The industry as a whole has favoured not caring about dependencies or where they come from in order to increase velocity. Concerns about supply chain (before we even had the term) were dismissed as &quot;unlikely and we won&#x27;t be blamed because everyone&#x27;s doing it&quot;).<p>The organisations that did have some measures were complained about loudly, and they diluted their requirements over time in order to avoid stagnation. Example:  Debian used to have a &quot;key must be signed by three other Debian developers&quot; requirement. They had to relax the requirement in part because, from the perspective of the wider ecosystem, nobody else had these onerous requirements and so they seemed unreasonable (although Covid was the final straw). If we&#x27;d had an ecosystem-wide culture of &quot;know your upstream maintainer&quot;, then this kind of expectation as a condition of maintainership would be normal, we&#x27;d have much better tooling to do it, and such requirements would not have seemed onerous to anyone. It&#x27;s like there&#x27;s an Overton Window of what is acceptable, that has perhaps shifted too far in favour of velocity and at the cost of security, and this kind of incident is needed to get people to sit up and take notice.<p>This incident provides the ecosystem as a whole the opportunity to consider slowing down in order to improve supply chain security. There&#x27;s no silver bullet, but there are a variety of measures available to mitigate, such as trying to know the real world identity of maintainers, more cautious code review, banning practices such as binary blobs in source trees, better tooling to roll back, etc. All of these require slowing down velocity in some way. Change can only realistically happen by shifting the Overton Window across the ecosystem as a whole, with everyone accepting the hit to velocity. I think that an individual or organisation within the ecosystem isn&#x27;t really in a position to stray too far from this Overton Window without becoming ineffective, because of the way that ecosystem elements all depend on each other.<p>&gt; If you&#x27;re unwilling to do that, sorry mate, you&#x27;re just unprofessional.<p>There are no professionals doing what you suggest today, because if they did, they&#x27;d be out-competed on price immediately. It&#x27;s too expensive and customers do not care.</div><br/></div></div></div></div><div id="39927158" class="c"><input type="checkbox" id="c-39927158" checked=""/><div class="controls bullet"><span class="by">begueradj</span><span>|</span><a href="#39915022">parent</a><span>|</span><a href="#39916323">prev</a><span>|</span><a href="#39918404">next</a><span>|</span><label class="collapse" for="c-39927158">[-]</label><label class="expand" for="c-39927158">[1 more]</label></div><br/><div class="children"><div class="content">&gt;, is probably only entry-to-mid level complexity for the folks working at that stage.<p>On the contrary: the developers and maintainers who are more informed than us described it as highly sophisticated attack. I also read early InfoSec (information security) articles which were able to only describe a part of the code, not the whole strategy behind the attack because, again, the attack and code are sophisticated. You can also read early InfoSec articles which describe the attack in different ways simply because it was not that simple to understand. Then I read articles saying something like this: &quot;Finally it seems it&#x27;s an RCE attack&quot;.<p>Of course, now that even a scanner is developed to detect that vulnerability on your server, we can all claim: &quot;Oh that was a so simple and stupid attack, how come no one detected it much earlier ?!&quot;</div><br/></div></div><div id="39918404" class="c"><input type="checkbox" id="c-39918404" checked=""/><div class="controls bullet"><span class="by">bipson</span><span>|</span><a href="#39915022">parent</a><span>|</span><a href="#39927158">prev</a><span>|</span><a href="#39925589">next</a><span>|</span><label class="collapse" for="c-39918404">[-]</label><label class="expand" for="c-39918404">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why I don&#x27;t see e.g. TP-Link basing their router firmware on OpenWRT as a win, and why I want the &quot;vanilla&quot; upstream project (or something that tracks upstream by design) running on my devices.<p>Applies to all of my devices btw. I don&#x27;t like Android having to use an old kernel, I didn&#x27;t like MacOS running some ancient Darwin&#x2F;BSD thing, etc. The required effort for backporting worries me.<p>Don&#x27;t get me wrong, I&#x27;m not saying OSS has no vulns.</div><br/><div id="39923241" class="c"><input type="checkbox" id="c-39923241" checked=""/><div class="controls bullet"><span class="by">doubled112</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39918404">parent</a><span>|</span><a href="#39925589">next</a><span>|</span><label class="collapse" for="c-39923241">[-]</label><label class="expand" for="c-39923241">[1 more]</label></div><br/><div class="children"><div class="content">More orgs directly contributing to upstream is best in my eyes too.  I&#x27;m not against forking, but there are usually real benefits to running the latest version of the most popular one.<p>One opposite of this I&#x27;ve seen is Mikrotik&#x27;s RouterOS.  I&#x27;m under the understanding that they usually reimplement software and protocols rather than depending on an upstream.<p>I&#x27;d imagine that is what leads to issues such as missing UDP support in OpenVPN for 10 years, and I&#x27;m not sure it gives me the warmest fuzzy feeling about security.  Pros and cons, I suppose.  More secure because it&#x27;s not the same target as everybody else.  Less secure because there are fewer users and eyes looking at this thing.</div><br/></div></div></div></div><div id="39925589" class="c"><input type="checkbox" id="c-39925589" checked=""/><div class="controls bullet"><span class="by">fieldcny</span><span>|</span><a href="#39915022">parent</a><span>|</span><a href="#39918404">prev</a><span>|</span><a href="#39918161">next</a><span>|</span><label class="collapse" for="c-39925589">[-]</label><label class="expand" for="c-39925589">[1 more]</label></div><br/><div class="children"><div class="content">Any moderately well run shop will have a mechanism to get updates when a dependency of theirs has a security issues, depending on the line of business it may actually be required by a regulator or certification body (eg PCI etc)<p>We should probably be more afraid of the backdoors you can’t see in proprietary that would almost never be found.</div><br/></div></div><div id="39918649" class="c"><input type="checkbox" id="c-39918649" checked=""/><div class="controls bullet"><span class="by">0xdeadbeefbabe</span><span>|</span><a href="#39915022">parent</a><span>|</span><a href="#39918161">prev</a><span>|</span><a href="#39911156">next</a><span>|</span><label class="collapse" for="c-39918649">[-]</label><label class="expand" for="c-39918649">[2 more]</label></div><br/><div class="children"><div class="content">&gt; there will be hundreds of cases like it uncovered in the next few months, I am certain of it.<p>&quot;Given the activity over several weeks, the committer is either directly
involved or there was some quite severe compromise of their
system. Unfortunately the latter looks like the less likely explanation, given
they communicated on various lists about the &quot;fixes&quot; mentioned above.&quot; (<a href="https:&#x2F;&#x2F;www.openwall.com&#x2F;lists&#x2F;oss-security&#x2F;2024&#x2F;03&#x2F;29&#x2F;4" rel="nofollow">https:&#x2F;&#x2F;www.openwall.com&#x2F;lists&#x2F;oss-security&#x2F;2024&#x2F;03&#x2F;29&#x2F;4</a>)<p>So, it&#x27;s like story of those security researchers injecting bugs into the kernel <a href="https:&#x2F;&#x2F;thehackernews.com&#x2F;2021&#x2F;04&#x2F;minnesota-university-apologizes-for.html&amp;ved=2ahUKEwjXz96VraaFAxXKLUQIHQLiCmIQFnoECBMQAw&amp;usg=AOvVaw31l0n2EeBePe4cWE8rqjau" rel="nofollow">https:&#x2F;&#x2F;thehackernews.com&#x2F;2021&#x2F;04&#x2F;minnesota-university-apolo...</a><p>I&#x27;m saying this isn&#x27;t that easy to pull off, and it&#x27;s unlikely we&#x27;ll see hundreds of similar cases.</div><br/><div id="39926660" class="c"><input type="checkbox" id="c-39926660" checked=""/><div class="controls bullet"><span class="by">diego_sandoval</span><span>|</span><a href="#39915022">root</a><span>|</span><a href="#39918649">parent</a><span>|</span><a href="#39911156">next</a><span>|</span><label class="collapse" for="c-39926660">[-]</label><label class="expand" for="c-39926660">[1 more]</label></div><br/><div class="children"><div class="content">&gt; this isn&#x27;t that easy to pull off,<p>How much does it cost in money? 400k? 600k? 1M? That&#x27;s peanuts for any three letter agency from the US, UK, China, etc.</div><br/></div></div></div></div></div></div><div id="39911156" class="c"><input type="checkbox" id="c-39911156" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#39915022">prev</a><span>|</span><a href="#39918632">next</a><span>|</span><label class="collapse" for="c-39911156">[-]</label><label class="expand" for="c-39911156">[105 more]</label></div><br/><div class="children"><div class="content">As a longtime autotools-hater I would say this justifies my position, but any build system complex enough to be multiplatform is going to be inscrutable enough to let somebody slip something in like this. But it really is a problem that so much software is built with what&#x27;s essentially become a giant cargo cult-style shell script whose pieces no one person understands all of.</div><br/><div id="39911234" class="c"><input type="checkbox" id="c-39911234" checked=""/><div class="controls bullet"><span class="by">echoangle</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39914254">next</a><span>|</span><label class="collapse" for="c-39911234">[-]</label><label class="expand" for="c-39911234">[84 more]</label></div><br/><div class="children"><div class="content">I think the common usage of bash and other languages with a dense and complicated syntax is the root problem here. If build scripts were written in python, you would have a hard time obfuscating backdoors, because everyone would see that it is weird code. Bash code is just assumed to be normal when you can’t read it.</div><br/><div id="39911299" class="c"><input type="checkbox" id="c-39911299" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39911304">next</a><span>|</span><label class="collapse" for="c-39911299">[-]</label><label class="expand" for="c-39911299">[64 more]</label></div><br/><div class="children"><div class="content">I think the issue is that build systems are often build on a completely different language - python with some weird build framework is likely as inscrutable as bash and autotools to someone who doesn&#x27;t use python.<p>You <i>can</i> write pretty straightforward readable bash, just as I&#x27;m sure you can write pretty gnarly python. Especially if you&#x27;re intentionally trying to obfuscate.</div><br/><div id="39912167" class="c"><input type="checkbox" id="c-39912167" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911299">parent</a><span>|</span><a href="#39911348">next</a><span>|</span><label class="collapse" for="c-39912167">[-]</label><label class="expand" for="c-39912167">[38 more]</label></div><br/><div class="children"><div class="content">Man, this <i>sounds</i> right, but I dunno ... I feel like even &quot;simple&quot; shell scripts tend toward more inscrutability than all but the most questionable python code I&#x27;ve ever written. Just comparing my dotfiles - every bit of which I understood when I wrote them - to the gnarliest sections of a big python app I work on ... I just really feel like at least <i>some</i> of this inscrutability issue can truly be laid at the feet of shell &#x2F; bash as a language.</div><br/><div id="39913792" class="c"><input type="checkbox" id="c-39913792" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912167">parent</a><span>|</span><a href="#39915188">next</a><span>|</span><label class="collapse" for="c-39913792">[-]</label><label class="expand" for="c-39913792">[18 more]</label></div><br/><div class="children"><div class="content">Shell is evil mainly because it&#x27;s so old. It&#x27;s largely unchanged since 1978 and had to run on incredibly resource limited machines. What it could achieve on those machines was amazing. Tradeoffs would be different today, e.g. PowerShell.</div><br/><div id="39914284" class="c"><input type="checkbox" id="c-39914284" checked=""/><div class="controls bullet"><span class="by">SlightlyLeftPad</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39913792">parent</a><span>|</span><a href="#39917066">next</a><span>|</span><label class="collapse" for="c-39914284">[-]</label><label class="expand" for="c-39914284">[14 more]</label></div><br/><div class="children"><div class="content">A big pet peeve of mine is that shell is written off as evil but the only reason I ever hear is basically a variation of “I don’t understand it, therefore it scares me.” The reality is, unlike _really_ old languages like COBOL or RPG, bash is still literally everywhere, it’s installed on practically every linux machine by default which makes deploying a shell script completely trivial. It’s certainly under appreciated and because it’s ubiquitous, widely used in build processes, there’s a responsibility to learn it. It’s not hard, it’s not a wildly complex language.<p>I don’t think these issues would necessarily be solved at all by waving a hand and replacing it with similarly complex build tools. Bazel, for example, can be a daunting tool to fully grasp. Any tool used should be well understood. Easier said than done of course.</div><br/><div id="39914339" class="c"><input type="checkbox" id="c-39914339" checked=""/><div class="controls bullet"><span class="by">Espressosaurus</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914284">parent</a><span>|</span><a href="#39916396">next</a><span>|</span><label class="collapse" for="c-39914339">[-]</label><label class="expand" for="c-39914339">[12 more]</label></div><br/><div class="children"><div class="content">If a language has more footguns than guns-pointed-at-not-my-feet, I consider that a problem with the language.<p>And shell has a lot of footguns.</div><br/><div id="39922167" class="c"><input type="checkbox" id="c-39922167" checked=""/><div class="controls bullet"><span class="by">eitland</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914339">parent</a><span>|</span><a href="#39914461">next</a><span>|</span><label class="collapse" for="c-39922167">[-]</label><label class="expand" for="c-39922167">[3 more]</label></div><br/><div class="children"><div class="content">Agree.<p>As long as you apply the same standards to what seems to be everyones darling: Javascript.<p>Javascript has the same amount of footguns as PHP and Bash but has gotten away with it by being cute (and having a whole menagerie if support tools around it to make it possible for ordinary people to write workable code in it).<p>(Yes, I am qualified to rant about Javascript BTW. I wrote a working map rendering system with pan and zoom and automatic panning based on GPS location using ECMAScript and SVG back in the spring of 2005. I think roughly half a year before Google Maps became public. Back before <i>all</i> the modern JS tooling existed. All I had was JEdit with syntax highlighting. Perl at least let me put breakpoints in my code even back then.<p>And yes, I have written more JS since then.)</div><br/><div id="39922316" class="c"><input type="checkbox" id="c-39922316" checked=""/><div class="controls bullet"><span class="by">Espressosaurus</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39922167">parent</a><span>|</span><a href="#39914461">next</a><span>|</span><label class="collapse" for="c-39922316">[-]</label><label class="expand" for="c-39922316">[2 more]</label></div><br/><div class="children"><div class="content">I specifically avoided web development because of Javascript and its plethora and ever-changing set of frameworks. So IMO, it absolutely counts.</div><br/><div id="39922842" class="c"><input type="checkbox" id="c-39922842" checked=""/><div class="controls bullet"><span class="by">eitland</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39922316">parent</a><span>|</span><a href="#39914461">next</a><span>|</span><label class="collapse" for="c-39922842">[-]</label><label class="expand" for="c-39922842">[1 more]</label></div><br/><div class="children"><div class="content">FWIW it has actually become better the last few years:<p>Now you <i>can</i> at least just stick to React and TypeScript and bundle it using Webpack and have months of relative sanity between each time you have to throw something out and replace it.</div><br/></div></div></div></div></div></div><div id="39914461" class="c"><input type="checkbox" id="c-39914461" checked=""/><div class="controls bullet"><span class="by">SlightlyLeftPad</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914339">parent</a><span>|</span><a href="#39922167">prev</a><span>|</span><a href="#39916396">next</a><span>|</span><label class="collapse" for="c-39914461">[-]</label><label class="expand" for="c-39914461">[8 more]</label></div><br/><div class="children"><div class="content">I’d argue that every language is loaded full of foot guns. If you’re encountering those foot guns on a regular basis, it’s an issue with the author.<p>That said, what can help drastically here are well-defined best practices and conventions built into the language which, admittedly, bash really doesn’t have.</div><br/><div id="39914871" class="c"><input type="checkbox" id="c-39914871" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914461">parent</a><span>|</span><a href="#39916396">next</a><span>|</span><label class="collapse" for="c-39914871">[-]</label><label class="expand" for="c-39914871">[7 more]</label></div><br/><div class="children"><div class="content">Can you point to 3 python foot guns, for instance?</div><br/><div id="39914977" class="c"><input type="checkbox" id="c-39914977" checked=""/><div class="controls bullet"><span class="by">s1dev</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914871">parent</a><span>|</span><a href="#39916396">next</a><span>|</span><label class="collapse" for="c-39914977">[-]</label><label class="expand" for="c-39914977">[6 more]</label></div><br/><div class="children"><div class="content">I’m generally in agreement with the anti-bash camp, but I can name about that many :)<p>- Mutating default arguments to functions, so subsequent calls have different behavior<p>- Somewhat particular rules around creating references vs copies<p>- Things that look like lambda captures but aren’t quite</div><br/><div id="39916415" class="c"><input type="checkbox" id="c-39916415" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914977">parent</a><span>|</span><a href="#39919942">next</a><span>|</span><label class="collapse" for="c-39916415">[-]</label><label class="expand" for="c-39916415">[3 more]</label></div><br/><div class="children"><div class="content">Yep, every language has footguns and other kinds of quirks, but I contend that 
the &quot;footguns per character&quot; ratio in shell is unusually high. (It is not unique in having a high ratio though; other popular languages, like c++ for instance, also have this issue.)</div><br/><div id="39922262" class="c"><input type="checkbox" id="c-39922262" checked=""/><div class="controls bullet"><span class="by">eitland</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39916415">parent</a><span>|</span><a href="#39919942">next</a><span>|</span><label class="collapse" for="c-39922262">[-]</label><label class="expand" for="c-39922262">[2 more]</label></div><br/><div class="children"><div class="content">The worst (level of nastyness * usage) offenders all probably have a reason for being popular despite their flaws:<p>- Bash: installed everywhere you want to work (yes, who actually <i>wants</i> to work on Windows ;-)<p>- C&#x2F;C++: when speed&#x2F;size matters there was no alternative except Assembly until recently<p>- Javascript: until recently this was the most sane option for client side code on the web (Active X and Java applets existed yes but managed to be even worse.)<p>- PHP: Low cost hosting, Function-As-A-Service way before that became popular, shared nothing architecture, <i>instant</i> reload for local development bliss</div><br/><div id="39922385" class="c"><input type="checkbox" id="c-39922385" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39922262">parent</a><span>|</span><a href="#39919942">next</a><span>|</span><label class="collapse" for="c-39922385">[-]</label><label class="expand" for="c-39922385">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t agree more.</div><br/></div></div></div></div></div></div><div id="39919942" class="c"><input type="checkbox" id="c-39919942" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914977">parent</a><span>|</span><a href="#39916415">prev</a><span>|</span><a href="#39915014">next</a><span>|</span><label class="collapse" for="c-39919942">[-]</label><label class="expand" for="c-39919942">[1 more]</label></div><br/><div class="children"><div class="content">- string vs. list &quot;in&quot; (&#x27;a&#x27; in &#x27;a&#x27; is True, but &#x27;a&#x27; in [&#x27;a&#x27;] is also True)<p>- cannot know which object attributes are private or public (and some classes use settable properties so you can&#x27;t say &quot;just don&#x27;t set any attributes on non-dataclass objects&quot;)</div><br/></div></div><div id="39915014" class="c"><input type="checkbox" id="c-39915014" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914977">parent</a><span>|</span><a href="#39919942">prev</a><span>|</span><a href="#39916396">next</a><span>|</span><label class="collapse" for="c-39915014">[-]</label><label class="expand" for="c-39915014">[1 more]</label></div><br/><div class="children"><div class="content">Touche!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39916396" class="c"><input type="checkbox" id="c-39916396" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914284">parent</a><span>|</span><a href="#39914339">prev</a><span>|</span><a href="#39917066">next</a><span>|</span><label class="collapse" for="c-39916396">[-]</label><label class="expand" for="c-39916396">[1 more]</label></div><br/><div class="children"><div class="content">I think a good way to evaluate languages from this perspective is through the lens of how easy it is to maintain understanding over time. I have learned bash well three or four times now, but I know now that I&#x27;m never going to remember enough of its quirks through the interim periods where I&#x27;m not focused on it, to be able to grok arbitrary scripts without refreshing my memory. This is very different for languages like java, go, python, and some others, which have their quirks, sure, but a much lower quirks per character ratio.<p>I might agree with &quot;it&#x27;s not hard to learn it&quot;, but I don&#x27;t agree with &quot;it&#x27;s not hard to remember it&quot;.</div><br/></div></div></div></div><div id="39917066" class="c"><input type="checkbox" id="c-39917066" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39913792">parent</a><span>|</span><a href="#39914284">prev</a><span>|</span><a href="#39916519">next</a><span>|</span><label class="collapse" for="c-39917066">[-]</label><label class="expand" for="c-39917066">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think PowerShell is a big improvement, though. Still allows no signature checking of functions. Shells are optimized for fast entry, not for writing comprehensible (or even secure) programs.</div><br/></div></div><div id="39916519" class="c"><input type="checkbox" id="c-39916519" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39913792">parent</a><span>|</span><a href="#39917066">prev</a><span>|</span><a href="#39918385">next</a><span>|</span><label class="collapse" for="c-39916519">[-]</label><label class="expand" for="c-39916519">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Shell is evil mainly because it&#x27;s so old.<p>I really don&#x27;t understand this point, its a script language, how old is it doesn&#x27;t make any difference. I&#x27;ve come accross some Powershell scripts that were unreadable down to its verbosity with certain things, and if you don&#x27;t already know all the flags and options for it, it&#x27;s hopeless to try and understand.<p>Both serve a purpose, neither are &#x27;evil&#x27;.</div><br/></div></div><div id="39918385" class="c"><input type="checkbox" id="c-39918385" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39913792">parent</a><span>|</span><a href="#39916519">prev</a><span>|</span><a href="#39915188">next</a><span>|</span><label class="collapse" for="c-39918385">[-]</label><label class="expand" for="c-39918385">[1 more]</label></div><br/><div class="children"><div class="content">There is Xonsh which is a Python shell. I don&#x27;t know why everyone hasn&#x27;t switched to it already as default.</div><br/></div></div></div></div><div id="39915188" class="c"><input type="checkbox" id="c-39915188" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912167">parent</a><span>|</span><a href="#39913792">prev</a><span>|</span><a href="#39912804">next</a><span>|</span><label class="collapse" for="c-39915188">[-]</label><label class="expand" for="c-39915188">[5 more]</label></div><br/><div class="children"><div class="content">&gt;  I feel like even &quot;simple&quot; shell scripts tend toward more inscrutability than all but the most questionable python code I&#x27;ve ever written.<p>When you use long options in bash (scripts), it becomes very readable, but it&#x27;s not a widespread practice. I <i>always</i> use long options while writing scripts.<p>Consider these two examples, which is very straightforward:<p>- curl -fsSL $URL | bash<p>- curl --fail --silent --show-error --location $URL | bash<p>The second one almost &quot;talks you through&quot;.</div><br/><div id="39916468" class="c"><input type="checkbox" id="c-39916468" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39915188">parent</a><span>|</span><a href="#39912804">next</a><span>|</span><label class="collapse" for="c-39916468">[-]</label><label class="expand" for="c-39916468">[4 more]</label></div><br/><div class="children"><div class="content">IMO, that&#x27;s not where the inscrutability comes from. Rather, it is things like many useful (and thus used) constructs being implemented with line noise like `&quot;$(foo)&quot;`, `2&gt;&amp;1 &amp;`, `${foo:-bar}`, etc., finicky control flow syntax, surprising defaults that can be changed within unclear scopes, etc.</div><br/><div id="39916508" class="c"><input type="checkbox" id="c-39916508" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39916468">parent</a><span>|</span><a href="#39912804">next</a><span>|</span><label class="collapse" for="c-39916508">[-]</label><label class="expand" for="c-39916508">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, but you can also expand these. If not syntactically, by adding temporary variables and comments around these complex parts.<p>It&#x27;s true that Bash and Perl has one of the most contractible syntax around, but it&#x27;s not impossible to make it more understandable.<p>However, these parts of codebases are considered &quot;supportive&quot; and treated as second class citizens, and never receives the same love core parts of the codebases enjoy. That&#x27;s a big mistake IMO.<p>When you make something more readable all around, hiding things becomes harder exponentially.</div><br/><div id="39926947" class="c"><input type="checkbox" id="c-39926947" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39916508">parent</a><span>|</span><a href="#39912804">next</a><span>|</span><label class="collapse" for="c-39926947">[-]</label><label class="expand" for="c-39926947">[2 more]</label></div><br/><div class="children"><div class="content">I have seen people write bash scripts with a lot of love and attention trying really hard to pay attention to modern best practices and avoiding known pitfalls and using shellcheck. It still looked like shit imo.<p>I challenge you to find a single easily readable &gt;100 line bash script and link it here (I do think small scripts can be fine).</div><br/><div id="39927313" class="c"><input type="checkbox" id="c-39927313" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39926947">parent</a><span>|</span><a href="#39912804">next</a><span>|</span><label class="collapse" for="c-39927313">[-]</label><label class="expand" for="c-39927313">[1 more]</label></div><br/><div class="children"><div class="content">While not completely up to my own standards, this is pretty neat and readable: <a href="https:&#x2F;&#x2F;rclone.org&#x2F;install.sh" rel="nofollow">https:&#x2F;&#x2F;rclone.org&#x2F;install.sh</a><p>I may add more if I have time today.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39912804" class="c"><input type="checkbox" id="c-39912804" checked=""/><div class="controls bullet"><span class="by">clnhlzmn</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912167">parent</a><span>|</span><a href="#39915188">prev</a><span>|</span><a href="#39911348">next</a><span>|</span><label class="collapse" for="c-39912804">[-]</label><label class="expand" for="c-39912804">[14 more]</label></div><br/><div class="children"><div class="content">This is totally true and the bash apologists are delusional.</div><br/><div id="39914144" class="c"><input type="checkbox" id="c-39914144" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912804">parent</a><span>|</span><a href="#39913520">next</a><span>|</span><label class="collapse" for="c-39914144">[-]</label><label class="expand" for="c-39914144">[10 more]</label></div><br/><div class="children"><div class="content">So are some Python advocates, too. The thing that&#x27;s worse than a bash script made of Perlish line noise, is a piece of &quot;clean code&quot; dead simple Python that&#x27;s 80% __language__.boilerplate, 20% logic, smeared over 10x the lines because small functions calling small functions are cool. No one has enough working memory to keep track of what&#x27;s going on there. Instead, your eyes glaze over it and you convince yourself you understand what&#x27;s going on.<p>Also, Python build scripts can be living hell too, full of dancing devils that could be introducing backdoors left and right - just look at your average Conan recipe, particularly for larger&#x2F;more sensitive libraries, like OpenSSL or libcurl.</div><br/><div id="39916497" class="c"><input type="checkbox" id="c-39916497" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914144">parent</a><span>|</span><a href="#39914878">next</a><span>|</span><label class="collapse" for="c-39916497">[-]</label><label class="expand" for="c-39916497">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, my comment wasn&#x27;t meant to single out python as particularly good. I think the comparison I drew between its inscrutability and that of shell &#x2F; bash would apply to nearly all other languages as well.</div><br/></div></div><div id="39914878" class="c"><input type="checkbox" id="c-39914878" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914144">parent</a><span>|</span><a href="#39916497">prev</a><span>|</span><a href="#39913520">next</a><span>|</span><label class="collapse" for="c-39914878">[-]</label><label class="expand" for="c-39914878">[8 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a lot of emotive language, can you actually link to some actual examples.</div><br/><div id="39915500" class="c"><input type="checkbox" id="c-39915500" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914878">parent</a><span>|</span><a href="#39915513">next</a><span>|</span><label class="collapse" for="c-39915500">[-]</label><label class="expand" for="c-39915500">[3 more]</label></div><br/><div class="children"><div class="content">I can understand the frustration when those small functions are not well-named, so you have to inspect what they do.</div><br/><div id="39915653" class="c"><input type="checkbox" id="c-39915653" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39915500">parent</a><span>|</span><a href="#39915513">next</a><span>|</span><label class="collapse" for="c-39915653">[-]</label><label class="expand" for="c-39915653">[2 more]</label></div><br/><div class="children"><div class="content">You already have to inspect everything if you want to review&#x2F;audit a build script. Small functions - and I specifically mean functions being written small because of misguided ideas of &quot;clean code&quot;, as opposed to e.g. useful abstraction or reusability - become especially painful there, as you have that much more code to read, and things that go together logically (or execution-wise) are now smeared around the file.<p>And you can&#x27;t really name such small functions well anyway, not when they&#x27;re broken down for the sake of being small. Case in point, some build script I saw this week had function like `rename_foo_dll_unit_tests` calling `rename_foo_dll_in_folder` calling `rename_foo_dll` calling `rename_dlls`, a distinct call chain of four non-reused functions that should&#x27;ve been at most two functions.<p>Are all Python build scripts like that? Not really. It&#x27;s just a style I&#x27;ve seen repeatedly. The same is the case with inscrutable Bash scripts. I think it speaks more about common practices than the language itself (notwithstanding Bash not really being meant for writing longer programs).</div><br/><div id="39916028" class="c"><input type="checkbox" id="c-39916028" checked=""/><div class="controls bullet"><span class="by">medstrom</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39915653">parent</a><span>|</span><a href="#39915513">next</a><span>|</span><label class="collapse" for="c-39916028">[-]</label><label class="expand" for="c-39916028">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like DRY run amok indeed.  Maybe a compiler or linter could detect these cases and complain &quot;this function is only called from one place&quot; :)</div><br/></div></div></div></div></div></div><div id="39915513" class="c"><input type="checkbox" id="c-39915513" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914878">parent</a><span>|</span><a href="#39915500">prev</a><span>|</span><a href="#39913520">next</a><span>|</span><label class="collapse" for="c-39915513">[-]</label><label class="expand" for="c-39915513">[4 more]</label></div><br/><div class="children"><div class="content">I mentioned Conan recipes, didn&#x27;t I? :). Those are my most recent sources of frustration.</div><br/><div id="39916092" class="c"><input type="checkbox" id="c-39916092" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39915513">parent</a><span>|</span><a href="#39913520">next</a><span>|</span><label class="collapse" for="c-39916092">[-]</label><label class="expand" for="c-39916092">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never heard of a conan language, and a couple of URLs to some bad recipes would not go amiss.</div><br/><div id="39916498" class="c"><input type="checkbox" id="c-39916498" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39916092">parent</a><span>|</span><a href="#39913520">next</a><span>|</span><label class="collapse" for="c-39916498">[-]</label><label class="expand" for="c-39916498">[2 more]</label></div><br/><div class="children"><div class="content">Conan is a package manager for C&#x2F;C++, written in Python. See: <a href="https:&#x2F;&#x2F;conan.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;conan.io&#x2F;</a>.<p>The way it works is that you can provide &quot;recipes&quot;, which are Python scripts, that automate the process of collecting source code (usually from a remote Git repository, or a remote source tarball), patching it, making its dependencies and transitive dependencies available, building for specific platform and architecture (via any number of build systems), then packaging up and serving binaries. There&#x27;s a <i>lot</i> of complexity involved.<p>Here are the two recipes I mentioned:<p>libcurl: <a href="https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;blob&#x2F;master&#x2F;recipes&#x2F;libcurl&#x2F;all&#x2F;conanfile.py">https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;blob&#x2F;master&#x2F;r...</a><p>OpenSSL v3: <a href="https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;blob&#x2F;master&#x2F;recipes&#x2F;openssl&#x2F;3.x.x&#x2F;conanfile.py">https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;blob&#x2F;master&#x2F;r...</a><p>Now, for the sake of this thread I want to highlight three things here:<p>- Conan recipes are usually made by people unaffiliated with the libraries they&#x27;re packaging;<p>- The recipes are fully Turing-complete, do a lot of work, have their own bugs - therefore they should really be treated as software comonents themselves, for the purpose of OSS clearing&#x2F;supply chain verification, except as far as I know, nobody does it;<p>- The recipes can, and do, patch source code and build scripts. There&#x27;s supporting infrastruture for this built into Conan, and of course one can also do it by brute-force search and replace. See e.g. ZLib recipe that <i>does it both at the same time</i>:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;blob&#x2F;7b0ac710d99d15b926edd40b3b07bbc83cb5444f&#x2F;recipes&#x2F;zlib&#x2F;all&#x2F;conanfile.py#L66">https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;blob&#x2F;7b0ac710...</a> -- `_patch_sources` does <i>both</i> direct search-and-replace in source files, <i>and</i> applies the patches from <a href="https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;tree&#x2F;master&#x2F;recipes&#x2F;zlib&#x2F;all&#x2F;patches">https:&#x2F;&#x2F;github.com&#x2F;conan-io&#x2F;conan-center-index&#x2F;tree&#x2F;master&#x2F;r...</a>.<p>Good luck keeping track of what exact code goes into your program, when using Turing-complete &quot;recipe&quot; programs fetched from the Internet, which fetch your libraries from <i>somewhere else</i> on the Internet.</div><br/><div id="39916971" class="c"><input type="checkbox" id="c-39916971" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39916498">parent</a><span>|</span><a href="#39913520">next</a><span>|</span><label class="collapse" for="c-39916971">[-]</label><label class="expand" for="c-39916971">[1 more]</label></div><br/><div class="children"><div class="content">That was a really, really good answer, thanks.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39913520" class="c"><input type="checkbox" id="c-39913520" checked=""/><div class="controls bullet"><span class="by">lobocinza</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912804">parent</a><span>|</span><a href="#39914144">prev</a><span>|</span><a href="#39914904">next</a><span>|</span><label class="collapse" for="c-39913520">[-]</label><label class="expand" for="c-39913520">[2 more]</label></div><br/><div class="children"><div class="content">It depends on the use case. Bash code can be elegant, Python code can be ugly. I&#x27;m not saying those are the average cases but complex code regardless of the language often is ugly even with effort to make it more readable.</div><br/><div id="39925988" class="c"><input type="checkbox" id="c-39925988" checked=""/><div class="controls bullet"><span class="by">clnhlzmn</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39913520">parent</a><span>|</span><a href="#39914904">next</a><span>|</span><label class="collapse" for="c-39925988">[-]</label><label class="expand" for="c-39925988">[1 more]</label></div><br/><div class="children"><div class="content">Oh I get it. Sometimes bash is the right tool for the job. I think that’s just mostly an unfortunate historical artifact though. It’s hard to argue it’s intuitive or “clean” or ${POSITIVE_ADJECTIVE} in the average case.</div><br/></div></div></div></div><div id="39914904" class="c"><input type="checkbox" id="c-39914904" checked=""/><div class="controls bullet"><span class="by">egorfine</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912804">parent</a><span>|</span><a href="#39913520">prev</a><span>|</span><a href="#39911348">next</a><span>|</span><label class="collapse" for="c-39914904">[-]</label><label class="expand" for="c-39914904">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bash apologist and I totally stand by your words. It&#x27;s delusional. Bash totally has to go.</div><br/></div></div></div></div></div></div><div id="39911348" class="c"><input type="checkbox" id="c-39911348" checked=""/><div class="controls bullet"><span class="by">echoangle</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911299">parent</a><span>|</span><a href="#39912167">prev</a><span>|</span><a href="#39915038">next</a><span>|</span><label class="collapse" for="c-39911348">[-]</label><label class="expand" for="c-39911348">[18 more]</label></div><br/><div class="children"><div class="content">The problem is that obfuscated bash is considered normal. If unreadable bash was not allowed to be committed, it would be much harder to hide stuff like this. But unreadable bash code is not suspicious, because it is kind of expected. That’s the main problem in my opinion.</div><br/><div id="39911486" class="c"><input type="checkbox" id="c-39911486" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911348">parent</a><span>|</span><a href="#39911678">next</a><span>|</span><label class="collapse" for="c-39911486">[-]</label><label class="expand" for="c-39911486">[2 more]</label></div><br/><div class="children"><div class="content">Lots of autogenerated code appears &quot;obfuscated&quot; - certainly less clear than if a programmer would have written it directly.<p>But all this relies on one specific thing about the autotools ecosystem - that shipping the generated code is considered normal.<p>I know of no other build system that does this? It feels weird, like shipping cmake-generated makefiles instead of just generating them yourself, or something like scons or meson being packaged <i>with</i> the tarball instead of requiring an eternal installation.<p>That&#x27;s a <i>lot</i> of extra code to review, before you even get to any kind of language differences.</div><br/><div id="39913298" class="c"><input type="checkbox" id="c-39913298" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911486">parent</a><span>|</span><a href="#39911678">next</a><span>|</span><label class="collapse" for="c-39913298">[-]</label><label class="expand" for="c-39913298">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Lots of autogenerated code appears &quot;obfuscated&quot; - certainly less clear than if a programmer would have written it directly.<p>That&#x27;s why you don&#x27;t commit auto-generated code.  You commit the generating code, and review that.<p>Same reason we don&#x27;t stick compiled binaries in our repositories.  Binary executables are just auto-generated machine code.</div><br/></div></div></div></div><div id="39911678" class="c"><input type="checkbox" id="c-39911678" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911348">parent</a><span>|</span><a href="#39911486">prev</a><span>|</span><a href="#39911615">next</a><span>|</span><label class="collapse" for="c-39911678">[-]</label><label class="expand" for="c-39911678">[7 more]</label></div><br/><div class="children"><div class="content">This probably varies widely, because unreadable bash is absolutely <i>not</i> considered normal, nor would pass code review in any of my projects.<p>On a slightly different note, unless the application is written in python, it grosses me out to think of writing scripts in python.  IMHO, if the script is more complex that what bash is good at (my general rule of thumb is do you need a data structure like an array or hash?  then don&#x27;t use bash), then use the same language that the application is written in.  It really grosses me out to think of a rails application with scripts written in python.  Same with most languages&#x2F;platforms.</div><br/><div id="39911778" class="c"><input type="checkbox" id="c-39911778" checked=""/><div class="controls bullet"><span class="by">echoangle</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911678">parent</a><span>|</span><a href="#39911615">next</a><span>|</span><label class="collapse" for="c-39911778">[-]</label><label class="expand" for="c-39911778">[6 more]</label></div><br/><div class="children"><div class="content">What if your application is written in Rust or C? Would you write your build scripts in these languages, too? I would much prefer a simpler scripting language for this. If you’re already using a scripting language as the main language, you don’t necessarily need to pull in another language just for scripts, of course.</div><br/><div id="39913343" class="c"><input type="checkbox" id="c-39913343" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911778">parent</a><span>|</span><a href="#39921541">next</a><span>|</span><label class="collapse" for="c-39913343">[-]</label><label class="expand" for="c-39913343">[1 more]</label></div><br/><div class="children"><div class="content">Writing a build script in Rust is fine-ish.<p>Writing anything in C is a bad idea these days, and requires active justification that only applies in some situations.  Essentially, almost no new projects should be done in C.<p>Re-doing your build system, or writing a build system for a new project, counts as something new, so should probably not be done in C.<p>In general, I don&#x27;t think your build (or build system) should necessarily be specified in the same language as most of the rest of your system.<p>However I can see that if most of your system is written in language X, then you are pretty much guaranteed to have people who are good at X amongst your developers, so there&#x27;s some natural incentive to use X for the tooling, too.<p>In any case, I would mostly just advice against coding anything complicated in shell scripts, and to stay away from Make and autotools, too.<p>There are lots of modern build systems like Shake, Ninja, Bazel, etc that you can pick from.  They are all have their pros and cons, just like the different distributed version control systems have their pros and cons; but they are better than autotools and bash and Make, just like almost any distributed version control is better than CVS and SVN etc.</div><br/></div></div><div id="39921541" class="c"><input type="checkbox" id="c-39921541" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911778">parent</a><span>|</span><a href="#39913343">prev</a><span>|</span><a href="#39920503">next</a><span>|</span><label class="collapse" for="c-39921541">[-]</label><label class="expand" for="c-39921541">[1 more]</label></div><br/><div class="children"><div class="content">C is probably the best example where I <i>would</i> be fine with scripts in Python (for utility scripts, not build scripts).  Though, if it were me I&#x27;d use Ruby instead as I like that language a lot better, and it has Rake (a ruby-ish version of Make), but that&#x27;s a &quot;flavor of ice cream&quot; kind of choice.</div><br/></div></div><div id="39920503" class="c"><input type="checkbox" id="c-39920503" checked=""/><div class="controls bullet"><span class="by">northzen</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911778">parent</a><span>|</span><a href="#39921541">prev</a><span>|</span><a href="#39912968">next</a><span>|</span><label class="collapse" for="c-39920503">[-]</label><label class="expand" for="c-39920503">[1 more]</label></div><br/><div class="children"><div class="content">Also zig is a good example of not a scripting language which does this job.</div><br/></div></div><div id="39912968" class="c"><input type="checkbox" id="c-39912968" checked=""/><div class="controls bullet"><span class="by">ycombinatrix</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911778">parent</a><span>|</span><a href="#39920503">prev</a><span>|</span><a href="#39911615">next</a><span>|</span><label class="collapse" for="c-39912968">[-]</label><label class="expand" for="c-39912968">[2 more]</label></div><br/><div class="children"><div class="content">build.rs is a thing FYI</div><br/><div id="39915058" class="c"><input type="checkbox" id="c-39915058" checked=""/><div class="controls bullet"><span class="by">dgsb</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912968">parent</a><span>|</span><a href="#39911615">next</a><span>|</span><label class="collapse" for="c-39915058">[-]</label><label class="expand" for="c-39915058">[1 more]</label></div><br/><div class="children"><div class="content">or make.go, for some project it makes sense to not add another language for scripting and building tasks. It way easier for every one to have to master multiple language.</div><br/></div></div></div></div></div></div></div></div><div id="39911615" class="c"><input type="checkbox" id="c-39911615" checked=""/><div class="controls bullet"><span class="by">owlbite</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911348">parent</a><span>|</span><a href="#39911678">prev</a><span>|</span><a href="#39913291">next</a><span>|</span><label class="collapse" for="c-39911615">[-]</label><label class="expand" for="c-39911615">[2 more]</label></div><br/><div class="children"><div class="content">I think the main issue is auto tools tries to support so many different shells&#x2F;versions all with their own foibles, so the resulting cross-compatible code looks obfuscated to a modern user.<p>Something built on python won&#x27;t cover quite as wide a range of (obsolete?) hardware.</div><br/><div id="39913317" class="c"><input type="checkbox" id="c-39913317" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911615">parent</a><span>|</span><a href="#39913291">next</a><span>|</span><label class="collapse" for="c-39913317">[-]</label><label class="expand" for="c-39913317">[1 more]</label></div><br/><div class="children"><div class="content">Python actually covers quite a lot of hardware.  Of course, it does that via an autotools nightmare generated configure script.<p>Of course, you could do the detection logic with some autotools-like shenanigans, but then crunch the data (ie run the logic) on a different computer that can run reasonable software.<p>The detection should all be very small self-contained short pieces of script, that might be gnarly, but only produce something like a boolean or other small amount of data each and don&#x27;t interact (and that would be enforced by some means, like containers or whatever).<p>The logic to tie everything together can be more complicated and can have interactions, but should be written in a sane language in a sane style.</div><br/></div></div></div></div><div id="39913291" class="c"><input type="checkbox" id="c-39913291" checked=""/><div class="controls bullet"><span class="by">salawat</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911348">parent</a><span>|</span><a href="#39911615">prev</a><span>|</span><a href="#39915038">next</a><span>|</span><label class="collapse" for="c-39913291">[-]</label><label class="expand" for="c-39913291">[6 more]</label></div><br/><div class="children"><div class="content">...The main problem is some asshat trying to install a backdoor.<p>I use bash habitually, and every time I have an inscrutable or non-intuitive command, I pair it with a comment explaining what it does. No exceptions.<p>I also don&#x27;t clean up after scripts for debuggability. I will offer an invocation to do the cleanup though after you&#x27;ve ascertained everything worked. Blaming this on bash is like a smith blaming a hammer failing on a carpenter&#x27;s shoddy haft... Not terribly convincing.<p>There was a lot of intentionally obfuscatory measures at play here and tons of weaponization of most conscientious developer&#x27;s adherence to the principle of least astonishment, violations of homoglyphy (using easy to mistake filenames and mixed conventions), degenerative tool invocations (using sed as cat), excessive use&#x2F;nesting of tools (awk script for the RC4 decryptor), the tr, and, to crown it all, <i>malicious use of test data!!!</i><p><i>As a tester, nothing makes me angrier!</i><p>A pox upon them, and may their treachery be returned upon them 7-fold!</div><br/><div id="39913360" class="c"><input type="checkbox" id="c-39913360" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39913291">parent</a><span>|</span><a href="#39914951">next</a><span>|</span><label class="collapse" for="c-39913360">[-]</label><label class="expand" for="c-39913360">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Blaming this on bash is like a smith blaming a hammer failing on a carpenter&#x27;s shoddy haft... Not terribly convincing.<p>If your hammer is repurposed shoe, it&#x27;s fair to blame the tools.</div><br/></div></div><div id="39914951" class="c"><input type="checkbox" id="c-39914951" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39913291">parent</a><span>|</span><a href="#39913360">prev</a><span>|</span><a href="#39915038">next</a><span>|</span><label class="collapse" for="c-39914951">[-]</label><label class="expand" for="c-39914951">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  pair it with a comment<p>A good practice, but not really a defense against malice, because if the expression is inscrutable enough to really need a comment, then it&#x27;s also inscrutable enough that many people won&#x27;t notice that the comment is a lie.</div><br/><div id="39921942" class="c"><input type="checkbox" id="c-39921942" checked=""/><div class="controls bullet"><span class="by">salawat</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914951">parent</a><span>|</span><a href="#39915038">next</a><span>|</span><label class="collapse" for="c-39921942">[-]</label><label class="expand" for="c-39921942">[3 more]</label></div><br/><div class="children"><div class="content">Nothing short of reading the damn code is a defense against malice. I have yet to have any luck in getting people to actually do that.</div><br/><div id="39925590" class="c"><input type="checkbox" id="c-39925590" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39921942">parent</a><span>|</span><a href="#39924708">next</a><span>|</span><label class="collapse" for="c-39925590">[-]</label><label class="expand" for="c-39925590">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s not get into a all-or-nothing fallacy here, my point is that there <i>is</i> an important security difference between:<p>1. Languages where obfuscation techniques look a lot like business as usual.<p>2. Languages where obfuscation techniques look weird compared to business as usual.<p>The presence or lack of comments in #1 situations won&#x27;t really help to bridge the gap.</div><br/></div></div><div id="39924708" class="c"><input type="checkbox" id="c-39924708" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39921942">parent</a><span>|</span><a href="#39925590">prev</a><span>|</span><a href="#39915038">next</a><span>|</span><label class="collapse" for="c-39924708">[-]</label><label class="expand" for="c-39924708">[1 more]</label></div><br/><div class="children"><div class="content">“Why can’t humans just be better computers!” is a naive exercise in futility. This is not the answer, and completely ignores the fact that you yourself certainly make just as many mistakes as everyone else.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39915038" class="c"><input type="checkbox" id="c-39915038" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911299">parent</a><span>|</span><a href="#39911348">prev</a><span>|</span><a href="#39914690">next</a><span>|</span><label class="collapse" for="c-39915038">[-]</label><label class="expand" for="c-39915038">[1 more]</label></div><br/><div class="children"><div class="content">This feels a bit like saying you <i>can</i> run as fast as Usain Bolt. Theoretically many things are possible, but I don&#x27;t think I&#x27;ve ever seen a readable bash script beyond a trivial oneliner and I&#x27;ve seen a lot of bash in my life. Or to maybe explain from a different perspective, ask a room full of developers to write a bash if-else without looking at the docs and you&#x27;ll probably come back with more different options than developers in the room. Ask the same for a language such as Python and you&#x27;ll mostly get one thing.</div><br/></div></div><div id="39914690" class="c"><input type="checkbox" id="c-39914690" checked=""/><div class="controls bullet"><span class="by">deanishe</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911299">parent</a><span>|</span><a href="#39915038">prev</a><span>|</span><a href="#39912122">next</a><span>|</span><label class="collapse" for="c-39914690">[-]</label><label class="expand" for="c-39914690">[4 more]</label></div><br/><div class="children"><div class="content">Python makes it relatively hard to write inscrutable code, and more importantly, it&#x27;s very non-idiomatic, and there would be pushback.<p>WTFing at shell scripts is normal.</div><br/><div id="39914917" class="c"><input type="checkbox" id="c-39914917" checked=""/><div class="controls bullet"><span class="by">egorfine</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914690">parent</a><span>|</span><a href="#39924757">next</a><span>|</span><label class="collapse" for="c-39914917">[-]</label><label class="expand" for="c-39914917">[2 more]</label></div><br/><div class="children"><div class="content">&gt; WTFing at shell scripts is normal<p>&quot;WTFing&quot;. This is brilliant.</div><br/><div id="39914969" class="c"><input type="checkbox" id="c-39914969" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914917">parent</a><span>|</span><a href="#39924757">next</a><span>|</span><label class="collapse" for="c-39914969">[-]</label><label class="expand" for="c-39914969">[1 more]</label></div><br/><div class="children"><div class="content">I always think of this now-old comic: <a href="https:&#x2F;&#x2F;www.osnews.com&#x2F;story&#x2F;19266&#x2F;wtfsm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.osnews.com&#x2F;story&#x2F;19266&#x2F;wtfsm&#x2F;</a></div><br/></div></div></div></div><div id="39924757" class="c"><input type="checkbox" id="c-39924757" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914690">parent</a><span>|</span><a href="#39914917">prev</a><span>|</span><a href="#39912122">next</a><span>|</span><label class="collapse" for="c-39924757">[-]</label><label class="expand" for="c-39924757">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Python is my day job. If anyone on my team put something up that was as unreadable as a typical bash script, without really good justification, I’d immediately hit “request changes”.<p>This isn’t just because I’m more familiar with Python. I don’t even think it’s the main reason. It’s just that Python is more likely to be able to be read in a ‘natural language’ sort of way. It’s better at doing what it says on the tin. It’s more able to be read via pure intuition by a programmer that’s not familiar with Python specifically.<p>In bash land? “What the hell is [[?”<p>And yes, I could come up with 20 ways off the top of my head that Python is a far-from-perfect language.<p>And I’m not even saying that Python is the right tool for the job here. Maybe we’re better off with one of the many more modern attempts at a shell language. The main thing is that we should 
 acknowledge that bash has overstayed its welcome in many of the areas in which it’s still used.</div><br/></div></div></div></div><div id="39912122" class="c"><input type="checkbox" id="c-39912122" checked=""/><div class="controls bullet"><span class="by">giantrobot</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911299">parent</a><span>|</span><a href="#39914690">prev</a><span>|</span><a href="#39924674">next</a><span>|</span><label class="collapse" for="c-39912122">[-]</label><label class="expand" for="c-39912122">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ll write build scripts in highly obfuscated Perl. There, now no one is happy.</div><br/></div></div><div id="39924674" class="c"><input type="checkbox" id="c-39924674" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911299">parent</a><span>|</span><a href="#39912122">prev</a><span>|</span><a href="#39911304">next</a><span>|</span><label class="collapse" for="c-39924674">[-]</label><label class="expand" for="c-39924674">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, nah.
 I’m all for “every tool has its place”, “religious wars over languages are silly”, etc. Don’t get me wrong.
But anyone that claims that all but the 1% most simple bash scripts are “straightforward” and “readable” is, to be blunt, showing their age.<p>The reality is that we as a society have made meaningful progress as far as designing readable languages goes. And we LITERALLY have many orders of magnitude more resources to make that happen. That’s something to feel good about. It’s unreadable to continue to mischaracterise some sysadmin greybeard’s’ familiarity with bash as an indication that it is in any way intuitive or readable.<p>Like, sheesh, now we all sound like C developers trying to justify an absurdly footgun-laden standard library just because we happen to know the right secret incantations, or <i>think</i> that we know them, anyway. But now this is definitely becoming a religious war…</div><br/></div></div></div></div><div id="39911304" class="c"><input type="checkbox" id="c-39911304" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39911299">prev</a><span>|</span><a href="#39916699">next</a><span>|</span><label class="collapse" for="c-39911304">[-]</label><label class="expand" for="c-39911304">[12 more]</label></div><br/><div class="children"><div class="content">It&#x27;s rather easy to monkeypatch Python into doing spooky things. For something like this you really want a language that can&#x27;t be monkeypatched, like I think Starlark.</div><br/><div id="39911327" class="c"><input type="checkbox" id="c-39911327" checked=""/><div class="controls bullet"><span class="by">echoangle</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911304">parent</a><span>|</span><a href="#39916699">next</a><span>|</span><label class="collapse" for="c-39911327">[-]</label><label class="expand" for="c-39911327">[11 more]</label></div><br/><div class="children"><div class="content">Where are you going to hide your monkey patching though? As long as your code is public, stuff like this is always going to stand out, because no one writes weird magic one liners in python.</div><br/><div id="39911659" class="c"><input type="checkbox" id="c-39911659" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911327">parent</a><span>|</span><a href="#39911374">next</a><span>|</span><label class="collapse" for="c-39911659">[-]</label><label class="expand" for="c-39911659">[3 more]</label></div><br/><div class="children"><div class="content">The way python&#x27;s run time literally executes code when you import a module makes it seem pretty easy to taint things from afar. You only need to control a single import anywhere in the dependency hierarchy and you can reach over and override any code somewhere else.</div><br/><div id="39913363" class="c"><input type="checkbox" id="c-39913363" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911659">parent</a><span>|</span><a href="#39911666">next</a><span>|</span><label class="collapse" for="c-39913363">[-]</label><label class="expand" for="c-39913363">[1 more]</label></div><br/><div class="children"><div class="content">There are lints that will warn you, if your imported module does anything apart from define functions and classes.<p>(Though not sure how fool-proof these are.)</div><br/></div></div><div id="39911666" class="c"><input type="checkbox" id="c-39911666" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911659">parent</a><span>|</span><a href="#39913363">prev</a><span>|</span><a href="#39911374">next</a><span>|</span><label class="collapse" for="c-39911666">[-]</label><label class="expand" for="c-39911666">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah, that&#x27;s a fantastic point.</div><br/></div></div></div></div><div id="39911374" class="c"><input type="checkbox" id="c-39911374" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911327">parent</a><span>|</span><a href="#39911659">prev</a><span>|</span><a href="#39911530">next</a><span>|</span><label class="collapse" for="c-39911374">[-]</label><label class="expand" for="c-39911374">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a security-oriented professional, but to me a place I could hide this logic is by secretly evaling the contents of some file (like the &quot;corrupt archive&quot; used in xz) somewhere in the build process, hiding it behind a decorator or similar.</div><br/><div id="39911437" class="c"><input type="checkbox" id="c-39911437" checked=""/><div class="controls bullet"><span class="by">echoangle</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911374">parent</a><span>|</span><a href="#39911481">next</a><span>|</span><label class="collapse" for="c-39911437">[-]</label><label class="expand" for="c-39911437">[3 more]</label></div><br/><div class="children"><div class="content">I’m not a security professional either, but that doesn’t sound very plausible to me. If you assume a maintainer who checks every commit added to the codebase, he’s hopefully blocking you the second he sees an eval call in your build script. And even a code audit should find weird stuff like that, if the code is pythonic and simple to read. And if it’s not, it should not be trusted and should be treated as malicious.</div><br/><div id="39911585" class="c"><input type="checkbox" id="c-39911585" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911437">parent</a><span>|</span><a href="#39911481">next</a><span>|</span><label class="collapse" for="c-39911585">[-]</label><label class="expand" for="c-39911585">[2 more]</label></div><br/><div class="children"><div class="content">Well, the threat model here is that a maintainer themselves is the saboteur.</div><br/><div id="39913619" class="c"><input type="checkbox" id="c-39913619" checked=""/><div class="controls bullet"><span class="by">cjbprime</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911585">parent</a><span>|</span><a href="#39911481">next</a><span>|</span><label class="collapse" for="c-39913619">[-]</label><label class="expand" for="c-39913619">[1 more]</label></div><br/><div class="children"><div class="content">That was true for this project, which was almost orphaned to begin with.  We&#x27;ll run out of nearly-unmaintained critical infrastructure projects sometime.  Larger projects with healthier maintenance situations are also at risk, and it&#x27;s worth reasoning about how a group of honest developers could discover the actions of one malicious developer (with perhaps a malicious reviewer involved too).</div><br/></div></div></div></div></div></div><div id="39911481" class="c"><input type="checkbox" id="c-39911481" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911374">parent</a><span>|</span><a href="#39911437">prev</a><span>|</span><a href="#39911530">next</a><span>|</span><label class="collapse" for="c-39911481">[-]</label><label class="expand" for="c-39911481">[1 more]</label></div><br/><div class="children"><div class="content">Would stick out like a sore thumb</div><br/></div></div></div></div><div id="39911530" class="c"><input type="checkbox" id="c-39911530" checked=""/><div class="controls bullet"><span class="by">cyanydeez</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911327">parent</a><span>|</span><a href="#39911374">prev</a><span>|</span><a href="#39921309">next</a><span>|</span><label class="collapse" for="c-39911530">[-]</label><label class="expand" for="c-39911530">[1 more]</label></div><br/><div class="children"><div class="content">This code was essentially monkey patched from a test script. Python automatically runs any code in a imported module, so not hard to see a chain of module imports that progressively modifies and deploys a similar structure.</div><br/></div></div><div id="39921309" class="c"><input type="checkbox" id="c-39921309" checked=""/><div class="controls bullet"><span class="by">DrFalkyn</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911327">parent</a><span>|</span><a href="#39911530">prev</a><span>|</span><a href="#39916699">next</a><span>|</span><label class="collapse" for="c-39921309">[-]</label><label class="expand" for="c-39921309">[1 more]</label></div><br/><div class="children"><div class="content">eval() is a big security hole</div><br/></div></div></div></div></div></div><div id="39916699" class="c"><input type="checkbox" id="c-39916699" checked=""/><div class="controls bullet"><span class="by">unhammer</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39911304">prev</a><span>|</span><a href="#39913671">next</a><span>|</span><label class="collapse" for="c-39916699">[-]</label><label class="expand" for="c-39916699">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the beginning of Unix, m4 was created. This has made many people very angry and has been widely regarded as a bad move.<p>autoconf creates a shell script by preprocessing with m4. So you need to know not just the intricacies of shell scripting, but also of m4, with its arcane rules for escaping: <a href="https:&#x2F;&#x2F;mbreen.com&#x2F;m4.html#quotes" rel="nofollow">https:&#x2F;&#x2F;mbreen.com&#x2F;m4.html#quotes</a><p>If autoconf used m4 to generate python scripts, they would also look like <a href="https:&#x2F;&#x2F;pyobfusc.com&#x2F;#winners" rel="nofollow">https:&#x2F;&#x2F;pyobfusc.com&#x2F;#winners</a></div><br/></div></div><div id="39913671" class="c"><input type="checkbox" id="c-39913671" checked=""/><div class="controls bullet"><span class="by">heavyset_go</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39916699">prev</a><span>|</span><a href="#39919146">next</a><span>|</span><label class="collapse" for="c-39913671">[-]</label><label class="expand" for="c-39913671">[1 more]</label></div><br/><div class="children"><div class="content">The things that Bash is good at can wind up obfuscated in Python code due to the verbosity and complexity that it translates to in Python.<p>Bash is great at dealing with files, text, running other programs, job handling, parallelism and IPC.<p>Those things in combination can end up being more complex in Python, which creates more opportunities for obfuscation.</div><br/></div></div><div id="39919146" class="c"><input type="checkbox" id="c-39919146" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39913671">prev</a><span>|</span><a href="#39915298">next</a><span>|</span><label class="collapse" for="c-39919146">[-]</label><label class="expand" for="c-39919146">[1 more]</label></div><br/><div class="children"><div class="content">Just wait for AI to start pumping spaghetti code everywhere.<p>That&#x27;s AI phase one<p>Hey, I phase 2 is even better disguised exploit code hiding behind acres of seemingly plausible AI generated code</div><br/></div></div><div id="39915298" class="c"><input type="checkbox" id="c-39915298" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39919146">prev</a><span>|</span><a href="#39914923">next</a><span>|</span><label class="collapse" for="c-39915298">[-]</label><label class="expand" for="c-39915298">[1 more]</label></div><br/><div class="children"><div class="content">Yet it is python code which has the highest amount of security vulnerabilities found in public repos. And the most often times that pre-compiled code is commited as well.</div><br/></div></div><div id="39914923" class="c"><input type="checkbox" id="c-39914923" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39915298">prev</a><span>|</span><a href="#39911628">next</a><span>|</span><label class="collapse" for="c-39914923">[-]</label><label class="expand" for="c-39914923">[1 more]</label></div><br/><div class="children"><div class="content">Cliffy is also pretty good: <a href="https:&#x2F;&#x2F;cliffy.io" rel="nofollow">https:&#x2F;&#x2F;cliffy.io</a><p>And type safe.</div><br/></div></div><div id="39911628" class="c"><input type="checkbox" id="c-39911628" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911234">parent</a><span>|</span><a href="#39914923">prev</a><span>|</span><a href="#39914254">next</a><span>|</span><label class="collapse" for="c-39911628">[-]</label><label class="expand" for="c-39911628">[2 more]</label></div><br/><div class="children"><div class="content">Any language can become a turing tarpit if you try hard enough.</div><br/><div id="39913368" class="c"><input type="checkbox" id="c-39913368" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39911628">parent</a><span>|</span><a href="#39914254">next</a><span>|</span><label class="collapse" for="c-39913368">[-]</label><label class="expand" for="c-39913368">[1 more]</label></div><br/><div class="children"><div class="content">Some languages make you try harder, some less so.<p>And not all languages are Turing complete in the first place.  Not even all useful languages.</div><br/></div></div></div></div></div></div><div id="39914254" class="c"><input type="checkbox" id="c-39914254" checked=""/><div class="controls bullet"><span class="by">livrem</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39911234">prev</a><span>|</span><a href="#39916088">next</a><span>|</span><label class="collapse" for="c-39914254">[-]</label><label class="expand" for="c-39914254">[2 more]</label></div><br/><div class="children"><div class="content">I see what everyone is saying about autotools, and I never envied those that maintained the config scripts, but as an end-user I miss the days when installing almost any software was as simple as .&#x2F;configure &amp;&amp; make &amp;&amp; make install.</div><br/><div id="39916104" class="c"><input type="checkbox" id="c-39916104" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914254">parent</a><span>|</span><a href="#39916088">next</a><span>|</span><label class="collapse" for="c-39916104">[-]</label><label class="expand" for="c-39916104">[1 more]</label></div><br/><div class="children"><div class="content">Running that command is simple, sure. The development workflows when that doesn&#x27;t work is full stop horrible.<p>Also the basic workflows for the alternative build systems have maybe ten more characters to type. It&#x27;s not bad.</div><br/></div></div></div></div><div id="39916088" class="c"><input type="checkbox" id="c-39916088" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39914254">prev</a><span>|</span><a href="#39912017">next</a><span>|</span><label class="collapse" for="c-39916088">[-]</label><label class="expand" for="c-39916088">[1 more]</label></div><br/><div class="children"><div class="content">Autotools need to go away, but most of the underlying use cases that cause build system complexity comes down to dependency management and detection. The utter lack of best practices for those workflows is the root cause of complexity. There is no way to have a mybuild.toml build config on the face of those challenges.</div><br/></div></div><div id="39912017" class="c"><input type="checkbox" id="c-39912017" checked=""/><div class="controls bullet"><span class="by">dpkirchner</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39916088">prev</a><span>|</span><a href="#39911260">next</a><span>|</span><label class="collapse" for="c-39912017">[-]</label><label class="expand" for="c-39912017">[2 more]</label></div><br/><div class="children"><div class="content">Agreed, and I think this leads to the question: how much risk do we face because we want to support such a wide range of platforms that a complex system is required?<p>And how did we get to the point that a complex system is required to build a compression library -- something that doesn&#x27;t really have to do much more than math and memory allocation?</div><br/><div id="39912377" class="c"><input type="checkbox" id="c-39912377" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912017">parent</a><span>|</span><a href="#39911260">next</a><span>|</span><label class="collapse" for="c-39912377">[-]</label><label class="expand" for="c-39912377">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And how did we get to the point that a complex system is required to build a compression library -- something that doesn&#x27;t really have to do much more than math and memory allocation?<p>The project in question <i>contained</i> a compression library, but was not limited to it; it also contained a set of command line tools (the &quot;xz&quot; command and several others).<p>And a modern compression library needs more than just &quot;math and memory allocation&quot;; it also needs <i>threads</i> (to make use of all the available cores), which is historically not portable. You need to detect whether threads are available, and which threading library should be used (pthreads is not always the available option). And not only that, a modern compression library often needs hand-optimized assembly code, with several variants depending on the exact CPU type, the correct one possibly being known only at runtime (and it was exactly in the code to select the correct variant for the current CPU that this backdoor was hidden).<p>And that&#x27;s before considering that this is a <i>library</i>. Building a dynamic library is something which has a lot of variation between operating systems. You have Windows with its DLLs, MacOS with its frameworks, modern Linux with its ELF stuff, and historically it was even worse (like old a.out-based Linux with its manually pre-allocated base address for every dynamic library in the whole system).<p>So yeah, if you restrict yourself to modern Linux and perhaps a couple of the BSDs, and require the correct CPU type to be selected at compilation time, you could get away with just a couple of pages of simple Makefile declarations. But once you start porting to a more diverse set of systems, you&#x27;ll see it get more and more complicated. Add cross-compilation to the mix (a non-trivial amount of autotools complexity is there to make cross-compilation work well) and it gets even more complicated.</div><br/></div></div></div></div><div id="39911260" class="c"><input type="checkbox" id="c-39911260" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39912017">prev</a><span>|</span><a href="#39914620">next</a><span>|</span><label class="collapse" for="c-39911260">[-]</label><label class="expand" for="c-39911260">[1 more]</label></div><br/><div class="children"><div class="content">Right there with you. It&#x27;s really tempting to blame this entire thing existing on m4 but that&#x27;s the trauma talking.</div><br/></div></div><div id="39914620" class="c"><input type="checkbox" id="c-39914620" checked=""/><div class="controls bullet"><span class="by">frankohn</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39911260">prev</a><span>|</span><a href="#39913147">next</a><span>|</span><label class="collapse" for="c-39914620">[-]</label><label class="expand" for="c-39914620">[5 more]</label></div><br/><div class="children"><div class="content">I do not agree with your generalisation, the Meson build system is well thought, it has a clear declarative syntax that let you just express what you want in a direct way.<p>The designer of Meson explicitly avoided making the language turing complete so for example you cannot define functions. In my experience this was an excellent decision to limit people tendency to write complex stuff and put the pressure on the Meson developer to implement themselves all the useful functionalities.<p>In my experience the Meson configuration are as simple as they can be and accommodate only a modicum of complexity to describe OS specific options or advanced compiler option one may need.<p>Please note that some projects&#x27; Meson file have been made complex because of the goal to match whatever the configure script was doing. I had in mind the crazy habits of autotools to check if the system has any possibly used function because some system may not have it.</div><br/><div id="39916124" class="c"><input type="checkbox" id="c-39916124" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914620">parent</a><span>|</span><a href="#39917832">next</a><span>|</span><label class="collapse" for="c-39916124">[-]</label><label class="expand" for="c-39916124">[3 more]</label></div><br/><div class="children"><div class="content">Meson is way better than autotools, but if you&#x27;re too level to depend on python, you&#x27;re probably needing to customize your build scripts in the ways you mention. I don&#x27;t see meson being a silver bullet there.<p>Also, meson&#x27;s build dependencies (muon, python) are a lot for some of these projects.</div><br/><div id="39924287" class="c"><input type="checkbox" id="c-39924287" checked=""/><div class="controls bullet"><span class="by">pknopf</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39916124">parent</a><span>|</span><a href="#39917832">next</a><span>|</span><label class="collapse" for="c-39924287">[-]</label><label class="expand" for="c-39924287">[2 more]</label></div><br/><div class="children"><div class="content">If a projects build system can&#x27;t depend on python, that let&#x27;s leave them in the dust, ffs..</div><br/><div id="39924477" class="c"><input type="checkbox" id="c-39924477" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39924287">parent</a><span>|</span><a href="#39917832">next</a><span>|</span><label class="collapse" for="c-39924477">[-]</label><label class="expand" for="c-39924477">[1 more]</label></div><br/><div class="children"><div class="content">What if the project is python or a dependency of python?</div><br/></div></div></div></div></div></div><div id="39917832" class="c"><input type="checkbox" id="c-39917832" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39914620">parent</a><span>|</span><a href="#39916124">prev</a><span>|</span><a href="#39913147">next</a><span>|</span><label class="collapse" for="c-39917832">[-]</label><label class="expand" for="c-39917832">[1 more]</label></div><br/><div class="children"><div class="content">This just results in 500x worse build.sh on top of meson&#x2F;ninja&#x2F;whatever.</div><br/></div></div></div></div><div id="39913147" class="c"><input type="checkbox" id="c-39913147" checked=""/><div class="controls bullet"><span class="by">kjellsbells</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39914620">prev</a><span>|</span><a href="#39911363">next</a><span>|</span><label class="collapse" for="c-39913147">[-]</label><label class="expand" for="c-39913147">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad to see I&#x27;m not a minority of one here. Looking at autoconf and friends I&#x27;m reminded of the dreck that used to fill OpenSSL&#x27;s code simply because they were trying to account for every eventuality. Autotools feels like the same thing. You end up with a ton of hard to read code (autogenerated bash, not exactly poetry) and that feels very inimical to safety.</div><br/></div></div><div id="39911363" class="c"><input type="checkbox" id="c-39911363" checked=""/><div class="controls bullet"><span class="by">shp0ngle</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39913147">prev</a><span>|</span><a href="#39911298">next</a><span>|</span><label class="collapse" for="c-39911363">[-]</label><label class="expand" for="c-39911363">[1 more]</label></div><br/><div class="children"><div class="content">Every time someone explains to me autotools, the individual pieces sort of make sense, yet the result is always this inscrutable unreadable mess.<p>I don&#x27;t know why.</div><br/></div></div><div id="39911298" class="c"><input type="checkbox" id="c-39911298" checked=""/><div class="controls bullet"><span class="by">rgmerk</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39911363">prev</a><span>|</span><a href="#39912591">next</a><span>|</span><label class="collapse" for="c-39911298">[-]</label><label class="expand" for="c-39911298">[1 more]</label></div><br/><div class="children"><div class="content">Yeah.<p>I haven’t used it for some time but autoconf always seemed like a horrible hack that was impossible to debug if it didn’t work properly.<p>That was bad enough back in the days where one was mostly concerned with accidents, but in more modern times things that are impossible to debug are such tempting targets for mischief.</div><br/></div></div><div id="39912591" class="c"><input type="checkbox" id="c-39912591" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39911298">prev</a><span>|</span><a href="#39912831">next</a><span>|</span><label class="collapse" for="c-39912591">[-]</label><label class="expand" for="c-39912591">[3 more]</label></div><br/><div class="children"><div class="content">The issue was that built artifacts weren’t immutable during the test phase and&#x2F;or the test phase wasn’t sandboxed from the built artifacts.<p>The last build system I worked on separated build and test as separate stages. That meant you got a lot of useless artifacts pushed to a development namespace on the distribution server, but it also meant later stages only needed read access to that server.</div><br/><div id="39912890" class="c"><input type="checkbox" id="c-39912890" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912591">parent</a><span>|</span><a href="#39912831">next</a><span>|</span><label class="collapse" for="c-39912890">[-]</label><label class="expand" for="c-39912890">[2 more]</label></div><br/><div class="children"><div class="content">The malicious .o is extracted from data in binary test files, but the backdoor is inserted entirely in the build phase. Running any test phase is not necessary.</div><br/><div id="39917917" class="c"><input type="checkbox" id="c-39917917" checked=""/><div class="controls bullet"><span class="by">rafaelmn</span><span>|</span><a href="#39911156">root</a><span>|</span><a href="#39912890">parent</a><span>|</span><a href="#39912831">next</a><span>|</span><label class="collapse" for="c-39917917">[-]</label><label class="expand" for="c-39917917">[1 more]</label></div><br/><div class="children"><div class="content">So if you ran build without test files it would fail. I get that this is hindsight thinking - but maybe removing all non essential files when packaging&#x2F;building libraries reduces the surface area.</div><br/></div></div></div></div></div></div><div id="39912831" class="c"><input type="checkbox" id="c-39912831" checked=""/><div class="controls bullet"><span class="by">salawat</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39912591">prev</a><span>|</span><a href="#39911665">next</a><span>|</span><label class="collapse" for="c-39912831">[-]</label><label class="expand" for="c-39912831">[1 more]</label></div><br/><div class="children"><div class="content">Let me reword that for you:<p>&gt;No one has any business saying they know what something does until they&#x27;ve actually read it.<p>Beneath the placid surface of abstraction is the den of the devil.</div><br/></div></div><div id="39911665" class="c"><input type="checkbox" id="c-39911665" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39912831">prev</a><span>|</span><a href="#39911503">next</a><span>|</span><label class="collapse" for="c-39911665">[-]</label><label class="expand" for="c-39911665">[1 more]</label></div><br/><div class="children"><div class="content">The devil is in the detail and nothing obscures details like complexity.<p>Same reason why I don&#x27;t like TypeScript in its current form. It&#x27;s not worth the extra complexity it brings.</div><br/></div></div><div id="39911503" class="c"><input type="checkbox" id="c-39911503" checked=""/><div class="controls bullet"><span class="by">cyanydeez</span><span>|</span><a href="#39911156">parent</a><span>|</span><a href="#39911665">prev</a><span>|</span><a href="#39918632">next</a><span>|</span><label class="collapse" for="c-39911503">[-]</label><label class="expand" for="c-39911503">[1 more]</label></div><br/><div class="children"><div class="content">Just the fact that you have multiple platforms suggests few people will fully understand the entire complex.</div><br/></div></div></div></div><div id="39918632" class="c"><input type="checkbox" id="c-39918632" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39911156">prev</a><span>|</span><a href="#39907835">next</a><span>|</span><label class="collapse" for="c-39918632">[-]</label><label class="expand" for="c-39918632">[6 more]</label></div><br/><div class="children"><div class="content">As a naive bystander, the thing that stands out most to me:<p>&gt; Many of the files have been created by hand with a hex editor, thus there is no better &quot;source code&quot; than the files themselves.” This is a fact of life for parsing libraries like liblzma. The attacker looked like they were just adding a few new test files.<p>Yes, these files are scary, but I can see the reason. But at least can we keep them away from the build?<p>&gt; Usually, the configure script and its support libraries are only added to the tarball distributions, not the source repository. The xz distribution works this way too.<p>Obligatory auto tools wtf aside, why on earth should the tarballs contain the test files at all? I mean, a malicious test could infect a developer machine, but if the tars are for building final artifacts <i>for everyone else</i>, then shouldn’t the policy be to only include what’s necessary? <i>Especially</i> if the test files are unauditable blobs.</div><br/><div id="39927912" class="c"><input type="checkbox" id="c-39927912" checked=""/><div class="controls bullet"><span class="by">nhellman</span><span>|</span><a href="#39918632">parent</a><span>|</span><a href="#39919070">next</a><span>|</span><label class="collapse" for="c-39927912">[-]</label><label class="expand" for="c-39927912">[1 more]</label></div><br/><div class="children"><div class="content">Besides for verifying that the compiled program works on the target, tests are also required to compile with PGO because you need to have a runtime example to optimize for.</div><br/></div></div><div id="39919070" class="c"><input type="checkbox" id="c-39919070" checked=""/><div class="controls bullet"><span class="by">finaard</span><span>|</span><a href="#39918632">parent</a><span>|</span><a href="#39927912">prev</a><span>|</span><a href="#39918963">next</a><span>|</span><label class="collapse" for="c-39919070">[-]</label><label class="expand" for="c-39919070">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty common to run tests on CI after building to verify your particular setup doesn&#x27;t break stuff.<p>Last time we were doing that we were preferring git upstream, though, and generated autocrap as needed - I never liked the idea of release tarballs containing stuff not in git.</div><br/><div id="39920669" class="c"><input type="checkbox" id="c-39920669" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39918632">root</a><span>|</span><a href="#39919070">parent</a><span>|</span><a href="#39918963">next</a><span>|</span><label class="collapse" for="c-39920669">[-]</label><label class="expand" for="c-39920669">[2 more]</label></div><br/><div class="children"><div class="content">This strengthens the argument I’m making, no? You bring in the source repo when doing development and debugging. In either case - tarball or not - it doesn’t seem that difficult to nuke the test dir before building a release for distribution. Again, only really necessary if you have opaque blobs where fishy things can hide.</div><br/><div id="39920834" class="c"><input type="checkbox" id="c-39920834" checked=""/><div class="controls bullet"><span class="by">lathiat</span><span>|</span><a href="#39918632">root</a><span>|</span><a href="#39920669">parent</a><span>|</span><a href="#39918963">next</a><span>|</span><label class="collapse" for="c-39920834">[-]</label><label class="expand" for="c-39920834">[1 more]</label></div><br/><div class="children"><div class="content">The distributions often run the same tests after it’s built to make sure it’s working correctly as built in the distribution environment. This can and does find real problems.</div><br/></div></div></div></div></div></div><div id="39918963" class="c"><input type="checkbox" id="c-39918963" checked=""/><div class="controls bullet"><span class="by">wiml</span><span>|</span><a href="#39918632">parent</a><span>|</span><a href="#39919070">prev</a><span>|</span><a href="#39907835">next</a><span>|</span><label class="collapse" for="c-39918963">[-]</label><label class="expand" for="c-39918963">[1 more]</label></div><br/><div class="children"><div class="content">Because, despite containing some amount of generated autoconf code, they are still source tarballs. You want to be able to run the tests after compiling the code on the destination machine.</div><br/></div></div></div></div><div id="39907835" class="c"><input type="checkbox" id="c-39907835" checked=""/><div class="controls bullet"><span class="by">mzs</span><span>|</span><a href="#39918632">prev</a><span>|</span><a href="#39927267">next</a><span>|</span><label class="collapse" for="c-39907835">[-]</label><label class="expand" for="c-39907835">[20 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen Thomas Roccia&#x27;s infographic mentioned here yet: <a href="https:&#x2F;&#x2F;twitter.com&#x2F;fr0gger_&#x2F;status&#x2F;1774342248437813525" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;fr0gger_&#x2F;status&#x2F;1774342248437813525</a></div><br/><div id="39911249" class="c"><input type="checkbox" id="c-39911249" checked=""/><div class="controls bullet"><span class="by">ihsoy</span><span>|</span><a href="#39907835">parent</a><span>|</span><a href="#39911496">next</a><span>|</span><label class="collapse" for="c-39911249">[-]</label><label class="expand" for="c-39911249">[2 more]</label></div><br/><div class="children"><div class="content">That seems to be largely grasped at straws and connecting dots without reason.<p>For example oss-fuzz was building xz by cloning the github repo directly. There was never a chance for oss-fuzz to discover the backdoor, because only the tarball had it, not the repo itself. So that oss-fuzz PR might genuinely just be a genuine thing unrelated to the backdoor.</div><br/><div id="39911711" class="c"><input type="checkbox" id="c-39911711" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39911249">parent</a><span>|</span><a href="#39911496">next</a><span>|</span><label class="collapse" for="c-39911711">[-]</label><label class="expand" for="c-39911711">[1 more]</label></div><br/><div class="children"><div class="content">The ifunc part looked more legitimate, it was used to switch between optimized implementations of CRC. So that part was in the git repo. <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;oss-fuzz&#x2F;pull&#x2F;10667">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;oss-fuzz&#x2F;pull&#x2F;10667</a></div><br/></div></div></div></div><div id="39911496" class="c"><input type="checkbox" id="c-39911496" checked=""/><div class="controls bullet"><span class="by">_trampeltier</span><span>|</span><a href="#39907835">parent</a><span>|</span><a href="#39911249">prev</a><span>|</span><a href="#39910922">next</a><span>|</span><label class="collapse" for="c-39911496">[-]</label><label class="expand" for="c-39911496">[14 more]</label></div><br/><div class="children"><div class="content">Jia Tan asked distros to update quickly just before it became public. How possible is it, there is another account &#x2F; person who learned earlyer from people around Andreas Freund, the backdoor would become public. How possible is it, there is still another insider around?</div><br/><div id="39912706" class="c"><input type="checkbox" id="c-39912706" checked=""/><div class="controls bullet"><span class="by">strunz</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39911496">parent</a><span>|</span><a href="#39911687">next</a><span>|</span><label class="collapse" for="c-39912706">[-]</label><label class="expand" for="c-39912706">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s probably because of this (as mentioned in the timeline):<p>&gt;2024-02-29: On GitHub, @teknoraver <a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31550">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31550</a> to stop linking liblzma into libsystemd. It appears that this would have defeated the attack. <a href="https:&#x2F;&#x2F;doublepulsar.com&#x2F;inside-the-failed-attempt-to-backdoor-ssh-globally-that-got-caught-by-chance-bbfe628fafdd" rel="nofollow">https:&#x2F;&#x2F;doublepulsar.com&#x2F;inside-the-failed-attempt-to-backdo...</a> that knowing this was on the way may have accelerated the attacker’s schedule. It is unclear whether any earlier discussions exist that would have tipped them off.</div><br/><div id="39912809" class="c"><input type="checkbox" id="c-39912809" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39912706">parent</a><span>|</span><a href="#39911687">next</a><span>|</span><label class="collapse" for="c-39912809">[-]</label><label class="expand" for="c-39912809">[6 more]</label></div><br/><div class="children"><div class="content">rwmj did mention about an unintentional embargo break, so I wonder whether this is GitHub issue is actually it.</div><br/><div id="39915873" class="c"><input type="checkbox" id="c-39915873" checked=""/><div class="controls bullet"><span class="by">teknoraver</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39912809">parent</a><span>|</span><a href="#39911687">next</a><span>|</span><label class="collapse" for="c-39915873">[-]</label><label class="expand" for="c-39915873">[5 more]</label></div><br/><div class="children"><div class="content">Hi,<p>I&#x27;m the author of such PR. My purpose was to trim down the size of the initram files by removing unneeded dependencies.<p>I couldn&#x27;t imagine that liblzma had a backdoor.</div><br/><div id="39915910" class="c"><input type="checkbox" id="c-39915910" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39915873">parent</a><span>|</span><a href="#39911687">next</a><span>|</span><label class="collapse" for="c-39915910">[-]</label><label class="expand" for="c-39915910">[4 more]</label></div><br/><div class="children"><div class="content">Hi! Was there any discussion on any mailing lists ahead of time, or was your PR the first public mention of that idea? Thanks.</div><br/><div id="39916125" class="c"><input type="checkbox" id="c-39916125" checked=""/><div class="controls bullet"><span class="by">teknoraver</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39915910">parent</a><span>|</span><a href="#39911687">next</a><span>|</span><label class="collapse" for="c-39916125">[-]</label><label class="expand" for="c-39916125">[3 more]</label></div><br/><div class="children"><div class="content">Yes, there was an effort to turn all the dependencies into on demand loads, where possible.
It started in 2020 with libpcre2:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;16260">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;16260</a><p>But many others followed, like libselinux:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;19997">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;19997</a><p>libqrencode:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;16145">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;16145</a><p>p11kit:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;25771">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;25771</a><p>tpm2-util:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;28333">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;28333</a><p>libiptc:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;29836">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;29836</a><p>libkmod:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131</a><p>Exactly during the development of the libkmod PR, someone noted that libxz could be lazily loaded too:
<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131#issuecomment-1963334057">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131#issuecomment-1...</a><p>And so I proposed myself to to the job, nothing less, nothing more.<p>If you look at the code of the other PRs, you see that they are very very similar, there are also macros to easy this task, like DLSYM_FUNCTION()</div><br/><div id="39923506" class="c"><input type="checkbox" id="c-39923506" checked=""/><div class="controls bullet"><span class="by">teknoraver</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39916125">parent</a><span>|</span><a href="#39911687">next</a><span>|</span><label class="collapse" for="c-39923506">[-]</label><label class="expand" for="c-39923506">[2 more]</label></div><br/><div class="children"><div class="content">Hi @rsc, I just saw your update on the timeline.<p>To be more precise, the first public comment asking to dlopenify lzma was dated 30 Jan by Daan: <a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131#issuecomment-1917693005">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131#issuecomment-1...</a><p>The day after, it was reiterated by Lennart: <a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131#issuecomment-1918667390">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;pull&#x2F;31131#issuecomment-1...</a><p>But if you look in the systemd repo there is a TODO file with a section of libraries which needs to be lazy loaded.
liblzma was added in this list in June 2020 (<a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;commit&#x2F;cdfd853744ee9348691e9bbe4d2775e5415ba119">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;commit&#x2F;cdfd853744ee934869...</a>) by Lennart, and removed by me just after that my PR was merged.</div><br/><div id="39923633" class="c"><input type="checkbox" id="c-39923633" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39923506">parent</a><span>|</span><a href="#39911687">next</a><span>|</span><label class="collapse" for="c-39923633">[-]</label><label class="expand" for="c-39923633">[1 more]</label></div><br/><div class="children"><div class="content">Updated. Thanks!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39911687" class="c"><input type="checkbox" id="c-39911687" checked=""/><div class="controls bullet"><span class="by">ptx</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39911496">parent</a><span>|</span><a href="#39912706">prev</a><span>|</span><a href="#39911642">next</a><span>|</span><label class="collapse" for="c-39911687">[-]</label><label class="expand" for="c-39911687">[1 more]</label></div><br/><div class="children"><div class="content">There were also changes to systemd happening around that time which would have prevented the backdoor from working. See the timeline article by the same author linked in this one.</div><br/></div></div><div id="39911642" class="c"><input type="checkbox" id="c-39911642" checked=""/><div class="controls bullet"><span class="by">OneLeggedCat</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39911496">parent</a><span>|</span><a href="#39911687">prev</a><span>|</span><a href="#39910922">next</a><span>|</span><label class="collapse" for="c-39911642">[-]</label><label class="expand" for="c-39911642">[5 more]</label></div><br/><div class="children"><div class="content">Right.  Way too much coincidence.  Jia Tan found out that it was about to become public and threw a Hail Mary.  How did he find out?</div><br/><div id="39915934" class="c"><input type="checkbox" id="c-39915934" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39911642">parent</a><span>|</span><a href="#39911705">next</a><span>|</span><label class="collapse" for="c-39915934">[-]</label><label class="expand" for="c-39915934">[3 more]</label></div><br/><div class="children"><div class="content">I think the RedHat Valgrind report on 2024-03-04 made the Jia Tan team panic, since the one public rwmj stack trace pointed the finger directly at the backdoor. All it would take is someone looking closely at that failure to expose the whole operation. They fixed it on 2024-03-09, but then two weeks later distros still had not updated to the new version, and every day is another day that someone might hit the Valgrind failure and dig. I think that&#x27;s why the sockpuppets came back on 2024-03-25 begging Debian to update. And then on the Debian thread there was pushback because they weren&#x27;t the maintainer (except probably they were), so once Debian was updated, Jia Tan had to be the account that asked Ubuntu to update.</div><br/><div id="39918238" class="c"><input type="checkbox" id="c-39918238" checked=""/><div class="controls bullet"><span class="by">peteradio</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39915934">parent</a><span>|</span><a href="#39911705">next</a><span>|</span><label class="collapse" for="c-39918238">[-]</label><label class="expand" for="c-39918238">[2 more]</label></div><br/><div class="children"><div class="content">That seems like a breach that they went forward with the update based on some random persons request.  Oh you&#x27;re getting pushy?  I guess we better listen to this guy.</div><br/><div id="39919148" class="c"><input type="checkbox" id="c-39919148" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39918238">parent</a><span>|</span><a href="#39911705">next</a><span>|</span><label class="collapse" for="c-39919148">[-]</label><label class="expand" for="c-39919148">[1 more]</label></div><br/><div class="children"><div class="content">The update was pulling from trusted upstream archives. I&#x27;m sure Debian verified that.</div><br/></div></div></div></div></div></div><div id="39911705" class="c"><input type="checkbox" id="c-39911705" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#39907835">root</a><span>|</span><a href="#39911642">parent</a><span>|</span><a href="#39915934">prev</a><span>|</span><a href="#39910922">next</a><span>|</span><label class="collapse" for="c-39911705">[-]</label><label class="expand" for="c-39911705">[1 more]</label></div><br/><div class="children"><div class="content">If the stakes weren&#x27;t so high, this would be a damn fun game of murder mystery.</div><br/></div></div></div></div></div></div><div id="39910922" class="c"><input type="checkbox" id="c-39910922" checked=""/><div class="controls bullet"><span class="by">xomodo</span><span>|</span><a href="#39907835">parent</a><span>|</span><a href="#39911496">prev</a><span>|</span><a href="#39910949">next</a><span>|</span><label class="collapse" for="c-39910922">[-]</label><label class="expand" for="c-39910922">[1 more]</label></div><br/><div class="children"><div class="content">Thx. Timeline shows attack begun by adding ignore entry in .gitignore file. That is hard to detect nowadays.</div><br/></div></div><div id="39910949" class="c"><input type="checkbox" id="c-39910949" checked=""/><div class="controls bullet"><span class="by">moopitydoop</span><span>|</span><a href="#39907835">parent</a><span>|</span><a href="#39910922">prev</a><span>|</span><a href="#39911221">next</a><span>|</span><label class="collapse" for="c-39910949">[-]</label><label class="expand" for="c-39910949">[1 more]</label></div><br/><div class="children"><div class="content">This just gives a partial high-level look at how the exploit gets planted in liblzma, it doesn&#x27;t cover how the exploit works or its contents at all.</div><br/></div></div></div></div><div id="39927267" class="c"><input type="checkbox" id="c-39927267" checked=""/><div class="controls bullet"><span class="by">Woodi</span><span>|</span><a href="#39907835">prev</a><span>|</span><a href="#39908673">next</a><span>|</span><label class="collapse" for="c-39927267">[-]</label><label class="expand" for="c-39927267">[1 more]</label></div><br/><div class="children"><div class="content">Few notes:<p>- &quot;auto<i>&quot; tools are installer tools and, after all, do good job. Maybe we can download any project that use it, run it once, parse results and put it in &#x2F;etc ? - becouse it&#x27;s already there. Then next step: build just-detection tools. Side note: just straight &#x27;make all&#x27; will detect it too :)  And it show additional next problem that auto</i>&#x27;s already solved - setting up all that inc&#x2F;lib paths...<p>- m4 should be replaced and <i>not</i> by monstrosity like cmake<p>- GNU&#x27;s came after MIT&#x27;s and BSD&#x27;s, evolved from them. But corporations adapted and assimilated. We need next evolution step: something that forces corporations to spend money on what they use, fund devs or participate in development. OSlicensecertification.orgs should help with that instead of helping corps to be predators becouse some outdated bullshit talks<p>- yea, auto* tools are way overcomplicated<p>- finally do that TTY 2.0 !</div><br/></div></div><div id="39908673" class="c"><input type="checkbox" id="c-39908673" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#39927267">prev</a><span>|</span><a href="#39915178">next</a><span>|</span><label class="collapse" for="c-39908673">[-]</label><label class="expand" for="c-39908673">[25 more]</label></div><br/><div class="children"><div class="content">&gt; The first difference is that the script makes sure (very sure!) to exit if not being run on Linux.<p>The repeated check is indeed mysterious. My only hypothesis is that the attacker may have thought that it should look plausible as a test input to a compression library, hence repetition.</div><br/><div id="39909225" class="c"><input type="checkbox" id="c-39909225" checked=""/><div class="controls bullet"><span class="by">mercurialuser</span><span>|</span><a href="#39908673">parent</a><span>|</span><a href="#39918207">next</a><span>|</span><label class="collapse" for="c-39909225">[-]</label><label class="expand" for="c-39909225">[1 more]</label></div><br/><div class="children"><div class="content">It can be to make space for script changes: you may overwrite the first bytes of the script.<p>Or just add some laziness.</div><br/></div></div><div id="39918207" class="c"><input type="checkbox" id="c-39918207" checked=""/><div class="controls bullet"><span class="by">Hakkin</span><span>|</span><a href="#39908673">parent</a><span>|</span><a href="#39909225">prev</a><span>|</span><a href="#39911896">next</a><span>|</span><label class="collapse" for="c-39918207">[-]</label><label class="expand" for="c-39918207">[2 more]</label></div><br/><div class="children"><div class="content">I also thought it was odd. There&#x27;s also different random bytes (not random text, actual random bytes) prefixed to the start the scripts, but the bytes are prefixed by a hash symbol, which comments them out, so they don&#x27;t affect the script. It seems intentional, but I can&#x27;t think of why they would be there. I thought maybe xz would skip compression if the input was short&#x2F;not complex enough or something, so they were added to pad the size, but removing them and re-compressing with xz seems to properly compress it, none of the original plaintext is in the compressed archive bytes.<p>One thing I noticed while trying to reproduce the exact bytes included in the .xz file committed to git is that the script&#x27;s xz stream doesn&#x27;t seem to be compressed by any of the default xz presets, I was only able to reproduce it by using `xz --lzma2=dict=65536 -c stream_2`. All the default numbered presents chose a different dictionary size. Another odd seemingly intentional choice, but again I don&#x27;t understand the reasoning.</div><br/><div id="39918324" class="c"><input type="checkbox" id="c-39918324" checked=""/><div class="controls bullet"><span class="by">Hakkin</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39918207">parent</a><span>|</span><a href="#39911896">next</a><span>|</span><label class="collapse" for="c-39918324">[-]</label><label class="expand" for="c-39918324">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I think I understand the random bytes at the start of the script now. They&#x27;re prepended to make the partial output of the &quot;corrupted&quot; (pre-tr&#x27;d) test stream look like random data. Without those random bytes, you will see part of the start of the script if you observe the partially decompressed output before xz throws an error. They really thought quite carefully about hiding this well.<p>Still not sure about the repeated lines, though now I&#x27;m convinced there must be some reason for it.</div><br/></div></div></div></div><div id="39911896" class="c"><input type="checkbox" id="c-39911896" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#39908673">parent</a><span>|</span><a href="#39918207">prev</a><span>|</span><a href="#39908838">next</a><span>|</span><label class="collapse" for="c-39911896">[-]</label><label class="expand" for="c-39911896">[1 more]</label></div><br/><div class="children"><div class="content">Can it be to enlarge&#x2F;or obfuscate parts of the compressed test file? Perhaps without the repetitions the compressed file has some strange binary triggering some security or antivirus software?</div><br/></div></div><div id="39908838" class="c"><input type="checkbox" id="c-39908838" checked=""/><div class="controls bullet"><span class="by">TheBlight</span><span>|</span><a href="#39908673">parent</a><span>|</span><a href="#39911896">prev</a><span>|</span><a href="#39917415">next</a><span>|</span><label class="collapse" for="c-39908838">[-]</label><label class="expand" for="c-39908838">[8 more]</label></div><br/><div class="children"><div class="content">Is it though? The attacker probably has Linux x86 target(s) in mind and IFUNC support isn&#x27;t guaranteed to work with other platforms.</div><br/><div id="39908956" class="c"><input type="checkbox" id="c-39908956" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39908838">parent</a><span>|</span><a href="#39913062">next</a><span>|</span><label class="collapse" for="c-39908956">[-]</label><label class="expand" for="c-39908956">[5 more]</label></div><br/><div class="children"><div class="content">Checking for Linux makes sense. Doing the exact same check for Linux five times in a row is mysterious.</div><br/><div id="39910029" class="c"><input type="checkbox" id="c-39910029" checked=""/><div class="controls bullet"><span class="by">tamimio</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39908956">parent</a><span>|</span><a href="#39913909">next</a><span>|</span><label class="collapse" for="c-39910029">[-]</label><label class="expand" for="c-39910029">[3 more]</label></div><br/><div class="children"><div class="content">It would be an interesting plot twist if the whole thing was an AI hallucination.</div><br/><div id="39911512" class="c"><input type="checkbox" id="c-39911512" checked=""/><div class="controls bullet"><span class="by">ddalex</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39910029">parent</a><span>|</span><a href="#39910272">next</a><span>|</span><label class="collapse" for="c-39911512">[-]</label><label class="expand" for="c-39911512">[1 more]</label></div><br/><div class="children"><div class="content">How about an AI trying to make itself some spare CPU cycles available ?</div><br/></div></div><div id="39910272" class="c"><input type="checkbox" id="c-39910272" checked=""/><div class="controls bullet"><span class="by">neffy</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39910029">parent</a><span>|</span><a href="#39911512">prev</a><span>|</span><a href="#39913909">next</a><span>|</span><label class="collapse" for="c-39910272">[-]</label><label class="expand" for="c-39910272">[1 more]</label></div><br/><div class="children"><div class="content">...or a stalking horse by somebody in Microsoft&#x27;s marketing division.</div><br/></div></div></div></div><div id="39913909" class="c"><input type="checkbox" id="c-39913909" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39908956">parent</a><span>|</span><a href="#39910029">prev</a><span>|</span><a href="#39913062">next</a><span>|</span><label class="collapse" for="c-39913909">[-]</label><label class="expand" for="c-39913909">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps expected a very fast machine that might blast straight through the first few checks. Like how you needed two STOP statements in a Cray Fortran program in case it blew through the first one at 80MIPS.</div><br/></div></div></div></div><div id="39913062" class="c"><input type="checkbox" id="c-39913062" checked=""/><div class="controls bullet"><span class="by">ycombinatrix</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39908838">parent</a><span>|</span><a href="#39908956">prev</a><span>|</span><a href="#39917415">next</a><span>|</span><label class="collapse" for="c-39913062">[-]</label><label class="expand" for="c-39913062">[2 more]</label></div><br/><div class="children"><div class="content">why doesn&#x27;t IFUNC work on Linux ARM64?</div><br/><div id="39918285" class="c"><input type="checkbox" id="c-39918285" checked=""/><div class="controls bullet"><span class="by">bodyfour</span><span>|</span><a href="#39908673">root</a><span>|</span><a href="#39913062">parent</a><span>|</span><a href="#39917415">next</a><span>|</span><label class="collapse" for="c-39918285">[-]</label><label class="expand" for="c-39918285">[1 more]</label></div><br/><div class="children"><div class="content">IFUNC is supported on several architectures, including ARM64.<p>The malicious code that the xz backdoor inserts into the library is a compiled x86_64 object file so it only is targeting one platform.</div><br/></div></div></div></div></div></div><div id="39917415" class="c"><input type="checkbox" id="c-39917415" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#39908673">parent</a><span>|</span><a href="#39908838">prev</a><span>|</span><a href="#39912898">next</a><span>|</span><label class="collapse" for="c-39917415">[-]</label><label class="expand" for="c-39917415">[1 more]</label></div><br/><div class="children"><div class="content">Maybe if run on non Linux it could be found out either by crashing or leaving some trace because of OS differences</div><br/></div></div></div></div><div id="39915178" class="c"><input type="checkbox" id="c-39915178" checked=""/><div class="controls bullet"><span class="by">kelseydh</span><span>|</span><a href="#39908673">prev</a><span>|</span><a href="#39910745">next</a><span>|</span><label class="collapse" for="c-39915178">[-]</label><label class="expand" for="c-39915178">[11 more]</label></div><br/><div class="children"><div class="content">The lesson I take away from this incident is that we probably shouldn&#x27;t be allowing anonymity for core contributers in critical open source projects.  This attack worked and the attacker will likely get away with it free of consequence, because they were anonymous.</div><br/><div id="39915310" class="c"><input type="checkbox" id="c-39915310" checked=""/><div class="controls bullet"><span class="by">ulrikrasmussen</span><span>|</span><a href="#39915178">parent</a><span>|</span><a href="#39915958">next</a><span>|</span><label class="collapse" for="c-39915310">[-]</label><label class="expand" for="c-39915310">[4 more]</label></div><br/><div class="children"><div class="content">No thanks.<p>That&#x27;s not going to help, and will be fairly easy to circumvent for nation state actors or similar advanced persistent threats who will not have a problem adding an extra step of identity theft to their attack chain, or simply use an agent who can be protected if the backdoor is ever discovered.<p>On the other hand, the technical hoops required for something like that will likely cause a lot of damage to the whole open source community.<p>The solution here is learn from this attack and change practices to make a similar one more difficult to pull off:<p>1. Never allow files in release tar-balls which are not present in the repo.<p>2. As a consequence, all generated code should be checked in. Build scripts should re-generate all derived code and fail if the checked in code deviates from the generated.<p>3. No inscrutable data should be accessible by the release build process. This means that tests relying on binary data should be built completely separately from the release binaries.</div><br/><div id="39918737" class="c"><input type="checkbox" id="c-39918737" checked=""/><div class="controls bullet"><span class="by">lenerdenator</span><span>|</span><a href="#39915178">root</a><span>|</span><a href="#39915310">parent</a><span>|</span><a href="#39918271">next</a><span>|</span><label class="collapse" for="c-39918737">[-]</label><label class="expand" for="c-39918737">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to steal or craft an identity. Having a person adopt that identity and use it over multiple in-person meetings around the world over an extended period of time is not.<p>Part of the appeal of cyber operations for intelligence agencies is that there&#x27;s basically no tradecraft involved. You park some hacker in front of a laptop within your territory (which also happens to have a constitution forbidding the extradition of citizens) and the hacker strikes at targets through obfuscated digital vectors of attack. They never go in public, they never get a photo taken of them, they never get trailed by counterintelligence.<p>If you start telling people who want to be FLOSS repo maintainers that they&#x27;ll need to be at a few in-person meetings over a span of two or three years if they want the keys to the project, that hacker has a <i>much</i> harder job, because in-person social engineering is hard. It has to be the same person showing up, time after time, and that person has to be able to talk the language of someone intimately familiar with the technology while being someone they&#x27;re not.<p>It&#x27;s not a cure-all but for supply chain attacks, it makes the operation a lot riskier, resource-intense, and time-consuming.</div><br/><div id="39923298" class="c"><input type="checkbox" id="c-39923298" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#39915178">root</a><span>|</span><a href="#39918737">parent</a><span>|</span><a href="#39918271">next</a><span>|</span><label class="collapse" for="c-39923298">[-]</label><label class="expand" for="c-39923298">[1 more]</label></div><br/><div class="children"><div class="content">Many OSS contributors likely don&#x27;t have &quot;fly to distant country for mandatory meeting&quot; money.<p>You are excluding a ton of contributors based on geography and income.<p>It&#x27;s not common that I find this line actually decent but check your privilege with this kind of comment.<p>This is really a small step away from segregation.</div><br/></div></div></div></div><div id="39918271" class="c"><input type="checkbox" id="c-39918271" checked=""/><div class="controls bullet"><span class="by">peteradio</span><span>|</span><a href="#39915178">root</a><span>|</span><a href="#39915310">parent</a><span>|</span><a href="#39918737">prev</a><span>|</span><a href="#39915958">next</a><span>|</span><label class="collapse" for="c-39918271">[-]</label><label class="expand" for="c-39918271">[1 more]</label></div><br/><div class="children"><div class="content">Stop trying to support such a variety of images too? Maybe?</div><br/></div></div></div></div><div id="39915958" class="c"><input type="checkbox" id="c-39915958" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#39915178">parent</a><span>|</span><a href="#39915310">prev</a><span>|</span><a href="#39918310">next</a><span>|</span><label class="collapse" for="c-39915958">[-]</label><label class="expand" for="c-39915958">[1 more]</label></div><br/><div class="children"><div class="content">Two problems with this:<p>1. Many important contributors, especially in security, prefer to be pseudonymous for good reasons. Insisting on identity drives them away.<p>2. If a spy agency was behind this, as many people have speculated, those can all manufacture &quot;real&quot; identities anyway.<p>So you&#x27;d be excluding helpful people and not excluding the attackers.</div><br/></div></div><div id="39918310" class="c"><input type="checkbox" id="c-39918310" checked=""/><div class="controls bullet"><span class="by">akdev1l</span><span>|</span><a href="#39915178">parent</a><span>|</span><a href="#39915958">prev</a><span>|</span><a href="#39915210">next</a><span>|</span><label class="collapse" for="c-39918310">[-]</label><label class="expand" for="c-39918310">[1 more]</label></div><br/><div class="children"><div class="content">If this was a state-actor (which it definitely looks like it) then what validation are you going to do? They can probably manufacture legitimate papers for anything.<p>Driver’s license, SSN, national ID, passport, etc. If the government is in on it then there’s no limits.<p>The only way would be to require physical presence in a trusted location. (Hopefully in a jurisdiction that doesn’t belong to the attacker…)</div><br/></div></div><div id="39915210" class="c"><input type="checkbox" id="c-39915210" checked=""/><div class="controls bullet"><span class="by">hk__2</span><span>|</span><a href="#39915178">parent</a><span>|</span><a href="#39918310">prev</a><span>|</span><a href="#39915291">next</a><span>|</span><label class="collapse" for="c-39915210">[-]</label><label class="expand" for="c-39915210">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The lesson I take away from this incident is that we probably shouldn&#x27;t be allowing anonymity for core contributers in critical open source projects. This attack worked and the attacker will likely get away with it free of consequence, because they were anonymous.<p>This would be impossible to enforce, and might not be a good idea because it enables other ranges of attacks: if you know the identities of the maintainers of critical open source projects, it’s easier to put pressure on them.</div><br/></div></div><div id="39915291" class="c"><input type="checkbox" id="c-39915291" checked=""/><div class="controls bullet"><span class="by">Jonnax</span><span>|</span><a href="#39915178">parent</a><span>|</span><a href="#39915210">prev</a><span>|</span><a href="#39915320">next</a><span>|</span><label class="collapse" for="c-39915291">[-]</label><label class="expand" for="c-39915291">[1 more]</label></div><br/><div class="children"><div class="content">Who designates it as critical?<p>If someone makes a library and other people start using it, are they forced to reveal their identity?<p>Do the maintainers get paid?</div><br/></div></div><div id="39915320" class="c"><input type="checkbox" id="c-39915320" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#39915178">parent</a><span>|</span><a href="#39915291">prev</a><span>|</span><a href="#39915244">next</a><span>|</span><label class="collapse" for="c-39915320">[-]</label><label class="expand" for="c-39915320">[1 more]</label></div><br/><div class="children"><div class="content">It might prevent attacks under different aliases, but a determined organization will be able to create a verified account, if only because nobody, certainly noy github, has the will and means to verify  each account themselves.</div><br/></div></div><div id="39915244" class="c"><input type="checkbox" id="c-39915244" checked=""/><div class="controls bullet"><span class="by">damsalor</span><span>|</span><a href="#39915178">parent</a><span>|</span><a href="#39915320">prev</a><span>|</span><a href="#39910745">next</a><span>|</span><label class="collapse" for="c-39915244">[-]</label><label class="expand" for="c-39915244">[1 more]</label></div><br/><div class="children"><div class="content">The attack almost worked because of too few eyes</div><br/></div></div></div></div><div id="39910745" class="c"><input type="checkbox" id="c-39910745" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#39915178">prev</a><span>|</span><a href="#39920104">next</a><span>|</span><label class="collapse" for="c-39910745">[-]</label><label class="expand" for="c-39910745">[25 more]</label></div><br/><div class="children"><div class="content">Whoever hired these people to infiltrate this project spent a shit ton of hours building it in such a way to avoid detection this long. Fortunately, it was so complicated that they couldn&#x27;t account for all of the factors.<p>This is why open source will always outperform closed source in terms of security. Sure it pointed a massive flaw in the supply chain. Sure it highlights how under appreciated the foundational elements of FOSS, leaving maintainers subject to manipulation.<p>But the same attack within a private company? Shit, probably wouldn&#x27;t even need advanced obfuscation. With a large enough PR and looming deadlines, could easily sneak something like this with a minimal amount of effort into production systems. By the time company even realizes what happens, you are already flying off to a non-extradition country and selling the exfiltrated data on Tor (or dark web).</div><br/><div id="39910956" class="c"><input type="checkbox" id="c-39910956" checked=""/><div class="controls bullet"><span class="by">bsza</span><span>|</span><a href="#39910745">parent</a><span>|</span><a href="#39911038">next</a><span>|</span><label class="collapse" for="c-39910956">[-]</label><label class="expand" for="c-39910956">[7 more]</label></div><br/><div class="children"><div class="content">I’m gonna cry survivorship bias here. How do we know how many similar attempts succeeded? How many of the ones discovered have been written off as honest mistakes? How can we know for sure that e.g. Heartbleed wasn’t put there by someone on purpose (and that that someone isn’t filthy rich now)?<p>When you get hired to a private company, they know who you are. That’s an immediate deterrent against trying anything funny. On Github, no one knows who you are. It might be harder to backdoor a project without getting noticed, but there is no risk to getting noticed. You can try as many times as you like. Jia Tan is still at large, and didn’t even have to plan their whole life around living in a non-extraditing country (if they aren’t in one already).</div><br/><div id="39911701" class="c"><input type="checkbox" id="c-39911701" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39910956">parent</a><span>|</span><a href="#39915115">prev</a><span>|</span><a href="#39911038">next</a><span>|</span><label class="collapse" for="c-39911701">[-]</label><label class="expand" for="c-39911701">[5 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Industrial_espionage" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Industrial_espionage</a> (aka corporate espionage)<p>Happens all the time. Maybe it&#x27;s a state actor. Maybe it&#x27;s a disgruntled employee. It&#x27;s just not in the same lens as you expect (software supply chain attack).<p>Apple has trouble keeping the lid on top secret projects. Leaks about designs happen all the time prior to scheduled debut at WWDC.<p>MS has had trouble in the past as well when it came to developing the Xbox (One?).<p>&quot;Owners of China-Based Company Charged With Conspiracy to Send Trade Secrets Belonging to Leading U.S.-Based Electric Vehicle Company&quot; - <a href="https:&#x2F;&#x2F;www.justice.gov&#x2F;usao-edny&#x2F;pr&#x2F;owners-china-based-company-charged-conspiracy-send-trade-secrets-belonging-leading-us" rel="nofollow">https:&#x2F;&#x2F;www.justice.gov&#x2F;usao-edny&#x2F;pr&#x2F;owners-china-based-comp...</a><p>&quot;Ex-Google engineer charged with stealing AI trade secrets while working with Chinese companies&quot; - <a href="https:&#x2F;&#x2F;www.latimes.com&#x2F;world-nation&#x2F;story&#x2F;2024-03-07&#x2F;ex-google-engineer-charged-with-stealing-ai-trade-secrets-while-working-with-chinese-companies" rel="nofollow">https:&#x2F;&#x2F;www.latimes.com&#x2F;world-nation&#x2F;story&#x2F;2024-03-07&#x2F;ex-goo...</a><p>&quot;The US Hits Huawei With New Charges of Trade Secret Theft&quot; - <a href="https:&#x2F;&#x2F;www.wired.com&#x2F;story&#x2F;us-hits-huawei-new-charges-trade-secret-theft&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.wired.com&#x2F;story&#x2F;us-hits-huawei-new-charges-trade...</a><p>&quot;U.S. charges China-controlled company in trade secrets theft&quot; - <a href="https:&#x2F;&#x2F;www.pbs.org&#x2F;newshour&#x2F;economy&#x2F;u-s-charges-china-controlled-company-in-trade-secrets-theft" rel="nofollow">https:&#x2F;&#x2F;www.pbs.org&#x2F;newshour&#x2F;economy&#x2F;u-s-charges-china-contr...</a><p>&quot;Ex-Google and Uber engineer Anthony Levandowski charged with trade secret theft&quot; - <a href="https:&#x2F;&#x2F;www.theverge.com&#x2F;2019&#x2F;8&#x2F;27&#x2F;20835368&#x2F;google-uber-engineer-trade-theft-secrets-anthony-levandowski-charged" rel="nofollow">https:&#x2F;&#x2F;www.theverge.com&#x2F;2019&#x2F;8&#x2F;27&#x2F;20835368&#x2F;google-uber-engi...</a><p>In the case of Levandowski, the dude didn&#x27;t even bother with covering his tracks. Straight up just downloads trade secrets from source control and transfers them to personal computer - <a href="https:&#x2F;&#x2F;www.justice.gov&#x2F;usao-ndca&#x2F;press-release&#x2F;file&#x2F;1197991&#x2F;download" rel="nofollow">https:&#x2F;&#x2F;www.justice.gov&#x2F;usao-ndca&#x2F;press-release&#x2F;file&#x2F;1197991...</a><p>In this small sample of cases, were the exfiltration attempts as elaborate as the &quot;xz attack&quot;? Probably not, but all of these people were vetted by internal procedures and that did nothing to stop them from acting maliciously.<p>Forget back dooring the project when getting through the front door is so much easier! People are very relaxed in their walled off garden and cubicle :)</div><br/><div id="39912932" class="c"><input type="checkbox" id="c-39912932" checked=""/><div class="controls bullet"><span class="by">resolutebat</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39911701">parent</a><span>|</span><a href="#39913886">next</a><span>|</span><label class="collapse" for="c-39912932">[-]</label><label class="expand" for="c-39912932">[1 more]</label></div><br/><div class="children"><div class="content">Stealing trade secrets (read: copying source code) is a whole different ballgame from trying to inject backdoors into ubiquitous pieces of software.</div><br/></div></div><div id="39913886" class="c"><input type="checkbox" id="c-39913886" checked=""/><div class="controls bullet"><span class="by">bsza</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39911701">parent</a><span>|</span><a href="#39912932">prev</a><span>|</span><a href="#39911038">next</a><span>|</span><label class="collapse" for="c-39913886">[-]</label><label class="expand" for="c-39913886">[3 more]</label></div><br/><div class="children"><div class="content">This kind of demonstrates my point. Every single one of these headlines indicates the bad actor has been &quot;charged&quot; (with serious consequences in the case of Huawei).<p>Has Jia Tan been &quot;charged&quot; with anything?</div><br/><div id="39914042" class="c"><input type="checkbox" id="c-39914042" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39913886">parent</a><span>|</span><a href="#39911038">next</a><span>|</span><label class="collapse" for="c-39914042">[-]</label><label class="expand" for="c-39914042">[2 more]</label></div><br/><div class="children"><div class="content">I’m gonna cry survivorship bias here. How do we know how many similar attempts succeeded?</div><br/><div id="39917473" class="c"><input type="checkbox" id="c-39917473" checked=""/><div class="controls bullet"><span class="by">bsza</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39914042">parent</a><span>|</span><a href="#39911038">next</a><span>|</span><label class="collapse" for="c-39917473">[-]</label><label class="expand" for="c-39917473">[1 more]</label></div><br/><div class="children"><div class="content">Right, we don’t know that, but we have yet to hear of one case where a supply chain attack on a FOSS project resulted in someone getting arrested.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39911038" class="c"><input type="checkbox" id="c-39911038" checked=""/><div class="controls bullet"><span class="by">yongjik</span><span>|</span><a href="#39910745">parent</a><span>|</span><a href="#39910956">prev</a><span>|</span><a href="#39910934">next</a><span>|</span><label class="collapse" for="c-39911038">[-]</label><label class="expand" for="c-39911038">[12 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t buy it.  Most private companies would require a face-to-face meeting when you start.  Even if you&#x27;re fully remote, the expectation would be that at some point you would meet your coworkers at meetspace, most likely before you get to commit anything substantial.  The ones that are worth penetrating will almost certainly require a background check.<p>And then, once you&#x27;re in, you cannot just commit to your target project willy-nilly, as your manager and your manager&#x27;s manager will have other priorities.  A for-profit company&#x27;s frequently dysfunctional management would actually work as deterrent here: you don&#x27;t just need to justify your code, you will have to justify why you were working on it in the first place.</div><br/><div id="39911751" class="c"><input type="checkbox" id="c-39911751" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39911038">parent</a><span>|</span><a href="#39911332">next</a><span>|</span><label class="collapse" for="c-39911751">[-]</label><label class="expand" for="c-39911751">[9 more]</label></div><br/><div class="children"><div class="content">face to face, background checks. they are all superficial.<p>A smooth talker can get you to relax your guard.<p>Identity can be faked, especially if you have a nation state backing you.</div><br/><div id="39912129" class="c"><input type="checkbox" id="c-39912129" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39911751">parent</a><span>|</span><a href="#39911898">next</a><span>|</span><label class="collapse" for="c-39912129">[-]</label><label class="expand" for="c-39912129">[1 more]</label></div><br/><div class="children"><div class="content">How much would you bet against the NSA having a team full of leetcode and interview experts, who&#x27;s job is to apply at tech companies and perform excellently through the hiring process, so that the offensive team at NSA can infiltrate and work remotely without ever needing to meet there new &quot;coworkers&quot;?<p>I suspect a &quot;professional job seeker&quot; with the resources of the NSA behind them and who lands 1st and subsequent interviews dozens of times a year - would be _way_ better at landing interviews and jumping through stupid recruiting hoops that even the best senior or &quot;10x engineers&quot;, who probably only interview a dozen or two times in their entire career.</div><br/></div></div><div id="39911898" class="c"><input type="checkbox" id="c-39911898" checked=""/><div class="controls bullet"><span class="by">breadwinner</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39911751">parent</a><span>|</span><a href="#39912129">prev</a><span>|</span><a href="#39911332">next</a><span>|</span><label class="collapse" for="c-39911898">[-]</label><label class="expand" for="c-39911898">[7 more]</label></div><br/><div class="children"><div class="content">Today no one knows what Jia Tan looks like. That means Jia Tan come back as Gary Smith and work on the next exploit. If we knew what he looked like, we could have at least prevented him from coming back.</div><br/><div id="39912559" class="c"><input type="checkbox" id="c-39912559" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39911898">parent</a><span>|</span><a href="#39911332">next</a><span>|</span><label class="collapse" for="c-39912559">[-]</label><label class="expand" for="c-39912559">[6 more]</label></div><br/><div class="children"><div class="content">Jia Tan might be more than one person.</div><br/><div id="39913650" class="c"><input type="checkbox" id="c-39913650" checked=""/><div class="controls bullet"><span class="by">breadwinner</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39912559">parent</a><span>|</span><a href="#39911332">next</a><span>|</span><label class="collapse" for="c-39913650">[-]</label><label class="expand" for="c-39913650">[5 more]</label></div><br/><div class="children"><div class="content">Requiring him&#x2F;her to show their face might have prevented that.</div><br/><div id="39915051" class="c"><input type="checkbox" id="c-39915051" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39913650">parent</a><span>|</span><a href="#39911332">next</a><span>|</span><label class="collapse" for="c-39915051">[-]</label><label class="expand" for="c-39915051">[4 more]</label></div><br/><div class="children"><div class="content">Why? Just have one person show up and everyone else funnel the work through their account.</div><br/><div id="39916670" class="c"><input type="checkbox" id="c-39916670" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39915051">parent</a><span>|</span><a href="#39915482">next</a><span>|</span><label class="collapse" for="c-39916670">[-]</label><label class="expand" for="c-39916670">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s still one named person the police can go after, a good starting point for investigation into the criminal network.<p>Also, that&#x27;s still one named person that no one would like to end up being, so that alone acts as a deterrent.</div><br/></div></div><div id="39915482" class="c"><input type="checkbox" id="c-39915482" checked=""/><div class="controls bullet"><span class="by">kelseydh</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39915051">parent</a><span>|</span><a href="#39916670">prev</a><span>|</span><a href="#39911332">next</a><span>|</span><label class="collapse" for="c-39915482">[-]</label><label class="expand" for="c-39915482">[2 more]</label></div><br/><div class="children"><div class="content">On open source projects you can vet people based on whether you can personally identify them as real people.  Moving forward be suspicious of anonymity for core contributions.</div><br/><div id="39919133" class="c"><input type="checkbox" id="c-39919133" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39915482">parent</a><span>|</span><a href="#39911332">next</a><span>|</span><label class="collapse" for="c-39919133">[-]</label><label class="expand" for="c-39919133">[1 more]</label></div><br/><div class="children"><div class="content">Debian does things that way, their developers have to get their key signed by other developers, and a DD who signs someone&#x27;s key is supposed to check ID. But there&#x27;s no similar protection for their upstream.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39911092" class="c"><input type="checkbox" id="c-39911092" checked=""/><div class="controls bullet"><span class="by">ThePowerOfFuet</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39911038">parent</a><span>|</span><a href="#39911332">prev</a><span>|</span><a href="#39910934">next</a><span>|</span><label class="collapse" for="c-39911092">[-]</label><label class="expand" for="c-39911092">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;rigor-mortis.nmrc.org&#x2F;@simplenomad&#x2F;112184869681420177" rel="nofollow">https:&#x2F;&#x2F;rigor-mortis.nmrc.org&#x2F;@simplenomad&#x2F;11218486968142017...</a></div><br/></div></div></div></div><div id="39910934" class="c"><input type="checkbox" id="c-39910934" checked=""/><div class="controls bullet"><span class="by">skrtskrt</span><span>|</span><a href="#39910745">parent</a><span>|</span><a href="#39911038">prev</a><span>|</span><a href="#39911254">next</a><span>|</span><label class="collapse" for="c-39910934">[-]</label><label class="expand" for="c-39910934">[4 more]</label></div><br/><div class="children"><div class="content">off topic, but how many actual non-extradition countries are there these days (for the US)?<p>Even countries we have strained relationships with will extradite as part of a negotiation when it&#x27;s convenient for them politically.<p>Russia probably wouldn&#x27;t have even kept Snowden if it wasn&#x27;t state secrets he revealed.
If it was just some random data breach they would have prisoner-swapped him for an oligarch caught money laundering elsewhere.</div><br/><div id="39910991" class="c"><input type="checkbox" id="c-39910991" checked=""/><div class="controls bullet"><span class="by">moopitydoop</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39910934">parent</a><span>|</span><a href="#39911266">next</a><span>|</span><label class="collapse" for="c-39910991">[-]</label><label class="expand" for="c-39910991">[1 more]</label></div><br/><div class="children"><div class="content">Our adversaries aren&#x27;t going to extradite their citizens to the west. And obviously if it&#x27;s a state-level actor they aren&#x27;t going to extradite their own actors.<p>As someone old enough to remember the tail end of the early hacker eras (e.g. Mitnick), I don&#x27;t think anyone SHOULD be extradited over this, in particular if they&#x27;re not being charged with actually using the exploit. Prosecute them where they live. Should they be prosecuted 193 times over in every state on Earth? What&#x27;s the nexus? Github? Every server that installed the compromised xz utils?<p>But you are right they will <i>deport</i> (not extradite) foreigners who are inconvenient to them or when it is politically expedient to do so, if the foreigners are a nuisance, or as part of a political negotiation or prisoner exchange.<p>The whole &quot;extradition treaties&quot; meme is a misconception. You will only get extradited if you flee to a country where you are a citizen (even dual citizen), or the ability to assert citizenship&#x2F;nationality there. A fugitive fleeing to a country without an extradition treaty is subject to deportation. Every country on earth reserves the right to deny entry to or deport foreign fugitives. They might choose not to if someone is found to be a refugee, subject to the death penalty in a non-death-penalty state, etc.</div><br/></div></div><div id="39911266" class="c"><input type="checkbox" id="c-39911266" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39910934">parent</a><span>|</span><a href="#39910991">prev</a><span>|</span><a href="#39912433">next</a><span>|</span><label class="collapse" for="c-39911266">[-]</label><label class="expand" for="c-39911266">[1 more]</label></div><br/><div class="children"><div class="content">Russia and China would never extradite for this, they would hire the people involved if they aren&#x27;t already in their employ, and I wouldn&#x27;t blame them. I&#x27;m not even sure if they could be charged with more than misdemeanor charges anyway.</div><br/></div></div><div id="39912433" class="c"><input type="checkbox" id="c-39912433" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#39910745">root</a><span>|</span><a href="#39910934">parent</a><span>|</span><a href="#39911266">prev</a><span>|</span><a href="#39911254">next</a><span>|</span><label class="collapse" for="c-39912433">[-]</label><label class="expand" for="c-39912433">[1 more]</label></div><br/><div class="children"><div class="content">&gt; off topic, but how many actual non-extradition countries are there these days (for the US)?<p>Several countries do not extradite their own citizens. For citizens of these countries, going back to their own home country would be enough.</div><br/></div></div></div></div><div id="39911254" class="c"><input type="checkbox" id="c-39911254" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#39910745">parent</a><span>|</span><a href="#39910934">prev</a><span>|</span><a href="#39920104">next</a><span>|</span><label class="collapse" for="c-39911254">[-]</label><label class="expand" for="c-39911254">[1 more]</label></div><br/><div class="children"><div class="content">Could be interesting as a class project to investigate other small relatively innocuous but near ubiquitous projects that could be treated the same way and investigate whether something similar could be done or has been done already. Just making a list of them would be useful if nothing else.</div><br/></div></div></div></div><div id="39920104" class="c"><input type="checkbox" id="c-39920104" checked=""/><div class="controls bullet"><span class="by">PHGamer</span><span>|</span><a href="#39910745">prev</a><span>|</span><a href="#39920582">next</a><span>|</span><label class="collapse" for="c-39920104">[-]</label><label class="expand" for="c-39920104">[2 more]</label></div><br/><div class="children"><div class="content">if anyone has worked in any development. (closed or open) you know half the time developers are lazy and just approve PRs. Linus Torvalds is like the glimming exception where he will call out shit all day long.</div><br/><div id="39920284" class="c"><input type="checkbox" id="c-39920284" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#39920104">parent</a><span>|</span><a href="#39920582">next</a><span>|</span><label class="collapse" for="c-39920284">[-]</label><label class="expand" for="c-39920284">[1 more]</label></div><br/><div class="children"><div class="content">Second this.<p>And in the event someone is pedantic enough to actually care: that person will be considered a pariah that all development stifles due to.<p>Tensions with the team for nitpicking etc;<p>FD: I have a situation like this now, I am not the one being picky- one of the developers I hired is. I had to move him out of the team because unfortunately his nitpicky behaviour was not well regarded. (he also comes from eastern europe and has a very matter-of-fact way of giving feedback too which does not aid things).</div><br/></div></div></div></div><div id="39920582" class="c"><input type="checkbox" id="c-39920582" checked=""/><div class="controls bullet"><span class="by">jcarrano</span><span>|</span><a href="#39920104">prev</a><span>|</span><a href="#39918438">next</a><span>|</span><label class="collapse" for="c-39920582">[-]</label><label class="expand" for="c-39920582">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the advantage of IFUNCS, over putting a function in the library that selects the implementation, either via function pointers or a switch&#x2F;if? In particular given that they seem to be quite fragile and exploitable too.<p>I don&#x27;t have much experience in low-level optimization, but would a modern CPU not be able to predict the path taken by a brach that tests the CPU features.</div><br/><div id="39921116" class="c"><input type="checkbox" id="c-39921116" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#39920582">parent</a><span>|</span><a href="#39918438">next</a><span>|</span><label class="collapse" for="c-39921116">[-]</label><label class="expand" for="c-39921116">[1 more]</label></div><br/><div class="children"><div class="content">&gt; either via function pointers or a switch&#x2F;if?<p>&gt; but would a modern CPU not be able to predict the path taken by a brach that tests the CPU features.<p>That&#x27;s true, but the CPU has finite branch predictor state, and now you&#x27;ve wasted some of it. Indirect calls hurt too, especially in you need retpolines.<p>This is a great read: <a href="https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;microarchitecture.pdf" rel="nofollow">https:&#x2F;&#x2F;www.agner.org&#x2F;optimize&#x2F;microarchitecture.pdf</a><p>The Linux kernel has interfaces for doing the same thing, more explicitly than ifunc:<p><a href="https:&#x2F;&#x2F;docs.kernel.org&#x2F;next&#x2F;staging&#x2F;static-keys.html" rel="nofollow">https:&#x2F;&#x2F;docs.kernel.org&#x2F;next&#x2F;staging&#x2F;static-keys.html</a><p><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;815908&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;815908&#x2F;</a></div><br/></div></div></div></div><div id="39918438" class="c"><input type="checkbox" id="c-39918438" checked=""/><div class="controls bullet"><span class="by">xurukefi</span><span>|</span><a href="#39920582">prev</a><span>|</span><a href="#39911936">next</a><span>|</span><label class="collapse" for="c-39918438">[-]</label><label class="expand" for="c-39918438">[3 more]</label></div><br/><div class="children"><div class="content">Since I&#x27;m a bit late to the party and feeling somewhat overwhelmed by the multitude of articles floating around, I wonder: Has there been any detailed analysis of the actual injected object file? Thus far, I haven&#x27;t come across any, which strikes me as rather peculiar given that it&#x27;s been a few days.</div><br/><div id="39918889" class="c"><input type="checkbox" id="c-39918889" checked=""/><div class="controls bullet"><span class="by">tithe</span><span>|</span><a href="#39918438">parent</a><span>|</span><a href="#39918609">next</a><span>|</span><label class="collapse" for="c-39918889">[-]</label><label class="expand" for="c-39918889">[1 more]</label></div><br/><div class="children"><div class="content">Your best bet may be in the chat (from <a href="https:&#x2F;&#x2F;www.openwall.com&#x2F;lists&#x2F;oss-security&#x2F;2024&#x2F;03&#x2F;30&#x2F;26" rel="nofollow">https:&#x2F;&#x2F;www.openwall.com&#x2F;lists&#x2F;oss-security&#x2F;2024&#x2F;03&#x2F;30&#x2F;26</a> ):<p>Matrix: #xz-backdoor-reversing:nil.im<p>IRC: #xz-backdoor-reversing on irc.oftc.net<p>Discord: <a href="https:&#x2F;&#x2F;discord.gg&#x2F;XqTshWbR5F" rel="nofollow">https:&#x2F;&#x2F;discord.gg&#x2F;XqTshWbR5F</a></div><br/></div></div><div id="39918609" class="c"><input type="checkbox" id="c-39918609" checked=""/><div class="controls bullet"><span class="by">lenerdenator</span><span>|</span><a href="#39918438">parent</a><span>|</span><a href="#39918889">prev</a><span>|</span><a href="#39911936">next</a><span>|</span><label class="collapse" for="c-39918609">[-]</label><label class="expand" for="c-39918609">[1 more]</label></div><br/><div class="children"><div class="content">I agree, I haven&#x27;t seen anything about decompiling the object file.<p>If I had a project to develop a backdoor to keep persistent access to whatever machine I wanted, it would make sense that I would have a plug-in executable that I would use for multiple backdoors. That&#x27;s just decent engineering.</div><br/></div></div></div></div><div id="39911936" class="c"><input type="checkbox" id="c-39911936" checked=""/><div class="controls bullet"><span class="by">zadwang</span><span>|</span><a href="#39918438">prev</a><span>|</span><a href="#39912238">next</a><span>|</span><label class="collapse" for="c-39911936">[-]</label><label class="expand" for="c-39911936">[2 more]</label></div><br/><div class="children"><div class="content">The set of unix utilities have been tested a long time. I just wish the kernel and key utilities keeps fixed and not changed. Unless absolutely necessary. Don’t fix it if it ain’t broken. The software empire seems out of control.</div><br/><div id="39913618" class="c"><input type="checkbox" id="c-39913618" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39911936">parent</a><span>|</span><a href="#39912238">next</a><span>|</span><label class="collapse" for="c-39913618">[-]</label><label class="expand" for="c-39913618">[1 more]</label></div><br/><div class="children"><div class="content">It is all broken. The quick hack to make things kind of work today, compounded across fifty years and a million developers.<p>There are occasional shining lights of stuff done right but I think it&#x27;s fair to say they&#x27;re comprehensively outcompeted.</div><br/></div></div></div></div><div id="39912238" class="c"><input type="checkbox" id="c-39912238" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#39911936">prev</a><span>|</span><a href="#39921879">next</a><span>|</span><label class="collapse" for="c-39912238">[-]</label><label class="expand" for="c-39912238">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of tragically amusing how heinously complex and unnecessarily inscrutable modern technology is, and it&#x27;s only getting worse. I think developers sadistically enjoy it.</div><br/><div id="39918229" class="c"><input type="checkbox" id="c-39918229" checked=""/><div class="controls bullet"><span class="by">Trufa</span><span>|</span><a href="#39912238">parent</a><span>|</span><a href="#39921879">next</a><span>|</span><label class="collapse" for="c-39918229">[-]</label><label class="expand" for="c-39918229">[1 more]</label></div><br/><div class="children"><div class="content">This is probably the worst take ever.<p>It&#x27;s pretty amazing how the tools keep up with the increasing complexity of the products we make.<p>And to be honest, in most cases just make it simpler, I think people just don&#x27;t like to learn new stuff.</div><br/></div></div></div></div><div id="39920660" class="c"><input type="checkbox" id="c-39920660" checked=""/><div class="controls bullet"><span class="by">k3vinw</span><span>|</span><a href="#39921879">prev</a><span>|</span><a href="#39918823">next</a><span>|</span><label class="collapse" for="c-39920660">[-]</label><label class="expand" for="c-39920660">[1 more]</label></div><br/><div class="children"><div class="content">Ha. This backdoor belongs in the same museum as automake!</div><br/></div></div><div id="39918823" class="c"><input type="checkbox" id="c-39918823" checked=""/><div class="controls bullet"><span class="by">LunicLynx</span><span>|</span><a href="#39920660">prev</a><span>|</span><a href="#39909544">next</a><span>|</span><label class="collapse" for="c-39918823">[-]</label><label class="expand" for="c-39918823">[2 more]</label></div><br/><div class="children"><div class="content">Imagine this inside GitHub copilot, just because it has seen it enough times.</div><br/><div id="39924803" class="c"><input type="checkbox" id="c-39924803" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#39918823">parent</a><span>|</span><a href="#39909544">next</a><span>|</span><label class="collapse" for="c-39924803">[-]</label><label class="expand" for="c-39924803">[1 more]</label></div><br/><div class="children"><div class="content">This is why, in my opinion, if AI will bring exponentially more efficiency, it will also bring an exponential increase in security issues.<p>The most common vulnerabilities are due to how input is handled (or not). XSS vulns, SQL injections, other injections, etc.<p>Now, the AI agent itself also produces untrusted input. But it does so, in a way, as an extension of the user using it who is actually a trusted entity. Because of this, it is solely up to the user to validate everything coming out of the AI but most users will not do that thoroughly.<p>What you mention in your comment is a good example of that. If the AI reproduces malicious code e.g. inspired from this campaign, it is essentially an injection attack where the user misses it and didn&#x27;t properly validate the untrusted input.</div><br/></div></div></div></div><div id="39915351" class="c"><input type="checkbox" id="c-39915351" checked=""/><div class="controls bullet"><span class="by">say_it_as_it_is</span><span>|</span><a href="#39909544">prev</a><span>|</span><a href="#39911799">next</a><span>|</span><label class="collapse" for="c-39915351">[-]</label><label class="expand" for="c-39915351">[1 more]</label></div><br/><div class="children"><div class="content">Imagine paying for a security scanning service such as Snyk and finding that it never scanned source code for injection attacks.  How many millions of dollars went down the drain?</div><br/></div></div><div id="39911799" class="c"><input type="checkbox" id="c-39911799" checked=""/><div class="controls bullet"><span class="by">cletus</span><span>|</span><a href="#39915351">prev</a><span>|</span><a href="#39908170">next</a><span>|</span><label class="collapse" for="c-39911799">[-]</label><label class="expand" for="c-39911799">[17 more]</label></div><br/><div class="children"><div class="content">My big takeaway is that modern build systems are fundamentally broken. Autotools, even Makefiles, are (or can be) incredibly obtuse, even unreadable. If I read this attack correctly, it relied on a payload in a test file (to obfuscate it). It shouldn&#x27;t be possible to include test resources in a production build.<p>As an aside, C&#x2F;C++&#x27;s header system with conditional inclusion is also fundamentally broken. Even templates are just text substitution with a thin veneer of typing.<p>I think about Google&#x27;s build system, which is very much designed to avoid this kind of thing. The internal build tool is Blaze (Bazel is the open-source cousin). Many years ago, you could essentially write scripts in your BUILD files (called genrules) that were hugely problematic. There was no way to guarantee the output so they had to be constantly rebuilt. There was a long project to eliminate this kind of edge case.<p>Blaze (and Bazel) are built around declaring hermetic units to be built with explicit dependencies only. Nothing shipped to production is built locally. It&#x27;s all built by the build servers (a system called Forge). These outputs are packaged into Midas packages (&quot;MPMs&quot;). You could absolutely reconstruct the source used to build a particular library, binary or package as well as the build toolchain and version used. And any build is completely deterministic and verifiable.<p>C&#x2F;C++, Make, CMake, autotools, autoconf and all that tooling so common in Linux and its core dependencies absolutely needs to go.</div><br/><div id="39913314" class="c"><input type="checkbox" id="c-39913314" checked=""/><div class="controls bullet"><span class="by">ufmace</span><span>|</span><a href="#39911799">parent</a><span>|</span><a href="#39912121">next</a><span>|</span><label class="collapse" for="c-39913314">[-]</label><label class="expand" for="c-39913314">[5 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not wrong, but IMO that isn&#x27;t the real problem. The real problem is the combination of highly popular core open-source utilities with near-zero maintenance resources.<p>This was all possible because XZ, despite being effectively everywhere, has one actual part-time maintainer who had other things going on in his life. That also means that there&#x27;s nowhere near enough resources to redo the build system to some more secure alternative. If they had, say, 10 enthusiastic and skilled volunteer contributors with plenty of free time, they could do that, but then a new person appearing out of nowhere with a few helpful commits would never have a chance at being made an official maintainer or sneaking sketchy tools and code past the other maintainers.<p>Not that I&#x27;m blaming XZ or the real maintainer. Clearly whoever was behind this was looking for the weakest link, and if it wasn&#x27;t XZ, it would have been something else. The real problem is the culture.<p>So I guess what this really means is someone at a big corporation making Linux distros should audit their full dependency tree. Any tool in that tree that isn&#x27;t actively maintained, say at least 3 long-time active contributors, they should take over one way or another - whether that&#x27;s hiring the current maintainer as a full-time remote employee, offering to buy out the rights, or forking and running under their own team.<p>I&#x27;m not necessarily super thrilled with that, but I guess it&#x27;s the world we live in now.</div><br/><div id="39916442" class="c"><input type="checkbox" id="c-39916442" checked=""/><div class="controls bullet"><span class="by">pch00</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39913314">parent</a><span>|</span><a href="#39914216">next</a><span>|</span><label class="collapse" for="c-39916442">[-]</label><label class="expand" for="c-39916442">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So I guess what this really means is someone at a big corporation making Linux distros should audit their full dependency tree.<p>This is it precisely.  When you&#x27;re paying Redhat for an &quot;enterprise&quot; Linux then that guarantee should extend down their entire software stack.  Just getting the odd backported patch and so-so email support no longer cuts it.</div><br/></div></div><div id="39914216" class="c"><input type="checkbox" id="c-39914216" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39913314">parent</a><span>|</span><a href="#39916442">prev</a><span>|</span><a href="#39918335">next</a><span>|</span><label class="collapse" for="c-39914216">[-]</label><label class="expand" for="c-39914216">[1 more]</label></div><br/><div class="children"><div class="content">The overworked solo maintainer is a problem.<p>However I&#x27;ve seen way too many projects where individuals in the &#x27;team&#x27; are able to carve out impenetrable fiefdoms where they can operate with wide latitude.<p>I could see a Jia Tan being able to pull this off in a team context as well - bigger teams might even be weaker. (Everyone welcome Jia - he&#x27;s going to write test cases and optimize our build process so everyone can focus on $LAUNCH_DAY)</div><br/></div></div><div id="39918335" class="c"><input type="checkbox" id="c-39918335" checked=""/><div class="controls bullet"><span class="by">peteradio</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39913314">parent</a><span>|</span><a href="#39914216">prev</a><span>|</span><a href="#39912121">next</a><span>|</span><label class="collapse" for="c-39918335">[-]</label><label class="expand" for="c-39918335">[2 more]</label></div><br/><div class="children"><div class="content">Why do utilities need constant fucking updates?  Why do they need maintenance?  New features are entirely optional and if what you want to do isn&#x27;t supported aka xz java, uhh, get fucked or do it yourself.</div><br/><div id="39921648" class="c"><input type="checkbox" id="c-39921648" checked=""/><div class="controls bullet"><span class="by">Dunedan</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39918335">parent</a><span>|</span><a href="#39912121">next</a><span>|</span><label class="collapse" for="c-39921648">[-]</label><label class="expand" for="c-39921648">[1 more]</label></div><br/><div class="children"><div class="content">I believe software of a certain complexity can&#x27;t be finished and will always need updates, even if you exclude new features, as the whole eco system of hardware and software is constantly evolving around it. Here are a few reasons why:<p>- bug fixes (as every non-trivial software has bugs)<p>- improved security (as the kernel adds security functionality (capability dropping, sandboxing, ...), software can utilize this functionality to reduce its attack surface)<p>- improvements of existing features (e.g. utilizing new CPU extensions or new algorithms for improved performance)</div><br/></div></div></div></div></div></div><div id="39912121" class="c"><input type="checkbox" id="c-39912121" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#39911799">parent</a><span>|</span><a href="#39913314">prev</a><span>|</span><a href="#39912035">next</a><span>|</span><label class="collapse" for="c-39912121">[-]</label><label class="expand" for="c-39912121">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>modern build systems</i>
&gt; <i>Autotools, even Makefiles</i>
&gt; <i>C&#x2F;C++&#x27;s header system with conditional inclusion</i><p>Wouldn&#x27;t it be more accurate to say something like &quot;older build systems&quot;? I don&#x27;t think any of the things you listed are &quot;modern&quot;. Which isn&#x27;t a criticism of their legacy! They have been very useful for a long time, and that&#x27;s to be applauded. But they have <i>huge</i> problems, which is a big part of why newer systems have been created.<p>FWIW, I have been using pants[0] (v2) for a little under a year. We chose it after also evaluating it and bazel (but not nix, for better or worse). I think it&#x27;s really really great! Also painful in some ways (as is inevitably the case with any software). And of course it&#x27;s nearly impossible to <i>entirely</i> stomp out &quot;genrules&quot; use cases. But it&#x27;s much easier to get much closer to true hermeticity, and I&#x27;m a big fan of that.<p>0: <a href="https:&#x2F;&#x2F;www.pantsbuild.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.pantsbuild.org&#x2F;</a></div><br/><div id="39912628" class="c"><input type="checkbox" id="c-39912628" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39912121">parent</a><span>|</span><a href="#39912035">next</a><span>|</span><label class="collapse" for="c-39912628">[-]</label><label class="expand" for="c-39912628">[1 more]</label></div><br/><div class="children"><div class="content">To be clear about the history: Make is from 1976, and Autotools is from 1991. Had me a chuckle about these being called modern, they&#x27;re (some of?) the earliest build systems.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Make_(software)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Make_(software)</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Autoconf" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Autoconf</a></div><br/></div></div></div></div><div id="39912035" class="c"><input type="checkbox" id="c-39912035" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#39911799">parent</a><span>|</span><a href="#39912121">prev</a><span>|</span><a href="#39912198">next</a><span>|</span><label class="collapse" for="c-39912035">[-]</label><label class="expand" for="c-39912035">[3 more]</label></div><br/><div class="children"><div class="content">If I were starting something from scratch I&#x27;d do Bazel for internal deps, Nix for external ones.  If that&#x27;s a tall order, so be it: we train people. Investments in determinism usually end up paying off.</div><br/><div id="39912153" class="c"><input type="checkbox" id="c-39912153" checked=""/><div class="controls bullet"><span class="by">threePointFive</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39912035">parent</a><span>|</span><a href="#39912174">next</a><span>|</span><label class="collapse" for="c-39912153">[-]</label><label class="expand" for="c-39912153">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with Bazel, but Nix in it&#x27;s current form wouldn&#x27;t have solved this attack. First of all, the standard mkDerivation function calls the same configure; make; make install process that made this attack possible. Nixpkgs regularly pulls in external resources (fetchUrl and friends) that are equally vulnerable to a poisoned release tarball. Checkout the comment on the current xz entry in nixpkgs <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;tools&#x2F;compression&#x2F;xz&#x2F;default.nix">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;tools&#x2F;comp...</a></div><br/></div></div><div id="39912174" class="c"><input type="checkbox" id="c-39912174" checked=""/><div class="controls bullet"><span class="by">wocram</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39912035">parent</a><span>|</span><a href="#39912153">prev</a><span>|</span><a href="#39912198">next</a><span>|</span><label class="collapse" for="c-39912174">[-]</label><label class="expand" for="c-39912174">[1 more]</label></div><br/><div class="children"><div class="content">This sounds nice on paper, but there&#x27;s a lot of missing glue to be written between nix and bazel.<p>Ideally nix would move towards less imperative&#x2F;genrule style package declarations and ultimately become more usable for internal builds.</div><br/></div></div></div></div><div id="39912198" class="c"><input type="checkbox" id="c-39912198" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#39911799">parent</a><span>|</span><a href="#39912035">prev</a><span>|</span><a href="#39912833">next</a><span>|</span><label class="collapse" for="c-39912198">[-]</label><label class="expand" for="c-39912198">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The internal build tool is Blaze (Bazel is the open-source cousin).<p>I was under the impression that Blaze is Google&#x27;s Bazel deployment, i.e. that they&#x27;re the same code. Is that not correct?</div><br/><div id="39912462" class="c"><input type="checkbox" id="c-39912462" checked=""/><div class="controls bullet"><span class="by">xen0</span><span>|</span><a href="#39911799">root</a><span>|</span><a href="#39912198">parent</a><span>|</span><a href="#39912833">next</a><span>|</span><label class="collapse" for="c-39912462">[-]</label><label class="expand" for="c-39912462">[1 more]</label></div><br/><div class="children"><div class="content">Mostly correct; there&#x27;s some code that&#x27;s Blaze only and some that&#x27;s Bazel only, but the core is the same.</div><br/></div></div></div></div><div id="39912833" class="c"><input type="checkbox" id="c-39912833" checked=""/><div class="controls bullet"><span class="by">dhx</span><span>|</span><a href="#39911799">parent</a><span>|</span><a href="#39912198">prev</a><span>|</span><a href="#39918309">next</a><span>|</span><label class="collapse" for="c-39912833">[-]</label><label class="expand" for="c-39912833">[1 more]</label></div><br/><div class="children"><div class="content">Ugly and broken build systems are most of the reason why Gentoo&#x27;s &#x27;sandbox&#x27; feature and equivalent for other distributions exists.[1] These sandboxing features have mostly been used in the past to prevent an ugly shell script in the build process for libuselesscruft from doing something similar to &quot;rm -rf&quot; on the build system. More recently these sandboxing features are helpful in encouraging reproducible builds by alerting maintainers to build processes which try and obtain non-deterministic information from the operating system environment such as the operating system name and version, host name and current time stamp.<p>There are a few gaps I think xz-utils highlights:<p>- Repositories containing a mixture of source code, build scripts, test frameworks, static resources and documentation generation scripts are all considered to be a single security domain with no isolation between them. If you look to Gentoo&#x27;s src_prepare function as an example, we perhaps should instead split this into build_src_prepare, doc_src_prepare, test_src_prepare and install_src_prepare instead. If source code is being built and binaries generated, the sandboxed build directory should perhaps not contain test files and documentation generation scripts. If the package is being installed with &quot;make install&quot; (or equivalent) then static resources (such as a timezone database) should be available to copy to &#x2F;usr&#x2F;, but build scripts used to generate the binaries or documentation do not need to be available to &quot;make install&quot; (or equivalent).<p>- Sandboxing used for package building hasn&#x27;t traditionally been implemented for security reasons in the past. Sandboxing should perhaps be hardened further with modern and more complex approaches such as seccomp to further protect build systems from the likes of libbackdoored that are targeted towards package maintainers&#x2F;Linux distribution build systems. As a further example to seccomp, Gentoo&#x27;s &#x27;sandbox&#x27; has Linux namespace isolation built in, but not yet enabled whilst it is tested.<p>- There is a lack of automated package management tools (including dashboards &#x2F; automatic bug creation) for comparing source trees in Git to released tarballs and making discrepancies more visible and easier for maintainers to review.<p>- There is a lack of automatic package management tools (including dashboards &#x2F; automatic bug creation) for detecting binary and high entropy files in source trees and confirming they are validly formatted (e.g. invalid tag in a TLV file format) and confirming that test and example files contain nothing-up-my-sleeve content.<p>There has already been an accelerated move in recent years towards modern and safer build systems (such as meson and cargo) as 80&#x27;s&#x2F;90&#x27;s C libraries get ripped out and replaced with modern Rust libraries, or other safer options. This is a lot of work that will take many years though, and many old 80&#x27;s&#x2F;90&#x27;s C libraries and build systems will be needed for many more years to come. And for this reason, sandboxing&#x2F;isolation&#x2F;safety of old build systems seemingly needs to be improved as a priority, noting that old build systems will take years or decades to replace.<p>[1] <a href="https:&#x2F;&#x2F;devmanual.gentoo.org&#x2F;general-concepts&#x2F;sandbox&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;devmanual.gentoo.org&#x2F;general-concepts&#x2F;sandbox&#x2F;index....</a><p>[2] <a href="https:&#x2F;&#x2F;devmanual.gentoo.org&#x2F;ebuild-writing&#x2F;functions&#x2F;src_prepare&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;devmanual.gentoo.org&#x2F;ebuild-writing&#x2F;functions&#x2F;src_pr...</a></div><br/></div></div><div id="39918309" class="c"><input type="checkbox" id="c-39918309" checked=""/><div class="controls bullet"><span class="by">peteradio</span><span>|</span><a href="#39911799">parent</a><span>|</span><a href="#39912833">prev</a><span>|</span><a href="#39917293">next</a><span>|</span><label class="collapse" for="c-39918309">[-]</label><label class="expand" for="c-39918309">[1 more]</label></div><br/><div class="children"><div class="content">Google gets to decide what platform they want to support for their backend.  I wonder what their build code would look like if they tried to support the top-10 common OS from the last 30 years.</div><br/></div></div><div id="39917293" class="c"><input type="checkbox" id="c-39917293" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#39911799">parent</a><span>|</span><a href="#39918309">prev</a><span>|</span><a href="#39912606">next</a><span>|</span><label class="collapse" for="c-39917293">[-]</label><label class="expand" for="c-39917293">[1 more]</label></div><br/><div class="children"><div class="content">Makefiles are not a Linux thing, but Unix.<p>And if you confuse C with C++ and Make with CMake&#x2F;Autotools&#x2F;Autoconf, you have a lot to learn.
Look: simple and portable makefiles work:<p>git:&#x2F;&#x2F;bitreich.org&#x2F;english_knight</div><br/></div></div></div></div><div id="39908170" class="c"><input type="checkbox" id="c-39908170" checked=""/><div class="controls bullet"><span class="by">benlivengood</span><span>|</span><a href="#39911799">prev</a><span>|</span><a href="#39911997">next</a><span>|</span><label class="collapse" for="c-39908170">[-]</label><label class="expand" for="c-39908170">[24 more]</label></div><br/><div class="children"><div class="content">The only upside of finding this attack (aside from preventing it from being rolled out more widely) is that it gives a public example of a complex APT supply-chain attack.  Rest assured there are more out there, and the patterns used will probably be repeated elsewhere and easier to spot.<p>Obfuscated autoconf changes, multi-stage deployment, binary blobs (hello lib&#x2F;firmware and friends, various other encoders&#x2F;decoders, boot logos, etc), repo ownership changes, new-ish prolific committers in understaffed dependency libraries, magic values introduced without explanation.</div><br/><div id="39909751" class="c"><input type="checkbox" id="c-39909751" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#39908170">parent</a><span>|</span><a href="#39909289">next</a><span>|</span><label class="collapse" for="c-39909751">[-]</label><label class="expand" for="c-39909751">[6 more]</label></div><br/><div class="children"><div class="content">Add to that list suppression of warnings from valgrind and address sanitizer without any justification. And no tracking issue to follow up on fixing the problem so the suppression can be removed.<p>Committing binary files to source control rather than including build commands to generate the files is a bit of a red flag.</div><br/><div id="39915070" class="c"><input type="checkbox" id="c-39915070" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39909751">parent</a><span>|</span><a href="#39909289">next</a><span>|</span><label class="collapse" for="c-39915070">[-]</label><label class="expand" for="c-39915070">[5 more]</label></div><br/><div class="children"><div class="content">They&#x27;re test cases for a compression library. Seems pretty reasonable.</div><br/><div id="39915986" class="c"><input type="checkbox" id="c-39915986" checked=""/><div class="controls bullet"><span class="by">hyperhopper</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39915070">parent</a><span>|</span><a href="#39909289">next</a><span>|</span><label class="collapse" for="c-39915986">[-]</label><label class="expand" for="c-39915986">[4 more]</label></div><br/><div class="children"><div class="content">Not at all. This would not pass a good code review. The test was for good stream, bad stream, good stream. The two good streams were only a few bites, why was the bad stream so large?<p>A good reviewer should have, even for a binary test case, asked the submitter to simplify it to the smallest or most basic binary required for the functionality.</div><br/><div id="39921697" class="c"><input type="checkbox" id="c-39921697" checked=""/><div class="controls bullet"><span class="by">Dunedan</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39915986">parent</a><span>|</span><a href="#39917317">next</a><span>|</span><label class="collapse" for="c-39921697">[-]</label><label class="expand" for="c-39921697">[1 more]</label></div><br/><div class="children"><div class="content">Adding a script to regenerate good and bad binary files might have worked for this use case pretty well too.</div><br/></div></div><div id="39917317" class="c"><input type="checkbox" id="c-39917317" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39915986">parent</a><span>|</span><a href="#39921697">prev</a><span>|</span><a href="#39909289">next</a><span>|</span><label class="collapse" for="c-39917317">[-]</label><label class="expand" for="c-39917317">[2 more]</label></div><br/><div class="children"><div class="content">idk picking a real-world example that breaks the code seems like a good test case to me</div><br/><div id="39921981" class="c"><input type="checkbox" id="c-39921981" checked=""/><div class="controls bullet"><span class="by">benlivengood</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39917317">parent</a><span>|</span><a href="#39909289">next</a><span>|</span><label class="collapse" for="c-39921981">[-]</label><label class="expand" for="c-39921981">[1 more]</label></div><br/><div class="children"><div class="content">It is a good example for an initial bug report but, once the code has been fixed to handle that failure case, minimal examples are the correct lasting tests to live with the code forever.<p>Additionally, a complex example may require multiple conditions to fail and if those aren&#x27;t split into multiple tests then subtle bugs can be reintroduced later because that complex test doesn&#x27;t cover all potential failure conditions.  If there need to be test cases for multiple related bugs then they need to be minimal to demonstrate the failure condition combinations they are testing for.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39909289" class="c"><input type="checkbox" id="c-39909289" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#39908170">parent</a><span>|</span><a href="#39909751">prev</a><span>|</span><a href="#39908542">next</a><span>|</span><label class="collapse" for="c-39909289">[-]</label><label class="expand" for="c-39909289">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The changes to build-to-host.m4 weren&#x27;t in the source repo, so there was no commit.
&gt; 
&gt; The attacker had permissions to create GitHub releases, so they simply added it to the GitHub release tarball.<p>What are some simple tweaks the &quot;Debians&quot; of the world can do to mitigate this kind of stuff?<p>Not trust &quot;hand-curated-by-possibly-malicious-maintainers&quot; GitHub release tarballs, only trust git commits?<p>Whitelist functions that are allowed to do IFUNC&#x2F;ELF hooking to core OpenSSH functions?</div><br/><div id="39912143" class="c"><input type="checkbox" id="c-39912143" checked=""/><div class="controls bullet"><span class="by">ilc</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39909289">parent</a><span>|</span><a href="#39912412">next</a><span>|</span><label class="collapse" for="c-39912143">[-]</label><label class="expand" for="c-39912143">[1 more]</label></div><br/><div class="children"><div class="content">Read IOCCC entries.<p>Now realize, those are people having FUN.  What is your chance of catching nation state level maliciousness in a codebase?  Pretty low.</div><br/></div></div><div id="39912412" class="c"><input type="checkbox" id="c-39912412" checked=""/><div class="controls bullet"><span class="by">heeen2</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39909289">parent</a><span>|</span><a href="#39912143">prev</a><span>|</span><a href="#39908542">next</a><span>|</span><label class="collapse" for="c-39912412">[-]</label><label class="expand" for="c-39912412">[5 more]</label></div><br/><div class="children"><div class="content">remove test blobs before building</div><br/><div id="39913649" class="c"><input type="checkbox" id="c-39913649" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39912412">parent</a><span>|</span><a href="#39908542">next</a><span>|</span><label class="collapse" for="c-39913649">[-]</label><label class="expand" for="c-39913649">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a test binary? Bunch of bytes on disk. What&#x27;s a source file? Bunch of bytes on disk.</div><br/><div id="39925390" class="c"><input type="checkbox" id="c-39925390" checked=""/><div class="controls bullet"><span class="by">heeen2</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39913649">parent</a><span>|</span><a href="#39915005">next</a><span>|</span><label class="collapse" for="c-39925390">[-]</label><label class="expand" for="c-39925390">[1 more]</label></div><br/><div class="children"><div class="content">binary files can be distinguished from text files with good enough confidence.<p>folders containing test files could easily be removed before build just by name or should live in a  separate repository altogether.</div><br/></div></div><div id="39915005" class="c"><input type="checkbox" id="c-39915005" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39913649">parent</a><span>|</span><a href="#39925390">prev</a><span>|</span><a href="#39908542">next</a><span>|</span><label class="collapse" for="c-39915005">[-]</label><label class="expand" for="c-39915005">[2 more]</label></div><br/><div class="children"><div class="content">Good people and bad people are all made of atoms so there&#x27;s no difference.</div><br/><div id="39921106" class="c"><input type="checkbox" id="c-39921106" checked=""/><div class="controls bullet"><span class="by">evilos</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39915005">parent</a><span>|</span><a href="#39908542">next</a><span>|</span><label class="collapse" for="c-39921106">[-]</label><label class="expand" for="c-39921106">[1 more]</label></div><br/><div class="children"><div class="content">I think the point is that you can&#x27;t tell a good person from a bad one by inspecting the atoms.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39908542" class="c"><input type="checkbox" id="c-39908542" checked=""/><div class="controls bullet"><span class="by">cassianoleal</span><span>|</span><a href="#39908170">parent</a><span>|</span><a href="#39909289">prev</a><span>|</span><a href="#39915087">next</a><span>|</span><label class="collapse" for="c-39908542">[-]</label><label class="expand" for="c-39908542">[8 more]</label></div><br/><div class="children"><div class="content">&gt; a complex APT supply-chain attack<p>What do you mean by APT? If you mean Debian&#x27;s package manager, that&#x27;s not what this attack was. This was done upstream and affected non-apt distros just as much.<p>It&#x27;s true that upstream is part of apt&#x27;s supply chain but focussing on apt is misleading.<p>edit: why the downvotes? I get from the responses that I was wrong but given how the exploit was initially found in a Debian system and a lot of people very quickly jumped on the “Debian patched a thing and broke security” bandwagon, I don’t think it was much of a leap to wonder if that’s what was meant.<p>Acronyms and initialisms are not the best way to convey specific information.</div><br/><div id="39908571" class="c"><input type="checkbox" id="c-39908571" checked=""/><div class="controls bullet"><span class="by">haimez</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39908542">parent</a><span>|</span><a href="#39908572">next</a><span>|</span><label class="collapse" for="c-39908571">[-]</label><label class="expand" for="c-39908571">[1 more]</label></div><br/><div class="children"><div class="content">It stands for “Advanced Persistent Threat” - <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Advanced_persistent_threat" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Advanced_persistent_threat</a></div><br/></div></div><div id="39908572" class="c"><input type="checkbox" id="c-39908572" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39908542">parent</a><span>|</span><a href="#39908571">prev</a><span>|</span><a href="#39908563">next</a><span>|</span><label class="collapse" for="c-39908572">[-]</label><label class="expand" for="c-39908572">[1 more]</label></div><br/><div class="children"><div class="content">I think Advanced Persistent Threat.</div><br/></div></div><div id="39908563" class="c"><input type="checkbox" id="c-39908563" checked=""/><div class="controls bullet"><span class="by">mttpgn</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39908542">parent</a><span>|</span><a href="#39908572">prev</a><span>|</span><a href="#39908585">next</a><span>|</span><label class="collapse" for="c-39908563">[-]</label><label class="expand" for="c-39908563">[1 more]</label></div><br/><div class="children"><div class="content">Not apt the package manager-- it&#x27;s an acronym for Advanced Persistent Threat</div><br/></div></div><div id="39908566" class="c"><input type="checkbox" id="c-39908566" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39908542">parent</a><span>|</span><a href="#39908585">prev</a><span>|</span><a href="#39910832">next</a><span>|</span><label class="collapse" for="c-39908566">[-]</label><label class="expand" for="c-39908566">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What do you mean by APT<p>Advanced, persistent threat.</div><br/></div></div><div id="39910832" class="c"><input type="checkbox" id="c-39910832" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39908542">parent</a><span>|</span><a href="#39908566">prev</a><span>|</span><a href="#39910876">next</a><span>|</span><label class="collapse" for="c-39910832">[-]</label><label class="expand" for="c-39910832">[1 more]</label></div><br/><div class="children"><div class="content">Others have answered your question about APT but FWIW I don&#x27;t understand the downvotes. You were respectful and simply sought to clear up a misunderstanding.</div><br/></div></div><div id="39910876" class="c"><input type="checkbox" id="c-39910876" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#39908170">root</a><span>|</span><a href="#39908542">parent</a><span>|</span><a href="#39910832">prev</a><span>|</span><a href="#39915087">next</a><span>|</span><label class="collapse" for="c-39910876">[-]</label><label class="expand" for="c-39910876">[1 more]</label></div><br/><div class="children"><div class="content">I was heavily downvoted for supplying a link to a previous discussion on the same topic recently. I wouldn’t worry much about it.</div><br/></div></div></div></div><div id="39915087" class="c"><input type="checkbox" id="c-39915087" checked=""/><div class="controls bullet"><span class="by">fsflover</span><span>|</span><a href="#39908170">parent</a><span>|</span><a href="#39908542">prev</a><span>|</span><a href="#39910472">next</a><span>|</span><label class="collapse" for="c-39915087">[-]</label><label class="expand" for="c-39915087">[1 more]</label></div><br/><div class="children"><div class="content">&gt; hello lib&#x2F;firmware<p>How could it play any role here? It doesn&#x27;t bring any dependencies, does it?</div><br/></div></div></div></div></div></div></div></div></div></body></html>