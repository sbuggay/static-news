<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725613277131" as="style"/><link rel="stylesheet" href="styles.css?v=1725613277131"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Scthe/nanite-webgpu">UE5 Nanite in WebGPU</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>vouwfietsman</span> | <span>100 comments</span></div><br/><div><div id="41459509" class="c"><input type="checkbox" id="c-41459509" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41460618">next</a><span>|</span><label class="collapse" for="c-41459509">[-]</label><label class="expand" for="c-41459509">[18 more]</label></div><br/><div class="children"><div class="content">Oh, nice. Third party implementations of Nanite playback.<p>Nanite is a very clever representation of graphics meshes. They&#x27;re directed acyclic graphs rather than trees. Repetition is a link, not a copy. It&#x27;s recursive; meshes can share submeshes, which in turn can share submeshes, all the way down. It&#x27;s also set up for within-mesh level of detail support, so the submeshes drop out when they&#x27;re small enough. 
So you can have repetitive content of very large size with a finite amount of data and fast rendering times. The insight is that there are only so many pixels on screen, so there&#x27;s an upper bound on rendering work really needed.<p>There&#x27;s a really good SIGGRAPH video on this from someone at Epic.<p>Current GPU designs are a mismatch for Nanite, Some new hardware operations are needed to do more of this in the GPU, where it belongs. Whether that will happen, with NVidia distracted by the AI market, is a good question.<p>The scene needs a lot of instancing for this to pay off. Unreal Engine demos show such things as a hall of identical statues. If each statue was different, Nanite would help far less. So it works best for projects where a limited number of objects are reused to create large areas of content. That&#x27;s the case for most AAA titles. Watch a video of Cyberpunk 2077, and look for railings and trash heaps. You&#x27;ll see the same ones over and over in totally different contexts.<p>Making a nanite mesh is complicated, with a lot of internal offsets for linking, and so far only Unreal Engine&#x27;s editor does it. With playback now open source, someone will probably do that.<p>Those internal offsets in the format present an attack surface which probably can be exploited with carefully crafted bad content, like hostile Microsoft Word .doc files.</div><br/><div id="41459686" class="c"><input type="checkbox" id="c-41459686" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41459642">next</a><span>|</span><label class="collapse" for="c-41459686">[-]</label><label class="expand" for="c-41459686">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Repetition is a link, not a copy. It&#x27;s recursive; meshes can share submeshes, which in turn can share submeshes, all the way down.<p>While it does construct a DAG to perform the graph cut, the final data set on disk is just a flat list of clusters for consideration, along with their cutoffs for inclusion&#x2F;rejection. There seems to be a considerable misunderstanding of what the DAG is used for, and how it&#x27;s constructed. It&#x27;s constructed dynamically based on the vertex data, and doesn&#x27;t have anything to do with how the artist constructed submeshes and things, nor does &quot;repetition become a link&quot;.<p>&gt; The scene needs a lot of instancing for this to pay off. Unreal Engine demos show such things as a hall of identical statues. If each statue was different, Nanite would help far less.<p>What makes you say this? The graph cut is <i>different</i> for each instance of the object, so they can&#x27;t use traditional instancing, and I don&#x27;t even see how it could help.</div><br/><div id="41459759" class="c"><input type="checkbox" id="c-41459759" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41459509">root</a><span>|</span><a href="#41459686">parent</a><span>|</span><a href="#41459642">next</a><span>|</span><label class="collapse" for="c-41459759">[-]</label><label class="expand" for="c-41459759">[5 more]</label></div><br/><div class="children"><div class="content">It may not be based on what the mesh&#x27;s creator considered repetition, but repetition is encoded within the mesh. Not sure if the mesh builder discovers some of the repetition itself.<p>Look at a terrain example:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=DKvA7NZRUcg" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=DKvA7NZRUcg</a></div><br/><div id="41459947" class="c"><input type="checkbox" id="c-41459947" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#41459509">root</a><span>|</span><a href="#41459759">parent</a><span>|</span><a href="#41459642">next</a><span>|</span><label class="collapse" for="c-41459947">[-]</label><label class="expand" for="c-41459947">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not seeing what you claim to be seeing in that demo video. I see a per-triangle debug view, and a per-cluster debug view. None of that is showing repetition.</div><br/><div id="41460278" class="c"><input type="checkbox" id="c-41460278" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41459509">root</a><span>|</span><a href="#41459947">parent</a><span>|</span><a href="#41459642">next</a><span>|</span><label class="collapse" for="c-41460278">[-]</label><label class="expand" for="c-41460278">[3 more]</label></div><br/><div class="children"><div class="content">If there wasn&#x27;t repetition, you&#x27;d need a really huge GPU for that scene at that level of detail.</div><br/><div id="41460567" class="c"><input type="checkbox" id="c-41460567" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#41459509">root</a><span>|</span><a href="#41460278">parent</a><span>|</span><a href="#41460545">next</a><span>|</span><label class="collapse" for="c-41460567">[-]</label><label class="expand" for="c-41460567">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. Nanite compresses meshes (including in-memory) _very_ heavily, and _also_ streams in only the visible mesh data.<p>In general, I wouldn&#x27;t think of Nanite as &quot;one thing&quot;. It&#x27;s a combination of many, many different techniques that add up into some really good technology.</div><br/></div></div><div id="41460545" class="c"><input type="checkbox" id="c-41460545" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#41459509">root</a><span>|</span><a href="#41460278">parent</a><span>|</span><a href="#41460567">prev</a><span>|</span><a href="#41459642">next</a><span>|</span><label class="collapse" for="c-41460545">[-]</label><label class="expand" for="c-41460545">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to estimate storage space right now, but meshes can be stored very efficiently. For example, I think UE uses an optimization where vertex positions are heavily quantized to just a few bits within the meshlet&#x27;s bounding box. Index buffers can be constructed to share the same vertices across LOD levels. Shading normals can be quantized quite a bit before shading artifacts become noticeable - if you even need them anymore at that triangle density.<p>If your triangles are at or below the size of a texel, texture values could even be looked up offline and stored in the vertex attributes directly rather than keeping the UV coordinates around, but that may not be a win.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41459642" class="c"><input type="checkbox" id="c-41459642" checked=""/><div class="controls bullet"><span class="by">turtledragonfly</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41459686">prev</a><span>|</span><a href="#41459860">next</a><span>|</span><label class="collapse" for="c-41459642">[-]</label><label class="expand" for="c-41459642">[1 more]</label></div><br/><div class="children"><div class="content">I think the SIGGRAPH talk you referred to is: &quot;A Deep Dive into Nanite Virtualized Geometry&quot;  (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eviSykqSUUw" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eviSykqSUUw</a>)<p>There&#x27;s also this short high-level intro (2.5 min) that I thought was decent: &quot;What is virtualized micropolygon geometry? An explainer on Nanite&quot; (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-50MJf7hyOw" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-50MJf7hyOw</a>)</div><br/></div></div><div id="41459860" class="c"><input type="checkbox" id="c-41459860" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41459642">prev</a><span>|</span><a href="#41461491">next</a><span>|</span><label class="collapse" for="c-41459860">[-]</label><label class="expand" for="c-41459860">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and so far only Unreal Engine&#x27;s editor does it<p>Not a major&#x2F;mainstream engine by any means (a small Rust ECS game engine) but Bevy also supports something similar under the feature name &quot;Virtual Geometry&quot;, mentioned here: <a href="https:&#x2F;&#x2F;bevyengine.org&#x2F;news&#x2F;bevy-0-14&#x2F;#virtual-geometry-experimental" rel="nofollow">https:&#x2F;&#x2F;bevyengine.org&#x2F;news&#x2F;bevy-0-14&#x2F;#virtual-geometry-expe...</a><p>Also, a technical deep dive into the feature from one of the authors of the feature: <a href="https:&#x2F;&#x2F;jms55.github.io&#x2F;posts&#x2F;2024-06-09-virtual-geometry-bevy-0-14&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jms55.github.io&#x2F;posts&#x2F;2024-06-09-virtual-geometry-be...</a></div><br/></div></div><div id="41461491" class="c"><input type="checkbox" id="c-41461491" checked=""/><div class="controls bullet"><span class="by">DaoVeles</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41459860">prev</a><span>|</span><a href="#41460427">next</a><span>|</span><label class="collapse" for="c-41461491">[-]</label><label class="expand" for="c-41461491">[2 more]</label></div><br/><div class="children"><div class="content">In a past life (2000&#x27;s) I was doing some dev stuff on Ps3, trying to figure out so decent uses for Cell&#x27;s mass of compute and working around RSX&#x27;s limited memory bandwidth while having the luxury of Blu-ray storage to burn through.<p>One such thing I did get a fair way into was something like Nanite - I called it compressive meshing. It is the typical case of misguided engineering hubris at work.<p>The initial work looked promising but the further into the problem I get the more complicated the entire thing become. Having to construct the entire asset generation pipeline was just way beyond what I could manage in the time frame that would look anything decent and not blow out the memory required.<p>I did manage to get something that vague resembled large scale meshes being rendered in a staggered level of detail but it ran SLOW and looked like rubbish unless you hammered the GPU to get sub-pixel accuracy. It was a fun experiment but it was far too much for the hardware and too big of a task to take on as a single programmer.<p>When Epic showed off Nantine... wow they did what I never could in a fashion way beyond even my best vision! It is one of those technologies that when it came along really was a true solution rather than just hype. Yes there are limits as with anything on that scale but it is one of the technical jewels of the modern graphics world. I have said that if Epic was public traded company I would considered putting in a sizable amount of money just based on Nanite tech alone.</div><br/><div id="41462861" class="c"><input type="checkbox" id="c-41462861" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#41459509">root</a><span>|</span><a href="#41461491">parent</a><span>|</span><a href="#41460427">next</a><span>|</span><label class="collapse" for="c-41462861">[-]</label><label class="expand" for="c-41462861">[1 more]</label></div><br/><div class="children"><div class="content">Keep in mind, it took Epic a long time to get it sorted. I think I saw the primary creator say it took him a decade of research and work to come to the initial implementation of Nanite that shipped in Unreal.</div><br/></div></div></div></div><div id="41460427" class="c"><input type="checkbox" id="c-41460427" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41461491">prev</a><span>|</span><a href="#41460171">next</a><span>|</span><label class="collapse" for="c-41460427">[-]</label><label class="expand" for="c-41460427">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Making a nanite mesh is complicated, with a lot of internal offsets for linking, and so far only Unreal Engine&#x27;s editor does it.<p>meshoptimizer [1] is an OSS implementation of meshlet generation, which is what most people think of when they think of &quot;Nanite&#x27;s algorithm&quot;. Bevy, mentioned in a sibling reply, uses meshoptimizer as the generation tool.<p>(Strictly speaking, &quot;Nanite&quot; is a brand name that encompasses a large collection of techniques, including meshlets, software rasterization, streaming geometry, etc. For clarity, when discussing these concepts outside of the context of the Unreal Engine specifically, I prefer to refer to individual techniques instead of the &quot;Nanite&quot; brand. They&#x27;re really separate, even though they complement one another. For example, software rasterization can be profitably used without meshlets if your triangles are really small. Streaming geometry can be useful even if you aren&#x27;t using meshlets. And so on.)<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;zeux&#x2F;meshoptimizer">https:&#x2F;&#x2F;github.com&#x2F;zeux&#x2F;meshoptimizer</a></div><br/><div id="41460580" class="c"><input type="checkbox" id="c-41460580" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#41459509">root</a><span>|</span><a href="#41460427">parent</a><span>|</span><a href="#41460171">next</a><span>|</span><label class="collapse" for="c-41460580">[-]</label><label class="expand" for="c-41460580">[1 more]</label></div><br/><div class="children"><div class="content">Small correction: meshoptimizer only does the grouping triangles -&gt; meshlets part, and the mesh simplification. Actually building the DAG, grouping clusters together, etc is handled by Bevy code (I&#x27;m the author, happy to answer questions).<p>That said I do know zeux was interested in experimenting with Nanite-like DAGs directly in meshoptimizer, so maybe a future version of the library will have an end-to-end API.</div><br/></div></div></div></div><div id="41460171" class="c"><input type="checkbox" id="c-41460171" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41460427">prev</a><span>|</span><a href="#41462627">next</a><span>|</span><label class="collapse" for="c-41460171">[-]</label><label class="expand" for="c-41460171">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nanite playback<p>That&#x27;s not what this is though. It&#x27;s an implementation of the techniques&#x2F;technology used in Nanite. It doesn&#x27;t load data from Unreal Engine&#x27;s editor. One of the mentioned goals:<p><pre><code>   Simplicity. We start with an OBJ file and everything is done
   in the app. No magic pre-processing steps, Blender exports, etc.
   You set the breakpoint at loadObjFile() and F10 your way till
   the first frame finishes.</code></pre></div><br/></div></div><div id="41462627" class="c"><input type="checkbox" id="c-41462627" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41460171">prev</a><span>|</span><a href="#41461037">next</a><span>|</span><label class="collapse" for="c-41462627">[-]</label><label class="expand" for="c-41462627">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Current GPU designs are a mismatch for Nanite, Some new hardware operations are needed to do more of this in the GPU, where it belongs. Whether that will happen, with NVidia distracted by the AI market, is a good question.<p>Unreal 5 was only released in 2022, and we have been iterating the Nanite idea since then. With Unreal 5.5 and more AAA Gaming titles coming in and we can take what we learned and put into hardware. Not to mention the lead time is 3-4 years down the road. Even if Nvidia decided to make one in 2023 it would have been at least 2026 before we see any GPU acceleration.</div><br/></div></div><div id="41461037" class="c"><input type="checkbox" id="c-41461037" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41462627">prev</a><span>|</span><a href="#41460488">next</a><span>|</span><label class="collapse" for="c-41461037">[-]</label><label class="expand" for="c-41461037">[1 more]</label></div><br/><div class="children"><div class="content">This is like when Joel said git stores diffs.</div><br/></div></div><div id="41460488" class="c"><input type="checkbox" id="c-41460488" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41459509">parent</a><span>|</span><a href="#41461037">prev</a><span>|</span><a href="#41460618">next</a><span>|</span><label class="collapse" for="c-41460488">[-]</label><label class="expand" for="c-41460488">[1 more]</label></div><br/><div class="children"><div class="content">I read through the papers and my impression was that the biggest gains were from quantised coordinates and dynamic LOD for small patches instead of the entire mesh.<p>The logic behind nanite as I understood it was to keep the mesh accuracy at roughly 1 pixel precision. So for example, a low detail mesh can be used with coordinates rounded to just 10 bits (or whatever) if the resulting error is only about half a pixel when perspective projected onto the screen.<p>I vaguely remember the quantisation pulling double duty: not only does it reduce the data storage size it also helps the LOD generation because it snaps vertices to the same locations in space. The duplicates can then be eliminated.</div><br/></div></div></div></div><div id="41460618" class="c"><input type="checkbox" id="c-41460618" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#41459509">prev</a><span>|</span><a href="#41459393">next</a><span>|</span><label class="collapse" for="c-41460618">[-]</label><label class="expand" for="c-41460618">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been mentioned a couple of times in this thread, but Bevy also has an implementation of Nanite&#x27;s ideas (sometimes called Virtual Geometry). I&#x27;m the author of that, happy to answer questions :)<p>As for this project, Scthe did a great job! I&#x27;ve been talking with them about several parts of the process, culminating in some improvements to Bevy&#x27;s code based on their experience (<a href="https:&#x2F;&#x2F;github.com&#x2F;bevyengine&#x2F;bevy&#x2F;pull&#x2F;15023">https:&#x2F;&#x2F;github.com&#x2F;bevyengine&#x2F;bevy&#x2F;pull&#x2F;15023</a>). Always happy to see more people working on this, Nanite has a ton of cool ideas.</div><br/></div></div><div id="41459393" class="c"><input type="checkbox" id="c-41459393" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#41460618">prev</a><span>|</span><a href="#41461987">next</a><span>|</span><label class="collapse" for="c-41459393">[-]</label><label class="expand" for="c-41459393">[11 more]</label></div><br/><div class="children"><div class="content">Is the demo using user agent strings to determine compatibility? That&#x27;s not good, and feature compatibility should be determined on a case-by-case basis by simply attempting to detect&#x2F;use the specific feature.<p>I am on Chromium, not Chrome, and use WebGPU all the time, but the demos tell me to use Chrome, which I cannot do ethically. Would love to try the demos out, this looks like a lot of hard work!</div><br/><div id="41459941" class="c"><input type="checkbox" id="c-41459941" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#41459393">parent</a><span>|</span><a href="#41459533">next</a><span>|</span><label class="collapse" for="c-41459941">[-]</label><label class="expand" for="c-41459941">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not working for me on Chrome under Linux, nor on Android, for what it&#x27;s worth (though Firefox is what I use for practically all my browsing needs).  Something really odd with their detection logic.</div><br/><div id="41460229" class="c"><input type="checkbox" id="c-41460229" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41459393">root</a><span>|</span><a href="#41459941">parent</a><span>|</span><a href="#41459533">next</a><span>|</span><label class="collapse" for="c-41460229">[-]</label><label class="expand" for="c-41460229">[3 more]</label></div><br/><div class="children"><div class="content">WebGPU is not supported on Linux, and it won&#x27;t for the foreseeable future.<p>On Android you should have at least Android 12, with good enough Vulkan drivers, not blacklisted.</div><br/><div id="41460538" class="c"><input type="checkbox" id="c-41460538" checked=""/><div class="controls bullet"><span class="by">sva_</span><span>|</span><a href="#41459393">root</a><span>|</span><a href="#41460229">parent</a><span>|</span><a href="#41459533">next</a><span>|</span><label class="collapse" for="c-41460538">[-]</label><label class="expand" for="c-41460538">[2 more]</label></div><br/><div class="children"><div class="content">&gt; WebGPU is not supported on Linux, and it won&#x27;t for the foreseeable future.<p>A lot of it runs fine with a flag.</div><br/><div id="41463379" class="c"><input type="checkbox" id="c-41463379" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41459393">root</a><span>|</span><a href="#41460538">parent</a><span>|</span><a href="#41459533">next</a><span>|</span><label class="collapse" for="c-41463379">[-]</label><label class="expand" for="c-41463379">[1 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t really something for production use.</div><br/></div></div></div></div></div></div></div></div><div id="41459533" class="c"><input type="checkbox" id="c-41459533" checked=""/><div class="controls bullet"><span class="by">robin_reala</span><span>|</span><a href="#41459393">parent</a><span>|</span><a href="#41459941">prev</a><span>|</span><a href="#41459551">next</a><span>|</span><label class="collapse" for="c-41459533">[-]</label><label class="expand" for="c-41459533">[1 more]</label></div><br/><div class="children"><div class="content">Don’t think so. I’m on a Firefox that has experimental WebGPU support enabled, and it fails with shader compilation errors rather than any message.</div><br/></div></div><div id="41459551" class="c"><input type="checkbox" id="c-41459551" checked=""/><div class="controls bullet"><span class="by">drusepth</span><span>|</span><a href="#41459393">parent</a><span>|</span><a href="#41459533">prev</a><span>|</span><a href="#41459815">next</a><span>|</span><label class="collapse" for="c-41459551">[-]</label><label class="expand" for="c-41459551">[1 more]</label></div><br/><div class="children"><div class="content">If this is the case, I imagine it&#x27;d be pretty easy to spoof your UA and see the demo, even from Chromium.</div><br/></div></div><div id="41459815" class="c"><input type="checkbox" id="c-41459815" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41459393">parent</a><span>|</span><a href="#41459551">prev</a><span>|</span><a href="#41460097">next</a><span>|</span><label class="collapse" for="c-41459815">[-]</label><label class="expand" for="c-41459815">[3 more]</label></div><br/><div class="children"><div class="content">&gt; and use WebGPU all the time<p>I&#x27;m curious, what for?</div><br/><div id="41460212" class="c"><input type="checkbox" id="c-41460212" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#41459393">root</a><span>|</span><a href="#41459815">parent</a><span>|</span><a href="#41460097">next</a><span>|</span><label class="collapse" for="c-41460212">[-]</label><label class="expand" for="c-41460212">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used it to build and&#x2F;or run various machine learning models for text generation, speech recognition, image generation, depth estimation, etc. in the browser, in support of an agentic system I&#x27;ve been building out.<p>Lots of future possibilities as well once support is more ubiquitous!</div><br/><div id="41462017" class="c"><input type="checkbox" id="c-41462017" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#41459393">root</a><span>|</span><a href="#41460212">parent</a><span>|</span><a href="#41460097">next</a><span>|</span><label class="collapse" for="c-41462017">[-]</label><label class="expand" for="c-41462017">[1 more]</label></div><br/><div class="children"><div class="content">Your ideas are intriguing to me and I wish to subscribe to your newsletter.</div><br/></div></div></div></div></div></div><div id="41460097" class="c"><input type="checkbox" id="c-41460097" checked=""/><div class="controls bullet"><span class="by">bakugo</span><span>|</span><a href="#41459393">parent</a><span>|</span><a href="#41459815">prev</a><span>|</span><a href="#41461987">next</a><span>|</span><label class="collapse" for="c-41460097">[-]</label><label class="expand" for="c-41460097">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Is the demo using user agent strings to determine compatibility<p>&gt;I am on Chromium, not Chrome<p>Don&#x27;t know about your build, but I&#x27;m using Ungoogled Chromium, and it has the exact same user-agent string as Google Chrome.<p>Have you enabled the WebGL permission for the site in site settings? I think it was disabled by default for me.</div><br/></div></div></div></div><div id="41461987" class="c"><input type="checkbox" id="c-41461987" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41459393">prev</a><span>|</span><a href="#41459028">next</a><span>|</span><label class="collapse" for="c-41461987">[-]</label><label class="expand" for="c-41461987">[1 more]</label></div><br/><div class="children"><div class="content">Here is the somewhat neglected original 2009 dissertation by Federico Ponchio, the guy who invented the dynamic mesh simplification algorithm on which Nanite is based, with lots of illustrations:<p><a href="https:&#x2F;&#x2F;vcg.isti.cnr.it&#x2F;~ponchio&#x2F;download&#x2F;ponchio_phd.pdf" rel="nofollow">https:&#x2F;&#x2F;vcg.isti.cnr.it&#x2F;~ponchio&#x2F;download&#x2F;ponchio_phd.pdf</a> (107 pages!)</div><br/></div></div><div id="41459028" class="c"><input type="checkbox" id="c-41459028" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41461987">prev</a><span>|</span><a href="#41459296">next</a><span>|</span><label class="collapse" for="c-41459028">[-]</label><label class="expand" for="c-41459028">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s cool that it kind of works, but they had to make some nasty compromises to get around WebGPUs lack of 64 bit atomics. Hopefully that will be added as an optional extension at some point, hardware support is almost ubiquitous on desktop-class hardware at least (AMD and Nvidia have had it forever but Apple has only had it since the M3).</div><br/><div id="41459181" class="c"><input type="checkbox" id="c-41459181" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#41459028">parent</a><span>|</span><a href="#41460240">next</a><span>|</span><label class="collapse" for="c-41459181">[-]</label><label class="expand" for="c-41459181">[5 more]</label></div><br/><div class="children"><div class="content">What is the use case for atomics in the rasterizer? I can’t figure out what the atomic operations do inside the rendering pipeline. I looked at the GitHub, but couldn’t find the place the atomic were hoped for.</div><br/><div id="41459323" class="c"><input type="checkbox" id="c-41459323" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41459028">root</a><span>|</span><a href="#41459181">parent</a><span>|</span><a href="#41459228">next</a><span>|</span><label class="collapse" for="c-41459323">[-]</label><label class="expand" for="c-41459323">[1 more]</label></div><br/><div class="children"><div class="content">With traditional hardware rasterization there are specialized hardware blocks which handle atomically updating the framebuffer to whichever sample is currently the closest to the camera, and discarding anything behind that. Nanite does software rasterization instead, and one of their insights was figuring out a practical way to cram all of the data needed for each pixel into just 64 bits (depth in the high bits and everything else in the low bits) which allows them to do efficient depth sorting using min&#x2F;max atomics from a compute shader instead. The 64 bits are crucial though, that&#x27;s the absolute bare minimum useful amount of data per pixel so you <i>really</i> need 64 bit atomics. Nanite doesn&#x27;t even try to work without them.<p>To kind of get it working with 32 bit atomics this demo is reducing depth to just 16 bits (not enough to avoid artifacts) and only encoding a normal vector into the other 16 bits, which is why the compute rasterized pixels are untextured. There just aren&#x27;t enough bits to store any more material parameters or a primitive ID, the latter being how Nanite does it.</div><br/></div></div><div id="41459228" class="c"><input type="checkbox" id="c-41459228" checked=""/><div class="controls bullet"><span class="by">hrydgard</span><span>|</span><a href="#41459028">root</a><span>|</span><a href="#41459181">parent</a><span>|</span><a href="#41459323">prev</a><span>|</span><a href="#41459282">next</a><span>|</span><label class="collapse" for="c-41459228">[-]</label><label class="expand" for="c-41459228">[2 more]</label></div><br/><div class="children"><div class="content">Pack Z and 32-bit color together into a 64-bit integer, then do an atomic min (or max with reversed Z) to effectively do a Z-query and a write really, really fast.</div><br/><div id="41459527" class="c"><input type="checkbox" id="c-41459527" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41459028">root</a><span>|</span><a href="#41459228">parent</a><span>|</span><a href="#41459282">next</a><span>|</span><label class="collapse" for="c-41459527">[-]</label><label class="expand" for="c-41459527">[1 more]</label></div><br/><div class="children"><div class="content">Nanite writes out the ID of the primitive at that pixel rather than the color, but otherwise yeah that&#x27;s the idea. After rasterization is done a separate pass uses that ID to fetch the vertex data again and reconstruct all of the material parameters, which can be freely written out without atomics since there&#x27;s exactly one thread per pixel at that point.</div><br/></div></div></div></div><div id="41459282" class="c"><input type="checkbox" id="c-41459282" checked=""/><div class="controls bullet"><span class="by">neomantra</span><span>|</span><a href="#41459028">root</a><span>|</span><a href="#41459181">parent</a><span>|</span><a href="#41459228">prev</a><span>|</span><a href="#41460240">next</a><span>|</span><label class="collapse" for="c-41459282">[-]</label><label class="expand" for="c-41459282">[1 more]</label></div><br/><div class="children"><div class="content">Visibility buffer needing atomics is noted briefly in the long README. Link to discussion detailing it:
<a href="https:&#x2F;&#x2F;github.com&#x2F;Scthe&#x2F;nanite-webgpu&#x2F;issues&#x2F;1">https:&#x2F;&#x2F;github.com&#x2F;Scthe&#x2F;nanite-webgpu&#x2F;issues&#x2F;1</a></div><br/></div></div></div></div><div id="41460240" class="c"><input type="checkbox" id="c-41460240" checked=""/><div class="controls bullet"><span class="by">my123</span><span>|</span><a href="#41459028">parent</a><span>|</span><a href="#41459181">prev</a><span>|</span><a href="#41459296">next</a><span>|</span><label class="collapse" for="c-41460240">[-]</label><label class="expand" for="c-41460240">[2 more]</label></div><br/><div class="children"><div class="content">Since the M2</div><br/><div id="41460292" class="c"><input type="checkbox" id="c-41460292" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41459028">root</a><span>|</span><a href="#41460240">parent</a><span>|</span><a href="#41459296">next</a><span>|</span><label class="collapse" for="c-41460292">[-]</label><label class="expand" for="c-41460292">[1 more]</label></div><br/><div class="children"><div class="content">Right you are, 64 bit atomics were added with the Apple8 GPU but only in M-series chips (M2 and up) and then the Apple9 GPU made it universal (A17 Pro and up).<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;metal&#x2F;Metal-Feature-Set-Tables.pdf" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;metal&#x2F;Metal-Feature-Set-Tables.p...</a></div><br/></div></div></div></div></div></div><div id="41459296" class="c"><input type="checkbox" id="c-41459296" checked=""/><div class="controls bullet"><span class="by">TaylorAlexander</span><span>|</span><a href="#41459028">prev</a><span>|</span><a href="#41460643">next</a><span>|</span><label class="collapse" for="c-41459296">[-]</label><label class="expand" for="c-41459296">[4 more]</label></div><br/><div class="children"><div class="content">It says my iPhone 12 Pro Max doesn’t have WebGPU, but I enabled it in experimental features and another website[1] with WebGPU demos now works. Has anyone gotten this working on iPhone? Would be nice if the web app gave more info on what failed.<p>[1] <a href="https:&#x2F;&#x2F;webgpu.github.io&#x2F;webgpu-samples&#x2F;?sample=texturedCube" rel="nofollow">https:&#x2F;&#x2F;webgpu.github.io&#x2F;webgpu-samples&#x2F;?sample=texturedCube</a></div><br/><div id="41459476" class="c"><input type="checkbox" id="c-41459476" checked=""/><div class="controls bullet"><span class="by">KMnO4</span><span>|</span><a href="#41459296">parent</a><span>|</span><a href="#41462898">next</a><span>|</span><label class="collapse" for="c-41459476">[-]</label><label class="expand" for="c-41459476">[2 more]</label></div><br/><div class="children"><div class="content">I enabled WebGPU in Safari but I&#x27;m seeing a bunch of shader errors.<p>WebGPU error [init][validation]: 6 errors generated while compiling the shader: 50:22: unresolved call target &#x27;pack4x8snorm&#x27; 50:9: cannot bitcast from &#x27;â¥&#x27; to &#x27;f32&#x27; 54:10: unresolved call target &#x27;unpack4x8snorm&#x27; 59:22: unresolved call target &#x27;pack4x8unorm&#x27; 59:9: cannot bitcast from &#x27;â¥&#x27; to &#x27;f32&#x27; 63:9: unresolved call target &#x27;unpack4x8unorm&#x27;</div><br/></div></div><div id="41462898" class="c"><input type="checkbox" id="c-41462898" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41459296">parent</a><span>|</span><a href="#41459476">prev</a><span>|</span><a href="#41460643">next</a><span>|</span><label class="collapse" for="c-41462898">[-]</label><label class="expand" for="c-41462898">[1 more]</label></div><br/><div class="children"><div class="content">WebGPU support is not finished in Safari which is why it&#x27;s still experimental.</div><br/></div></div></div></div><div id="41460643" class="c"><input type="checkbox" id="c-41460643" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41459296">prev</a><span>|</span><a href="#41459555">next</a><span>|</span><label class="collapse" for="c-41460643">[-]</label><label class="expand" for="c-41460643">[10 more]</label></div><br/><div class="children"><div class="content">I wonder how other engines compare when it comes to LODs and similar systems.<p>Godot has automatic LOD which seems pretty cool for what it is: <a href="https:&#x2F;&#x2F;docs.godotengine.org&#x2F;en&#x2F;stable&#x2F;tutorials&#x2F;3d&#x2F;mesh_lod.html" rel="nofollow">https:&#x2F;&#x2F;docs.godotengine.org&#x2F;en&#x2F;stable&#x2F;tutorials&#x2F;3d&#x2F;mesh_lod...</a><p>Unity also has an LOD system, though despite how popular the engine is, you have to create LOD models manually: <a href="https:&#x2F;&#x2F;docs.unity3d.com&#x2F;Manual&#x2F;LevelOfDetail.html" rel="nofollow">https:&#x2F;&#x2F;docs.unity3d.com&#x2F;Manual&#x2F;LevelOfDetail.html</a> (unless you dig through the asset store and find a plugin)<p>I did see an interesting approach in a lesser known engine called NeoAxis: <a href="https:&#x2F;&#x2F;www.neoaxis.com&#x2F;docs&#x2F;html&#x2F;NeoAxis_Levels.htm" rel="nofollow">https:&#x2F;&#x2F;www.neoaxis.com&#x2F;docs&#x2F;html&#x2F;NeoAxis_Levels.htm</a> however that engine ran very poorly for me on my old RX580, although I haven&#x27;t tried on my current A580.<p>As far as I can tell, Unreal is really quite far ahead of the competition when it comes to putting lots of things on the screen, except the downside of this is that artists will be tempted to include higher quality assets in their games, bloating the install sizes quite far.</div><br/><div id="41460996" class="c"><input type="checkbox" id="c-41460996" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#41460643">parent</a><span>|</span><a href="#41461657">next</a><span>|</span><label class="collapse" for="c-41460996">[-]</label><label class="expand" for="c-41460996">[7 more]</label></div><br/><div class="children"><div class="content">In theory Nanite is superior to precomputed LODs. In practice it&#x27;s less clear cut as they aren&#x27;t going to be as good as artist-created LODs and it&#x27;s not entirely reasonable to expect them to do so. Also the performance cost is <i>huge</i> as Nanite&#x2F;virtual geometry is a poor fit for modern GPUs. iirc peak fill rate is 1&#x2F;4th or something like that as GPU rasterization works on 2x2 quads not per-pixel like shaders do.</div><br/><div id="41461080" class="c"><input type="checkbox" id="c-41461080" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41460643">root</a><span>|</span><a href="#41460996">parent</a><span>|</span><a href="#41461657">next</a><span>|</span><label class="collapse" for="c-41461080">[-]</label><label class="expand" for="c-41461080">[6 more]</label></div><br/><div class="children"><div class="content">Rasterizing very small triangles in hardware is indeed inefficient due to the 2x2 quad tax, but one of Nanites tent-pole features is a software rasterizer which sidesteps that problem entirely. IIRC they said that for a screen entirely filled with triangles roughly the size of a pixel, their software raster ends up being about 3x faster than using the dedicated raster hardware.</div><br/><div id="41461610" class="c"><input type="checkbox" id="c-41461610" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#41460643">root</a><span>|</span><a href="#41461080">parent</a><span>|</span><a href="#41461657">next</a><span>|</span><label class="collapse" for="c-41461610">[-]</label><label class="expand" for="c-41461610">[5 more]</label></div><br/><div class="children"><div class="content">Yes but I&#x27;m talking the other way around. Nanite is 1&#x2F;4th the performance for triangles that aren&#x27;t 1-3 pixels in size, which is the majority of the time.<p>The main selling point of Nanite is really just to reduce artist costs by avoiding manual LODs. But a high quality automatic LOD at build time may (read: almost certainly does) strike a much better balance for both current and near future hardware</div><br/><div id="41463481" class="c"><input type="checkbox" id="c-41463481" checked=""/><div class="controls bullet"><span class="by">guitarlimeo</span><span>|</span><a href="#41460643">root</a><span>|</span><a href="#41461610">parent</a><span>|</span><a href="#41462128">next</a><span>|</span><label class="collapse" for="c-41463481">[-]</label><label class="expand" for="c-41463481">[1 more]</label></div><br/><div class="children"><div class="content">Nanite is actually good at AAA graphics for hardware stacks that don&#x27;t do raytracing well, but if raytracing gets faster, Nanite becomes more useless as it doesn&#x27;t work well with raytracing. What Nanite is actually good with is providing LODs for only parts of the mesh, so that might get some longer use in the industry.<p><a href="https:&#x2F;&#x2F;threadreaderapp.com&#x2F;thread&#x2F;1809936882278469878.html" rel="nofollow">https:&#x2F;&#x2F;threadreaderapp.com&#x2F;thread&#x2F;1809936882278469878.html</a></div><br/></div></div><div id="41462128" class="c"><input type="checkbox" id="c-41462128" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#41460643">root</a><span>|</span><a href="#41461610">parent</a><span>|</span><a href="#41463481">prev</a><span>|</span><a href="#41461631">next</a><span>|</span><label class="collapse" for="c-41462128">[-]</label><label class="expand" for="c-41462128">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But a high quality automatic LOD at build time may (read: almost certainly does) strike a much better balance for both current and near future hardware<p>You can&#x27;t have a manual LOD for a cliff where half is near the player and should be high resolution, and half is further away and can be low resolution. Nanite&#x27;s hierarchical LODs are a huge improvement for this.<p>You&#x27;re also underestimating the amount of time artists have to spend making and tweaking LODs, and how big of an impact skipping that is.</div><br/><div id="41464249" class="c"><input type="checkbox" id="c-41464249" checked=""/><div class="controls bullet"><span class="by">incrudible</span><span>|</span><a href="#41460643">root</a><span>|</span><a href="#41462128">parent</a><span>|</span><a href="#41461631">next</a><span>|</span><label class="collapse" for="c-41464249">[-]</label><label class="expand" for="c-41464249">[1 more]</label></div><br/><div class="children"><div class="content">This is assuming you have this &quot;one big cliff mesh&quot;. This is the Nanite mindset: Just let the artists throw anything that comes out of their DCC at it. That is a great value proposition for studios, especially the ones that fail the marriage of art and engineering.<p>It&#x27;s a bad value proposition for end-users. Nanite is much slower for the same image quality that a bespoke solution would offer, which is evident with several AAA titles that choose to use in-house tech over UE.</div><br/></div></div></div></div><div id="41461631" class="c"><input type="checkbox" id="c-41461631" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41460643">root</a><span>|</span><a href="#41461610">parent</a><span>|</span><a href="#41462128">prev</a><span>|</span><a href="#41461657">next</a><span>|</span><label class="collapse" for="c-41461631">[-]</label><label class="expand" for="c-41461631">[1 more]</label></div><br/><div class="children"><div class="content">Nanite batches up triangles above a certain size threshold and sends them to the hardware rasterizer instead, since it is faster to use it in those cases. This was all documented from very early on.</div><br/></div></div></div></div></div></div></div></div><div id="41461657" class="c"><input type="checkbox" id="c-41461657" checked=""/><div class="controls bullet"><span class="by">elabajaba</span><span>|</span><a href="#41460643">parent</a><span>|</span><a href="#41460996">prev</a><span>|</span><a href="#41459555">next</a><span>|</span><label class="collapse" for="c-41461657">[-]</label><label class="expand" for="c-41461657">[2 more]</label></div><br/><div class="children"><div class="content">Intel Arc GPUs are terrible for Nanite rendering, since they lack hardware support for both indirect draws (widely used in GPU driven renderers, Intel emulates it in software which is slow) and 64bit atomics, which are required for nanite.</div><br/><div id="41463835" class="c"><input type="checkbox" id="c-41463835" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41460643">root</a><span>|</span><a href="#41461657">parent</a><span>|</span><a href="#41459555">next</a><span>|</span><label class="collapse" for="c-41463835">[-]</label><label class="expand" for="c-41463835">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting. Are there benchmarks on UE5 games which back this up?</div><br/></div></div></div></div></div></div><div id="41459555" class="c"><input type="checkbox" id="c-41459555" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#41460643">prev</a><span>|</span><a href="#41459462">next</a><span>|</span><label class="collapse" for="c-41459555">[-]</label><label class="expand" for="c-41459555">[3 more]</label></div><br/><div class="children"><div class="content">Name and description are very confusing and a trademark violation since despite the claims it seems to be completely unrelated to actual Nanite in UE5, just an implementation of something similar by a person unaffiliated with UE5.<p>There is also Bevy&#x27;s Virtual Geometry that provides similar functionality and is probably much more useful since it&#x27;s written in Rust and integrated with a game engine: <a href="https:&#x2F;&#x2F;jms55.github.io&#x2F;posts&#x2F;2024-06-09-virtual-geometry-bevy-0-14&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jms55.github.io&#x2F;posts&#x2F;2024-06-09-virtual-geometry-be...</a></div><br/><div id="41460484" class="c"><input type="checkbox" id="c-41460484" checked=""/><div class="controls bullet"><span class="by">KMnO4</span><span>|</span><a href="#41459555">parent</a><span>|</span><a href="#41459462">next</a><span>|</span><label class="collapse" for="c-41460484">[-]</label><label class="expand" for="c-41460484">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think it’s really an issue. It’s clear from the readme that it’s an implementation.<p>If I made an “implementation of OpenAI’s GPT-3 in JS” you would understand that to mean I took the architecture from the whitepaper and reimplemented it.</div><br/><div id="41462156" class="c"><input type="checkbox" id="c-41462156" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#41459555">root</a><span>|</span><a href="#41460484">parent</a><span>|</span><a href="#41459462">next</a><span>|</span><label class="collapse" for="c-41462156">[-]</label><label class="expand" for="c-41462156">[1 more]</label></div><br/><div class="children"><div class="content">The technique is commonly called virtual geometry or virtualized geometry, or dynamic LOD in research papers. Really no need to reuse the name of a specific implementation.</div><br/></div></div></div></div></div></div><div id="41459462" class="c"><input type="checkbox" id="c-41459462" checked=""/><div class="controls bullet"><span class="by">SaintSeiya</span><span>|</span><a href="#41459555">prev</a><span>|</span><a href="#41459607">next</a><span>|</span><label class="collapse" for="c-41459462">[-]</label><label class="expand" for="c-41459462">[11 more]</label></div><br/><div class="children"><div class="content">Honest question:
It is calim that software rasterizer is faster than hardware one. Can someone explain me why? isn&#x27;t the purpose of the GPU to accelerate rasterization itself?
Unless is a recent algorithm or the &quot;software rasterizer&quot; is actually running on the GPU and not the CPU I don&#x27;t see how</div><br/><div id="41460365" class="c"><input type="checkbox" id="c-41460365" checked=""/><div class="controls bullet"><span class="by">TinkersW</span><span>|</span><a href="#41459462">parent</a><span>|</span><a href="#41459530">next</a><span>|</span><label class="collapse" for="c-41460365">[-]</label><label class="expand" for="c-41460365">[2 more]</label></div><br/><div class="children"><div class="content">A couple reasons<p>1. HW does 2x2 blocks of pixels always so it can have derivatives, even if you don&#x27;t use them..<p>2. Accessing SV_PrimitiveID is surprisingly slow on Nvidia&#x2F;AMD, by writing it out in the PS you will take a huge perf hit in HW. There are ways to work around this, but they aren&#x27;t trivial and differ between vendors, and you have to be aware of the issue it in the first place! I think some of the &quot;software&quot; &gt; &quot;hardware&quot; raster stuff may come from this.<p>The HW shader in this demo looks wonky though, it should be writing out the visibility buffer, and instead it is writing out a vec4 with color data, so of course that is going to hurt perf. Way too many varyings being passed down also.<p>In a high triangle HW rasterizer you want the visibility buffer PS do a little compute as possible, and write as little as possible, so it should only have 1 or 2 input varyings and simply writes them out.</div><br/><div id="41463844" class="c"><input type="checkbox" id="c-41463844" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#41459462">root</a><span>|</span><a href="#41460365">parent</a><span>|</span><a href="#41459530">next</a><span>|</span><label class="collapse" for="c-41463844">[-]</label><label class="expand" for="c-41463844">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s PS? Pixel shader? I&#x27;m guessing here.</div><br/></div></div></div></div><div id="41459530" class="c"><input type="checkbox" id="c-41459530" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41459462">parent</a><span>|</span><a href="#41460365">prev</a><span>|</span><a href="#41459496">next</a><span>|</span><label class="collapse" for="c-41459530">[-]</label><label class="expand" for="c-41459530">[2 more]</label></div><br/><div class="children"><div class="content">The answer to that is in this hour-long SIGGRAPH video.[1] Some of the operations needed are not done well, or at all, by the GPU.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eviSykqSUUw" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eviSykqSUUw</a></div><br/><div id="41459808" class="c"><input type="checkbox" id="c-41459808" checked=""/><div class="controls bullet"><span class="by">janito</span><span>|</span><a href="#41459462">root</a><span>|</span><a href="#41459530">parent</a><span>|</span><a href="#41459496">next</a><span>|</span><label class="collapse" for="c-41459808">[-]</label><label class="expand" for="c-41459808">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the relevant part of the (really cool!) video: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eviSykqSUUw&amp;t=1888s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eviSykqSUUw&amp;t=1888s</a></div><br/></div></div></div></div><div id="41459496" class="c"><input type="checkbox" id="c-41459496" checked=""/><div class="controls bullet"><span class="by">janito</span><span>|</span><a href="#41459462">parent</a><span>|</span><a href="#41459530">prev</a><span>|</span><a href="#41459645">next</a><span>|</span><label class="collapse" for="c-41459496">[-]</label><label class="expand" for="c-41459496">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also curious. From what I could read in the repository&#x27;s references, I think that the problem is that the GPU is bad at rasterizing small triangles. Apparently each triangle in the fixed function pipeline generates a batch of pixels to render (16 in one of the slides I saw), so if the triangle covers only one or two pixels, all others in the batch are wasted. I speculate that the idea is to then detect these small triangles and draw them quickly using less pixel shaders (still on the GPU, but without using the graphics specific fixed functions), but I&#x27;m honestly not sure I understand what&#x27;s happening.</div><br/></div></div><div id="41459645" class="c"><input type="checkbox" id="c-41459645" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41459462">parent</a><span>|</span><a href="#41459496">prev</a><span>|</span><a href="#41459520">next</a><span>|</span><label class="collapse" for="c-41459645">[-]</label><label class="expand" for="c-41459645">[2 more]</label></div><br/><div class="children"><div class="content">I thought it was a software rasterizer running inside fragment shader on the GPU. Not actually on the CPU. I need to watch that video again to be sure, but I cant see how a CPU could handle that many triangles.</div><br/><div id="41460361" class="c"><input type="checkbox" id="c-41460361" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#41459462">root</a><span>|</span><a href="#41459645">parent</a><span>|</span><a href="#41459520">next</a><span>|</span><label class="collapse" for="c-41460361">[-]</label><label class="expand" for="c-41460361">[1 more]</label></div><br/><div class="children"><div class="content">To be precise, this is running in a compute shader (rasterizeSwPass.wgsl.ts for the curious). You can think of that as running the GPU in a mode where it&#x27;s a type of computer with some frustrating limitations, but also the ability to efficiently run thousands of threads in parallel.<p>This is in contrast to hardware rasterization, where there is dedicated hardware onboard the GPU to decide which pixels are covered by a given triangle, and assigns those pixels to a fragment shader, where the color (and potentially other things) are computed, finally written to the render target as a raster op (also a bit of specialized hardware).<p>The seminal paper on this is cudaraster [1], which implemented basic 3D rendering in CUDA (the CUDA of 13 years ago is roughly comparable in power to compute shaders today), and basically posed the question: how much does using the specialized rasterization hardware help, compared with just using compute? The answer is roughly 2x, though it depends a lot on the details.<p>And those details are important. One of the assumptions that hardware rasterization relies on for efficiency is that a triangle covers dozens of pixels. In Nanite, that assumption is not valid, in fact a great many triangles are approximately a single pixel, and then software&#x2F;compute approaches actually start beating the hardware.<p>Nanite, like this project, thus actually uses a hybrid approach: rasterization for medium to large triangles, and compute for smaller ones. Both can share the same render target.<p>[1]: <a href="https:&#x2F;&#x2F;research.nvidia.com&#x2F;publication&#x2F;2011-08_high-performance-software-rasterization-gpus" rel="nofollow">https:&#x2F;&#x2F;research.nvidia.com&#x2F;publication&#x2F;2011-08_high-perform...</a></div><br/></div></div></div></div><div id="41459520" class="c"><input type="checkbox" id="c-41459520" checked=""/><div class="controls bullet"><span class="by">NotGMan</span><span>|</span><a href="#41459462">parent</a><span>|</span><a href="#41459645">prev</a><span>|</span><a href="#41459574">next</a><span>|</span><label class="collapse" for="c-41459520">[-]</label><label class="expand" for="c-41459520">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit out of the GPU game but so this might be slightly wrong in some places: the issue is in small triangles because you end up paying a huge cost. GPUs ALWAYS shade in 2x2 blocks of pixels, not 1x1 pixels.<p>So if you have a very small triangle (small as in how many pixels on the screen it covers) that covers 1 pixel you will still pay the price of a 2x2 block (4 pixels instead of 1), so you just wasted 300% of your performance.<p>Nanite auto-picks the best triangle to minimize this and probably many more perf metrics that I have no idea about.<p>So even if you do it in software the point is that if you can get rid of that 2x2 block penalty as much as possible you could be faster than GPU doing 2x2 blocks in hardware since pixel shaders can be very expensive.<p>This issue gets worse the larger the rendering resolution is.<p>Nanite then picks larger triangles instead of those tiny 1-pixel ones since those are too small to give any visual fidelity anyway.<p>Nanite is also not used for large triangles since those are more efficient to do in hardware.</div><br/><div id="41461059" class="c"><input type="checkbox" id="c-41461059" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#41459462">root</a><span>|</span><a href="#41459520">parent</a><span>|</span><a href="#41459574">next</a><span>|</span><label class="collapse" for="c-41461059">[-]</label><label class="expand" for="c-41461059">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So even if you do it in software the point is that if you can get rid of that 2x2 block penalty as much as possible you could be faster than GPU doing 2x2 blocks in hardware since pixel shaders can be very expensive.<p>Of course the obvious problem with that is if you don&#x27;t have most of the screen covered in such small triangles then you&#x27;re paying a large cost for nanite vs traditional means.</div><br/></div></div></div></div><div id="41459574" class="c"><input type="checkbox" id="c-41459574" checked=""/><div class="controls bullet"><span class="by">SaintSeiya</span><span>|</span><a href="#41459462">parent</a><span>|</span><a href="#41459520">prev</a><span>|</span><a href="#41459607">next</a><span>|</span><label class="collapse" for="c-41459574">[-]</label><label class="expand" for="c-41459574">[1 more]</label></div><br/><div class="children"><div class="content">thanks all, yes it start making sense now</div><br/></div></div></div></div><div id="41459607" class="c"><input type="checkbox" id="c-41459607" checked=""/><div class="controls bullet"><span class="by">theogravity</span><span>|</span><a href="#41459462">prev</a><span>|</span><a href="#41459949">next</a><span>|</span><label class="collapse" for="c-41459607">[-]</label><label class="expand" for="c-41459607">[4 more]</label></div><br/><div class="children"><div class="content">Using latest chrome on M2 Max for the jinx demo:<p><pre><code>  WebGPU error [frame][validation]: Fill size (7398781) is not a multiple of 4 
  bytes.
  - While encoding [CommandEncoder &quot;main-frame-cmd-buffer&quot;].ClearBuffer([Buffer 
  &quot;rasterize-sw&quot;], 0, 7398781).</code></pre></div><br/><div id="41461619" class="c"><input type="checkbox" id="c-41461619" checked=""/><div class="controls bullet"><span class="by">flockonus</span><span>|</span><a href="#41459607">parent</a><span>|</span><a href="#41461183">next</a><span>|</span><label class="collapse" for="c-41461619">[-]</label><label class="expand" for="c-41461619">[1 more]</label></div><br/><div class="children"><div class="content">If helpful to author, on M1 no errors, can see 15+ fps at all times.</div><br/></div></div><div id="41461183" class="c"><input type="checkbox" id="c-41461183" checked=""/><div class="controls bullet"><span class="by">daemonologist</span><span>|</span><a href="#41459607">parent</a><span>|</span><a href="#41461619">prev</a><span>|</span><a href="#41459803">next</a><span>|</span><label class="collapse" for="c-41461183">[-]</label><label class="expand" for="c-41461183">[1 more]</label></div><br/><div class="children"><div class="content">Same (different number) on Chrome on Android (Pixel 7).</div><br/></div></div><div id="41459803" class="c"><input type="checkbox" id="c-41459803" checked=""/><div class="controls bullet"><span class="by">stephc_int13</span><span>|</span><a href="#41459607">parent</a><span>|</span><a href="#41461183">prev</a><span>|</span><a href="#41459949">next</a><span>|</span><label class="collapse" for="c-41459803">[-]</label><label class="expand" for="c-41459803">[1 more]</label></div><br/><div class="children"><div class="content">I have the same error on Windows 11, GPU is a RTX4090. Browser is Edge.</div><br/></div></div></div></div><div id="41459949" class="c"><input type="checkbox" id="c-41459949" checked=""/><div class="controls bullet"><span class="by">eigenvalue</span><span>|</span><a href="#41459607">prev</a><span>|</span><a href="#41461255">next</a><span>|</span><label class="collapse" for="c-41459949">[-]</label><label class="expand" for="c-41459949">[3 more]</label></div><br/><div class="children"><div class="content">Whenever I see rendered scenes like this (I.e., lots of repetitive static geometry) I imagine that annoying guy’s voice going on about “unlimited detail” from that old vaporware video. I guess nanite really did solve that problem for real, as opposed to whatever that old thing was using (I remember something about oct-trees or something).</div><br/><div id="41460801" class="c"><input type="checkbox" id="c-41460801" checked=""/><div class="controls bullet"><span class="by">HappMacDonald</span><span>|</span><a href="#41459949">parent</a><span>|</span><a href="#41461255">next</a><span>|</span><label class="collapse" for="c-41460801">[-]</label><label class="expand" for="c-41460801">[2 more]</label></div><br/><div class="children"><div class="content">I recall those claims being made by a company called &quot;Euclidean&quot;, from Australia I think. Online rumors suggested they might have been using octtrees, but later Euclidean videos flatly denied that.</div><br/><div id="41460990" class="c"><input type="checkbox" id="c-41460990" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#41459949">root</a><span>|</span><a href="#41460801">parent</a><span>|</span><a href="#41461255">next</a><span>|</span><label class="collapse" for="c-41460990">[-]</label><label class="expand" for="c-41460990">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Euclideon. And it is octtrees. My interpretation after reading a <i>fascinating</i> Reddit thread [1] is that these denials were misdirection. There&#x27;s definitely new interest in splatting techniques (Gaussian in particular), though they&#x27;ve long been an alternative to triangles in the 3D world. I think it&#x27;d be fun to experiment with implementing some of that using modern compute shaders.<p>[1]: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;VoxelGameDev&#x2F;comments&#x2F;1bz5vvy&#x2F;a_small_update_on_cpu_octree_splatting_feat&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;VoxelGameDev&#x2F;comments&#x2F;1bz5vvy&#x2F;a_sma...</a></div><br/></div></div></div></div></div></div><div id="41461255" class="c"><input type="checkbox" id="c-41461255" checked=""/><div class="controls bullet"><span class="by">mbforbes</span><span>|</span><a href="#41459949">prev</a><span>|</span><a href="#41463246">next</a><span>|</span><label class="collapse" for="c-41461255">[-]</label><label class="expand" for="c-41461255">[1 more]</label></div><br/><div class="children"><div class="content">Funny coincidence, was just reading through an amazing thread on the three.js form a couple days ago about a web graphics implementation of virtual geometry (nanite). webgl, 2021:
<a href="https:&#x2F;&#x2F;discourse.threejs.org&#x2F;t&#x2F;virtually-geometric&#x2F;28420" rel="nofollow">https:&#x2F;&#x2F;discourse.threejs.org&#x2F;t&#x2F;virtually-geometric&#x2F;28420</a><p>it&#x27;s closed source, but I found the discussion and description of the tradeoffs interesting</div><br/></div></div><div id="41463246" class="c"><input type="checkbox" id="c-41463246" checked=""/><div class="controls bullet"><span class="by">vladde</span><span>|</span><a href="#41461255">prev</a><span>|</span><a href="#41462923">next</a><span>|</span><label class="collapse" for="c-41463246">[-]</label><label class="expand" for="c-41463246">[1 more]</label></div><br/><div class="children"><div class="content">Got to love in the stated goals:<p>&gt; I could have built this with Vulkan and Rust. None would touch it.</div><br/></div></div><div id="41462923" class="c"><input type="checkbox" id="c-41462923" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41463246">prev</a><span>|</span><a href="#41460726">next</a><span>|</span><label class="collapse" for="c-41462923">[-]</label><label class="expand" for="c-41462923">[1 more]</label></div><br/><div class="children"><div class="content">This is amazing! I will be so great when Safari and Firefox but finish their WebGPU implementations so it runs everywhere.</div><br/></div></div><div id="41460726" class="c"><input type="checkbox" id="c-41460726" checked=""/><div class="controls bullet"><span class="by">astlouis44</span><span>|</span><a href="#41462923">prev</a><span>|</span><a href="#41459595">next</a><span>|</span><label class="collapse" for="c-41460726">[-]</label><label class="expand" for="c-41460726">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an actual implementation of UE5 in WebGPU, for anyone interested.<p>Just a disclaimer that it will only work on WebGPU-enabled browser on Windows (Chrome, Edge, etc) unfortunately Mac has issues for now. Also, there is no Nanite in this demo, but it will be possible in the future.<p><a href="https:&#x2F;&#x2F;play.spacelancers.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;play.spacelancers.com&#x2F;</a></div><br/><div id="41460942" class="c"><input type="checkbox" id="c-41460942" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#41460726">parent</a><span>|</span><a href="#41459595">next</a><span>|</span><label class="collapse" for="c-41460942">[-]</label><label class="expand" for="c-41460942">[1 more]</label></div><br/><div class="children"><div class="content">I was curious what &quot;issues&quot; Mac has, and at least for me it didn&#x27;t explode for any <i>good</i> reason, it puked trying to JSON.stringify() some capabilities object into localStorage which is a pretty piss-poor reason to bomb loading a webpage, IMHO</div><br/></div></div></div></div><div id="41459595" class="c"><input type="checkbox" id="c-41459595" checked=""/><div class="controls bullet"><span class="by">smartmic</span><span>|</span><a href="#41460726">prev</a><span>|</span><a href="#41459232">next</a><span>|</span><label class="collapse" for="c-41459595">[-]</label><label class="expand" for="c-41459595">[5 more]</label></div><br/><div class="children"><div class="content">Wow, I can&#x27;t remember the last time I read a project summary with so much jargon - I literally didn&#x27;t understand anything:<p>&gt; UE5&#x27;s Nanite implementation using WebGPU. Includes the meshlet LOD hierarchy, software rasterizer and billboard impostors. Culling on both per-instance and per-meshlet basis.</div><br/><div id="41460054" class="c"><input type="checkbox" id="c-41460054" checked=""/><div class="controls bullet"><span class="by">bogwog</span><span>|</span><a href="#41459595">parent</a><span>|</span><a href="#41459784">next</a><span>|</span><label class="collapse" for="c-41460054">[-]</label><label class="expand" for="c-41460054">[2 more]</label></div><br/><div class="children"><div class="content">UE5 Nanite -&gt; <a href="https:&#x2F;&#x2F;dev.epicgames.com&#x2F;documentation&#x2F;en-us&#x2F;unreal-engine&#x2F;nanite-virtualized-geometry-in-unreal-engine" rel="nofollow">https:&#x2F;&#x2F;dev.epicgames.com&#x2F;documentation&#x2F;en-us&#x2F;unreal-engine&#x2F;...</a><p>WebGPU -&gt; <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;WebGPU_API" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;WebGPU_API</a><p>Meshlet -&gt; <a href="https:&#x2F;&#x2F;developer.nvidia.com&#x2F;blog&#x2F;introduction-turing-mesh-shaders&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developer.nvidia.com&#x2F;blog&#x2F;introduction-turing-mesh-s...</a><p>LOD -&gt; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Level_of_detail_(computer_graphics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Level_of_detail_(computer_grap...</a><p>Software rasterizer -&gt; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rasterisation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rasterisation</a> (&quot;software&quot; means it runs on the CPU instead of GPU)<p>Billboard imposters -&gt; <a href="https:&#x2F;&#x2F;www.alanzucconi.com&#x2F;2018&#x2F;08&#x2F;25&#x2F;shader-showcase-saturday-7&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.alanzucconi.com&#x2F;2018&#x2F;08&#x2F;25&#x2F;shader-showcase-satur...</a><p>Culling -&gt; <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hidden-surface_determination" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hidden-surface_determination</a></div><br/><div id="41460309" class="c"><input type="checkbox" id="c-41460309" checked=""/><div class="controls bullet"><span class="by">nicebyte</span><span>|</span><a href="#41459595">root</a><span>|</span><a href="#41460054">parent</a><span>|</span><a href="#41459784">next</a><span>|</span><label class="collapse" for="c-41460309">[-]</label><label class="expand" for="c-41460309">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (&quot;software&quot; means it runs on the CPU instead of GPU)<p>no, in this context it means that the rasterisation algorithm is implemented in a compute kernel, rather than using the fixed hw built into the gpu. so rasterization still happens on the gpu, just using programmable blocks.</div><br/></div></div></div></div><div id="41459662" class="c"><input type="checkbox" id="c-41459662" checked=""/><div class="controls bullet"><span class="by">goodcjw2</span><span>|</span><a href="#41459595">parent</a><span>|</span><a href="#41459784">prev</a><span>|</span><a href="#41459232">next</a><span>|</span><label class="collapse" for="c-41459662">[-]</label><label class="expand" for="c-41459662">[1 more]</label></div><br/><div class="children"><div class="content">Guess this really shows how much domain specific knowledge in the Computer Graphics...<p>Yet still, this post is now ranked top 1 on HN.</div><br/></div></div></div></div><div id="41459232" class="c"><input type="checkbox" id="c-41459232" checked=""/><div class="controls bullet"><span class="by">macawfish</span><span>|</span><a href="#41459595">prev</a><span>|</span><a href="#41459675">next</a><span>|</span><label class="collapse" for="c-41459232">[-]</label><label class="expand" for="c-41459232">[3 more]</label></div><br/><div class="children"><div class="content">The camera controls on my phone are very hard to get down</div><br/><div id="41459313" class="c"><input type="checkbox" id="c-41459313" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41459232">parent</a><span>|</span><a href="#41459274">next</a><span>|</span><label class="collapse" for="c-41459313">[-]</label><label class="expand" for="c-41459313">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t we use something like this to provide a more intuitive experience for the mobile web targets?<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Device_orientation_events&#x2F;Detecting_device_orientation" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Device_orie...</a></div><br/></div></div><div id="41459274" class="c"><input type="checkbox" id="c-41459274" checked=""/><div class="controls bullet"><span class="by">aaroninsf</span><span>|</span><a href="#41459232">parent</a><span>|</span><a href="#41459313">prev</a><span>|</span><a href="#41459675">next</a><span>|</span><label class="collapse" for="c-41459274">[-]</label><label class="expand" for="c-41459274">[1 more]</label></div><br/><div class="children"><div class="content">Browser&#x2F;touchpad also :)</div><br/></div></div></div></div><div id="41459675" class="c"><input type="checkbox" id="c-41459675" checked=""/><div class="controls bullet"><span class="by">replete</span><span>|</span><a href="#41459232">prev</a><span>|</span><a href="#41460644">next</a><span>|</span><label class="collapse" for="c-41459675">[-]</label><label class="expand" for="c-41459675">[1 more]</label></div><br/><div class="children"><div class="content">Intel Mac, Chrome and ungoogled chromium:
index.web.ts:159 Uncaught (in promise) OperationError: Instance dropped in popErrorScope</div><br/></div></div><div id="41460644" class="c"><input type="checkbox" id="c-41460644" checked=""/><div class="controls bullet"><span class="by">hising</span><span>|</span><a href="#41459675">prev</a><span>|</span><a href="#41460475">next</a><span>|</span><label class="collapse" for="c-41460644">[-]</label><label class="expand" for="c-41460644">[1 more]</label></div><br/><div class="children"><div class="content">I would love to see this but it wont work on Linux + Chrome even if WebGPU is enabled.</div><br/></div></div><div id="41460475" class="c"><input type="checkbox" id="c-41460475" checked=""/><div class="controls bullet"><span class="by">tech-no-logical</span><span>|</span><a href="#41460644">prev</a><span>|</span><a href="#41460252">next</a><span>|</span><label class="collapse" for="c-41460475">[-]</label><label class="expand" for="c-41460475">[2 more]</label></div><br/><div class="children"><div class="content">getting the message<p><pre><code>    No WebGPU available. Please use Chrome.
</code></pre>
on chrome (Version 129.0.6668.29 (Official Build) beta (64-bit)) , under windows</div><br/><div id="41463174" class="c"><input type="checkbox" id="c-41463174" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#41460475">parent</a><span>|</span><a href="#41460252">next</a><span>|</span><label class="collapse" for="c-41463174">[-]</label><label class="expand" for="c-41463174">[1 more]</label></div><br/><div class="children"><div class="content">Look at the #enable-unsafe-webgpu flag in chrome.<p>Turn it back off when done, as tools like noscript only block webgl tags.<p>Cheers =3</div><br/></div></div></div></div><div id="41460252" class="c"><input type="checkbox" id="c-41460252" checked=""/><div class="controls bullet"><span class="by">readyplayernull</span><span>|</span><a href="#41460475">prev</a><span>|</span><a href="#41460188">next</a><span>|</span><label class="collapse" for="c-41460252">[-]</label><label class="expand" for="c-41460252">[1 more]</label></div><br/><div class="children"><div class="content">Will virtual geometry be integrated into GPUs some day?</div><br/></div></div><div id="41460188" class="c"><input type="checkbox" id="c-41460188" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41460252">prev</a><span>|</span><a href="#41459475">next</a><span>|</span><label class="collapse" for="c-41460188">[-]</label><label class="expand" for="c-41460188">[1 more]</label></div><br/><div class="children"><div class="content">Note: this isn&#x27;t actually UE5 Nanite in WebGPU. It&#x27;s a totally independent implementation of the same idea as Nanite.<p>This technique is starting to appear in a variety of places. Nanite definitely made the idea famous, but Nanite is the name a specific implementation, not the name of the technique.</div><br/></div></div><div id="41459475" class="c"><input type="checkbox" id="c-41459475" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#41460188">prev</a><span>|</span><a href="#41459209">next</a><span>|</span><label class="collapse" for="c-41459475">[-]</label><label class="expand" for="c-41459475">[2 more]</label></div><br/><div class="children"><div class="content">&gt; No WebGPU available. Please use Chrome.<p>Getting that on Chromium, lol.</div><br/><div id="41459665" class="c"><input type="checkbox" id="c-41459665" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41459475">parent</a><span>|</span><a href="#41459209">next</a><span>|</span><label class="collapse" for="c-41459665">[-]</label><label class="expand" for="c-41459665">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m getting that in <i>google chrome proper</i>, but what completes the joke is that in firefox I just get a blank page without the message to use chrome.<p>Edit: WebGPU in chrome is behind a flag on linux: <a href="https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;wiki&#x2F;Implementation-Status#implementation-status">https:&#x2F;&#x2F;github.com&#x2F;gpuweb&#x2F;gpuweb&#x2F;wiki&#x2F;Implementation-Status#...</a></div><br/></div></div></div></div><div id="41459209" class="c"><input type="checkbox" id="c-41459209" checked=""/><div class="controls bullet"><span class="by">moralestapia</span><span>|</span><a href="#41459475">prev</a><span>|</span><a href="#41460693">next</a><span>|</span><label class="collapse" for="c-41459209">[-]</label><label class="expand" for="c-41459209">[1 more]</label></div><br/><div class="children"><div class="content">Outstanding work. Also, thanks for proving actual demos of the tech. I get 60-120fps on my MBP which is phenomenal given the amount of triangles in the scene.</div><br/></div></div><div id="41460693" class="c"><input type="checkbox" id="c-41460693" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#41459209">prev</a><span>|</span><a href="#41459538">next</a><span>|</span><label class="collapse" for="c-41460693">[-]</label><label class="expand" for="c-41460693">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you want to add this tech to the existing engine, I&#x27;m not a person you should be asking (I don&#x27;t work in the industry).<p>Fucking .. bravo man.</div><br/></div></div></div></div></div></div></div></body></html>