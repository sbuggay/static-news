<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690448460743" as="style"/><link rel="stylesheet" href="styles.css?v=1690448460743"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html">It&#x27;s 2023, so of course I&#x27;m learning Common Lisp</a> <span class="domain">(<a href="https://log.schemescape.com">log.schemescape.com</a>)</span></div><div class="subtext"><span>behnamoh</span> | <span>196 comments</span></div><br/><div><div id="36887744" class="c"><input type="checkbox" id="c-36887744" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36890783">next</a><span>|</span><label class="collapse" for="c-36887744">[-]</label><label class="expand" for="c-36887744">[28 more]</label></div><br/><div class="children"><div class="content">Wow, wasn&#x27;t expecting to see my post on here! Eventually, I want to write a follow-up, but I&#x27;m still a beginner.<p>Here&#x27;s what I&#x27;ve liked about Common Lisp so far:<p>* The condition system is neat and I&#x27;ve never used anything like it -- you can easily control code from afar with restarts<p>* REPL-driven programming is handy in situations where you don&#x27;t quite know what will happen and don&#x27;t want to lose context -- for example parsing data from a source you&#x27;re unfamiliar with, you can just update your code and continue on instead of having to save, possibly compile, and restart from the very beginning<p>* Common Lisp has a lot of implementations and there&#x27;s a good deal of interoperability -- I was able to swap out implementations to trade speed (SBCL) for memory usage (CLISP) in one case (multiple compatible implementations is one of the reasons I&#x27;ve been leaning towards CL instead of Scheme for learning a Lisp)<p>* Even as an Emacs noob, the integration with Common Lisp is excellent, and it works great even on my super slow netbook where I&#x27;ve been developing -- this isn&#x27;t as big of an advantage these days with fast computers, VS Code, and language servers, but it&#x27;s definitely retrofuturistic<p>There&#x27;s also a few things I don&#x27;t like:<p>* The most popular package manager (QuickLisp) is nice, but not nearly as featureful as I&#x27;ve become accustomed to with newer languages&#x2F;ecosystems<p>* Since the language itself is frozen in time, you need lots of interoperability libraries for threads, synchronization, command line arguments, and tons of other things<p>* I really, really wish SBCL could support fully static builds, to enable distributing binaries to non-glibc Linux distributions<p>I&#x27;m sure there are more pros&#x2F;cons, but that&#x27;s what came to mind just now.</div><br/><div id="36888454" class="c"><input type="checkbox" id="c-36888454" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36888213">next</a><span>|</span><label class="collapse" for="c-36888454">[-]</label><label class="expand" for="c-36888454">[11 more]</label></div><br/><div class="children"><div class="content">I have some cons!<p>Last time I checked on it, QuickLisp doesn&#x27;t support fetching packages over anything except for plain http, with no encryption and no verification mechanism in place to detect files that may have been tampered with during transmission.<p>I think not supporting encryption or authentication for something as important as fetching source code makes QL a non-starter for me and hopefully for anyone else who cares about security.<p>Another issue I have ran into, is that SBCL is hosted on sourceforge, which has in the past injected malware into projects downloadable archives! I consider this to also be a security issue, and sourceforge in general is not pleasant to work with. I don&#x27;t think there are any valid reasons to continue to use sourceforge today, so why such an important project continues to use it confuses me a lot.<p>I don&#x27;t see these issues mentioned by anyone else which is bizarre to me.<p>I really like lisps and common lisp specifically but things like this has driven me away from using it and it doesn&#x27;t appear that anyone cares about fixing these things.</div><br/><div id="36890790" class="c"><input type="checkbox" id="c-36890790" checked=""/><div class="controls bullet"><span class="by">ristos</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888454">parent</a><span>|</span><a href="#36890801">next</a><span>|</span><label class="collapse" for="c-36890790">[-]</label><label class="expand" for="c-36890790">[1 more]</label></div><br/><div class="children"><div class="content">These issues get mentioned a lot, you just haven&#x27;t noticed I guess. Sourceforge is also an issue with some C libraries too, I&#x27;m guessing because it was done a long time ago? not sure.<p>I use ECL because it has really good C interop. It actually lets you inline C and access macros directly, making it a great glue language for C libraries. It&#x27;s what I&#x27;m using it for now. I think you might even be able to avoid the GC entirely and use it to script C programs together in a performant way, by using the C FFI to allocate and manage the memory, including the ECL types, instead of the GC. And that&#x27;s actually doable because of how good the inspector&#x2F;debugger for lisp is. You can even inline assembly. I&#x27;m working on a bunch of CL stuff around this sort of thing, I plan to do a writeup of it and share it once I&#x27;ve developed it more.<p>Lisp has it&#x27;s downsides, but the C FFI&#x2F;embeddability, along with the excellent low-level debugger&#x2F;inspector, interactivity, and conditions and restarts, makes it worth the time for me to invest in it. And the stability of the language. My main gripe is the reader, but it&#x27;s easy-ish enough to avoid the problems with named-readtables, or a simple lisp parser for `read` or whatever. I like Clojure, but it&#x27;s missing some key stuff from the old lisp world that I&#x27;d love to see. Shadow-cljs is awesome.</div><br/></div></div><div id="36890801" class="c"><input type="checkbox" id="c-36890801" checked=""/><div class="controls bullet"><span class="by">momentoftop</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888454">parent</a><span>|</span><a href="#36890790">prev</a><span>|</span><a href="#36888739">next</a><span>|</span><label class="collapse" for="c-36890801">[-]</label><label class="expand" for="c-36890801">[1 more]</label></div><br/><div class="children"><div class="content">When I started using CL 20 years ago, libraries were stored on cliki and any malicious user could put malware there. Any source you asdf-installed was generally GPG signed and the installer automatically checked signatures against your personal trust-chain.<p>Learning CL back then was my first introduction to GPG (and Emacs, and Linux)</div><br/></div></div><div id="36888739" class="c"><input type="checkbox" id="c-36888739" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888454">parent</a><span>|</span><a href="#36890801">prev</a><span>|</span><a href="#36889854">next</a><span>|</span><label class="collapse" for="c-36888739">[-]</label><label class="expand" for="c-36888739">[7 more]</label></div><br/><div class="children"><div class="content">Quicklisp doesn’t use TLS or signatures? How have I not heard this before?<p>That would be unbelievably irresponsible. Has this really not been addressed by the CL community?<p>Edit: here’s the issue: <a href="https:&#x2F;&#x2F;github.com&#x2F;quicklisp&#x2F;quicklisp-client&#x2F;issues&#x2F;167">https:&#x2F;&#x2F;github.com&#x2F;quicklisp&#x2F;quicklisp-client&#x2F;issues&#x2F;167</a><p>Thanks for bringing this up!</div><br/><div id="36888797" class="c"><input type="checkbox" id="c-36888797" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888739">parent</a><span>|</span><a href="#36889117">next</a><span>|</span><label class="collapse" for="c-36888797">[-]</label><label class="expand" for="c-36888797">[4 more]</label></div><br/><div class="children"><div class="content">The reason for this is quite simple: portability. Quicklisp also uses plain TAR files to distribute dists. Why? Because quicklisp has a built-in TAR extractor written in 100% standard&#x2F;portable CL. This allows Quicklisp to run on just about everything, from your computer to real LispMs and operating systems like Mezzano.<p>TLS comes up every time someone discusses Quicklisp, but nobody bothers to go ahead and actually implement it portably (and even if they did, have fun with performance and side channel attacks, both of which require you to break portability to implement well for every platform you want to target).<p>If you would like a more stereotypical package manager, consider using CLPM. Though one of the big reasons to use CLPM is not encryption IMO, but versioning. ASDF supports locking versions of dependencies, but Quicklisp doesnt ever use this and instead constantly pushes latest of everything from git repositories. This IMO sucks a lot more than using plain HTTP given that this actually breaks code, whereas some MITM from plain HTTP connection to Quicklisp would require so much coordination (and specificity of target) that it&#x27;s just not in my threat model at all.</div><br/><div id="36890683" class="c"><input type="checkbox" id="c-36890683" checked=""/><div class="controls bullet"><span class="by">ristos</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888797">parent</a><span>|</span><a href="#36889098">next</a><span>|</span><label class="collapse" for="c-36890683">[-]</label><label class="expand" for="c-36890683">[1 more]</label></div><br/><div class="children"><div class="content">This does keep coming up, and it&#x27;s a few years old now. I think Quicklisp can easily still support https while supporting the older packages that are tar+http, which could easily be mirrored in a git repo. Quicklisp has unfortunately taken over the entire ecosystem, making it hard to use anything else, and you often need to depend on it to use a lot of tools in the ecosystem. It sort of reminds me of Systemd in that way.<p>I agree on the version pinning being a worse situation, and also not having something like &quot;node_modules&quot; for lisp. I haven&#x27;t tried CLPM since a while back, it was kind of hard to setup back then.<p>I have a little package manager thing, cl-micropm, that just uses Quicklisp to fetch everything via docker (should probably support podman too), and an .envrc file to tell ASDF to look in the project directory (a project-local node_modules-like folder called &quot;lisp-systems&quot;) for systems. That way I can pin my deps manually by picking the commits + git submodule in lisp-systems&#x2F;, and it&#x27;s isolated to my local project. I looked into using the Docker container to rewrite the requests to use https, bypassing whatever Quicklisp is doing, but I never got around to that.<p>I&#x27;m looking to switch it to something even simpler&#x2F;explicit though, cl-pm, that&#x27;ll only optionally need&#x2F;use Quicklisp via podman _only_ to figure out what the dependencies are, and then just have a function that uses wget&#x2F;curl&#x2F;git-pull to conveniently explicitly pull them in on request. That way you can decide to add a git mirror for an old http library, or pin a specific version, etc. It&#x27;s slightly more manual than Quicklisp or CLPM, not a big deal, but very easy for anyone with just a little bit of lisp knowledge to understand the whole thing in under an hour.</div><br/></div></div><div id="36889098" class="c"><input type="checkbox" id="c-36889098" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888797">parent</a><span>|</span><a href="#36890683">prev</a><span>|</span><a href="#36889951">next</a><span>|</span><label class="collapse" for="c-36889098">[-]</label><label class="expand" for="c-36889098">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Quicklisp doesnt ever use this and instead constantly pushes latest of everything from git repositories<p>Yeah, I didn&#x27;t recall off hand, but this was one of my main complaints with Quicklisp vs. other package managers I&#x27;ve used (for other ecosystems--not CL).<p>&gt; whereas some MITM from plain HTTP connection to Quicklisp would require so much coordination (and specificity of target) that it&#x27;s just not in my threat model at all<p>I hope you&#x27;re right, but it still seems like an <i>unnecessary</i> risk. Even if I can&#x27;t imagine a scenario where someone is able to MITM me (or, more likely, a server I&#x27;m deploying code to), there&#x27;s still the lingering feeling that it&#x27;s <i>possible</i>. I certainly wouldn&#x27;t download an executable over HTTP and run it, and downloading library code is fairly similar (although easier to inspect, at least).</div><br/></div></div></div></div><div id="36889117" class="c"><input type="checkbox" id="c-36889117" checked=""/><div class="controls bullet"><span class="by">atgreen</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888739">parent</a><span>|</span><a href="#36888797">prev</a><span>|</span><a href="#36889854">next</a><span>|</span><label class="collapse" for="c-36889117">[-]</label><label class="expand" for="c-36889117">[2 more]</label></div><br/><div class="children"><div class="content">Try ocicl instead of quicklisp.  System tarballs are hosted in an OCI registry, and are downloaded via TLS connections (obeying proxies).  Tarballs are signed and signatures are stored in the sigstore rekor transparency log for later inspection.  <a href="https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl">https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl</a></div><br/><div id="36889450" class="c"><input type="checkbox" id="c-36889450" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36889117">parent</a><span>|</span><a href="#36889854">next</a><span>|</span><label class="collapse" for="c-36889450">[-]</label><label class="expand" for="c-36889450">[1 more]</label></div><br/><div class="children"><div class="content">Just wanted to say I did see your other comment and am intrigued by ocicl. Thanks!</div><br/></div></div></div></div></div></div><div id="36889854" class="c"><input type="checkbox" id="c-36889854" checked=""/><div class="controls bullet"><span class="by">sussmannbaka</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888454">parent</a><span>|</span><a href="#36888739">prev</a><span>|</span><a href="#36888213">next</a><span>|</span><label class="collapse" for="c-36889854">[-]</label><label class="expand" for="c-36889854">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have some cons<p>I’m sure you do :°)</div><br/></div></div></div></div><div id="36888213" class="c"><input type="checkbox" id="c-36888213" checked=""/><div class="controls bullet"><span class="by">tgbugs</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36888454">prev</a><span>|</span><a href="#36888646">next</a><span>|</span><label class="collapse" for="c-36888213">[-]</label><label class="expand" for="c-36888213">[2 more]</label></div><br/><div class="children"><div class="content">For static builds, if you&#x27;re willing to run a slightly older version of sbcl daewok&#x27;s work on building and linking sbcl in a musl environment might be solution you&#x27;re looking  for. I&#x27;ve tried to port his patches to more recent versions but there are segfaults due to changes in upstream.<p><a href="https:&#x2F;&#x2F;www.timmons.dev&#x2F;posts&#x2F;static-executables-with-sbcl.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.timmons.dev&#x2F;posts&#x2F;static-executables-with-sbcl.h...</a>
<a href="https:&#x2F;&#x2F;www.timmons.dev&#x2F;posts&#x2F;static-executables-with-sbcl-v2.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.timmons.dev&#x2F;posts&#x2F;static-executables-with-sbcl-v...</a></div><br/><div id="36888420" class="c"><input type="checkbox" id="c-36888420" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888213">parent</a><span>|</span><a href="#36888646">next</a><span>|</span><label class="collapse" for="c-36888420">[-]</label><label class="expand" for="c-36888420">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I did see that, but I was scared off by having to apply patches :)</div><br/></div></div></div></div><div id="36888646" class="c"><input type="checkbox" id="c-36888646" checked=""/><div class="controls bullet"><span class="by">matrix12</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36888213">prev</a><span>|</span><a href="#36888225">next</a><span>|</span><label class="collapse" for="c-36888646">[-]</label><label class="expand" for="c-36888646">[3 more]</label></div><br/><div class="children"><div class="content">I will give you a cons.
<a href="https:&#x2F;&#x2F;cons.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;cons.io</a>
Gerbil&#x2F;Gambit scheme are fully static binary generating alternative to CL.</div><br/><div id="36888756" class="c"><input type="checkbox" id="c-36888756" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888646">parent</a><span>|</span><a href="#36888225">next</a><span>|</span><label class="collapse" for="c-36888756">[-]</label><label class="expand" for="c-36888756">[2 more]</label></div><br/><div class="children"><div class="content">I’ll take a look, thanks! My biggest concern with Scheme is that each implementation seems to have its own ecosystem due to subtle incompatibilities.<p>From an outsider’s perspective it seems a lot more fragmented than CL. Not necessarily a big deal if you have the libraries you want, but it gives me pause.</div><br/><div id="36889862" class="c"><input type="checkbox" id="c-36889862" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888756">parent</a><span>|</span><a href="#36888225">next</a><span>|</span><label class="collapse" for="c-36889862">[-]</label><label class="expand" for="c-36889862">[1 more]</label></div><br/><div class="children"><div class="content">R7RS, which Gambit (mostly?) supports, helps mitigate this by making library code more portable across implementations. Gambit, in particular, can also very easily take advantage of the wide variety of C libraries; it has one of the easiest, most integrated FFIs of all Scheme implementations.</div><br/></div></div></div></div></div></div><div id="36888225" class="c"><input type="checkbox" id="c-36888225" checked=""/><div class="controls bullet"><span class="by">mark_l_watson</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36888646">prev</a><span>|</span><a href="#36889369">next</a><span>|</span><label class="collapse" for="c-36888225">[-]</label><label class="expand" for="c-36888225">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for your write up. I am looking forward to the next installment.</div><br/><div id="36888431" class="c"><input type="checkbox" id="c-36888431" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888225">parent</a><span>|</span><a href="#36889369">next</a><span>|</span><label class="collapse" for="c-36888431">[-]</label><label class="expand" for="c-36888431">[1 more]</label></div><br/><div class="children"><div class="content">Thank <i>you</i> for your Lisp books!<p>I like your pragmatic approach of using Lisp where it makes sense and not being afraid to shell out to something else where appropriate (among many other nuggets of wisdom).</div><br/></div></div></div></div><div id="36889369" class="c"><input type="checkbox" id="c-36889369" checked=""/><div class="controls bullet"><span class="by">easeout</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36888225">prev</a><span>|</span><a href="#36888819">next</a><span>|</span><label class="collapse" for="c-36889369">[-]</label><label class="expand" for="c-36889369">[3 more]</label></div><br/><div class="children"><div class="content">Love your site&#x27;s CGA vibes.</div><br/><div id="36890710" class="c"><input type="checkbox" id="c-36890710" checked=""/><div class="controls bullet"><span class="by">distcs</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36889369">parent</a><span>|</span><a href="#36889456">next</a><span>|</span><label class="collapse" for="c-36890710">[-]</label><label class="expand" for="c-36890710">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m missing something. What about the site is giving CGA vibes?</div><br/></div></div><div id="36889456" class="c"><input type="checkbox" id="c-36889456" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36889369">parent</a><span>|</span><a href="#36890710">prev</a><span>|</span><a href="#36888819">next</a><span>|</span><label class="collapse" for="c-36889456">[-]</label><label class="expand" for="c-36889456">[1 more]</label></div><br/><div class="children"><div class="content">That is exactly what I was going for!</div><br/></div></div></div></div><div id="36888819" class="c"><input type="checkbox" id="c-36888819" checked=""/><div class="controls bullet"><span class="by">mrcode007</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36889369">prev</a><span>|</span><a href="#36887916">next</a><span>|</span><label class="collapse" for="c-36888819">[-]</label><label class="expand" for="c-36888819">[3 more]</label></div><br/><div class="children"><div class="content">SBCL supports static builds by saving core with runtime into an executable file you can then copy around at will.</div><br/><div id="36889116" class="c"><input type="checkbox" id="c-36889116" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36888819">parent</a><span>|</span><a href="#36887916">next</a><span>|</span><label class="collapse" for="c-36889116">[-]</label><label class="expand" for="c-36889116">[2 more]</label></div><br/><div class="children"><div class="content">Do they work across glibc verisons or musl libc? My understanding is that they do not.</div><br/><div id="36889503" class="c"><input type="checkbox" id="c-36889503" checked=""/><div class="controls bullet"><span class="by">mark254</span><span>|</span><a href="#36887744">root</a><span>|</span><a href="#36889116">parent</a><span>|</span><a href="#36887916">next</a><span>|</span><label class="collapse" for="c-36889503">[-]</label><label class="expand" for="c-36889503">[1 more]</label></div><br/><div class="children"><div class="content">I often use RHEL7-compatible binaries on RHEL8 and Debian (testing) machines, with no problems.</div><br/></div></div></div></div></div></div><div id="36887916" class="c"><input type="checkbox" id="c-36887916" checked=""/><div class="controls bullet"><span class="by">atgreen</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36888819">prev</a><span>|</span><a href="#36889619">next</a><span>|</span><label class="collapse" for="c-36887916">[-]</label><label class="expand" for="c-36887916">[1 more]</label></div><br/><div class="children"><div class="content">Check out ocicl as an alternative to quicklisp!</div><br/></div></div><div id="36889619" class="c"><input type="checkbox" id="c-36889619" checked=""/><div class="controls bullet"><span class="by">CodeCompost</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36887916">prev</a><span>|</span><a href="#36888712">next</a><span>|</span><label class="collapse" for="c-36889619">[-]</label><label class="expand" for="c-36889619">[1 more]</label></div><br/><div class="children"><div class="content">Small typo enusre =&gt; ensure</div><br/></div></div><div id="36888712" class="c"><input type="checkbox" id="c-36888712" checked=""/><div class="controls bullet"><span class="by">keithalewis</span><span>|</span><a href="#36887744">parent</a><span>|</span><a href="#36889619">prev</a><span>|</span><a href="#36890783">next</a><span>|</span><label class="collapse" for="c-36888712">[-]</label><label class="expand" for="c-36888712">[1 more]</label></div><br/><div class="children"><div class="content">I cdr car less about your cons. Seriously though, mad props for being diligent enough to spend your attention on this. There is a lot to learn from people who came before us and build on that.</div><br/></div></div></div></div><div id="36890783" class="c"><input type="checkbox" id="c-36890783" checked=""/><div class="controls bullet"><span class="by">massimosgrelli</span><span>|</span><a href="#36887744">prev</a><span>|</span><a href="#36887792">next</a><span>|</span><label class="collapse" for="c-36890783">[-]</label><label class="expand" for="c-36890783">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry about my basic question. Back in the 80s, AI was betting on Lisp machines — <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lisp_machine" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lisp_machine</a> — now, of course obsolete.
Is Lisp still relevant in the AI space?</div><br/></div></div><div id="36887792" class="c"><input type="checkbox" id="c-36887792" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#36890783">prev</a><span>|</span><a href="#36887220">next</a><span>|</span><label class="collapse" for="c-36887792">[-]</label><label class="expand" for="c-36887792">[3 more]</label></div><br/><div class="children"><div class="content">I use Clojure at work but wow do I miss just about everything about Common Lisp whenever I have to debug anything or want performant code. Being able to be in nested errors and click at any part of the stack to inspect lexical bindings is extremely useful, and more importantly, clicking on an object then pushing M-&lt;RET&gt; to copy it to my REPL is much nicer than what Clojure offers (tap&gt;, which I consider a glorified pretty printer even if you use tools like Portal).<p>As for performance, well, Common Lisp lets you statically type things, and SBCL can emit really efficient code if you do this. I find it helpful to run DISASSEMBLE on my own code to see what exactly is being emitted and optimize from there. And more importantly, packages like SB-SIMD and Loopus are a god send for any number crunching application.</div><br/><div id="36889192" class="c"><input type="checkbox" id="c-36889192" checked=""/><div class="controls bullet"><span class="by">maxwelljoslyn</span><span>|</span><a href="#36887792">parent</a><span>|</span><a href="#36888429">next</a><span>|</span><label class="collapse" for="c-36889192">[-]</label><label class="expand" for="c-36889192">[1 more]</label></div><br/><div class="children"><div class="content">This nicely summarizes some of my frustrations with using Clojure for my master&#x27;s thesis. I&#x27;m not unhappy with the choice. Clojure allows such a juicy crossover between &quot;everything is a key-value map, mannn&quot; and &quot;If it has :quack key set to true, treat it like a duck&quot; which works really well for entity-component-system game-design-y things.<p>but the development story in Common Lisp ... and my gawd, the CONDITION SYSTEM ... were things that I sorely missed for the last year. and I&#x27;m not even that experienced of a CL hacker. It just grew on me so quickly. If only CLOS and the primitive data types in CL played together more nicely than they seem to.</div><br/></div></div><div id="36888429" class="c"><input type="checkbox" id="c-36888429" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#36887792">parent</a><span>|</span><a href="#36889192">prev</a><span>|</span><a href="#36887220">next</a><span>|</span><label class="collapse" for="c-36888429">[-]</label><label class="expand" for="c-36888429">[1 more]</label></div><br/><div class="children"><div class="content">You should look at flowstorm for Clojure. It lets you step through and back from a function and you can send maps to the repl with their functions.</div><br/></div></div></div></div><div id="36887220" class="c"><input type="checkbox" id="c-36887220" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#36887792">prev</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36887220">[-]</label><label class="expand" for="c-36887220">[75 more]</label></div><br/><div class="children"><div class="content">Steel Bank Common Lisp is the workhorse which led me to build profitable software companies. I don&#x27;t think I would be as productive without it. The repl driven workflow is amazing and the lisp images are rock solid and highly performant.</div><br/><div id="36887997" class="c"><input type="checkbox" id="c-36887997" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36887220">parent</a><span>|</span><a href="#36887245">next</a><span>|</span><label class="collapse" for="c-36887997">[-]</label><label class="expand" for="c-36887997">[1 more]</label></div><br/><div class="children"><div class="content">Care to share the companies for those curious?</div><br/></div></div><div id="36887245" class="c"><input type="checkbox" id="c-36887245" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#36887220">parent</a><span>|</span><a href="#36887997">prev</a><span>|</span><a href="#36887682">next</a><span>|</span><label class="collapse" for="c-36887245">[-]</label><label class="expand" for="c-36887245">[4 more]</label></div><br/><div class="children"><div class="content">It looks awesome, but I&#x27;m too lazy as of today to go back to Emacs. I usually just use VSCode close to the defaults for my (mostly) Python and JavaScript development. I don&#x27;t code full time, since I&#x27;m on a CTO role.</div><br/><div id="36887593" class="c"><input type="checkbox" id="c-36887593" checked=""/><div class="controls bullet"><span class="by">nbf_1995</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36887245">parent</a><span>|</span><a href="#36887289">next</a><span>|</span><label class="collapse" for="c-36887593">[-]</label><label class="expand" for="c-36887593">[1 more]</label></div><br/><div class="children"><div class="content">You may be interested in <a href="https:&#x2F;&#x2F;github.com&#x2F;nobody-famous&#x2F;alive">https:&#x2F;&#x2F;github.com&#x2F;nobody-famous&#x2F;alive</a> which brings the power of slime to vscode (Mostly, it&#x27;s relatively new and missing some features, but getting better all the time)</div><br/></div></div><div id="36887289" class="c"><input type="checkbox" id="c-36887289" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36887245">parent</a><span>|</span><a href="#36887593">prev</a><span>|</span><a href="#36887682">next</a><span>|</span><label class="collapse" for="c-36887289">[-]</label><label class="expand" for="c-36887289">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if you&#x27;re interested in Sublime Text or not but <a href="https:&#x2F;&#x2F;github.com&#x2F;s-clerc&#x2F;slyblime">https:&#x2F;&#x2F;github.com&#x2F;s-clerc&#x2F;slyblime</a> is pretty good. VS Code also has Alive which I heard is good although I don&#x27;t use Electron apps.</div><br/><div id="36887378" class="c"><input type="checkbox" id="c-36887378" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36887289">parent</a><span>|</span><a href="#36887682">next</a><span>|</span><label class="collapse" for="c-36887378">[-]</label><label class="expand" for="c-36887378">[1 more]</label></div><br/><div class="children"><div class="content">Thanks a lot! It does indeed look good.<p>Btw, what made you choose Common Lisp instead of Scheme (Guile, Racket, etc) or Clojure? What made it more business effective? Genuine curiosity :)</div><br/></div></div></div></div></div></div><div id="36888648" class="c"><input type="checkbox" id="c-36888648" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">parent</a><span>|</span><a href="#36887682">prev</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36888648">[-]</label><label class="expand" for="c-36888648">[68 more]</label></div><br/><div class="children"><div class="content">&gt; The repl driven workflow is amazing and the lisp images are rock solid and highly performant.<p>do people not realize that basically everything vm&#x2F;interpreted language has a repl these days?<p><a href="https:&#x2F;&#x2F;www.digitalocean.com&#x2F;community&#x2F;tutorials&#x2F;java-repl-jshell" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.digitalocean.com&#x2F;community&#x2F;tutorials&#x2F;java-repl-j...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;waf&#x2F;CSharpRepl">https:&#x2F;&#x2F;github.com&#x2F;waf&#x2F;CSharpRepl</a><p><a href="https:&#x2F;&#x2F;pub.dev&#x2F;packages&#x2F;interactive" rel="nofollow noreferrer">https:&#x2F;&#x2F;pub.dev&#x2F;packages&#x2F;interactive</a><p>not to mention ruby, python, php, lua<p>hell even c++ has a janky repl <a href="https:&#x2F;&#x2F;github.com&#x2F;root-project&#x2F;cling">https:&#x2F;&#x2F;github.com&#x2F;root-project&#x2F;cling</a><p>edit: i get downvoted by the lisp crowd every time i bring up that the repl isn&#x27;t a differentiating feature anymore :shrug:</div><br/><div id="36888686" class="c"><input type="checkbox" id="c-36888686" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888648">parent</a><span>|</span><a href="#36888731">next</a><span>|</span><label class="collapse" for="c-36888686">[-]</label><label class="expand" for="c-36888686">[26 more]</label></div><br/><div class="children"><div class="content">Of course people &quot;realise&quot; this. But those REPLs are not actually REPLs. They are interactive language prompts. They aren&#x27;t actually REPLs. As the joke goes, Python doesn&#x27;t have a REPL: it lacks READ, EVAL, PRINT and LOOP.<p>Being able to type in code and have it evaluated one line at a time isn&#x27;t a REPL.</div><br/><div id="36888800" class="c"><input type="checkbox" id="c-36888800" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888686">parent</a><span>|</span><a href="#36889736">next</a><span>|</span><label class="collapse" for="c-36888800">[-]</label><label class="expand" for="c-36888800">[24 more]</label></div><br/><div class="children"><div class="content">i have no idea what subtle or nuanced distinction you&#x27;re trying to strike so what exactly do you imagine is the difference between a lisp repl and a python repl?<p>Edit: people that aren&#x27;t familiar with python (or how interpreters work in general) don&#x27;t seem to understand that being able to poke and prod the runtime is entirely a function of the runtime, not the language. In cpython you can absolutely do anything you want to the program state, all the way up to, and including, manually push&#x2F;pop from the interpreter&#x27;s value stack (to say nothing of moving up and down the frame stack), mutating owned data, redefining functions, classes, modules, etc. You can even, again at runtime, parse, to AST, and compile source to get macro-like functionally. It&#x27;s not as clean as in lisp but it 100% gets the job done.</div><br/><div id="36890684" class="c"><input type="checkbox" id="c-36890684" checked=""/><div class="controls bullet"><span class="by">ghfwlc</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888800">parent</a><span>|</span><a href="#36890097">next</a><span>|</span><label class="collapse" for="c-36890684">[-]</label><label class="expand" for="c-36890684">[1 more]</label></div><br/><div class="children"><div class="content">Restarting from the debugger keeps state without third party Python hacks that you mention. In this example Python increments x twice, Lisp just once:<p><pre><code>  &gt;&gt;&gt; x = 0
  &gt;&gt;&gt; def f():
  ...     global x # yuck!
  ...     x += 1
  ... 
  &gt;&gt;&gt; def g(y):
  ...     h()
  ... 
  &gt;&gt;&gt; 
  &gt;&gt;&gt; g(f())
  Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;&lt;stdin&gt;&quot;, line 2, in g
  NameError: name &#x27;h&#x27; is not defined
  &gt;&gt;&gt; 
  &gt;&gt;&gt; def h(): pass
  ... 
  &gt;&gt;&gt; g(f())
  &gt;&gt;&gt; 
  &gt;&gt;&gt; x
  2

</code></pre>
Versus:<p><pre><code>  * (setf x 0)
  * (defun f() (incf x))
  * (defun g(y) (h))
  * (g(f))

  debugger invoked on a UNDEFINED-FUNCTION in thread
  #&lt;THREAD &quot;main thread&quot; RUNNING {1001878103}&gt;:
    The function COMMON-LISP-USER::H is undefined.

  Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

  restarts (invokable by number or by possibly-abbreviated name):
    0: [CONTINUE      ] Retry calling H.
    1: [USE-VALUE     ] Call specified function.
    2: [RETURN-VALUE  ] Return specified values.
    3: [RETURN-NOTHING] Return zero values.
    4: [ABORT         ] Exit debugger, returning to top level.

  (&quot;undefined function&quot;)
  0] (defun h() nil)
  ; No debug variables for current frame: using EVAL instead of EVAL-IN-FRAME.
  H
  0] 0
  NIL
  * x
  1</code></pre></div><br/></div></div><div id="36890097" class="c"><input type="checkbox" id="c-36890097" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888800">parent</a><span>|</span><a href="#36890684">prev</a><span>|</span><a href="#36888863">next</a><span>|</span><label class="collapse" for="c-36890097">[-]</label><label class="expand" for="c-36890097">[11 more]</label></div><br/><div class="children"><div class="content">How does it look like in Python? In Lisp:<p><pre><code>  CL-USER 43 &gt; (+ 1 (foo 20))

  Error: Undefined operator FOO in form (FOO 20).
    1 (continue) Try invoking FOO again.
    2 Return some values from the form (FOO 20).
    3 Try invoking something other than FOO with the same arguments.
    4 Set the symbol-function of FOO to another function.
    5 Set the macro-function of FOO to another function.
    6 (abort) Return to top loop level 0.

  Type :b for backtrace or :c &lt;option number&gt; to proceed.
  Type :bug-form &quot;&lt;subject&gt;&quot; for a bug report template or :? for other options.

  CL-USER 44 : 1 &gt; (defun foo (a) (+ a 21))
  FOO

  CL-USER 45 : 1 &gt; :c 1
  42
</code></pre>
Note that we are not in some debug mode, to get this functionality. It also works for compiled code.<p>Lisp detects that FOO is undefined. We get a clear error message.<p>Lisp then offers me a list of restarts, how to continue.<p>It then displays a REPL one level deep in an error.<p>I then define the missing function.<p>Then I tell Lisp to use the first restart, to try to invoke FOO again. We don&#x27;t want to start from scratch, we want to continue the computation.<p>Lisp then is able to complete the computation, since FOO is available now.</div><br/><div id="36890187" class="c"><input type="checkbox" id="c-36890187" checked=""/><div class="controls bullet"><span class="by">sireat</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890097">parent</a><span>|</span><a href="#36890124">next</a><span>|</span><label class="collapse" for="c-36890187">[-]</label><label class="expand" for="c-36890187">[4 more]</label></div><br/><div class="children"><div class="content">Hmm, what advantage does Lisp offer here over Python?<p><pre><code>  &gt;&gt;&gt; 1 + foo(20)
  Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  NameError: name &#x27;foo&#x27; is not defined
  &gt;&gt;&gt; def foo(a):
  ... return a + 21
    File &quot;&lt;stdin&gt;&quot;, line 2
      return a + 21
           ^
  IndentationError: expected an indented block
  &gt;&gt;&gt; def foo(a):
  ...   return a + 21
  ...
  &gt;&gt;&gt; 1 + foo(20)
  42
  &gt;&gt;&gt;
</code></pre>
Mind the hilarious indentation error, as I had not touched the old-school REPL in ages.<p>In normal day to day operations, I do the same thing daily with Jupyter Notebooks. I get access to as much state as I need.<p>With notebooks workflow it is normal to forget to define something and then redefine in the next cell. You could redefine function signatures etc. Ideally then you move cells in the correct order so that code can be used as Run All.<p>I &quot;feel&quot; ridiculously productive in VS Code with full Notebook support + copilot. I can work across multiple knowledge domains with ease (ETL across multiple database technologies, NLP-ML, visualization, web scraping, etc)<p>Underneath it is same as working in old school Python REPL just with more scaffolding.</div><br/><div id="36890762" class="c"><input type="checkbox" id="c-36890762" checked=""/><div class="controls bullet"><span class="by">momentoftop</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890187">parent</a><span>|</span><a href="#36890492">next</a><span>|</span><label class="collapse" for="c-36890762">[-]</label><label class="expand" for="c-36890762">[1 more]</label></div><br/><div class="children"><div class="content">I have been playing again with CL recently and am doing some trivial web-scraping of an old internet forum. I don&#x27;t use a REPL directly, but just have a bunch of code snippets in a lisp file that I tell my editor to evaluate (similar to Jupyter?). I haven&#x27;t bothered doing any exception (condition) handling, and so this morning I found this in a new window:<p><pre><code>   Condition USOCKET:TIMEOUT-ERROR was signalled.
      [Condition of type USOCKET:TIMEOUT-ERROR]

   Restarts:
    0: [RETRY-REQUEST] Retry the same request.
    1: [RETRY-INSECURE] Retry the same request without checking for SSL certificate validity.
    2: [RETRY] Retry SLIME interactive evaluation request.
    3: [*ABORT] Return to SLIME&#x27;s top level.
    4: [ABORT] abort thread (#&lt;THREAD tid=17291 &quot;worker&quot; RUNNING {1001088003}&gt;)
</code></pre>
plus the backtrace. This is in a loop that&#x27;s already crawled a load of webpages and has some accumulated some state. I don&#x27;t want a full redo (2), so I just press 0. The request succeeds this time and it continues as if nothing happened.</div><br/></div></div><div id="36890492" class="c"><input type="checkbox" id="c-36890492" checked=""/><div class="controls bullet"><span class="by">kgwgk</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890187">parent</a><span>|</span><a href="#36890762">prev</a><span>|</span><a href="#36890397">next</a><span>|</span><label class="collapse" for="c-36890492">[-]</label><label class="expand" for="c-36890492">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hmm, what advantage does Lisp offer here over Python?<p>It does have a clear advantage if instead of<p><pre><code>    (+ 1 (foo 20))
</code></pre>
we were doing<p><pre><code>    (+ (long-computation-answering-the-ultimate-question-of-life-the-universe-and-everything)
       (foo 20))
</code></pre>
(Reminder: we&#x27;re dicussing Common Lisp here.)</div><br/></div></div><div id="36890397" class="c"><input type="checkbox" id="c-36890397" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890187">parent</a><span>|</span><a href="#36890492">prev</a><span>|</span><a href="#36890124">next</a><span>|</span><label class="collapse" for="c-36890397">[-]</label><label class="expand" for="c-36890397">[1 more]</label></div><br/><div class="children"><div class="content">From what I see in your example, you invoke the form again. In Common Lisp you don&#x27;t need that. You can stay in a computation and fix&amp;resume from within.</div><br/></div></div></div></div><div id="36890124" class="c"><input type="checkbox" id="c-36890124" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890097">parent</a><span>|</span><a href="#36890187">prev</a><span>|</span><a href="#36888863">next</a><span>|</span><label class="collapse" for="c-36890124">[-]</label><label class="expand" for="c-36890124">[6 more]</label></div><br/><div class="children"><div class="content">&gt;Note that we are not in some debug mode, to get this functionality.<p>Jesus Christ I swear it&#x27;s like you ascribe mysterious powers to the parens. Do you think the parens give you the ability to travel through time or reverse the pc or what? Okay it&#x27;s not in a debug mode but it&#x27;s in a &quot;debug mode&quot;. Like seriously tell me how you think this works if it&#x27;s not effectively catching&#x2F;trapping some sigkill or something that&#x27;s the equivalent thereof?<p>I have never in my life met this kind of intransigence on just manifestly obvious things.</div><br/><div id="36890463" class="c"><input type="checkbox" id="c-36890463" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890124">parent</a><span>|</span><a href="#36888863">next</a><span>|</span><label class="collapse" for="c-36890463">[-]</label><label class="expand" for="c-36890463">[5 more]</label></div><br/><div class="children"><div class="content">Common Lisp programs run by default in a way that calls to undefined functions are detected.<p>Here the Lisp simply tries to look up the function object from the symbol. There is no function, so it signals a condition (aka exception). The default exception handler gets called (without unwinding the stack). This handler prints the restarts and calls another REPL. I define the function -&gt; the symbol now has a function definition. We then resume and Lisp tries again to get the function definition. The computation continues where we were.<p>That&#x27;s the DEFAULT behavior you&#x27;ll find in Common Lisp implementations.</div><br/><div id="36890569" class="c"><input type="checkbox" id="c-36890569" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890463">parent</a><span>|</span><a href="#36888863">next</a><span>|</span><label class="collapse" for="c-36890569">[-]</label><label class="expand" for="c-36890569">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Common Lisp programs run by default in a way that calls to undefined functions are detected.<p>Cool so what you&#x27;re telling me is that by default every single function call incurs the unavoidable overhead of indirecting through some lookup for a function bound to a symbol. And you&#x27;re <i>proud</i> of this?</div><br/><div id="36890735" class="c"><input type="checkbox" id="c-36890735" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890569">parent</a><span>|</span><a href="#36890698">next</a><span>|</span><label class="collapse" for="c-36890735">[-]</label><label class="expand" for="c-36890735">[1 more]</label></div><br/><div class="children"><div class="content">I thought you know Lisp? Now you are surprised that Lisp often looks up functions via symbols -&gt; aka &quot;late binding&quot;? How can that be? That&#x27;s one of the basic Lisp features.<p>Next you can find out what optimizing compilers do to avoid it, where possible or where wanted.</div><br/></div></div><div id="36890698" class="c"><input type="checkbox" id="c-36890698" checked=""/><div class="controls bullet"><span class="by">ghfwlc</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890569">parent</a><span>|</span><a href="#36890735">prev</a><span>|</span><a href="#36888863">next</a><span>|</span><label class="collapse" for="c-36890698">[-]</label><label class="expand" for="c-36890698">[2 more]</label></div><br/><div class="children"><div class="content">Compared to Python, Common Lisp hardly has any performance issues.</div><br/><div id="36890778" class="c"><input type="checkbox" id="c-36890778" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890698">parent</a><span>|</span><a href="#36888863">next</a><span>|</span><label class="collapse" for="c-36890778">[-]</label><label class="expand" for="c-36890778">[1 more]</label></div><br/><div class="children"><div class="content">Okay well when pytorch, tensorflow, pandas, Django, flask, numpy, networks, script, xgboost, matplotlib, spacy, scrapy, selenium get ported to lisp, I&#x27;ll consider switching (only consider though since the are probably at least another 20 python python packages that I couldn&#x27;t do my job without).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36888863" class="c"><input type="checkbox" id="c-36888863" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888800">parent</a><span>|</span><a href="#36890097">prev</a><span>|</span><a href="#36889298">next</a><span>|</span><label class="collapse" for="c-36888863">[-]</label><label class="expand" for="c-36888863">[4 more]</label></div><br/><div class="children"><div class="content">In TFA, go to the “Try this in your favorite repl”, try that in your “repl” and that would be the fine distinction you’re missing.</div><br/><div id="36888890" class="c"><input type="checkbox" id="c-36888890" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888863">parent</a><span>|</span><a href="#36889298">next</a><span>|</span><label class="collapse" for="c-36888890">[-]</label><label class="expand" for="c-36888890">[3 more]</label></div><br/><div class="children"><div class="content">&gt;The answer to that question is the differentiating point of repl-driven programming. In an old-fashioned Lisp or Smalltalk environment, the break in foo drops you into a breakloop.<p>do you want me to show you how to do this in a python repl? it&#x27;s literally just breaking on exception...</div><br/></div></div></div></div><div id="36889298" class="c"><input type="checkbox" id="c-36889298" checked=""/><div class="controls bullet"><span class="by">FPGAhacker</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888800">parent</a><span>|</span><a href="#36888863">prev</a><span>|</span><a href="#36889736">next</a><span>|</span><label class="collapse" for="c-36889298">[-]</label><label class="expand" for="c-36889298">[7 more]</label></div><br/><div class="children"><div class="content">Can you connect to a running server or other running application, inspect live in memory data, change live in memory data, redefine functions and classes and have those changes take immediate effect without restarting the server or app?<p>I think that is that is the big difference.<p>It’s a triple edged sword bonded to a double barreled shotgun though, and the very antithesis of the idea of functional programming vs mutable state.</div><br/><div id="36889329" class="c"><input type="checkbox" id="c-36889329" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889298">parent</a><span>|</span><a href="#36889736">next</a><span>|</span><label class="collapse" for="c-36889329">[-]</label><label class="expand" for="c-36889329">[6 more]</label></div><br/><div class="children"><div class="content">&gt;Can you connect to a running server or other running application, inspect live in memory data, change live in memory data, redefine functions and classes and have those changes take immediate effect without restarting the server or app?<p>The answer to all of these things, at least in python, is emphatically yes. I do this absolutely all the time. You can debug from one process to another if you&#x27;ve loaded the right hooks. You don&#x27;t need to take my word for it or even try to do it; you just need to reason a fortiori: python can do it because it&#x27;s an interpreter with a boxed calling convention and managed memory, just like lisp interpreters.<p>It&#x27;s amazing: people will die on this hill for some reason but lisp isn&#x27;t some kind of mysterious system that was and continues to be beyond us mere mortal language&#x2F;runtime designers. the good ideas in lisp were recognized as good ideas and then incorporated and improved upon.</div><br/><div id="36889832" class="c"><input type="checkbox" id="c-36889832" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889329">parent</a><span>|</span><a href="#36889493">next</a><span>|</span><label class="collapse" for="c-36889832">[-]</label><label class="expand" for="c-36889832">[3 more]</label></div><br/><div class="children"><div class="content">The answer to all these things should be &quot;just doesn&#x27;t work in practise&quot;, not for real programs anyways. Unlike Lisp, Python doesn&#x27;t lean itself well to this mode of development.<p>Primitive CLI-like tinkering, figuring out language features, calc-like usage - maybe. But not a single time in 15 years of doing Python across the industry I saw anybody using these features for serious program development, or live coding, or REPL-driven development.</div><br/><div id="36889936" class="c"><input type="checkbox" id="c-36889936" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889832">parent</a><span>|</span><a href="#36890622">next</a><span>|</span><label class="collapse" for="c-36889936">[-]</label><label class="expand" for="c-36889936">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Primitive CLI-like tinkering, figuring out language features, calc-like usage - maybe. But not a single time in 15 years of doing Python across the industry I saw anybody using these features for serious program development, or live coding, or REPL-driven development.<p>I swear you people are like ostriches in the sand over this - Django, pytest, fastapi, pytorch, Jax, <i>all</i> use these features and more. I work on DL compilers and I use those features every day - python is a fantastic edsl host for whatever IR you can dream of. So just because you&#x27;re in some sector&#x2F;area&#x2F;job that doesn&#x27;t put you in contact with this kind of python dev doesn&#x27;t mean it&#x27;s not happening, doesn&#x27;t mean that python doesn&#x27;t support it, doesn&#x27;t mean it&#x27;s an accidentally supported API (as if such a thing could even be possible).<p>Really what this convo is doing is underscoring for me how there really is nothing more to be learned from lisp - I had a lingering doubt that I&#x27;d missed some aspect but you guys are all repeating the same thing over and over. So thanks!</div><br/></div></div><div id="36890622" class="c"><input type="checkbox" id="c-36890622" checked=""/><div class="controls bullet"><span class="by">darthrupert</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889832">parent</a><span>|</span><a href="#36889936">prev</a><span>|</span><a href="#36889493">next</a><span>|</span><label class="collapse" for="c-36890622">[-]</label><label class="expand" for="c-36890622">[1 more]</label></div><br/><div class="children"><div class="content">Am I some kind of a python unicorn? I do those things with python just about every time I write new python code.<p>The thing Common Lisp does that python doesn&#x27;t (so far) is outputting well-performing code.</div><br/></div></div></div></div><div id="36889493" class="c"><input type="checkbox" id="c-36889493" checked=""/><div class="controls bullet"><span class="by">FPGAhacker</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889329">parent</a><span>|</span><a href="#36889832">prev</a><span>|</span><a href="#36889736">next</a><span>|</span><label class="collapse" for="c-36889493">[-]</label><label class="expand" for="c-36889493">[2 more]</label></div><br/><div class="children"><div class="content">Can you give me some links?  I don’t program clojure much these days but I’ve never found anything comparable in python.</div><br/><div id="36889524" class="c"><input type="checkbox" id="c-36889524" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889493">parent</a><span>|</span><a href="#36889736">next</a><span>|</span><label class="collapse" for="c-36889524">[-]</label><label class="expand" for="c-36889524">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;help&#x2F;pycharm&#x2F;remote-debugging-with-product.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jetbrains.com&#x2F;help&#x2F;pycharm&#x2F;remote-debugging-with...</a><p>I need to be very clear so that no one misunderstands: this is not proprietary pycharm functionality - this is all due to to sys.settrace and the pydev debug protocol<p><a href="https:&#x2F;&#x2F;www.pydev.org&#x2F;manual_adv_remote_debugger.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pydev.org&#x2F;manual_adv_remote_debugger.html</a><p>So you can hook this up completely by yourself with some work but lucky for you and me pycharm makes it effortless.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36889736" class="c"><input type="checkbox" id="c-36889736" checked=""/><div class="controls bullet"><span class="by">actuallyalys</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888686">parent</a><span>|</span><a href="#36888800">prev</a><span>|</span><a href="#36888731">next</a><span>|</span><label class="collapse" for="c-36889736">[-]</label><label class="expand" for="c-36889736">[1 more]</label></div><br/><div class="children"><div class="content">IMO, the downside with the term REPL is that if you don&#x27;t understand the specific Lisp definitions of the terms, it sounds like any other interactive execution environment.</div><br/></div></div></div></div><div id="36888731" class="c"><input type="checkbox" id="c-36888731" checked=""/><div class="controls bullet"><span class="by">Calamitous</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888648">parent</a><span>|</span><a href="#36888686">prev</a><span>|</span><a href="#36888727">next</a><span>|</span><label class="collapse" for="c-36888731">[-]</label><label class="expand" for="c-36888731">[1 more]</label></div><br/><div class="children"><div class="content">&gt; i get downvoted by the lisp crowd every time i bring up that the repl isn&#x27;t a differentiating feature anymore<p>I’d suggest it has more to do with tone than content.</div><br/></div></div><div id="36888727" class="c"><input type="checkbox" id="c-36888727" checked=""/><div class="controls bullet"><span class="by">xbpx</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888648">parent</a><span>|</span><a href="#36888731">prev</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36888727">[-]</label><label class="expand" for="c-36888727">[15 more]</label></div><br/><div class="children"><div class="content">A REPL isn&#x27;t just a REPL. You are comparing modern day Toyota Corollas to a Spaceship sent from the future to the 80s. One is just different level radical.
At least when it&#x27;s baked by SLY or SLIME</div><br/><div id="36888818" class="c"><input type="checkbox" id="c-36888818" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888727">parent</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36888818">[-]</label><label class="expand" for="c-36888818">[14 more]</label></div><br/><div class="children"><div class="content">here is the list of slime features on the slime webpage<p>&gt;Code evaluation, compilation, and macroexpansion.<p>&gt;Online documentation (describe, apropos, hyperspec).<p>&gt;Definition finding (aka Meta-Point aka M-.).<p>&gt;Symbol and package name completion.<p>&gt;Automatic macro indentation based on &amp;body.<p>&gt;Cross-reference interface (WHO-CALLS, etc).<p><a href="https:&#x2F;&#x2F;slime.common-lisp.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;slime.common-lisp.dev&#x2F;</a><p>and i&#x27;m still wondering which of these things i can&#x27;t do in a python repl? note macroexpansion doesn&#x27;t count because that&#x27;s not a dimension of the repl.</div><br/><div id="36889963" class="c"><input type="checkbox" id="c-36889963" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888818">parent</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36889963">[-]</label><label class="expand" for="c-36889963">[13 more]</label></div><br/><div class="children"><div class="content">&gt;Code evaluation, compilation<p>I couldn’t debug the following in pycharm and add the missing function at runtime, or could i?<p><pre><code>    def interactively_writing_code():
        this_doesnt_exist_yet()

    interactively_writing_code()
</code></pre>
I don’t think i can patch a function at runtime without losing state either in python - the act of redefining the function causes the variables to be reset but in lisp the bindings are untouched.</div><br/><div id="36890021" class="c"><input type="checkbox" id="c-36890021" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889963">parent</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36890021">[-]</label><label class="expand" for="c-36890021">[12 more]</label></div><br/><div class="children"><div class="content">I just did it - it works perfectly fine. Debug-run your code, an exception will be thrown at the call site, step up one frame from the exception (ie module level), define the missing function, call again and it succeeds - all without leaving the same repl instance. Don&#x27;t believe me? Try it.<p>I&#x27;ll say it again: you guys are in plain denial not about python or lisp as languages but about <i>how interpreters work</i>. There&#x27;s just nothing more to be said about this dimension of it.</div><br/><div id="36890562" class="c"><input type="checkbox" id="c-36890562" checked=""/><div class="controls bullet"><span class="by">versteegen</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890021">parent</a><span>|</span><a href="#36890406">next</a><span>|</span><label class="collapse" for="c-36890562">[-]</label><label class="expand" for="c-36890562">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s being asked is, after defining the missing function, whether it&#x27;s possible to clear the exception and continue the execution without having to restart from the beginning. This is very useful when you hit an exception after 10 minutes of execution. (This is a real usecase which would have saved me untold hours.)<p>I hope it&#x27;s possible somehow, but if you just load pdb (e.g. with %pdb in ipython), pdb is entered in post-mortem mode, from which it&#x27;s impossible to modify code&#x2F;data and resume execution. Setting a breakpoint (or pdb.set_trace()) would requiring knowing about the bug ahead of time. Does it only work when interrupting with a remote debugger rather than on exception?<p>However, it wouldn&#x27;t be possible if the interpreter unwinds the stack looking for exception handlers before finding that there is none? In other languages&#x2F;VMs such as SBCL the runtime can look up the stack for handlers, and invoke the debugger before destructively unwinding.</div><br/><div id="36890673" class="c"><input type="checkbox" id="c-36890673" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890562">parent</a><span>|</span><a href="#36890406">next</a><span>|</span><label class="collapse" for="c-36890673">[-]</label><label class="expand" for="c-36890673">[2 more]</label></div><br/><div class="children"><div class="content">The other guy up above claims this is a feature unique to calling functions, rather than all error states, and that the lisp runtime specifically guards against this. If that&#x27;s the case then my answer is very simple: it would be trivial to guard function calls (all function calls) to achieve the exact same functionality in python. I&#x27;m in bed but it would literally take me 5 minutes (I would hook eval of the CALL_FUNCTION opcode). Now it would be asinine because it&#x27;s a six-sigma event that I call a function that isn&#x27;t defined. On the other hand, setting a breakpoint and redefining functions as you go works perfectly well and is the common case and simultaneously the kind of &quot;repl driven development&quot; discussed all up and down this thread.</div><br/><div id="36890749" class="c"><input type="checkbox" id="c-36890749" checked=""/><div class="controls bullet"><span class="by">versteegen</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890673">parent</a><span>|</span><a href="#36890406">next</a><span>|</span><label class="collapse" for="c-36890749">[-]</label><label class="expand" for="c-36890749">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, you&#x27;re very helpful despite this raging flame war. I&#x27;m glad to hear you can hook opcodes like that, then you really can do anything. And I really need to give &quot;set a defensive breakpoint and then step through the function&quot; an honest go. Now that you say it, I realise I haven&#x27;t.</div><br/></div></div></div></div></div></div><div id="36890406" class="c"><input type="checkbox" id="c-36890406" checked=""/><div class="controls bullet"><span class="by">yaantc</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890021">parent</a><span>|</span><a href="#36890562">prev</a><span>|</span><a href="#36890501">next</a><span>|</span><label class="collapse" for="c-36890406">[-]</label><label class="expand" for="c-36890406">[3 more]</label></div><br/><div class="children"><div class="content">Calling again and continuing are not the same thing. Sure, with the above trivial example it is. But if the parent function has non idempotent code before calling the missing function (like doing some global change &#x2F; side effects), then calling again will give a different result than just continuing from the current state.<p>So is it possible to define the missing function and continue from the same state in Python? I don&#x27;t think so, but I&#x27;m not a heavy Python user (just for small&#x2F;medium scripts).</div><br/><div id="36890512" class="c"><input type="checkbox" id="c-36890512" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890406">parent</a><span>|</span><a href="#36890501">next</a><span>|</span><label class="collapse" for="c-36890512">[-]</label><label class="expand" for="c-36890512">[2 more]</label></div><br/><div class="children"><div class="content">&gt;So is it possible to define the missing function and continue from the same state in Python? I don&#x27;t think so, but I&#x27;m not a heavy Python user<p>This is a pointless debate - someone has to catch the exception, save caller registers, handle the exception (if there&#x27;s a handler) or reraise. Either you have to do it (by putting a try except there) or your runtime has to be always defensively saving registers or <i>something</i>. Lisp isn&#x27;t magic, it&#x27;s just a point on trade-off curve and I have without a shadow of a doubt proven that that point is very close to python (wrt the repl). So okay maybe clisp has made some design decisions that make it a hair more effective at resuming than python. Cool I guess I&#x27;ll just ignore all the other python features where there&#x27;s parity or advantage because of this one thing &#x2F;s.</div><br/><div id="36890709" class="c"><input type="checkbox" id="c-36890709" checked=""/><div class="controls bullet"><span class="by">versteegen</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890512">parent</a><span>|</span><a href="#36890501">next</a><span>|</span><label class="collapse" for="c-36890709">[-]</label><label class="expand" for="c-36890709">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll take this as an answer to my sibling comment that the answer is &quot;No&quot;. I&#x27;m really sad CPython can&#x27;t do that, but maybe some other Python can. It shouldn&#x27;t necessarily be any slower for the interpreter to figure out where to jump to before saving the execution trace and jumping.<p>It&#x27;s not &quot;pointless&quot;, I was tearing out my hair and losing days because I couldn&#x27;t do this in CPython. Yes, I&#x27;d much rather use Python than Common Lisp regardless.</div><br/></div></div></div></div></div></div><div id="36890501" class="c"><input type="checkbox" id="c-36890501" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890021">parent</a><span>|</span><a href="#36890406">prev</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36890501">[-]</label><label class="expand" for="c-36890501">[5 more]</label></div><br/><div class="children"><div class="content">This works in compiled Lisp code.</div><br/><div id="36890553" class="c"><input type="checkbox" id="c-36890553" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890501">parent</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36890553">[-]</label><label class="expand" for="c-36890553">[4 more]</label></div><br/><div class="children"><div class="content">It works in code compiled from c++ too: define and associate a signal handler for sigkill, call a function whose symbol can&#x27;t be runtime resolved by the linker, sigkill is sent and caught, define your function (in your asm dejure),  patch the GOT to point from the original symbol to wherever the bytearray is with your asm, and voila.<p>I&#x27;ll say it again: what exactly do you think your magical lisp is doing that defies the laws of physics&#x2F;computing?</div><br/><div id="36890671" class="c"><input type="checkbox" id="c-36890671" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890553">parent</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36890671">[-]</label><label class="expand" for="c-36890671">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It works in code compiled from c++ too: define and associate a signal handler for sigkill, call a function whose symbol can&#x27;t be runtime resolved by the linker, sigkill is sent and caught, define your function (in your asm dejure), patch the GOT to point from the original symbol to wherever the bytearray is with your asm, and voila.<p>I don&#x27;t need to do anything like that in Lisp. I just define the function and RESUME THE COMPUTATION WHERE IT STANDS in my read eval print loop. &lt;&lt; important parts in uppercase.</div><br/><div id="36890690" class="c"><input type="checkbox" id="c-36890690" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890671">parent</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36890690">[-]</label><label class="expand" for="c-36890690">[2 more]</label></div><br/><div class="children"><div class="content">Do you think the magic fairies are doing it for you? Your interpreter&#x2F;runtime is still doing it whether you&#x27;re aware of it or not.<p>My point is very simple: I can do it too, in any language I want, and so there&#x27;s nothing special about lisp.</div><br/><div id="36890761" class="c"><input type="checkbox" id="c-36890761" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890690">parent</a><span>|</span><a href="#36888724">next</a><span>|</span><label class="collapse" for="c-36890761">[-]</label><label class="expand" for="c-36890761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My point is very simple: I can do it too, in any language I want, and so there&#x27;s nothing special about lisp.<p>The big difference is: &quot;I can do it too&quot; means YOU need to do it. Lisp does it for me already, I have not to do anything. I don&#x27;t want to know what you claim you can do with C++, show me where C++ does it for you.<p>Telling me &quot;I can do it too&quot; is not a good answer. Show me where the language implementation (!) does it for you.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36888724" class="c"><input type="checkbox" id="c-36888724" checked=""/><div class="controls bullet"><span class="by">rfrey</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888648">parent</a><span>|</span><a href="#36888727">prev</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36888724">[-]</label><label class="expand" for="c-36888724">[25 more]</label></div><br/><div class="children"><div class="content">The repls you mention are not like lisp repls. You&#x27;re being downvoted because your comment makes it sound like you&#x27;ve never programmed a lisp but have strong opinions nonetheless.</div><br/><div id="36889454" class="c"><input type="checkbox" id="c-36889454" checked=""/><div class="controls bullet"><span class="by">bbbobbb</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888724">parent</a><span>|</span><a href="#36888828">next</a><span>|</span><label class="collapse" for="c-36889454">[-]</label><label class="expand" for="c-36889454">[4 more]</label></div><br/><div class="children"><div class="content">Not the OP but would somebody be able to summarize HOW are the lisp REPLs different then to me?  
I&#x27;ve written limited amount of clojure and common lisp just to play around and I don&#x27;t recall any difference between Clojure REPL and the REPL I get for say Kotlin inside IntelliJ idea.<p>Maybe the ability to send expression from the IDE into the REPL with one keybind but I cannot say it&#x27;s not possible with the Kotlin one right now because that&#x27;s not what I use it for.</div><br/><div id="36889469" class="c"><input type="checkbox" id="c-36889469" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889454">parent</a><span>|</span><a href="#36888828">next</a><span>|</span><label class="collapse" for="c-36889469">[-]</label><label class="expand" for="c-36889469">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a person above saying that it&#x27;s about being to able to mutate program state from the repl, which is a thing that&#x27;s also possible in any repl for a language with managed memory.</div><br/><div id="36889726" class="c"><input type="checkbox" id="c-36889726" checked=""/><div class="controls bullet"><span class="by">ohyes</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889469">parent</a><span>|</span><a href="#36888828">next</a><span>|</span><label class="collapse" for="c-36889726">[-]</label><label class="expand" for="c-36889726">[2 more]</label></div><br/><div class="children"><div class="content">Cl Condition system + repl = godmode. Your software crashes? Do you go back and set a breakpoint? No, because you’re already in the stacktrace in the repl exactly where the crash occurred. You fix the code, reload it, tell it to ether run where it left off, or restart from an earlier point.</div><br/><div id="36889793" class="c"><input type="checkbox" id="c-36889793" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889726">parent</a><span>|</span><a href="#36888828">next</a><span>|</span><label class="collapse" for="c-36889793">[-]</label><label class="expand" for="c-36889793">[1 more]</label></div><br/><div class="children"><div class="content">Flask and Django have the exact same functionality - I&#x27;ve already said that this thing you guys keep talking is just a matter catching exceptions.<p><a href="https:&#x2F;&#x2F;flask.palletsprojects.com&#x2F;en&#x2F;2.3.x&#x2F;debugging&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;flask.palletsprojects.com&#x2F;en&#x2F;2.3.x&#x2F;debugging&#x2F;</a><p><a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;dev&#x2F;ref&#x2F;settings&#x2F;#debug" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;dev&#x2F;ref&#x2F;settings&#x2F;#debug</a></div><br/></div></div></div></div></div></div></div></div><div id="36888828" class="c"><input type="checkbox" id="c-36888828" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888724">parent</a><span>|</span><a href="#36889454">prev</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36888828">[-]</label><label class="expand" for="c-36888828">[20 more]</label></div><br/><div class="children"><div class="content">&gt;you&#x27;ve never programmed a lisp but have strong opinions nonetheless<p>i&#x27;ve written racket and clojure (and mathematica, which is a lisp). not multiple 10kloc but enough to understand what the big ideas are. claiming i just haven&#x27;t written enough lisp is basically the logical fallacy of assuming the premise.</div><br/><div id="36889174" class="c"><input type="checkbox" id="c-36889174" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36888828">parent</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36889174">[-]</label><label class="expand" for="c-36889174">[19 more]</label></div><br/><div class="children"><div class="content">&gt; “mathematica is a lisp”</div><br/><div id="36889194" class="c"><input type="checkbox" id="c-36889194" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889174">parent</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36889194">[-]</label><label class="expand" for="c-36889194">[18 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;xahlee.info&#x2F;M&#x2F;lisp_root_of_wolfram_lang.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;xahlee.info&#x2F;M&#x2F;lisp_root_of_wolfram_lang.html</a><p><a href="http:&#x2F;&#x2F;xahlee.info&#x2F;M&#x2F;lisp_vs_WolframLang.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;xahlee.info&#x2F;M&#x2F;lisp_vs_WolframLang.html</a><p>&gt; WolframLang has all the characteristics of LISP:<p>seems you either don&#x27;t know what lisp is or you&#x27;ve never written mathematica</div><br/><div id="36889229" class="c"><input type="checkbox" id="c-36889229" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889194">parent</a><span>|</span><a href="#36889594">next</a><span>|</span><label class="collapse" for="c-36889229">[-]</label><label class="expand" for="c-36889229">[4 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;seems you either don&#x27;t know what lisp or you&#x27;ve never written mathematica&quot;<p>Meanwhile, you brought up examples from Mathematica docs that talk about head&#x2F;tails (car&#x2F;cdr) but by that logic, Python is a Lisp too because you have:<p><pre><code>   list[0]
</code></pre>
and<p><pre><code>    list[1:]
</code></pre>
Maybe your Clojure&#x2F;Racket experience wasn&#x27;t enough to teach you what the essence of Lisp was. From your first link:<p>&quot;Mathematica expressions are in many respects like LISP lists. In Mathematica, however, expressions are the lowest-level objects accessible to the user. LISP allows you to go below lists, and access the binary trees from which they are built.&quot;<p>That right there is telling you that Mathematica is not a Lisp.<p>Edit: Corrected the Python list example.</div><br/><div id="36889269" class="c"><input type="checkbox" id="c-36889269" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889229">parent</a><span>|</span><a href="#36889594">next</a><span>|</span><label class="collapse" for="c-36889269">[-]</label><label class="expand" for="c-36889269">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry but are you really going to pretend like car and cdr are not core to lisp?<p>&gt;list[0] and list[-1]<p>That is not car and cdr; closer would be list[0] and list[1:] if lists were cons in python.<p>&gt;Mathematica expressions are in many respects like LISP lists. In Mathematica, however, expressions are the lowest-level objects accessible to the user. LISP allows you to go below lists, and access the binary trees from which they are built<p>This is a quote from 1986. I wonder if the language has changed much since then<p><a href="https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;tutorial&#x2F;Expressions.html#14609" rel="nofollow noreferrer">https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;tutorial&#x2F;Expressions....</a></div><br/><div id="36889339" class="c"><input type="checkbox" id="c-36889339" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889269">parent</a><span>|</span><a href="#36889594">next</a><span>|</span><label class="collapse" for="c-36889339">[-]</label><label class="expand" for="c-36889339">[2 more]</label></div><br/><div class="children"><div class="content">Read PG&#x27;s &quot;Roots of Lisp&quot; and you&#x27;ll understand what I mean.</div><br/><div id="36889363" class="c"><input type="checkbox" id="c-36889363" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889339">parent</a><span>|</span><a href="#36889594">next</a><span>|</span><label class="collapse" for="c-36889363">[-]</label><label class="expand" for="c-36889363">[1 more]</label></div><br/><div class="children"><div class="content">I believe that is an argument from authority (if I remember correctly).</div><br/></div></div></div></div></div></div></div></div><div id="36889594" class="c"><input type="checkbox" id="c-36889594" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889194">parent</a><span>|</span><a href="#36889229">prev</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36889594">[-]</label><label class="expand" for="c-36889594">[13 more]</label></div><br/><div class="children"><div class="content">The content on the pages clearly explain the differences.<p>Mathematica is a symbolic language based on &#x27;rewriting&#x27; There are other examples - Prolog would be an example, a logic language. Also most other computer algebra systems are in this category, similar to Mathematica: Macsyma&#x2F;Maxima, Axiom, ...<p>&gt; WolframLang has all the characteristics of LISP<p>It has many, but there are a lot of differences, too.<p>The big difference is the actual engine. Mathematica is based on a &#x27;rewrite system&#x27;. It translates expressions by applying rewrite rules.<p>Lisp evaluates expressions either based on an interpreted evaluator or by evaluating compiled code. Lisp has macros, but those can be transformed before the code is compiled or running. The practical effect is that in many Lisp implementations usually all code is compiled, incl. user code. Mathematica uses C++ then. Most of the UI in Mathematica is implemented in C++, where many Lisp systems would implement that in native compiled Lisp.<p>Thus the computation is very different. Using a rewrite system for programming is quite clunky and inefficient under the hood. A simple example would be to look how lexical closures are implemented.<p>Another difference is that Mathematica does not expose the data representation of programs to the user all the time, where Lisp programs are also on the surface written as s-expressions (aka symbolic expressions) in text.<p>The linked page from the Mathematica book also claims that Mathematica is a higher level language. Which is true. Lisp is lower level and languages like the Wolfram Language can be implemented in it. That&#x27;s one of its original purposes: it&#x27;s an implementation language for other (&#x27;higher-level&#x27;) languages. Sometimes it already comes with embedded higher-level languages. CLOS + MOP (the meta-object protocol) would be an example for that.</div><br/><div id="36889616" class="c"><input type="checkbox" id="c-36889616" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889594">parent</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36889616">[-]</label><label class="expand" for="c-36889616">[12 more]</label></div><br/><div class="children"><div class="content">&gt; Another difference is that Mathematica does not expose the data representation of programs to the user all the time, where Lisp programs are also on the surface written as s-expressions (aka symbolic expressions) in text.<p>I have already addressed this: FullForm<p><a href="https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;tutorial&#x2F;Expressions.html#14609" rel="nofollow noreferrer">https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;tutorial&#x2F;Expressions....</a><p>&gt;Thus the computation is very different. Using a rewrite system for programming is quite clunky and inefficient under the hood. A simple example would be to look how lexical closures are implemented.<p>You&#x27;re skimming a couple of paragraphs without actually knowing much about Mathematica. It&#x27;s absolutely not the case that Mathematica is purely a redex system; it&#x27;s just that it&#x27;s very good at beta reduction because it has a strong focus on CAS features.</div><br/><div id="36889769" class="c"><input type="checkbox" id="c-36889769" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889616">parent</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36889769">[-]</label><label class="expand" for="c-36889769">[11 more]</label></div><br/><div class="children"><div class="content">&gt; I have already addressed this: FullForm<p>No you haven&#x27;t addressed it. The &quot;Wolfram Language&quot; user typically does not write code in FullForm. It&#x27;s used as an internal representation.<p>&gt;  it&#x27;s just that it&#x27;s very good at beta reduction<p>and not so good at compiling code...<p><a href="https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;ref&#x2F;Compile.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;ref&#x2F;Compile.html</a><p>See &quot;Details and Options&quot;</div><br/><div id="36889812" class="c"><input type="checkbox" id="c-36889812" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889769">parent</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36889812">[-]</label><label class="expand" for="c-36889812">[10 more]</label></div><br/><div class="children"><div class="content">&gt;The &quot;Wolfram Language&quot; user typically does not write code in FullForm. It&#x27;s used as an internal representation.<p>I have no clue what you&#x27;re talking about - it&#x27;s an available primitive and I use it all the time.<p>&gt;and not so good at compiling code...<p>Lol I am 100% sure that the majority of lisps cannot be aot compiled.</div><br/><div id="36890161" class="c"><input type="checkbox" id="c-36890161" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889812">parent</a><span>|</span><a href="#36889988">next</a><span>|</span><label class="collapse" for="c-36890161">[-]</label><label class="expand" for="c-36890161">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Lol I am 100% sure that the majority of lisps cannot be aot compiled.</i><p>Ahead-of-time compiling has been the principal method in mainstream Lisps going back to the 1960&#x27;s.  The Lisp 1.5 Programmer&#x27;s Manual from 1962 describes ahead-of-time compiling.<p>The curious thing is how can you be &quot;100% sure&quot; in making a completely wrong statement, rather than some lower number, like &quot;12% sure&quot;.</div><br/><div id="36890357" class="c"><input type="checkbox" id="c-36890357" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890161">parent</a><span>|</span><a href="#36889988">next</a><span>|</span><label class="collapse" for="c-36890357">[-]</label><label class="expand" for="c-36890357">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The curious thing is how can you be &quot;100% sure&quot; in making a completely wrong statement, rather than some lower number, like &quot;12% sure&quot;.<p>The reason is very simple and surprisingly straightforward (but requires some understanding of compilers): dynamically typed languages that are amenable to interpreter implementations are <i>very</i> hard to compile AOT. Now note I have since the beginning emphasized AOT - ahead of time - but this does not preclude JITs.<p>But in reality I don&#x27;t really care about this aspect - it was the other guy who for whatever reason decided to flaunt that clisp can be compiled when comparing it with Mathematica.</div><br/></div></div></div></div><div id="36889988" class="c"><input type="checkbox" id="c-36889988" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889812">parent</a><span>|</span><a href="#36890161">prev</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36889988">[-]</label><label class="expand" for="c-36889988">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I have no clue what you&#x27;re talking about<p>That&#x27;s not good. Try again.<p>In Lisp adding two numbers looks like this is source code: (+ 1 2)<p><pre><code>  CL-USER 41 &gt; (+ 1 2)
  3
</code></pre>
If I quote the expression and evaluate it, the result is (+ 1 2)<p><pre><code>  CL-USER 42 &gt; (quote (+ 1 2))
  (+ 1 2)
</code></pre>
Thus in Lisp the textual representation of code and code as data are the same.<p>Not so in &quot;Wolfram Language&quot;: a + b  has a FullForm which looks differently. The user does not write ALL of the code in FullForm notation.<p>Source notation<p><pre><code>  a + b
</code></pre>
FullForm<p><pre><code>  Plus[a, b]
</code></pre>
Lisp:<p>Source notation<p><pre><code>  (+ a b)
</code></pre>
FullForm<p><pre><code>  (+ a b)
</code></pre>
Can you see the difference?<p>&gt; Lol I am 100% sure that the majority of lisps cannot be aot compiled.<p>I&#x27;d expect that they can. That&#x27;s a feature since 1962. SBCL for example does AOT compilation by default, always.<p><pre><code>  * (disassemble (lambda (a) (+ a 42)))
  ; disassembly for (LAMBDA (A))
  ; Size: 36 bytes. Origin: #x7006DC83B4                        ; (LAMBDA (A))
  ; B4:       AA0A40F9         LDR R0, [THREAD, #16]            ; binding-stack-pointer
  ; B8:       4A0B00F9         STR R0, [CFP, #16]
  ; BC:       EA030CAA         MOV R0, R2
  ; C0:       8B0A80D2         MOVZ R1, #84
  ; C4:       3CAA80D2         MOVZ TMP, #1361
  ; C8:       BE6B7CF8         LDR LR, [NULL, TMP]              ; SB-KERNEL:TWO-ARG-+
  ; CC:       DE130091         ADD LR, LR, #4
  ; D0:       C0031FD6         BR LR
  ; D4:       E00120D4         BRK #15                          ; Invalid argument count trap
  NIL
</code></pre>
Looks like native ARM64 code to me.</div><br/><div id="36890072" class="c"><input type="checkbox" id="c-36890072" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36889988">parent</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36890072">[-]</label><label class="expand" for="c-36890072">[6 more]</label></div><br/><div class="children"><div class="content">&gt; FullForm Plus[a, b]<p>How can I make this any more clear? You are able, in Mathematica, to write Plus[a, b] with your own fingers on your own keyboard and it will be interpreted as the same thing as a+b<p>&gt; I&#x27;d expect that they can.<p>Clisp is not the only lisp - I can name 10 others that cannot be compiled.</div><br/><div id="36890359" class="c"><input type="checkbox" id="c-36890359" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890072">parent</a><span>|</span><a href="#36890217">next</a><span>|</span><label class="collapse" for="c-36890359">[-]</label><label class="expand" for="c-36890359">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You are able, in Mathematica, to write Plus[a, b] with your own fingers on your own keyboard and it will be interpreted as the same thing as a+b<p>Sure, but it is not Mathematica&#x27;s InputForm:<p><a href="https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;ref&#x2F;InputForm.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;reference.wolfram.com&#x2F;language&#x2F;ref&#x2F;InputForm.html</a><p>The majority of code is written not in FullForm. In Lisp 100% of the code is written in s-expressions.<p>&gt; Clisp is not the only lisp - I can name 10 others that cannot be compiled.<p>Typical Lisp and Lisp dialects all can be compiled: Common Lisp, Emacs Lisp, ISLisp, Scheme, Racket, ...<p>Which Lisps can not be compiled?</div><br/><div id="36890435" class="c"><input type="checkbox" id="c-36890435" checked=""/><div class="controls bullet"><span class="by">mathisfun123</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890359">parent</a><span>|</span><a href="#36890217">next</a><span>|</span><label class="collapse" for="c-36890435">[-]</label><label class="expand" for="c-36890435">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Racket<p>Do you really know what you&#x27;re talking about here?<p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;raco&#x2F;make.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;raco&#x2F;make.html</a><p>&gt;The raco make command accept filenames for Racket modules to be compiled to bytecode format.<p>That&#x27;s not a compiler...<p>I don&#x27;t claim to be an expert on lisp, so further googling I find<p><a href="https:&#x2F;&#x2F;racket.discourse.group&#x2F;t&#x2F;chez-for-architectures-without-native-backends&#x2F;950&#x2F;2" rel="nofollow noreferrer">https:&#x2F;&#x2F;racket.discourse.group&#x2F;t&#x2F;chez-for-architectures-with...</a><p>which has some discussion about this and that native backend.<p>Suffice it to say I am not any more confident that being compilable is somehow intrinsic to lisp.</div><br/><div id="36890822" class="c"><input type="checkbox" id="c-36890822" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890435">parent</a><span>|</span><a href="#36890217">next</a><span>|</span><label class="collapse" for="c-36890822">[-]</label><label class="expand" for="c-36890822">[1 more]</label></div><br/><div class="children"><div class="content">From the Racket documentation:<p><a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;reference&#x2F;compiler.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;reference&#x2F;compiler.html</a><p>&quot;18.7.1.2 CS Compilation Modes<p>The CS implementation of Racket supports several compilation modes: machine code, machine-independent, interpreted, and JIT. Machine code is the primary mode, and the machine-independent mode is the same as for BC.&quot;<p>CS is the new implementation of Racket on top of the Chez Scheme runtime. Chez Scheme is known for its excellent machine code compiler.<p>&quot;Machine code is the primary mode&quot;<p>&gt; Do you really know what you&#x27;re talking about here?<p>Read above.</div><br/></div></div></div></div></div></div><div id="36890217" class="c"><input type="checkbox" id="c-36890217" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890072">parent</a><span>|</span><a href="#36890359">prev</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36890217">[-]</label><label class="expand" for="c-36890217">[2 more]</label></div><br/><div class="children"><div class="content">If we count everyone&#x27;s one-weekend project that evaluates (+ 1 2) into 3, then there are probably thousands of Lisps that cannot be compiled. So what?</div><br/><div id="36890378" class="c"><input type="checkbox" id="c-36890378" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36887220">root</a><span>|</span><a href="#36890217">parent</a><span>|</span><a href="#36889101">next</a><span>|</span><label class="collapse" for="c-36890378">[-]</label><label class="expand" for="c-36890378">[1 more]</label></div><br/><div class="children"><div class="content">Then the person should spend another weekend and implement a compiler for it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36889101" class="c"><input type="checkbox" id="c-36889101" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36887220">prev</a><span>|</span><a href="#36887136">next</a><span>|</span><label class="collapse" for="c-36889101">[-]</label><label class="expand" for="c-36889101">[12 more]</label></div><br/><div class="children"><div class="content">I see a lot of “coding” talk in the blog and comments from the author here, but few mentions as to what kind of software they’re building or what use cases they’re targeting.<p>My hot take is that the reason functional programming never took off is that, while it certainly is fine for writing programs, most software these days is not “program running locally on my pc&#x2F;server from the command line until it completes” and is instead “program that starts, reacts to input from user, then gets closed by the user” or “program that starts, then responds to network or other automated I&#x2F;O (to serve web pages, to monitor something, to emit logs, etc) then stops when the other software tells it to”. This is a lot harder to do in a purely functional style, or at least it is in most opinionated functional programming implementations I’ve used, because you’re no longer “just” evaluating some expression but instead initializing state, reacting to I&#x2F;O, then updating state and&#x2F;or performing further I&#x2F;O potentially while using parallelization to perform monitoring&#x2F;listen for other things&#x2F;perform further I&#x2F;O and state updates.<p>Of course it’s not impossible to do these things with Lisp but from my couple of semesters of exposure of FP in undergrad and use of FP features in C++ and Scala professionally to solve these kinds of problems… it seems quite hard to get FP to work for these applications, and that lack of suitability is what discourages me from diving more fully into FP</div><br/><div id="36889360" class="c"><input type="checkbox" id="c-36889360" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36889101">parent</a><span>|</span><a href="#36889316">next</a><span>|</span><label class="collapse" for="c-36889360">[-]</label><label class="expand" for="c-36889360">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I see a lot of “coding” talk in the blog and comments from the author here, but few mentions as to what kind of software they’re building or what use cases they’re targeting.<p>Good point! This is all currently just a hobby. For Common Lisp specifically, the only things I&#x27;ve produced are a (mediocre) Battlesnake client and a (now defunct, as of yesterday) multiplayer word scramble game. Neither of these really derives much benefit from being created in Lisp, but I learned a lot along the way (which was really the point).<p>Unrelated to Common Lisp, I&#x27;ve found myself often needing to write code that generates code. This is an area where I suspect Lisp will shine, although I haven&#x27;t had a chance to give it a try yet. Two examples from recent projects (which I tackled before ever thinking about using Common Lisp) are:<p>* Generating code to validate a particular JSON Schema (used in a static site generator)<p>* Generating JSX from Markdown (used for story content in a programming game)<p>To say nothing of the innumerable C macros I&#x27;ve written in my lifetime :)</div><br/><div id="36889480" class="c"><input type="checkbox" id="c-36889480" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36889101">root</a><span>|</span><a href="#36889360">parent</a><span>|</span><a href="#36889316">next</a><span>|</span><label class="collapse" for="c-36889480">[-]</label><label class="expand" for="c-36889480">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the answer! Your word scramble game in particular seems like something that approximates my “maybe not a good fit for FP” bucket. Do you plan on sharing it on GitHub or describing the challenges you ran into?<p>Completely agree code generation is where I expect Lisp to perform the best. Though, I looked it up and apparently Markdown is not context-free so.. curious as to the challenges that introduces as I figure FP could zap through parsing a CFG but really struggle with state for something not context free</div><br/></div></div></div></div><div id="36889316" class="c"><input type="checkbox" id="c-36889316" checked=""/><div class="controls bullet"><span class="by">rileyphone</span><span>|</span><a href="#36889101">parent</a><span>|</span><a href="#36889360">prev</a><span>|</span><a href="#36889940">next</a><span>|</span><label class="collapse" for="c-36889316">[-]</label><label class="expand" for="c-36889316">[2 more]</label></div><br/><div class="children"><div class="content">Note that Common Lisp contains CLOS, which is one of the most advanced object-oriented systems even now. Most Lisps are not functional like Haskell is.</div><br/><div id="36889435" class="c"><input type="checkbox" id="c-36889435" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36889101">root</a><span>|</span><a href="#36889316">parent</a><span>|</span><a href="#36889940">next</a><span>|</span><label class="collapse" for="c-36889435">[-]</label><label class="expand" for="c-36889435">[1 more]</label></div><br/><div class="children"><div class="content">I read this Wikipedia article and some examples: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Common_Lisp_Object_System" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Common_Lisp_Object_System</a><p>Yes, the article calls it powerful, but aside from the ability to update classes and their functions at runtime - which, maybe I’m missing the utility of so I won’t say it’s useless although in my experience a SharedInstanceSingleton or LocalImmutableConfig or BatchedMonitoringEvent wouldn’t need it - it’s “just” dynamically resolving the method implementation to use based on argument types dynamically and letting you provide an order of precedence for diamond inheritance.<p>I think it does solve one problem I have - with some solid tooling and a guarantee that class updates at runtime don’t disrupt ongoing calls, it might let me patch running binaries without doing a full update. Though, the cost is that I seem to incur a few extra lookups or even sorts on each dynamically dispatched method, to resolve the implementation? Besides that it doesn’t seem to really solve most problems I have regarding I&#x2F;O or state - having the option to update some of these at runtime is interesting but it seems like something I’d only want to selectively enable</div><br/></div></div></div></div><div id="36889940" class="c"><input type="checkbox" id="c-36889940" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#36889101">parent</a><span>|</span><a href="#36889316">prev</a><span>|</span><a href="#36890439">next</a><span>|</span><label class="collapse" for="c-36889940">[-]</label><label class="expand" for="c-36889940">[1 more]</label></div><br/><div class="children"><div class="content">Whatsapp and discord runs on functional elixir&#x2F;erlang. I heard they are pretty big and not hobby projects.</div><br/></div></div><div id="36890439" class="c"><input type="checkbox" id="c-36890439" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#36889101">parent</a><span>|</span><a href="#36889940">prev</a><span>|</span><a href="#36889158">next</a><span>|</span><label class="collapse" for="c-36890439">[-]</label><label class="expand" for="c-36890439">[1 more]</label></div><br/><div class="children"><div class="content">Functional programming took off big time. Just look at the JavaScript ecosystem.</div><br/></div></div><div id="36889158" class="c"><input type="checkbox" id="c-36889158" checked=""/><div class="controls bullet"><span class="by">vippy</span><span>|</span><a href="#36889101">parent</a><span>|</span><a href="#36890439">prev</a><span>|</span><a href="#36887136">next</a><span>|</span><label class="collapse" for="c-36889158">[-]</label><label class="expand" for="c-36889158">[5 more]</label></div><br/><div class="children"><div class="content">It took me a while to grok monads, and the IO monad, and longer still to figure out how to compose them in safe ways, and manipulate execution order, etc. But: now I can write typesafe applications, and I produce fewer bugs when I work in non-FP languages (I get paid to write Java.) Lisp is a starting point. Haskell is where it&#x27;s at. I recommend learning the style, even if you never produce production code in it.</div><br/><div id="36889299" class="c"><input type="checkbox" id="c-36889299" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36889101">root</a><span>|</span><a href="#36889158">parent</a><span>|</span><a href="#36889232">next</a><span>|</span><label class="collapse" for="c-36889299">[-]</label><label class="expand" for="c-36889299">[3 more]</label></div><br/><div class="children"><div class="content">Let’s say I want to do something simple but slightly beyond the scope of a traditional toy demonstration:<p>* Read some environment variables and a local file<p>* Start a monitoring thread that consumes from a channel or something similar, then every X s or X events writes to a local temp file and then sends a request batching some metrics to an external system<p>* Configure and start an http server<p>* Said server has a handler that 0. Starts a timer 1. loads, then increments an atomic “num requests served until now” variable 2. uses synchronization to lock on a list or ring buffer containing the last 5 requests’ user-agent headers 2.5 copies the current last 5 values, replaces oldest one with the one from the handles request, unlocks 3. generates a json response containing like “num_so_far: x, last5agent: [..], “some_env_var”:..” 3.5 stops the timer 4. write request user agent and time interval to monitoring thread’s channel 5. write response and end handling<p>* server’s gotta be able to do concurrency &gt; 1 with parallelism<p>* On sigterm set the server to a state that rejects new requests, waits for existing requests to complete, then flushes the monitoring channel<p>I’d consider this a trial run of some of the most basic patterns commonly used by networked software: init io, immutable shared state, atomic mutable shared state, synchronization locked shared state, http ingress and egress, serialization, concurrency, parallelizarion, background threads, os signals, nontrivial cleanup. In Go, Java, or C++ I could write this with my eyes closed. How easy is it in Haskell or Lisp?<p>If you know of any demos or repos that do something like this - not a pure toy or barebones demo, but not a huge task all in all-  in either I’d be interested in seeing what it looks like.</div><br/><div id="36890789" class="c"><input type="checkbox" id="c-36890789" checked=""/><div class="controls bullet"><span class="by">draven</span><span>|</span><a href="#36889101">root</a><span>|</span><a href="#36889299">parent</a><span>|</span><a href="#36889762">next</a><span>|</span><label class="collapse" for="c-36890789">[-]</label><label class="expand" for="c-36890789">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have time to try it atm but this looks like it would be quite easy to implement in Clojure (that falls under &quot;Lisp&quot;, right?)</div><br/></div></div><div id="36889762" class="c"><input type="checkbox" id="c-36889762" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#36889101">root</a><span>|</span><a href="#36889299">parent</a><span>|</span><a href="#36890789">prev</a><span>|</span><a href="#36889232">next</a><span>|</span><label class="collapse" for="c-36889762">[-]</label><label class="expand" for="c-36889762">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll cover the Haskell side because I&#x27;m more familiar with its library ecosystem:<p>&gt; Read some environment variables and a local file<p><pre><code>    import System.Environment (getEnv)
    import System.FilePath ((&lt;&#x2F;&gt;))
    main = do
      dir &lt;- getEnv &quot;WHATEVER_DIR&quot;
      data &lt;- readFile (dir &lt;&#x2F;&gt; &quot;foo.txt&quot;)
      putStrLn (&quot;Had &quot; ++ show (length (lines data)) ++ &quot; lines&quot;)
</code></pre>
&gt; Start a monitoring thread [...]<p><pre><code>    import Control.Concurrent
    import Control.Concurrent.Chan
    import Network.HTTP
    -- also more stuff...

    monitoringThread :: Chan String -&gt; IO ()
    monitoringThread chan = do
      file &lt;- openFile &quot;log.txt&quot; AppendMode
      forever $ do -- no $ needed if you pass -XBlockArguments [0, 1]
        batch &lt;- replicateM 5 (readChan chan)
        let chunk = unlines batch
        hPutStr file chunk
        simpleHTTP (postRequestWithBody &quot;&quot; &quot;text&#x2F;plain&quot; chunk)

    main :: IO ()
    main = do
      logChan &lt;- newChan
      void (forkIO (monitoringThread logChan))
      -- ...
      forever $ do
        threadDelay (1000 * 1000) -- 1M usec
        writeChan logChan &quot;Hello, world!&quot;
</code></pre>
&gt; Configure and start an http server<p><pre><code>    import Network.Wai
    import Network.Wai.Handler.Warp

    main = run 8000 $ \req respond -&gt;
      respond (responseLBS status200 [] &quot;Hello, world!&quot;)
</code></pre>
&gt; Said server has [...]<p>Yeah, this is long. If you&#x27;re just getting the current time with the timer, that&#x27;s here[2]; synchronize across threads with MVars[3] or STM[4]; JSON is in aeson[5], which should feel broadly familiar if you know Rust&#x27;s serde.<p>&gt; server’s gotta be able to do concurrency &gt; 1 with parallelism<p>Yep, GHC Haskell has _excellent_ concurrency support on top of a parallel runtime.<p>&gt; On sigterm set the server to a state that rejects new requests, waits for existing requests to complete, then flushes the monitoring channel<p>I haven&#x27;t personally tried this, but this[6] function sounds like... exactly this, actually, so I think its example should suffice?<p>On two separate notes:<p>- Common Lisp and Python 3 are a _lot_ closer than Common Lisp and Haskell, or even Python 3 and JavaScript; the Python 3 object model is very close to Common Lisp&#x27;s, and Common Lisp is not particularly pure (setf isn&#x27;t unidiomatic by a longshot), and supports a very non-functional style of programming (it has gotos!).<p>- &quot;Haskell is worse at IO than other high-level languages&quot; isn&#x27;t particularly true. What _is_ true is that Haskell has the same &quot;function coloring problem&quot; as JavaScript (Haskell has the IO monad, JavaScript has the Promise monad); Haskell also has a &quot;uses funny academic words&quot; problem (well, debatably a problem...) which I think confuses the issue.<p>[0]: <a href="https:&#x2F;&#x2F;ghc.gitlab.haskell.org&#x2F;ghc&#x2F;doc&#x2F;users_guide&#x2F;exts&#x2F;block_arguments.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;ghc.gitlab.haskell.org&#x2F;ghc&#x2F;doc&#x2F;users_guide&#x2F;exts&#x2F;bloc...</a><p>[1]: Haskell has a spec, one &quot;main&quot; implementation (GHC), little spec-committee activity, and a respect for that implementation not superseding the spec; many improvements become language extensions (-X flags or {-# LANGUAGE #-} pragmas), so when you invoke GHC you&#x27;re getting a by-the-spec implementation by default.<p>[2]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;time-1.12.2&#x2F;docs&#x2F;Data-Time-Clock.html#v:getCurrentTime" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;time-1.12.2&#x2F;docs&#x2F;Data-Ti...</a><p>[3]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.18.0.0&#x2F;docs&#x2F;Control-Concurrent-MVar.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.18.0.0&#x2F;docs&#x2F;Contr...</a><p>[4]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;stm-2.5.1.0&#x2F;docs&#x2F;Control-Concurrent-STM-TMVar.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;stm-2.5.1.0&#x2F;docs&#x2F;Control...</a><p>[5]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;aeson-2.2.0.0&#x2F;docs&#x2F;Data-Aeson.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;aeson-2.2.0.0&#x2F;docs&#x2F;Data-...</a><p>[6]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;warp-3.3.28&#x2F;docs&#x2F;Network-Wai-Handler-Warp.html#v:setInstallShutdownHandler" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;warp-3.3.28&#x2F;docs&#x2F;Network...</a></div><br/></div></div></div></div><div id="36889232" class="c"><input type="checkbox" id="c-36889232" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#36889101">root</a><span>|</span><a href="#36889158">parent</a><span>|</span><a href="#36889299">prev</a><span>|</span><a href="#36887136">next</a><span>|</span><label class="collapse" for="c-36889232">[-]</label><label class="expand" for="c-36889232">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Haskell is magnificent for learning FP.  I used to think Haskell was terrible for IO, but my tune has changed dramatically since I started working with it full time.</div><br/></div></div></div></div></div></div><div id="36887136" class="c"><input type="checkbox" id="c-36887136" checked=""/><div class="controls bullet"><span class="by">kaveh808</span><span>|</span><a href="#36889101">prev</a><span>|</span><a href="#36887851">next</a><span>|</span><label class="collapse" for="c-36887136">[-]</label><label class="expand" for="c-36887136">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re into 3D graphics, this could be a fun Common Lisp codebase to look at. I have tried to keep it simple and comprehensible.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;kaveh808&#x2F;kons-9">https:&#x2F;&#x2F;github.com&#x2F;kaveh808&#x2F;kons-9</a></div><br/><div id="36888154" class="c"><input type="checkbox" id="c-36888154" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#36887136">parent</a><span>|</span><a href="#36887851">next</a><span>|</span><label class="collapse" for="c-36888154">[-]</label><label class="expand" for="c-36888154">[3 more]</label></div><br/><div class="children"><div class="content">Look up Kaveh’s CL tutorial videos on YouTube. They’re really good.</div><br/><div id="36888436" class="c"><input type="checkbox" id="c-36888436" checked=""/><div class="controls bullet"><span class="by">bkomarath</span><span>|</span><a href="#36887136">root</a><span>|</span><a href="#36888154">parent</a><span>|</span><a href="#36887851">next</a><span>|</span><label class="collapse" for="c-36888436">[-]</label><label class="expand" for="c-36888436">[2 more]</label></div><br/><div class="children"><div class="content">I think you are replying to him.</div><br/><div id="36888664" class="c"><input type="checkbox" id="c-36888664" checked=""/><div class="controls bullet"><span class="by">kaveh808</span><span>|</span><a href="#36887136">root</a><span>|</span><a href="#36888436">parent</a><span>|</span><a href="#36887851">next</a><span>|</span><label class="collapse" for="c-36888664">[-]</label><label class="expand" for="c-36888664">[1 more]</label></div><br/><div class="children"><div class="content">My Youtube channel: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCHNK9EcrAwP7djlwQN4C_tg">https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCHNK9EcrAwP7djlwQN4C_tg</a></div><br/></div></div></div></div></div></div></div></div><div id="36887851" class="c"><input type="checkbox" id="c-36887851" checked=""/><div class="controls bullet"><span class="by">temporallobe</span><span>|</span><a href="#36887136">prev</a><span>|</span><a href="#36890476">next</a><span>|</span><label class="collapse" for="c-36887851">[-]</label><label class="expand" for="c-36887851">[1 more]</label></div><br/><div class="children"><div class="content">As a Clojure dev, break loops and REPL-driven workflows sound wonderful, and something we could definitely benefit from, which would make it more like front-end coding with JS&#x2F;TypeScript using the browser’s awesome debugging tools. Sadly, the state of tooling and community support for the Clojure ecosystem seems to be pretty lackluster at present.</div><br/></div></div><div id="36890476" class="c"><input type="checkbox" id="c-36890476" checked=""/><div class="controls bullet"><span class="by">massimosgrelli</span><span>|</span><a href="#36887851">prev</a><span>|</span><a href="#36887243">next</a><span>|</span><label class="collapse" for="c-36890476">[-]</label><label class="expand" for="c-36890476">[1 more]</label></div><br/><div class="children"><div class="content">Always been fascinated by Lisp, but I never spent enough time to enjoy its elegance and applications. I went through Lurk, a Lisp dialect, a Turing-complete programming language for recursive zk-SNARKs in the last year. I started to grasp a bit of its potential in solving real-world problems, but still too little to understand why it&#x27;s so right for solving some problems. I&#x27;m curious about what other projects you guys are successfully and better solving because of Lisp today.</div><br/></div></div><div id="36887243" class="c"><input type="checkbox" id="c-36887243" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36890476">prev</a><span>|</span><a href="#36889677">next</a><span>|</span><label class="collapse" for="c-36887243">[-]</label><label class="expand" for="c-36887243">[43 more]</label></div><br/><div class="children"><div class="content">The scoop: Scheme and Janet are great, but the author wants a more standalone language. What makes the difference is the breakloop, a full-blown REPL that opens when an error in a program occurs. Not a stacktrace, not a debugger; just build from the point where it&#x27;s currently broken.</div><br/><div id="36887555" class="c"><input type="checkbox" id="c-36887555" checked=""/><div class="controls bullet"><span class="by">peanutz454</span><span>|</span><a href="#36887243">parent</a><span>|</span><a href="#36888221">next</a><span>|</span><label class="collapse" for="c-36887555">[-]</label><label class="expand" for="c-36887555">[31 more]</label></div><br/><div class="children"><div class="content">This sounds so amazing, why is Common Lisp not the most popular language out there? (asking as someone who almost never writes code)</div><br/><div id="36887833" class="c"><input type="checkbox" id="c-36887833" checked=""/><div class="controls bullet"><span class="by">tikhonj</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887555">parent</a><span>|</span><a href="#36887739">next</a><span>|</span><label class="collapse" for="c-36887833">[-]</label><label class="expand" for="c-36887833">[3 more]</label></div><br/><div class="children"><div class="content">Because language popularity is, at best, <i>loosely</i> correlated with any intrinsic qualities of the language itself.</div><br/><div id="36888448" class="c"><input type="checkbox" id="c-36888448" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887833">parent</a><span>|</span><a href="#36887739">next</a><span>|</span><label class="collapse" for="c-36888448">[-]</label><label class="expand" for="c-36888448">[2 more]</label></div><br/><div class="children"><div class="content">See also advertising. C++ and Java had enormous advertising budgets, while Common Lisp had virtually none. For years, virtually every programming book and magazine was touting C++ and then later Java. Every conference, every keynote, everything a CTO might ever read or notice was telling them to use C++ or Java.</div><br/><div id="36888499" class="c"><input type="checkbox" id="c-36888499" checked=""/><div class="controls bullet"><span class="by">to23iu42343434</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888448">parent</a><span>|</span><a href="#36887739">next</a><span>|</span><label class="collapse" for="c-36888499">[-]</label><label class="expand" for="c-36888499">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a religion.<p><a href="https:&#x2F;&#x2F;www.nicklitten.com&#x2F;if-programming-languages-were-religions&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nicklitten.com&#x2F;if-programming-languages-were-rel...</a><p>Unsurprising that C&#x2F;C++&#x2F;Java are all put in the &#x27;religion of the book&#x27; family, with great emphasis on proselytization.</div><br/></div></div></div></div></div></div><div id="36887739" class="c"><input type="checkbox" id="c-36887739" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887555">parent</a><span>|</span><a href="#36887833">prev</a><span>|</span><a href="#36888073">next</a><span>|</span><label class="collapse" for="c-36887739">[-]</label><label class="expand" for="c-36887739">[12 more]</label></div><br/><div class="children"><div class="content">Eventually you need to work with other people, and using a common time-shared or multi user session is unlikely. Now consider that lisp images generally can&#x27;t be easily diff&#x27;d or merged.<p>And with that the edit-and-continue paradigm loses much of its value. If you have to commit changes to a shared source file anyhow then you&#x27;ll be not much worse off with debugging a core dump.</div><br/><div id="36887900" class="c"><input type="checkbox" id="c-36887900" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887739">parent</a><span>|</span><a href="#36889161">next</a><span>|</span><label class="collapse" for="c-36887900">[-]</label><label class="expand" for="c-36887900">[9 more]</label></div><br/><div class="children"><div class="content">People say this a lot, but they fail to take into account that you can debug your server live as it continues to handle normal traffic. Even if you don’t deploy changes via the REPL, merely debugging the problem in a REPL without restarting anything is a huge win.</div><br/><div id="36887967" class="c"><input type="checkbox" id="c-36887967" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887900">parent</a><span>|</span><a href="#36889161">next</a><span>|</span><label class="collapse" for="c-36887967">[-]</label><label class="expand" for="c-36887967">[8 more]</label></div><br/><div class="children"><div class="content">Lots of languages that are not lisp have this ability.</div><br/><div id="36888412" class="c"><input type="checkbox" id="c-36888412" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887967">parent</a><span>|</span><a href="#36888205">next</a><span>|</span><label class="collapse" for="c-36888412">[-]</label><label class="expand" for="c-36888412">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think that they do. I know that Erlang has something similar; you can reload a module and it will gradually replace the old code as processes are replaced. In principle you could debug a single thread in a C (or C++) program without stopping the others, and some IDEs will let you edit the code and recompile while the program is running (they patch out the old function definition so that it jumps to the new one instead), but good luck doing that in production.<p>But don’t forget that in Common Lisp, you can redefine classes at run time as well as functions. All existing instances of the class will be updated to the new definition, and you can provide the code that decides how the old fields are translated into the new ones if the default behavior is insufficient. Good luck doing that in C or C++.<p>My favorite story involved a race condition that was discovered in the code running on a satellite, after it had been launched. The software on the satellite was mostly written in Common Lisp (there was a C component as well), so they opened a connection to the satellite, started the REPL, debugged the problem, and uploaded replacement code (which obviously added a lock or something) to the satellite all through that same REPL. While the satellite was a hundred million miles away from Earth, and while it kept performing it’s other duties. You can’t do that on a system which merely dumps core any time something unexpected happens.</div><br/><div id="36889230" class="c"><input type="checkbox" id="c-36889230" checked=""/><div class="controls bullet"><span class="by">maxwelljoslyn</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888412">parent</a><span>|</span><a href="#36888205">next</a><span>|</span><label class="collapse" for="c-36889230">[-]</label><label class="expand" for="c-36889230">[1 more]</label></div><br/><div class="children"><div class="content">Said &quot;software on satellite&quot; story is from Ron Garret, for anyone interested.<p><a href="https:&#x2F;&#x2F;flownet.com&#x2F;gat&#x2F;jpl-lisp.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;flownet.com&#x2F;gat&#x2F;jpl-lisp.html</a><p>&gt; During that time we were able to debug and fix a race condition that had not shown up during ground testing. (Debugging a program running on a $100M piece of hardware that is 100 million miles away is an interesting experience. Having a read-eval-print loop running on the spacecraft proved invaluable in finding and fixing the problem.</div><br/></div></div></div></div><div id="36888205" class="c"><input type="checkbox" id="c-36888205" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887967">parent</a><span>|</span><a href="#36888412">prev</a><span>|</span><a href="#36888233">next</a><span>|</span><label class="collapse" for="c-36888205">[-]</label><label class="expand" for="c-36888205">[4 more]</label></div><br/><div class="children"><div class="content">examples please, because so far i have only seen this from common lisp and smalltalk. there is also pike where i can reload classes or objects at runtime, thus avoiding a full restart, but it&#x27;s not as closely integrated as in smalltalk and you actually have to build your app in a way that allows you to do that.</div><br/><div id="36889719" class="c"><input type="checkbox" id="c-36889719" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888205">parent</a><span>|</span><a href="#36888975">next</a><span>|</span><label class="collapse" for="c-36889719">[-]</label><label class="expand" for="c-36889719">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript immediately comes to mind.</div><br/></div></div><div id="36888975" class="c"><input type="checkbox" id="c-36888975" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888205">parent</a><span>|</span><a href="#36889719">prev</a><span>|</span><a href="#36888233">next</a><span>|</span><label class="collapse" for="c-36888975">[-]</label><label class="expand" for="c-36888975">[2 more]</label></div><br/><div class="children"><div class="content">Java supports live debugging and profiling.</div><br/><div id="36889313" class="c"><input type="checkbox" id="c-36889313" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888975">parent</a><span>|</span><a href="#36888233">next</a><span>|</span><label class="collapse" for="c-36889313">[-]</label><label class="expand" for="c-36889313">[1 more]</label></div><br/><div class="children"><div class="content">But that’s not the same thing at all. If you’re debugging an exception in Java, you cannot continue execution as if the exception had not been thrown at all. With Common Lisp’s condition system you can.</div><br/></div></div></div></div></div></div><div id="36888233" class="c"><input type="checkbox" id="c-36888233" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887967">parent</a><span>|</span><a href="#36888205">prev</a><span>|</span><a href="#36889161">next</a><span>|</span><label class="collapse" for="c-36888233">[-]</label><label class="expand" for="c-36888233">[1 more]</label></div><br/><div class="children"><div class="content">Which?</div><br/></div></div></div></div></div></div><div id="36889161" class="c"><input type="checkbox" id="c-36889161" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887739">parent</a><span>|</span><a href="#36887900">prev</a><span>|</span><a href="#36888073">next</a><span>|</span><label class="collapse" for="c-36889161">[-]</label><label class="expand" for="c-36889161">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused. Why aren&#x27;t you all just working on your own machines?</div><br/><div id="36889746" class="c"><input type="checkbox" id="c-36889746" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36889161">parent</a><span>|</span><a href="#36888073">next</a><span>|</span><label class="collapse" for="c-36889746">[-]</label><label class="expand" for="c-36889746">[1 more]</label></div><br/><div class="children"><div class="content">The classic lisp way is to build a runtime image by editing the image while running it, then dumping a binary. You never specifically need to load a source file.<p>But you can&#x27;t easily collaborate with that style of development.</div><br/></div></div></div></div></div></div><div id="36888073" class="c"><input type="checkbox" id="c-36888073" checked=""/><div class="controls bullet"><span class="by">0xcde4c3db</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887555">parent</a><span>|</span><a href="#36887739">prev</a><span>|</span><a href="#36889054">next</a><span>|</span><label class="collapse" for="c-36888073">[-]</label><label class="expand" for="c-36888073">[1 more]</label></div><br/><div class="children"><div class="content">It probably didn&#x27;t help that a bunch of key Lisp people were leaning hard into proprietary $80,000 minicomputers right around the time that commodity(ish) microcomputers were about to massively explode in popularity.</div><br/></div></div><div id="36889054" class="c"><input type="checkbox" id="c-36889054" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887555">parent</a><span>|</span><a href="#36888073">prev</a><span>|</span><a href="#36889875">next</a><span>|</span><label class="collapse" for="c-36889054">[-]</label><label class="expand" for="c-36889054">[1 more]</label></div><br/><div class="children"><div class="content">Lisp is more of a meta-language than a mere language. Since it&#x27;s homoiconic, you eventually end up developing a domain-specific language that works great for your subject area. It also may make it a bit harder to onboard new team members, because the level of abstraction which you can reach can be relly high, all while keeping performance reasonable.<p>Technically, you could run e.g. a Python program under pdb, break on certain exceptions, and fix things inside a living system. It&#x27;s just not a customary way to do that.</div><br/></div></div><div id="36889875" class="c"><input type="checkbox" id="c-36889875" checked=""/><div class="controls bullet"><span class="by">atemerev</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887555">parent</a><span>|</span><a href="#36889054">prev</a><span>|</span><a href="#36887689">next</a><span>|</span><label class="collapse" for="c-36889875">[-]</label><label class="expand" for="c-36889875">[1 more]</label></div><br/><div class="children"><div class="content">“Avoid success at all costs”</div><br/></div></div><div id="36887689" class="c"><input type="checkbox" id="c-36887689" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887555">parent</a><span>|</span><a href="#36889875">prev</a><span>|</span><a href="#36887611">next</a><span>|</span><label class="collapse" for="c-36887689">[-]</label><label class="expand" for="c-36887689">[3 more]</label></div><br/><div class="children"><div class="content">Performance, approachability<p>Someone&#x27;s going to argue with me. Fair enough. Provide your explanation.</div><br/><div id="36887775" class="c"><input type="checkbox" id="c-36887775" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887689">parent</a><span>|</span><a href="#36887611">next</a><span>|</span><label class="collapse" for="c-36887775">[-]</label><label class="expand" for="c-36887775">[2 more]</label></div><br/><div class="children"><div class="content">this is an age old argument, but given the popularity of other slower languages, i&#x27;d rather think that approachability is the more critical issue.</div><br/><div id="36888355" class="c"><input type="checkbox" id="c-36888355" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887775">parent</a><span>|</span><a href="#36887611">next</a><span>|</span><label class="collapse" for="c-36888355">[-]</label><label class="expand" for="c-36888355">[1 more]</label></div><br/><div class="children"><div class="content">It’s the issue. The ever popular syntax issue continues to haunt it.<p>CL has had no real “unknown unknowns” for a very long time. While folks who newly discover it feel they found the gold idol in the jungle cave, the cave is, in truth, well explored, mapped, and documented but the idol is left behind.<p>All excuses to not use CL have long been, or have had the opportunity to be, addressed. Today, it’s fast enough, small enough, empowered through utilities and libraries enough, has different build and deployment scenarios to work with a vast array of applications. And yet here we are...still.<p>ABCL runs on the JVM, which runs everywhere on everything. Clojure, first class system on top of the JVM, but no real adoption. Some, to be sure, likely (I have no data) more than CL itself. But it’s still an blip on the radar.<p>Meanwhile, a bunch of hackers threw together a language sharing many aspects of the core feature set made popular in Lisp and Scheme runtime environments, made it look like an Algol step child with curly braces and everything, and since then an entire ecosystem of software has been written (and rewritten) into this system and it’s runtime is the focus of some of the largest companies in the history of civilization.<p>Raise your hand if you think that if the creators of JavaScript went with an S-expression syntax instead of a C&#x2F;Java derivative, we’d be running a VBA clone in our browsers (but nowhere else)?<p>Because at this juncture, THE thing that distinguishes CL and other Lisps from where we are today, is the syntax. Every other charm these systems enjoyed have been cherry picked away.<p>Advocates say the syntax is not an issue. It’s a feature m, not a bug. But the “wisdom of the crowds” has spoken, and they stay away.</div><br/></div></div></div></div></div></div><div id="36887611" class="c"><input type="checkbox" id="c-36887611" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887555">parent</a><span>|</span><a href="#36887689">prev</a><span>|</span><a href="#36888221">next</a><span>|</span><label class="collapse" for="c-36887611">[-]</label><label class="expand" for="c-36887611">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s questionable whether it&#x27;s really much better than just a debugger with a core dump (what I usually work on, it&#x27;s not any better). It is, however, a pretty snazzy feature.</div><br/><div id="36887745" class="c"><input type="checkbox" id="c-36887745" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887611">parent</a><span>|</span><a href="#36887767">next</a><span>|</span><label class="collapse" for="c-36887745">[-]</label><label class="expand" for="c-36887745">[6 more]</label></div><br/><div class="children"><div class="content">with a debugger, after you fix the application, you still have to restart and run it again. the big benefit here is that no restart is required.<p>smalltalk can do the same btw. i had been working on a small website where a specific request from the browser would fail. instead of sending a failure message the request would just hang. in the mean time on the server in my pharo smalltalk window an error would pop up. when i fixed the error,  the download of the request resumed in the browser as if nothing had happened other than a delay.</div><br/><div id="36887802" class="c"><input type="checkbox" id="c-36887802" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887745">parent</a><span>|</span><a href="#36887850">next</a><span>|</span><label class="collapse" for="c-36887802">[-]</label><label class="expand" for="c-36887802">[2 more]</label></div><br/><div class="children"><div class="content">&gt; with a debugger, after you fix the application, you still have to restart and run it again. the big benefit here is that no restart is required.<p>We like to make sure everything running in prod is verifiably built from source in-repo. So that&#x27;s the thing, while it&#x27;s a really snazzy feature for sure, the value over the rest of the world is on the questionable side. At least for our use case, but I think it&#x27;s true for <i>most</i> use cases.<p>edit: Also really curious about your smalltalk and pharo experience. Sounds fascinating!</div><br/><div id="36887917" class="c"><input type="checkbox" id="c-36887917" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887802">parent</a><span>|</span><a href="#36887850">next</a><span>|</span><label class="collapse" for="c-36887917">[-]</label><label class="expand" for="c-36887917">[1 more]</label></div><br/><div class="children"><div class="content">once you fixed the problem you of course commit the change to the code on disk. there is nothing in the workflow that prevents you from doing that. you are not going to just fix apps in production without running your tests and what not. at worst you fix an error in a production system, and run the tests afterwards to make sure everything is clean. but mostly this feature is used during development when your code is still incomplete. not having to restart every time there is an error simply speeds up your development loop.</div><br/></div></div></div></div><div id="36887850" class="c"><input type="checkbox" id="c-36887850" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887745">parent</a><span>|</span><a href="#36887802">prev</a><span>|</span><a href="#36887767">next</a><span>|</span><label class="collapse" for="c-36887850">[-]</label><label class="expand" for="c-36887850">[3 more]</label></div><br/><div class="children"><div class="content">I am really curious about your experience with Smalltalk and Pharo!</div><br/><div id="36888072" class="c"><input type="checkbox" id="c-36888072" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887850">parent</a><span>|</span><a href="#36887767">next</a><span>|</span><label class="collapse" for="c-36888072">[-]</label><label class="expand" for="c-36888072">[2 more]</label></div><br/><div class="children"><div class="content">i am really just a beginner with smalltalk and CL. as a vim user i didn&#x27;t really have a good integration of the CL repl with the editor  (there were tools, but they weren&#x27;t as straightforward to set up as slime would have been). and when i encountered the breakloop i didn&#x27;t really know what do to and just tried to get out of it as quickly as i could. (exiting vim is easier ;-)
the thing that bothered me was that when i change code in the repl without an integrated editor, then how do i keep track of the changes and make sure i don&#x27;t loose them? but then, i just never tried to set up a proper environment.<p>in smalltalk on the other hand you get a nice IDE with all the comforts of a GUI. you have your windows where you browse your code neatly structured in classes and methods. there is a window where you run your app and manage your tests which light up red or green if they fail or pass, another which logs error or other print messages, and if an error happens while an app is running a new window pops up, showing you a trace of what was running and a text field with the code that failed, like in a debugger, and right there you can edit the code and resume.<p>the code is written to your class, and when you go back to your code browser the change is reflected there, and you can commit it to a version control system. pharo btw has pretty good integration with git, and already a few years ago it almost acted like a git gui. it&#x27;s probably even better now. the primary downside is that the text editor in pharo is simple, like a browser text area, and not a sophisticated editor like emacs or vim.</div><br/><div id="36889249" class="c"><input type="checkbox" id="c-36889249" checked=""/><div class="controls bullet"><span class="by">maxwelljoslyn</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888072">parent</a><span>|</span><a href="#36887767">next</a><span>|</span><label class="collapse" for="c-36889249">[-]</label><label class="expand" for="c-36889249">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [Lisp] the thing that bothered me was that when i change code in the repl without an integrated editor, then how do i keep track of the changes and make sure i don&#x27;t loose them<p>&gt; [Smalltalk] the code is written to your class, and when you go back to your code browser the change is reflected there<p>I feel your pain. &quot;writing the changes back to the source code definition&quot; seemed like a no-brainer desirable feature of a Lisp REPL, yet I could not find a way to do that out of the box using Slime. I&#x27;m sure one could program it, however! Bet someone has...</div><br/></div></div></div></div></div></div></div></div><div id="36887767" class="c"><input type="checkbox" id="c-36887767" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887611">parent</a><span>|</span><a href="#36887745">prev</a><span>|</span><a href="#36888221">next</a><span>|</span><label class="collapse" for="c-36887767">[-]</label><label class="expand" for="c-36887767">[2 more]</label></div><br/><div class="children"><div class="content">In my experience, it&#x27;s definitely better for prototyping because if you hit an error that is difficult to reproduce, you can update your code and try again, without having to try and create reliable steps to reproduce the problem.</div><br/><div id="36887889" class="c"><input type="checkbox" id="c-36887889" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887767">parent</a><span>|</span><a href="#36888221">next</a><span>|</span><label class="collapse" for="c-36887889">[-]</label><label class="expand" for="c-36887889">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I can see this being a pretty handy feature for prototyping. Otherwise you&#x27;ll need to, like, catch errors in your main loop to ensure you don&#x27;t have some program-halting issue while you&#x27;re working.</div><br/></div></div></div></div></div></div></div></div><div id="36888221" class="c"><input type="checkbox" id="c-36888221" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#36887243">parent</a><span>|</span><a href="#36887555">prev</a><span>|</span><a href="#36888563">next</a><span>|</span><label class="collapse" for="c-36888221">[-]</label><label class="expand" for="c-36888221">[5 more]</label></div><br/><div class="children"><div class="content">That sounds intriguing as a Clojure dev but what happens in the following case (not very lispy code but it&#x27;s just to show what I don&#x27;t get):<p><pre><code>    (do-it (do-it first))
</code></pre>
What if (do-it first) works fine, but it&#x27;s the call to (do-it (do-it first)) that fails?<p>I get control right where it&#x27;s broken, so I can fix the do-it <i>defun</i>.  Great, I like that.  But by fixing it, this means I changed the result of (do-it first).<p>So the point at which the machine (?) is is a point that&#x27;s unreachable anymore by the current code.<p>I hope my example is clear enough.<p>I really don&#x27;t understand how that works when fixing what would allow you to continue would change the state at which you&#x27;re given control to fix things?</div><br/><div id="36888356" class="c"><input type="checkbox" id="c-36888356" checked=""/><div class="controls bullet"><span class="by">belmarca</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888221">parent</a><span>|</span><a href="#36888264">next</a><span>|</span><label class="collapse" for="c-36888356">[-]</label><label class="expand" for="c-36888356">[1 more]</label></div><br/><div class="children"><div class="content">Please excuse the really contrived example, but you can do this in Gambit:<p><pre><code>    ~ cat do-it.scm
  (define (do-it x)
    (if (&gt; x 0)
        x
        &#x27;error))
  
  (define (do-it-fixed x)
    (if (and (number? x) (&gt; x 0))
        x
        &#x27;error))
  ~ gsi do-it.scm -
  &gt; (do-it (do-it 0))
  *** ERROR IN do-it, &quot;do-it.scm&quot;@2.7 -- (Argument 2) REAL expected
  (&gt; &#x27;error 0)
  1&gt; ,b
  0  do-it                   &quot;do-it.scm&quot;@2:7         (&gt; x 0)
  1  (interaction)           (stdin)@1:1             (do-it (do-it 0))
  2  ##main                  
  1&gt; ,e
  x = &#x27;error
  1&gt; (set! do-it do-it-fixed) 
  1&gt; ,(c x)
  error
  &gt; (do-it (do-it 0))
  error
</code></pre>
Per the Gambit docs[1], &quot;The nested REPL’s continuation and evaluation environment are the same as the point where the evaluation was stopped.&quot;. The call to ,(c x) is really just calling the reified continuation c with argument x.<p>[1]: <a href="https:&#x2F;&#x2F;gambitscheme.org&#x2F;latest&#x2F;manual&#x2F;#Debugging" rel="nofollow noreferrer">https:&#x2F;&#x2F;gambitscheme.org&#x2F;latest&#x2F;manual&#x2F;#Debugging</a></div><br/></div></div><div id="36888264" class="c"><input type="checkbox" id="c-36888264" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888221">parent</a><span>|</span><a href="#36888356">prev</a><span>|</span><a href="#36888563">next</a><span>|</span><label class="collapse" for="c-36888264">[-]</label><label class="expand" for="c-36888264">[3 more]</label></div><br/><div class="children"><div class="content">you didn&#x27;t necessarily change the result of (do-it first), you may have, but that just means you introduced another error.<p>i think the approach here is to accept that you fixed the bug for the second call, but you will still have to go back and retest the first call.</div><br/><div id="36888811" class="c"><input type="checkbox" id="c-36888811" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888264">parent</a><span>|</span><a href="#36888319">next</a><span>|</span><label class="collapse" for="c-36888811">[-]</label><label class="expand" for="c-36888811">[1 more]</label></div><br/><div class="children"><div class="content">Lisp used to specialize in offering extravagantly expensive features, maybe time travel debugging would be a good addition.</div><br/></div></div><div id="36888319" class="c"><input type="checkbox" id="c-36888319" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888264">parent</a><span>|</span><a href="#36888811">prev</a><span>|</span><a href="#36888563">next</a><span>|</span><label class="collapse" for="c-36888319">[-]</label><label class="expand" for="c-36888319">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you didn&#x27;t necessarily change the result of (do-it first)<p>You&#x27;re right.<p>&gt; i think the approach here is to accept that you fixed the bug for the second call, but you will still have to go back and retest the first call.<p>Gotcha.  It looks like a very useful feature.  I may actually just try it to try to understand how it works: especially since TFA says the CL integration with Emacs is good (I happen to be an Emacs user).</div><br/></div></div></div></div></div></div><div id="36888563" class="c"><input type="checkbox" id="c-36888563" checked=""/><div class="controls bullet"><span class="by">BaseballPhysics</span><span>|</span><a href="#36887243">parent</a><span>|</span><a href="#36888221">prev</a><span>|</span><a href="#36888967">next</a><span>|</span><label class="collapse" for="c-36888563">[-]</label><label class="expand" for="c-36888563">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What makes the difference is the breakloop, a full-blown REPL that opens when an error in a program occurs. Not a stacktrace, not a debugger; just build from the point where it&#x27;s currently broken.<p>This just makes me wanna bust open a smalltalk image...</div><br/></div></div><div id="36888967" class="c"><input type="checkbox" id="c-36888967" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#36887243">parent</a><span>|</span><a href="#36888563">prev</a><span>|</span><a href="#36887738">next</a><span>|</span><label class="collapse" for="c-36888967">[-]</label><label class="expand" for="c-36888967">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t all this stuff a vector for malicious code and security vulnerabilities in production ?</div><br/><div id="36889010" class="c"><input type="checkbox" id="c-36889010" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36888967">parent</a><span>|</span><a href="#36887738">next</a><span>|</span><label class="collapse" for="c-36889010">[-]</label><label class="expand" for="c-36889010">[1 more]</label></div><br/><div class="children"><div class="content">No.</div><br/></div></div></div></div><div id="36887738" class="c"><input type="checkbox" id="c-36887738" checked=""/><div class="controls bullet"><span class="by">belmarca</span><span>|</span><a href="#36887243">parent</a><span>|</span><a href="#36888967">prev</a><span>|</span><a href="#36889677">next</a><span>|</span><label class="collapse" for="c-36887738">[-]</label><label class="expand" for="c-36887738">[3 more]</label></div><br/><div class="children"><div class="content">This is standard in Gambit Scheme as well.</div><br/><div id="36887942" class="c"><input type="checkbox" id="c-36887942" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887738">parent</a><span>|</span><a href="#36889677">next</a><span>|</span><label class="collapse" for="c-36887942">[-]</label><label class="expand" for="c-36887942">[2 more]</label></div><br/><div class="children"><div class="content">It supports modifying code in the middle of an error and continuing on? I hadn’t found that in a Scheme before!</div><br/><div id="36888193" class="c"><input type="checkbox" id="c-36888193" checked=""/><div class="controls bullet"><span class="by">belmarca</span><span>|</span><a href="#36887243">root</a><span>|</span><a href="#36887942">parent</a><span>|</span><a href="#36889677">next</a><span>|</span><label class="collapse" for="c-36888193">[-]</label><label class="expand" for="c-36888193">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure you can find differences, but here&#x27;s an example adapted from the docs[1]:<p><pre><code>  Gambit v4.9.5
  
  &gt; (let ((x 10) (y (- 1 1))) (\* (&#x2F; x y) 2))
  \*\* ERROR IN (stdin)@1.30 -- Divide by zero
  (&#x2F; 10 0)
  1&gt; ,e
  x = 10
  y = 0
  1&gt; (set! y 2)
  1&gt; ,(c y)
  4
  &gt;
</code></pre>
[1]: <a href="https:&#x2F;&#x2F;gambitscheme.org&#x2F;latest&#x2F;manual&#x2F;#Debugging" rel="nofollow noreferrer">https:&#x2F;&#x2F;gambitscheme.org&#x2F;latest&#x2F;manual&#x2F;#Debugging</a></div><br/></div></div></div></div></div></div></div></div><div id="36889677" class="c"><input type="checkbox" id="c-36889677" checked=""/><div class="controls bullet"><span class="by">Roark66</span><span>|</span><a href="#36887243">prev</a><span>|</span><a href="#36890615">next</a><span>|</span><label class="collapse" for="c-36889677">[-]</label><label class="expand" for="c-36889677">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be interested in if you considered Guile first and what made you decide in favor of common lisp. Few years ago when I decided its finally time to learn lisp I looked at few variants and Guile seemed to have the benefit of: fairly vibrant(but somewhat hermetic) online community, a sizable manual that describes most frequently used APIs (you can learn the language itself very quickly, but it&#x27;s the knowledge of the APIs you need to do anything in the &quot;real world&quot;), and being actively maintained and extended. So I chose Guile.<p>For those that don&#x27;t know these terms Guile and common lisp are two implementations of the same scheme language (simplifying a lot).</div><br/></div></div><div id="36890615" class="c"><input type="checkbox" id="c-36890615" checked=""/><div class="controls bullet"><span class="by">ghfwlc</span><span>|</span><a href="#36889677">prev</a><span>|</span><a href="#36889228">next</a><span>|</span><label class="collapse" for="c-36890615">[-]</label><label class="expand" for="c-36890615">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp is still the most pleasant REPL language. The only complaint I have is that too many function names are taken due to the large spec.</div><br/></div></div><div id="36889228" class="c"><input type="checkbox" id="c-36889228" checked=""/><div class="controls bullet"><span class="by">dutchblacksmith</span><span>|</span><a href="#36890615">prev</a><span>|</span><a href="#36889167">next</a><span>|</span><label class="collapse" for="c-36889228">[-]</label><label class="expand" for="c-36889228">[1 more]</label></div><br/><div class="children"><div class="content">Big fan of Lispworks (Yes, there is a free version). Using it in production, as many others. Using Quicklisp in experiments. Not direct in my codebase. Lisp will always be there. Learning Lisp will make you a better programmer, while having fun.</div><br/></div></div><div id="36889167" class="c"><input type="checkbox" id="c-36889167" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#36889228">prev</a><span>|</span><a href="#36887505">next</a><span>|</span><label class="collapse" for="c-36889167">[-]</label><label class="expand" for="c-36889167">[1 more]</label></div><br/><div class="children"><div class="content">There is something very playful about lisp that is so intriguing to me.  I&#x27;ve come to rely heavily on powerful type systems at work (which is amazing), but lisp feels like unbounded imagination flowing at my fingertips.</div><br/></div></div><div id="36887505" class="c"><input type="checkbox" id="c-36887505" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#36889167">prev</a><span>|</span><a href="#36887494">next</a><span>|</span><label class="collapse" for="c-36887505">[-]</label><label class="expand" for="c-36887505">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why the author says:<p>&gt; I had previously abandoned using Scheme because, frankly, I ran out of free time for exploratory programming.<p>But they find Common Lisp acceptable. In what way are Schemes more &quot;exploratory&quot; than Common Lisp? Isn&#x27;t that exactly what the author says they like about CL (REPL driven development)?</div><br/><div id="36887538" class="c"><input type="checkbox" id="c-36887538" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887505">parent</a><span>|</span><a href="#36887494">next</a><span>|</span><label class="collapse" for="c-36887538">[-]</label><label class="expand" for="c-36887538">[5 more]</label></div><br/><div class="children"><div class="content">Sorry that was unclear. What I meant was: a while back, I was exploring Scheme (motivated by SICP) and then ran out of free time. Now, I’ve got some free time again and want to try Common Lisp because of the REPL-driven workflow.<p>It wasn’t meant to be a comment on Scheme vs. CL.</div><br/><div id="36887834" class="c"><input type="checkbox" id="c-36887834" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#36887505">root</a><span>|</span><a href="#36887538">parent</a><span>|</span><a href="#36887839">next</a><span>|</span><label class="collapse" for="c-36887834">[-]</label><label class="expand" for="c-36887834">[1 more]</label></div><br/><div class="children"><div class="content">i found the repl driven workflow intriguing but i could never get into it. i am not an emacs user and the vim integration wasn&#x27;t as good as slime promises to be and i couldn&#x27;t really get comfortable running lisp from within vim. not ssure, i probably didn&#x27;t try to hard.<p>smalltalk on the other hand made this a lot easier. not repl driven but having an actual UI to manage code and handling errors it provides the same ability to fix issues at runtime without restarting but with a nicer interface to manage the code.</div><br/></div></div><div id="36887839" class="c"><input type="checkbox" id="c-36887839" checked=""/><div class="controls bullet"><span class="by">gorjusborg</span><span>|</span><a href="#36887505">root</a><span>|</span><a href="#36887538">parent</a><span>|</span><a href="#36887834">prev</a><span>|</span><a href="#36887809">next</a><span>|</span><label class="collapse" for="c-36887839">[-]</label><label class="expand" for="c-36887839">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for clarifying.<p>I recently went into the lispy rabbit hole for a while.<p>Scheme is so beautiful.<p>CL seems more willing to compromise for pragmatism.</div><br/><div id="36887932" class="c"><input type="checkbox" id="c-36887932" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#36887505">root</a><span>|</span><a href="#36887839">parent</a><span>|</span><a href="#36887809">next</a><span>|</span><label class="collapse" for="c-36887932">[-]</label><label class="expand" for="c-36887932">[1 more]</label></div><br/><div class="children"><div class="content">Yes, CL is extremely pragmatic. And Scheme was invented specifically as a pedagogical tool, so everything is much cleaner. At least until you install scm-utils, and find that it added an entire computer algebra system and physics simulation system and so on. :)</div><br/></div></div></div></div><div id="36887809" class="c"><input type="checkbox" id="c-36887809" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#36887505">root</a><span>|</span><a href="#36887538">parent</a><span>|</span><a href="#36887839">prev</a><span>|</span><a href="#36887494">next</a><span>|</span><label class="collapse" for="c-36887809">[-]</label><label class="expand" for="c-36887809">[1 more]</label></div><br/><div class="children"><div class="content">I see, thanks for clarifying!</div><br/></div></div></div></div></div></div><div id="36887494" class="c"><input type="checkbox" id="c-36887494" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#36887505">prev</a><span>|</span><a href="#36888419">next</a><span>|</span><label class="collapse" for="c-36887494">[-]</label><label class="expand" for="c-36887494">[3 more]</label></div><br/><div class="children"><div class="content">Me too buddy. I&#x27;m not even sure how I got to this point, but I can&#x27;t go back.</div><br/><div id="36888438" class="c"><input type="checkbox" id="c-36888438" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36887494">parent</a><span>|</span><a href="#36888419">next</a><span>|</span><label class="collapse" for="c-36888438">[-]</label><label class="expand" for="c-36888438">[2 more]</label></div><br/><div class="children"><div class="content">Care to share what you’re using CL for?</div><br/><div id="36890785" class="c"><input type="checkbox" id="c-36890785" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#36887494">root</a><span>|</span><a href="#36888438">parent</a><span>|</span><a href="#36888419">next</a><span>|</span><label class="collapse" for="c-36890785">[-]</label><label class="expand" for="c-36890785">[1 more]</label></div><br/><div class="children"><div class="content">I automate my workflow for approval of rhel kernel content to customers.   Keeping the wheels on the delivery of 12 different streams of kernels to customers.<p>It also controls the workflow of delivery of intermediate &quot;hot fix&quot; kernels between scheduled releases when fixes are needed immediately.<p>I also use it for gathering metrics on gitlab ci and internal pipelines, alerting if the system is stalling or performing outside   acceptable limits.</div><br/></div></div></div></div></div></div><div id="36888419" class="c"><input type="checkbox" id="c-36888419" checked=""/><div class="controls bullet"><span class="by">jbottoms</span><span>|</span><a href="#36887494">prev</a><span>|</span><a href="#36887878">next</a><span>|</span><label class="collapse" for="c-36888419">[-]</label><label class="expand" for="c-36888419">[1 more]</label></div><br/><div class="children"><div class="content">Then Prolog should be somewhere on your list also.</div><br/></div></div><div id="36887878" class="c"><input type="checkbox" id="c-36887878" checked=""/><div class="controls bullet"><span class="by">trhr</span><span>|</span><a href="#36888419">prev</a><span>|</span><a href="#36887533">next</a><span>|</span><label class="collapse" for="c-36887878">[-]</label><label class="expand" for="c-36887878">[1 more]</label></div><br/><div class="children"><div class="content">When I want &quot;this will run forever,&quot; I write it in Rust.<p>When I want &quot;this will compile forever,&quot; I write it in ANSI C.<p>When I want &quot;this will live forever,&quot; I write it Python 2.7 and make it the backbone of the entire org&#x27;s infra templating. Bonus points if it&#x27;s a custom Ansible module.</div><br/></div></div><div id="36887533" class="c"><input type="checkbox" id="c-36887533" checked=""/><div class="controls bullet"><span class="by">robomartin</span><span>|</span><a href="#36887878">prev</a><span>|</span><a href="#36888409">next</a><span>|</span><label class="collapse" for="c-36887533">[-]</label><label class="expand" for="c-36887533">[4 more]</label></div><br/><div class="children"><div class="content">Let me preface this by saying I used LISP professionally in the &#x27;80&#x27;s for about ten years.<p>It&#x27;s a great language.  It is right up there at the top of my list with Assembler, APL and Forth as languages that taught me so much more than the typical C-like language path most people are exposed to today.  And, yes, I used those languages professionally for years.<p>I have always said it is important to learn these non-C languages.<p>However...<p>&gt; I&#x27;ve spent some time contemplating future-proof programming languages because I want to ensure that code I write will be usable in the future.<p>I think it is clear that it will not be long until you can use an AI-based tool to translate any program from language A to language B.  And, in fact, likely improve, maintain and extend it.<p>For example, you might be able to have the AI tool write a function or module in assembler targeted at different processors and be able to accelerate critical code in a platform-specific manner that would be almost impossible for most developers to manage and maintain today.<p>I experimented with some of this using ChatGPT.  We built a product using MicroPython that require hard real time performance.  Sure, MicroPython was not the right choice to begin with.  This was one of those projects where we walked into something that morphed and we were stuck.  Being that I am perfectly comfortable in assembler, I replaced chunks of code with ARM assembly routings.  The performance boost was massive, of course.<p>As an experiment, I wrote a specification for one of those modules and asked ChatGPT to write the code in ARM assembler.  It took all of five seconds to get a listing.  Let&#x27;s just say it took me a lot longer.  The code was not optimal, yet, it worked just fine.  Someone like me, with experience in the domain, could easily take that as a starting point and improve from there.  Just for kicks, I asked ChatGPT to write the same code in C, C++, JS, Python, 8080, 8085, 6502, 68K and x86 assembler.  That probably took a minute or so.  Did not test all of the generated code.  All of it looked like it would run just fine.<p>In other words, I believe that, today, the only reason to pick a language is likely something like:  It&#x27;s what I know and it has the libraries, frameworks and support I need.  In some cases, it&#x27;s because it&#x27;s the only way to achieve required performance (example: Python is 70+ times slower than C).<p>Code longevity is not likely to be an issue at all.</div><br/><div id="36887740" class="c"><input type="checkbox" id="c-36887740" checked=""/><div class="controls bullet"><span class="by">nescioquid</span><span>|</span><a href="#36887533">parent</a><span>|</span><a href="#36887680">next</a><span>|</span><label class="collapse" for="c-36887740">[-]</label><label class="expand" for="c-36887740">[1 more]</label></div><br/><div class="children"><div class="content">I was going to reply by suggesting emacs lisp as a candidate language, really making it a bet on how long emacs will be around. Will people (commonly) be using emacs in 50 years? I think people will, though I hesitate to say so. If it turns out that we converge on text as a necessary interface to a computer (at least in some cases), maybe the bet pays off.<p>But I think your idea that the expression of a program will become fungible or machine-translatable is much more salient. Though if the program itself depends on a whole chain of ancient dependencies and idioms (think a VB UI in front of an Access DB) might run afoul of infinite regress. So, to really future-proof on a long time-horizon, it seems you need to be preoccupied with a lot more than the programming language.</div><br/></div></div><div id="36887680" class="c"><input type="checkbox" id="c-36887680" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36887533">parent</a><span>|</span><a href="#36887740">prev</a><span>|</span><a href="#36887921">next</a><span>|</span><label class="collapse" for="c-36887680">[-]</label><label class="expand" for="c-36887680">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In other words, I believe that, today, the only reason to pick a language is likely something like: It&#x27;s what I know and it has the libraries, frameworks and support I need.<p>I would take it even further and say that in the near future, everyone will have their own beloved DSL completely customized to their needs and the AI will be able to translate any code to your favorite DSL. You’ll code and commit the changes and the AI will take care of that and convert it back to other peoples’ DSL’s.</div><br/></div></div><div id="36887921" class="c"><input type="checkbox" id="c-36887921" checked=""/><div class="controls bullet"><span class="by">at_a_remove</span><span>|</span><a href="#36887533">parent</a><span>|</span><a href="#36887680">prev</a><span>|</span><a href="#36888409">next</a><span>|</span><label class="collapse" for="c-36887921">[-]</label><label class="expand" for="c-36887921">[1 more]</label></div><br/><div class="children"><div class="content">I strongly agree.  For me, it&#x27;s the libraries.<p>Not just having libraries, but having One Obvious Choice.  I don&#x27;t want to compare and contrast libraries, realize that one has sixty percent of what I need, the other has eighty, and they overlap for about forty percent of it.<p>More and more, I think in terms of algorithms and data structures over anything else.  Being able to express those fluently is my focus.<p>So to bring it around to your comment, what I like to imagine is that someone designs a programming language where the focus is on the ability of the language to be translated to other languages.  Then, libraries will be built out, everything that is in standard Python and more.  Once a translator is built and tweaked, we could have functional (not like the paradigm) libraries for any langue you fancy.<p>Yes, the translator would need to be more constrained to avoid &quot;hallucination&quot; and I am sure the resultant libraries would be slow, inefficient, and so on, but they would be <i>there</i>.  As it stands now, I think there&#x27;s a lot of rebuilding the wheel in scores of languages.  I wouldn&#x27;t say that the effort is wasted, exactly, but I can imagine talented programmers making better use of their time.</div><br/></div></div></div></div><div id="36888409" class="c"><input type="checkbox" id="c-36888409" checked=""/><div class="controls bullet"><span class="by">10g1k</span><span>|</span><a href="#36887533">prev</a><span>|</span><label class="collapse" for="c-36888409">[-]</label><label class="expand" for="c-36888409">[8 more]</label></div><br/><div class="children"><div class="content">There are plenty of old business systems which are critical, can&#x27;t be removed or turned off, and use LISP, COBOL, etc.  Meanwhile, nothing important uses Clojure or other trendy flash-in-the-pan language.  If you want an interesting project, sure, use Clojure or something.  If you want money, learn COBOL.</div><br/><div id="36889127" class="c"><input type="checkbox" id="c-36889127" checked=""/><div class="controls bullet"><span class="by">xedrac</span><span>|</span><a href="#36888409">parent</a><span>|</span><a href="#36889130">next</a><span>|</span><label class="collapse" for="c-36889127">[-]</label><label class="expand" for="c-36889127">[4 more]</label></div><br/><div class="children"><div class="content">I hear this a lot, but have never once seen a COBOL job posting.</div><br/><div id="36889888" class="c"><input type="checkbox" id="c-36889888" checked=""/><div class="controls bullet"><span class="by">asimovfan</span><span>|</span><a href="#36888409">root</a><span>|</span><a href="#36889127">parent</a><span>|</span><a href="#36889136">next</a><span>|</span><label class="collapse" for="c-36889888">[-]</label><label class="expand" for="c-36889888">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;de.indeed.com&#x2F;q-cobol-entwickler-jobs.html?vjk=8d36a8c68f360866" rel="nofollow noreferrer">https:&#x2F;&#x2F;de.indeed.com&#x2F;q-cobol-entwickler-jobs.html?vjk=8d36a...</a></div><br/></div></div><div id="36889136" class="c"><input type="checkbox" id="c-36889136" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#36888409">root</a><span>|</span><a href="#36889127">parent</a><span>|</span><a href="#36889888">prev</a><span>|</span><a href="#36889233">next</a><span>|</span><label class="collapse" for="c-36889136">[-]</label><label class="expand" for="c-36889136">[1 more]</label></div><br/><div class="children"><div class="content">I think a lot of these jobs go to former employees who now contract.</div><br/></div></div><div id="36889233" class="c"><input type="checkbox" id="c-36889233" checked=""/><div class="controls bullet"><span class="by">10g1k</span><span>|</span><a href="#36888409">root</a><span>|</span><a href="#36889127">parent</a><span>|</span><a href="#36889136">prev</a><span>|</span><a href="#36889130">next</a><span>|</span><label class="collapse" for="c-36889233">[-]</label><label class="expand" for="c-36889233">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because gigs in trendy languages come and go, and you might earn good pay for six months, whereas cobol gigs run for 20 years and pay consistently high salaries.</div><br/></div></div></div></div><div id="36889130" class="c"><input type="checkbox" id="c-36889130" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#36888409">parent</a><span>|</span><a href="#36889127">prev</a><span>|</span><a href="#36889199">next</a><span>|</span><label class="collapse" for="c-36889130">[-]</label><label class="expand" for="c-36889130">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not as though the company that bought the consultancy that employs many of the core Clojure people runs a bank with Clojure.</div><br/></div></div><div id="36889199" class="c"><input type="checkbox" id="c-36889199" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#36888409">parent</a><span>|</span><a href="#36889130">prev</a><span>|</span><a href="#36888525">next</a><span>|</span><label class="collapse" for="c-36889199">[-]</label><label class="expand" for="c-36889199">[1 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re gonna go off what has the most businesses built on it, LISP wouldn&#x27;t even be in the top 20</div><br/></div></div><div id="36888525" class="c"><input type="checkbox" id="c-36888525" checked=""/><div class="controls bullet"><span class="by">jcpst</span><span>|</span><a href="#36888409">parent</a><span>|</span><a href="#36889199">prev</a><span>|</span><label class="collapse" for="c-36888525">[-]</label><label class="expand" for="c-36888525">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t walmart use clojure?</div><br/></div></div></div></div></div></div></div></div></div></body></html>