<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720688470030" as="style"/><link rel="stylesheet" href="styles.css?v=1720688470030"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.timdbg.com/posts/useless-x86-trivia/">Things I learned while writing an x86 emulator (2013)</a> <span class="domain">(<a href="https://www.timdbg.com">www.timdbg.com</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>102 comments</span></div><br/><div><div id="40929438" class="c"><input type="checkbox" id="c-40929438" checked=""/><div class="controls bullet"><span class="by">aengelke</span><span>|</span><a href="#40929076">next</a><span>|</span><label class="collapse" for="c-40929438">[-]</label><label class="expand" for="c-40929438">[30 more]</label></div><br/><div class="children"><div class="content">Bonus quirk: there&#x27;s BSF&#x2F;BSR, for which the Intel SDM states that on zero input, the destination has an undefined value. (AMD documents that the destination is not modified in that case.) And then there&#x27;s glibc, which happily uses the undocumented fact that the destination is also unmodified on Intel [1]. It took me quite some time to track down the issue in my binary translator. (There&#x27;s also TZCNT&#x2F;LZCNT, which is BSF&#x2F;BSR encoded with F3-prefix -- which is silently ignored on older processors not supporting the extension. So the same code will behave differently on different CPUs. At least, that&#x27;s documented.)<p>Encoding: People often complain about prefixes, but IMHO, that&#x27;s by far not the worst thing. It is well known and somewhat well documented. There are worse quirks: For example, REX&#x2F;VEX&#x2F;EVEX.RXB extension bits are ignored when they do not apply (e.g., MMX registers); except for mask registers (k0-k7), where they trigger #UD -- also fine -- except if the register is encoded in ModRM.rm, in which case the extension bit is ignored again.<p>APX takes the number of quirks to a different level: the REX2 prefix can encode general-purpose registers r16-r31, but not xmm16-xmm31; the EVEX prefix has several opcode-dependent layouts; and the extension bits for a register used depend on the register type (XMM registers use X3:B3:rm and V4:X3:idx; GP registers use B4:B3:rm, X4:X3:idx). I can&#x27;t give a complete list yet, I still haven&#x27;t finished my APX decoder after a year...<p>[1]: <a href="https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=31748" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=31748</a></div><br/><div id="40930717" class="c"><input type="checkbox" id="c-40930717" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40929438">parent</a><span>|</span><a href="#40931425">next</a><span>|</span><label class="collapse" for="c-40930717">[-]</label><label class="expand" for="c-40930717">[8 more]</label></div><br/><div class="children"><div class="content">On and off over the last year I have been rewriting QEMU&#x27;s x86 decoder. It started as a necessary task to incorporate AVX support, but I am now at a point where only a handful of opcodes are left to rewrite, after which it should not be too hard to add APX support. For EVEX my plan is to keep the raw bits until after the opcode has been read (i.e. before immediates and possibly before modrm) and the EVEX class identified.<p>My decoder is mostly based on the tables in the manual, and the code is mostly okay—not too much indentation and phases mostly easy to separate&#x2F;identify. Because the output is JITted code, it&#x27;s ok to not be super efficient and keep the code readable; it&#x27;s not where most of the time is spent. Nevertheless there are several cases in which the manual is wrong or doesn&#x27;t say the whole story. And the tables haven&#x27;t been updated for several years (no K register instructions, for example), so going forward there will be more manual work to do. :(<p>The top comment explains a bit what&#x27;s going on: <a href="https:&#x2F;&#x2F;github.com&#x2F;qemu&#x2F;qemu&#x2F;blob&#x2F;59084feb256c617063e0dbe7e64821ae8852d7cf&#x2F;target&#x2F;i386&#x2F;tcg&#x2F;decode-new.c.inc#L22">https:&#x2F;&#x2F;github.com&#x2F;qemu&#x2F;qemu&#x2F;blob&#x2F;59084feb256c617063e0dbe7e6...</a><p>(As I said above, there are still a few instructions handled by the old code predating the rewrite, notably BT&#x2F;BTS&#x2F;BTR&#x2F;BTC. I have written the code but not merged it yet).</div><br/><div id="40931081" class="c"><input type="checkbox" id="c-40931081" checked=""/><div class="controls bullet"><span class="by">aengelke</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930717">parent</a><span>|</span><a href="#40931425">next</a><span>|</span><label class="collapse" for="c-40931081">[-]</label><label class="expand" for="c-40931081">[7 more]</label></div><br/><div class="children"><div class="content">Thanks for the pointer to QEMU&#x27;s decoder! I actually never looked at it before.<p>So you coded all the tables manually in C -- interesting, that&#x27;s quite some effort. I opted to autogenerate the tables (and keep them as data only =&gt; smaller memory footprint) [1,2]. That&#x27;s doable, because x86 encodings are mostly fairly consistent. I can also generate an encoder from it (ok, you don&#x27;t need that). Re &#x27;custom size &quot;xh&quot;&#x27;: AVX-512 also has fourth and eighth. Also interesting that you have a separate row for &quot;66+F2&quot;. I special case these two (CRC32, MOVBE) instructions with a flag.<p>I think the prefix decoding is not quite right for x86-64: 26&#x2F;2e&#x2F;36&#x2F;3e are ignored in 64-bit mode, except for 2e&#x2F;3e as branch-not-taken&#x2F;taken hints and 3e as notrack. (See SDM Vol. 1 3.3.7.1 &quot;Other segment override prefixes (CS, DS, ES, and SS) are ignored.&quot;) Also, REX prefixes that don&#x27;t immediately preceed the opcode (or VEX&#x2F;EVEX prefix) are ignored. Anyhow, I need to take a closer look at the decoder with more time. :-)<p>&gt; For EVEX my plan is to keep the raw bits until after the opcode has been read<p>I came to the same conclusion that this is necessary with APX. The map+prefix+opcode combination identifies how the other fields are to be interpreted. For AVX-512, storing the last byte was sufficient, but with APX, vvvv got a second meaning.<p>&gt; Nevertheless there are several cases in which the manual is wrong or doesn&#x27;t say the whole story.<p>Yes... especially for corner cases, getting real hardware is the only reliable way to find out, how the CPU behaves.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;aengelke&#x2F;fadec&#x2F;blob&#x2F;master&#x2F;instrs.txt">https:&#x2F;&#x2F;github.com&#x2F;aengelke&#x2F;fadec&#x2F;blob&#x2F;master&#x2F;instrs.txt</a>
[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;aengelke&#x2F;fadec&#x2F;blob&#x2F;master&#x2F;decode.c">https:&#x2F;&#x2F;github.com&#x2F;aengelke&#x2F;fadec&#x2F;blob&#x2F;master&#x2F;decode.c</a></div><br/><div id="40931927" class="c"><input type="checkbox" id="c-40931927" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40931081">parent</a><span>|</span><a href="#40931121">next</a><span>|</span><label class="collapse" for="c-40931927">[-]</label><label class="expand" for="c-40931927">[4 more]</label></div><br/><div class="children"><div class="content">FWIW here&#x27;s all 700 lines of Blink&#x27;s x86 decoder. <a href="https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;blink&#x2F;blob&#x2F;master&#x2F;blink&#x2F;x86.c">https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;blink&#x2F;blob&#x2F;master&#x2F;blink&#x2F;x86.c</a></div><br/><div id="40932251" class="c"><input type="checkbox" id="c-40932251" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40931927">parent</a><span>|</span><a href="#40931121">next</a><span>|</span><label class="collapse" for="c-40932251">[-]</label><label class="expand" for="c-40932251">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to be the person that has to add an instruction to blink...</div><br/><div id="40932371" class="c"><input type="checkbox" id="c-40932371" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40932251">parent</a><span>|</span><a href="#40931121">next</a><span>|</span><label class="collapse" for="c-40932371">[-]</label><label class="expand" for="c-40932371">[2 more]</label></div><br/><div class="children"><div class="content">It looks like someone started with Intel&#x27;s XED code (which relies on custom tables to specify instructions, and compiles that to C tables at compile time) and hand-minimized the code into a single file. I&#x27;m guessing it&#x27;s designed to never have any more code added to it.</div><br/><div id="40933335" class="c"><input type="checkbox" id="c-40933335" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40932371">parent</a><span>|</span><a href="#40931121">next</a><span>|</span><label class="collapse" for="c-40933335">[-]</label><label class="expand" for="c-40933335">[1 more]</label></div><br/><div class="children"><div class="content">I minimized it by hand to make it more maintainable, to me at least.</div><br/></div></div></div></div></div></div></div></div><div id="40931121" class="c"><input type="checkbox" id="c-40931121" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40931081">parent</a><span>|</span><a href="#40931927">prev</a><span>|</span><a href="#40931425">next</a><span>|</span><label class="collapse" for="c-40931121">[-]</label><label class="expand" for="c-40931121">[2 more]</label></div><br/><div class="children"><div class="content">&gt; interesting that you have a separate row for &quot;66+F2&quot;<p>Yeah that&#x27;s only for 0F38F0 to 0F38FF.<p>&gt; Re &#x27;custom size &quot;xh&quot;&#x27;: AVX-512 also has fourth and eighth<p>Also AVX for VPMOVSX and VPMOVZX but those are handled differently. I probably should check if xh is actually redundant... <i>EDIT</i>: it&#x27;s only needed for VCVTPS2PH, which is the only instruction with a half-sized <i>destination</i>.<p>&gt; I think the prefix decoding is not quite right for x86-64: 26&#x2F;2e&#x2F;36&#x2F;3e are ignored in 64-bit mode<p>Interesting, I need to check how they interact with the FS&#x2F;GS prefixes (64&#x2F;65).<p>&gt; REX prefixes that don&#x27;t immediately preceed the opcode (or VEX&#x2F;EVEX prefix) are ignored<p>Oh, didn&#x27;t know that!</div><br/><div id="40931214" class="c"><input type="checkbox" id="c-40931214" checked=""/><div class="controls bullet"><span class="by">aengelke</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40931121">parent</a><span>|</span><a href="#40931425">next</a><span>|</span><label class="collapse" for="c-40931214">[-]</label><label class="expand" for="c-40931214">[1 more]</label></div><br/><div class="children"><div class="content">&gt; how they interact with the FS&#x2F;GS prefixes (64&#x2F;65)<p>For memory operations, they are ignored: 64-2e-65-3e gives 65 as segment override. (From my memory and the resulting implementation, I did some tests with hardware a few years back.)<p>I do need to check myself how 2e&#x2F;3e on branches interact with other segment overrides, though.</div><br/></div></div></div></div></div></div></div></div><div id="40931425" class="c"><input type="checkbox" id="c-40931425" checked=""/><div class="controls bullet"><span class="by">torusle</span><span>|</span><a href="#40929438">parent</a><span>|</span><a href="#40930717">prev</a><span>|</span><a href="#40930181">next</a><span>|</span><label class="collapse" for="c-40931425">[-]</label><label class="expand" for="c-40931425">[2 more]</label></div><br/><div class="children"><div class="content">Another bonus quirk, from the 486 and Pentium area..<p>BSWAP EAX converts from little endian to big endian and vice versa. It was a 32 bit instruction to begin with.<p>However, we have the 0x66 prefix that switches between 16 and 32 bit mode. If you apply that to BSWAP EAX undefined funky things happen.<p>On some CPU architectures (Intel vs. AMD) the prefix was just ignored. On others it did something that I call an &quot;inner swap&quot;. E.g. in your four bytes that are stored in EAX byte 1 and 2 are swapped.<p><pre><code>  0x11223344 became 0x11332244.</code></pre></div><br/><div id="40933467" class="c"><input type="checkbox" id="c-40933467" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40931425">parent</a><span>|</span><a href="#40930181">next</a><span>|</span><label class="collapse" for="c-40933467">[-]</label><label class="expand" for="c-40933467">[1 more]</label></div><br/><div class="children"><div class="content">Also known as &quot;bswap ax&quot;, and research shows that it does something surprising but consistent on almost all hardware: It zeros the register.<p><a href="https:&#x2F;&#x2F;www.ragestorm.net&#x2F;blogs&#x2F;?p=141" rel="nofollow">https:&#x2F;&#x2F;www.ragestorm.net&#x2F;blogs&#x2F;?p=141</a><p><a href="https:&#x2F;&#x2F;gynvael.coldwind.pl&#x2F;?id=268" rel="nofollow">https:&#x2F;&#x2F;gynvael.coldwind.pl&#x2F;?id=268</a><p>However, this page, now gone, suggests that some CPUs (early 486s?) did something different: <a href="http:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20071231192014&#x2F;http:&#x2F;&#x2F;www.df.lth.se&#x2F;~john_e&#x2F;gems&#x2F;gem000c.html" rel="nofollow">http:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20071231192014&#x2F;http:&#x2F;&#x2F;www.df.lth....</a><p>Unfortunately I have not found any evidence nor reason to believe that this &quot;inner swap&quot; behaviour you mention exists in some CPU --- except perhaps some flawed emulators?</div><br/></div></div></div></div><div id="40930181" class="c"><input type="checkbox" id="c-40930181" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#40929438">parent</a><span>|</span><a href="#40931425">prev</a><span>|</span><a href="#40930899">next</a><span>|</span><label class="collapse" for="c-40930181">[-]</label><label class="expand" for="c-40930181">[16 more]</label></div><br/><div class="children"><div class="content">Can you imagine having to make all this logic work faithfully, let alone <i>fast</i>, in silicon?<p>X86 used to be Intel&#x27;s moat, but what a nightmarish burden to carry.</div><br/><div id="40932456" class="c"><input type="checkbox" id="c-40932456" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930181">parent</a><span>|</span><a href="#40930425">next</a><span>|</span><label class="collapse" for="c-40932456">[-]</label><label class="expand" for="c-40932456">[4 more]</label></div><br/><div class="children"><div class="content">A fun thing is that e.g. &quot;cmp ax, 0x4231&quot; differs from &quot;cmp eax, 0x87654321&quot; only in the presence of the data16 prefix, and thus the longer immediate; and it&#x27;s the only significant case (I think?) of a prefix changing the total instruction size, and thus, for <i>some</i> such instructions, the 16-bit version, <i>sometimes</i> (but not always!) is significantly slower. &quot;but not always&quot; as in, if you try to microbenchmark a loop of such, sometimes you can have entire microseconds of it consistently running at 0.25 cycles&#x2F;instr avg, and sometimes that same exact code (in the same process!) will measure it at 3 cycles&#x2F;instr (tested on Haswell, but uops.info indicates this happens on all non-atom Intel since Ivy Bridge).</div><br/><div id="40933327" class="c"><input type="checkbox" id="c-40933327" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40932456">parent</a><span>|</span><a href="#40934140">next</a><span>|</span><label class="collapse" for="c-40933327">[-]</label><label class="expand" for="c-40933327">[2 more]</label></div><br/><div class="children"><div class="content">Probably, if the uops come from the uop cache you get the fast speed since the prefix and any decoding stalls don&#x27;t have any impact in that case (that mess is effectively erased in the uop cache), but if it needs to be decoded you get a stall due to the length changing prefix.<p>Whether a bit of code comes from the uop cache is highly dependent on alignment, surrounding instructions, the specific microarchitecture, microcode version and even more esototeric things like how many incoming jumps target the nearby region of code (and in which order they were observed by the cache).</div><br/><div id="40933688" class="c"><input type="checkbox" id="c-40933688" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40933327">parent</a><span>|</span><a href="#40934140">next</a><span>|</span><label class="collapse" for="c-40933688">[-]</label><label class="expand" for="c-40933688">[1 more]</label></div><br/><div class="children"><div class="content">Yep, a lot of potential contributors. Though, my test was of a single plain 8x unrolled loop doing nothing else, running for tens of thousands of iterations to take a total of ~0.1ms, i.e. should trivially cache, and yet there&#x27;s consistent inconsistency.<p>Did some &#x27;perf stat&#x27;ting, comparing the same test with &quot;cmp eax,1000&quot; vs &quot;cmp ax,1000&quot;; per instruction, idq.mite_uops goes 0.04% → 35%, and lsd.uops goes 90% → 54%; so presumably sometimes somehow the loop makes into LSD at which point dropping out of it is hard, while other times it perpetually gets stuck at MITE? (test is of 10 instrs - 8 copies of the cmp, and dec+jne that&#x27;d get fused, so 90% uops&#x2F;instr makes sense)</div><br/></div></div></div></div><div id="40934140" class="c"><input type="checkbox" id="c-40934140" checked=""/><div class="controls bullet"><span class="by">aengelke</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40932456">parent</a><span>|</span><a href="#40933327">prev</a><span>|</span><a href="#40930425">next</a><span>|</span><label class="collapse" for="c-40934140">[-]</label><label class="expand" for="c-40934140">[1 more]</label></div><br/><div class="children"><div class="content">The behavior&#x2F;penalty of 66&#x2F;67 length-changing prefixes is documented in the Intel Optimization Reference Manual (3.4.2.3):<p>&gt; Assembly&#x2F;Compiler Coding Rule 19. (MH impact, MH generality) Favor generating code using imm8 or imm32 values instead of imm16 values.</div><br/></div></div></div></div><div id="40930425" class="c"><input type="checkbox" id="c-40930425" checked=""/><div class="controls bullet"><span class="by">dx4100</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930181">parent</a><span>|</span><a href="#40932456">prev</a><span>|</span><a href="#40930474">next</a><span>|</span><label class="collapse" for="c-40930425">[-]</label><label class="expand" for="c-40930425">[7 more]</label></div><br/><div class="children"><div class="content">Did people just... do this by hand (in software), transistor by transistor, or was it laid out programmatically in some sense? As in, were segments created algorithmically, then repeated to obtain the desired outcome? CPU design baffles me, especially considering there are 134 BILLION transistors or so in the latest i7 CPU. How does the team even keep track of, work on, or even load the files to WORK on the CPUs?</div><br/><div id="40930665" class="c"><input type="checkbox" id="c-40930665" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930425">parent</a><span>|</span><a href="#40930885">next</a><span>|</span><label class="collapse" for="c-40930665">[-]</label><label class="expand" for="c-40930665">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s written in an HDL; IIRC both Intel and AMD use verilog.  A modern core is on the order of a million or so lines of verilog.<p>Some of that will be hand placed, quite a bit will just be thrown at the synthesizer.  Other parts like SRAM blocks will have their cad generated directly from a macro and a description of the block in question.</div><br/><div id="40931493" class="c"><input type="checkbox" id="c-40931493" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930665">parent</a><span>|</span><a href="#40930885">next</a><span>|</span><label class="collapse" for="c-40931493">[-]</label><label class="expand" for="c-40931493">[1 more]</label></div><br/><div class="children"><div class="content">To further expound on this.  ASIC (like AMD CPUs) is a lot like software work.  The engineers that create a lot of the digital logic aren&#x27;t dealing with individual transistors, instead they are saying &quot;give me an accumulator for this section of code&quot; and the HDL provides it.  The definition of that module exists elsewhere and is shared throughout the system.<p>This is how the complexity can be wrangled.<p>Now, MOST of the work is automated for digital logic.  However, we live in an analog world.  So, there is (As far as I&#x27;m aware) still quite a bit of work for analog engineers to bend the analog reality into digital.  In the real world, changing current creates magnetic fields which means you need definitions limiting voltages and defining how close a signal line can be to avoid cross talk.  Square waves are hard to come by, so there&#x27;s effort in timing and voltage bands to make sure you aren&#x27;t registering a &quot;1&quot; when it should have been a &quot;0&quot;.<p>Several of my professors were intel engineers.  From what they told me, the ratios of employment were something like 100 digital engineers to 10 analog engineers to 1 Physicist&#x2F;materials engineer.</div><br/></div></div></div></div><div id="40930885" class="c"><input type="checkbox" id="c-40930885" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930425">parent</a><span>|</span><a href="#40930665">prev</a><span>|</span><a href="#40932403">next</a><span>|</span><label class="collapse" for="c-40930885">[-]</label><label class="expand" for="c-40930885">[1 more]</label></div><br/><div class="children"><div class="content">It was entirely laid out by hand until the 286. Using standard cells in the 386 enabled the switch from microcode to a mostly hardwired core.</div><br/></div></div><div id="40932403" class="c"><input type="checkbox" id="c-40932403" checked=""/><div class="controls bullet"><span class="by">moosedev</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930425">parent</a><span>|</span><a href="#40930885">prev</a><span>|</span><a href="#40930626">next</a><span>|</span><label class="collapse" for="c-40932403">[-]</label><label class="expand" for="c-40932403">[1 more]</label></div><br/><div class="children"><div class="content">You might enjoy Ken’s latest article on some of this stuff, posted just the other day: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40899393">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40899393</a></div><br/></div></div><div id="40930626" class="c"><input type="checkbox" id="c-40930626" checked=""/><div class="controls bullet"><span class="by">tristor</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930425">parent</a><span>|</span><a href="#40932403">prev</a><span>|</span><a href="#40930474">next</a><span>|</span><label class="collapse" for="c-40930626">[-]</label><label class="expand" for="c-40930626">[2 more]</label></div><br/><div class="children"><div class="content">They use EDA (Electronic Design Automation) software, there are only a handful of vendors, the largest probably being Mentor Graphics, now owned by Siemens.  So, yes, they use automation to algorithmically build and track&#x2F;resolve refactors as they design CPUs.  CPUs are &#x2F;generally&#x2F; block-type designs these days, so particular functions get repeated identically in different places and can be somewhat abstracted away in your EDA.<p>It&#x27;s still enormously complex, and way more complex than the last time I touched this stuff more than 15 years ago.</div><br/><div id="40930986" class="c"><input type="checkbox" id="c-40930986" checked=""/><div class="controls bullet"><span class="by">rikthevik</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930626">parent</a><span>|</span><a href="#40930474">next</a><span>|</span><label class="collapse" for="c-40930986">[-]</label><label class="expand" for="c-40930986">[1 more]</label></div><br/><div class="children"><div class="content">I love that the EDA industry still uses Tcl heavily. Warms my heart.</div><br/></div></div></div></div></div></div><div id="40930474" class="c"><input type="checkbox" id="c-40930474" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930181">parent</a><span>|</span><a href="#40930425">prev</a><span>|</span><a href="#40930795">next</a><span>|</span><label class="collapse" for="c-40930474">[-]</label><label class="expand" for="c-40930474">[3 more]</label></div><br/><div class="children"><div class="content">A lot of this is done in software (microcode).  But even with that case, your statement still holds: &quot;Can you imagine having to make all this logic work faithfully, let alone fast, in the chip itself?&quot;  Writing that microcode must be fiendishly difficult given all the functional units, out of order execution, register renaming...</div><br/><div id="40930646" class="c"><input type="checkbox" id="c-40930646" checked=""/><div class="controls bullet"><span class="by">aengelke</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930474">parent</a><span>|</span><a href="#40930598">next</a><span>|</span><label class="collapse" for="c-40930646">[-]</label><label class="expand" for="c-40930646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of this is done in software (microcode).<p>No, that&#x27;s not the case, since &gt;30 years. Microcode is only used for implementing some complex instructions (mostly system instructions). Most regular instructions (and the rest of the core) don&#x27;t use microcode and their expansions into uOps are hardwired. Also the entire execution unit is hardwired.<p>There are typically some undocumented registers (MSRs on x86) that can control how the core behaves (e.g., kill switches for certain optimizations). These can then be changed by microcode updates.</div><br/></div></div><div id="40930598" class="c"><input type="checkbox" id="c-40930598" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930474">parent</a><span>|</span><a href="#40930646">prev</a><span>|</span><a href="#40930795">next</a><span>|</span><label class="collapse" for="c-40930598">[-]</label><label class="expand" for="c-40930598">[1 more]</label></div><br/><div class="children"><div class="content">The crazy parts that were mentioned in the parent comment are all part of the hot path. Microcode handles slow paths related to paging and segmentation, and very rare instructions. Not necessarily unimportant (many common privileged instructions are microcoded) but still rare compared to the usual ALU instructions.<p>But it&#x27;s not a huge deal to program the quirky encoding in an HDL, it&#x27;s just a waste of transistors. The really complicated part is the sequencing of micro operations and how they enter the (out of order) execution unit.</div><br/></div></div></div></div><div id="40930795" class="c"><input type="checkbox" id="c-40930795" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930181">parent</a><span>|</span><a href="#40930474">prev</a><span>|</span><a href="#40930899">next</a><span>|</span><label class="collapse" for="c-40930795">[-]</label><label class="expand" for="c-40930795">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a lot easier to more or less accidentally create something quirky than it is to create a second quirk-for-quirk compatible system.</div><br/></div></div></div></div><div id="40930899" class="c"><input type="checkbox" id="c-40930899" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40929438">parent</a><span>|</span><a href="#40930181">prev</a><span>|</span><a href="#40929076">next</a><span>|</span><label class="collapse" for="c-40930899">[-]</label><label class="expand" for="c-40930899">[3 more]</label></div><br/><div class="children"><div class="content">The semantics of LZCNT combined with its encoding feels like an own goal: it’s encoded as a BSR instruction with a legacy-ignored prefix, <i>but</i> for nonzero inputs its return value is the operand size minus the return value of the legacy version. Yes, clz() is a function that exists, but the extra subtraction in its implementation feels like a small cost to pay for extra compatibility when LZCNT could’ve just been BSR with different zero-input semantics.</div><br/><div id="40933358" class="c"><input type="checkbox" id="c-40933358" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930899">parent</a><span>|</span><a href="#40932269">next</a><span>|</span><label class="collapse" for="c-40933358">[-]</label><label class="expand" for="c-40933358">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not following: as long as you are introducing a new, incompatible instruction for leading zero counting, you&#x27;d definitely choose LZCNT over BSR as LZCNT has definitely won in retrospect over BSR as the primitive for this use case. BSR is just a historical anomaly which has a zero-input problem for no benefit.<p>What would be the point of offering a new variation BSR with different input semantics?</div><br/></div></div><div id="40932269" class="c"><input type="checkbox" id="c-40932269" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40929438">root</a><span>|</span><a href="#40930899">parent</a><span>|</span><a href="#40933358">prev</a><span>|</span><a href="#40929076">next</a><span>|</span><label class="collapse" for="c-40932269">[-]</label><label class="expand" for="c-40932269">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s like someone looked at TZCNT and thought &quot;let&#x27;s encode LZCNT the same way&quot;, but it makes no sense.</div><br/></div></div></div></div></div></div><div id="40929076" class="c"><input type="checkbox" id="c-40929076" checked=""/><div class="controls bullet"><span class="by">sdsd</span><span>|</span><a href="#40929438">prev</a><span>|</span><a href="#40933988">next</a><span>|</span><label class="collapse" for="c-40929076">[-]</label><label class="expand" for="c-40929076">[3 more]</label></div><br/><div class="children"><div class="content">What a cool person. I really enjoy writing assembly, it feels so simple and I really enjoy the vertical aesthetic quality.<p>The closest I&#x27;ve ever come to something like OP (which is to say, not close at all) was when I was trying to help my JS friend understand the stack, and we ended up writing a mini vm with its own little ISA: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;darighost&#x2F;2d880fe27510e0c90f75680bfee86b29" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;darighost&#x2F;2d880fe27510e0c90f75680bfe...</a><p>This could have gone much deeper - i&#x27;d have enjoyed that, but doing so would have detracted from the original educational goal lol. I should contact that friend and see if he still wants to study with me. it&#x27;s hard since he&#x27;s making so much money doing fancy web dev, he has no time to go deep into stuff. whereas my unemployed ass is basically an infinite ocean of time and energy.</div><br/><div id="40929730" class="c"><input type="checkbox" id="c-40929730" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40929076">parent</a><span>|</span><a href="#40933988">next</a><span>|</span><label class="collapse" for="c-40929730">[-]</label><label class="expand" for="c-40929730">[2 more]</label></div><br/><div class="children"><div class="content">You should leverage that into your friend teaching you JS, maybe.</div><br/><div id="40933079" class="c"><input type="checkbox" id="c-40933079" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#40929076">root</a><span>|</span><a href="#40929730">parent</a><span>|</span><a href="#40933988">next</a><span>|</span><label class="collapse" for="c-40933079">[-]</label><label class="expand" for="c-40933079">[1 more]</label></div><br/><div class="children"><div class="content">It’s like my friend 0x86 always said: “Stay away from JavaScript.  But stay away from TypeScript harder.”</div><br/></div></div></div></div></div></div><div id="40933988" class="c"><input type="checkbox" id="c-40933988" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40929076">prev</a><span>|</span><a href="#40929052">next</a><span>|</span><label class="collapse" for="c-40933988">[-]</label><label class="expand" for="c-40933988">[1 more]</label></div><br/><div class="children"><div class="content">I recently implemented a good portion of x86(-64) decoder for some side project [1] and kinda surprised how it got even more complicated in recent days. Sandpile.org [2] was really useful for my purpose.<p>[1] Namely, a version of Fabian Giesen&#x27;s disfilter for x86-64, for yet another side project which is still not in public: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;lifthrasiir&#x2F;df47509caac2f065032ef72e70f2ec05" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;lifthrasiir&#x2F;df47509caac2f065032ef72e...</a><p>[2] <a href="https:&#x2F;&#x2F;sandpile.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sandpile.org&#x2F;</a></div><br/></div></div><div id="40929052" class="c"><input type="checkbox" id="c-40929052" checked=""/><div class="controls bullet"><span class="by">AstroJetson</span><span>|</span><a href="#40933988">prev</a><span>|</span><a href="#40928990">next</a><span>|</span><label class="collapse" for="c-40929052">[-]</label><label class="expand" for="c-40929052">[2 more]</label></div><br/><div class="children"><div class="content">Check out Justine Tunney and her emulator. <a href="https:&#x2F;&#x2F;justine.lol&#x2F;blinkenlights&#x2F;" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;blinkenlights&#x2F;</a><p>The docs are an amazing tour of how the cpu works.</div><br/><div id="40929991" class="c"><input type="checkbox" id="c-40929991" checked=""/><div class="controls bullet"><span class="by">zarathustreal</span><span>|</span><a href="#40929052">parent</a><span>|</span><a href="#40928990">next</a><span>|</span><label class="collapse" for="c-40929991">[-]</label><label class="expand" for="c-40929991">[1 more]</label></div><br/><div class="children"><div class="content">Astonishing.. they never cease to amaze me</div><br/></div></div></div></div><div id="40928990" class="c"><input type="checkbox" id="c-40928990" checked=""/><div class="controls bullet"><span class="by">pm2222</span><span>|</span><a href="#40929052">prev</a><span>|</span><a href="#40930287">next</a><span>|</span><label class="collapse" for="c-40928990">[-]</label><label class="expand" for="c-40928990">[1 more]</label></div><br/><div class="children"><div class="content">Prior discussion here <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34636699">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34636699</a><p>Cannot believe it’s been 16months. How time flies.</div><br/></div></div><div id="40930287" class="c"><input type="checkbox" id="c-40930287" checked=""/><div class="controls bullet"><span class="by">trollied</span><span>|</span><a href="#40928990">prev</a><span>|</span><a href="#40932618">next</a><span>|</span><label class="collapse" for="c-40930287">[-]</label><label class="expand" for="c-40930287">[21 more]</label></div><br/><div class="children"><div class="content">&gt; Writing a CPU emulator is, in my opinion, the best way to REALLY understand how a CPU works<p>Hard disagree.<p>The best way is to create a CPU from gate level, like you do on a decent CS course. (I really enjoyed making a cut down ARM from scratch)</div><br/><div id="40931513" class="c"><input type="checkbox" id="c-40931513" checked=""/><div class="controls bullet"><span class="by">timmisiak</span><span>|</span><a href="#40930287">parent</a><span>|</span><a href="#40931885">next</a><span>|</span><label class="collapse" for="c-40931513">[-]</label><label class="expand" for="c-40931513">[7 more]</label></div><br/><div class="children"><div class="content">I think both are useful, but designing a modern CPU from the gate level is out of reach for most folks, and I think there&#x27;s a big gap between the sorts of CPUs we designed in college and the sort that run real code. I think creating an emulator of a modern CPU is a somewhat more accessible challenge, while still being very educational even if you only get something partially working.</div><br/><div id="40932074" class="c"><input type="checkbox" id="c-40932074" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40931513">parent</a><span>|</span><a href="#40933102">next</a><span>|</span><label class="collapse" for="c-40932074">[-]</label><label class="expand" for="c-40932074">[4 more]</label></div><br/><div class="children"><div class="content">When I was at Caltech, another student in the dorm had been admitted because he&#x27;d designed and implemented a CPU using only 7400 TTL.<p>Woz wasn&#x27;t the only supersmart young computer guy at the time :-)<p>(I don&#x27;t know how capable it was, even a 4 bit CPU would be quite a challenge with TTL.)</div><br/><div id="40932779" class="c"><input type="checkbox" id="c-40932779" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40932074">parent</a><span>|</span><a href="#40933102">next</a><span>|</span><label class="collapse" for="c-40932779">[-]</label><label class="expand" for="c-40932779">[3 more]</label></div><br/><div class="children"><div class="content">I think the key word above was modern. I felt able to design a simple CPU when I finished my Computer Architecture course in university. I think I forgot most of it by now ;) There are a few basic concepts to wrap your head around but once you have them a simple CPU is doable. Doing this with TTL or other off the shelf components is mostly minimizing&#x2F;adapting&#x2F;optimizing to those components (or using a lot of chips ;) ). I have never looked at discrete component CPU designs, I imagine ROM and RAM chips play a dominant part (e.g. you don&#x27;t just built RAM with 74x TTL flip-flops).</div><br/><div id="40933025" class="c"><input type="checkbox" id="c-40933025" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40932779">parent</a><span>|</span><a href="#40933102">next</a><span>|</span><label class="collapse" for="c-40933025">[-]</label><label class="expand" for="c-40933025">[2 more]</label></div><br/><div class="children"><div class="content">He probably used off-the-shelf RAM chips, after all, RAM is not part of the CPU.<p>In the early 70s, before the internet, even finding the information needed would be a fair amount of work.<p>I learned how flip flops worked, adders, and registers in college, and that could be extended to an ALU. But still, that was in college, not high school.<p>I&#x27;ve read some books on computer history, and they are frustratingly vague about how the machines actually worked. I suspect the authors didn&#x27;t actually know. Sort of the like the books on the history of Apple that gush over Woz&#x27;s floppy disk interface, but no details.</div><br/><div id="40933081" class="c"><input type="checkbox" id="c-40933081" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40933025">parent</a><span>|</span><a href="#40933102">next</a><span>|</span><label class="collapse" for="c-40933081">[-]</label><label class="expand" for="c-40933081">[1 more]</label></div><br/><div class="children"><div class="content">Was doing some Googling and came across: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Breakout_(video_game)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Breakout_(video_game)</a><p>I never heard this story...</div><br/></div></div></div></div></div></div></div></div><div id="40933102" class="c"><input type="checkbox" id="c-40933102" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40931513">parent</a><span>|</span><a href="#40932074">prev</a><span>|</span><a href="#40931911">next</a><span>|</span><label class="collapse" for="c-40933102">[-]</label><label class="expand" for="c-40933102">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and the sort that run real code<p>And the sort that are commercially viable in today&#x27;s marketplace.  The nature of the code has nothing to do with it.  The types of machines we play around with today surpass the machines we used to land men on the moon.  What&#x27;s not &quot;real code&quot; about that?</div><br/></div></div><div id="40931911" class="c"><input type="checkbox" id="c-40931911" checked=""/><div class="controls bullet"><span class="by">banish-m4</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40931513">parent</a><span>|</span><a href="#40933102">prev</a><span>|</span><a href="#40931885">next</a><span>|</span><label class="collapse" for="c-40931911">[-]</label><label class="expand" for="c-40931911">[1 more]</label></div><br/><div class="children"><div class="content">This is an illusion and a red herring. RTL synthesis is the typical functional prototype stage reached which is generally sufficient for FPGA work. To burn an ASIC as part of an educational consortium run is doable, but it&#x27;s uncommon.</div><br/></div></div></div></div><div id="40931885" class="c"><input type="checkbox" id="c-40931885" checked=""/><div class="controls bullet"><span class="by">banish-m4</span><span>|</span><a href="#40930287">parent</a><span>|</span><a href="#40931513">prev</a><span>|</span><a href="#40931126">next</a><span>|</span><label class="collapse" for="c-40931885">[-]</label><label class="expand" for="c-40931885">[3 more]</label></div><br/><div class="children"><div class="content">Seconded. A microcoded, pipelined, superscalar, branch-predicting basic processor with L1 data &amp; instruction caches and write-back L2 cache controller is nontrivial. Most software engineers have an incomplete grasp of data hazards, cache invalidation, or pipeline stalls.</div><br/><div id="40932804" class="c"><input type="checkbox" id="c-40932804" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40931885">parent</a><span>|</span><a href="#40931126">next</a><span>|</span><label class="collapse" for="c-40932804">[-]</label><label class="expand" for="c-40932804">[2 more]</label></div><br/><div class="children"><div class="content">IIRC reading some Intel CPU design history some of their designers are from a CS&#x2F;software background. But I agree. Software is naturally very sequential which is different than digital hardware which is naturally&#x2F;inherently parallel. A clock can change the state of a million flip-flops all at once, it&#x27;s a very different way of thinking about computation (though ofcourse at the theoretical level all the same) and then there&#x27;s the physics and EE parts of a real world CPU. Writing software and designing CPUs are just very different disciplines and the CPU as it appears to the software developer isn&#x27;t how it appears to the CPU designer.</div><br/><div id="40933334" class="c"><input type="checkbox" id="c-40933334" checked=""/><div class="controls bullet"><span class="by">banish-m4</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40932804">parent</a><span>|</span><a href="#40931126">next</a><span>|</span><label class="collapse" for="c-40933334">[-]</label><label class="expand" for="c-40933334">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not talking about Intel&#x27;s engineers, I&#x27;m saying very few software engineers today understand how a processor works. I&#x27;m sure Intel hires all sorts of engineers for different aspects of each ecosystem they maintain. Furthermore, very few software engineers have ever even touched a physical server because they&#x27;re sequestered away from a significant fraction of the total stack.<p>Speculative and out-of-order execution requires synchronization to maintain dataflow and temporal consistency.<p>Computer Organization is a good book should anyone want to dive deeper.</div><br/></div></div></div></div></div></div><div id="40931126" class="c"><input type="checkbox" id="c-40931126" checked=""/><div class="controls bullet"><span class="by">quantified</span><span>|</span><a href="#40930287">parent</a><span>|</span><a href="#40931885">prev</a><span>|</span><a href="#40930438">next</a><span>|</span><label class="collapse" for="c-40931126">[-]</label><label class="expand" for="c-40931126">[3 more]</label></div><br/><div class="children"><div class="content">Well, I think you&#x27;re both right. It&#x27;s satisfying as heck to sling 74xx chips together and you get a feel for the electrical side of things and internal tradeoffs.<p>When you get to doing that for the CPU that you want to do meaningful work with, you start to lose interest in that detail. Then the complexities of the behavior and spec become interesting and the emulator approach is more tractable, can cover more types of behavior.</div><br/><div id="40931285" class="c"><input type="checkbox" id="c-40931285" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40931126">parent</a><span>|</span><a href="#40930438">next</a><span>|</span><label class="collapse" for="c-40931285">[-]</label><label class="expand" for="c-40931285">[2 more]</label></div><br/><div class="children"><div class="content">I think trollied is correct actually. I work on a CPU emulator professionally and while it gives you a great understanding of the spec there are lots of details about <i>why</i> the spec is the way it is that are due to how you actually implement the microarchitecture. You only learn that stuff by actually implementing a microarchitecture.<p>Emulators tend not to have many features that you find in real chips, e.g. caches, speculative execution, out-of-order execution, branch predictors, pipelining, etc.<p>This isn&#x27;t &quot;the electrical side of things&quot;. When he said &quot;gate level&quot; he meant RTL (SystemVerilog&#x2F;VHDL) which is pretty much entirely in the digital domain; you very rarely need to worry about actual electricity.</div><br/><div id="40931522" class="c"><input type="checkbox" id="c-40931522" checked=""/><div class="controls bullet"><span class="by">trollied</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40931285">parent</a><span>|</span><a href="#40930438">next</a><span>|</span><label class="collapse" for="c-40931522">[-]</label><label class="expand" for="c-40931522">[1 more]</label></div><br/><div class="children"><div class="content">I write retro console emulators for fun, so agree with you 100% :)</div><br/></div></div></div></div></div></div><div id="40930438" class="c"><input type="checkbox" id="c-40930438" checked=""/><div class="controls bullet"><span class="by">commandlinefan</span><span>|</span><a href="#40930287">parent</a><span>|</span><a href="#40931126">prev</a><span>|</span><a href="#40931863">next</a><span>|</span><label class="collapse" for="c-40930438">[-]</label><label class="expand" for="c-40930438">[4 more]</label></div><br/><div class="children"><div class="content">OTOH, are you really going to be implementing memory segmenting in your gate-level CPU?  I&#x27;d say actually creating a working CPU and _then_ emulating a real CPU (warts and all) are both necessary steps to real understanding.</div><br/><div id="40934783" class="c"><input type="checkbox" id="c-40934783" checked=""/><div class="controls bullet"><span class="by">mrspuratic</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40930438">parent</a><span>|</span><a href="#40930690">next</a><span>|</span><label class="collapse" for="c-40934783">[-]</label><label class="expand" for="c-40934783">[1 more]</label></div><br/><div class="children"><div class="content">This. I mean, why not start with wave theory and material science if you really want a good understanding :)<p>In my CS course I learned a hell of a lot from creating a 6800 emulator; though it wasn&#x27;t on the course, building a working 6800 system was. The development involved running an assembler on a commercial *nix system and then typing the hex object code into an EPROM programmer. You get a lot of time to think about where your bugs are when you have to wait for a UV erase cycle...</div><br/></div></div><div id="40930690" class="c"><input type="checkbox" id="c-40930690" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40930438">parent</a><span>|</span><a href="#40934783">prev</a><span>|</span><a href="#40930683">next</a><span>|</span><label class="collapse" for="c-40930690">[-]</label><label class="expand" for="c-40930690">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OTOH, are you really going to be implementing memory segmenting in your gate-level CPU?<p>I have, but it was a PDP-8 which I&#x27;ll be the first to admit is kind of cheating.</div><br/></div></div><div id="40930683" class="c"><input type="checkbox" id="c-40930683" checked=""/><div class="controls bullet"><span class="by">trollied</span><span>|</span><a href="#40930287">root</a><span>|</span><a href="#40930438">parent</a><span>|</span><a href="#40930690">prev</a><span>|</span><a href="#40931863">next</a><span>|</span><label class="collapse" for="c-40930683">[-]</label><label class="expand" for="c-40930683">[1 more]</label></div><br/><div class="children"><div class="content">I agree.</div><br/></div></div></div></div><div id="40931863" class="c"><input type="checkbox" id="c-40931863" checked=""/><div class="controls bullet"><span class="by">brailsafe</span><span>|</span><a href="#40930287">parent</a><span>|</span><a href="#40930438">prev</a><span>|</span><a href="#40933318">next</a><span>|</span><label class="collapse" for="c-40931863">[-]</label><label class="expand" for="c-40931863">[1 more]</label></div><br/><div class="children"><div class="content">So far on my journey through Nand2Tetris (since I kind of dropped out of my real CS course) I&#x27;ve found the entire process of working my way up from gate level, and just finished the VM emulator chapter which took an eternity. Now onto compilation.</div><br/></div></div><div id="40933318" class="c"><input type="checkbox" id="c-40933318" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40930287">parent</a><span>|</span><a href="#40931863">prev</a><span>|</span><a href="#40930335">next</a><span>|</span><label class="collapse" for="c-40933318">[-]</label><label class="expand" for="c-40933318">[1 more]</label></div><br/><div class="children"><div class="content">CPU was a poor choice of words. ISA would have worked.</div><br/></div></div><div id="40930335" class="c"><input type="checkbox" id="c-40930335" checked=""/><div class="controls bullet"><span class="by">whobre</span><span>|</span><a href="#40930287">parent</a><span>|</span><a href="#40933318">prev</a><span>|</span><a href="#40932618">next</a><span>|</span><label class="collapse" for="c-40930335">[-]</label><label class="expand" for="c-40930335">[1 more]</label></div><br/><div class="children"><div class="content">Reading Petzold’s “Code” comes pretty close to, though and is easier.</div><br/></div></div></div></div><div id="40932618" class="c"><input type="checkbox" id="c-40932618" checked=""/><div class="controls bullet"><span class="by">jmspring</span><span>|</span><a href="#40930287">prev</a><span>|</span><a href="#40933223">next</a><span>|</span><label class="collapse" for="c-40932618">[-]</label><label class="expand" for="c-40932618">[1 more]</label></div><br/><div class="children"><div class="content">Apparently my memory is false, I thought originally the salsa20 variants and machine code were on cryp.to in my memory, but Dan Berstein&#x27;s site is - <a href="https:&#x2F;&#x2F;cr.yp.to&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cr.yp.to&#x2F;</a><p>While at a startup when we were looking at data at rest encryption, streaming encryption and other such things.  Dan had a page with different implementations (cross compiled from his assembler representation) to target chipsets and instruction sets.  Using VMs (this was the early&#x2F;mid 2000s) and such, it was interesting to see what of those instruction sets were supported.  In testing, there would be occasional hiccups where an implementation wasn&#x27;t fully supported though the VM claimed such.</div><br/></div></div><div id="40933223" class="c"><input type="checkbox" id="c-40933223" checked=""/><div class="controls bullet"><span class="by">t_sea</span><span>|</span><a href="#40932618">prev</a><span>|</span><a href="#40934269">next</a><span>|</span><label class="collapse" for="c-40933223">[-]</label><label class="expand" for="c-40933223">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Writing a CPU emulator is, in my opinion, the best way to REALLY understand how a CPU works.<p>The 68k disassembler we wrote in college was such a Neo “I know kung fu” moment for me. It was the missing link that let me reason about code from high-level language down to transistors and back. I can only imagine writing a full emulator is an order of magnitude more effective. Great article!</div><br/></div></div><div id="40934269" class="c"><input type="checkbox" id="c-40934269" checked=""/><div class="controls bullet"><span class="by">ale42</span><span>|</span><a href="#40933223">prev</a><span>|</span><a href="#40932166">next</a><span>|</span><label class="collapse" for="c-40934269">[-]</label><label class="expand" for="c-40934269">[1 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t it be (2023) rather than (2013)?</div><br/></div></div><div id="40932166" class="c"><input type="checkbox" id="c-40932166" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#40934269">prev</a><span>|</span><a href="#40930506">next</a><span>|</span><label class="collapse" for="c-40932166">[-]</label><label class="expand" for="c-40932166">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny to me how much grief x86 assembly generates when compared to RISC here, because I have the opposite problem when delinking code back into object files.<p>For this use-case, x86 is really easy to analyze whereas MIPS has been a nightmare to pull off. This is because all I mostly care about are references to code and data. x86 has pointer-sized immediate constants and MIPS has split HI16&#x2F;LO16 relocation pairs, which leads to all sorts of trouble with register usage graphs, code flow and branch delay instructions.<p>That should not be constructed as praise on my end for x86.</div><br/></div></div><div id="40930506" class="c"><input type="checkbox" id="c-40930506" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#40932166">prev</a><span>|</span><a href="#40933416">next</a><span>|</span><label class="collapse" for="c-40930506">[-]</label><label class="expand" for="c-40930506">[2 more]</label></div><br/><div class="children"><div class="content">Interesting read. I have a lot of respect for people who develop emulator for x86 processors. It is a complicated processor and from first hand experience I know that developing and debugging emulators for CPU&#x27;s can be very challenging. In the past year, I spend some time developing a very limited i386 emulator [1] including some system calls for executing the first steps of live-bootstrap [2], primarily to figure out how it is working. I learned a lot about system calls and ELF.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;Emulator&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;FransFaase&#x2F;Emulator&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;fosslinux&#x2F;live-bootstrap&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;fosslinux&#x2F;live-bootstrap&#x2F;</a></div><br/><div id="40931935" class="c"><input type="checkbox" id="c-40931935" checked=""/><div class="controls bullet"><span class="by">banish-m4</span><span>|</span><a href="#40930506">parent</a><span>|</span><a href="#40933416">next</a><span>|</span><label class="collapse" for="c-40931935">[-]</label><label class="expand" for="c-40931935">[1 more]</label></div><br/><div class="children"><div class="content">Most of the complexities lie in managing the various configurations of total system compatibility emulation, especially for timing, analog oddities, and whether to include bugs or not and for which steppings. If you want precise and accurate emulation, you have to have real hardware to validate behavior against. Then there are the cases of what not to emulate and offering better-than-original alternatives.</div><br/></div></div></div></div><div id="40929247" class="c"><input type="checkbox" id="c-40929247" checked=""/><div class="controls bullet"><span class="by">SunlitCat</span><span>|</span><a href="#40933416">prev</a><span>|</span><a href="#40930088">next</a><span>|</span><label class="collapse" for="c-40929247">[-]</label><label class="expand" for="c-40929247">[1 more]</label></div><br/><div class="children"><div class="content">Haha! Writing an x86 emulator! I still remember writing a toy emulator which was able to execute something around the first 1000-ish lines of a real bios (and then it stuck or looped when it started to access ports or so, can&#x27;t remember it was too long ago and I didn&#x27;t continue it as I started to get into DirectX and modern c++ more).</div><br/></div></div><div id="40930088" class="c"><input type="checkbox" id="c-40930088" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#40929247">prev</a><span>|</span><a href="#40933071">next</a><span>|</span><label class="collapse" for="c-40930088">[-]</label><label class="expand" for="c-40930088">[13 more]</label></div><br/><div class="children"><div class="content">Intel architecture is loaded with historical artifacts. The switch in how segment registers were used as you went from real mode to protected mode was an incredible hardware hack to keep older software working. I blame Intel for why so many folks avoid assembly language. I programmed in assembly for years using TI&#x27;s 84010 graphics chips and the design was gorgeous -- simple RISC instruction set, flat address space, and bit addressable! If during the earlier decades folks were programming using chips with more elegant designs, far more folks would be programming in assembly language (or at least would know how to).</div><br/><div id="40930906" class="c"><input type="checkbox" id="c-40930906" checked=""/><div class="controls bullet"><span class="by">russdill</span><span>|</span><a href="#40930088">parent</a><span>|</span><a href="#40930274">next</a><span>|</span><label class="collapse" for="c-40930906">[-]</label><label class="expand" for="c-40930906">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s crazy is that depending on how deep you want to go, a lot of the information is not available in documents published by Intel. Fortunately, if it matters for emulators it typically can be&#x2F;has been reverse engineering.</div><br/><div id="40931566" class="c"><input type="checkbox" id="c-40931566" checked=""/><div class="controls bullet"><span class="by">Max-q</span><span>|</span><a href="#40930088">root</a><span>|</span><a href="#40930906">parent</a><span>|</span><a href="#40930274">next</a><span>|</span><label class="collapse" for="c-40931566">[-]</label><label class="expand" for="c-40931566">[2 more]</label></div><br/><div class="children"><div class="content">Wow, is that true? And the documentation is thousands of pages! I can&#x27;t understand how Intel keep these processors consistent during development. It must be a really, really hard job.<p>It was a nice period in history when proper RISC was working well, when we could get stuff to run faster, but getting more transistors was expensive. Now we can&#x27;t get it to run faster but we can get billions of transistors, making stuff more complicated being the way to more performance.<p>I wonder if we ever again will get a time where simplification is a valid option...</div><br/><div id="40931797" class="c"><input type="checkbox" id="c-40931797" checked=""/><div class="controls bullet"><span class="by">russdill</span><span>|</span><a href="#40930088">root</a><span>|</span><a href="#40931566">parent</a><span>|</span><a href="#40930274">next</a><span>|</span><label class="collapse" for="c-40931797">[-]</label><label class="expand" for="c-40931797">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some info here:<p><a href="http:&#x2F;&#x2F;www.rcollins.org&#x2F;secrets&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.rcollins.org&#x2F;secrets&#x2F;</a>
<a href="http:&#x2F;&#x2F;www.rcollins.org&#x2F;ddj&#x2F;ddj.html" rel="nofollow">http:&#x2F;&#x2F;www.rcollins.org&#x2F;ddj&#x2F;ddj.html</a><p>Notably things like undocumented opcodes, processor modes, undocumented registers, undocumented bits within registers, etc. It&#x27;s not uncommon to release a specific set of documentation to trusted partners only. Back in the day intel called these &quot;gold books&quot;.</div><br/></div></div></div></div></div></div><div id="40930274" class="c"><input type="checkbox" id="c-40930274" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#40930088">parent</a><span>|</span><a href="#40930906">prev</a><span>|</span><a href="#40930485">next</a><span>|</span><label class="collapse" for="c-40930274">[-]</label><label class="expand" for="c-40930274">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I blame Intel for why so many folks avoid assembly language.<p>x86 (the worst assembly of any of the top 50 most popular ISAs by a massive margin) and tricky MIPS branch delay slots trivia questions at university have done more to turn off programmers from learning assembly than anything else and it&#x27;s not even close.<p>This is one reason I&#x27;m hoping that RISC-V kills off x86. It actually has a chance of once again allowing your average programmer to learn useful assembly.</div><br/><div id="40933128" class="c"><input type="checkbox" id="c-40933128" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40930088">root</a><span>|</span><a href="#40930274">parent</a><span>|</span><a href="#40930881">next</a><span>|</span><label class="collapse" for="c-40933128">[-]</label><label class="expand" for="c-40933128">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s putting the cart before the horse.  I think it wouldn&#x27;t matter which architecture you choose as there will always be deep performance considerations that must be understood in order to write efficient software.<p>Otherwise your statement might amount down to &quot;I hope there is an ISA that intentionally wastes performance and energy in deference to human standards of beauty.&quot;<p>It&#x27;s why the annals of expertise rarely makes for good dinner table conversation.</div><br/></div></div><div id="40930881" class="c"><input type="checkbox" id="c-40930881" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40930088">root</a><span>|</span><a href="#40930274">parent</a><span>|</span><a href="#40933128">prev</a><span>|</span><a href="#40930485">next</a><span>|</span><label class="collapse" for="c-40930881">[-]</label><label class="expand" for="c-40930881">[4 more]</label></div><br/><div class="children"><div class="content">What do you find particularly problematic about x86 assembly, from a pedagogical standpoint? I&#x27;ve never noticed any glaring issues with it, except for the weird suffixes and sigils if you use AT&amp;T syntax (which I generally avoid).</div><br/><div id="40931588" class="c"><input type="checkbox" id="c-40931588" checked=""/><div class="controls bullet"><span class="by">timmisiak</span><span>|</span><a href="#40930088">root</a><span>|</span><a href="#40930881">parent</a><span>|</span><a href="#40931372">next</a><span>|</span><label class="collapse" for="c-40931588">[-]</label><label class="expand" for="c-40931588">[2 more]</label></div><br/><div class="children"><div class="content">I suspect the biggest issue is that courses like to talk about how instructions are encoded, and that can be difficult with x86 considering how complex the encoding scheme is. Personally, I don&#x27;t think x86 is all that bad as long as you look at a small useful subset of instructions and ignore legacy and encoding.</div><br/><div id="40931692" class="c"><input type="checkbox" id="c-40931692" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40930088">root</a><span>|</span><a href="#40931588">parent</a><span>|</span><a href="#40931372">next</a><span>|</span><label class="collapse" for="c-40931692">[-]</label><label class="expand" for="c-40931692">[1 more]</label></div><br/><div class="children"><div class="content">True, encoding is one thing that really sets x86 apart. But as you say, the assembly itself doesn&#x27;t seem that uniquely horrible (at least not since the 32-bit era), which is why I found the sentiment confusing as it was phrased.<p>Maybe it&#x27;s the haphazard SIMD instruction set, with every extension adding various subtly-different ways to permute bytes and whatnot?  But that would hardly seem like a beginner&#x27;s issue. The integer multiplication and division instructions can also be a bit wonky to use, but hardly unbearably so.</div><br/></div></div></div></div></div></div></div></div><div id="40930485" class="c"><input type="checkbox" id="c-40930485" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#40930088">parent</a><span>|</span><a href="#40930274">prev</a><span>|</span><a href="#40931025">next</a><span>|</span><label class="collapse" for="c-40930485">[-]</label><label class="expand" for="c-40930485">[1 more]</label></div><br/><div class="children"><div class="content">If Terry A. Davis is to be trusted, as long as you ignore the legacy stuff, x64 assembly is nice to work with.</div><br/></div></div><div id="40931025" class="c"><input type="checkbox" id="c-40931025" checked=""/><div class="controls bullet"><span class="by">jecel</span><span>|</span><a href="#40930088">parent</a><span>|</span><a href="#40930485">prev</a><span>|</span><a href="#40933071">next</a><span>|</span><label class="collapse" for="c-40931025">[-]</label><label class="expand" for="c-40931025">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t that be the 34010?</div><br/><div id="40931258" class="c"><input type="checkbox" id="c-40931258" checked=""/><div class="controls bullet"><span class="by">waynecochran</span><span>|</span><a href="#40930088">root</a><span>|</span><a href="#40931025">parent</a><span>|</span><a href="#40933071">next</a><span>|</span><label class="collapse" for="c-40931258">[-]</label><label class="expand" for="c-40931258">[1 more]</label></div><br/><div class="children"><div class="content">Yes. TMS 34010 and 34020 ... my bad.</div><br/></div></div></div></div></div></div><div id="40933071" class="c"><input type="checkbox" id="c-40933071" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#40930088">prev</a><span>|</span><a href="#40930000">next</a><span>|</span><label class="collapse" for="c-40933071">[-]</label><label class="expand" for="c-40933071">[1 more]</label></div><br/><div class="children"><div class="content">“I don’t believe in emulatores.” - 0x86</div><br/></div></div><div id="40930000" class="c"><input type="checkbox" id="c-40930000" checked=""/><div class="controls bullet"><span class="by">was_a_dev</span><span>|</span><a href="#40933071">prev</a><span>|</span><a href="#40929146">next</a><span>|</span><label class="collapse" for="c-40930000">[-]</label><label class="expand" for="c-40930000">[2 more]</label></div><br/><div class="children"><div class="content">Off topic, but I like this blog style&#x2F;layout. I can imagine it isn&#x27;t everyones taste, but it just works for me</div><br/><div id="40931528" class="c"><input type="checkbox" id="c-40931528" checked=""/><div class="controls bullet"><span class="by">timmisiak</span><span>|</span><a href="#40930000">parent</a><span>|</span><a href="#40929146">next</a><span>|</span><label class="collapse" for="c-40931528">[-]</label><label class="expand" for="c-40931528">[1 more]</label></div><br/><div class="children"><div class="content">Glad you like it. I used m10c, with a few tweaks: <a href="https:&#x2F;&#x2F;github.com&#x2F;vaga&#x2F;hugo-theme-m10c">https:&#x2F;&#x2F;github.com&#x2F;vaga&#x2F;hugo-theme-m10c</a></div><br/></div></div></div></div><div id="40929146" class="c"><input type="checkbox" id="c-40929146" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#40930000">prev</a><span>|</span><a href="#40931206">next</a><span>|</span><label class="collapse" for="c-40929146">[-]</label><label class="expand" for="c-40929146">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written fast emulators for a dozen non-toy architectures and a few JIT translators for a few as well. x86 still gives me PTSD. I have never seen a messier architecture. There is history, and a reason for it, but still ... damn</div><br/><div id="40929301" class="c"><input type="checkbox" id="c-40929301" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40929146">parent</a><span>|</span><a href="#40929237">next</a><span>|</span><label class="collapse" for="c-40929301">[-]</label><label class="expand" for="c-40929301">[10 more]</label></div><br/><div class="children"><div class="content">Studying the x86 architecture is kind of like studying languages with lots of irregularities and vestigial bits, and with competing grammatical paradigms, e.g. French. Other architectures, like RISC-V and ARMv8, are much more consistent.</div><br/><div id="40931185" class="c"><input type="checkbox" id="c-40931185" checked=""/><div class="controls bullet"><span class="by">aengelke</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40929301">parent</a><span>|</span><a href="#40930101">next</a><span>|</span><label class="collapse" for="c-40931185">[-]</label><label class="expand" for="c-40931185">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Other architectures, like [...] ARMv8, are much more consistent.<p>From an instruction&#x2F;operation perspective, AArch64 is more clean. However, from an instruction operand and encoding perspective, AArch64 is a lot less consistent than x86. Consider the different operand types: on x86, there are a dozen register types, immediate (8&#x2F;16&#x2F;32&#x2F;64 bits), and memory operands (always the same layout). On AArch64, there&#x27;s: GP regs, incremented GP reg (MOPS extension), extended GP reg (e.g., SXTB), shifted GP reg, stack pointer, FP reg, vector register, vector register element, vector register table, vector register table element, a dozen types of memory operands, conditions, and a dozen types of immediate encodings (including the fascinating and very useful, but also very non-trivial encoding of logical immediates [1]).<p>AArch64 also has some register constraints: some vector operations can only encode register 0-15 or 0-7; not to mention SVE with it&#x27;s &quot;movprfx&quot; prefix instruction that is only valid in front of a few selected instructions.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;aengelke&#x2F;disarm&#x2F;blob&#x2F;master&#x2F;encode.c#L19-L54">https:&#x2F;&#x2F;github.com&#x2F;aengelke&#x2F;disarm&#x2F;blob&#x2F;master&#x2F;encode.c#L19-...</a></div><br/><div id="40934474" class="c"><input type="checkbox" id="c-40934474" checked=""/><div class="controls bullet"><span class="by">corsix</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40931185">parent</a><span>|</span><a href="#40932104">next</a><span>|</span><label class="collapse" for="c-40934474">[-]</label><label class="expand" for="c-40934474">[1 more]</label></div><br/><div class="children"><div class="content">For an implementation of logical immediate encoding without the loop, see <a href="https:&#x2F;&#x2F;github.com&#x2F;LuaJIT&#x2F;LuaJIT&#x2F;blob&#x2F;04dca7911ea255f37be799c18d74c305b921c1a6&#x2F;src&#x2F;lj_emit_arm64.h#L43-L58">https:&#x2F;&#x2F;github.com&#x2F;LuaJIT&#x2F;LuaJIT&#x2F;blob&#x2F;04dca7911ea255f37be799...</a></div><br/></div></div><div id="40932104" class="c"><input type="checkbox" id="c-40932104" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40931185">parent</a><span>|</span><a href="#40934474">prev</a><span>|</span><a href="#40931810">next</a><span>|</span><label class="collapse" for="c-40932104">[-]</label><label class="expand" for="c-40932104">[1 more]</label></div><br/><div class="children"><div class="content">As I&#x27;m currently implementing an AArch64 code generator for the D language dmd compiler, the inconsistency of its instructions is equaled and worsened by the clumsiness of the documentation for it :-&#x2F; But I&#x27;m slowly figuring it out.<p>(For example, some instructions with very different encodings have the same mnemonic. Arrgghh.)</div><br/></div></div><div id="40931810" class="c"><input type="checkbox" id="c-40931810" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40931185">parent</a><span>|</span><a href="#40932104">prev</a><span>|</span><a href="#40930101">next</a><span>|</span><label class="collapse" for="c-40931810">[-]</label><label class="expand" for="c-40931810">[4 more]</label></div><br/><div class="children"><div class="content">Admittedly, I never wrote an assembler, but the encoding of x86-64 seems pretty convoluted [0] [1], with much of the information smeared across the some bits in the Mod&#x2F;RM and SIB bytes and then extended by prefix bytes. It&#x27;s more complicated than you would assume from having only written assembly in text and then having the assembler encode the instructions.<p>One of the things that sticks out to me is that on x86-64, operations on 32-bit registers implicitly zero out the upper 32-bits of the corresponding 64-bit register (e.g. &quot;MOV EAX, EBX&quot; also zeroes out the upper 32-bits of RAX), except for the opcode 0x90, which, logically, would be the accumulator encoding of &quot;XCHG EAX, EAX&quot; but is special-cased to do nothing because it&#x27;s the traditional NOP instruction for x86. So you have to use the other encoding, 87 C0.<p>The fact that AArch64 has instructions that are almost always 4 bytes, and the fact that they clearly thought out their instruction set more (e.g. instead of having CMP, they just use SUBS (subtract and store condition codes) and store the result in the zero register, which is always zero), is what made me say that it seemed more regular. I hadn&#x27;t studied it in as close detail as x86-64, though. But, you&#x27;ve written an an ARM disassembler and I haven&#x27;t; you seem to know more about it than me, and so I believe what you&#x27;re saying.<p>&gt; AArch64 also has some register constraints<p>x86-64 also has some, in that many instructions can&#x27;t encode the upper 8 bits of a 16-bit register (AH, BH, DH, CH) if a REX prefix is used.<p>[0]: <a href="https:&#x2F;&#x2F;wiki.osdev.org&#x2F;X86-64_Instruction_Encoding" rel="nofollow">https:&#x2F;&#x2F;wiki.osdev.org&#x2F;X86-64_Instruction_Encoding</a><p>[1]: <a href="http:&#x2F;&#x2F;www.c-jump.com&#x2F;CIS77&#x2F;CPU&#x2F;x86&#x2F;lecture.html" rel="nofollow">http:&#x2F;&#x2F;www.c-jump.com&#x2F;CIS77&#x2F;CPU&#x2F;x86&#x2F;lecture.html</a></div><br/><div id="40932142" class="c"><input type="checkbox" id="c-40932142" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40931810">parent</a><span>|</span><a href="#40932629">next</a><span>|</span><label class="collapse" for="c-40932142">[-]</label><label class="expand" for="c-40932142">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you&#x27;ve written an an ARM disassembler<p>Here&#x27;s my AArch64 disassembler work in progress:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;blob&#x2F;master&#x2F;compiler&#x2F;src&#x2F;dmd&#x2F;backend&#x2F;arm&#x2F;disasmarm.d">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;blob&#x2F;master&#x2F;compiler&#x2F;src&#x2F;dmd&#x2F;ba...</a><p>I add to it in tandem with writing the code generator. It helps flush out bugs in both by doing this. I.e. generate the instruction, the disassemble it and compare with what I thought it should be.<p>It&#x27;s quite a bit more complicated than the corresponding x86 disassembler:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;blob&#x2F;master&#x2F;compiler&#x2F;src&#x2F;dmd&#x2F;backend&#x2F;x86&#x2F;disasm86.d">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;dmd&#x2F;blob&#x2F;master&#x2F;compiler&#x2F;src&#x2F;dmd&#x2F;ba...</a></div><br/></div></div><div id="40932629" class="c"><input type="checkbox" id="c-40932629" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40931810">parent</a><span>|</span><a href="#40932142">prev</a><span>|</span><a href="#40932311">next</a><span>|</span><label class="collapse" for="c-40932629">[-]</label><label class="expand" for="c-40932629">[1 more]</label></div><br/><div class="children"><div class="content">One of the projects I work on every now and then is the &quot;World&#x27;s Worst X86 Decoder&quot;, where I&#x27;m trying to essentially automatically uncover x86 assembly semantics without ever having to build a list of x86 instructions, and this has forced me to look at the x86 ISA in a different way. The basic format I build for an opcode is this:<p><pre><code>  enum Group1Prefix { Lock = 0xf0, Repnz = 0xf2, Repz = 0xf3 }
  enum Group2Prefix { Cs = 0x2e, Ds = 0x3e, Es = 0x26, Fs = 0x64, Gs = 0x65, Ss = 0x36 }
  enum Group3Prefix { OpSize = 0x66 }
  enum Group4Prefix { AddrSize = 0x67 }
  enum ModernPrefix {
    Rex { w: bool },
    Vex { w: bool, l: bool },
  }
  struct Opcode {
    pub group1: Option&lt;Group1Prefix&gt;,
    pub group2: Option&lt;Group2Prefix&gt;,
    pub group3: Option&lt;Group3Prefix&gt;,
    pub group4: Option&lt;Group4Prefix&gt;,
    pub modern_prefix: Option&lt;ModernPrefix&gt;,
    pub opcode_map: u8,
    pub opcode: u8,
  }
</code></pre>
And all opcodes can optionally have an immediate of 1, 2, 3, 4, or 8 bytes and optionally have a ModR&#x2F;M byte (which is a separate datastructure because I don&#x27;t enter that information myself, I simply run a sandsifter-like program to execute every single opcode and work out the answer).<p>This isn&#x27;t quite accurate to how an assembler would see it, as Intel will sometimes pack instructions with 0 or 1 operands into a ModR&#x2F;M byte, so that, e.g., 0F.01 eax, [mem] is actually the SGDT instruction and 0F.01 ecx, [mem] is SIDT (and 0F.01 eax, ecx is actually VMCALL).<p>As long as you&#x27;re internally making a distinction between the different operand forms of instructions (e.g., 8-bit ADD versus 16-bit versus 32-bit versus 64-bit, and register&#x2F;register versus register&#x2F;immediate versus register&#x2F;memory), it&#x27;s actually not all that difficult to deal with the instruction encoding, or even mapping IR to those instructions, at least until EVEX prefixes enter the picture.</div><br/></div></div><div id="40932311" class="c"><input type="checkbox" id="c-40932311" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40931810">parent</a><span>|</span><a href="#40932629">prev</a><span>|</span><a href="#40930101">next</a><span>|</span><label class="collapse" for="c-40932311">[-]</label><label class="expand" for="c-40932311">[1 more]</label></div><br/><div class="children"><div class="content">x86 has a lot of special cases and it&#x27;s becoming harder and harder to find non-code material with all instructions in a nice tabular format. But overall the encoding isn&#x27;t that complicated. What&#x27;s complex in the architecture is the amount of legacy stuff that still lives in privileged code.<p>&gt; x86-64 also has some, in that many instructions can&#x27;t encode the upper 8 bits of a 16-bit register (AH, BH, DH, CH) if a REX prefix is used.<p>You can&#x27;t use both the high registers and the extended low registers in the same instruction, indeed. But in practice nobody is using the high registers anymore so it&#x27;s a relatively rare limitation.</div><br/></div></div></div></div></div></div><div id="40930101" class="c"><input type="checkbox" id="c-40930101" checked=""/><div class="controls bullet"><span class="by">x0x0</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40929301">parent</a><span>|</span><a href="#40931185">prev</a><span>|</span><a href="#40929237">next</a><span>|</span><label class="collapse" for="c-40930101">[-]</label><label class="expand" for="c-40930101">[2 more]</label></div><br/><div class="children"><div class="content">I think English may be a better example; we just stapled chunks of vulgar latin to  an inconsistently simplified proto-germanic and then borrowed words from every language we met along the way.  Add in 44 sounds serialized to the page with 26 letters and tada!</div><br/><div id="40932174" class="c"><input type="checkbox" id="c-40932174" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40930101">parent</a><span>|</span><a href="#40929237">next</a><span>|</span><label class="collapse" for="c-40932174">[-]</label><label class="expand" for="c-40932174">[1 more]</label></div><br/><div class="children"><div class="content">The Norman conquest of England means English is a language with barbarian syntax and French nouns. It&#x27;s a happy mess of cultural appropriation!<p>Squeezing the lot into 26 characters was simply genius - enabling printing with movable type, Morse code, Baudot code, ASCII, etc.<p>Of course, then icons came along and ruined everything.</div><br/></div></div></div></div></div></div><div id="40929237" class="c"><input type="checkbox" id="c-40929237" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40929146">parent</a><span>|</span><a href="#40929301">prev</a><span>|</span><a href="#40929219">next</a><span>|</span><label class="collapse" for="c-40929237">[-]</label><label class="expand" for="c-40929237">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I have never seen a messier architecture.<p>Itanium. Pretty much every time I open up the manual, I find a new thing that makes me go &quot;what the hell were you guys thinking!?&quot; without even trying to.</div><br/><div id="40930859" class="c"><input type="checkbox" id="c-40930859" checked=""/><div class="controls bullet"><span class="by">snazz</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40929237">parent</a><span>|</span><a href="#40929219">next</a><span>|</span><label class="collapse" for="c-40930859">[-]</label><label class="expand" for="c-40930859">[3 more]</label></div><br/><div class="children"><div class="content">What sorts of projects are you working on that use Itanium?</div><br/><div id="40931416" class="c"><input type="checkbox" id="c-40931416" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40929146">root</a><span>|</span><a href="#40930859">parent</a><span>|</span><a href="#40929219">next</a><span>|</span><label class="collapse" for="c-40931416">[-]</label><label class="expand" for="c-40931416">[2 more]</label></div><br/><div class="children"><div class="content">None, really. I just happened to get a copy of the manual and start idly reading it when my computer got stuck in a very long update-reboot cycle and I couldn&#x27;t do anything other than read a physical book.</div><br/></div></div></div></div></div></div><div id="40929219" class="c"><input type="checkbox" id="c-40929219" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#40929146">parent</a><span>|</span><a href="#40929237">prev</a><span>|</span><a href="#40931206">next</a><span>|</span><label class="collapse" for="c-40929219">[-]</label><label class="expand" for="c-40929219">[1 more]</label></div><br/><div class="children"><div class="content">Haha, man, I feel you :DD
You probably should have started with it from the very beginning :D</div><br/></div></div></div></div><div id="40931206" class="c"><input type="checkbox" id="c-40931206" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#40929146">prev</a><span>|</span><a href="#40929460">next</a><span>|</span><label class="collapse" for="c-40931206">[-]</label><label class="expand" for="c-40931206">[1 more]</label></div><br/><div class="children"><div class="content">Just as an adjacent aside from a random about learning by doing:<p>Implementing a ThingDoer is a huge learning experience. I remember doing co-op  &quot;write-a-compiler&quot; coursework with another person. We were doing great, everything was working and then we got to the oral exam...<p>&quot;Why is your Stack Pointer growing upwards&quot;?<p>... I was kinda stunned. I&#x27;d never thought about that. We understood most of the things, but sometimes we kind of just bashed at things until they worked... and it turned out upward-growing SP did work (up to a point) on the architecture our toy compiler was targeting.</div><br/></div></div></div></div></div></div></div></body></html>