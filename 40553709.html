<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717405251202" as="style"/><link rel="stylesheet" href="styles.css?v=1717405251202"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.circle-lang.org/site/intro/">Circle C++ with memory safety</a> <span class="domain">(<a href="https://www.circle-lang.org">www.circle-lang.org</a>)</span></div><div class="subtext"><span>davikr</span> | <span>148 comments</span></div><br/><div><div id="40555270" class="c"><input type="checkbox" id="c-40555270" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40555787">next</a><span>|</span><label class="collapse" for="c-40555270">[-]</label><label class="expand" for="c-40555270">[27 more]</label></div><br/><div class="children"><div class="content">Sean (the author of Circle) is an impressive guy. He started pursuing this work at about the same point several of the &quot;C++ Successor Languages&quot; were created, but although all of them <i>claimed</i> to be about solving this problem, especially when first announced, they actually don&#x27;t have a solution unlike this Circle work. Let me briefly enumerate:<p>Val (now HyLo) says it wants to solve this problem... but it doesn&#x27;t yet have the C++ interop stuff, so, it&#x27;s just really a completely different language nobody uses.<p>Carbon wants to ship a finished working Carbon language, then bolt on safety (somehow) but, only for some things, not data races for example, so, you still don&#x27;t actually have Rust&#x27;s Memory Safety<p>Cpp2 explicitly says it isn&#x27;t even interested in solving the problem, Herb says if he can produced measurements saying it&#x27;s &quot;safer&quot; somehow that&#x27;s good enough.<p>It&#x27;s interesting how many good ideas from Rust just come along free for the ride when you try to do this, do you like Destructive Move? Good news, that&#x27;s how you make this work in Rust so that&#x27;s how Circle does it. Exhaustive Pattern Matching? Again, Circles does that for the same reason Rust needs it.<p>It is certainly true that this is not the Only Possible Way to get Safety. It would be profoundly weird if Rust had stumbled onto such a thing, but &quot;Let&#x27;s just copy the thing that worked in Rust&quot; is somehow at once the simplest possible plan that could work <i>and</i> an astonishing achievement for one man.</div><br/><div id="40555720" class="c"><input type="checkbox" id="c-40555720" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40555270">parent</a><span>|</span><a href="#40556343">next</a><span>|</span><label class="collapse" for="c-40555720">[-]</label><label class="expand" for="c-40555720">[4 more]</label></div><br/><div class="children"><div class="content">Right now, Circle looks like the only Typescript like evolution path for existing C++, with a production quality compiler.<p>Unfortunately WG21 seems to have some issues with any ideas coming out from Circle, going back to its early days, and I don&#x27;t see them being willing to adopt Sean&#x27;s work.<p>Which is really a pity, as he single handled managed to deliver more than whole C++ compiler folks, stuck in endless discussions about the philosophical meaning of the word safety.<p>Maybe at least some vendor in high integrity computing domain does adopt his work.</div><br/><div id="40556221" class="c"><input type="checkbox" id="c-40556221" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40555720">parent</a><span>|</span><a href="#40556343">next</a><span>|</span><label class="collapse" for="c-40556221">[-]</label><label class="expand" for="c-40556221">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Unfortunately WG21 seems to have some issues with any ideas coming out from Circle, going back to its early days, and I don&#x27;t see them being willing to adopt Sean&#x27;s work.<p>What reasons? Are those valid?</div><br/><div id="40556512" class="c"><input type="checkbox" id="c-40556512" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556221">parent</a><span>|</span><a href="#40556343">next</a><span>|</span><label class="collapse" for="c-40556512">[-]</label><label class="expand" for="c-40556512">[2 more]</label></div><br/><div class="children"><div class="content">It was due to the metaprogramming capabilities, due to how Circle enables to use full C++ at compile time instead of constexpr&#x2F;constinit&#x2F;constval, David Sankel has a talk where he jokes with the WG21 decision process that was behind it,<p>&quot;Don&#x27;t constexpr All the Things&quot;, from CppNow 2021,<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;NNU6cbG96M4?t=2045" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;NNU6cbG96M4?t=2045</a></div><br/><div id="40557384" class="c"><input type="checkbox" id="c-40557384" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556512">parent</a><span>|</span><a href="#40556343">next</a><span>|</span><label class="collapse" for="c-40557384">[-]</label><label class="expand" for="c-40557384">[1 more]</label></div><br/><div class="children"><div class="content">Well, GCC supports -fimplicit-constexpr these days: <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;C_002b_002b-Dialect-Options.html#index-fimplicit-constexpr" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;C_002b_002b-Dialect-Optio...</a></div><br/></div></div></div></div></div></div></div></div><div id="40556343" class="c"><input type="checkbox" id="c-40556343" checked=""/><div class="controls bullet"><span class="by">wrsh07</span><span>|</span><a href="#40555270">parent</a><span>|</span><a href="#40555720">prev</a><span>|</span><a href="#40555356">next</a><span>|</span><label class="collapse" for="c-40556343">[-]</label><label class="expand" for="c-40556343">[16 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very confused by the love for circle - there&#x27;s a GitHub that hasn&#x27;t been updated for 7 months that doesn&#x27;t have a license.<p>When I first heard about it, a lot of the ideas seemed interesting, but are there users of it?<p>I think my biggest question is &quot;what is the goal here?&quot;<p>For carbon they&#x27;re pretty explicit that it&#x27;s a research prototype. If anything is to come if it, it will need to be usable at Google&#x27;s scale (they have real issues with build times, they build from head so abi compatibility isn&#x27;t required, etc)<p>Herb wasn&#x27;t really designing cpp2 as a successor language so much as a playground to understand what features might make sense to propose for adoption in c++.<p>What is circle? It&#x27;s more than just some project, but the ideas haven&#x27;t been adopted in cpp and the compiler repository isn&#x27;t being updated</div><br/><div id="40556411" class="c"><input type="checkbox" id="c-40556411" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556343">parent</a><span>|</span><a href="#40555356">next</a><span>|</span><label class="collapse" for="c-40556411">[-]</label><label class="expand" for="c-40556411">[15 more]</label></div><br/><div class="children"><div class="content">Circle is not open source, that’s correct.</div><br/><div id="40556701" class="c"><input type="checkbox" id="c-40556701" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556411">parent</a><span>|</span><a href="#40559684">next</a><span>|</span><label class="collapse" for="c-40556701">[-]</label><label class="expand" for="c-40556701">[13 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s automatically a dead end, then. People have inceasingly abandoned closed source compilers, they create a huge risk if the maker decides to stop maintaining it. Most languages that people pick up have an open source software implementation.</div><br/><div id="40557582" class="c"><input type="checkbox" id="c-40557582" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556701">parent</a><span>|</span><a href="#40559498">next</a><span>|</span><label class="collapse" for="c-40557582">[-]</label><label class="expand" for="c-40557582">[5 more]</label></div><br/><div class="children"><div class="content">In most cases, I’d probably agree with your point here, but in this case, I think you’re wrong. If Circle can truly accomplish its stated goals, the value proposition of a memory-safe superset of C++ is ginormous. Lots of companies with critical software written in C++ won’t care that Circle isn’t open-source as long as it ticks all of their boxes (certifications, audits, etc.) and they have a strong enterprise support story. This isn’t your average project.</div><br/><div id="40557809" class="c"><input type="checkbox" id="c-40557809" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40557582">parent</a><span>|</span><a href="#40558854">next</a><span>|</span><label class="collapse" for="c-40557809">[-]</label><label class="expand" for="c-40557809">[2 more]</label></div><br/><div class="children"><div class="content">Even Ada is not that closed. But yeah, Ada proves that some will pay, a lot.</div><br/><div id="40559933" class="c"><input type="checkbox" id="c-40559933" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40557809">parent</a><span>|</span><a href="#40558854">next</a><span>|</span><label class="collapse" for="c-40559933">[-]</label><label class="expand" for="c-40559933">[1 more]</label></div><br/><div class="children"><div class="content">Enough that there are still seven vendors selling Ada compilers.</div><br/></div></div></div></div><div id="40558854" class="c"><input type="checkbox" id="c-40558854" checked=""/><div class="controls bullet"><span class="by">wrsh07</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40557582">parent</a><span>|</span><a href="#40557809">prev</a><span>|</span><a href="#40559498">next</a><span>|</span><label class="collapse" for="c-40558854">[-]</label><label class="expand" for="c-40558854">[2 more]</label></div><br/><div class="children"><div class="content">I hope that&#x27;s right, but I don&#x27;t really get it.<p>From a practical standpoint, when you run your tests with msan and asan (and if you have decent test coverage) I&#x27;m not convinced of the benefits of memory safety that eg rust provides<p>Supposing that it is worth it though, why not migrate to rust? I have a friend starting a startup &#x2F; consultancy to do just that, and it makes more sense than using circle. Even carbon says &quot;if you can use rust, use rust not carbon&quot;</div><br/><div id="40558933" class="c"><input type="checkbox" id="c-40558933" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40558854">parent</a><span>|</span><a href="#40559498">next</a><span>|</span><label class="collapse" for="c-40558933">[-]</label><label class="expand" for="c-40558933">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Supposing that it is worth it though, why not migrate to rust? I have a friend starting a startup &#x2F; consultancy to do just that, and it makes more sense than using circle. Even carbon says &quot;if you can use rust, use rust not carbon&quot;<p>A key selling point for Circle is the “superset of C++” aspect. What you’re proposing—while feasible for startups—is entirely unreasonable for larger companies, especially those with existing [usually massive] C++ codebases. With enough evangelizing, you might get them to agree to start using something like Rust in new, smaller, and internal projects. However, suggesting a rewrite of anything mission-critical that can directly impact the bottom line to an entirely different language, ecosystem, behaviors, guarantees, community, etc. is one of the most scary proposals you can make to a company. Are the existing engineers proficient in this new language? How long will it take to ramp up? Are there any new costs (not just financial) to adopting this new language (hint: there always are)? Are there legal concerns? How long will the rewrite take (hint: likely longer than the engineers think)? The list goes on. It’s simply too risky a proposition.</div><br/></div></div></div></div></div></div><div id="40559498" class="c"><input type="checkbox" id="c-40559498" checked=""/><div class="controls bullet"><span class="by">shaklee3</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556701">parent</a><span>|</span><a href="#40557582">prev</a><span>|</span><a href="#40559697">next</a><span>|</span><label class="collapse" for="c-40559498">[-]</label><label class="expand" for="c-40559498">[1 more]</label></div><br/><div class="children"><div class="content">Sean has said he would consider open sourcing it later, but doing so now would defeat the purpose of the project. He makes a lot of progress simply because he&#x27;s but watching all the issues and prs in GitHub.</div><br/></div></div><div id="40559697" class="c"><input type="checkbox" id="c-40559697" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556701">parent</a><span>|</span><a href="#40559498">prev</a><span>|</span><a href="#40559942">next</a><span>|</span><label class="collapse" for="c-40559697">[-]</label><label class="expand" for="c-40559697">[1 more]</label></div><br/><div class="children"><div class="content">The greatest value of Circle isn&#x27;t in the compiler and tooling, it&#x27;s in the design. Designing a C++ superset with Rust-like safety properties is <i>hard</i>. Once Circle gains traction, there&#x27;s 110% chance that it gets reimplemented elsewhere.<p>That said, I&#x27;m wholly uninterested in any proprietary language, too.</div><br/></div></div><div id="40559942" class="c"><input type="checkbox" id="c-40559942" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556701">parent</a><span>|</span><a href="#40559697">prev</a><span>|</span><a href="#40556755">next</a><span>|</span><label class="collapse" for="c-40559942">[-]</label><label class="expand" for="c-40559942">[3 more]</label></div><br/><div class="children"><div class="content">There is still a healthy C and C++ commercial compiler market, specially in embedded, high integrity computing and games.</div><br/><div id="40560072" class="c"><input type="checkbox" id="c-40560072" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40559942">parent</a><span>|</span><a href="#40556755">next</a><span>|</span><label class="collapse" for="c-40560072">[-]</label><label class="expand" for="c-40560072">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but the whole value proposition of Circle is rewriting existing C++ libraries in safe C++. Because if not, you could &quot;just&quot; use Rust and call them from there. And without an open source compiler that won&#x27;t happen, even if it would be free as in beer.</div><br/><div id="40560408" class="c"><input type="checkbox" id="c-40560408" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40560072">parent</a><span>|</span><a href="#40556755">next</a><span>|</span><label class="collapse" for="c-40560408">[-]</label><label class="expand" for="c-40560408">[1 more]</label></div><br/><div class="children"><div class="content">Regulation and certificed compilers also help to reach decisions.</div><br/></div></div></div></div></div></div><div id="40556755" class="c"><input type="checkbox" id="c-40556755" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556701">parent</a><span>|</span><a href="#40559942">prev</a><span>|</span><a href="#40558359">next</a><span>|</span><label class="collapse" for="c-40556755">[-]</label><label class="expand" for="c-40556755">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more complicated than that, but I agree that it&#x27;s a factor that would give some folks pause for currently adopting Circle.</div><br/></div></div><div id="40558359" class="c"><input type="checkbox" id="c-40558359" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40556701">parent</a><span>|</span><a href="#40556755">prev</a><span>|</span><a href="#40559684">next</a><span>|</span><label class="collapse" for="c-40558359">[-]</label><label class="expand" for="c-40558359">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t MSVC closed source?</div><br/></div></div></div></div></div></div></div></div><div id="40555356" class="c"><input type="checkbox" id="c-40555356" checked=""/><div class="controls bullet"><span class="by">Vt71fcAqt7</span><span>|</span><a href="#40555270">parent</a><span>|</span><a href="#40556343">prev</a><span>|</span><a href="#40555787">next</a><span>|</span><label class="collapse" for="c-40555356">[-]</label><label class="expand" for="c-40555356">[6 more]</label></div><br/><div class="children"><div class="content">&gt;Carbon wants to ship a finished working Carbon language, then bolt on safety (somehow) but, only for some things, not data races for example, so, you still don&#x27;t actually have Rust&#x27;s Memory Safety<p>I&#x27;m not sure this is correct. As I understand it, Carbon&#x27;s plan is to add a borrow checker like Rust&#x27;s.<p>From a recent talk[0][1] by one of the lead developers:<p>&gt;Best candidate for C++ is likely similar to Rust’s borrow checker<p>[0] slides: <a href="https:&#x2F;&#x2F;chandlerc.blog&#x2F;slides&#x2F;2023-cppnow-carbon-strategy&#x2F;index.html#&#x2F;105" rel="nofollow">https:&#x2F;&#x2F;chandlerc.blog&#x2F;slides&#x2F;2023-cppnow-carbon-strategy&#x2F;in...</a><p>[1] relevant timestamps:<p><a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=1ZTJ9omXOQ0&amp;t=1h31m34s" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=1ZTJ9omXOQ0&amp;t=1h31m34s</a><p><a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=1ZTJ9omXOQ0&amp;t=1h9m49s" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=1ZTJ9omXOQ0&amp;t=1h9m49s</a></div><br/><div id="40555483" class="c"><input type="checkbox" id="c-40555483" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40555356">parent</a><span>|</span><a href="#40555787">next</a><span>|</span><label class="collapse" for="c-40555483">[-]</label><label class="expand" for="c-40555483">[5 more]</label></div><br/><div class="children"><div class="content">Chandler has explicitly said that he doesn&#x27;t see a reason to solve data races.<p>The borrow checker isn&#x27;t enough on its own to solve this in Rust, Sean explains (probably deeper in Circle&#x27;s documentation) that you need to track a new property of types which is infectious, Rust does this with the Send and Sync traits.</div><br/><div id="40558630" class="c"><input type="checkbox" id="c-40558630" checked=""/><div class="controls bullet"><span class="by">chandlerc1024</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40555483">parent</a><span>|</span><a href="#40555721">next</a><span>|</span><label class="collapse" for="c-40558630">[-]</label><label class="expand" for="c-40558630">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Chandler has explicitly said that he doesn&#x27;t see a reason to solve data races.&quot;<p>Er, the slide title says that solving this is <i>highly desirable</i>, just not a strict requirement for security purposes.<p>Not sure how that&#x27;s the same as &quot;doesn&#x27;t see a reason to solve data races&quot;. I see lots of reasons. I just think it is <i>possible</i> to achieve the security goals without it.<p>FWIW, I&#x27;m hopeful we&#x27;ll end up including this in whatever model we end up with for Safe Carbon. It&#x27;s just a degree of freedom we also shouldn&#x27;t ignore when designing it.</div><br/><div id="40559751" class="c"><input type="checkbox" id="c-40559751" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40558630">parent</a><span>|</span><a href="#40558842">next</a><span>|</span><label class="collapse" for="c-40559751">[-]</label><label class="expand" for="c-40559751">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not sure how that&#x27;s the same as &quot;doesn&#x27;t see a reason to solve data races&quot;. I see lots of reasons. I just think it is possible to achieve the security goals without it.<p>If Carbon doesn&#x27;t prevent data races, then how exactly will it achieve memory safety? Will it implement something like OCaml&#x27;s &quot;Bounding Data Races in Space and Time&quot;? [0]<p>If we ignore compiler optimizations, the problem with data races is that it may make you observe tearing (incomplete writes) and thus it&#x27;s almost impossible to maintain safety invariants with them. But the job of a safe low level language is to give tools for the programmer to guarantee correctness of the unsafe parts. In the presence of data races, this is infeasible. So even if you find a way to ensure that data races aren&#x27;t technically UB, data races happening in a low level language surely lead to UB elsewhere.<p>Ultimately this may end up showing as CVEs related to memory safety so I don&#x27;t think you can achieve your security goals without preventing data races.<p>[0] <a href="https:&#x2F;&#x2F;kcsrk.info&#x2F;papers&#x2F;pldi18-memory.pdf" rel="nofollow">https:&#x2F;&#x2F;kcsrk.info&#x2F;papers&#x2F;pldi18-memory.pdf</a></div><br/></div></div><div id="40558842" class="c"><input type="checkbox" id="c-40558842" checked=""/><div class="controls bullet"><span class="by">Vt71fcAqt7</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40558630">parent</a><span>|</span><a href="#40559751">prev</a><span>|</span><a href="#40555721">next</a><span>|</span><label class="collapse" for="c-40558842">[-]</label><label class="expand" for="c-40558842">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for clarifying that point. It&#x27;s worth pointing out that the safety strategy doc[0] mentions that<p>&gt;A key subset of safety categories Carbon should address are:<p>&gt;[...]<p>&gt;Data race safety protects against racing memory access: when a thread accesses (read or write) a memory location concurrently with a different writing thread and without synchronizing<p>But then later in the doc it says<p>&gt;It&#x27;s possible to modify the Rust model several ways in order to reduce the burden on C++ developers:<p>&gt;Don&#x27;t offer safety guarantees for data races, eliminating RefCell.<p>&gt;[...]<p>&gt;Overall, Carbon is making a compromise around safety in order to give a path for C++ to evolve. [...]<p>One could read this as saying that guaranteed safety against data races is not a goal. Perhaps this doc could be reworded? Maybe something like &quot;Carbon does not see guaranteed safety against data races as strictly necessary to achieve its security goals but we still currently aim for a model that will prevent them.&quot;<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;trunk&#x2F;docs&#x2F;project&#x2F;principles&#x2F;safety_strategy.md">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;trunk&#x2F;do...</a></div><br/></div></div></div></div><div id="40555721" class="c"><input type="checkbox" id="c-40555721" checked=""/><div class="controls bullet"><span class="by">Vt71fcAqt7</span><span>|</span><a href="#40555270">root</a><span>|</span><a href="#40555483">parent</a><span>|</span><a href="#40558630">prev</a><span>|</span><a href="#40555787">next</a><span>|</span><label class="collapse" for="c-40555721">[-]</label><label class="expand" for="c-40555721">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. In fact it was in the previous slide[0] from that same talk. Thanks for pointing that out.<p>[0] <a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=1ZTJ9omXOQ0?t=1h8m19s" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=1ZTJ9omXOQ0?t=1h8m19s</a></div><br/></div></div></div></div></div></div></div></div><div id="40555787" class="c"><input type="checkbox" id="c-40555787" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40555270">prev</a><span>|</span><a href="#40555590">next</a><span>|</span><label class="collapse" for="c-40555787">[-]</label><label class="expand" for="c-40555787">[17 more]</label></div><br/><div class="children"><div class="content">Many of the criticisms are of the C++ standard library design and implementation rather than C++ the language per se, particularly with respect to undefined behavior. Much of this, in turn, is because the C++ standard library is very old and anything new added to it must be compatible and interoperable with all of the older parts, whether or not it is a good idea. Borrow checking is a separate matter.<p>Modern C++ provides all the tools to build an alternative standard library from the ground up with most behaviors and interactions being defined and safe. This always seemed like lower-hanging fruit for a first attempt than changing the language.<p>C++ is commonly used in contexts where object lifetimes and ownership are inherently unknowable at compile-time, safety can only be determined at runtime. This is why memory safety annotations like &#x27;std::launder&#x27; exist in C++. Trying force these cases into compile-time memory safety box is a source of much friction when using languages like Rust. They handle the 80% case where compile-time safety, destructive moves, etc make things easy for the developer but then significantly worsen the complexity, and therefore safety, of the other 20%. This isn&#x27;t necessarily a bad thing but it intrinsically creates a market for C++ which explicitly allows you to handle these cases in a reasonable way.<p>Systems programming is full of edge cases that break tidy programming language models. This has to be accommodated reasonably in languages that want to wear the mantle of &quot;systems language&quot;. Zig is an example of a new systems language that does this well in my opinion.</div><br/><div id="40556803" class="c"><input type="checkbox" id="c-40556803" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40555787">parent</a><span>|</span><a href="#40559181">next</a><span>|</span><label class="collapse" for="c-40556803">[-]</label><label class="expand" for="c-40556803">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Modern C++ provides all the tools to build an alternative standard library from the ground up with most behaviors and interactions being defined and safe.<p>It also goes to a great lenght to embed standard library into base language as deeply as it can, and forces unsafe constructs. Just see how many magic types from std namespace are emmited by compiler when you use range for, initializers, or, worst of all, coroutines. Lambdas with capture by reference replace old fashioned dangling pointers with much more modern dangling references (you are free to copy lambdas that reference local variables :smiling virus with thumbs-up emoji:).<p>There is no way to get &quot;another library&quot;, without making it not-c++. Those guys cannot even make no-exceptions&#x2F;no-rtti a part of the standard.</div><br/><div id="40558255" class="c"><input type="checkbox" id="c-40558255" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40556803">parent</a><span>|</span><a href="#40559181">next</a><span>|</span><label class="collapse" for="c-40558255">[-]</label><label class="expand" for="c-40558255">[5 more]</label></div><br/><div class="children"><div class="content">The dependence of C++ is one of the reasons I think C and C++ need a divorce.<p>Because while you&#x27;ll never be able to create a new standard lib for C++ it wouldn&#x27;t be hard for C.</div><br/><div id="40559224" class="c"><input type="checkbox" id="c-40559224" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40558255">parent</a><span>|</span><a href="#40559181">next</a><span>|</span><label class="collapse" for="c-40559224">[-]</label><label class="expand" for="c-40559224">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more like C++ made by that ISO committee and C++ used by actual users of C++ needs a divorce. They are so far up in the clouds adding features to language that mostly only help them to write less embarrasing standard library code, it hurts to watch sometimes.<p>Remember discussions that led to std::bit_cast? How absolutely everyone who processes binary data is wrong, because object of type, say, &quot;unsigned&quot; does not exist before it is created, so everyone casting pointers to parse packets is wrong, and only commitee is right?<p>It is doubly sad to see them claim compatibility to C (C++ is absolutely not compatible to C) as a reason for some features, or single pass compilation as a reason for others...<p>[edit]
To clarify, on one hand, a lot of terrible misfeatures are kept in the name of compatibility, e.g. &quot;int x = x;&quot; (&quot;fixing that will break too many existing exploits&quot;) or not being able to add friends without editing source (&quot;debugging? we think it is overrated&quot;), but then they go and proclaim basically all existing code that processes structured binary data as non-conformant.</div><br/><div id="40560043" class="c"><input type="checkbox" id="c-40560043" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40559224">parent</a><span>|</span><a href="#40559181">next</a><span>|</span><label class="collapse" for="c-40560043">[-]</label><label class="expand" for="c-40560043">[3 more]</label></div><br/><div class="children"><div class="content">&gt; a lot of terrible misfeatures are kept in the name of compatibility, e.g. &quot;int x = x;&quot; (&quot;fixing that will break too many existing exploits&quot;)<p>What does this code do? Is this referring to a previously defined x, now shadowed by a new x? Like this<p><pre><code>    int x = 1;
    int x = x;
</code></pre>
If yes, Rust has this feature too. And in Rust, shadowing variables is very idiomatic and is sometimes used to create safe abstractions.</div><br/><div id="40560138" class="c"><input type="checkbox" id="c-40560138" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40560043">parent</a><span>|</span><a href="#40559181">next</a><span>|</span><label class="collapse" for="c-40560138">[-]</label><label class="expand" for="c-40560138">[2 more]</label></div><br/><div class="children"><div class="content">No, it is referring to the x that is being initialized, and uses uninitialized memory to initialize x. -Wall will even print a helpful reminder. Compare:<p><pre><code>    int f(int x) {
        int x = x; &#x2F;&#x2F; second x is not argument
        return x;
    }
</code></pre>
and:<p><pre><code>    int f(int x){
        &#x2F;&#x2F; here second x is argument
        return [x=x] { return x; }();
    }</code></pre></div><br/><div id="40560465" class="c"><input type="checkbox" id="c-40560465" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40560138">parent</a><span>|</span><a href="#40559181">next</a><span>|</span><label class="collapse" for="c-40560465">[-]</label><label class="expand" for="c-40560465">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand, in the two cases there is a local x shadowing a function parameter also named x.. in the first case it is a local variable that shadows the parameter, in the second it&#x27;s a closure binding.<p>Are you sure that, in the first example, in int x = x, the local variable x doesn&#x27;t get initialized with the function parameter x, but rather gets initialized with itself (uninitialized memory)? Is this instant UB?<p>Is the second example actually legit, and initializes the closure bound variable with the x function parameter?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40559181" class="c"><input type="checkbox" id="c-40559181" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40555787">parent</a><span>|</span><a href="#40556803">prev</a><span>|</span><a href="#40557505">next</a><span>|</span><label class="collapse" for="c-40559181">[-]</label><label class="expand" for="c-40559181">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They handle the 80% case where compile-time safety, destructive moves, etc make things easy for the developer but then significantly worsen the complexity, and therefore safety, of the other 20%.<p>Thankfully we have actual data on this, not just random numbers, and no, this is not the case in practice.</div><br/></div></div><div id="40557505" class="c"><input type="checkbox" id="c-40557505" checked=""/><div class="controls bullet"><span class="by">roca</span><span>|</span><a href="#40555787">parent</a><span>|</span><a href="#40559181">prev</a><span>|</span><a href="#40556863">next</a><span>|</span><label class="collapse" for="c-40557505">[-]</label><label class="expand" for="c-40557505">[1 more]</label></div><br/><div class="children"><div class="content">The claim that Rust makes the safety of 20% of code worse requires some justification. It is utterly contradictory to my experience. Having to do a dynamic check (an array bounds check, or `Option::unwrap`) does not make code &quot;less safe&quot;.</div><br/></div></div><div id="40556863" class="c"><input type="checkbox" id="c-40556863" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#40555787">parent</a><span>|</span><a href="#40557505">prev</a><span>|</span><a href="#40556663">next</a><span>|</span><label class="collapse" for="c-40556863">[-]</label><label class="expand" for="c-40556863">[1 more]</label></div><br/><div class="children"><div class="content">See for example <a href="https:&#x2F;&#x2F;suslib.cc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;suslib.cc&#x2F;</a></div><br/></div></div><div id="40556663" class="c"><input type="checkbox" id="c-40556663" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40555787">parent</a><span>|</span><a href="#40556863">prev</a><span>|</span><a href="#40557271">next</a><span>|</span><label class="collapse" for="c-40556663">[-]</label><label class="expand" for="c-40556663">[1 more]</label></div><br/><div class="children"><div class="content">Zig is basically Modula-2 with a revamped syntax for C folks, plus compile time metaprogramming.<p>And yes, many of these issues were already solved by other system programming languages outside the UNIX linage of programming languages.</div><br/></div></div><div id="40557271" class="c"><input type="checkbox" id="c-40557271" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#40555787">parent</a><span>|</span><a href="#40556663">prev</a><span>|</span><a href="#40557158">next</a><span>|</span><label class="collapse" for="c-40557271">[-]</label><label class="expand" for="c-40557271">[4 more]</label></div><br/><div class="children"><div class="content">&gt; C++ is commonly used in contexts where object lifetimes and ownership are inherently unknowable at compile-time<p>What specific contexts are these?</div><br/><div id="40558526" class="c"><input type="checkbox" id="c-40558526" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40557271">parent</a><span>|</span><a href="#40557158">next</a><span>|</span><label class="collapse" for="c-40558526">[-]</label><label class="expand" for="c-40558526">[3 more]</label></div><br/><div class="children"><div class="content">For example, anything that pages live objects to disk from user space. This is a common feature of high-performance&#x2F;high-scale database engines and other data intensive software. Modern storage is larger than the addressable virtual memory supported by silicon so you can&#x27;t mmap() it, and even if you could you wouldn&#x27;t want to because using virtual memory is significantly slower than doing it from user space.<p>A single memory address can contain several unrelated live objects depending on when you look; a single live object can appear at different memory addresses over its lifetime without being moved; and live objects may not have a memory address at all. The hardware implicitly owns read and write references to these objects, which are not visible to the compiler and free to ignore the ownership model.<p>Consequently, you need a way to tell the compiler that the object it thinks exists at an address no longer does, and that object has neither been moved nor destroyed, and that there may be an unrelated object at that address that was never constructed. In these cases, compiler optimizations can generate incorrect code based on a naive analysis based on what is visible at compile-time. C++ provides ways to give this a defined behavior and indicate to the compiler when its lifetime model is incomplete so that it doesn&#x27;t produce incorrect code. You can build ownership models on top of this that incorporate ownership that is not visible at compile-time.<p>Some C++ devs don&#x27;t know these features exist, other C++ devs use them routinely. But the point is that C++ has specific features to address the case when lifetime analysis cannot be correctly done by the compiler.</div><br/><div id="40559216" class="c"><input type="checkbox" id="c-40559216" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40558526">parent</a><span>|</span><a href="#40560056">next</a><span>|</span><label class="collapse" for="c-40559216">[-]</label><label class="expand" for="c-40559216">[1 more]</label></div><br/><div class="children"><div class="content">Userspace-paged data is a tiny fraction of the amount of data that C++ programs, taken as a whole, process, and is a very weak argument for dropping static memory safety. Besides, because of unsafe, any Rust-like language, like Circle C++, will have the features needed to deal with such data too.</div><br/></div></div><div id="40560056" class="c"><input type="checkbox" id="c-40560056" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40558526">parent</a><span>|</span><a href="#40559216">prev</a><span>|</span><a href="#40557158">next</a><span>|</span><label class="collapse" for="c-40560056">[-]</label><label class="expand" for="c-40560056">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Modern storage is larger than the addressable virtual memory supported by silicon so you can&#x27;t mmap() it<p>Larger than the 48 bits address space of most 64 bits architectures?</div><br/></div></div></div></div></div></div><div id="40557158" class="c"><input type="checkbox" id="c-40557158" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#40555787">parent</a><span>|</span><a href="#40557271">prev</a><span>|</span><a href="#40555590">next</a><span>|</span><label class="collapse" for="c-40557158">[-]</label><label class="expand" for="c-40557158">[2 more]</label></div><br/><div class="children"><div class="content">I think the &quot;unknowable&quot; lifetimes are C++&#x27;s own making.<p>It&#x27;s like types in statically vs dynamically typed languages. Types  are unknowable at compile time when  the compiler doesn&#x27;t force them to be static.<p>And similarly ownership and lifetimes are &quot;dynamically typed&quot; in C++, because the compiler doesn&#x27;t force them to be rigidly declared like in Rust.</div><br/><div id="40557845" class="c"><input type="checkbox" id="c-40557845" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40555787">root</a><span>|</span><a href="#40557158">parent</a><span>|</span><a href="#40555590">next</a><span>|</span><label class="collapse" for="c-40557845">[-]</label><label class="expand" for="c-40557845">[1 more]</label></div><br/><div class="children"><div class="content">Unknowable lifetimes are a necessary evil. Rust has them too. It&#x27;s called RefCell. Without RefCell there are very useful things that are impossible to write in safe Rust.</div><br/></div></div></div></div></div></div><div id="40555590" class="c"><input type="checkbox" id="c-40555590" checked=""/><div class="controls bullet"><span class="by">geertj</span><span>|</span><a href="#40555787">prev</a><span>|</span><a href="#40558559">next</a><span>|</span><label class="collapse" for="c-40555590">[-]</label><label class="expand" for="c-40555590">[2 more]</label></div><br/><div class="children"><div class="content">First came across this 2 days ago and found this extremely impressive. There&#x27;s also a YouTube presentation where Sean goes over the main features of Circle&#x27;s C++ memory: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5Q1awoAwBgQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5Q1awoAwBgQ</a>.<p>This seems to be adding Rust borrow semantics and borrow checking to C++. The delivery vehicle seems to be a C++ compiler that the author has been working on for a number of of years. I couldn&#x27;t find a ton more on the background of this.<p>From a technical perspective this looks promising as a C++ successor language. The project will have to attract other members in the C++ community though.</div><br/><div id="40555733" class="c"><input type="checkbox" id="c-40555733" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#40555590">parent</a><span>|</span><a href="#40558559">next</a><span>|</span><label class="collapse" for="c-40555733">[-]</label><label class="expand" for="c-40555733">[1 more]</label></div><br/><div class="children"><div class="content">He’s active on the C++ Slack, regularly asking questions about the minutiae of the C++ spec. It seems like a massive headache.</div><br/></div></div></div></div><div id="40558559" class="c"><input type="checkbox" id="c-40558559" checked=""/><div class="controls bullet"><span class="by">_huayra_</span><span>|</span><a href="#40555590">prev</a><span>|</span><a href="#40558389">next</a><span>|</span><label class="collapse" for="c-40558559">[-]</label><label class="expand" for="c-40558559">[1 more]</label></div><br/><div class="children"><div class="content">Sean Baxter was on cppcast recently, highly recommend anyone interested to give it a listen: <a href="https:&#x2F;&#x2F;cppcast.com&#x2F;safe-borrow-checked-cpp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cppcast.com&#x2F;safe-borrow-checked-cpp&#x2F;</a></div><br/></div></div><div id="40558389" class="c"><input type="checkbox" id="c-40558389" checked=""/><div class="controls bullet"><span class="by">madebydouglas</span><span>|</span><a href="#40558559">prev</a><span>|</span><a href="#40556083">next</a><span>|</span><label class="collapse" for="c-40558389">[-]</label><label class="expand" for="c-40558389">[2 more]</label></div><br/><div class="children"><div class="content">It seems like if this can be the next version of C++ that would be a good thing, but if it&#x27;s just another C++ like language, such as Carbon (even with proposed benefits), aren&#x27;t we just going in circles here?<p>Wouldn&#x27;t a better approach be to instead focus on adding better C++ interop into Rust? Isn&#x27;t that a more forward thinking approach?<p>On that line of thinking, what about Swift and its C++ interop? Or is Swift not ready for systems level programming?</div><br/><div id="40558575" class="c"><input type="checkbox" id="c-40558575" checked=""/><div class="controls bullet"><span class="by">zer0zzz</span><span>|</span><a href="#40558389">parent</a><span>|</span><a href="#40556083">next</a><span>|</span><label class="collapse" for="c-40558575">[-]</label><label class="expand" for="c-40558575">[1 more]</label></div><br/><div class="children"><div class="content">&gt; On that line of thinking, what about Swift and its C++ interop? Or is Swift not ready for systems level programming?<p>A lot of swift behavior is dictated by the standard library. There have been Micro-Swift and embedded swift implementations to cut down overhead along with work on move only types.<p>I think swift could be a good candidate for a post-c++ language but despite the open community it is highly Apple dominated in its scope and direction. That’s probably my the biggest trouble with swift.</div><br/></div></div></div></div><div id="40556083" class="c"><input type="checkbox" id="c-40556083" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#40558389">prev</a><span>|</span><a href="#40556055">next</a><span>|</span><label class="collapse" for="c-40556083">[-]</label><label class="expand" for="c-40556083">[6 more]</label></div><br/><div class="children"><div class="content">Nice to see Sean cite Fil-C, though he does it much more in passing than it deserves, considering that Fil-C gives you memory-safe C and C++ without requiring any annotations whatsoever. He cites it as a sanitizer and references undefined behavior, which isn&#x27;t really how I would describe it (unlike a sanitizer, it catches all memory safety bugs, and also unlike a sanitizer, it turns a lot of what would have been UB in C++ into defined-but-safe behavior). It&#x27;s a very different approach from Sean&#x27;s.<p>For example, Circle implies broad overhaul to tooling and libraries while Fil-C implies no such thing. Also, Circle is all about not using existing compilers on the grounds that they are hard to experiment with, while Fil-C is a surgical change to clang&#x2F;LLVM.<p>The main advantage of Circle over Fil-C is that if you pay the cost of that overhaul, you&#x27;ll get performance that is better than what Fil-C could ever do even with a lot of optimization. Not obvious to me if that makes it net better, though.</div><br/><div id="40556365" class="c"><input type="checkbox" id="c-40556365" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40556083">parent</a><span>|</span><a href="#40556055">next</a><span>|</span><label class="collapse" for="c-40556365">[-]</label><label class="expand" for="c-40556365">[5 more]</label></div><br/><div class="children"><div class="content">For the performance, there are a <i>bunch</i> of people, some of them probably wrong and others definitely right, who believe they <i>need</i> the best possible performance from software.<p>You can sell these people something like Rust because you can very often either show why the &quot;better performance&quot; C++ they have is wrong (and if they wanted a <i>wrong</i> answer here&#x27;s zero already, pay me) or sometimes actually worse performance. Not every time, but often enough to make a real difference. The Circle safety feature should be in the same ballpark.<p>You can&#x27;t sell them anything that&#x27;s just anyway going to have worse performance, if you could they&#x27;d be writing Java already.  So that&#x27;s counting against Fil-C.</div><br/><div id="40556481" class="c"><input type="checkbox" id="c-40556481" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#40556083">root</a><span>|</span><a href="#40556365">parent</a><span>|</span><a href="#40556055">next</a><span>|</span><label class="collapse" for="c-40556481">[-]</label><label class="expand" for="c-40556481">[4 more]</label></div><br/><div class="children"><div class="content">Java is a totally different language, so it’s not even remotely a competitor in this space. Also Java is quite fast, even compared to C or Rust.<p>Fil-C is all about being able to run existing C&#x2F;C++ code that nobody is going to rewrite, not even in a dialect like Circle, since the burden of annotations will be too great.</div><br/><div id="40556878" class="c"><input type="checkbox" id="c-40556878" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#40556083">root</a><span>|</span><a href="#40556481">parent</a><span>|</span><a href="#40556055">next</a><span>|</span><label class="collapse" for="c-40556878">[-]</label><label class="expand" for="c-40556878">[3 more]</label></div><br/><div class="children"><div class="content">For existing C++ just using a checked std::vector and Boehm GC can get you quite a long way.</div><br/><div id="40556939" class="c"><input type="checkbox" id="c-40556939" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#40556083">root</a><span>|</span><a href="#40556878">parent</a><span>|</span><a href="#40556055">next</a><span>|</span><label class="collapse" for="c-40556939">[-]</label><label class="expand" for="c-40556939">[2 more]</label></div><br/><div class="children"><div class="content">Nowhere near to memory safety. There are so many exploits left on the table if you do what you say.<p>Not to mention that Boehm isn’t sound on modern C compilers. Conservative stack scanning can be foiled by optimizations that are valid from the compiler’s perspective.</div><br/><div id="40560333" class="c"><input type="checkbox" id="c-40560333" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#40556083">root</a><span>|</span><a href="#40556939">parent</a><span>|</span><a href="#40556055">next</a><span>|</span><label class="collapse" for="c-40560333">[-]</label><label class="expand" for="c-40560333">[1 more]</label></div><br/><div class="children"><div class="content">No, but it can be done without rewriting code. There&#x27;s a lot of C++ out there that was perhaps once performance sensitive but hasn&#x27;t been for years due to hardware improvements, or was perhaps never sensitive but used C++ just for team consistency etc. Windows is full of code like that for example. But, there&#x27;s no funding to rewrite it. For situations like that, things which boost safety but don&#x27;t require rewrites of any kind are waaaay under-rated.<p>Compilers should definitely have a mode that stops them breaking conservative stack scanning. GC is a drop-in fix for so many memory safety problems it&#x27;s a vital weapon in the toolbox. Combined with checked array and vector dereferences, you can get a <i>long</i> way without needing Rust or Circle style rewrites.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40556055" class="c"><input type="checkbox" id="c-40556055" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#40556083">prev</a><span>|</span><a href="#40555800">next</a><span>|</span><label class="collapse" for="c-40556055">[-]</label><label class="expand" for="c-40556055">[13 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s only one systems-level&#x2F;non-garbage collected language that provides rigorous memory safety. That&#x27;s the Rust language.<p>Honest question: what about Ada? It was specifically designed to be a safe language for critical systems, and for a while was mandated for some military systems. Did the author not consider it, or are its protections just not as expansive as Rust&#x27;s?</div><br/><div id="40556387" class="c"><input type="checkbox" id="c-40556387" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40556055">parent</a><span>|</span><a href="#40556448">next</a><span>|</span><label class="collapse" for="c-40556387">[-]</label><label class="expand" for="c-40556387">[10 more]</label></div><br/><div class="children"><div class="content">I’m not the author, but there’s a few reasons Ada tends to be forgotten in these discussions:<p>Back when Ada was new, people just didn’t actually like programming in it much. Some did, of course, but many did not. This is the reason the Ada Mandate was abandoned.<p>This led into a situation with a small, walled off community that didn’t really communicate with the outside world much. This has a compounding effect over time.<p>Ada, while designed for safety critical systems, was not actually memory safe until fairly recently. Deallocating memory at runtime wasn’t, and in my understanding, may only be in the presence of SPARK? Hopefully someone can chime in here. Now, that fine for the systems Ada tended to be used for, which often have either no dynamic allocation or a singular allocation at program startup, but for inspiration for other language designs, given that it forgoes a hard problem, it’s not really as useful to those who are trying to solve those problems. This doesn’t mean Ada is useless for inspiration, but for “how do I implement memory safety,” it doesn’t have many unique uses things to offer.<p>None of this means Ada is a bad language, but these are the main contributing factors that I see with regards to your specific question.</div><br/><div id="40556710" class="c"><input type="checkbox" id="c-40556710" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40556387">parent</a><span>|</span><a href="#40556448">next</a><span>|</span><label class="collapse" for="c-40556710">[-]</label><label class="expand" for="c-40556710">[9 more]</label></div><br/><div class="children"><div class="content">That is the usual Ada outdated image, just like unsafe code blocks in Rust, those Unchecked Deallocation are wrapped in safe calls, and since Ada95 there are controlled types, allowing for RAII patterns.<p>Additionally, it is common to use arenas, and many types can be dynamically stack allocated with a retry operation in case there is not enough space, so that the call can be redone with a smaller size.<p>Memory Management with Ada 2012 from FOSDEM 2016,<p><a href="https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2016&#x2F;schedule&#x2F;event&#x2F;ada_memory&#x2F;" rel="nofollow">https:&#x2F;&#x2F;archive.fosdem.org&#x2F;2016&#x2F;schedule&#x2F;event&#x2F;ada_memory&#x2F;</a><p>Doesn&#x27;t go much into SPARK related improvements though, given its date.</div><br/><div id="40557637" class="c"><input type="checkbox" id="c-40557637" checked=""/><div class="controls bullet"><span class="by">roca</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40556710">parent</a><span>|</span><a href="#40557527">next</a><span>|</span><label class="collapse" for="c-40557637">[-]</label><label class="expand" for="c-40557637">[2 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s affine types and borrow checking give safe Rust a lot more power than the safe subset of Ada95. A trivial getter method that returns a reference (i.e. pointer) to a field of its object is safe in Rust, but in Ada95 (and C++ and most other non-GC languages) in general you can&#x27;t ensure the object outlives the reference.<p>It is true that Ada has a safe suitable-for-systems-programming subset that&#x27;s much better than most languages. I think when people say &quot;Rust is the first safe systems programming language&quot; they implicitly mean &quot;that is expressive enough for me to replace C++ with&quot;.</div><br/><div id="40559780" class="c"><input type="checkbox" id="c-40559780" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40557637">parent</a><span>|</span><a href="#40557527">next</a><span>|</span><label class="collapse" for="c-40559780">[-]</label><label class="expand" for="c-40559780">[1 more]</label></div><br/><div class="children"><div class="content">Except we are into Ada 2022 nowadays, so SPARK is also part of the story.</div><br/></div></div></div></div><div id="40557527" class="c"><input type="checkbox" id="c-40557527" checked=""/><div class="controls bullet"><span class="by">roca</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40556710">parent</a><span>|</span><a href="#40557637">prev</a><span>|</span><a href="#40557447">next</a><span>|</span><label class="collapse" for="c-40557527">[-]</label><label class="expand" for="c-40557527">[2 more]</label></div><br/><div class="children"><div class="content">How does &quot;redo the call with a smaller size&quot; possibly help you? If you could get by with less memory, you should have asked for less memory in the first place.</div><br/><div id="40559789" class="c"><input type="checkbox" id="c-40559789" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40557527">parent</a><span>|</span><a href="#40557447">next</a><span>|</span><label class="collapse" for="c-40559789">[-]</label><label class="expand" for="c-40559789">[1 more]</label></div><br/><div class="children"><div class="content">For some types of applications, it is a doable use case, it is the same as asking how malloc() returning NULL helps.</div><br/></div></div></div></div><div id="40557447" class="c"><input type="checkbox" id="c-40557447" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40556710">parent</a><span>|</span><a href="#40557527">prev</a><span>|</span><a href="#40556448">next</a><span>|</span><label class="collapse" for="c-40557447">[-]</label><label class="expand" for="c-40557447">[4 more]</label></div><br/><div class="children"><div class="content">Sure, none of that is particularly novel though, so in terms of citing it as something specifically to add to the conversation, there isn&#x27;t any real reason.</div><br/><div id="40557526" class="c"><input type="checkbox" id="c-40557526" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40557447">parent</a><span>|</span><a href="#40556448">next</a><span>|</span><label class="collapse" for="c-40557526">[-]</label><label class="expand" for="c-40557526">[3 more]</label></div><br/><div class="children"><div class="content">It was the article author&#x27;s choice to specifically say there is no safe systems programming language other than Rust. If that is not true then it&#x27;s worth citing in discussion of the article.</div><br/><div id="40557638" class="c"><input type="checkbox" id="c-40557638" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40557526">parent</a><span>|</span><a href="#40556448">next</a><span>|</span><label class="collapse" for="c-40557638">[-]</label><label class="expand" for="c-40557638">[2 more]</label></div><br/><div class="children"><div class="content">My parent confirmed that deallocating memory is still unsafe, even though there are common usage patterns that help make sure you&#x27;re doing it correctly.</div><br/><div id="40559797" class="c"><input type="checkbox" id="c-40559797" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40557638">parent</a><span>|</span><a href="#40556448">next</a><span>|</span><label class="collapse" for="c-40559797">[-]</label><label class="expand" for="c-40559797">[1 more]</label></div><br/><div class="children"><div class="content">Just like using double linked lists in Rust is unsafe, unless special libraries are used, this is no different.<p>Also we aren&#x27;t talking about Ada83 any longer.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40556448" class="c"><input type="checkbox" id="c-40556448" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40556055">parent</a><span>|</span><a href="#40556387">prev</a><span>|</span><a href="#40555800">next</a><span>|</span><label class="collapse" for="c-40556448">[-]</label><label class="expand" for="c-40556448">[2 more]</label></div><br/><div class="children"><div class="content">Ada itself doesn&#x27;t provide you the same guarantees as Safe Rust. You can use SPARK to grant Ada more memory safety capabilities. However as a language (rather than comments which may or may not be ignored by your Ada compiler) SPARK is from 2014, so now we&#x27;re close to Rust&#x27;s age.<p>I assume that the totality of SPARK&#x27;s guarantees would get you to the same place as Rust but I don&#x27;t know.<p>A big thing which counts against Ada (and SPARK) in practice is that it&#x27;s not popular. You&#x27;ll trip over Rust programmers everywhere, two of my friends are getting paid to write Rust, for completely unrelated companies, unrelated reasons, Rust seems like a reasonable fit so those companies picked Rust. You don&#x27;t see that with Ada and SPARK.</div><br/><div id="40557983" class="c"><input type="checkbox" id="c-40557983" checked=""/><div class="controls bullet"><span class="by">cardanome</span><span>|</span><a href="#40556055">root</a><span>|</span><a href="#40556448">parent</a><span>|</span><a href="#40555800">next</a><span>|</span><label class="collapse" for="c-40557983">[-]</label><label class="expand" for="c-40557983">[1 more]</label></div><br/><div class="children"><div class="content">I think Ada not being very popular shows that the need for a memory safe non-garbage collected language is kind of overstated. If there was really that much of a need, people would have flocked to Ada despite its shortcomings.<p>Most people solved the safety problem a long time ago by switching to garbage collected languages. As times go on and garbage collector designs get better while hardware gets beefier you can get away with using a garbage collected language in more and more cases. Case in point golang marketing itself as a system programming language and succeeding, not to even mention even the game dev accepting C# these days.<p>To be clear, there is a niche and need for safe and non-garbadge collected languages and there will always be. I am just saying the niche is much smaller than people might think.<p>I think it is mistake for Rust evangelists to market safety of the killer-feature of the language. Rust is not popular because of the safety but because it lowered the barriers of entry for a new generation of system programmers by providing excellent tooling, error messages and a type system that take at least the lower hanging fruits of the academic functional world. That is all cool stuff beyond the safety circle jerk.</div><br/></div></div></div></div></div></div><div id="40555800" class="c"><input type="checkbox" id="c-40555800" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#40556055">prev</a><span>|</span><a href="#40556144">next</a><span>|</span><label class="collapse" for="c-40555800">[-]</label><label class="expand" for="c-40555800">[1 more]</label></div><br/><div class="children"><div class="content">I think a challenge to this evolution path is the same as what motivated Sutter’s cpp2: defaults<p>I think the premise that a lot of experienced programmers can write good C++ is at least somewhat valid. They know to not use raw pointers, which APIs to use for bound checking, whatever. The issue is that new users don’t, and the defaults are bad.<p>If I have to write #feature on safety in every file, it becomes possible to forget. Opting in vs opting out</div><br/></div></div><div id="40555670" class="c"><input type="checkbox" id="c-40555670" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40556144">prev</a><span>|</span><a href="#40557695">next</a><span>|</span><label class="collapse" for="c-40555670">[-]</label><label class="expand" for="c-40555670">[17 more]</label></div><br/><div class="children"><div class="content">Memory-safe languages are IMHO a distraction from making people write bug-free code.<p>There are much more important bugs than memory safety bugs, including all sorts of performance bugs.<p>We need to address the whole spectrum instead of compromising all areas in order to tackle niche bugs that only matter in security-critical contexts.</div><br/><div id="40555883" class="c"><input type="checkbox" id="c-40555883" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#40555670">parent</a><span>|</span><a href="#40555772">next</a><span>|</span><label class="collapse" for="c-40555883">[-]</label><label class="expand" for="c-40555883">[6 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t true in practice.<p>When you don&#x27;t have to worry about memory safety, your brain is freed up to worry about other kinds of bugs.<p>The other bit of good news is that the sorts of things Rust does to have memory safety also enable the systematic elimination of many other kinds of bugs. For example, iterator invalidation.</div><br/><div id="40557764" class="c"><input type="checkbox" id="c-40557764" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40555883">parent</a><span>|</span><a href="#40555772">next</a><span>|</span><label class="collapse" for="c-40557764">[-]</label><label class="expand" for="c-40557764">[5 more]</label></div><br/><div class="children"><div class="content">For example, the easiest way to make programs avoid use-after-free errors is to never free things.<p>Would you rather get a program that constantly use all of your RAM until you restart it, or one that consistently uses very little, but someone crashes in edge cases?</div><br/><div id="40557955" class="c"><input type="checkbox" id="c-40557955" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40557764">parent</a><span>|</span><a href="#40560266">next</a><span>|</span><label class="collapse" for="c-40557955">[-]</label><label class="expand" for="c-40557955">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d rather use a program that uses as little memory as possible and that also never crashes. With Rust you can just have both.</div><br/><div id="40560238" class="c"><input type="checkbox" id="c-40560238" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40557955">parent</a><span>|</span><a href="#40560266">next</a><span>|</span><label class="collapse" for="c-40560238">[-]</label><label class="expand" for="c-40560238">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not really what happens. Most Rust code actually does whatever is easiest to get the borrow checker to stop complaining, including extending lifetime beyond the scope that is necessary, and putting reference counting everywhere.</div><br/></div></div></div></div><div id="40560266" class="c"><input type="checkbox" id="c-40560266" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40557764">parent</a><span>|</span><a href="#40557955">prev</a><span>|</span><a href="#40555772">next</a><span>|</span><label class="collapse" for="c-40560266">[-]</label><label class="expand" for="c-40560266">[2 more]</label></div><br/><div class="children"><div class="content">Good luck not releasing stack frames.</div><br/><div id="40560472" class="c"><input type="checkbox" id="c-40560472" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40560266">parent</a><span>|</span><a href="#40555772">next</a><span>|</span><label class="collapse" for="c-40560472">[-]</label><label class="expand" for="c-40560472">[1 more]</label></div><br/><div class="children"><div class="content">Talked like somebody that doesn&#x27;t understand the stack at all.<p>On Linux, the stack grows automatically and never shrinks.</div><br/></div></div></div></div></div></div></div></div><div id="40555772" class="c"><input type="checkbox" id="c-40555772" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40555670">parent</a><span>|</span><a href="#40555883">prev</a><span>|</span><a href="#40555838">next</a><span>|</span><label class="collapse" for="c-40555772">[-]</label><label class="expand" for="c-40555772">[2 more]</label></div><br/><div class="children"><div class="content">It’s not true that memory safety bugs only matter in security-critical contexts. If a program segfaults, it’s going to make the user unhappy regardless of security implications.</div><br/><div id="40555846" class="c"><input type="checkbox" id="c-40555846" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40555772">parent</a><span>|</span><a href="#40555838">next</a><span>|</span><label class="collapse" for="c-40555846">[-]</label><label class="expand" for="c-40555846">[1 more]</label></div><br/><div class="children"><div class="content">And don&#x27;t forget that a segfault is the lucky case in matters of memory safety bugs. I&#x27;ve worked on many memory safety bugs that manifested themselves by silently corrupting data.</div><br/></div></div></div></div><div id="40555838" class="c"><input type="checkbox" id="c-40555838" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#40555670">parent</a><span>|</span><a href="#40555772">prev</a><span>|</span><a href="#40556117">next</a><span>|</span><label class="collapse" for="c-40555838">[-]</label><label class="expand" for="c-40555838">[1 more]</label></div><br/><div class="children"><div class="content">What kind of niche bugs are you speaking of?<p>For what it&#x27;s worth, Rust (and other languages of ML heritage) are really good at getting rid of huge categories of bugs, not just memory. Not all bugs, of course.</div><br/></div></div><div id="40556117" class="c"><input type="checkbox" id="c-40556117" checked=""/><div class="controls bullet"><span class="by">panstromek</span><span>|</span><a href="#40555670">parent</a><span>|</span><a href="#40555838">prev</a><span>|</span><a href="#40557296">next</a><span>|</span><label class="collapse" for="c-40556117">[-]</label><label class="expand" for="c-40556117">[1 more]</label></div><br/><div class="children"><div class="content">The term &quot;Memory safety&quot; also heavily undersells what it actually implies in Rust.</div><br/></div></div><div id="40557296" class="c"><input type="checkbox" id="c-40557296" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#40555670">parent</a><span>|</span><a href="#40556117">prev</a><span>|</span><a href="#40555812">next</a><span>|</span><label class="collapse" for="c-40557296">[-]</label><label class="expand" for="c-40557296">[2 more]</label></div><br/><div class="children"><div class="content">&gt; all sorts of performance bugs<p>A lot of code is written in safe, slow languages that could be written in a safe, fast language.</div><br/><div id="40560303" class="c"><input type="checkbox" id="c-40560303" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40557296">parent</a><span>|</span><a href="#40555812">next</a><span>|</span><label class="collapse" for="c-40560303">[-]</label><label class="expand" for="c-40560303">[1 more]</label></div><br/><div class="children"><div class="content">Making all vector accesses bounds-checked, as all memory-safe languages do, is a recipe for slow code.</div><br/></div></div></div></div><div id="40555812" class="c"><input type="checkbox" id="c-40555812" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#40555670">parent</a><span>|</span><a href="#40557296">prev</a><span>|</span><a href="#40557695">next</a><span>|</span><label class="collapse" for="c-40555812">[-]</label><label class="expand" for="c-40555812">[4 more]</label></div><br/><div class="children"><div class="content">Memory safety bugs are second only to segfaults in terms of importance.</div><br/><div id="40558709" class="c"><input type="checkbox" id="c-40558709" checked=""/><div class="controls bullet"><span class="by">vitiral</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40555812">parent</a><span>|</span><a href="#40556110">next</a><span>|</span><label class="collapse" for="c-40558709">[-]</label><label class="expand" for="c-40558709">[1 more]</label></div><br/><div class="children"><div class="content">Segfaults are a result of violating memory safety. They are the BEST case since you can actually detect the program yolo&#x27;d<p>Far worse is your program starts corrupting your data and suddenly you are executing a routine you had no intention of ever executing</div><br/></div></div><div id="40556110" class="c"><input type="checkbox" id="c-40556110" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40555812">parent</a><span>|</span><a href="#40558709">prev</a><span>|</span><a href="#40555868">next</a><span>|</span><label class="collapse" for="c-40556110">[-]</label><label class="expand" for="c-40556110">[1 more]</label></div><br/><div class="children"><div class="content">With an MMU, segfaults cause pretty abrupt and obvious failures for straying outside the heap or stack. Violating memory safety may cause subtle and unpredictable errors even in correct functions, which is a lot more dangerous.</div><br/></div></div><div id="40555868" class="c"><input type="checkbox" id="c-40555868" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#40555670">root</a><span>|</span><a href="#40555812">parent</a><span>|</span><a href="#40556110">prev</a><span>|</span><a href="#40557695">next</a><span>|</span><label class="collapse" for="c-40555868">[-]</label><label class="expand" for="c-40555868">[1 more]</label></div><br/><div class="children"><div class="content">In terms of the actual bugs encountered when developing modern C++ applications, logic bugs vastly outnumber segfaults and memory safety bugs, which are quite rare when you&#x27;re writing business logic.</div><br/></div></div></div></div></div></div><div id="40557695" class="c"><input type="checkbox" id="c-40557695" checked=""/><div class="controls bullet"><span class="by">roca</span><span>|</span><a href="#40555670">prev</a><span>|</span><a href="#40555196">next</a><span>|</span><label class="collapse" for="c-40557695">[-]</label><label class="expand" for="c-40557695">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an impressive project. One of the key problems for any safe language interoperating with C++ (even a safe C++ subset) is that you really want to be able to interact with C++ standard library types (string, vector etc) safely because they will appear at interface boundaries. Circle introduces its own safe standard library so I don&#x27;t see how Circle fares here.</div><br/></div></div><div id="40555196" class="c"><input type="checkbox" id="c-40555196" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#40557695">prev</a><span>|</span><a href="#40555760">next</a><span>|</span><label class="collapse" for="c-40555196">[-]</label><label class="expand" for="c-40555196">[4 more]</label></div><br/><div class="children"><div class="content">Haven’t read through it in enough detail yet to fully understand the language changes, but the authors are absolutely correct on some basic background that other folks don’t always understand:<p>&gt; Memory-safe languages are predicated on a basic observation of human nature: people would rather try something, and only then ask for help if it doesn&#x27;t work. For programming, this means developers try to use a library, and only then read the docs if they can&#x27;t get it to work. This has proven very dangerous, since appearing to work is not the same as working.<p>100% 100% 100%</div><br/><div id="40555437" class="c"><input type="checkbox" id="c-40555437" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40555196">parent</a><span>|</span><a href="#40555360">next</a><span>|</span><label class="collapse" for="c-40555437">[-]</label><label class="expand" for="c-40555437">[1 more]</label></div><br/><div class="children"><div class="content">You already wrote &quot;100%&quot; enough times, so I&#x27;ll add that Rust&#x27;s technology, and Rust&#x27;s culture, still aren&#x27;t enough, you have to really put the work in counteract this very powerful danger. Rust&#x27;s technology + culture should mean you won&#x27;t blow your foot off with this (entirely human) approach in their language, but you can definitely give yourself a nasty splinter, destroy your customer&#x27;s data, and a million other dumb things.<p>For example Rust provides types like core::cmp::Ordering,  core::time::Duration and  core::ops::ControlFlow  so sometimes your API will be harder to misuse than in might have been because you know, your timeout parameter was a Duration, not an integer count of seconds (or was it milliseconds?)<p>But, although eventually Clippy will express doubts, Rust won&#x27;t force you to rewrite that function which took N booleans and now after modification takes N+1 booleans, even though all your callers are probably a mess of true, false, true, true, false undecipherable flag nonsense and a re-factor was called for.<p>It&#x27;s surprisingly hard to give new programmers the right instincts on this stuff. I&#x27;m pretty sure I was terrible (thirty years ago) too, so this isn&#x27;t a humble brag it&#x27;s just an observation.</div><br/></div></div><div id="40555360" class="c"><input type="checkbox" id="c-40555360" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40555196">parent</a><span>|</span><a href="#40555437">prev</a><span>|</span><a href="#40555760">next</a><span>|</span><label class="collapse" for="c-40555360">[-]</label><label class="expand" for="c-40555360">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an elegant sentence but it&#x27;s incorrect to say memory save languages are predicated on that? Even a room full of C++ experts who understand this completely and write their code strictly based on formal contracts will still eventually write memory bugs.<p>Memory safe languages are just predicated on the memory-safety problem being difficult to avoid for humans, because nobody has a 0% error rate. They would still be incredibly necessary and relevant even if nobody relied on &quot;appears to work&quot; as the measure of correctness.</div><br/><div id="40557324" class="c"><input type="checkbox" id="c-40557324" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#40555196">root</a><span>|</span><a href="#40555360">parent</a><span>|</span><a href="#40555760">next</a><span>|</span><label class="collapse" for="c-40557324">[-]</label><label class="expand" for="c-40557324">[1 more]</label></div><br/><div class="children"><div class="content">I think the point is that Rust encodes more rules in its interfaces (ownership, lifetimes, thread safety). If you misunderstand how a Rust library works, your code most likely won&#x27;t compile instead of silently causing UB.<p>The rules for safe interfaces are the same for all Rust programs, so users know what to expect. Whereas in C++ the library author has more to say what usage is supported and what isn&#x27;t (e.g. Rust requires all globals to be thread-safe unconditionally, but a C++ library may say it&#x27;s thread safe if you set a config option or it&#x27;s your problem to synchronize access).</div><br/></div></div></div></div></div></div><div id="40555760" class="c"><input type="checkbox" id="c-40555760" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#40555196">prev</a><span>|</span><a href="#40555203">next</a><span>|</span><label class="collapse" for="c-40555760">[-]</label><label class="expand" for="c-40555760">[1 more]</label></div><br/><div class="children"><div class="content">This sounds a lot like C++&#x2F;CLI which has Microsoft backing and has a whole .NET sub language.<p>The problem was even when written together the impedance mismatch existed.</div><br/></div></div><div id="40555203" class="c"><input type="checkbox" id="c-40555203" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#40555760">prev</a><span>|</span><a href="#40555825">next</a><span>|</span><label class="collapse" for="c-40555203">[-]</label><label class="expand" for="c-40555203">[25 more]</label></div><br/><div class="children"><div class="content">Also, check out Google&#x27;s in-development Carbon Language, designed to address the same issues with a Kotlin-like approach. It&#x27;s an entirely new language that could interoperate with existing C++ code&#x2F;library.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang</a></div><br/><div id="40557882" class="c"><input type="checkbox" id="c-40557882" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40555203">parent</a><span>|</span><a href="#40555275">next</a><span>|</span><label class="collapse" for="c-40557882">[-]</label><label class="expand" for="c-40557882">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced Carbon will become popular at all. I was a Google employee when it was first announced and even internally the project was shrouded in secrecy because there was a ton of resistance. Google employees who cared about safety wanted to write Rust.</div><br/><div id="40558457" class="c"><input type="checkbox" id="c-40558457" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40557882">parent</a><span>|</span><a href="#40555275">next</a><span>|</span><label class="collapse" for="c-40558457">[-]</label><label class="expand" for="c-40558457">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t a memory-safe language subset one of their long term goals?</div><br/></div></div></div></div><div id="40555275" class="c"><input type="checkbox" id="c-40555275" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#40555203">parent</a><span>|</span><a href="#40557882">prev</a><span>|</span><a href="#40555825">next</a><span>|</span><label class="collapse" for="c-40555275">[-]</label><label class="expand" for="c-40555275">[22 more]</label></div><br/><div class="children"><div class="content">Does Carbon have any undefined behavior? Some of the wording in their goals document suggests that they do&#x2F;will, but it isn&#x27;t clear to me.</div><br/><div id="40556634" class="c"><input type="checkbox" id="c-40556634" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555275">parent</a><span>|</span><a href="#40555449">next</a><span>|</span><label class="collapse" for="c-40556634">[-]</label><label class="expand" for="c-40556634">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that if you want a high level of semantic compatibility with C++, a certain degree of UB is quite hard to avoid. But at least unlike C++, they prefer not to leave 100s of different possibilities on the table.</div><br/></div></div><div id="40555449" class="c"><input type="checkbox" id="c-40555449" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555275">parent</a><span>|</span><a href="#40556634">prev</a><span>|</span><a href="#40555825">next</a><span>|</span><label class="collapse" for="c-40555449">[-]</label><label class="expand" for="c-40555449">[20 more]</label></div><br/><div class="children"><div class="content">Unless you solve the halting problem, every language has undefined behavior.</div><br/><div id="40555782" class="c"><input type="checkbox" id="c-40555782" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555449">parent</a><span>|</span><a href="#40556261">next</a><span>|</span><label class="collapse" for="c-40555782">[-]</label><label class="expand" for="c-40555782">[1 more]</label></div><br/><div class="children"><div class="content">That’s not true. The halting problem &#x2F; Rice’s theorem only mean that the behavior can’t be statically determined by the compiler, not that it’s undefined.</div><br/></div></div><div id="40556261" class="c"><input type="checkbox" id="c-40556261" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555449">parent</a><span>|</span><a href="#40555782">prev</a><span>|</span><a href="#40555532">next</a><span>|</span><label class="collapse" for="c-40556261">[-]</label><label class="expand" for="c-40556261">[1 more]</label></div><br/><div class="children"><div class="content">C++ has a specific definition of UB. Most languages don&#x27;t suffer from it, regardless of halting problem.</div><br/></div></div><div id="40555532" class="c"><input type="checkbox" id="c-40555532" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555449">parent</a><span>|</span><a href="#40556261">prev</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40555532">[-]</label><label class="expand" for="c-40555532">[12 more]</label></div><br/><div class="children"><div class="content">Nope.<p>A language which has <i>semantic requirements</i> and isn&#x27;t willing to reject programs for which it has been unable to determine whether they meet the requirements, will have these cases by Rice&#x27;s Theorem. This is why C++ is a complete disaster. C++ <i>specifically</i> does not allow the compiler to reject such programs.<p>You can defuse this like (safe) Rust by just writing conservative checking. You will reject some programs you would like to have successfully compiled, but that&#x27;s actually OK, programmers who hate it are inspired to improve the checking, that&#x27;s what Rust&#x27;s &quot;Non-Lexical Lifetimes&quot; - mentioned by Sean, are about.<p>Even more radically, you can be a Special Purpose language and just only allow a relatively small subset of possible programs, all of which you know are correct, that&#x27;s why WUFFS gets to emit indexing with no runtime bounds miss checks - it did all the bounds checks at compile time, all source where that wouldn&#x27;t be possible isn&#x27;t legal WUFFS code.</div><br/><div id="40555738" class="c"><input type="checkbox" id="c-40555738" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555532">parent</a><span>|</span><a href="#40556268">next</a><span>|</span><label class="collapse" for="c-40555738">[-]</label><label class="expand" for="c-40555738">[1 more]</label></div><br/><div class="children"><div class="content">I suppose you can make that assertion by moving the goalposts.  But Rice&#x27;s theorem specifically addresses such behavior: all turing machines are inherently undecidable for all but trivial cases.<p>You can well argue that Rust may be <i>better</i> than C++ in some dimension, just as others can argue that those qualities have an unreasonable or intractable cost (note that about 20% of all crates resort to `unsafe`).  But your blanket assertion is not even supported by the reference you made.<p>Also the user is free to tell a C++ compiler to reject programs that use many sorts of undefined behavior, though indeed nobody would claim that any current compiler can identify <i>all</i> such cases.  But Rice&#x27;s theorem says that no Rust compiler could either.</div><br/></div></div><div id="40556268" class="c"><input type="checkbox" id="c-40556268" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555532">parent</a><span>|</span><a href="#40555738">prev</a><span>|</span><a href="#40555710">next</a><span>|</span><label class="collapse" for="c-40556268">[-]</label><label class="expand" for="c-40556268">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but it seems that we can&#x27;t satisfy all reasonable real-world use cases this way, or else Rust wouldn&#x27;t have the &quot;unsafe&quot; escape hatch that&#x27;s actually used by real code.</div><br/></div></div><div id="40555710" class="c"><input type="checkbox" id="c-40555710" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555532">parent</a><span>|</span><a href="#40556268">prev</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40555710">[-]</label><label class="expand" for="c-40555710">[9 more]</label></div><br/><div class="children"><div class="content">That is incorrect. A C++ compiler is perfectly allowed to reject any program that contains undefined behaviour.<p>It&#x27;s just not required to do so.</div><br/><div id="40555797" class="c"><input type="checkbox" id="c-40555797" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555710">parent</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40555797">[-]</label><label class="expand" for="c-40555797">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s allowed to reject programs that will evaluate an undefined operation on every possible execution. This is pretty much impossible, so no compiler even attempts this.</div><br/><div id="40556478" class="c"><input type="checkbox" id="c-40556478" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555797">parent</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40556478">[-]</label><label class="expand" for="c-40556478">[7 more]</label></div><br/><div class="children"><div class="content">It can replace any path with undefined behaviour to one that does std::abort.</div><br/><div id="40560292" class="c"><input type="checkbox" id="c-40560292" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40556478">parent</a><span>|</span><a href="#40556723">next</a><span>|</span><label class="collapse" for="c-40560292">[-]</label><label class="expand" for="c-40560292">[1 more]</label></div><br/><div class="children"><div class="content">Which is very different from diagnosing at compile time.</div><br/></div></div><div id="40556723" class="c"><input type="checkbox" id="c-40556723" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40556478">parent</a><span>|</span><a href="#40560292">prev</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40556723">[-]</label><label class="expand" for="c-40556723">[5 more]</label></div><br/><div class="children"><div class="content">It can, but in practice no one does it.</div><br/><div id="40557437" class="c"><input type="checkbox" id="c-40557437" checked=""/><div class="controls bullet"><span class="by">majoe</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40556723">parent</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40557437">[-]</label><label class="expand" for="c-40557437">[4 more]</label></div><br/><div class="children"><div class="content">When you think about it, that&#x27;s what -fsanitize=undefined is doing. It detects undefined behaviour at runtime and aborts the program.</div><br/><div id="40560289" class="c"><input type="checkbox" id="c-40560289" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40557437">parent</a><span>|</span><a href="#40560322">prev</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40560289">[-]</label><label class="expand" for="c-40560289">[2 more]</label></div><br/><div class="children"><div class="content">It detects some, but not all UBs. AFAIK it can&#x27;t detect UB due to hnsequenced access to the same variable.</div><br/><div id="40560455" class="c"><input type="checkbox" id="c-40560455" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40560289">parent</a><span>|</span><a href="#40556499">next</a><span>|</span><label class="collapse" for="c-40560455">[-]</label><label class="expand" for="c-40560455">[1 more]</label></div><br/><div class="children"><div class="content">There are different sanitizers that detect different types of UB.<p>Asan, Msan, Tsan and UBSan all detects different ones.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40556499" class="c"><input type="checkbox" id="c-40556499" checked=""/><div class="controls bullet"><span class="by">Asooka</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40555449">parent</a><span>|</span><a href="#40555532">prev</a><span>|</span><a href="#40555825">next</a><span>|</span><label class="collapse" for="c-40556499">[-]</label><label class="expand" for="c-40556499">[5 more]</label></div><br/><div class="children"><div class="content">No? The CPU doesn&#x27;t have undefined behaviour, thus any code running on it doesn&#x27;t have undefined behaviour either. There are certain operations whose result is not defined in certain states, I think on Intel some SSE operations had undefined results, but even then the same order of operations will lead to the same result. C&#x2F;C++ compilers generally let you turn off almost all possible undefined behaviour assumptions. I think the only one you can&#x27;t turn off is the assumption that a pointer to an object is properly aligned, which is understandable - if every pointer had to be checked for alignment before every access, it would ruin performance.<p>In general I would be much happier if I could assert to the compiler that my data fits certain parameters and it would optimise based on these explicit assertions rather than on implicit assumptions (undefined behaviour). Those assertions could be turned off in the final build if we determine they actually impact performance, but I expect I&#x27;d be able to keep them on all the time.</div><br/><div id="40557177" class="c"><input type="checkbox" id="c-40557177" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40556499">parent</a><span>|</span><a href="#40557842">next</a><span>|</span><label class="collapse" for="c-40557177">[-]</label><label class="expand" for="c-40557177">[1 more]</label></div><br/><div class="children"><div class="content">CPUs do have undefined behavior.</div><br/></div></div><div id="40557842" class="c"><input type="checkbox" id="c-40557842" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40556499">parent</a><span>|</span><a href="#40557177">prev</a><span>|</span><a href="#40555825">next</a><span>|</span><label class="collapse" for="c-40557842">[-]</label><label class="expand" for="c-40557842">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The CPU doesn&#x27;t have undefined behaviour, thus any code running on it doesn&#x27;t have undefined behaviour either.<p>Have you read Rice’s theorem?  Every nontrivial program on a Turing machine (which has only defined behavior) is undecidable.</div><br/><div id="40560307" class="c"><input type="checkbox" id="c-40560307" checked=""/><div class="controls bullet"><span class="by">jaccobbo</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40557842">parent</a><span>|</span><a href="#40559558">next</a><span>|</span><label class="collapse" for="c-40560307">[-]</label><label class="expand" for="c-40560307">[1 more]</label></div><br/><div class="children"><div class="content">Real computers are not turing machines, they are FSMs.</div><br/></div></div><div id="40559558" class="c"><input type="checkbox" id="c-40559558" checked=""/><div class="controls bullet"><span class="by">Slyfox33</span><span>|</span><a href="#40555203">root</a><span>|</span><a href="#40557842">parent</a><span>|</span><a href="#40560307">prev</a><span>|</span><a href="#40555825">next</a><span>|</span><label class="collapse" for="c-40559558">[-]</label><label class="expand" for="c-40559558">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what c++ UB is.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40555825" class="c"><input type="checkbox" id="c-40555825" checked=""/><div class="controls bullet"><span class="by">ljlolel</span><span>|</span><a href="#40555203">prev</a><span>|</span><a href="#40555188">next</a><span>|</span><label class="collapse" for="c-40555825">[-]</label><label class="expand" for="c-40555825">[3 more]</label></div><br/><div class="children"><div class="content">Who is using Circle C++ in production?</div><br/><div id="40557248" class="c"><input type="checkbox" id="c-40557248" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40555825">parent</a><span>|</span><a href="#40555188">next</a><span>|</span><label class="collapse" for="c-40557248">[-]</label><label class="expand" for="c-40557248">[2 more]</label></div><br/><div class="children"><div class="content">There was once a time when nobody used C++ in production.</div><br/><div id="40557647" class="c"><input type="checkbox" id="c-40557647" checked=""/><div class="controls bullet"><span class="by">ljlolel</span><span>|</span><a href="#40555825">root</a><span>|</span><a href="#40557248">parent</a><span>|</span><a href="#40555188">next</a><span>|</span><label class="collapse" for="c-40557647">[-]</label><label class="expand" for="c-40557647">[1 more]</label></div><br/><div class="children"><div class="content">Sorry are you saying nobody is using Circle? Also it seems closed source?</div><br/></div></div></div></div></div></div><div id="40558107" class="c"><input type="checkbox" id="c-40558107" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#40555188">prev</a><span>|</span><a href="#40556389">next</a><span>|</span><label class="collapse" for="c-40558107">[-]</label><label class="expand" for="c-40558107">[3 more]</label></div><br/><div class="children"><div class="content">FALSE - this is so misleading - these statements imply that 68% to 70% of ALL SECURITY ISSUES are due to memory safety - that&#x27;s wrong and those quotes leave out the important context.<p>From the post:<p><pre><code>  Microsoft&#x27;s bug telemetry reveals that 70% of its vulnerabilities would be stopped by memory-safe programming languages.

  Google&#x27;s research has found 68% of 0day exploits are related to memory corruption.
</code></pre>
These sorts of false statements make people everywhere think that memory safety is a bigger issue than it is and that it impacts almost all application development which is completely wrong.</div><br/><div id="40558245" class="c"><input type="checkbox" id="c-40558245" checked=""/><div class="controls bullet"><span class="by">binarycrusader</span><span>|</span><a href="#40558107">parent</a><span>|</span><a href="#40556389">next</a><span>|</span><label class="collapse" for="c-40558245">[-]</label><label class="expand" for="c-40558245">[2 more]</label></div><br/><div class="children"><div class="content"><i>Disclaimer: Speaking only for myself.</i><p><pre><code>  memory safety is a bigger issue than it is and that it impacts almost all application development which is completely wrong.
</code></pre>
It specifically states that in the context of <i>vulnerabilities</i> so I&#x27;m not sure why it&#x27;s believed to be insufficiently qualifying.<p>With that said, while you&#x27;re right to question the precisions of statements, Google says the same for their own data:<p><a href="https:&#x2F;&#x2F;www.chromium.org&#x2F;Home&#x2F;chromium-security&#x2F;memory-safety&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.chromium.org&#x2F;Home&#x2F;chromium-security&#x2F;memory-safet...</a><p><i>Around 70% of our high severity security bugs are memory unsafety problems (that is, mistakes with C&#x2F;C++ pointers). Half of those are use-after-free bugs.</i><p>...so it&#x27;s not just Microsoft saying that.<p>You&#x27;ll also see this mentioned on Wikipedia:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety</a><p>Going farther, the numbers vary, sometimes even more:<p><a href="https:&#x2F;&#x2F;www.memorysafety.org&#x2F;docs&#x2F;memory-safety&#x2F;#how-common-are-memory-safety-vulnerabilities" rel="nofollow">https:&#x2F;&#x2F;www.memorysafety.org&#x2F;docs&#x2F;memory-safety&#x2F;#how-common-...</a><p><i>Extremely. A recent study found that 60-70% of vulnerabilities in iOS and macOS are memory safety vulnerabilities. Microsoft estimates that 70% of all vulnerabilities in their products over the last decade have been memory safety issues. Google estimated that 90% of Android vulnerabilities are memory safety issues. An analysis of 0-days that were discovered being exploited in the wild found that more than 80% of the exploited vulnerabilities were memory safety issues.</i><p>In short, I don&#x27;t think the context here will change most folks&#x27; interpretation of the results--nor do I think it should. Any network-connected device is inherently multi-user and the security of that device is only as effective as the least secure program executing on that device at a particular permission level.<p>I can think of very few applications today that don&#x27;t interact with a network in some way. In addition to that, my opinion is that most memory-safety issues that create vulnerabilities are also reliability issues. Secure applications are generally inherently more reliable applications.</div><br/><div id="40558968" class="c"><input type="checkbox" id="c-40558968" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#40558107">root</a><span>|</span><a href="#40558245">parent</a><span>|</span><a href="#40556389">next</a><span>|</span><label class="collapse" for="c-40558968">[-]</label><label class="expand" for="c-40558968">[1 more]</label></div><br/><div class="children"><div class="content">The full context is that MS and Google said these things - SPECIFICALLY about their compiled consumer applications.<p>NOT as a general statement about all security vulnerabilities.<p>So its false and wrong.</div><br/></div></div></div></div></div></div><div id="40556389" class="c"><input type="checkbox" id="c-40556389" checked=""/><div class="controls bullet"><span class="by">Asooka</span><span>|</span><a href="#40558107">prev</a><span>|</span><a href="#40555773">next</a><span>|</span><label class="collapse" for="c-40556389">[-]</label><label class="expand" for="c-40556389">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that last paragraph had to be so toxic. We&#x27;ve had enough toxic egos in this industry, we don&#x27;t need any more. I&#x27;ve never heard of this person before, but I do not think I wish to be part of his project.</div><br/></div></div><div id="40555773" class="c"><input type="checkbox" id="c-40555773" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#40556389">prev</a><span>|</span><a href="#40555458">next</a><span>|</span><label class="collapse" for="c-40555773">[-]</label><label class="expand" for="c-40555773">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite ironic that on a page about safety they use an if statement without {} braces:<p><pre><code>        if(x % 2)
          vec^.push_back(x);

        unsafe printf(&quot;%d\n&quot;, x);
</code></pre>
Skipping the braces for single line conditionals in C++ is a lazy practice that almost inevitably leads to bugs, like Apple&#x27;s famous goto fail bug: <a href="https:&#x2F;&#x2F;www.synopsys.com&#x2F;blogs&#x2F;software-security&#x2F;understanding-apple-goto-fail-vulnerability-2.html" rel="nofollow">https:&#x2F;&#x2F;www.synopsys.com&#x2F;blogs&#x2F;software-security&#x2F;understandi...</a> . While memory bugs are difficult to prevent, this particular class of logic bug can be eliminated entirely just by always remembering to write two {} around the statement, so a language concerned with correctness should promote such good practices.<p><pre><code>        if(x % 2){
          vec^.push_back(x);
        }</code></pre></div><br/><div id="40556238" class="c"><input type="checkbox" id="c-40556238" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#40555773">parent</a><span>|</span><a href="#40555864">next</a><span>|</span><label class="collapse" for="c-40556238">[-]</label><label class="expand" for="c-40556238">[1 more]</label></div><br/><div class="children"><div class="content">That feels like a I was learning how to program and this bit me and now I&#x27;m always scared of it type of bug. I&#x27;ve never seen it myself. But then again some of my friends complain about OCD coworkers that can&#x27;t not obsessively remove blank lines from code.<p>I have seen<p><pre><code>   for(size_t i=0; i&lt;n; i++);
       foo(i);

   if(a&gt;b);
     a=b;
</code></pre>
The famous goto bug was because the assholes had no tests for that module.</div><br/></div></div><div id="40555864" class="c"><input type="checkbox" id="c-40555864" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40555773">parent</a><span>|</span><a href="#40556238">prev</a><span>|</span><a href="#40555458">next</a><span>|</span><label class="collapse" for="c-40555864">[-]</label><label class="expand" for="c-40555864">[6 more]</label></div><br/><div class="children"><div class="content">This is nitpicking style, there are no real safety implications. Compilers will happily inform you if the parse is ambiguous or code is unreachable.</div><br/><div id="40555896" class="c"><input type="checkbox" id="c-40555896" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#40555773">root</a><span>|</span><a href="#40555864">parent</a><span>|</span><a href="#40555458">next</a><span>|</span><label class="collapse" for="c-40555896">[-]</label><label class="expand" for="c-40555896">[5 more]</label></div><br/><div class="children"><div class="content">If you write in this style then there&#x27;s the possibility that someone else (or yourself in future) will add a second line, like:<p><pre><code>        if(x % 2)
          vec^.push_back(x);
          do_something_else();
</code></pre>
under the mistaken assumption that the second line will also only run in the x % 2 case. People make mistakes, this particular one can happen, does happen, and has happened many times, and the compiler absolutely will not inform or warn you, because it doesn&#x27;t know you intended the second line to run in the same if statement as the first (because C++ isn&#x27;t whitespace sensitive). Is ruling out an entire class of bug really not worth the effort of just typing two more characters?</div><br/><div id="40556153" class="c"><input type="checkbox" id="c-40556153" checked=""/><div class="controls bullet"><span class="by">throwaway376512</span><span>|</span><a href="#40555773">root</a><span>|</span><a href="#40555896">parent</a><span>|</span><a href="#40556048">next</a><span>|</span><label class="collapse" for="c-40556153">[-]</label><label class="expand" for="c-40556153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and the compiler absolutely will not inform or warn you<p>False.<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Warning-Options.html#index-Wmisleading-indentation" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Warning-Options.html#inde...</a><p><a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;DiagnosticsReference.html#wmisleading-indentation" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;DiagnosticsReference.html#wmisle...</a></div><br/></div></div><div id="40556048" class="c"><input type="checkbox" id="c-40556048" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#40555773">root</a><span>|</span><a href="#40555896">parent</a><span>|</span><a href="#40556153">prev</a><span>|</span><a href="#40555458">next</a><span>|</span><label class="collapse" for="c-40556048">[-]</label><label class="expand" for="c-40556048">[3 more]</label></div><br/><div class="children"><div class="content">Indentation can be fixed with a code formatter in pre commit hook.</div><br/><div id="40556276" class="c"><input type="checkbox" id="c-40556276" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#40555773">root</a><span>|</span><a href="#40556048">parent</a><span>|</span><a href="#40555458">next</a><span>|</span><label class="collapse" for="c-40556276">[-]</label><label class="expand" for="c-40556276">[2 more]</label></div><br/><div class="children"><div class="content">Or even an on-save or (and more likely to prevent this kind of error in a large file) as-you-type feature in your IDE&#x2F;editor.</div><br/><div id="40556528" class="c"><input type="checkbox" id="c-40556528" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#40555773">root</a><span>|</span><a href="#40556276">parent</a><span>|</span><a href="#40555458">next</a><span>|</span><label class="collapse" for="c-40556528">[-]</label><label class="expand" for="c-40556528">[1 more]</label></div><br/><div class="children"><div class="content">Available autoformatting is great, but IIRC the Apple issue happened in an automatic merge.  Autoformatting would still help it be noticed, when someone wondered why the formatter changed some bit of the code they hadn&#x27;t touched, but a formatting check in with the automated tests would catch it faster.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40555458" class="c"><input type="checkbox" id="c-40555458" checked=""/><div class="controls bullet"><span class="by">reynmorris</span><span>|</span><a href="#40555773">prev</a><span>|</span><a href="#40555515">next</a><span>|</span><label class="collapse" for="c-40555458">[-]</label><label class="expand" for="c-40555458">[7 more]</label></div><br/><div class="children"><div class="content">A lot of coders already do this. My STL replacement has Vector and VectorUnsafe. Vector is checked to the hilt for bounds safety, stack safety, UB safety, etc. and is slower. But if I have a tight loop, I can use VectorUnsafe and just make sure I&#x27;m being careful, and it has no checks at all.</div><br/><div id="40556094" class="c"><input type="checkbox" id="c-40556094" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#40555458">parent</a><span>|</span><a href="#40555515">next</a><span>|</span><label class="collapse" for="c-40556094">[-]</label><label class="expand" for="c-40556094">[6 more]</label></div><br/><div class="children"><div class="content">Care to share your Vector implementation that is &quot;stack safe&quot; and &quot;UB safe&quot;?</div><br/><div id="40556709" class="c"><input type="checkbox" id="c-40556709" checked=""/><div class="controls bullet"><span class="by">reynmorris</span><span>|</span><a href="#40555458">root</a><span>|</span><a href="#40556094">parent</a><span>|</span><a href="#40555515">next</a><span>|</span><label class="collapse" for="c-40556709">[-]</label><label class="expand" for="c-40556709">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s simple, whether the backing memory is heap or stack, it&#x27;s bounds checked. And overriding all the operators and only returning safe types prevents many types of undefined behavior.<p>Of course you can fuck with it enough to make it unsafe, but at that point you know exactly what you&#x27;re doing</div><br/><div id="40557113" class="c"><input type="checkbox" id="c-40557113" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40555458">root</a><span>|</span><a href="#40556709">parent</a><span>|</span><a href="#40557122">next</a><span>|</span><label class="collapse" for="c-40557113">[-]</label><label class="expand" for="c-40557113">[2 more]</label></div><br/><div class="children"><div class="content">Without seeing it, of course it&#x27;s hard to write examples, but typically for this type of thing it turns out that &quot;fucking with it&quot; enough to be unsafe is easy to do by mistake and so you end up basically saying resorting to classic C++ &quot;Nobody will make mistakes&quot; safety which we know doesn&#x27;t work.<p>In some cases you can even &quot;fuck with it&quot; less than std::vector and cause memory unsafety because std::vector was implemented by people who&#x27;ve been fucked with before, and this &quot;safe&quot; collection maybe was not. Pushing items from the collection itself into the collection again when it&#x27;s full is often one way to cause this - the std::vector promises this works correctly.</div><br/><div id="40557263" class="c"><input type="checkbox" id="c-40557263" checked=""/><div class="controls bullet"><span class="by">reynmorris</span><span>|</span><a href="#40555458">root</a><span>|</span><a href="#40557113">parent</a><span>|</span><a href="#40557122">next</a><span>|</span><label class="collapse" for="c-40557263">[-]</label><label class="expand" for="c-40557263">[1 more]</label></div><br/><div class="children"><div class="content">You can assume that the collection doesn&#x27;t have good coverage, but what I&#x27;m saying is the constructs in the C++ language are there to make it have good coverage. Pair this with some Clang sanitation (like banning raw pointers) and you&#x27;d have to go out of your way to make it unsafe.</div><br/></div></div></div></div><div id="40557122" class="c"><input type="checkbox" id="c-40557122" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40555458">root</a><span>|</span><a href="#40556709">parent</a><span>|</span><a href="#40557113">prev</a><span>|</span><a href="#40555515">next</a><span>|</span><label class="collapse" for="c-40557122">[-]</label><label class="expand" for="c-40557122">[2 more]</label></div><br/><div class="children"><div class="content">Does it stop you from writing code like this?<p><pre><code>    Vector&lt;int&gt; v {1, 2, 3};
    int *p = &amp;v[0];
    v.push_back(4);
    printf(&quot;%d\n&quot;, *p); &#x2F;&#x2F; this is UB</code></pre></div><br/><div id="40557192" class="c"><input type="checkbox" id="c-40557192" checked=""/><div class="controls bullet"><span class="by">reynmorris</span><span>|</span><a href="#40555458">root</a><span>|</span><a href="#40557122">parent</a><span>|</span><a href="#40555515">next</a><span>|</span><label class="collapse" for="c-40557192">[-]</label><label class="expand" for="c-40557192">[1 more]</label></div><br/><div class="children"><div class="content">That is not an issue with the safety of the Vector, it is an issue with the safety of &#x27;int&#x27; and raw pointers. If the Vector grows, that pointer points to freed memory.<p>But yes, in my implementation I have a safe version of int called &#x27;i32&#x27; which overrides the &amp; operator and doesn&#x27;t allow it to return raw pointers.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40555515" class="c"><input type="checkbox" id="c-40555515" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40555458">prev</a><span>|</span><label class="collapse" for="c-40555515">[-]</label><label class="expand" for="c-40555515">[6 more]</label></div><br/><div class="children"><div class="content">&gt; rust: rigorous memory safety<p>&gt; circle : unsafe printf<p>Comeon people, if you allow unsafety, you cannot call your language safe. There are safe system languages, but don&#x27;t lie and call unsafe languages safe.
Partial safety is not full safety.</div><br/><div id="40555650" class="c"><input type="checkbox" id="c-40555650" checked=""/><div class="controls bullet"><span class="by">wild_pointer</span><span>|</span><a href="#40555515">parent</a><span>|</span><label class="collapse" for="c-40555650">[-]</label><label class="expand" for="c-40555650">[5 more]</label></div><br/><div class="children"><div class="content">&gt; circle: rigorous memory safety<p>&gt; rust: unsafe { println!(&quot;{}&quot;, *r1); }<p>Comeon people, if you allow unsafety, you cannot call your language safe. There are safe system languages, but don&#x27;t lie and call unsafe languages safe. Partial safety is not full safety.</div><br/><div id="40556601" class="c"><input type="checkbox" id="c-40556601" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40555515">root</a><span>|</span><a href="#40555650">parent</a><span>|</span><a href="#40555965">next</a><span>|</span><label class="collapse" for="c-40556601">[-]</label><label class="expand" for="c-40556601">[1 more]</label></div><br/><div class="children"><div class="content">Notice that &quot;unsafe&quot; isn&#x27;t a magic &quot;off&quot; switch, it&#x27;s just super powers, things you would otherwise be forbidden from doing are now legal, but things you could have done before have the same behaviour - and if everything in an unsafe block doesn&#x27;t need super powers you&#x27;ll get a compiler warning saying the unsafe block you wrote was futile.<p>So, this only does anything interesting <i>if</i> r1 was a raw pointer so that dereferencing it would be prohibited without the unsafe block. If it&#x27;s just a reference or some smart pointer type then that&#x27;s fine anyway.</div><br/></div></div><div id="40555965" class="c"><input type="checkbox" id="c-40555965" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#40555515">root</a><span>|</span><a href="#40555650">parent</a><span>|</span><a href="#40556601">prev</a><span>|</span><label class="collapse" for="c-40555965">[-]</label><label class="expand" for="c-40555965">[3 more]</label></div><br/><div class="children"><div class="content">Unsafe in Rust is not unsafe in the same sense that C&#x2F;C++ UB is unsafe.<p>Unsafe in Rust means &quot;soundness cannot be statically verified, the language will insert runtime checks for you and perform a clearly defined action (panic) if they are violated&quot;.<p>Much ink has been spilled about &quot;unsafe&quot; in Rust being unfortunately named.</div><br/><div id="40556751" class="c"><input type="checkbox" id="c-40556751" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40555515">root</a><span>|</span><a href="#40555965">parent</a><span>|</span><a href="#40556072">next</a><span>|</span><label class="collapse" for="c-40556751">[-]</label><label class="expand" for="c-40556751">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unsafe in Rust is not unsafe in the same sense that C&#x2F;C++ UB is unsafe.  Unsafe in Rust means &quot;soundness cannot be statically verified<p>Right.<p>But as sibling points out, the rest of your sentence is incorrect.  The language mostly does not insert additional, runtime checks and you are allowed to create UB-level bad behavior in unsafe blocks.</div><br/></div></div><div id="40556072" class="c"><input type="checkbox" id="c-40556072" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#40555515">root</a><span>|</span><a href="#40555965">parent</a><span>|</span><a href="#40556751">prev</a><span>|</span><label class="collapse" for="c-40556072">[-]</label><label class="expand" for="c-40556072">[1 more]</label></div><br/><div class="children"><div class="content">No. No. And no.<p>&gt; It is the programmer&#x27;s responsibility when writing unsafe code to ensure that any safe code interacting with the unsafe code cannot trigger these behaviors.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;behavior-considered-undefined.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;behavior-considered-unde...</a><p>And they transverse<p>&gt; However, violations of these constraints generally will just transitively lead to one of the above problems.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;what-unsafe-does.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;what-unsafe-does.html</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>