<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725094866376" as="style"/><link rel="stylesheet" href="styles.css?v=1725094866376"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.youtube.com/watch?v=YzIiUjgnSsA">Language and shell in Go with 92% test coverage and instant CI/CD [video]</a> <span class="domain">(<a href="https://www.youtube.com">www.youtube.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>37 comments</span></div><br/><div><div id="41401556" class="c"><input type="checkbox" id="c-41401556" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41403229">next</a><span>|</span><label class="collapse" for="c-41401556">[-]</label><label class="expand" for="c-41401556">[17 more]</label></div><br/><div class="children"><div class="content">Hey, it&#x27;s my talk, AMA :)<p>If you&#x27;re interested in Elvish, you may also be interested in the talk on its design - <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wrl9foNXdgM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wrl9foNXdgM</a></div><br/><div id="41404014" class="c"><input type="checkbox" id="c-41404014" checked=""/><div class="controls bullet"><span class="by">zvolsky</span><span>|</span><a href="#41401556">parent</a><span>|</span><a href="#41404236">prev</a><span>|</span><a href="#41403399">next</a><span>|</span><label class="collapse" for="c-41404014">[-]</label><label class="expand" for="c-41404014">[8 more]</label></div><br/><div class="children"><div class="content">Hey, thanks again for the talk and for answering my fork bomb question with a live demo!</div><br/><div id="41404281" class="c"><input type="checkbox" id="c-41404281" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404014">parent</a><span>|</span><a href="#41403399">next</a><span>|</span><label class="collapse" for="c-41404281">[-]</label><label class="expand" for="c-41404281">[7 more]</label></div><br/><div class="children"><div class="content">Thanks for your question and glad that you enjoyed it!</div><br/><div id="41404675" class="c"><input type="checkbox" id="c-41404675" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404281">parent</a><span>|</span><a href="#41403399">next</a><span>|</span><label class="collapse" for="c-41404675">[-]</label><label class="expand" for="c-41404675">[6 more]</label></div><br/><div class="children"><div class="content">I thought you handled the question really well. To be honest the whole talk was excellent. I&#x27;m gutted I missed it in person.</div><br/><div id="41404845" class="c"><input type="checkbox" id="c-41404845" checked=""/><div class="controls bullet"><span class="by">heleninboodler</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404675">parent</a><span>|</span><a href="#41404702">next</a><span>|</span><label class="collapse" for="c-41404845">[-]</label><label class="expand" for="c-41404845">[2 more]</label></div><br/><div class="children"><div class="content">There were a lot of aspects of this talk that I thought were really great.  The willingness to try something unscripted, diving into the code repo live (e.g. to show where fuzzing is used), and the discussions of the reasoning behind the design choices.  Great job @xiaq.  This really makes me want to try elvish out, and I usually am quite skeptical of new shells.</div><br/><div id="41404916" class="c"><input type="checkbox" id="c-41404916" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404845">parent</a><span>|</span><a href="#41404702">next</a><span>|</span><label class="collapse" for="c-41404916">[-]</label><label class="expand" for="c-41404916">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Glad that the talk is working as a marketing pitch for Elvish :)</div><br/></div></div></div></div><div id="41404702" class="c"><input type="checkbox" id="c-41404702" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404675">parent</a><span>|</span><a href="#41404845">prev</a><span>|</span><a href="#41403399">next</a><span>|</span><label class="collapse" for="c-41404702">[-]</label><label class="expand" for="c-41404702">[3 more]</label></div><br/><div class="children"><div class="content">Thanks! Murex talk when??? :)</div><br/><div id="41404797" class="c"><input type="checkbox" id="c-41404797" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404702">parent</a><span>|</span><a href="#41403399">next</a><span>|</span><label class="collapse" for="c-41404797">[-]</label><label class="expand" for="c-41404797">[2 more]</label></div><br/><div class="children"><div class="content">haha I can&#x27;t present nearly as well as yourself but maybe one day.<p>It&#x27;s not easy to present though. I know on HN we see a lot of very clever people give some well executed presentations and it&#x27;s sometimes easy to forget how much preparation and courage it takes to perform like that. And it&#x27;s great to see how engaged people were with the content too.<p>Sorry, this is less of a question and more just comment of appreciation.</div><br/><div id="41404921" class="c"><input type="checkbox" id="c-41404921" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404797">parent</a><span>|</span><a href="#41403399">next</a><span>|</span><label class="collapse" for="c-41404921">[-]</label><label class="expand" for="c-41404921">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I appreciate the comment the appreciation :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41403399" class="c"><input type="checkbox" id="c-41403399" checked=""/><div class="controls bullet"><span class="by">HeralFacker</span><span>|</span><a href="#41401556">parent</a><span>|</span><a href="#41404014">prev</a><span>|</span><a href="#41405371">next</a><span>|</span><label class="collapse" for="c-41403399">[-]</label><label class="expand" for="c-41403399">[2 more]</label></div><br/><div class="children"><div class="content">Do you have a link to a copy of the video with captions?  YouTube autogen doesn&#x27;t cut it unfortunately.  Or perhaps a written-form version (slide deck + transcript)?<p>What&#x27;s in the 8% not covered by testing?</div><br/><div id="41403852" class="c"><input type="checkbox" id="c-41403852" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41403399">parent</a><span>|</span><a href="#41405371">next</a><span>|</span><label class="collapse" for="c-41403852">[-]</label><label class="expand" for="c-41403852">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a version with captions, sorry. You can find the slidedeck at <a href="https:&#x2F;&#x2F;github.com&#x2F;elves&#x2F;elvish&#x2F;blob&#x2F;master&#x2F;website&#x2F;slides&#x2F;2024-08-gophercon-uk.md">https:&#x2F;&#x2F;github.com&#x2F;elves&#x2F;elvish&#x2F;blob&#x2F;master&#x2F;website&#x2F;slides&#x2F;2...</a><p>The remaining 8% mostly falls into the following categories:<p>- Code that use OS functionalities that are cumbersome to mock in tests<p>- Code paths that are triggered relatively rarely and I was simply too lazy to add tests for them<p>Nothing is impossible to cover, but for whatever reason it was too much work for me when I wrote the code.<p>However, it&#x27;s worth mentioning that I only settled on the transcript test pattern fairly recently, and if I were to rewrite or refactor some of the untested code today I would add tests for them, because the cost of adding tests has been lowered considerably. So Elvish&#x27;s test coverage is still increasing slowly as the cost of testing decreases.</div><br/></div></div></div></div><div id="41405371" class="c"><input type="checkbox" id="c-41405371" checked=""/><div class="controls bullet"><span class="by">mpenick</span><span>|</span><a href="#41401556">parent</a><span>|</span><a href="#41403399">prev</a><span>|</span><a href="#41404983">next</a><span>|</span><label class="collapse" for="c-41405371">[-]</label><label class="expand" for="c-41405371">[2 more]</label></div><br/><div class="children"><div class="content">Does elvish have a command history limit? Or is it configurable? I like a nearly infinite history.</div><br/><div id="41405420" class="c"><input type="checkbox" id="c-41405420" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41405371">parent</a><span>|</span><a href="#41404983">next</a><span>|</span><label class="collapse" for="c-41405420">[-]</label><label class="expand" for="c-41405420">[1 more]</label></div><br/><div class="children"><div class="content">History entries are kept indefinitely.</div><br/></div></div></div></div><div id="41404983" class="c"><input type="checkbox" id="c-41404983" checked=""/><div class="controls bullet"><span class="by">0xdeadbeefbabe</span><span>|</span><a href="#41401556">parent</a><span>|</span><a href="#41405371">prev</a><span>|</span><a href="#41403229">next</a><span>|</span><label class="collapse" for="c-41404983">[-]</label><label class="expand" for="c-41404983">[3 more]</label></div><br/><div class="children"><div class="content">In vim vi or nvim :r !date gives me shell returned 2</div><br/><div id="41405024" class="c"><input type="checkbox" id="c-41405024" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41404983">parent</a><span>|</span><a href="#41403229">next</a><span>|</span><label class="collapse" for="c-41405024">[-]</label><label class="expand" for="c-41405024">[2 more]</label></div><br/><div class="children"><div class="content">Did you set your login shell to Elvish? Vim unfortunately relies on your shell being a POSIX shell, but you can fix that with &quot;set shell=&#x2F;bin&#x2F;sh&quot; in your rc file.</div><br/><div id="41405114" class="c"><input type="checkbox" id="c-41405114" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41401556">root</a><span>|</span><a href="#41405024">parent</a><span>|</span><a href="#41403229">next</a><span>|</span><label class="collapse" for="c-41405114">[-]</label><label class="expand" for="c-41405114">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, I&#x27;ve just added this instruction to <a href="https:&#x2F;&#x2F;elv.sh&#x2F;get&#x2F;default-shell.html#vim-&#x2F;-neovim" rel="nofollow">https:&#x2F;&#x2F;elv.sh&#x2F;get&#x2F;default-shell.html#vim-&#x2F;-neovim</a></div><br/></div></div></div></div></div></div></div></div><div id="41403229" class="c"><input type="checkbox" id="c-41403229" checked=""/><div class="controls bullet"><span class="by">throwaway2016a</span><span>|</span><a href="#41401556">prev</a><span>|</span><a href="#41402882">next</a><span>|</span><label class="collapse" for="c-41403229">[-]</label><label class="expand" for="c-41403229">[12 more]</label></div><br/><div class="children"><div class="content">This seems like a cool project.<p>This is meant as additional information not criticism. I skimmed the transcript really fast so if this is in there and I missed it, please correct me, but two things I think are helpful for people creating projects like this to be aware of:<p>- This video seems to combine the concepts of lexing and parsing. It is usually beneficial to separate these two steps and lex the input into tokens before passing to the parser.<p>- Go actually has a pure Go implementation of Yacc in the toolset and I&#x27;ve used it in several projects to make parses. Dealing with the Yacc file is often much easier than dealing with code directly since it takes care of writing the actual parser. There is a lot of boiler plate that goes into parsers that when you use Yacc it &quot;just works&quot;.<p>Edit: there are also some tools for writing parsers in Lex&#x2F;Flex like syntax (re2c comes to mind) but I&#x27;ve found hand writing lexers to be effective in Go if your language doesn&#x27;t have many different types of tokens.</div><br/><div id="41404279" class="c"><input type="checkbox" id="c-41404279" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41403229">parent</a><span>|</span><a href="#41407238">next</a><span>|</span><label class="collapse" for="c-41404279">[-]</label><label class="expand" for="c-41404279">[2 more]</label></div><br/><div class="children"><div class="content">Right, I may have forgot to mention that lexerless parsers are somewhat unusual.<p>I didn&#x27;t have much time in the talk to go into the reason, so here it is:<p>- You&#x27;ll need a more complex lexer to parse a shell-like syntax. For example, one common thing you do with lexers is get rid of whitespaces, but shell syntax is whitespace sensitive: &quot;a$x&quot; and &quot;a $x&quot; (double quotes not part of the code) are different things: the first is a single word containing a string concatenation, the second is two separate words.<p>- If your parser backtracks a lot, lexing can improve performance: you&#x27;re not going back characters, only tokens (and there are fewer tokens than characters). Elvish&#x27;s parser doesn&#x27;t backtrack. (It does use lookahead fairly liberally.)<p>Having a lexerless parser does mean that you have to constantly deal with whitespaces in every place though, and it can get a bit annoying. But personally I like the conceptual simplicity and not having to deal with silly tokens like LBRACE, LPAREN, PIPE.<p>I have not used parser generators enough to comment about the benefits of using them compared to writing a parser by hand. The handwritten one works well so far :)</div><br/><div id="41406019" class="c"><input type="checkbox" id="c-41406019" checked=""/><div class="controls bullet"><span class="by">throwaway2016a</span><span>|</span><a href="#41403229">root</a><span>|</span><a href="#41404279">parent</a><span>|</span><a href="#41407238">next</a><span>|</span><label class="collapse" for="c-41406019">[-]</label><label class="expand" for="c-41406019">[1 more]</label></div><br/><div class="children"><div class="content">That example you gave could certainly be done in Lex&#x2F;Flex and I assume other lexers&#x2F;tokenizers as well, for instance, you would probably use states and have &quot;$x&quot; in the initial state evaluate to a different token type than &quot;$x&quot; in the string state.<p>But I do get your meaning, I&#x27;ve written a lot of tokenizers by hand as well, sometimes they can be easier to follow the hand written code. Config files for grammars can get convoluted fast.<p>But again, I was not meaning it as criticism. But your talk title does start with &quot;How to write a programming language and shell in Go&quot; so given the title I think Lexers &#x2F; Tokenizers are worth noting.</div><br/></div></div></div></div><div id="41407238" class="c"><input type="checkbox" id="c-41407238" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41403229">parent</a><span>|</span><a href="#41404279">prev</a><span>|</span><a href="#41403636">next</a><span>|</span><label class="collapse" for="c-41407238">[-]</label><label class="expand" for="c-41407238">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This video seems to combine the concepts of lexing and parsing. It is usually beneficial to separate these two steps and lex the input into tokens before passing to the parser.<p>Historically, yes. In recent years combined lever-parsers have outperformed dedicated lexer + dedicated parser combinations, and with modern tooling this isn’t the janky mess it used to be. Some of the best tools out there are combined lexer-parsers.</div><br/></div></div><div id="41403636" class="c"><input type="checkbox" id="c-41403636" checked=""/><div class="controls bullet"><span class="by">ridiculous_fish</span><span>|</span><a href="#41403229">parent</a><span>|</span><a href="#41407238">prev</a><span>|</span><a href="#41406166">next</a><span>|</span><label class="collapse" for="c-41403636">[-]</label><label class="expand" for="c-41403636">[6 more]</label></div><br/><div class="children"><div class="content">Shells have somewhat unusual parsing requirements. For example &quot;if&quot; is a keyword when used as `if echo` but not `echo if`.<p>So you either need to implement the lexer hack, or have a &quot;string&quot; token type which is disambiguated by the parser (which is what fish-shell does).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lexer_hack" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lexer_hack</a></div><br/><div id="41405954" class="c"><input type="checkbox" id="c-41405954" checked=""/><div class="controls bullet"><span class="by">throwaway2016a</span><span>|</span><a href="#41403229">root</a><span>|</span><a href="#41403636">parent</a><span>|</span><a href="#41403678">next</a><span>|</span><label class="collapse" for="c-41405954">[-]</label><label class="expand" for="c-41405954">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s no problem in many modern lexers as they usually have a &quot;state&quot; so when you encounter &quot;echo&quot; you can switch to a new state and that state may have different token parsing rules. So &quot;if&quot; in the &quot;echo&quot; state could be a string literal whereas it may be a keyword in the initial state.<p>Lex&#x2F;Flex takes care of that mostly for you which is one of the benefits of using a well worn lexer generator and not rolling your own.</div><br/></div></div><div id="41403678" class="c"><input type="checkbox" id="c-41403678" checked=""/><div class="controls bullet"><span class="by">radiospiel</span><span>|</span><a href="#41403229">root</a><span>|</span><a href="#41403636">parent</a><span>|</span><a href="#41405954">prev</a><span>|</span><a href="#41406166">next</a><span>|</span><label class="collapse" for="c-41403678">[-]</label><label class="expand" for="c-41403678">[4 more]</label></div><br/><div class="children"><div class="content">unless i miss something this should not be an issue. the lexer could parse if as an IF token, and the parser could treat tags as STRING || IF ( || other keywords… )</div><br/><div id="41403706" class="c"><input type="checkbox" id="c-41403706" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41403229">root</a><span>|</span><a href="#41403678">parent</a><span>|</span><a href="#41403731">next</a><span>|</span><label class="collapse" for="c-41403706">[-]</label><label class="expand" for="c-41403706">[1 more]</label></div><br/><div class="children"><div class="content">That seems like it&#x27;d get really awkward pretty quickly. &quot;if&quot; isn&#x27;t unique in this regard; there are about a hundred shell builtins, and all of them can be used as an argument to a command. (For example, &quot;echo then complete command while true history&quot; is a valid shell command consisting entirely of names of builtins, and the only keyword in it is the leading &quot;echo&quot;.)</div><br/></div></div><div id="41403731" class="c"><input type="checkbox" id="c-41403731" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41403229">root</a><span>|</span><a href="#41403678">parent</a><span>|</span><a href="#41403706">prev</a><span>|</span><a href="#41404849">next</a><span>|</span><label class="collapse" for="c-41403731">[-]</label><label class="expand" for="c-41403731">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d have to `|| EVERY_KEYWORD_IN_LANG`, and then if you ever add a keyword, now you&#x27;re updating that list there, <i>and</i> anywhere else you&#x27;ve used it.<p>As the &quot;Lexer hack&quot; Wiki page says, this is only a problem if you&#x27;re lexing in the first place. If you just parse the grammar, this isn&#x27;t a problem.</div><br/></div></div><div id="41404849" class="c"><input type="checkbox" id="c-41404849" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41403229">root</a><span>|</span><a href="#41403678">parent</a><span>|</span><a href="#41403731">prev</a><span>|</span><a href="#41406166">next</a><span>|</span><label class="collapse" for="c-41404849">[-]</label><label class="expand" for="c-41404849">[1 more]</label></div><br/><div class="children"><div class="content">The problem lies with shells extensive usage of barewords. If you could eliminate the requirement for any bareword to be treated as a string then parsing shell code would then become much simpler...but also few people would want to use it because nobody wants to write the following in their interactive shell:<p><pre><code>    git &quot;commit&quot; &quot;-am&quot; &quot;message&quot;

    ls &quot;-l&quot;

 etc</code></pre></div><br/></div></div></div></div></div></div><div id="41406166" class="c"><input type="checkbox" id="c-41406166" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41403229">parent</a><span>|</span><a href="#41403636">prev</a><span>|</span><a href="#41402882">next</a><span>|</span><label class="collapse" for="c-41406166">[-]</label><label class="expand" for="c-41406166">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Dealing with the Yacc file is often much easier than dealing with code directly since it takes care of writing the actual parser. There is a lot of boiler plate that goes into parsers that when you use Yacc it &quot;just works&quot;.<p>Honestly, I think this is overstating the amount of boilerplate in a parser and overstating how well a parser generator &quot;just works&quot;. I haven&#x27;t used Yacc, so maybe it&#x27;s better than ANTLR, but having tried ANTLR and written a few recursive descent parsers I&#x27;ve been pretty well cured of wanting to ever use a parser generator. ANTLR&#x27;s generated code is verbose, the data structures are hard to work with, and error handling leaves a lot to be desired.<p>Parser boilerplate can be reduced to a large extent with a good set of helper methods (I often find myself referring back to the set used in Crafting Interpreters [0]), and what you get in exchange is full control over the data structure generated by the parser and over the error handling. For a language that you&#x27;re serious about, that tradeoff is totally worth it.<p>[0] <a href="http:&#x2F;&#x2F;craftinginterpreters.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;craftinginterpreters.com&#x2F;</a></div><br/><div id="41406261" class="c"><input type="checkbox" id="c-41406261" checked=""/><div class="controls bullet"><span class="by">pianoben</span><span>|</span><a href="#41403229">root</a><span>|</span><a href="#41406166">parent</a><span>|</span><a href="#41402882">next</a><span>|</span><label class="collapse" for="c-41406261">[-]</label><label class="expand" for="c-41406261">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s just my skill level, but I&#x27;ve used both hand-rolled recursive-descent and ANTLR for the same project (Thrift parser), and hoo boy I would <i>never</i> go back to recursive-descent for that.  ANTLR shrank my code by an order of magnitude, and cleaned up some bugs too.<p>I&#x27;d be willing to believe that beyond a certain level of input complexity, ANTLR no longer pays for itself.  In my experience, there exists a class of languages for which there&#x27;s no better tool.</div><br/></div></div></div></div></div></div><div id="41402882" class="c"><input type="checkbox" id="c-41402882" checked=""/><div class="controls bullet"><span class="by">cdcarter</span><span>|</span><a href="#41403229">prev</a><span>|</span><a href="#41402415">next</a><span>|</span><label class="collapse" for="c-41402882">[-]</label><label class="expand" for="c-41402882">[3 more]</label></div><br/><div class="children"><div class="content">Do you have any written posts or documents about this language and your design decisions?</div><br/><div id="41403255" class="c"><input type="checkbox" id="c-41403255" checked=""/><div class="controls bullet"><span class="by">whereistimbo</span><span>|</span><a href="#41402882">parent</a><span>|</span><a href="#41404151">next</a><span>|</span><label class="collapse" for="c-41403255">[-]</label><label class="expand" for="c-41403255">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;elv.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;elv.sh&#x2F;</a></div><br/></div></div><div id="41404151" class="c"><input type="checkbox" id="c-41404151" checked=""/><div class="controls bullet"><span class="by">xiaq</span><span>|</span><a href="#41402882">parent</a><span>|</span><a href="#41403255">prev</a><span>|</span><a href="#41402415">next</a><span>|</span><label class="collapse" for="c-41404151">[-]</label><label class="expand" for="c-41404151">[1 more]</label></div><br/><div class="children"><div class="content">I gave a talk about the design: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wrl9foNXdgM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wrl9foNXdgM</a><p>As the sibling comment mentioned, you can find documentation on Elvish itself on the website <a href="https:&#x2F;&#x2F;elv.sh" rel="nofollow">https:&#x2F;&#x2F;elv.sh</a>. There are tutorials and (not 100% but fairly complete) reference documents.</div><br/></div></div></div></div></div></div></div></div></div></body></html>