<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710493274638" as="style"/><link rel="stylesheet" href="styles.css?v=1710493274638"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://go.dev/blog/execution-traces-2024">More powerful Go execution traces</a> <span class="domain">(<a href="https://go.dev">go.dev</a>)</span></div><div class="subtext"><span>nalgeon</span> | <span>49 comments</span></div><br/><div><div id="39710822" class="c"><input type="checkbox" id="c-39710822" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#39713285">next</a><span>|</span><label class="collapse" for="c-39710822">[-]</label><label class="expand" for="c-39710822">[5 more]</label></div><br/><div class="children"><div class="content">This is really amazing! I look forward to giving it a try. Kudos to the Go team and contributors.<p>Say what you will about the language itself, the Go stdlib is one of the most useful and pleasant standard libraries I&#x27;ve ever worked with. It gets better with every release, and great care is taken to make it featureful, performant and well documented. These days for most general things I rarely have the need to reach for an external package.</div><br/><div id="39712760" class="c"><input type="checkbox" id="c-39712760" checked=""/><div class="controls bullet"><span class="by">Zuiii</span><span>|</span><a href="#39710822">parent</a><span>|</span><a href="#39713285">next</a><span>|</span><label class="collapse" for="c-39712760">[-]</label><label class="expand" for="c-39712760">[4 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s standard library is a shining example of what all standard libraries should strive for. Yet, we still have some languages who&#x27;s developers refuse to include even a basic http API in their standard libraries in an age where even embedded systems have started to speak http. Imagine if if the same had happened with TCP and UDP...<p>Here&#x27;s to the continued success of Go and other sanely-designed languages.</div><br/><div id="39713396" class="c"><input type="checkbox" id="c-39713396" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39710822">root</a><span>|</span><a href="#39712760">parent</a><span>|</span><a href="#39713082">next</a><span>|</span><label class="collapse" for="c-39713396">[-]</label><label class="expand" for="c-39713396">[1 more]</label></div><br/><div class="children"><div class="content">Python (1991), Java (1995), .NET (2001), Smalltalk (1972), Common Lisp (1984), Ruby (1995), Perl (1993).<p>Go is following not leading.<p>To this day ISO C and ISO C++ still don&#x27;t include TCP and UDP on their standard library, that comes from POSIX, the UNIX APIs that didn&#x27;t make it into neither ISO C nor ISO C++.</div><br/></div></div><div id="39713082" class="c"><input type="checkbox" id="c-39713082" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#39710822">root</a><span>|</span><a href="#39712760">parent</a><span>|</span><a href="#39713396">prev</a><span>|</span><a href="#39713285">next</a><span>|</span><label class="collapse" for="c-39713082">[-]</label><label class="expand" for="c-39713082">[2 more]</label></div><br/><div class="children"><div class="content">I think it’s a bit extreme to characterise it as sanity vs insanity. I think you need at least one of a large stdlib or good dependency management.<p>I love Go, used it since the 1.0 release and have used it at work for years. No complaints about the language. But for the longest time Go didn’t have quality dependency management and pulling in dependencies was annoying. Building your programs with the large, high quality stdlib was the path of least resistance.<p>Since Go 1.0 (2012) most new languages have coalesced on good dependency management. Rust, for example, copied Ruby’s bundler idioms since before 1.0 (2015). People who needed good quality libraries were able to pull them in with minimal hassle. That’s why they didn’t need a large standard library to succeed. I’ve written more about the tradeoff here - <a href="https:&#x2F;&#x2F;blog.nindalf.com&#x2F;posts&#x2F;rust-stdlib&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.nindalf.com&#x2F;posts&#x2F;rust-stdlib&#x2F;</a><p>To you, I’d suggest using less charged language like sanity. In this case there’s a good technical case for both ways, and it’s not productive or nice to imply that people who choose a different path from you are insane.</div><br/><div id="39713143" class="c"><input type="checkbox" id="c-39713143" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#39710822">root</a><span>|</span><a href="#39713082">parent</a><span>|</span><a href="#39713285">next</a><span>|</span><label class="collapse" for="c-39713143">[-]</label><label class="expand" for="c-39713143">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To you, I’d suggest using less charged language like sanity.<p>To the grandparent, I&#x27;d suggest keeping the language as it is. Status quo in the current programming ecosystem is often insane, and when it is, we should call it out.<p>&gt; it’s not productive or nice to imply that people who choose a different path from you are insane.<p>In a general sense, I agree. However, when it comes to programming, insanity is so widely accepted as normality that I think it would be counterproductive to blunt the language used to describe it.<p>As an example of insanity for those who may (justifiably) think I&#x27;m talking out of my bottom - in NodeJS ecosystem the standard library is so bad that it is considered acceptable to use dependencies for even the simplest tasks, which caused the `leftpad` incident which broke countless programs.</div><br/></div></div></div></div></div></div></div></div><div id="39713285" class="c"><input type="checkbox" id="c-39713285" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#39710822">prev</a><span>|</span><a href="#39712517">next</a><span>|</span><label class="collapse" for="c-39713285">[-]</label><label class="expand" for="c-39713285">[1 more]</label></div><br/><div class="children"><div class="content">What about error stack traces? I find it crazy that you&#x27;re supposed to grep error strings and pray they&#x27;re all different.</div><br/></div></div><div id="39712517" class="c"><input type="checkbox" id="c-39712517" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39713285">prev</a><span>|</span><a href="#39710092">next</a><span>|</span><label class="collapse" for="c-39712517">[-]</label><label class="expand" for="c-39712517">[1 more]</label></div><br/><div class="children"><div class="content">The Flight Recoding pun did not go unnoticed.<p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javacomponents&#x2F;jmc-5-4&#x2F;jfr-runtime-guide&#x2F;about.htm" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javacomponents&#x2F;jmc-5-4&#x2F;jfr-runtime-g...</a></div><br/></div></div><div id="39710092" class="c"><input type="checkbox" id="c-39710092" checked=""/><div class="controls bullet"><span class="by">lagichikool</span><span>|</span><a href="#39712517">prev</a><span>|</span><a href="#39710377">next</a><span>|</span><label class="collapse" for="c-39710092">[-]</label><label class="expand" for="c-39710092">[8 more]</label></div><br/><div class="children"><div class="content">Really cool work. I&#x27;m still slightly paranoid about the overhead of leaving tracing enabled all the time but if it really is 1-2% that&#x27;d be totally worth it in many cases.<p>More awesome work from the Go team. Thanks!</div><br/><div id="39712610" class="c"><input type="checkbox" id="c-39712610" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#39710092">parent</a><span>|</span><a href="#39711162">next</a><span>|</span><label class="collapse" for="c-39712610">[-]</label><label class="expand" for="c-39712610">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but if it really is 1-2% that&#x27;d be totally worth it in many cases<p>As one of the people who worked on the optimizations mentioned in the article, I&#x27;m probably biased, but I think you can expect those claims to hold outside of artificially pathological workloads :).<p>We&#x27;re using execution tracing in our very large fleet of Go services at Datadog, and so far I&#x27;ve not seen any of our real workloads exceed 1% overhead from execution tracing.<p>In fact, we&#x27;re confident enough that we built our goroutine timeline feature on top of execution traces, and it&#x27;s enabled for all of our profiling customers by default nowdays as well [1].<p>[1] <a href="https:&#x2F;&#x2F;blog.felixge.de&#x2F;debug-go-request-latency-with-datadogs-profiling-timeline&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.felixge.de&#x2F;debug-go-request-latency-with-datado...</a></div><br/></div></div><div id="39711162" class="c"><input type="checkbox" id="c-39711162" checked=""/><div class="controls bullet"><span class="by">heyoni</span><span>|</span><a href="#39710092">parent</a><span>|</span><a href="#39712610">prev</a><span>|</span><a href="#39710377">next</a><span>|</span><label class="collapse" for="c-39711162">[-]</label><label class="expand" for="c-39711162">[6 more]</label></div><br/><div class="children"><div class="content">Go has a race detector that you can leave on for a while in like a dev environment and it’ll flag race conditions. There was documented overhead and at some point even a memory leak but they spent months looking into it and eventually plugged the leak and the saga is  now part of their official docs. It’s really interesting to see that kind of stuff laid bare so I would trust that this feature will at least run reasonably well and if it doesn’t, they’ll likely fix it:
 <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;articles&#x2F;race_detector" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;articles&#x2F;race_detector</a>
<a href="https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;26813" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;26813</a></div><br/><div id="39711665" class="c"><input type="checkbox" id="c-39711665" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39710092">root</a><span>|</span><a href="#39711162">parent</a><span>|</span><a href="#39711199">next</a><span>|</span><label class="collapse" for="c-39711665">[-]</label><label class="expand" for="c-39711665">[2 more]</label></div><br/><div class="children"><div class="content">The race detector is an invaluable complement to a language like Go that lacks compile time safety. It meaningfully increases the confidence in code and is anecdotally both good at finding races while also giving straightforward error information to plug them. It won’t find everything though, since it’s runtime analysis.<p>In general, Go tooling makes up for a lot of the intrinsic issues with the language, and even shines as best in class in some cases (like coverage, and perhaps tracing too). All out of the box, and improving with every release.</div><br/><div id="39713417" class="c"><input type="checkbox" id="c-39713417" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39710092">root</a><span>|</span><a href="#39711665">parent</a><span>|</span><a href="#39711199">next</a><span>|</span><label class="collapse" for="c-39713417">[-]</label><label class="expand" for="c-39713417">[1 more]</label></div><br/><div class="children"><div class="content">Only if we leave Smalltalk, Erlang, Java and .NET ecosystems out of the picture.</div><br/></div></div></div></div><div id="39711199" class="c"><input type="checkbox" id="c-39711199" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#39710092">root</a><span>|</span><a href="#39711162">parent</a><span>|</span><a href="#39711665">prev</a><span>|</span><a href="#39710377">next</a><span>|</span><label class="collapse" for="c-39711199">[-]</label><label class="expand" for="c-39711199">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The cost of race detection varies by program, but for a typical program, memory usage may increase by 5-10x and execution time by 2-20x.<p>That&#x27;s &quot;let&#x27;s run the race detector and get some coffee&quot; overhead, not &quot;let&#x27;s leave it on in dev&quot; overhead.<p>Still cool that they have it available!</div><br/><div id="39711792" class="c"><input type="checkbox" id="c-39711792" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#39710092">root</a><span>|</span><a href="#39711199">parent</a><span>|</span><a href="#39711500">next</a><span>|</span><label class="collapse" for="c-39711792">[-]</label><label class="expand" for="c-39711792">[1 more]</label></div><br/><div class="children"><div class="content">The main value of the race detector is enabling it for tests (go test -race), and then writing sufficiently exhaustive unit tests to cover all code paths.<p>I do think most gophers, instead of tests, use a combination of prayer and automatically restarting crashed processes when they inevitably panic from a race, which seems to work better than you&#x27;d expect!</div><br/></div></div><div id="39711500" class="c"><input type="checkbox" id="c-39711500" checked=""/><div class="controls bullet"><span class="by">cdelsolar</span><span>|</span><a href="#39710092">root</a><span>|</span><a href="#39711199">parent</a><span>|</span><a href="#39711792">prev</a><span>|</span><a href="#39710377">next</a><span>|</span><label class="collapse" for="c-39711500">[-]</label><label class="expand" for="c-39711500">[1 more]</label></div><br/><div class="children"><div class="content">I am always running everything in race mode when developing locally and have caught stuff before.</div><br/></div></div></div></div></div></div></div></div><div id="39710377" class="c"><input type="checkbox" id="c-39710377" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#39710092">prev</a><span>|</span><a href="#39710331">next</a><span>|</span><label class="collapse" for="c-39710377">[-]</label><label class="expand" for="c-39710377">[4 more]</label></div><br/><div class="children"><div class="content">The usage of the term execution trace really threw me off. I am more familiar with that term meaning a instruction execution trace or maybe just a function trace, so it made no sense why stack unwinding would be a bottleneck. Turns out it is actually a goroutine event (with stack trace at time of event) trace [1]. I guess Go does not have a code execution trace package?<p>[1] <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;runtime&#x2F;trace" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;runtime&#x2F;trace</a></div><br/><div id="39712937" class="c"><input type="checkbox" id="c-39712937" checked=""/><div class="controls bullet"><span class="by">felixge</span><span>|</span><a href="#39710377">parent</a><span>|</span><a href="#39710544">next</a><span>|</span><label class="collapse" for="c-39712937">[-]</label><label class="expand" for="c-39712937">[1 more]</label></div><br/><div class="children"><div class="content">Go doesn&#x27;t have an instruction (execution) or function call tracer. Go&#x27;s tracer is primarily tracing scheduler events. So maybe the term scheduler tracer should have been used?<p>Anyway, using the term &quot;execution tracer&quot; in Go goes back to the initial design doc from 2014: <a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;u&#x2F;1&#x2F;d&#x2F;1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14&#x2F;pub" rel="nofollow">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;u&#x2F;1&#x2F;d&#x2F;1FP5apqzBgr7ahCCgFO-y...</a></div><br/></div></div><div id="39710544" class="c"><input type="checkbox" id="c-39710544" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#39710377">parent</a><span>|</span><a href="#39712937">prev</a><span>|</span><a href="#39710331">next</a><span>|</span><label class="collapse" for="c-39710544">[-]</label><label class="expand" for="c-39710544">[2 more]</label></div><br/><div class="children"><div class="content">Tracing code is a way to see what&#x27;s happening in your code which Go provides:<p><a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;articles&#x2F;debugging-go-programs-pprof-trace&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.infoq.com&#x2F;articles&#x2F;debugging-go-programs-pprof-t...</a><p>Many other language use the same technique, see Python with: <a href="https:&#x2F;&#x2F;github.com&#x2F;bloomberg&#x2F;memray">https:&#x2F;&#x2F;github.com&#x2F;bloomberg&#x2F;memray</a></div><br/><div id="39710658" class="c"><input type="checkbox" id="c-39710658" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#39710377">root</a><span>|</span><a href="#39710544">parent</a><span>|</span><a href="#39710331">next</a><span>|</span><label class="collapse" for="c-39710658">[-]</label><label class="expand" for="c-39710658">[1 more]</label></div><br/><div class="children"><div class="content">I was talking about <i>execution tracing</i>, specifically, not <i>tracing</i> as a general concept. Tracing as a general concept just means a non-sampled time-series event stream and as commonly used these days generally also includes &quot;stacking&quot; to distinguish it from generic event streams or logging.<p>When you add a additional term like &quot;execution&quot; you are specializing the term to mean a event stream of &quot;execution&quot;. In areas I am familiar with, that would normally mean a trace of the complete execution of the program down to the instruction-level so you can <i>trace</i> the precise &quot;execution&quot; of the program through the code.<p>What is described here would, in the terminology I am familiar with, be more like... a thread status and system event trace just applied to goroutines and the Go runtime, respectively, I guess? It does also include the stack trace at the time of the event, so it does have more data than that, but that is qualitatively different than a instruction execution trace that allows you to trace the exact sequence of execution of your program.</div><br/></div></div></div></div></div></div><div id="39710331" class="c"><input type="checkbox" id="c-39710331" checked=""/><div class="controls bullet"><span class="by">bsaul</span><span>|</span><a href="#39710377">prev</a><span>|</span><a href="#39710002">next</a><span>|</span><label class="collapse" for="c-39710331">[-]</label><label class="expand" for="c-39710331">[18 more]</label></div><br/><div class="children"><div class="content">i&#x27;ve sometimes heard that the JVM had best in class tooling for server troubleshooting. How does go compare to it now ?</div><br/><div id="39710481" class="c"><input type="checkbox" id="c-39710481" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#39710331">parent</a><span>|</span><a href="#39712438">next</a><span>|</span><label class="collapse" for="c-39710481">[-]</label><label class="expand" for="c-39710481">[12 more]</label></div><br/><div class="children"><div class="content">Go is one of the best language in term of tooling, it has just one binary that contains everything, I don&#x27;t know any other language that includes out of the box all of that:<p>- testing<p>- benchmark<p>- profiling<p>- cross compilation ( that work from any platform, like compiling a windows .exe from your raspberry pi for example )<p>- some linting<p>- documentation<p>- package mgmt<p>- bug report<p>- code generation<p>- etc...<p>Java is probably more advanced in some fields ( like tracing &#x2F; profiling ) but it lacks others.</div><br/><div id="39710895" class="c"><input type="checkbox" id="c-39710895" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710481">parent</a><span>|</span><a href="#39710804">next</a><span>|</span><label class="collapse" for="c-39710895">[-]</label><label class="expand" for="c-39710895">[9 more]</label></div><br/><div class="children"><div class="content">Golang also has some of the worst tooling because everything is based off of what comes builtin, and because they&#x27;re not specialized projects, they&#x27;re very limited in capability and configuration.<p>Coming from ts, tooling like tsconfig has a lot of options, but sensible defaults can be set with a single flag like strict mode. If some org has some specialized needs, they can dive into the configuration and get what they need.<p>With golang, not only would it be a lot for any single team to offer all those features at a decent level of polish, the golang culture in particular is very, very resistant to small bits of comfort because of dogma like &quot;worse is better&quot;. It&#x27;s kind of similar to Haskell&#x27;s &quot;avoid success at all cost&quot;.</div><br/><div id="39712398" class="c"><input type="checkbox" id="c-39712398" checked=""/><div class="controls bullet"><span class="by">BillyTheKing</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710895">parent</a><span>|</span><a href="#39711010">next</a><span>|</span><label class="collapse" for="c-39712398">[-]</label><label class="expand" for="c-39712398">[1 more]</label></div><br/><div class="children"><div class="content">This is a classic example of a &#x27;contrarian&#x27; take for what feels like the sake of it. TS&#x2F;JS tooling is a total and utter disaster at this point.<p>The commonJS&#x2F;module transition is a nightmare. The fact that something like &#x27;prisma&#x27; exists - a c-written &#x27;query engine&#x27; that turns prisma js into sql.. wut?<p>This ecosystem is on a highway to hell literally.. I really hope Bun works out, because I do like Typescript, I do like programming in it - but I&#x27;m absolutely done with spending hours upon hours figuring out configs in tsconfig, jest, package.json eslintrc, prettier, vstest and whatever the next &#x27;new&#x27; abstraction is. In Go I can just focus on the code and forget about the rest</div><br/></div></div><div id="39711010" class="c"><input type="checkbox" id="c-39711010" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710895">parent</a><span>|</span><a href="#39712398">prev</a><span>|</span><a href="#39711457">next</a><span>|</span><label class="collapse" for="c-39711010">[-]</label><label class="expand" for="c-39711010">[3 more]</label></div><br/><div class="children"><div class="content">I can’t believe we’re seriously comparing go polished tooling with bloatware and half baked crap in the js&#x2F;ts land especially when it comes to package management and such.<p>Also there’s a lot of go tooling that doesn’t come from go team itself because go standard library exposes first class code introspection utilities. go vet is an example of this</div><br/><div id="39711447" class="c"><input type="checkbox" id="c-39711447" checked=""/><div class="controls bullet"><span class="by">icholy</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39711010">parent</a><span>|</span><a href="#39711457">next</a><span>|</span><label class="collapse" for="c-39711447">[-]</label><label class="expand" for="c-39711447">[2 more]</label></div><br/><div class="children"><div class="content">Why spend your time coding when you could be fiddling with configuration files all day? I love re-learning how to make package.json, tsconfig, esbuild, eslint, prettier, mocha and webpack play nice every time I start a new project.</div><br/><div id="39711678" class="c"><input type="checkbox" id="c-39711678" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39711447">parent</a><span>|</span><a href="#39711457">next</a><span>|</span><label class="collapse" for="c-39711678">[-]</label><label class="expand" for="c-39711678">[1 more]</label></div><br/><div class="children"><div class="content">Missing peer dependency. Have you tried nuking your node_modules?</div><br/></div></div></div></div></div></div><div id="39711457" class="c"><input type="checkbox" id="c-39711457" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710895">parent</a><span>|</span><a href="#39711010">prev</a><span>|</span><a href="#39712575">next</a><span>|</span><label class="collapse" for="c-39711457">[-]</label><label class="expand" for="c-39711457">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been involved in the Go community for almost 10 years, and I&#x27;ve never once heard anybody say &quot;worse is better&quot;. Comparing Go&#x27;s tooling to Typescript feels like a farce, especially since you&#x27;ve neglected to mention the horror that is npm.</div><br/></div></div><div id="39712575" class="c"><input type="checkbox" id="c-39712575" checked=""/><div class="controls bullet"><span class="by">random_mutex</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710895">parent</a><span>|</span><a href="#39711457">prev</a><span>|</span><a href="#39710921">next</a><span>|</span><label class="collapse" for="c-39712575">[-]</label><label class="expand" for="c-39712575">[1 more]</label></div><br/><div class="children"><div class="content">TS tooling excels at preventing you from getting work done</div><br/></div></div><div id="39710921" class="c"><input type="checkbox" id="c-39710921" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710895">parent</a><span>|</span><a href="#39712575">prev</a><span>|</span><a href="#39711507">next</a><span>|</span><label class="collapse" for="c-39710921">[-]</label><label class="expand" for="c-39710921">[1 more]</label></div><br/><div class="children"><div class="content">Which tools are you talking about?</div><br/></div></div><div id="39711507" class="c"><input type="checkbox" id="c-39711507" checked=""/><div class="controls bullet"><span class="by">cdelsolar</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710895">parent</a><span>|</span><a href="#39710921">prev</a><span>|</span><a href="#39710804">next</a><span>|</span><label class="collapse" for="c-39711507">[-]</label><label class="expand" for="c-39711507">[1 more]</label></div><br/><div class="children"><div class="content">No?</div><br/></div></div></div></div><div id="39712492" class="c"><input type="checkbox" id="c-39712492" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710481">parent</a><span>|</span><a href="#39710804">prev</a><span>|</span><a href="#39712438">next</a><span>|</span><label class="collapse" for="c-39712492">[-]</label><label class="expand" for="c-39712492">[1 more]</label></div><br/><div class="children"><div class="content">There is really nothing in Go that Java ecosystem lacks, in their 30 years of existence.<p>The only thing one could arguably argue that Go does better is value types, but even that requires careful coding so that escape analysis is triggered, and in that sense, it is only a matter to use a JVM implementation like GraalVM, OpenJ9, Android ART, PTC, Aicas, Azul.</div><br/></div></div></div></div><div id="39712438" class="c"><input type="checkbox" id="c-39712438" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#39710331">parent</a><span>|</span><a href="#39710481">prev</a><span>|</span><a href="#39710389">next</a><span>|</span><label class="collapse" for="c-39712438">[-]</label><label class="expand" for="c-39712438">[1 more]</label></div><br/><div class="children"><div class="content">I think Go is catching up, but it&#x27;s still significantly behind. For example, Go memory profiles are much, much worse than Java&#x27;s - they don&#x27;t even have them integrated with the GC to show the ownership graph (they can only show where each object was allocated, instead of which other objects are holding a reference to it). The CPU profiling parts seemed more up to par. This tracing thing is nice, I&#x27;m not as familiar with this are of Java. Also, I don&#x27;t think Java has a built-in race detector (except perhaps for the detection of concurrent write and iterations in collections?).<p>Also, the OpenJDK JVM supports live debugging and code hotswap, going so far as to de-optimize code you&#x27;re debugging on the fly to make it readable. Go doesn&#x27;t support live code reload even in local builds.</div><br/></div></div><div id="39710389" class="c"><input type="checkbox" id="c-39710389" checked=""/><div class="controls bullet"><span class="by">Xeoncross</span><span>|</span><a href="#39710331">parent</a><span>|</span><a href="#39712438">prev</a><span>|</span><a href="#39710002">next</a><span>|</span><label class="collapse" for="c-39710389">[-]</label><label class="expand" for="c-39710389">[4 more]</label></div><br/><div class="children"><div class="content">For good reason, the JVM has a ton more knobs that need adjusting. You can&#x27;t just run Java code. The JVM has a lot of tricks you have to customize for based on your workload.<p>For years until 1.19 the Go GC has had only one tuning parameter (GOGC).</div><br/><div id="39710764" class="c"><input type="checkbox" id="c-39710764" checked=""/><div class="controls bullet"><span class="by">rileymichael</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710389">parent</a><span>|</span><a href="#39712483">next</a><span>|</span><label class="collapse" for="c-39710764">[-]</label><label class="expand" for="c-39710764">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see the connection you&#x27;re making between knobs that adjust runtime behavior and tooling. As an aside, &quot;you can&#x27;t just run java code&quot; is a bit hyperbolic, plenty of people &quot;just run&quot; java apps and rely on the default ergonomics. The modern JVM also offers more automated options, such as ZGC which is explicitly self tuning.</div><br/></div></div><div id="39712483" class="c"><input type="checkbox" id="c-39712483" checked=""/><div class="controls bullet"><span class="by">Ironlink</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710389">parent</a><span>|</span><a href="#39710764">prev</a><span>|</span><a href="#39712444">next</a><span>|</span><label class="collapse" for="c-39712483">[-]</label><label class="expand" for="c-39712483">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t just run Java code. The JVM has a lot of tricks you have to customize for based on your workload.<p>This sounds like something you would hear 10 years ago in relation to the CMS garbage collector. Since Java 9, G1 has been the default gc for multi core workloads and is self-tuning. The CMS gc was removed 4 years ago. If you do need to tune G1, the primary knob is target pause time. While other knobs exist, you should think carefully before using them.<p>We run all of our workloads with vanilla settings.</div><br/></div></div><div id="39712444" class="c"><input type="checkbox" id="c-39712444" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#39710331">root</a><span>|</span><a href="#39710389">parent</a><span>|</span><a href="#39712483">prev</a><span>|</span><a href="#39710002">next</a><span>|</span><label class="collapse" for="c-39712444">[-]</label><label class="expand" for="c-39712444">[1 more]</label></div><br/><div class="children"><div class="content">Note that Go <i>needs</i> those knobs just as much as the JVM does, at least some of them. They just didn&#x27;t want to expose them.</div><br/></div></div></div></div></div></div><div id="39710002" class="c"><input type="checkbox" id="c-39710002" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39710331">prev</a><span>|</span><label class="collapse" for="c-39710002">[-]</label><label class="expand" for="c-39710002">[11 more]</label></div><br/><div class="children"><div class="content">I love go,  but I hate CamelCase so much that I often find myself using a thesaurus to find better names for my structs and functions.  It&#x27;s the only thing I don&#x27;t like about writing go code.</div><br/><div id="39711478" class="c"><input type="checkbox" id="c-39711478" checked=""/><div class="controls bullet"><span class="by">badrequest</span><span>|</span><a href="#39710002">parent</a><span>|</span><a href="#39712522">next</a><span>|</span><label class="collapse" for="c-39711478">[-]</label><label class="expand" for="c-39711478">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing about the Go compiler that enforces any case standard. I can&#x27;t imagine a more trivial hill to die on.</div><br/><div id="39711611" class="c"><input type="checkbox" id="c-39711611" checked=""/><div class="controls bullet"><span class="by">semiquaver</span><span>|</span><a href="#39710002">root</a><span>|</span><a href="#39711478">parent</a><span>|</span><a href="#39711646">next</a><span>|</span><label class="collapse" for="c-39711611">[-]</label><label class="expand" for="c-39711611">[2 more]</label></div><br/><div class="children"><div class="content">Nitpicking, but Go is one of the only languages I’m aware of where identifier case is semantically relevant (to determine visibility). Given that fact it’s hard to say “nothing” enforces a case standard.</div><br/><div id="39712967" class="c"><input type="checkbox" id="c-39712967" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#39710002">root</a><span>|</span><a href="#39711611">parent</a><span>|</span><a href="#39711646">next</a><span>|</span><label class="collapse" for="c-39712967">[-]</label><label class="expand" for="c-39712967">[1 more]</label></div><br/><div class="children"><div class="content">Adding to that, the compiler doesn&#x27;t <i>enforce</i> using &quot;mixed caps&quot;, as the documentations calls it, but it&#x27;s strongly recommended (<a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;effective_go#mixed-caps" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;effective_go#mixed-caps</a>)</div><br/></div></div></div></div><div id="39711646" class="c"><input type="checkbox" id="c-39711646" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#39710002">root</a><span>|</span><a href="#39711478">parent</a><span>|</span><a href="#39711611">prev</a><span>|</span><a href="#39712522">next</a><span>|</span><label class="collapse" for="c-39711646">[-]</label><label class="expand" for="c-39711646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can&#x27;t imagine a more trivial hill to die on.<p>I can&#x27;t imagine why this attitude pervades on hacker news.  I can&#x27;t imagine a more trivial reason than yours to make a reply.<p>I guess some people see this as a place to discover differences,  and others see it as a place to enforce blind conformity to the current fad.</div><br/></div></div></div></div><div id="39712522" class="c"><input type="checkbox" id="c-39712522" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#39710002">parent</a><span>|</span><a href="#39711478">prev</a><span>|</span><a href="#39710080">next</a><span>|</span><label class="collapse" for="c-39712522">[-]</label><label class="expand" for="c-39712522">[1 more]</label></div><br/><div class="children"><div class="content">That is a bizarre thing to care so much about.</div><br/></div></div><div id="39710080" class="c"><input type="checkbox" id="c-39710080" checked=""/><div class="controls bullet"><span class="by">lagichikool</span><span>|</span><a href="#39710002">parent</a><span>|</span><a href="#39712522">prev</a><span>|</span><a href="#39710044">next</a><span>|</span><label class="collapse" for="c-39710080">[-]</label><label class="expand" for="c-39710080">[2 more]</label></div><br/><div class="children"><div class="content">I was just thinking today that the case style is the <i>only</i> thing I continue to find objectionable on a day-to-day basis after a decade of writing&#x2F;reading Go.<p>I&#x27;ve fantasized about the idea of a future `go fmt` version rewriting all the code which seems possible if somewhat impractical.</div><br/><div id="39710790" class="c"><input type="checkbox" id="c-39710790" checked=""/><div class="controls bullet"><span class="by">bdzr</span><span>|</span><a href="#39710002">root</a><span>|</span><a href="#39710080">parent</a><span>|</span><a href="#39710044">next</a><span>|</span><label class="collapse" for="c-39710790">[-]</label><label class="expand" for="c-39710790">[1 more]</label></div><br/><div class="children"><div class="content">Go forth and prosper <a href="https:&#x2F;&#x2F;www.emacswiki.org&#x2F;emacs&#x2F;GlassesMode" rel="nofollow">https:&#x2F;&#x2F;www.emacswiki.org&#x2F;emacs&#x2F;GlassesMode</a>.</div><br/></div></div></div></div><div id="39710044" class="c"><input type="checkbox" id="c-39710044" checked=""/><div class="controls bullet"><span class="by">Xeoncross</span><span>|</span><a href="#39710002">parent</a><span>|</span><a href="#39710080">prev</a><span>|</span><a href="#39710485">next</a><span>|</span><label class="collapse" for="c-39710044">[-]</label><label class="expand" for="c-39710044">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually PascalCase, which I like better than camelCase and snake_case.</div><br/><div id="39710483" class="c"><input type="checkbox" id="c-39710483" checked=""/><div class="controls bullet"><span class="by">biomcgary</span><span>|</span><a href="#39710002">root</a><span>|</span><a href="#39710044">parent</a><span>|</span><a href="#39710485">next</a><span>|</span><label class="collapse" for="c-39710483">[-]</label><label class="expand" for="c-39710483">[1 more]</label></div><br/><div class="children"><div class="content">PascalCase for public variables, camelCase for private variables. Just to keep you on your toes.</div><br/></div></div></div></div><div id="39710485" class="c"><input type="checkbox" id="c-39710485" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#39710002">parent</a><span>|</span><a href="#39710044">prev</a><span>|</span><label class="collapse" for="c-39710485">[-]</label><label class="expand" for="c-39710485">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I love go, but I hate CamelCase so much that I often find myself using a thesaurus to find better names for my structs and functions<p>what does one have to do with the other? also yeah I agree, CamelCase is awful. for a while I was doing:<p><pre><code>    Camel_Case
</code></pre>
but it just didnt fit with anything, so now I use:<p><pre><code>    CamelCase &#x2F;&#x2F; just the normal style, for public identifiers
    snake_case &#x2F;&#x2F; for private identifiers
</code></pre>
but, I do not respect acronyms, as keeping them hurt readability I think:<p><pre><code>    HtmlHello
    HelloHtml</code></pre></div><br/></div></div></div></div></div></div></div></div></div></body></html>