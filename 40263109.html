<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715072455713" as="style"/><link rel="stylesheet" href="styles.css?v=1715072455713"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://yosefk.com/blog/a-100x-speedup-with-unsafe-python.html">A 100x speedup with unsafe Python</a> <span class="domain">(<a href="https://yosefk.com">yosefk.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>78 comments</span></div><br/><div><div id="40283491" class="c"><input type="checkbox" id="c-40283491" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40281614">next</a><span>|</span><label class="collapse" for="c-40283491">[-]</label><label class="expand" for="c-40283491">[2 more]</label></div><br/><div class="children"><div class="content">&gt; What can we do about this? We can&#x27;t change the layout of pygame Surface data. And we seriously don&#x27;t want to copy the C++ code of cv2.resize, with its various platform-specific optimizations,<p>Or...   you could have sent a ~25 line pull request to opencv  to fix this performance problem not just for you, but for thousands of other developers and millions of users.<p>I think your fix would go here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv&#x2F;blob&#x2F;ba65d2eb0d83e6c9567a2534f8994cd4484a1635&#x2F;modules&#x2F;imgproc&#x2F;src&#x2F;resize.cpp#L3410">https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv&#x2F;blob&#x2F;ba65d2eb0d83e6c9567a25...</a><p>And you could have tracked down that slow code easily by running your slow code in gdb, hitting Ctrl+C while it&#x27;s doing the slow thing, and then &quot;bt&quot; to get a stack trace of what it&#x27;s doing and you&#x27;d see it constructing this new image copy because the format isn&#x27;t correct.</div><br/><div id="40283597" class="c"><input type="checkbox" id="c-40283597" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40283491">parent</a><span>|</span><a href="#40281614">next</a><span>|</span><label class="collapse" for="c-40283597">[-]</label><label class="expand" for="c-40283597">[1 more]</label></div><br/><div class="children"><div class="content">25 line pull request doing what? Supporting this format efficiently is probably more LOC and unlikely to get merged as few need this and it complicates the code. Doing the thing I did in Python inside OpenCV C++ code instead (reinterpreting the data) is not really possible since you have less knowledge about the input data at this point (like, you&#x27;re going to assume it&#x27;s an RGBA image and access past the area defined as the allocated array data range for the last A value? The user gives a 3D array and you blithely work on the 4th dimension?)<p>And what about the other examples I measured, including pure numpy code? More patches to submit?</div><br/></div></div></div></div><div id="40281614" class="c"><input type="checkbox" id="c-40281614" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40283491">prev</a><span>|</span><a href="#40283314">next</a><span>|</span><label class="collapse" for="c-40281614">[-]</label><label class="expand" for="c-40281614">[16 more]</label></div><br/><div class="children"><div class="content">Oh, array striding.<p>This is a classic bikeshedding issue. When Go and Rust were first being designed, I brought up support for multidimensional arrays. For both cases, that became lost in discussions over what features arrays should have. Subarrays, like slices but multidimensional? That&#x27;s the main use case for striding. Flattening in more than one dimension? And some people want sparse arrays. Stuff like that. So the problem gets pushed off onto collection classes, there&#x27;s no standard, and everybody using such arrays spends time doing format conversion. This is why FORTRAN and Matlab still have strong positions in number-crunching.</div><br/><div id="40282603" class="c"><input type="checkbox" id="c-40282603" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40281614">parent</a><span>|</span><a href="#40281751">next</a><span>|</span><label class="collapse" for="c-40282603">[-]</label><label class="expand" for="c-40282603">[8 more]</label></div><br/><div class="children"><div class="content">From everything I&#x27;m seeing, it follows that Matlab &amp; Fortran have been decimated by Python and C&#x2F;C++ around 1990s and 2010s, respectively. Of course I could be wrong; any evidence of their still strong position will be greatly appreciated, doubly so evidence that this position is due to stride issues.<p>(Of course Python provides wrappers to Fortran code, eg FITPACK, but this code specifically was mostly written in the 80s, with small updates in this century, and is probably used more thru the numpy wrappers, stride conversion issues and all, than thru its native Fortran interface)</div><br/><div id="40282710" class="c"><input type="checkbox" id="c-40282710" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282603">parent</a><span>|</span><a href="#40282930">next</a><span>|</span><label class="collapse" for="c-40282710">[-]</label><label class="expand" for="c-40282710">[6 more]</label></div><br/><div class="children"><div class="content">I think pretty much all linear algebra libraries are still Fortran and are unlikely to ever be C because Fortran is legitimately faster than C for this stuff. I don&#x27;t know if it has anything to do with strong opinions about how values are represented, I think it has more to do with lower overhead of function calling, but that is just repeating what someone told me about Fortran vs C in general, not necessarily applicable to BLAS libraries.<p>Fortran at least used to be very common in heavy scientific computing, but I would bet that relies on GPUs or other accelerators these days.</div><br/><div id="40283153" class="c"><input type="checkbox" id="c-40283153" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282710">parent</a><span>|</span><a href="#40282800">next</a><span>|</span><label class="collapse" for="c-40283153">[-]</label><label class="expand" for="c-40283153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think pretty much all linear algebra libraries are still Fortran and are unlikely to ever be C<p>That is more of an urban legend than reality in 2024. Fact is, although the original BLAS implementation was fortran, it has been at least a decade since every Linux distribution ships either OpenBLAS or ATLAS or the MKL, which are both written in a mix of C and assembly. All modern processor support is only available in these implementations.<p>LAPACK itself is still often built from the Fortran code base, but it&#x27;s just glue over BLAS, and it gets performance solely from its underlying BLAS. Fortran doesn&#x27;t bring any value to LAPACK, it&#x27;s just that rewriting millions of algebraic tricks and heuristics for no performance gain is not enticing.</div><br/></div></div><div id="40282800" class="c"><input type="checkbox" id="c-40282800" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282710">parent</a><span>|</span><a href="#40283153">prev</a><span>|</span><a href="#40282930">next</a><span>|</span><label class="collapse" for="c-40282800">[-]</label><label class="expand" for="c-40282800">[4 more]</label></div><br/><div class="children"><div class="content">The question is how much new numeric code is written in Fortran vs C&#x2F;C++. My guess is way below 10%, certainly if we measure by usage as opposed to LOC and I would guess by LOC as well.<p>Is Fortran legitimately faster than C with the restrict keyword? Regardless of the function call cost diffs between the two - meaning, even if we assume Fortran is somehow faster here - there&#x27;s no way numeric production code does enough function calls for this to matter. If Fortran was faster than C at any point in time I can only imagine pointer aliasing issues to have been the culprit and I can&#x27;t imagine it still being relevant, but I am of course ready to stand corrected.</div><br/><div id="40283054" class="c"><input type="checkbox" id="c-40283054" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282800">parent</a><span>|</span><a href="#40282920">next</a><span>|</span><label class="collapse" for="c-40283054">[-]</label><label class="expand" for="c-40283054">[1 more]</label></div><br/><div class="children"><div class="content">Restrict probably helps. I can&#x27;t say much about fortran but C still has warts that can significantly impact its math library. For example almost every math function may set errno, that is a sideeffect that isn&#x27;t easy to eliminate by the compiler and might bloat the code significantly. For example with gcc a  single instruction sqrt turns into a sqrt instruction, followed by several checks to see if it succeeded, followed by a function call to the sqrt library function just to set errno correctly. I just started to disable math-errno completely once I realized that C allows several alternative ways to handle math errors, which basically makes any code relying on it non portable.</div><br/></div></div><div id="40282920" class="c"><input type="checkbox" id="c-40282920" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282800">parent</a><span>|</span><a href="#40283054">prev</a><span>|</span><a href="#40283008">next</a><span>|</span><label class="collapse" for="c-40282920">[-]</label><label class="expand" for="c-40282920">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think fortran is faster by language virtue, but it&#x27;s certainly easier to scrap together high performance numeric fortran code. And ifort&#x2F;aocc are amazing at making code that runs well on clusters, which is not a priority for any other domain. Fortran is absolutely still on top for modern numerics research code that involves clusters, talk to anyone who works in simulations at a national lab. If your code is mostly matrix math, modern fortran is very nice to work with.<p>Emphasis on modern because maintaining 70s-80s numeric mathematician cowboy code is a ninth circle of hell. It has a bad rep for that reason.</div><br/></div></div><div id="40283008" class="c"><input type="checkbox" id="c-40283008" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282800">parent</a><span>|</span><a href="#40282920">prev</a><span>|</span><a href="#40282930">next</a><span>|</span><label class="collapse" for="c-40283008">[-]</label><label class="expand" for="c-40283008">[1 more]</label></div><br/><div class="children"><div class="content">At the core, Fortran uses multidimensional numerical arrays, with the shapes being defined being defined in the code. So the compiler knows much more about the data that’s being operated on, which in theory allows better optimization.<p>I thought blas&#x2F;lapack is still written in Fortran, so most numerical code would still be built on top of Fortran.</div><br/></div></div></div></div></div></div><div id="40282930" class="c"><input type="checkbox" id="c-40282930" checked=""/><div class="controls bullet"><span class="by">chillfox</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282603">parent</a><span>|</span><a href="#40282710">prev</a><span>|</span><a href="#40281751">next</a><span>|</span><label class="collapse" for="c-40282930">[-]</label><label class="expand" for="c-40282930">[1 more]</label></div><br/><div class="children"><div class="content">If everyone is just using the Fortran libraries instead of reimplementing it in a modern language, then that&#x27;s evidence that it&#x27;s still being used for that purpose.</div><br/></div></div></div></div><div id="40281751" class="c"><input type="checkbox" id="c-40281751" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40281614">parent</a><span>|</span><a href="#40282603">prev</a><span>|</span><a href="#40282295">next</a><span>|</span><label class="collapse" for="c-40281751">[-]</label><label class="expand" for="c-40281751">[4 more]</label></div><br/><div class="children"><div class="content">But format conversion is inevitable because C and FORTRAN has a different axis ordering anyway, isn&#x27;t it?</div><br/><div id="40282057" class="c"><input type="checkbox" id="c-40282057" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40281751">parent</a><span>|</span><a href="#40282295">next</a><span>|</span><label class="collapse" for="c-40282057">[-]</label><label class="expand" for="c-40282057">[3 more]</label></div><br/><div class="children"><div class="content">Not really, you can always change the indexing to account for it. For example, the GEMM matrix multiplication subroutines from BLAS can transpose their arguments [1]. So if you have A (m x n) and B (n x p) stored row-major, but you want to use a column-major BLAS to compute A*B, you can instead tell BLAS that A is n x m, B is p x n, and you want to compute A&#x27; * B&#x27;.<p>As the article mentions, NumPy can handle both and do all the bookkeeping. So can Eigen in C++.<p>[1] <a href="https:&#x2F;&#x2F;www.math.utah.edu&#x2F;software&#x2F;lapack&#x2F;lapack-blas&#x2F;dgemm.html" rel="nofollow">https:&#x2F;&#x2F;www.math.utah.edu&#x2F;software&#x2F;lapack&#x2F;lapack-blas&#x2F;dgemm....</a></div><br/><div id="40282084" class="c"><input type="checkbox" id="c-40282084" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282057">parent</a><span>|</span><a href="#40282295">next</a><span>|</span><label class="collapse" for="c-40282084">[-]</label><label class="expand" for="c-40282084">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s conceptually still a format conversion, though the actual conversion might not happen. Users have to track which format is being used for which matrix and I believe that was what the GP was originally complaining for.</div><br/><div id="40282636" class="c"><input type="checkbox" id="c-40282636" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282084">parent</a><span>|</span><a href="#40282295">next</a><span>|</span><label class="collapse" for="c-40282636">[-]</label><label class="expand" for="c-40282636">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, realistically you&#x27;re going to either convert the data or give up on using the function rather than reimplementing it to support another data layout efficiently; while converting the code instead of the data, so to speak, is more efficient from the machine resource use POV, it can be very rough on human resources.<p>(The article is basically about not having to give up <i>in some cases</i> where you can tweak the input parameters and make things work without rewriting the function; but it&#x27;s not always possible)</div><br/></div></div></div></div></div></div></div></div><div id="40282295" class="c"><input type="checkbox" id="c-40282295" checked=""/><div class="controls bullet"><span class="by">sa-code</span><span>|</span><a href="#40281614">parent</a><span>|</span><a href="#40281751">prev</a><span>|</span><a href="#40283314">next</a><span>|</span><label class="collapse" for="c-40282295">[-]</label><label class="expand" for="c-40282295">[3 more]</label></div><br/><div class="children"><div class="content">What kind of support would you have hoped for?</div><br/><div id="40282909" class="c"><input type="checkbox" id="c-40282909" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282295">parent</a><span>|</span><a href="#40283314">next</a><span>|</span><label class="collapse" for="c-40282909">[-]</label><label class="expand" for="c-40282909">[2 more]</label></div><br/><div class="children"><div class="content">A way to reinterpret a slice of size N as a multidimensional array with strides that are a factorization of N, including optional reverse order strides. Basically, do the stride bookkeeping internally so I can write an algorithm only considering the logic and optimize the striding order independently.</div><br/><div id="40282968" class="c"><input type="checkbox" id="c-40282968" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40281614">root</a><span>|</span><a href="#40282909">parent</a><span>|</span><a href="#40283314">next</a><span>|</span><label class="collapse" for="c-40282968">[-]</label><label class="expand" for="c-40282968">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s where you end up after heavy bikeshedding. Lots of features, terrible performance, as the OP points out.</div><br/></div></div></div></div></div></div></div></div><div id="40283314" class="c"><input type="checkbox" id="c-40283314" checked=""/><div class="controls bullet"><span class="by">C4stor</span><span>|</span><a href="#40281614">prev</a><span>|</span><a href="#40282005">next</a><span>|</span><label class="collapse" for="c-40283314">[-]</label><label class="expand" for="c-40283314">[1 more]</label></div><br/><div class="children"><div class="content">All of this seems unnecessary, and easily replaced in the provided benchmark by :<p>i2 = np.ascontiguousarray(pg.surfarray.pixels3d(isurf))<p>Which does the 100x speedup too and is a &quot;safe&quot; way to adjust memory access to numpy strides.<p>Whether the output is correct or not is left as an exercise to the author, since the provided benchmark only use np.zeros() it&#x27;s kind of hard to verify</div><br/></div></div><div id="40282005" class="c"><input type="checkbox" id="c-40282005" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#40283314">prev</a><span>|</span><a href="#40282219">next</a><span>|</span><label class="collapse" for="c-40282005">[-]</label><label class="expand" for="c-40282005">[9 more]</label></div><br/><div class="children"><div class="content"><i>Why</i> does numpy do column order data?<p>Is it because in much of the maths domain it turns out you manipulate columns more often than rows?<p>(not a mathematician but I could believe if the columns represent &quot;dimensions&quot; or &quot;qualities&quot; of some dataset, and you want to apply a function to a given dimension, having data in column-natural order makes that faster.)<p>Obviously you want to believe naievely there is no difference to the X and Y in the X,Y plane, but machines are not naieve and sometimes there IS a difference to doing things to the set of verticals, and the set of horizontals.</div><br/><div id="40282087" class="c"><input type="checkbox" id="c-40282087" checked=""/><div class="controls bullet"><span class="by">sdeer</span><span>|</span><a href="#40282005">parent</a><span>|</span><a href="#40282881">next</a><span>|</span><label class="collapse" for="c-40282087">[-]</label><label class="expand" for="c-40282087">[1 more]</label></div><br/><div class="children"><div class="content">Probably because Fortran stores matrices and other multidimensional arrays in column order. Traditionally most numerical computation software was written in Fortran and numpy calls those under the hood. Storing in row order would have meant copying the data to column major order and back for any call to Fortran.</div><br/></div></div><div id="40282881" class="c"><input type="checkbox" id="c-40282881" checked=""/><div class="controls bullet"><span class="by">Pinus</span><span>|</span><a href="#40282005">parent</a><span>|</span><a href="#40282087">prev</a><span>|</span><a href="#40282386">next</a><span>|</span><label class="collapse" for="c-40282881">[-]</label><label class="expand" for="c-40282881">[2 more]</label></div><br/><div class="children"><div class="content">Hang on, doesn’t numpy use C (row major) array ordering by default? <i>checks docs</i> Seems like it does. However, numpy array indexing also follows the maths convention where 2D arrays are indexed by row, column (as does C, by the way), so to access pixel x, y you need to say im[y, x]. And the image libraries where I have toyed with with numpy integration (only Pillow, to be honest) seem to work just fine like this — a row of pixels is stored contiguously in memory. So I don’t quite see why the author claims that numpy stores a <i>column</i> of pixels contiguously, but I have only glanced at the article, so quite probably I have missed something.</div><br/><div id="40283038" class="c"><input type="checkbox" id="c-40283038" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#40282005">root</a><span>|</span><a href="#40282881">parent</a><span>|</span><a href="#40282386">next</a><span>|</span><label class="collapse" for="c-40283038">[-]</label><label class="expand" for="c-40283038">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. Numpy stores arrays in row-major order by default.
One can always just have a look at the flags (ndarray.flags returns some information about the order and underlying buffer).</div><br/></div></div></div></div><div id="40282386" class="c"><input type="checkbox" id="c-40282386" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#40282005">parent</a><span>|</span><a href="#40282881">prev</a><span>|</span><a href="#40282236">next</a><span>|</span><label class="collapse" for="c-40282386">[-]</label><label class="expand" for="c-40282386">[2 more]</label></div><br/><div class="children"><div class="content">It is possible that my brain had been damaged by convention, but it looks much tidier to have your vector multiplicand on the right of the matrix when doing a matrix vector multiplication y=Ax, where A is the matrix and x is the vector, y is the result.<p>So, x and y must be columns. So, it is nice if our language has column-order as the default, that way a vector is also just a good old 1d array.<p>If we did y=xA, x and y would be rows, the actual math would be the same but… I dunno, isn’t it just hideous? Ax is like a sentence, it should start with an upper case!<p>It also fits well with how we tend to learn math. First we learn about functions, f(x). Then we learn that a function can be an operator. And a matrix can represent a linear operator. So, we tend to have a long history of stuff sitting to the left of x getting ready to transform it.</div><br/><div id="40282510" class="c"><input type="checkbox" id="c-40282510" checked=""/><div class="controls bullet"><span class="by">SailorJerry</span><span>|</span><a href="#40282005">root</a><span>|</span><a href="#40282386">parent</a><span>|</span><a href="#40282236">next</a><span>|</span><label class="collapse" for="c-40282510">[-]</label><label class="expand" for="c-40282510">[1 more]</label></div><br/><div class="children"><div class="content">I think the reason I prefer columns is I do the mental expansion into large bracketed expressions. If x is a row and kept inline, then the expansion gets really wide. To keep it compact and have the symbols oriented the same as their expansion, you&#x27;d have to put the x above A and that&#x27;s just silly.</div><br/></div></div></div></div><div id="40282236" class="c"><input type="checkbox" id="c-40282236" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#40282005">parent</a><span>|</span><a href="#40282386">prev</a><span>|</span><a href="#40282543">next</a><span>|</span><label class="collapse" for="c-40282236">[-]</label><label class="expand" for="c-40282236">[2 more]</label></div><br/><div class="children"><div class="content">Numpy was originally designed for mathematicians and scientists, and in those domains convention often lines up better with column major order. For example, vectors are a single column, and the column index comes before the row index in many notations. So using column major order meant familar formulas and algorithms (including translating from fortran code which is column major, or matlab for that matter) are easy to translate to numpy code.<p>Also, numpy is built on some fortran libraries, like BLAS and LAPACK that assume a column major order. If it took row major input, it would need to transpose matrices in some cases change the order, or rewrite those libraries to use row major form.</div><br/><div id="40282252" class="c"><input type="checkbox" id="c-40282252" checked=""/><div class="controls bullet"><span class="by">kolbusa</span><span>|</span><a href="#40282005">root</a><span>|</span><a href="#40282236">parent</a><span>|</span><a href="#40282543">next</a><span>|</span><label class="collapse" for="c-40282252">[-]</label><label class="expand" for="c-40282252">[1 more]</label></div><br/><div class="children"><div class="content">Copying is usually not necessary. Often times you can swap data and&#x2F;or shape arguments and get a transposed result out. While it is true that Fortran BLAS only supports col-major, CBLAS supports both row- and col-major. Internally, all the libraries I worked on use col-major, but that is just a convention.</div><br/></div></div></div></div><div id="40282543" class="c"><input type="checkbox" id="c-40282543" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#40282005">parent</a><span>|</span><a href="#40282236">prev</a><span>|</span><a href="#40282219">next</a><span>|</span><label class="collapse" for="c-40282543">[-]</label><label class="expand" for="c-40282543">[1 more]</label></div><br/><div class="children"><div class="content">I think in math columns as vectors is a more common representation. Especially if we talk about matrix multiplication and linear systems.</div><br/></div></div></div></div><div id="40282219" class="c"><input type="checkbox" id="c-40282219" checked=""/><div class="controls bullet"><span class="by">ruined</span><span>|</span><a href="#40282005">prev</a><span>|</span><a href="#40281496">next</a><span>|</span><label class="collapse" for="c-40282219">[-]</label><label class="expand" for="c-40282219">[2 more]</label></div><br/><div class="children"><div class="content">oh THIS is why image byte order and dimensions are so confusing every time i fuck with opencv and pygame<p>well, half of why. for some reason i keep doing everything directly on &#x2F;dev&#x2F;fb0</div><br/><div id="40283265" class="c"><input type="checkbox" id="c-40283265" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#40282219">parent</a><span>|</span><a href="#40281496">next</a><span>|</span><label class="collapse" for="c-40283265">[-]</label><label class="expand" for="c-40283265">[1 more]</label></div><br/><div class="children"><div class="content">Image byte order, axis directions, coordinate system handedness when in 3D... after enough trying, you eventually figure out the order of looping at any given stage of your program, and then it Just Works, and then you <i>never touch it again</i>.</div><br/></div></div></div></div><div id="40281496" class="c"><input type="checkbox" id="c-40281496" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40282219">prev</a><span>|</span><a href="#40281979">next</a><span>|</span><label class="collapse" for="c-40281496">[-]</label><label class="expand" for="c-40281496">[5 more]</label></div><br/><div class="children"><div class="content">Do you actually need ctypes here, or can you just use np.reshape?  That would cut out the unsafety.</div><br/><div id="40281590" class="c"><input type="checkbox" id="c-40281590" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40281496">parent</a><span>|</span><a href="#40282694">next</a><span>|</span><label class="collapse" for="c-40281590">[-]</label><label class="expand" for="c-40281590">[2 more]</label></div><br/><div class="children"><div class="content">You can exploit memory unsafety in cpython using only built-in methods, no imports needed at all: <a href="https:&#x2F;&#x2F;github.com&#x2F;DavidBuchanan314&#x2F;unsafe-python&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;DavidBuchanan314&#x2F;unsafe-python&#x2F;</a></div><br/><div id="40282718" class="c"><input type="checkbox" id="c-40282718" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40281496">root</a><span>|</span><a href="#40281590">parent</a><span>|</span><a href="#40282694">next</a><span>|</span><label class="collapse" for="c-40282718">[-]</label><label class="expand" for="c-40282718">[1 more]</label></div><br/><div class="children"><div class="content">You... probably shouldn&#x27;t, but, very interesting stuff in that link! I didn&#x27;t know CPython had no bounds checks in the load_const bytecode op</div><br/></div></div></div></div><div id="40282694" class="c"><input type="checkbox" id="c-40282694" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40281496">parent</a><span>|</span><a href="#40281590">prev</a><span>|</span><a href="#40281605">next</a><span>|</span><label class="collapse" for="c-40282694">[-]</label><label class="expand" for="c-40282694">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;ll have a problem with BGR data absent ctypes, since you have a numpy array with the base pointing at the first red channel value, and you want an array with the base pointing 2 bytes <i>before</i> the first red channel value. This is almost definitely &quot;unsafe&quot;?.. or does numpy have functions knowing that due to the negative z stride, the red value before the blue value is within the bounds of the original array? I somehow doubt it though it would be very impressive. And I think the last A value is hopelessly out of reach absent ctypes since a safe API has no information that this last value is within the array bounds; more strictly speaking all the alpha values are out of bounds according to the shape and strides of the BGRA array.</div><br/></div></div><div id="40281605" class="c"><input type="checkbox" id="c-40281605" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40281496">parent</a><span>|</span><a href="#40282694">prev</a><span>|</span><a href="#40281979">next</a><span>|</span><label class="collapse" for="c-40281605">[-]</label><label class="expand" for="c-40281605">[1 more]</label></div><br/><div class="children"><div class="content">I think what you want is a combination of swapaxes and flip (reshape does not turn rows into columns, it turns m input rows into n output rows), but yeah.<p>Actually let me include a little figure<p><pre><code>  original  reshape  swapaxes

  abc       ab       ad
  def       cd       be
            ef       cf</code></pre></div><br/></div></div></div></div><div id="40281979" class="c"><input type="checkbox" id="c-40281979" checked=""/><div class="controls bullet"><span class="by">gugagore</span><span>|</span><a href="#40281496">prev</a><span>|</span><a href="#40281501">next</a><span>|</span><label class="collapse" for="c-40281979">[-]</label><label class="expand" for="c-40281979">[5 more]</label></div><br/><div class="children"><div class="content">Technically, image resizing does in general care about the color channel ordering, because color spaces are in general not linear. <a href="https:&#x2F;&#x2F;www.alanzucconi.com&#x2F;2016&#x2F;01&#x2F;06&#x2F;colour-interpolation&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.alanzucconi.com&#x2F;2016&#x2F;01&#x2F;06&#x2F;colour-interpolation&#x2F;</a></div><br/><div id="40282019" class="c"><input type="checkbox" id="c-40282019" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#40281979">parent</a><span>|</span><a href="#40282773">next</a><span>|</span><label class="collapse" for="c-40282019">[-]</label><label class="expand" for="c-40282019">[3 more]</label></div><br/><div class="children"><div class="content">That article fails to touch on the fundamental issue with its title &quot;The Secrets of Colour Interpolation&quot;: RGB values are a nonlinear function of the light emitted (because we are better at distinguishing dark colours, so it&#x27;s better to allow representing more of those), so to interpolate properly you need to invert that function, interpolate, then reapply. The difference that makes to colour gradients is really striking.</div><br/><div id="40282099" class="c"><input type="checkbox" id="c-40282099" checked=""/><div class="controls bullet"><span class="by">topherclay</span><span>|</span><a href="#40281979">root</a><span>|</span><a href="#40282019">parent</a><span>|</span><a href="#40282773">next</a><span>|</span><label class="collapse" for="c-40282099">[-]</label><label class="expand" for="c-40282099">[2 more]</label></div><br/><div class="children"><div class="content">Do you mean converting the RGB value to LAB values in the CIELAB color space and doing the interpellation there?<p>Is there a better way to do it?</div><br/><div id="40282277" class="c"><input type="checkbox" id="c-40282277" checked=""/><div class="controls bullet"><span class="by">CarVac</span><span>|</span><a href="#40281979">root</a><span>|</span><a href="#40282099">parent</a><span>|</span><a href="#40282773">next</a><span>|</span><label class="collapse" for="c-40282277">[-]</label><label class="expand" for="c-40282277">[1 more]</label></div><br/><div class="children"><div class="content">No, you just need to linearize the brightness.</div><br/></div></div></div></div></div></div><div id="40282773" class="c"><input type="checkbox" id="c-40282773" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40281979">parent</a><span>|</span><a href="#40282019">prev</a><span>|</span><a href="#40281501">next</a><span>|</span><label class="collapse" for="c-40282773">[-]</label><label class="expand" for="c-40282773">[1 more]</label></div><br/><div class="children"><div class="content">While this is a valid point, cv2.resize doesn&#x27;t actually implement color conversion in a way addressing this issue; at least in my testing I get identical results whether I interpret the data as RGB or BGR. So if you want to use cv2.resize, AFAIK you can count on it not caring which channel is which. And if you need fast resizing, you&#x27;re quite likely to settle for the straightforward interpolation implemented by cv2.resize.</div><br/></div></div></div></div><div id="40281501" class="c"><input type="checkbox" id="c-40281501" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#40281979">prev</a><span>|</span><a href="#40281289">next</a><span>|</span><label class="collapse" for="c-40281501">[-]</label><label class="expand" for="c-40281501">[6 more]</label></div><br/><div class="children"><div class="content">Well with mojo it looks like you will have both safety and performance</div><br/><div id="40281525" class="c"><input type="checkbox" id="c-40281525" checked=""/><div class="controls bullet"><span class="by">grandma_tea</span><span>|</span><a href="#40281501">parent</a><span>|</span><a href="#40281289">next</a><span>|</span><label class="collapse" for="c-40281525">[-]</label><label class="expand" for="c-40281525">[5 more]</label></div><br/><div class="children"><div class="content">Closed source and not relevant.</div><br/><div id="40281655" class="c"><input type="checkbox" id="c-40281655" checked=""/><div class="controls bullet"><span class="by">ianbutler</span><span>|</span><a href="#40281501">root</a><span>|</span><a href="#40281525">parent</a><span>|</span><a href="#40281289">next</a><span>|</span><label class="collapse" for="c-40281655">[-]</label><label class="expand" for="c-40281655">[4 more]</label></div><br/><div class="children"><div class="content">Mojo was open sourced months ago iirc<p><a href="https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo">https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo</a></div><br/><div id="40282194" class="c"><input type="checkbox" id="c-40282194" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40281501">root</a><span>|</span><a href="#40281655">parent</a><span>|</span><a href="#40281289">next</a><span>|</span><label class="collapse" for="c-40282194">[-]</label><label class="expand" for="c-40282194">[3 more]</label></div><br/><div class="children"><div class="content">Those are examples and docs. Mojo is still closed.</div><br/><div id="40282436" class="c"><input type="checkbox" id="c-40282436" checked=""/><div class="controls bullet"><span class="by">ianbutler</span><span>|</span><a href="#40281501">root</a><span>|</span><a href="#40282194">parent</a><span>|</span><a href="#40281289">next</a><span>|</span><label class="collapse" for="c-40282436">[-]</label><label class="expand" for="c-40282436">[2 more]</label></div><br/><div class="children"><div class="content">Their standard lib is in there, seems more open to me<p>Theres the announcement where they open sourced the modules in their standard lib:
<a href="https:&#x2F;&#x2F;www.modular.com&#x2F;blog&#x2F;the-next-big-step-in-mojo-open-source" rel="nofollow">https:&#x2F;&#x2F;www.modular.com&#x2F;blog&#x2F;the-next-big-step-in-mojo-open-...</a><p>There&#x27;s the standard lib:
<a href="https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo&#x2F;blob&#x2F;nightly&#x2F;stdlib&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo&#x2F;blob&#x2F;nightly&#x2F;stdlib&#x2F;README...</a></div><br/><div id="40283017" class="c"><input type="checkbox" id="c-40283017" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40281501">root</a><span>|</span><a href="#40282436">parent</a><span>|</span><a href="#40281289">next</a><span>|</span><label class="collapse" for="c-40283017">[-]</label><label class="expand" for="c-40283017">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s some minimal progress, but really not that interesting. (As in, it&#x27;s cool that it exists, but given we&#x27;ve got Python stdlib and numpy already open, it&#x27;s not really new&#x2F;exciting) And doesn&#x27;t allow you to port to platforms they don&#x27;t care enough about.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40281289" class="c"><input type="checkbox" id="c-40281289" checked=""/><div class="controls bullet"><span class="by">idkdotcom</span><span>|</span><a href="#40281501">prev</a><span>|</span><a href="#40281322">next</a><span>|</span><label class="collapse" for="c-40281289">[-]</label><label class="expand" for="c-40281289">[16 more]</label></div><br/><div class="children"><div class="content">Safety is one of Python&#x27;s greatest advantages over C or C++. Why would anyone use unsafe Python when P0ython doesn&#x27;t have other features such as type safety and all the debugging tools that have been built for C and C++ over time is beyond me.<p>Python is a great language, but just as the generation of kids who got out of computer science programs in the 2000s were clueless about anything that wasn&#x27;t Java, it seems this generation is clueless about anything that isn&#x27;t Python.<p>There was life before Python and there will be life after Python!</div><br/><div id="40281384" class="c"><input type="checkbox" id="c-40281384" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40281289">parent</a><span>|</span><a href="#40282310">next</a><span>|</span><label class="collapse" for="c-40281384">[-]</label><label class="expand" for="c-40281384">[5 more]</label></div><br/><div class="children"><div class="content">Seems to me if you could do most of the work in Python and then just make the critical loop unsafe and 100x faster then that would certainly have some appeal.</div><br/><div id="40281611" class="c"><input type="checkbox" id="c-40281611" checked=""/><div class="controls bullet"><span class="by">gibolt</span><span>|</span><a href="#40281289">root</a><span>|</span><a href="#40281384">parent</a><span>|</span><a href="#40281683">next</a><span>|</span><label class="collapse" for="c-40281611">[-]</label><label class="expand" for="c-40281611">[3 more]</label></div><br/><div class="children"><div class="content">Plenty of people would gladly not have to learn another language (especially C).<p>You could also benefit from testing blocks of code with safety enabled to have more confidence when safety is removed.</div><br/><div id="40282845" class="c"><input type="checkbox" id="c-40282845" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#40281289">root</a><span>|</span><a href="#40281611">parent</a><span>|</span><a href="#40283072">next</a><span>|</span><label class="collapse" for="c-40282845">[-]</label><label class="expand" for="c-40282845">[1 more]</label></div><br/><div class="children"><div class="content">It was explained pretty well in the blog: Installing the OpenCV python package is easy, fast and painless as long as you&#x27;re happy with the default binary. Building OpenCV from source to get it into a C&#x2F;C++ program can quickly turn into a multi-hour adventure, if you&#x27;re not familiar with building sizeable C++ projects.</div><br/></div></div><div id="40283072" class="c"><input type="checkbox" id="c-40283072" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#40281289">root</a><span>|</span><a href="#40281611">parent</a><span>|</span><a href="#40282845">prev</a><span>|</span><a href="#40281683">next</a><span>|</span><label class="collapse" for="c-40283072">[-]</label><label class="expand" for="c-40283072">[1 more]</label></div><br/><div class="children"><div class="content">Or if you’re going to learn another language might as well learn nim. Keep most of the python syntax, ditch the performance and the packaging insanity.</div><br/></div></div></div></div></div></div><div id="40282310" class="c"><input type="checkbox" id="c-40282310" checked=""/><div class="controls bullet"><span class="by">SunlitCat</span><span>|</span><a href="#40281289">parent</a><span>|</span><a href="#40281384">prev</a><span>|</span><a href="#40281624">next</a><span>|</span><label class="collapse" for="c-40282310">[-]</label><label class="expand" for="c-40282310">[1 more]</label></div><br/><div class="children"><div class="content">Thing about academia (like computer science and the like) is, you need a programming language you can get across easily, quickly and can get people to produce satisfying results in no time.<p>Back then it might have been java, then python, till the next language comes around.<p>The java thing was so apparent, that when you looked at c++ code, you were able to spot the former java user pretty easily. :)<p>About python, sometime ago, I was looking into arudino programming in c and found someone offering a library (I think) in c (or c++, can&#x27;t remember). What i remember is, that this person stopped working on it, because they got many requests and questions regarding to be able to use their library in python.</div><br/></div></div><div id="40281624" class="c"><input type="checkbox" id="c-40281624" checked=""/><div class="controls bullet"><span class="by">gibolt</span><span>|</span><a href="#40281289">parent</a><span>|</span><a href="#40282310">prev</a><span>|</span><a href="#40281834">next</a><span>|</span><label class="collapse" for="c-40281624">[-]</label><label class="expand" for="c-40281624">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Why would anyone use&quot; -&gt; &quot;when&quot; usage generally means lots of use cases are being ignored &#x2F; swept under the rug.<p>&gt;1 billion people exist. Each has a unique opinion &#x2F; viewpoint.</div><br/></div></div><div id="40281834" class="c"><input type="checkbox" id="c-40281834" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#40281289">parent</a><span>|</span><a href="#40281624">prev</a><span>|</span><a href="#40281388">next</a><span>|</span><label class="collapse" for="c-40281834">[-]</label><label class="expand" for="c-40281834">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;unsafe&quot; in the title appears to be used in the sense of &quot;exposing memory layout details&quot;, but not in the sense of &quot;direct unbounded access to memory&quot;.  It&#x27;s probably not the memory safety issue you are thinking of.</div><br/><div id="40282750" class="c"><input type="checkbox" id="c-40282750" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40281289">root</a><span>|</span><a href="#40281834">parent</a><span>|</span><a href="#40281388">next</a><span>|</span><label class="collapse" for="c-40282750">[-]</label><label class="expand" for="c-40282750">[1 more]</label></div><br/><div class="children"><div class="content">You can absolutely get direct unbounded access to memory with ctypes, with all the bugs that come from this. I just think&#x2F;hope the code I show in TFA happens to have no such bugs.</div><br/></div></div></div></div><div id="40281388" class="c"><input type="checkbox" id="c-40281388" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40281289">parent</a><span>|</span><a href="#40281834">prev</a><span>|</span><a href="#40282478">next</a><span>|</span><label class="collapse" for="c-40281388">[-]</label><label class="expand" for="c-40281388">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why would anyone use unsafe Python when Python doesn&#x27;t have other features such as type safety and all the debugging tools that have been built for C and C++ over time is beyond me.<p>C and C++ &#x27;type safety&#x27; is barely there (compared to more sane languages like OCaml or Rust or even Java etc).  As to why would anyone do that?  The question is &#x27;why not?&#x27;  It&#x27;s fun.</div><br/></div></div><div id="40282478" class="c"><input type="checkbox" id="c-40282478" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40281289">parent</a><span>|</span><a href="#40281388">prev</a><span>|</span><a href="#40281715">next</a><span>|</span><label class="collapse" for="c-40282478">[-]</label><label class="expand" for="c-40282478">[1 more]</label></div><br/><div class="children"><div class="content">while python is eminently criticable, yosef kreinin has designed his own cpu instruction set and gotten it fabbed in a shipping hardware product, and is the author of the c++fqa, which is by far the best-informed criticism of c++; criticizing him with &#x27;this generation is clueless about anything that isn&#x27;t Python&#x27; seems off the mark</div><br/></div></div><div id="40281715" class="c"><input type="checkbox" id="c-40281715" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#40281289">parent</a><span>|</span><a href="#40282478">prev</a><span>|</span><a href="#40281322">next</a><span>|</span><label class="collapse" for="c-40281715">[-]</label><label class="expand" for="c-40281715">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use Python because of type safety, I use it because it&#x27;s easy to write. I couldn&#x27;t give a single fuck about some missed pointers that weren&#x27;t cleaned up in the 2.5 seconds my program ran. I&#x27;m not deploying public code.<p>I tend to prototype in Python and then just rewrite the whole thing in C with classes if I need the 10000x speedup.</div><br/><div id="40282276" class="c"><input type="checkbox" id="c-40282276" checked=""/><div class="controls bullet"><span class="by">SunlitCat</span><span>|</span><a href="#40281289">root</a><span>|</span><a href="#40281715">parent</a><span>|</span><a href="#40281322">next</a><span>|</span><label class="collapse" for="c-40282276">[-]</label><label class="expand" for="c-40282276">[2 more]</label></div><br/><div class="children"><div class="content">That easy to write part is something, I am not so sure about. It took me ages to understand why my first try at writing a blender plugin didn&#x27;t work.<p>It was because of white spaces not lining up. I was like, really? Using white spaces as a way to denote the body of a function? Really?</div><br/><div id="40283467" class="c"><input type="checkbox" id="c-40283467" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#40281289">root</a><span>|</span><a href="#40282276">parent</a><span>|</span><a href="#40281322">next</a><span>|</span><label class="collapse" for="c-40283467">[-]</label><label class="expand" for="c-40283467">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious... what rock have you been living under in the past 33 years since python was launched?</div><br/></div></div></div></div></div></div></div></div><div id="40281322" class="c"><input type="checkbox" id="c-40281322" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40281289">prev</a><span>|</span><a href="#40282346">next</a><span>|</span><label class="collapse" for="c-40281322">[-]</label><label class="expand" for="c-40281322">[14 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t all Python, by design, unsafe?</div><br/><div id="40282113" class="c"><input type="checkbox" id="c-40282113" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#40281322">parent</a><span>|</span><a href="#40281333">next</a><span>|</span><label class="collapse" for="c-40282113">[-]</label><label class="expand" for="c-40282113">[2 more]</label></div><br/><div class="children"><div class="content">As others commented &quot;safety&quot; is a heavily overloaded term, for instance there&#x27;s &quot;type safety&quot; [1] and &quot;memory safety&quot; [2], and then there&#x27;s &quot;static vs dynamic typing&quot; [3], and &quot;weak vs strong typing&quot; [4], so talking about types and safety offered by a language can be very nuanced.<p>I suspect when you say &quot;unsafe by design&quot; you may be referring to the dynamic type checking aspect of Python, although Python has supported for a while type annotations, that can be statically checked by linter-like tools like PyRight.<p>--<p>1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_safety" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_safety</a><p>2: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety</a><p>3: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_system#Type_checking" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Type_system#Type_checking</a><p>4: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Strong_and_weak_typing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Strong_and_weak_typing</a></div><br/><div id="40282717" class="c"><input type="checkbox" id="c-40282717" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40282113">parent</a><span>|</span><a href="#40281333">next</a><span>|</span><label class="collapse" for="c-40282717">[-]</label><label class="expand" for="c-40282717">[1 more]</label></div><br/><div class="children"><div class="content">Python both type and memory safe e.g., &quot;&quot;+1 in Python is TypeError and [][0] is IndexError<p>But you can perform unsafe operations e.g.,<p><pre><code>    import ctypes
    ctypes.string_at(0)  # access 0 address in memory -&gt; segfault</code></pre></div><br/></div></div></div></div><div id="40281333" class="c"><input type="checkbox" id="c-40281333" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#40281322">parent</a><span>|</span><a href="#40282113">prev</a><span>|</span><a href="#40281328">next</a><span>|</span><label class="collapse" for="c-40281333">[-]</label><label class="expand" for="c-40281333">[4 more]</label></div><br/><div class="children"><div class="content">ctypes, c extensions, and CFFI are unsafe.<p>Python doesn&#x27;t have an unsafe keyword like Rustlang.<p>In Python, you can dereference a null pointer and cause a Segmentation fault given a ctypes import.<p>lancedb&#x2F;lance and&#x2F;or pandas&#x27; dtype_backend=&quot;pyarrow&quot; might work with pygame</div><br/><div id="40281599" class="c"><input type="checkbox" id="c-40281599" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281333">parent</a><span>|</span><a href="#40281328">next</a><span>|</span><label class="collapse" for="c-40281599">[-]</label><label class="expand" for="c-40281599">[3 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even need a ctypes import for it, you&#x27;ll get a segfault from this:<p><pre><code>   eval((lambda:0).__code__.replace(co_consts=()))
</code></pre>
cpython is not memory safe.</div><br/><div id="40281865" class="c"><input type="checkbox" id="c-40281865" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281599">parent</a><span>|</span><a href="#40281328">next</a><span>|</span><label class="collapse" for="c-40281865">[-]</label><label class="expand" for="c-40281865">[2 more]</label></div><br/><div class="children"><div class="content">Static analysis of Python code should include review of &quot;unsafe&quot; things like exec(), eval(), ctypes, c strings, memcpy (*),.<p>Containers are considered nearly sufficient to sandbox Python, which cannot be effectively sandboxed using Python itself. Isn&#x27;t that actually true for all languages though?<p>There&#x27;s a RustPython, but it does support CFFI and __builtins__.eval, so</div><br/><div id="40282639" class="c"><input type="checkbox" id="c-40282639" checked=""/><div class="controls bullet"><span class="by">maple3142</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281865">parent</a><span>|</span><a href="#40281328">next</a><span>|</span><label class="collapse" for="c-40282639">[-]</label><label class="expand" for="c-40282639">[1 more]</label></div><br/><div class="children"><div class="content">The example given by parent does not need eval to trigger though. Just create a function and replace its code object then call it, it will easily segfault.</div><br/></div></div></div></div></div></div></div></div><div id="40281328" class="c"><input type="checkbox" id="c-40281328" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40281322">parent</a><span>|</span><a href="#40281333">prev</a><span>|</span><a href="#40282346">next</a><span>|</span><label class="collapse" for="c-40281328">[-]</label><label class="expand" for="c-40281328">[7 more]</label></div><br/><div class="children"><div class="content">Is this supposed to be a joke?<p>Have a look at the linked article to see what meaning of &#x27;unsafe&#x27; the author has in mind.</div><br/><div id="40281365" class="c"><input type="checkbox" id="c-40281365" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281328">parent</a><span>|</span><a href="#40282346">next</a><span>|</span><label class="collapse" for="c-40281365">[-]</label><label class="expand" for="c-40281365">[6 more]</label></div><br/><div class="children"><div class="content">Safety is catching (more) errors ahead of time ...for which Python is grossly unsuitable imo.<p>Fun lang though, just not one that ever comes to mind when I hear &#x27;safe&#x27;.</div><br/><div id="40281397" class="c"><input type="checkbox" id="c-40281397" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281365">parent</a><span>|</span><a href="#40281383">next</a><span>|</span><label class="collapse" for="c-40281397">[-]</label><label class="expand" for="c-40281397">[1 more]</label></div><br/><div class="children"><div class="content">Memory corruption vs type safety.<p>&quot;Safety&quot; is an overloaded term, but that happens a lot in software.  You&#x27;ll probably get best results if you try to understand what people are talking about, rather than just assuming everyone else is an idiot.</div><br/></div></div><div id="40281383" class="c"><input type="checkbox" id="c-40281383" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281365">parent</a><span>|</span><a href="#40281397">prev</a><span>|</span><a href="#40282346">next</a><span>|</span><label class="collapse" for="c-40281383">[-]</label><label class="expand" for="c-40281383">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one definition of safety.  But it&#x27;s not the one the author uses in this case.<p>The generic snide about Python that has nothing to do with the article ain&#x27;t all that informative.<p>You could make the same remark you just made about all Python being unsafe about Rust: &#x27;Isn&#x27;t all Rust, by design, unsafe?&#x27;.  And compared to eg Agda or Idris that would be true, but it wouldn&#x27;t be a very useful nor interesting comment when talking about specifically &#x27;unsafe&#x27; Rust vs normal Rust.</div><br/><div id="40281430" class="c"><input type="checkbox" id="c-40281430" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281383">parent</a><span>|</span><a href="#40282346">next</a><span>|</span><label class="collapse" for="c-40281430">[-]</label><label class="expand" for="c-40281430">[3 more]</label></div><br/><div class="children"><div class="content">I would agree, Rust is not safe. We need to encourage more formal rigor in our craft and avoid misconceptions like &#x27;safe Rust&#x27; or &#x27;safe Python&#x27;. Thus my original comment :P</div><br/><div id="40281553" class="c"><input type="checkbox" id="c-40281553" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281430">parent</a><span>|</span><a href="#40281520">next</a><span>|</span><label class="collapse" for="c-40281553">[-]</label><label class="expand" for="c-40281553">[1 more]</label></div><br/><div class="children"><div class="content">It’s a term of art in this case. Or someone proposed the term improper noun <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32673100">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32673100</a><p>Fine and good to advocate rigor, whether or not it’s specifically relevant to this post, but maybe be careful with the interpretation and commentary lest people decide the misconception is on your part?</div><br/></div></div><div id="40281520" class="c"><input type="checkbox" id="c-40281520" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40281322">root</a><span>|</span><a href="#40281430">parent</a><span>|</span><a href="#40281553">prev</a><span>|</span><a href="#40282346">next</a><span>|</span><label class="collapse" for="c-40281520">[-]</label><label class="expand" for="c-40281520">[1 more]</label></div><br/><div class="children"><div class="content">Eh, even Agda is only safe in the sense of &#x27;does what you&#x27;ve proven it to do&#x27;.  That doesn&#x27;t mean that if you eg write a machine learning library in Agda, your AI won&#x27;t come and turn us all into paperclips.<p>So it doesn&#x27;t really make sense to pretend there&#x27;s some single meaning of &#x27;safe&#x27; vs &#x27;unsafe&#x27; that&#x27;s appropriate in all contexts.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40282346" class="c"><input type="checkbox" id="c-40282346" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#40281322">prev</a><span>|</span><label class="collapse" for="c-40282346">[-]</label><label class="expand" for="c-40282346">[1 more]</label></div><br/><div class="children"><div class="content">Clickbait title. The speedup only applies to one particular interaction between SDL and numpy.</div><br/></div></div></div></div></div></div></div></body></html>