<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732611672515" as="style"/><link rel="stylesheet" href="styles.css?v=1732611672515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://herecomesthemoon.net/2024/11/two-factions-of-cpp/">The two factions of C++</a>Â <span class="domain">(<a href="https://herecomesthemoon.net">herecomesthemoon.net</a>)</span></div><div class="subtext"><span>cyclopeanutopia</span> | <span>422 comments</span></div><br/><div><div id="42232183" class="c"><input type="checkbox" id="c-42232183" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42232004">next</a><span>|</span><label class="collapse" for="c-42232183">[-]</label><label class="expand" for="c-42232183">[155 more]</label></div><br/><div class="children"><div class="content">I compile a lot of C++ code from a lot of places, and the only time I run into code that somehow simply <i>doesn&#x27;t work</i> on newer versions of C++ and where the developers aren&#x27;t even sure if they will accept any patches to fix the issue as they claim it &quot;isn&#x27;t supported&quot; to use a newer version of C++--even for the public headers of a library--is, you guessed it: code from Google.<p>Meanwhile, most of the C++ code from Google seems to be written in some mishmash of different ideas, always at some halfway point along a migration between something ancient and something passable... but never anything I would ever dare to call &quot;modern&quot;, and thereby tends to be riddled with state machines and manual weak pointers that lead to memory corruption.<p>So... I really am not sure I buy the entire premise of this article? Honestly, I am extremely glad that Google is finally leaving the ecosystem, as I generally do not enjoy it when Google engineers try to force their ridiculous use cases down peoples&#x27; throats, as they seem to believe they simply know better than everyone else how to develop software.<p>Like... I honestly feel bad for the Rust people, as I do not think the increasing attention they are going to get from Google is going to be at all positive for that ecosystem, any more than I think the massive pressure Google has exerted on the web has been positive or any more than the pressure Google even exerted on Python was positive (not that Python caved to much of it, but the pressure was on and the fact that Python refused to play ball with Google was in no small part what caused Go to exist at all).<p>(FWIW, I do miss Microsoft&#x27;s being in the space, but they honestly left years ago -- Herb&#x27;s existence until recent being kind of a token consideration -- as they have been trying to figure out a tactical exit to C++ ever since Visual J++ and, arguably, Visual Basic, having largely managed to pivot to C# and TypeScript for SDKs long ago. That said... Sun kicking Microsoft out of Java might have been really smart, despite the ramifications?)</div><br/><div id="42235403" class="c"><input type="checkbox" id="c-42235403" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42239400">next</a><span>|</span><label class="collapse" for="c-42235403">[-]</label><label class="expand" for="c-42235403">[48 more]</label></div><br/><div class="children"><div class="content">&gt; code from Google.<p>I spilled my coffee, I was just talking the other day to some coworkers how I don&#x27;t trust google open source. Sure they open their code but they don&#x27;t give a damn about contributions or making it easy for you to use the projects. I feel a lot of this sentiment extends to GCP as well.<p>So many google projects are better than your average community one, but they never gain traction outside of google because it is just too damn hard to use them outside of google infra.<p>The only Google project that seems to evade this rule that I know of is Go.</div><br/><div id="42238047" class="c"><input type="checkbox" id="c-42238047" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235403">parent</a><span>|</span><a href="#42235981">next</a><span>|</span><label class="collapse" for="c-42238047">[-]</label><label class="expand" for="c-42238047">[14 more]</label></div><br/><div class="children"><div class="content">&gt;  but they don&#x27;t give a damn about contributions<p>Here is a concrete reason why Google open source sucks when it comes to contributions and I don&#x27;t think it can be improved unless Google changes things drastically: (1) an external contributor makes a nice change and a PR on GitHub; (2) the change breaks internal use cases and their tests; (3) the team is unwilling to fix the PR or port the internal test (which may be a test several layers down the dependency tree) to open source.<p>&gt; making it easy for you to use the projects<p>Google internally use Blaze, a version of Bazel. It&#x27;s so ridiculously easy for one team to use another team&#x27;s project that even just thinking about what the rest of us needs to do to use another project is unloved dreadful work. So people don&#x27;t make that effort.<p>I do not see either of these two points changing. Sure there are individuals at Google that really care about open source community, but most don&#x27;t, and so their project is forever a cathedral not a bazaar.</div><br/><div id="42238345" class="c"><input type="checkbox" id="c-42238345" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238047">parent</a><span>|</span><a href="#42238561">next</a><span>|</span><label class="collapse" for="c-42238345">[-]</label><label class="expand" for="c-42238345">[6 more]</label></div><br/><div class="children"><div class="content">It is not only that, but often when google uses an open source project not owned by them they either try to take ownership of the project or fork it instead of trying to contribute to the original.</div><br/><div id="42239444" class="c"><input type="checkbox" id="c-42239444" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238345">parent</a><span>|</span><a href="#42238561">next</a><span>|</span><label class="collapse" for="c-42239444">[-]</label><label class="expand" for="c-42239444">[5 more]</label></div><br/><div class="children"><div class="content">Which cases did you have in mind? Seems like it should be easy to find half a dozen examples since you claim it happens often.</div><br/><div id="42240581" class="c"><input type="checkbox" id="c-42240581" checked=""/><div class="controls bullet"><span class="by">Create</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239444">parent</a><span>|</span><a href="#42238561">next</a><span>|</span><label class="collapse" for="c-42240581">[-]</label><label class="expand" for="c-42240581">[4 more]</label></div><br/><div class="children"><div class="content">KHTML, officially discontinued in 2023. -- &quot;Embrace, extend, and extinguish&quot; (EEE) also known as &quot;embrace, extend, and exterminate&quot;, is a phrase that the U.S. Department of Justice.  It&#x27;s also possible that President-elect Donald Trump may interfere with the DOJ&#x27;s proposed remedies; he said on the campaign trail that a Google break-up may not be desirable since it could &quot;destroy&quot; a company that the US highly values.</div><br/><div id="42240762" class="c"><input type="checkbox" id="c-42240762" checked=""/><div class="controls bullet"><span class="by">jsnell</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42240581">parent</a><span>|</span><a href="#42238561">next</a><span>|</span><label class="collapse" for="c-42240762">[-]</label><label class="expand" for="c-42240762">[3 more]</label></div><br/><div class="children"><div class="content">The GP&#x27;s complaint was that Google &quot;took over projects&quot; or &quot;forked them without trying to contribute to the original&quot;.<p>In the case of KHTML, they never used it in the first place, so it seems like a particularly inappropriate example. I assume you actually meant Webkit? In that case, they spent half a decade and thousands of engineer-years contributing to Webkit, so it doesn&#x27;t fit the original complaint about not &quot;trying to contribute&quot; either.</div><br/><div id="42240930" class="c"><input type="checkbox" id="c-42240930" checked=""/><div class="controls bullet"><span class="by">Create</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42240762">parent</a><span>|</span><a href="#42238561">next</a><span>|</span><label class="collapse" for="c-42240930">[-]</label><label class="expand" for="c-42240930">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   November 4, 1998; 26 years ago (KHTML released)
   June 7, 2005; 19 years ago (WebKit sourced)
</code></pre>
<a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromium&#x2F;src&#x2F;+&#x2F;HEAD&#x2F;third_party&#x2F;blink&#x2F;renderer&#x2F;core&#x2F;css&#x2F;css_grouping_rule.h" rel="nofollow">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromium&#x2F;src&#x2F;+&#x2F;HEAD&#x2F;third_...</a><p><pre><code>   * (C) 1999-2003 Lars Knoll (knoll@kde.org)
   * (C) 2002-2003 Dirk Mueller (mueller@kde.org)
   * Copyright (C) 2002, 2006, 2008, 2012 Apple Inc. All rights reserved.
   * Copyright (C) 2006 Samuel Weinig (sam@webkit.org)
</code></pre>
&quot;...<i>they never used it in the first place</i>&quot;</div><br/><div id="42241099" class="c"><input type="checkbox" id="c-42241099" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42240930">parent</a><span>|</span><a href="#42238561">next</a><span>|</span><label class="collapse" for="c-42241099">[-]</label><label class="expand" for="c-42241099">[1 more]</label></div><br/><div class="children"><div class="content">I think the point is that KHTML was already forked into webkit by apple long before google came along (though, they have in fact also now forked webkit into blink).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42238561" class="c"><input type="checkbox" id="c-42238561" checked=""/><div class="controls bullet"><span class="by">rahkiin</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238047">parent</a><span>|</span><a href="#42238345">prev</a><span>|</span><a href="#42235981">next</a><span>|</span><label class="collapse" for="c-42238561">[-]</label><label class="expand" for="c-42238561">[7 more]</label></div><br/><div class="children"><div class="content">One could ask whether Google works âopen sourceâ or more âsource availableâ; the source is there but you cannot contribute, if you can build it at all</div><br/><div id="42238827" class="c"><input type="checkbox" id="c-42238827" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238561">parent</a><span>|</span><a href="#42235981">next</a><span>|</span><label class="collapse" for="c-42238827">[-]</label><label class="expand" for="c-42238827">[6 more]</label></div><br/><div class="children"><div class="content">No, &quot;open source&quot; doesn&#x27;t imply open contribution. The standard terminology is cathedral vs bazaar.</div><br/><div id="42239124" class="c"><input type="checkbox" id="c-42239124" checked=""/><div class="controls bullet"><span class="by">interroboink</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238827">parent</a><span>|</span><a href="#42235981">next</a><span>|</span><label class="collapse" for="c-42239124">[-]</label><label class="expand" for="c-42239124">[5 more]</label></div><br/><div class="children"><div class="content">Just to add a different perspective: sometimes people mean Open Source[1] when they say &quot;open source,&quot; and sometimes they don&#x27;t.<p>Personally, I take the cathedral&#x2F;bazaar distinction to indicate different development cadences and philosophies, rather than whether contributions are allowed&#x2F;encouraged.<p>Various cathedral-style projects (eg: FreeBSD, Emacs) still actively take contributions and encourage involvement.<p>There&#x27;s something even further along the spectrum that&#x27;s &quot;we provide dumps of source code, but don&#x27;t really want your patches.&quot; I&#x27;m not sure what the best term is for that, but &quot;source [merely] available&quot; sometimes has that connotation.<p>[1] <a href="https:&#x2F;&#x2F;opensource.org&#x2F;osd" rel="nofollow">https:&#x2F;&#x2F;opensource.org&#x2F;osd</a></div><br/><div id="42239162" class="c"><input type="checkbox" id="c-42239162" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239124">parent</a><span>|</span><a href="#42241404">next</a><span>|</span><label class="collapse" for="c-42239162">[-]</label><label class="expand" for="c-42239162">[3 more]</label></div><br/><div class="children"><div class="content">The quintessential example for providing source and discouraging contributions is SQLite. Nobody would argue that it&#x27;s merely source available. It is full open source.<p>In fact &quot;source available&quot; usually means you can see the source code, but there are severe restrictions on the source, such as no permission to modify the source even for your own use, or no permission to create forks of the project containing the modifications, or severe restrictions on such modifications. An example is MongoDB&#x27;s Server Side Public License, which is source-available but not open source.</div><br/><div id="42240833" class="c"><input type="checkbox" id="c-42240833" checked=""/><div class="controls bullet"><span class="by">steve_gh</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239162">parent</a><span>|</span><a href="#42241404">next</a><span>|</span><label class="collapse" for="c-42240833">[-]</label><label class="expand" for="c-42240833">[2 more]</label></div><br/><div class="children"><div class="content">I think it depends on the contribution. I sent a bug report with a minimal test case. It was welcomed and quickly fixed. It is not a source code contribution, but I think it is a contribution.</div><br/><div id="42241408" class="c"><input type="checkbox" id="c-42241408" checked=""/><div class="controls bullet"><span class="by">odo1242</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42240833">parent</a><span>|</span><a href="#42241404">next</a><span>|</span><label class="collapse" for="c-42241408">[-]</label><label class="expand" for="c-42241408">[1 more]</label></div><br/><div class="children"><div class="content">OP is specifically talking about code contributions. You can (I have) make that type of contribution to proprietary software.</div><br/></div></div></div></div></div></div><div id="42241404" class="c"><input type="checkbox" id="c-42241404" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239124">parent</a><span>|</span><a href="#42239162">prev</a><span>|</span><a href="#42235981">next</a><span>|</span><label class="collapse" for="c-42241404">[-]</label><label class="expand" for="c-42241404">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sometimes people mean Open Source[1] when they say &quot;open source,&quot; and sometimes they don&#x27;t.<p>And when they don&#x27;t when talking about source code, they are wrong. If someone says that an RJ45 cable is &quot;a piece of software&quot; because it&#x27;s &quot;soft&quot; (you can bend it), would you say it&#x27;s just a different perspective?<p>Open source, in the context of software, has a particular meaning. And it is the case that many software developers don&#x27;t know it, so it&#x27;s worth teaching them.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42235981" class="c"><input type="checkbox" id="c-42235981" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235403">parent</a><span>|</span><a href="#42238047">prev</a><span>|</span><a href="#42238157">next</a><span>|</span><label class="collapse" for="c-42235981">[-]</label><label class="expand" for="c-42235981">[24 more]</label></div><br/><div class="children"><div class="content">Googletest is the most widely used test library for C++. Googlemock is the only mocking library available that&#x27;s reasonably feature complete.</div><br/><div id="42236555" class="c"><input type="checkbox" id="c-42236555" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235981">parent</a><span>|</span><a href="#42237710">next</a><span>|</span><label class="collapse" for="c-42236555">[-]</label><label class="expand" for="c-42236555">[10 more]</label></div><br/><div class="children"><div class="content">I you are using googletest, you owe it to yourself to check out catch2 which I find much better and uses modern C++.  There are a few other test frameworks in C++ that look better than google test as well,  but catch2 is the one I settled on (and seems to be the best supported): feel free to check them out.<p>I&#x27;ve given up on mock frameworks.  They make it too easy to make an interface for everything and then test that you are calling functions with the expected parameters instead of the program works as you want.  A slight change to how I call some function results in 1000 failed tests and yet I&#x27;m confident that I didn&#x27;t break anything the user could notice (sometimes I&#x27;m wrong in this confidence - but none of the failing tests give me any clue that I&#x27;m wrong!)</div><br/><div id="42237053" class="c"><input type="checkbox" id="c-42237053" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236555">parent</a><span>|</span><a href="#42236788">next</a><span>|</span><label class="collapse" for="c-42237053">[-]</label><label class="expand" for="c-42237053">[4 more]</label></div><br/><div class="children"><div class="content">catch2 has become fairly bloated. doctest takes all of the best parts of catch2 without all the bloat and the end result is a test framework that is literally over 10x faster than catch2. It&#x27;s also like 90% compatible with catch2 so porting your tests to it is pretty easy.<p>Especially if you have a build process that always runs your unit tests, it&#x27;s nice to have a very fast test&#x2F;compile&#x2F;debug loop.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;doctest&#x2F;doctest">https:&#x2F;&#x2F;github.com&#x2F;doctest&#x2F;doctest</a></div><br/><div id="42238906" class="c"><input type="checkbox" id="c-42238906" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237053">parent</a><span>|</span><a href="#42237144">next</a><span>|</span><label class="collapse" for="c-42238906">[-]</label><label class="expand" for="c-42238906">[2 more]</label></div><br/><div class="children"><div class="content">&gt;catch2 has become fairly bloated. doctest takes all of the best parts of catch2 without all the bloat and the end result is a test framework that is literally over 10x faster than catch2. It&#x27;s also like 90% compatible with catch2 so porting your tests to it is pretty easy.<p>I feel like you could make a madlib where you could plug in any two project names and this sentence would make sense.</div><br/><div id="42239252" class="c"><input type="checkbox" id="c-42239252" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238906">parent</a><span>|</span><a href="#42237144">next</a><span>|</span><label class="collapse" for="c-42239252">[-]</label><label class="expand" for="c-42239252">[1 more]</label></div><br/><div class="children"><div class="content">Madlibs have become fairly bloated. Copypasta memes take all the best parts of madlibs without all the bloat and the end result is a form of mockery is literally over 10x faster than a madlib. It&#x27;s also like 90% compatible with madlibs so porting your gibes is pretty easy.</div><br/></div></div></div></div><div id="42237144" class="c"><input type="checkbox" id="c-42237144" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237053">parent</a><span>|</span><a href="#42238906">prev</a><span>|</span><a href="#42236788">next</a><span>|</span><label class="collapse" for="c-42237144">[-]</label><label class="expand" for="c-42237144">[1 more]</label></div><br/><div class="children"><div class="content">I was just about to suggest doctest, you beat me to it! I&#x27;m all about faster compile times, and it was mostly a drop-in replacement for catch2 in my case.<p>Also, IMO, both doctest and catch2 are far superior to Google Test.</div><br/></div></div></div></div><div id="42236788" class="c"><input type="checkbox" id="c-42236788" checked=""/><div class="controls bullet"><span class="by">ehoh</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236555">parent</a><span>|</span><a href="#42237053">prev</a><span>|</span><a href="#42237661">next</a><span>|</span><label class="collapse" for="c-42236788">[-]</label><label class="expand" for="c-42236788">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like the mocks are overused or used inappropriately in your experience (whether by a colleague or yourself).<p>Mocks have their place. A prototypical example is at user-visible endpoints (eg: a mock client).</div><br/><div id="42237022" class="c"><input type="checkbox" id="c-42237022" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236788">parent</a><span>|</span><a href="#42237661">next</a><span>|</span><label class="collapse" for="c-42237022">[-]</label><label class="expand" for="c-42237022">[1 more]</label></div><br/><div class="children"><div class="content">I have found in my world it is easy to setup a test database (we use sqlite!) and the file system is fast enough (I have code to force using a different directory for files).  I have been playing with starting a dbus server on a different port in my tests and then starting the real server to test against (with mixed results - I need a better way to know when dbus is running).  I have had great success by writing a fake for one service that is painful - the fake tracks the information I really care about and so lets me query on things that matter not what the function signature was.<p>I&#x27;m not arguing that mocks don&#x27;t have their place. However I have found that by declaring I won&#x27;t use them at all I overall come up with better solutions and thus better tests.</div><br/></div></div></div></div><div id="42237661" class="c"><input type="checkbox" id="c-42237661" checked=""/><div class="controls bullet"><span class="by">amalcon</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236555">parent</a><span>|</span><a href="#42236788">prev</a><span>|</span><a href="#42237710">next</a><span>|</span><label class="collapse" for="c-42237661">[-]</label><label class="expand" for="c-42237661">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found exactly three places where I really want to have a mock available:<p>1) Databases and other persistent storage.  Though in this case, the best mock for a database is generally another (smaller, easily snapshottable) database, not something like googlemock.<p>2) Network and other places where the hardware really matters.  Sometimes, I <i>really</i> want to drop a particular message, to exercise some property of the sender.  This is often possible to code around in greenfield projects, but in existing code it can be much simpler to just mock the network out.<p>3) Cases where I am calling out to some external black-box.  Sometimes it&#x27;s impractical to replicate the entire black-box in my test.  This could be e.g. because it is a piece of specialized hardware, or it&#x27;s non-deterministic in a way that I&#x27;d prefer my test not to be.  I don&#x27;t want to <i>actually</i> call out to an external black-box (hygiene), so some kind of a mock is more or less necessary.</div><br/><div id="42237867" class="c"><input type="checkbox" id="c-42237867" checked=""/><div class="controls bullet"><span class="by">eddautomates</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237661">parent</a><span>|</span><a href="#42237710">next</a><span>|</span><label class="collapse" for="c-42237867">[-]</label><label class="expand" for="c-42237867">[2 more]</label></div><br/><div class="children"><div class="content">For 1 have you looked at test containers?</div><br/><div id="42238586" class="c"><input type="checkbox" id="c-42238586" checked=""/><div class="controls bullet"><span class="by">amalcon</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237867">parent</a><span>|</span><a href="#42237710">next</a><span>|</span><label class="collapse" for="c-42238586">[-]</label><label class="expand" for="c-42238586">[1 more]</label></div><br/><div class="children"><div class="content">Briefly, but frankly:  copying small SQLite files around works so well in almost all cases that I don&#x27;t feel the need for a new abstraction.</div><br/></div></div></div></div></div></div></div></div><div id="42237710" class="c"><input type="checkbox" id="c-42237710" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235981">parent</a><span>|</span><a href="#42236555">prev</a><span>|</span><a href="#42236538">next</a><span>|</span><label class="collapse" for="c-42237710">[-]</label><label class="expand" for="c-42237710">[9 more]</label></div><br/><div class="children"><div class="content">I used to really like Google Test, and then Google decided in it&#x27;s infinite wisdom to make the OSS version depend on their C++ shared library replacement Abseil, and not just that but the live at head version.<p>That makes sense internally for Google because they have their massive monorepo, but it sure as hell makes it a pain in the ass to adopt for everyone else.</div><br/><div id="42237980" class="c"><input type="checkbox" id="c-42237980" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237710">parent</a><span>|</span><a href="#42236538">next</a><span>|</span><label class="collapse" for="c-42237980">[-]</label><label class="expand" for="c-42237980">[8 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;re reading those docs correctly. Googletest recommends living at head, but there&#x27;s no reason you can&#x27;t pin a release, either a git commit hash or a release label, of which there have been several. Googletest does not depend on the HEAD of abseil-cpp, it actually declares a direct dependency on an older LTS release of absl, but since you are building it from source any later release or commit of absl would work.<p>Google open source libraries are often a mess when you try to include more than one of them in the same project, but googletest isn&#x27;t an example of the mess. It&#x27;s actually pretty straightforward.</div><br/><div id="42238767" class="c"><input type="checkbox" id="c-42238767" checked=""/><div class="controls bullet"><span class="by">james_promoted</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237980">parent</a><span>|</span><a href="#42239659">next</a><span>|</span><label class="collapse" for="c-42238767">[-]</label><label class="expand" for="c-42238767">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Google open source libraries are often a mess when you try to include more than one of them in the same project<p>Completely agree. In isolation all of their libs are great, but inevitably I end up having to build Abseil from source, to then build Protobuf off of that, to then build gRPC off of that. If I can include the sanitizers under Google then that also becomes painful because Abseil (at least) will have ABI issues if it isn&#x27;t built appropriately.
Thinking about it I&#x27;d really just like a flat_hash_map replacement so I can drop Abseil.</div><br/><div id="42240621" class="c"><input type="checkbox" id="c-42240621" checked=""/><div class="controls bullet"><span class="by">Doctor_Fegg</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238767">parent</a><span>|</span><a href="#42242494">next</a><span>|</span><label class="collapse" for="c-42240621">[-]</label><label class="expand" for="c-42240621">[2 more]</label></div><br/><div class="children"><div class="content">Protobuf depending on Abseil (which has ongoing macOS build issues) is clinically insane. I tend to use protozero now which trades half a dayâs boilerplate for two daysâ build heartache.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mapbox&#x2F;protozero">https:&#x2F;&#x2F;github.com&#x2F;mapbox&#x2F;protozero</a></div><br/><div id="42240909" class="c"><input type="checkbox" id="c-42240909" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42240621">parent</a><span>|</span><a href="#42242494">next</a><span>|</span><label class="collapse" for="c-42240909">[-]</label><label class="expand" for="c-42240909">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t it be even more insane if protobuf had its own distinct string splitting&#x2F;merging routines, its own flags and logging libraries, etc?</div><br/></div></div></div></div><div id="42242494" class="c"><input type="checkbox" id="c-42242494" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238767">parent</a><span>|</span><a href="#42240621">prev</a><span>|</span><a href="#42239271">next</a><span>|</span><label class="collapse" for="c-42242494">[-]</label><label class="expand" for="c-42242494">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Thinking about it I&#x27;d really just like a flat_hash_map replacement so I can drop Abseil.<p>boost has a flat_hash_map implementation for quite a few versions now, which from what I could see generally beat or is competitive with the absl implementation: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;yikfi4&#x2F;boost_181_will_have_boostunordered_flat_map&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;cpp&#x2F;comments&#x2F;yikfi4&#x2F;boost_181_will_...</a></div><br/></div></div><div id="42239271" class="c"><input type="checkbox" id="c-42239271" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238767">parent</a><span>|</span><a href="#42242494">prev</a><span>|</span><a href="#42239659">next</a><span>|</span><label class="collapse" for="c-42239271">[-]</label><label class="expand" for="c-42239271">[2 more]</label></div><br/><div class="children"><div class="content">FWIW the flat hash map in Boost is now faster. I am not sure if integrating Boost is any easier for you.</div><br/><div id="42241184" class="c"><input type="checkbox" id="c-42241184" checked=""/><div class="controls bullet"><span class="by">james_promoted</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239271">parent</a><span>|</span><a href="#42239659">next</a><span>|</span><label class="collapse" for="c-42241184">[-]</label><label class="expand" for="c-42241184">[1 more]</label></div><br/><div class="children"><div class="content">I occasionally reconsider it so I can try a bunch of the FB alternatives (Folly, Thrift, CacheLib, etc.), but... yeah. Still just kind of waiting for a panacea.</div><br/></div></div></div></div></div></div><div id="42239659" class="c"><input type="checkbox" id="c-42239659" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237980">parent</a><span>|</span><a href="#42238767">prev</a><span>|</span><a href="#42236538">next</a><span>|</span><label class="collapse" for="c-42239659">[-]</label><label class="expand" for="c-42239659">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a few years to be fair, I stopped working with C++ in early 2021 or so so maybe I&#x27;ve just misremembered. I do remember having to take Abseil on where we previously didn&#x27;t.</div><br/></div></div></div></div></div></div><div id="42236538" class="c"><input type="checkbox" id="c-42236538" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235981">parent</a><span>|</span><a href="#42237710">prev</a><span>|</span><a href="#42238157">next</a><span>|</span><label class="collapse" for="c-42236538">[-]</label><label class="expand" for="c-42236538">[4 more]</label></div><br/><div class="children"><div class="content">Google test and mock are quite powerful but are a big hit at both compile time and runtime, which matters for quick edit-compile-fix loops.<p>I still go back and forth on whether google test and mock are worth it.<p>Google benchmark is also nice.</div><br/><div id="42239234" class="c"><input type="checkbox" id="c-42239234" checked=""/><div class="controls bullet"><span class="by">rangestransform</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236538">parent</a><span>|</span><a href="#42237951">next</a><span>|</span><label class="collapse" for="c-42239234">[-]</label><label class="expand" for="c-42239234">[2 more]</label></div><br/><div class="children"><div class="content">&gt; big hit at both compile time and runtime, which matters for quick edit-compile-fix loops<p>honestly if you write C++ for work, there&#x27;s no excuse for your company to not give you the beefiest dev machine that money can reasonably buy. given that rust exists, I think &quot;get a faster computer&quot; is a totally valid answer to build times, especially now that skylake malaise era is over and CPUs are getting faster</div><br/><div id="42239584" class="c"><input type="checkbox" id="c-42239584" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239234">parent</a><span>|</span><a href="#42237951">next</a><span>|</span><label class="collapse" for="c-42239584">[-]</label><label class="expand" for="c-42239584">[1 more]</label></div><br/><div class="children"><div class="content">&gt; given that rust exists, I think &quot;get a faster computer&quot; is a totally valid answer to build times<p>I find this amusing because one of the main reasons i avoid Rust (in the sense that i prefer to build things written in other languages if possible - i don&#x27;t mind if someone else uses it and gives me a binary&#x2F;library i can use - and it never went beyond &quot;i might check this at some point, sometime, maybe&quot; in my mind) is the build times compared to most other compilers :-P.<p>Also, at least personally, if i get a faster computer i want my workflow to be faster.</div><br/></div></div></div></div><div id="42237951" class="c"><input type="checkbox" id="c-42237951" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236538">parent</a><span>|</span><a href="#42239234">prev</a><span>|</span><a href="#42238157">next</a><span>|</span><label class="collapse" for="c-42237951">[-]</label><label class="expand" for="c-42237951">[1 more]</label></div><br/><div class="children"><div class="content">Does it not support only running some or no tests? I only run the full test suite rarely, close to releases.</div><br/></div></div></div></div></div></div><div id="42238157" class="c"><input type="checkbox" id="c-42238157" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235403">parent</a><span>|</span><a href="#42235981">prev</a><span>|</span><a href="#42235698">next</a><span>|</span><label class="collapse" for="c-42238157">[-]</label><label class="expand" for="c-42238157">[2 more]</label></div><br/><div class="children"><div class="content">I blame monorepo culture.  If it doesn&#x27;t grow up in a context where it&#x27;s expected to stand on its own, it crashes and burns when you kick it out of the nest.</div><br/><div id="42239115" class="c"><input type="checkbox" id="c-42239115" checked=""/><div class="controls bullet"><span class="by">DanielHB</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238157">parent</a><span>|</span><a href="#42235698">next</a><span>|</span><label class="collapse" for="c-42239115">[-]</label><label class="expand" for="c-42239115">[1 more]</label></div><br/><div class="children"><div class="content">I heard that Meta also has a monorepo but most of their open source projects are very community driven. I think it is corporate mandate thing, no resources to be spent on open source and not tracking open source contributions as part of career development.</div><br/></div></div></div></div><div id="42235698" class="c"><input type="checkbox" id="c-42235698" checked=""/><div class="controls bullet"><span class="by">badpun</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235403">parent</a><span>|</span><a href="#42238157">prev</a><span>|</span><a href="#42239400">next</a><span>|</span><label class="collapse" for="c-42235698">[-]</label><label class="expand" for="c-42235698">[7 more]</label></div><br/><div class="children"><div class="content">Tensorflow is&#x2F;was decent. It looked like they made a lot of effort for it to be accessible for outsiders.</div><br/><div id="42235830" class="c"><input type="checkbox" id="c-42235830" checked=""/><div class="controls bullet"><span class="by">th2oi34234234</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235698">parent</a><span>|</span><a href="#42239400">next</a><span>|</span><label class="collapse" for="c-42235830">[-]</label><label class="expand" for="c-42235830">[6 more]</label></div><br/><div class="children"><div class="content">Have you tried building the damn thing ?<p>Nix build is still stuck in the one from 3-4 y back because bazel doesn&#x27;t play well. Debian too has some issues building the thing...</div><br/><div id="42238296" class="c"><input type="checkbox" id="c-42238296" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235830">parent</a><span>|</span><a href="#42237937">next</a><span>|</span><label class="collapse" for="c-42238296">[-]</label><label class="expand" for="c-42238296">[1 more]</label></div><br/><div class="children"><div class="content">Having tried on other platforms, it&#x27;s not Bazwl, it&#x27;s not even <i>just</i> Google.<p>It&#x27;s python packaging and the way the only really supported binary distribution method of Tensorflow for many many years was to use Pip and hope it doesn&#x27;t crash. And it&#x27;s reflected in how the TF build scripts only support building python lib as artefact, everything else at the very least involved dissecting bazel intermediate targets</div><br/></div></div><div id="42237937" class="c"><input type="checkbox" id="c-42237937" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235830">parent</a><span>|</span><a href="#42238296">prev</a><span>|</span><a href="#42239400">next</a><span>|</span><label class="collapse" for="c-42237937">[-]</label><label class="expand" for="c-42237937">[4 more]</label></div><br/><div class="children"><div class="content">As an industry we need to stop treating breaking changes as an acceptable thing. The rate of bit rot has accelerated to an absurd pace. I can&#x27;t remember the package but I had to spend considerable time fixing a build because a package.. changed names.. for NO REASON. They just liked the new name better. This should be career death. You&#x27;re wasting your fellow humans&#x27; time and energy on your vanity when you make a breaking change that is at all avoidable. I should be able to run a build script made 20 years ago and it should just work. No renamed package hunting, no WARNING WARNING DEPRECATED REWRITE ALL YOUR CODE FOR LEFTPAD 10.3 IMMEDIATELY in the console, no code changes, no fuss, we should expect it to just work. This state of affairs is a stain on our industry.</div><br/><div id="42242037" class="c"><input type="checkbox" id="c-42242037" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237937">parent</a><span>|</span><a href="#42238480">next</a><span>|</span><label class="collapse" for="c-42242037">[-]</label><label class="expand" for="c-42242037">[1 more]</label></div><br/><div class="children"><div class="content">One day we will have bled enough and we&#x27;ll switch to using cryptographic hashes of package contents (or of some recipe for deterministically building the thing on different architectures) instead of anything so flimsy as a name and version number.<p>For the humans, we can render the hashes as something friendly, but there&#x27;s no reason to confuse the machines with our human notions of friendliness.</div><br/></div></div><div id="42238480" class="c"><input type="checkbox" id="c-42238480" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237937">parent</a><span>|</span><a href="#42242037">prev</a><span>|</span><a href="#42239400">next</a><span>|</span><label class="collapse" for="c-42238480">[-]</label><label class="expand" for="c-42238480">[2 more]</label></div><br/><div class="children"><div class="content">this is why you build to a specific version of a library. drop your build script into a container with the versions of software it expects and it should do fine. containerization is the admittance that versioning environments is needed for most software. I expect the nix&#x2F;guix crowds to win in the end.</div><br/><div id="42242143" class="c"><input type="checkbox" id="c-42242143" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238480">parent</a><span>|</span><a href="#42239400">next</a><span>|</span><label class="collapse" for="c-42242143">[-]</label><label class="expand" for="c-42242143">[1 more]</label></div><br/><div class="children"><div class="content">Blindly wrapping a build script in a Dockerfile is not nothing, but it&#x27;s no replacement for being careful while writing that script in the first place.<p>Otherwise I agree, because if you must be careful, you might as well use tooling that&#x27;s built for such care.  But if you&#x27;re doing that, do you need the Dockerfile?  And that&#x27;s how you end up with nix&#x2F;guix.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42239400" class="c"><input type="checkbox" id="c-42239400" checked=""/><div class="controls bullet"><span class="by">groos</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42235403">prev</a><span>|</span><a href="#42234375">next</a><span>|</span><label class="collapse" for="c-42239400">[-]</label><label class="expand" for="c-42239400">[1 more]</label></div><br/><div class="children"><div class="content">Whatever gave you the idea Microsoft &quot;left&quot; C++ years ago? It has massive code bases in C++ and continues to invest in its compiler teams and actively tracks the C++ standard. It was the first compiler to implement C++20 mostly completely, including modules, which other compilers have yet to catch up to. Like other mature companies, Microsoft realized decades ago that they can be a one-tech-dependent company and hence has code in C++ and .NET, and is now exploring Rust.</div><br/></div></div><div id="42234375" class="c"><input type="checkbox" id="c-42234375" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42239400">prev</a><span>|</span><a href="#42237462">next</a><span>|</span><label class="collapse" for="c-42234375">[-]</label><label class="expand" for="c-42234375">[15 more]</label></div><br/><div class="children"><div class="content">The issue with Microsoft until recently, has been the power of WinDev, which are the ones responsible for anything C++ on Microsoft dungeons.<p>Hence the failure of Longhorn, or any attempt coming out from Microsoft Research.<p>Ironically, given your Sun remark, Microsoft is back into the Java game, having their own distribution of OpenJDK, and Java is usually the only ecosystem that has day one parity with anything Azure puts out as .NET SDK.</div><br/><div id="42238041" class="c"><input type="checkbox" id="c-42238041" checked=""/><div class="controls bullet"><span class="by">memsom</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42234375">parent</a><span>|</span><a href="#42234543">next</a><span>|</span><label class="collapse" for="c-42238041">[-]</label><label class="expand" for="c-42238041">[3 more]</label></div><br/><div class="children"><div class="content">I use the Microsoft JDK daily - to develop in Maui for Android. Other than that, I&#x27;m not too sure what anyone would use it for over the actual OpenJDK versions. I&#x27;m pretty sure the MS OpenJDK is mostly there to support pushing people to Azure (hence your observation) and Android. I don&#x27;t think it is there for much else outside of that, but I&#x27;m happy to stand corrected if anyone has another use cas for it.</div><br/><div id="42238281" class="c"><input type="checkbox" id="c-42238281" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238041">parent</a><span>|</span><a href="#42234543">next</a><span>|</span><label class="collapse" for="c-42238281">[-]</label><label class="expand" for="c-42238281">[2 more]</label></div><br/><div class="children"><div class="content">It was thanks to Microsoft that you get to enjoy the JVM on ARM for example, or better escape analysis.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;openjdk-aarch64">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;openjdk-aarch64</a><p><a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;news&#x2F;2023&#x2F;02&#x2F;microsoft-openjdk-feature&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.infoq.com&#x2F;news&#x2F;2023&#x2F;02&#x2F;microsoft-openjdk-feature...</a></div><br/><div id="42240186" class="c"><input type="checkbox" id="c-42240186" checked=""/><div class="controls bullet"><span class="by">memsom</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238281">parent</a><span>|</span><a href="#42234543">next</a><span>|</span><label class="collapse" for="c-42240186">[-]</label><label class="expand" for="c-42240186">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but the first link is surely only benefiting those using Windows on ARM? I do have Windows on ARM on a MacBook under VMWare, but my daily usage of Windows is under x64. Second link - not really knowing much about Java I don&#x27;t know enough to comment. 99% of my Java use is indirect because it only gets touched by MSBuild when compiling my APK from C#.</div><br/></div></div></div></div></div></div><div id="42234543" class="c"><input type="checkbox" id="c-42234543" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42234375">parent</a><span>|</span><a href="#42238041">prev</a><span>|</span><a href="#42237462">next</a><span>|</span><label class="collapse" for="c-42234543">[-]</label><label class="expand" for="c-42234543">[11 more]</label></div><br/><div class="children"><div class="content">What is &quot;WinDev&quot;? A quick search didn&#x27;t turn up much except a French Wikipedia article.</div><br/><div id="42234661" class="c"><input type="checkbox" id="c-42234661" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42234543">parent</a><span>|</span><a href="#42237462">next</a><span>|</span><label class="collapse" for="c-42234661">[-]</label><label class="expand" for="c-42234661">[10 more]</label></div><br/><div class="children"><div class="content">Windows Development, per opposition to DevDiv, Developer Division.<p>Two quite common names in the Microsoft ecosystem.</div><br/><div id="42237983" class="c"><input type="checkbox" id="c-42237983" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42234661">parent</a><span>|</span><a href="#42235114">next</a><span>|</span><label class="collapse" for="c-42237983">[-]</label><label class="expand" for="c-42237983">[5 more]</label></div><br/><div class="children"><div class="content">As a former MS employee some time ago I don&#x27;t think I ever heard &quot;windev&quot;. It was always referred to as &quot;Windows&quot;. Though there were a lot of different groups within that, so sometimes you&#x27;d hear an initialism for a specific team. For example during some of my time there was a big organizational split between &quot;core&quot; and more UI oriented teams.</div><br/><div id="42238258" class="c"><input type="checkbox" id="c-42238258" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237983">parent</a><span>|</span><a href="#42235114">next</a><span>|</span><label class="collapse" for="c-42238258">[-]</label><label class="expand" for="c-42238258">[4 more]</label></div><br/><div class="children"><div class="content">Here is an example in the press, with an email from Somasegar, leader of developer division in the past.<p><a href="https:&#x2F;&#x2F;www.zdnet.com&#x2F;article&#x2F;microsoft-splits-up-its-xaml-team-whats-the-fallout&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.zdnet.com&#x2F;article&#x2F;microsoft-splits-up-its-xaml-t...</a></div><br/><div id="42238349" class="c"><input type="checkbox" id="c-42238349" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238258">parent</a><span>|</span><a href="#42235114">next</a><span>|</span><label class="collapse" for="c-42238349">[-]</label><label class="expand" for="c-42238349">[3 more]</label></div><br/><div class="children"><div class="content">I was an employee in Windows on the date of that email. I left a few months later. Note that the email itself doesn&#x27;t say &quot;windev&quot;. It says &quot;Windows&quot; a bunch of times.<p>If I&#x27;m stretching this &quot;windev&quot; thing, the domain for a lot of employee accounts (including mine) was NTDEV, that had a longer history afaik, nobody called an org that..</div><br/><div id="42238749" class="c"><input type="checkbox" id="c-42238749" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238349">parent</a><span>|</span><a href="#42235114">next</a><span>|</span><label class="collapse" for="c-42238749">[-]</label><label class="expand" for="c-42238749">[2 more]</label></div><br/><div class="children"><div class="content">The journalist writes it though, as do many other folks.<p>I didn&#x27;t come up with this definition myself.<p>If I am not mistaken, I can probably even dig some Sinosfky references using it.</div><br/><div id="42240781" class="c"><input type="checkbox" id="c-42240781" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238749">parent</a><span>|</span><a href="#42235114">next</a><span>|</span><label class="collapse" for="c-42240781">[-]</label><label class="expand" for="c-42240781">[1 more]</label></div><br/><div class="children"><div class="content">I think it was sort of externally derived based on &quot;DevDiv&quot;, but as another former MS employee - albeit from DevDiv - I can confirm that &quot;WinDev&quot; is not something that was routinely used inside the company the way &quot;DevDiv&quot; is. Usually it&#x27;s just &quot;Windows&quot;, or &quot;Windows org&quot; if the context is ambiguous.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42235114" class="c"><input type="checkbox" id="c-42235114" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42234661">parent</a><span>|</span><a href="#42237983">prev</a><span>|</span><a href="#42237462">next</a><span>|</span><label class="collapse" for="c-42235114">[-]</label><label class="expand" for="c-42235114">[4 more]</label></div><br/><div class="children"><div class="content">For a moment there I thought you were referring to this trademark: <a href="https:&#x2F;&#x2F;pcsoft.fr&#x2F;windev&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;pcsoft.fr&#x2F;windev&#x2F;index.html</a>  Which was known at a time for having young women in light clothing in their marketing material.</div><br/><div id="42235962" class="c"><input type="checkbox" id="c-42235962" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235114">parent</a><span>|</span><a href="#42237462">next</a><span>|</span><label class="collapse" for="c-42235962">[-]</label><label class="expand" for="c-42235962">[3 more]</label></div><br/><div class="children"><div class="content">aha, that&#x27;s the windev that comes to mind too. I didn&#x27;t know they were actually a french company, wild that they&#x27;re still around... their ads were plastered everywere in the 2000s.<p>Apparently they have a programming language for which you can &quot;one-click-switch&quot; between english and french for the keywords??? <a href="https:&#x2F;&#x2F;pcsoft.fr&#x2F;windev&#x2F;ebook&#x2F;56&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pcsoft.fr&#x2F;windev&#x2F;ebook&#x2F;56&#x2F;</a></div><br/><div id="42236042" class="c"><input type="checkbox" id="c-42236042" checked=""/><div class="controls bullet"><span class="by">voidfunc</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235962">parent</a><span>|</span><a href="#42237462">next</a><span>|</span><label class="collapse" for="c-42236042">[-]</label><label class="expand" for="c-42236042">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually kind of neat, also I love how the brochure uses the American flag for English...</div><br/><div id="42236639" class="c"><input type="checkbox" id="c-42236639" checked=""/><div class="controls bullet"><span class="by">xbar</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236042">parent</a><span>|</span><a href="#42237462">next</a><span>|</span><label class="collapse" for="c-42236639">[-]</label><label class="expand" for="c-42236639">[1 more]</label></div><br/><div class="children"><div class="content">Yes. I would have preferred that they had used Canadian flags for both.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42237462" class="c"><input type="checkbox" id="c-42237462" checked=""/><div class="controls bullet"><span class="by">fpoling</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42234375">prev</a><span>|</span><a href="#42239746">next</a><span>|</span><label class="collapse" for="c-42237462">[-]</label><label class="expand" for="c-42237462">[1 more]</label></div><br/><div class="children"><div class="content">I second the observation of the state of Google C++. Just look at Chromium. There are a lot of unfinished refactoring there, as if people lost interest the moment the clean refactoring hit a roadblock requiring efforts to communicate with other teams. Only by a sort of direct order from the management things can be completed.</div><br/></div></div><div id="42239746" class="c"><input type="checkbox" id="c-42239746" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42237462">prev</a><span>|</span><a href="#42232925">next</a><span>|</span><label class="collapse" for="c-42239746">[-]</label><label class="expand" for="c-42239746">[8 more]</label></div><br/><div class="children"><div class="content">Being smart, well-educated, and knowing how to program isn&#x27;t good enough for creating great code. It takes experience. I&#x27;ve been programming for 50 years now, and keep finding ways to make code more readable and more maintainable.</div><br/><div id="42241276" class="c"><input type="checkbox" id="c-42241276" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239746">parent</a><span>|</span><a href="#42232925">next</a><span>|</span><label class="collapse" for="c-42241276">[-]</label><label class="expand" for="c-42241276">[7 more]</label></div><br/><div class="children"><div class="content">How do you find gimmicks from Bob Martin like (d + e*g) which in theory are great but to use it in practice would take loads of coaching?</div><br/><div id="42241523" class="c"><input type="checkbox" id="c-42241523" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42241276">parent</a><span>|</span><a href="#42232925">next</a><span>|</span><label class="collapse" for="c-42241523">[-]</label><label class="expand" for="c-42241523">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with that gimmick.<p>One thing I learned, for example, is do not access global immutable state from within a function. All inputs come through the parameters, all outputs through the parameters or the return value.</div><br/><div id="42241694" class="c"><input type="checkbox" id="c-42241694" checked=""/><div class="controls bullet"><span class="by">pizza-wizard</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42241523">parent</a><span>|</span><a href="#42242818">next</a><span>|</span><label class="collapse" for="c-42241694">[-]</label><label class="expand" for="c-42241694">[4 more]</label></div><br/><div class="children"><div class="content">As someone without a lot of experience (in my first dev job now), would you care to expand on this? Does this mean that you wouldnât have a function fn() that manipulates a global variable VAR, but rather youâd pass VAR like fn(VAR)?</div><br/><div id="42242005" class="c"><input type="checkbox" id="c-42242005" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42241694">parent</a><span>|</span><a href="#42242230">next</a><span>|</span><label class="collapse" for="c-42242005">[-]</label><label class="expand" for="c-42242005">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve got the gist of it. By decoupling your function from the state of your application, you can test that function in isolation.<p>For instance, you might be tempted to write a function that opens an HTTP connection, performs an API call, parses the result, and returns it. But you&#x27;ll have a really hard time testing that function. If you decompose it into several tiny functions (one that opens a connection, one that accepts an open connection and performs the call, and one that parses the result), you&#x27;ll have a much easier time testing it.<p>(This clicked for me when I wrote code as I&#x27;ve described, wrote tests for it, and later found several bugs. I realized my tests did nothing and failed to catch my bugs, because the code I&#x27;d written was impossible to test. In general, side effects and global state are the enemies of testability.)<p>You end up with functions that take a lot of arguments (10+), which can feel wrong at first, but it&#x27;s worth it, and IDEs help enormously.<p>This pattern is called dependency injection.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_injection" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_injection</a><p>See also, the &quot;functional core, imperative shell&quot; pattern.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yTkzNHF6rMs" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yTkzNHF6rMs</a></div><br/></div></div><div id="42242230" class="c"><input type="checkbox" id="c-42242230" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42241694">parent</a><span>|</span><a href="#42242005">prev</a><span>|</span><a href="#42242818">next</a><span>|</span><label class="collapse" for="c-42242230">[-]</label><label class="expand" for="c-42242230">[2 more]</label></div><br/><div class="children"><div class="content">To expand on the other reply, some related things:<p>1. don&#x27;t do console I&#x2F;O in leaf functions. Instead, pass a parameter that&#x27;s a &quot;sink&quot; for output, and let the caller decide what do with it. This helps a lot when converting a command line program to a gui program. It also makes it practical to unit test the function<p>2. don&#x27;t allocate storage in a leaf function if the result is to be returned. Try to have storage allocated and free&#x27;d in the same function. It&#x27;s a lot easier to keep track of it that way. Another use of sinks, output ranges, etc.<p>3. separate functions that do a read-only gathering of data, from functions that mutate the data<p>Give these a try. I bet you&#x27;ll like the results!</div><br/><div id="42242763" class="c"><input type="checkbox" id="c-42242763" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42242230">parent</a><span>|</span><a href="#42242818">next</a><span>|</span><label class="collapse" for="c-42242763">[-]</label><label class="expand" for="c-42242763">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Give these a try. I bet you&#x27;ll like the results!<p>It sounds like too many words to refer ro plain old inversion of control and CQRS. They&#x27;re both tried and true techniques.</div><br/></div></div></div></div></div></div><div id="42242818" class="c"><input type="checkbox" id="c-42242818" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42241523">parent</a><span>|</span><a href="#42241694">prev</a><span>|</span><a href="#42232925">next</a><span>|</span><label class="collapse" for="c-42242818">[-]</label><label class="expand" for="c-42242818">[1 more]</label></div><br/><div class="children"><div class="content">Cool I am just confirming my own bias against much of âclean codeâ teachings. That it might be a bit easier to read order of the operations - but no one uses it so it doesnât matter.</div><br/></div></div></div></div></div></div></div></div><div id="42232925" class="c"><input type="checkbox" id="c-42232925" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42239746">prev</a><span>|</span><a href="#42232287">next</a><span>|</span><label class="collapse" for="c-42232925">[-]</label><label class="expand" for="c-42232925">[22 more]</label></div><br/><div class="children"><div class="content">&gt; Honestly, I am extremely glad that Google is finally leaving the ecosystem, as I generally do not enjoy it when Google engineers try to force their ridiculous use cases down peoples&#x27; throats, as they seem to believe they simply know better than everyone else how to develop software.<p>Well, you may be celebrating a bit prematurely then. Google still has a ton of C++ and they haven&#x27;t stopped writing it. It&#x27;s going to take ~forever until Google has left the C++ ecosystem. What <i>did</i> happen was that Google majorly scaled down their efforts in the committee.<p>When it comes to the current schism on how to improve the safety of C++ there are largely two factions:<p>* The Bjarne&#x2F;Herb [1] side that focuses on minimal changes to the code. The idea here is to add different profiles to the language and then [draw the rest of the fucking owl]. The big issue here is that it&#x27;s entirely unclear on how they will achieve temporal and spatial memory safety.<p>* The other side is represented by Sean Baxter and his work on Safe C++. This is basically a whole-sale adoption of Rust&#x27;s semantics. The big issue here is that it&#x27;s effectively introducing a new language that isn&#x27;t <i>C++</i>.<p>Google decided to pursue Carbon and isn&#x27;t a major playing in either of the above efforts. Last time I checked, that language is not not meant to be memory safe.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;BjarneStroustrup&#x2F;profiles">https:&#x2F;&#x2F;github.com&#x2F;BjarneStroustrup&#x2F;profiles</a>
[2] <a href="https:&#x2F;&#x2F;safecpp.org&#x2F;draft.html" rel="nofollow">https:&#x2F;&#x2F;safecpp.org&#x2F;draft.html</a></div><br/><div id="42238380" class="c"><input type="checkbox" id="c-42238380" checked=""/><div class="controls bullet"><span class="by">josh11b</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232925">parent</a><span>|</span><a href="#42236280">next</a><span>|</span><label class="collapse" for="c-42238380">[-]</label><label class="expand" for="c-42238380">[3 more]</label></div><br/><div class="children"><div class="content">(Carbon lang dev here.)<p>Carbon is intended to be memory safe! (Not sure whether you intended to write a double negative there.) There are a few reasons that might not be clear:<p>* Carbon has relatively few people working on it. We currently are prioritizing work on the compiler at the moment, and don&#x27;t yet have the bandwidth to also work on the safety design.<p>* As part of our migration-from-C++ story, where we expect code to transition C++ -&gt; unsafe Carbon -&gt; safe Carbon, we plan on supporting unsafe Carbon code with reasonable ergonomics.<p>* Carbon&#x27;s original focus was on evolvability, and didn&#x27;t focus on safety specifically. Since then it has become clear that memory safety is a requirement for Carbon&#x27;s success, and will be our first test of those evolvability goals. Talks like <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=1ZTJ9omXOQ0" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=1ZTJ9omXOQ0</a> better reflect more recent plans around this topic.</div><br/><div id="42239165" class="c"><input type="checkbox" id="c-42239165" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238380">parent</a><span>|</span><a href="#42240332">next</a><span>|</span><label class="collapse" for="c-42239165">[-]</label><label class="expand" for="c-42239165">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the correction, I appreciate it!<p>The double negative was not intended :)</div><br/></div></div><div id="42240332" class="c"><input type="checkbox" id="c-42240332" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238380">parent</a><span>|</span><a href="#42239165">prev</a><span>|</span><a href="#42236280">next</a><span>|</span><label class="collapse" for="c-42240332">[-]</label><label class="expand" for="c-42240332">[1 more]</label></div><br/><div class="children"><div class="content">Not super familiar with Carbon but .. what&#x27;s the elevator pitch for porting my C++ to unsafe Carbon? Can it be done with an automated refactoring tool or something?<p>I feel like if I&#x27;m gonna go through the whole nightmare of a code port I should get something for it as opposed to just relying on interop</div><br/></div></div></div></div><div id="42236280" class="c"><input type="checkbox" id="c-42236280" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232925">parent</a><span>|</span><a href="#42238380">prev</a><span>|</span><a href="#42238147">next</a><span>|</span><label class="collapse" for="c-42236280">[-]</label><label class="expand" for="c-42236280">[1 more]</label></div><br/><div class="children"><div class="content">People like to always talk about Carbon like that, yet the team is the first to point out anyone that can use something else, should.<p>Carbon is an experiment, that they aren&#x27;t sure how it is going to work out in first place.<p>&gt; &quot;If you can use Rust, ignore Carbon&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;e09bf82d364d8efb70edb55213b31d7260d8fe4f&#x2F;docs&#x2F;project&#x2F;faq.md#if-you-can-use-rust-ignore-carbon">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;e09bf82d...</a><p>&gt; &quot;We want to better understand whether we can build a language that meets our successor language criteria, and whether the resulting language can gather a critical mass of interest within the larger C++ industry and communit&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;e09bf82d364d8efb70edb55213b31d7260d8fe4f&#x2F;README.md#project-status">https:&#x2F;&#x2F;github.com&#x2F;carbon-language&#x2F;carbon-lang&#x2F;blob&#x2F;e09bf82d...</a></div><br/></div></div><div id="42238147" class="c"><input type="checkbox" id="c-42238147" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232925">parent</a><span>|</span><a href="#42236280">prev</a><span>|</span><a href="#42236571">next</a><span>|</span><label class="collapse" for="c-42238147">[-]</label><label class="expand" for="c-42238147">[2 more]</label></div><br/><div class="children"><div class="content">Carbon isn&#x27;t currently memory safe, but Chandler Carruth has made it clear that <i>every</i> security expert he talked to says the same thing: memory safety is a requirement for security.<p>He at least claims that Carbon will have memory safety features such as borrow checking down the line. I guess we&#x27;ll see.</div><br/><div id="42243031" class="c"><input type="checkbox" id="c-42243031" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238147">parent</a><span>|</span><a href="#42236571">next</a><span>|</span><label class="collapse" for="c-42243031">[-]</label><label class="expand" for="c-42243031">[1 more]</label></div><br/><div class="children"><div class="content">Itâs worrying to me that Carbon separates data races and memory safety as two distinct things when data races can easily cause both spatial and temporal memory safety issues. Similarly, type safety, can also cause spatial issues (e.g. many kernel exploits in Darwin were a result of causing type confusion for the SLAB allocator resulting in an exploitable memory safety issue).<p>The entire philosophy errs too much in the direction of âbeing reasonableâ and âpragmaticâ while getting fundamental things wrong.<p>&gt; Over time, safety should evolve using a hybrid compile-time and runtime safety approach to eventually provide a similar level of safety to a language that puts more emphasis on guaranteed safety, such as Rust. However, while Carbon may encourage developers to modify code in support of more efficient safety checks, it will remain important to improve the safety of code for developers who cannot invest into safety-specific code modifications.<p>Thatâs really just paying lip service to Rust without recognizing that the key insight is that optional memory safety isnât memory safety.<p>It is kind of neat just how much Rust has managed to disrupt the C++ ecosystem and dislodge its position.</div><br/></div></div></div></div><div id="42236571" class="c"><input type="checkbox" id="c-42236571" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232925">parent</a><span>|</span><a href="#42238147">prev</a><span>|</span><a href="#42232287">next</a><span>|</span><label class="collapse" for="c-42236571">[-]</label><label class="expand" for="c-42236571">[15 more]</label></div><br/><div class="children"><div class="content">&gt; Herb side that proposes minimal changes<p>Herb is developing a whole second syntax, I wouldn&#x27;t call that minimal changes. And probably the only way to evolve the language at this point, because like you said Sean is introducing a different language entirely, so its not C++ at that point.<p>I really like some of Herb&#x27;s ideas,but it seems less and less likely they&#x27;ll ever be added to C++</div><br/><div id="42236666" class="c"><input type="checkbox" id="c-42236666" checked=""/><div class="controls bullet"><span class="by">darknavi</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236571">parent</a><span>|</span><a href="#42232287">next</a><span>|</span><label class="collapse" for="c-42236666">[-]</label><label class="expand" for="c-42236666">[14 more]</label></div><br/><div class="children"><div class="content">Have you seen some of his recent talks? Lots of underpinnings of cppfront have been added or are in committy.<p>He compares it to the JS&#x2F;TS relationship.</div><br/><div id="42237137" class="c"><input type="checkbox" id="c-42237137" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236666">parent</a><span>|</span><a href="#42236984">next</a><span>|</span><label class="collapse" for="c-42237137">[-]</label><label class="expand" for="c-42237137">[1 more]</label></div><br/><div class="children"><div class="content">Nope, that is mostly sales pitch, the only thing added thus far has been the spaceship operator.<p>He also sells the language differently from any other language that also compiles to native via C++, like Eiffel and Nim among others, due to conflict of interest to have WG21 chair propose yet another take on C++.</div><br/></div></div><div id="42236984" class="c"><input type="checkbox" id="c-42236984" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236666">parent</a><span>|</span><a href="#42237137">prev</a><span>|</span><a href="#42242804">next</a><span>|</span><label class="collapse" for="c-42236984">[-]</label><label class="expand" for="c-42236984">[11 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really a valid comparison though. cppfront is a different language that just happens to be compatible with C++. ts&#x2F;js is were ts is just js with types. You can comment out the types and it just runs. cppfront&#x27;s language you&#x27;ll actually have to re-write the code to get it to compile in C++<p>typescript<p><pre><code>    function add(a: number, b: number): number { return a + b };
</code></pre>
javascript<p><pre><code>    function add(a&#x2F;*: number*&#x2F;, b&#x2F;*: number*&#x2F;)&#x2F;*: number*&#x2F; { return a + b };
</code></pre>
cppfront<p><pre><code>    add: (a: float, b: float): float = { a + b; }
</code></pre>
cpp<p><pre><code>    float add(float a, float b) { return a + b; }</code></pre></div><br/><div id="42238375" class="c"><input type="checkbox" id="c-42238375" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236984">parent</a><span>|</span><a href="#42237106">next</a><span>|</span><label class="collapse" for="c-42238375">[-]</label><label class="expand" for="c-42238375">[6 more]</label></div><br/><div class="children"><div class="content">&gt; ts&#x2F;js is were ts is just js with types. You can comment out the types and it just runs.<p>Is this true in the general case? I thought there were typescript features that didn&#x27;t have direct JavaScript alternatives, for example enums.</div><br/><div id="42238488" class="c"><input type="checkbox" id="c-42238488" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238375">parent</a><span>|</span><a href="#42237106">next</a><span>|</span><label class="collapse" for="c-42238488">[-]</label><label class="expand" for="c-42238488">[5 more]</label></div><br/><div class="children"><div class="content">Enums and namespaces are the only runtime features of TypeScript.<p>So, yes, you can&#x27;t just strip types, but it&#x27;s close.</div><br/><div id="42238799" class="c"><input type="checkbox" id="c-42238799" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238488">parent</a><span>|</span><a href="#42237106">next</a><span>|</span><label class="collapse" for="c-42238799">[-]</label><label class="expand" for="c-42238799">[4 more]</label></div><br/><div class="children"><div class="content">Is there a comprehensive list of such incompatibilities documented somewhere?</div><br/><div id="42240362" class="c"><input type="checkbox" id="c-42240362" checked=""/><div class="controls bullet"><span class="by">judofyr</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238799">parent</a><span>|</span><a href="#42240647">next</a><span>|</span><label class="collapse" for="c-42240362">[-]</label><label class="expand" for="c-42240362">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;tsconfig&#x2F;#isolatedModules" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;tsconfig&#x2F;#isolatedModules</a></div><br/><div id="42240657" class="c"><input type="checkbox" id="c-42240657" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42240362">parent</a><span>|</span><a href="#42240647">next</a><span>|</span><label class="collapse" for="c-42240657">[-]</label><label class="expand" for="c-42240657">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the same.<p>That guarantees that the types do not determine the output (e.g. no const enums), not that you can &quot;strip&quot; types to get the same output.</div><br/></div></div></div></div><div id="42240647" class="c"><input type="checkbox" id="c-42240647" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238799">parent</a><span>|</span><a href="#42240362">prev</a><span>|</span><a href="#42237106">next</a><span>|</span><label class="collapse" for="c-42240647">[-]</label><label class="expand" for="c-42240647">[1 more]</label></div><br/><div class="children"><div class="content">Not that I&#x27;m aware of.<p>Decorators would be another example. (Though they have always been marked experimental.)<p>And of course JSX, but that&#x27;s not a TypeScript invention.</div><br/></div></div></div></div></div></div></div></div><div id="42237106" class="c"><input type="checkbox" id="c-42237106" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236984">parent</a><span>|</span><a href="#42238375">prev</a><span>|</span><a href="#42242804">next</a><span>|</span><label class="collapse" for="c-42237106">[-]</label><label class="expand" for="c-42237106">[4 more]</label></div><br/><div class="children"><div class="content">Do you realize that the Typescript example contains strictly more information than the Javascript one (namely, declarations for the type of three things) and is therefore more complex to compile, while the two C++ examples are semantically identical (the last expression in the function is returned implicitly without having to write &quot;return&quot;) and the new syntax is easier to parse?</div><br/><div id="42238163" class="c"><input type="checkbox" id="c-42238163" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237106">parent</a><span>|</span><a href="#42239093">next</a><span>|</span><label class="collapse" for="c-42238163">[-]</label><label class="expand" for="c-42238163">[2 more]</label></div><br/><div class="children"><div class="content">There are several semantic differences between Cpp1 and Cpp2. Cpp2 moves from last use, which is the biggest one. In a contrived example, that could result in a &quot;hello world&quot; changing to &quot;goodbye world&quot; or any other arbitrary behavior change you want to demonstrate. Cpp2 also doesn&#x27;t require you to order functions and types or declare prototypes, which means partial template specializations and function overloads can produce similar changes when migrating from Cpp1 to Cpp2.</div><br/><div id="42239723" class="c"><input type="checkbox" id="c-42239723" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238163">parent</a><span>|</span><a href="#42239093">next</a><span>|</span><label class="collapse" for="c-42239723">[-]</label><label class="expand" for="c-42239723">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written a little demo here: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;xn1eqd5zb" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;xn1eqd5zb</a><p>You can see where CPPFront inserts a `cpp2::move` call automatically, and how that differs from a superficially equivalent Cpp1 function.</div><br/></div></div></div></div><div id="42239093" class="c"><input type="checkbox" id="c-42239093" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237106">parent</a><span>|</span><a href="#42238163">prev</a><span>|</span><a href="#42242804">next</a><span>|</span><label class="collapse" for="c-42239093">[-]</label><label class="expand" for="c-42239093">[1 more]</label></div><br/><div class="children"><div class="content">yes, of course. That&#x27;s not my point. My point is TypeScript succeeds because it&#x27;s just JavaScript with types. It&#x27;s not a new language. cppfront is an entirely new language so it&#x27;s arguably going to have a tougher time. Being an entirely new language, it is not analogous to typescript</div><br/></div></div></div></div></div></div><div id="42242804" class="c"><input type="checkbox" id="c-42242804" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236666">parent</a><span>|</span><a href="#42236984">prev</a><span>|</span><a href="#42232287">next</a><span>|</span><label class="collapse" for="c-42242804">[-]</label><label class="expand" for="c-42242804">[1 more]</label></div><br/><div class="children"><div class="content">&gt; He compares it to the JS&#x2F;TS relationship.<p>OP is right, TypeScript is a whole new syntax, and it&#x27;s shtick is that it can be transpiled into JavaScript.</div><br/></div></div></div></div></div></div></div></div><div id="42232287" class="c"><input type="checkbox" id="c-42232287" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42232925">prev</a><span>|</span><a href="#42236393">next</a><span>|</span><label class="collapse" for="c-42232287">[-]</label><label class="expand" for="c-42232287">[34 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; riddled with state machines
</code></pre>
Why is this bad?  Normally, state machines are easy to reason about.</div><br/><div id="42232446" class="c"><input type="checkbox" id="c-42232446" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42242530">next</a><span>|</span><label class="collapse" for="c-42232446">[-]</label><label class="expand" for="c-42232446">[14 more]</label></div><br/><div class="children"><div class="content">The set of developers who say &quot;I want to implement this logic as a state machine&quot; is MUCH larger than the set of developers who say &quot;I should make sure I fully understand every possible state and edge case ahead of time before making a state machine!&quot;</div><br/><div id="42238137" class="c"><input type="checkbox" id="c-42238137" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232446">parent</a><span>|</span><a href="#42239376">next</a><span>|</span><label class="collapse" for="c-42238137">[-]</label><label class="expand" for="c-42238137">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;I should make sure I fully understand every possible state and edge case ahead of time before making a state machine!&quot;<p>Attempting to understand every state and edge case before writing code is a fool&#x27;s errand because it would amount to writing the entire program anyway.<p>State machines are a clear, concise, elegant pattern to encapsulate logic. They&#x27;re dead simple to read and reason about. And, get this, writing one FORCES YOU to fully understand every possible state and edge case of the problem you&#x27;re solving.<p>You either have an explicit state machine, or an implicit one. In my entire career I have never regretted writing one the instant I even smell ambiguity coming on. They&#x27;re an indefatigable sword to cut through spaghetti that&#x27;s had poorly interacting logic sprinkled into it by ten devs over ten years, bring it into the light, and make the question and answer of how to fix it instantly articulable and solvable.<p>I truly don&#x27;t understand what grudge you could have against the state machine. Of all the patterns in software development I&#x27;d go as far as to hold it in the highest regard above all others. If our job is to make computers do what we want them to do in an unambiguous and maintainable manner then our job is to write state machines.</div><br/></div></div><div id="42239376" class="c"><input type="checkbox" id="c-42239376" checked=""/><div class="controls bullet"><span class="by">harrall</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232446">parent</a><span>|</span><a href="#42238137">prev</a><span>|</span><a href="#42232835">next</a><span>|</span><label class="collapse" for="c-42239376">[-]</label><label class="expand" for="c-42239376">[1 more]</label></div><br/><div class="children"><div class="content">The times Iâve bothered to write explicit state machines have created the most solid, confident and bug-free pieces of software Iâve ever built. I would send someone to the moon with them.</div><br/></div></div><div id="42232835" class="c"><input type="checkbox" id="c-42232835" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232446">parent</a><span>|</span><a href="#42239376">prev</a><span>|</span><a href="#42236811">next</a><span>|</span><label class="collapse" for="c-42232835">[-]</label><label class="expand" for="c-42232835">[6 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t this be said about any alternative solution?  I fail to see how this is specific to state machines.<p>What do you suggest instead of a state machine?</div><br/><div id="42235057" class="c"><input type="checkbox" id="c-42235057" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232835">parent</a><span>|</span><a href="#42236811">next</a><span>|</span><label class="collapse" for="c-42235057">[-]</label><label class="expand" for="c-42235057">[5 more]</label></div><br/><div class="children"><div class="content">Like properly model a domain in domain terms?</div><br/><div id="42235464" class="c"><input type="checkbox" id="c-42235464" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235057">parent</a><span>|</span><a href="#42236811">next</a><span>|</span><label class="collapse" for="c-42235464">[-]</label><label class="expand" for="c-42235464">[4 more]</label></div><br/><div class="children"><div class="content">And that won&#x27;t be a state machine with the states having more fancy names?</div><br/><div id="42235827" class="c"><input type="checkbox" id="c-42235827" checked=""/><div class="controls bullet"><span class="by">InDubioProRubio</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235464">parent</a><span>|</span><a href="#42236811">next</a><span>|</span><label class="collapse" for="c-42235827">[-]</label><label class="expand" for="c-42235827">[3 more]</label></div><br/><div class="children"><div class="content">It will be, but the idea of having an overview over the states is gone then. There is just modules-&gt; objects with the transitions being method calls. Nobody will have to know all the things about all the state transitions, resulting in another problem (dys)solved by architecture obscurity.<p>If needs be the state-machine can be reconstructed on a whiteboard by a team of five.</div><br/><div id="42243415" class="c"><input type="checkbox" id="c-42243415" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235827">parent</a><span>|</span><a href="#42236811">next</a><span>|</span><label class="collapse" for="c-42243415">[-]</label><label class="expand" for="c-42243415">[2 more]</label></div><br/><div class="children"><div class="content">A state machine makes the actual program state first class and easy to reason about. One does not even need mutable state to model one. Whereas you appear to be advocating mutable objects. The state space then becomes a combinatorial explosion of all the hidden mutable state &quot;encapsulated&quot; inside the objects. Object oriented programming is not the only way and often leads to a poor domain model. Some OOP evangelists even model a bank account with a mutable balance field and methods for making deposits. This is a absolutely not a faithful model of the domain (ledgers have been used for hundreds&#x2F;thousands of years). In summary, yes a state machine can absolutely be a good domain model.</div><br/><div id="42243768" class="c"><input type="checkbox" id="c-42243768" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42243415">parent</a><span>|</span><a href="#42236811">next</a><span>|</span><label class="collapse" for="c-42243768">[-]</label><label class="expand" for="c-42243768">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting to know about what state machines you talk. From my experience most of the time it&#x27;s an entity with state property with finger countable cardinality. And state is assumed to be changed directly. And it&#x27;s not easy to reason because author only heard about state machines and state transitions are spread over all code base.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42236811" class="c"><input type="checkbox" id="c-42236811" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232446">parent</a><span>|</span><a href="#42232835">prev</a><span>|</span><a href="#42236563">next</a><span>|</span><label class="collapse" for="c-42236811">[-]</label><label class="expand" for="c-42236811">[4 more]</label></div><br/><div class="children"><div class="content">Implement <i>as</i> a state machine? But. Your program exists as a set of transforms upon memory. Your program <i>is</i> a state machine! You just need to define the proper morpisms to map your problem domain to the computer domain.</div><br/><div id="42237334" class="c"><input type="checkbox" id="c-42237334" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236811">parent</a><span>|</span><a href="#42236563">next</a><span>|</span><label class="collapse" for="c-42237334">[-]</label><label class="expand" for="c-42237334">[3 more]</label></div><br/><div class="children"><div class="content">Transformations are separable by principle, it&#x27;s a fundamental property of them that state machines have as an afterthought that is even hard to represent.<p>It doesn&#x27;t matter if they have equivalent power. One of those representations fundamentally allows your software to have an architecture, the other doesn&#x27;t.</div><br/><div id="42237851" class="c"><input type="checkbox" id="c-42237851" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237334">parent</a><span>|</span><a href="#42236563">next</a><span>|</span><label class="collapse" for="c-42237851">[-]</label><label class="expand" for="c-42237851">[2 more]</label></div><br/><div class="children"><div class="content">How much of software architecture is required <i>because</i> of the architecture? If your program has types that are the possible states, and functions to transform between those states, what architecture is needed beyond that? A grouping of related types, perhaps?</div><br/><div id="42238786" class="c"><input type="checkbox" id="c-42238786" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237851">parent</a><span>|</span><a href="#42236563">next</a><span>|</span><label class="collapse" for="c-42238786">[-]</label><label class="expand" for="c-42238786">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, just one layer of functions is enough for everybody.<p>Let&#x27;s look next at that &quot;compiler&quot; thing and high-level languages. The hardware-native one suffices, no need for all that bloat.</div><br/></div></div></div></div></div></div></div></div><div id="42236563" class="c"><input type="checkbox" id="c-42236563" checked=""/><div class="controls bullet"><span class="by">kayo_20211030</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232446">parent</a><span>|</span><a href="#42236811">prev</a><span>|</span><a href="#42242530">next</a><span>|</span><label class="collapse" for="c-42236563">[-]</label><label class="expand" for="c-42236563">[1 more]</label></div><br/><div class="children"><div class="content">I have a coding problem.<p>I&#x27;ll use a state machine!<p>Now, I have two problems :-(</div><br/></div></div></div></div><div id="42242530" class="c"><input type="checkbox" id="c-42242530" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42232446">prev</a><span>|</span><a href="#42232443">next</a><span>|</span><label class="collapse" for="c-42242530">[-]</label><label class="expand" for="c-42242530">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never understood this claim. I find state machines very hard to follow because there&#x27;s no easy way to tell what paths lead to a given state; they&#x27;re like using goto instead of functions (indeed they&#x27;re often implemented that way).</div><br/></div></div><div id="42232443" class="c"><input type="checkbox" id="c-42232443" checked=""/><div class="controls bullet"><span class="by">risenshinetech</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42242530">prev</a><span>|</span><a href="#42233590">next</a><span>|</span><label class="collapse" for="c-42232443">[-]</label><label class="expand" for="c-42232443">[1 more]</label></div><br/><div class="children"><div class="content">Please describe &quot;normally&quot;. State machines can turn into nightmares, just like any design pattern used poorly.</div><br/></div></div><div id="42233590" class="c"><input type="checkbox" id="c-42233590" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42232443">prev</a><span>|</span><a href="#42232370">next</a><span>|</span><label class="collapse" for="c-42233590">[-]</label><label class="expand" for="c-42233590">[12 more]</label></div><br/><div class="children"><div class="content">State machines don&#x27;t have syntax for &quot;transition here when event is encountered no matter what state you are in&quot; so the whole diagram becomes a spaghetti mess if you have a lot of those escape hatches.</div><br/><div id="42235876" class="c"><input type="checkbox" id="c-42235876" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233590">parent</a><span>|</span><a href="#42234800">next</a><span>|</span><label class="collapse" for="c-42235876">[-]</label><label class="expand" for="c-42235876">[2 more]</label></div><br/><div class="children"><div class="content">&gt; State machines don&#x27;t have syntax for &quot;transition here when event is encountered no matter what state you are in&quot; so the whole diagram becomes a spaghetti mess if you have a lot of those escape hatches.<p>I place a note at the top of my diagrams stating what the default state would be on receipt of an unexpected event. There is no such thing as &quot;event silently gets swallowed because no transition exists&quot;, because, in implementation, the state machine `switch` statement <i>always</i> has a `default` clause which triggers all the alarm bells.<p>Works very well in practice; I used to write hard real-time munitions control software for blowing shit up. Never had a problem.</div><br/><div id="42236330" class="c"><input type="checkbox" id="c-42236330" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42235876">parent</a><span>|</span><a href="#42234800">next</a><span>|</span><label class="collapse" for="c-42236330">[-]</label><label class="expand" for="c-42236330">[1 more]</label></div><br/><div class="children"><div class="content">&gt; hard real-time munitions control software for blowing shit up. Never had a problem.<p>Ha, Ha, Ha! The juxtaposition of these two phrases is really funny. I would like to apply for a position on the Testing team :-)</div><br/></div></div></div></div><div id="42234800" class="c"><input type="checkbox" id="c-42234800" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233590">parent</a><span>|</span><a href="#42235876">prev</a><span>|</span><a href="#42235542">next</a><span>|</span><label class="collapse" for="c-42234800">[-]</label><label class="expand" for="c-42234800">[5 more]</label></div><br/><div class="children"><div class="content">State machines don&#x27;t have a native syntax in C++ <i>at all</i>, so you can structure them however you want. It&#x27;s easy to structure a state machine, if needed, so that all (or some) states can handle the same event in the same way.</div><br/><div id="42236855" class="c"><input type="checkbox" id="c-42236855" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42234800">parent</a><span>|</span><a href="#42239419">next</a><span>|</span><label class="collapse" for="c-42236855">[-]</label><label class="expand" for="c-42236855">[3 more]</label></div><br/><div class="children"><div class="content">I always thought this framework was neat: <a href="https:&#x2F;&#x2F;doc.qt.io&#x2F;qt-5&#x2F;statemachine-api.html" rel="nofollow">https:&#x2F;&#x2F;doc.qt.io&#x2F;qt-5&#x2F;statemachine-api.html</a><p>Downside of course is now you have a dependency on qt.</div><br/><div id="42238226" class="c"><input type="checkbox" id="c-42238226" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236855">parent</a><span>|</span><a href="#42239419">next</a><span>|</span><label class="collapse" for="c-42238226">[-]</label><label class="expand" for="c-42238226">[2 more]</label></div><br/><div class="children"><div class="content">The downside is that you&#x27;re now heap allocating at least one object for every state, and I&#x27;m willing to bet that each QState has an associated std::vector-style list of actions, and that each action is also its own object on the heap.<p>If you can afford to do things like this you can most likely use something other than C++ and save yourself a lot of headaches.</div><br/><div id="42238374" class="c"><input type="checkbox" id="c-42238374" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238226">parent</a><span>|</span><a href="#42239419">next</a><span>|</span><label class="collapse" for="c-42238374">[-]</label><label class="expand" for="c-42238374">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you can afford to do things like this you can most likely use something other than C++ and save yourself a lot of headaches.<p>Surely you can understand that, despite the recent c++ hate, my job doesn&#x27;t give a fuck and we aren&#x27;t migrating our massive codebase from c++ to... anything.</div><br/></div></div></div></div></div></div><div id="42239419" class="c"><input type="checkbox" id="c-42239419" checked=""/><div class="controls bullet"><span class="by">garethrowlands</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42234800">parent</a><span>|</span><a href="#42236855">prev</a><span>|</span><a href="#42235542">next</a><span>|</span><label class="collapse" for="c-42239419">[-]</label><label class="expand" for="c-42239419">[1 more]</label></div><br/><div class="children"><div class="content">Switch + goto is very close to being a native syntax for state machines. It&#x27;s also very efficient.</div><br/></div></div></div></div><div id="42235542" class="c"><input type="checkbox" id="c-42235542" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233590">parent</a><span>|</span><a href="#42234800">prev</a><span>|</span><a href="#42233710">next</a><span>|</span><label class="collapse" for="c-42235542">[-]</label><label class="expand" for="c-42235542">[1 more]</label></div><br/><div class="children"><div class="content">goto is exactly this feature.</div><br/></div></div><div id="42233710" class="c"><input type="checkbox" id="c-42233710" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233590">parent</a><span>|</span><a href="#42235542">prev</a><span>|</span><a href="#42232370">next</a><span>|</span><label class="collapse" for="c-42233710">[-]</label><label class="expand" for="c-42233710">[3 more]</label></div><br/><div class="children"><div class="content">I believe HSMs can model this, but don&#x27;t quote me. :)</div><br/><div id="42233963" class="c"><input type="checkbox" id="c-42233963" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233710">parent</a><span>|</span><a href="#42232370">next</a><span>|</span><label class="collapse" for="c-42233963">[-]</label><label class="expand" for="c-42233963">[2 more]</label></div><br/><div class="children"><div class="content">Yes, of course in theory nested state machines should be able to model this. I feel like adding more complexity and bending the rules is a bit of a concession.</div><br/><div id="42234852" class="c"><input type="checkbox" id="c-42234852" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233963">parent</a><span>|</span><a href="#42232370">next</a><span>|</span><label class="collapse" for="c-42234852">[-]</label><label class="expand" for="c-42234852">[1 more]</label></div><br/><div class="children"><div class="content">Back in the days we implemented HSM helper classes in about 500 LoC and generated them from Enterprise Architect. No need to write a GUI yourself, but better to have a visual for documentation and review. Worked very well until we replaced EA with docs-as-code, now I miss that there is no nice simulator and Modeler for that workflow.</div><br/></div></div></div></div></div></div></div></div><div id="42232370" class="c"><input type="checkbox" id="c-42232370" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42233590">prev</a><span>|</span><a href="#42236393">next</a><span>|</span><label class="collapse" for="c-42232370">[-]</label><label class="expand" for="c-42232370">[5 more]</label></div><br/><div class="children"><div class="content">They can be.  Or they can be... less easy.<p>Imagine you have an informally-specified, undocumented, at-least-somewhat-incomplete state machine.  Imagine that it interacts with several other similar state machines.  Still easy to reason about?<p>Now add multithreading.  Still easy?<p>Now add locking.  Still easy?<p>Cleanly-done state machines can be the cleanest way to describe a problem, and the simplest way to implement it.  But badly-done state machines can be a total mess.<p>Alas, I think that the last time I waded in such waters, what I left behind was pretty much on the &quot;mess&quot; side of the scale.  It worked, it worked mostly solidly, and it did so for more than a decade.  But it was still rather messy.</div><br/><div id="42233690" class="c"><input type="checkbox" id="c-42233690" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232370">parent</a><span>|</span><a href="#42233667">next</a><span>|</span><label class="collapse" for="c-42233690">[-]</label><label class="expand" for="c-42233690">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine you have an informally-specified, undocumented, at-least-somewhat-incomplete state machine. Imagine that it interacts with several other similar state machines. Still easy to reason about?<p>You think that developers that wrote an informally-specified, undocumented, at-least-somewhat-incomplete state-machine would have written that logic as a non-state-machine in a formally-specified, documented and at-least-somewhat-complete codebase?<p>State-machines are exceptionally easy to reason about because you can at least reverse-engineer a state-diagram from the state-machine code.<p>Almost-a-state-machine-but-not-quite are exceptionally difficult to reason about because you can not easily reverse-engineer the state-diagram from the state-machine code.</div><br/><div id="42236564" class="c"><input type="checkbox" id="c-42236564" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233690">parent</a><span>|</span><a href="#42233667">next</a><span>|</span><label class="collapse" for="c-42236564">[-]</label><label class="expand" for="c-42236564">[2 more]</label></div><br/><div class="children"><div class="content">In fact state machines are great for documentation even if the code is not explicitly written as a state machine!</div><br/><div id="42237330" class="c"><input type="checkbox" id="c-42237330" checked=""/><div class="controls bullet"><span class="by">_huayra_</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236564">parent</a><span>|</span><a href="#42233667">next</a><span>|</span><label class="collapse" for="c-42237330">[-]</label><label class="expand" for="c-42237330">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and it&#x27;s much better than having a dozen or more `bool` values that indicate some event occurred and put it into some &quot;mode&quot; (e.g. &quot;unhealthy&quot;, &quot;input exhausted&quot;, etc) and you have to infer what the &quot;hidden state machine is&quot; based on all of those bool values.<p>Want to add another &quot;bool state&quot;? Hello exponential growth...</div><br/></div></div></div></div></div></div><div id="42233667" class="c"><input type="checkbox" id="c-42233667" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232370">parent</a><span>|</span><a href="#42233690">prev</a><span>|</span><a href="#42236393">next</a><span>|</span><label class="collapse" for="c-42233667">[-]</label><label class="expand" for="c-42233667">[1 more]</label></div><br/><div class="children"><div class="content">But that is just true of any problem-solving&#x2F;programming technique.<p>In general, state&#x2F;event machine transition table and decision table techniques of structuring code are easier to comprehend than adhoc and even worse, poorly understood pattern-based techniques are.</div><br/></div></div></div></div></div></div><div id="42236393" class="c"><input type="checkbox" id="c-42236393" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42232287">prev</a><span>|</span><a href="#42238019">next</a><span>|</span><label class="collapse" for="c-42236393">[-]</label><label class="expand" for="c-42236393">[1 more]</label></div><br/><div class="children"><div class="content">I am out of the loop, what kind of pressure were they putting on Python?</div><br/></div></div><div id="42238019" class="c"><input type="checkbox" id="c-42238019" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42236393">prev</a><span>|</span><a href="#42236025">next</a><span>|</span><label class="collapse" for="c-42238019">[-]</label><label class="expand" for="c-42238019">[3 more]</label></div><br/><div class="children"><div class="content">The C++ from Google that people in the outside world are seeing is not the C++ the article is talking about. Chromium and open sourced libraries from Google are not the same as C++ in Google3. I worked on both back in the day and ... There&#x27;s slightly different style guides (not hugely different), but most importantly the tooling is not the same.<p>The kind of mass refactorings &#x2F; cleanups &#x2F; static analysis talked about in this article are done on a much more serious and large scale on C++ inside the Google3 monorepo than they are in Chromium. Different build systems, different code review tools, different development culture.</div><br/><div id="42238563" class="c"><input type="checkbox" id="c-42238563" checked=""/><div class="controls bullet"><span class="by">deltaburnt</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238019">parent</a><span>|</span><a href="#42236025">next</a><span>|</span><label class="collapse" for="c-42238563">[-]</label><label class="expand" for="c-42238563">[2 more]</label></div><br/><div class="children"><div class="content">Going from g3 to AOSP has been downright painful. It was like suddenly working in a different company the contrast was so stark.</div><br/><div id="42238918" class="c"><input type="checkbox" id="c-42238918" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238563">parent</a><span>|</span><a href="#42236025">next</a><span>|</span><label class="collapse" for="c-42238918">[-]</label><label class="expand" for="c-42238918">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. I never worked in Android, but did in Chromium &amp; Chromecast code bases. Biggest difference with Google3 was honestly in the tooling. Style guide was fairly close, maybe a bit more conservative. Also the lack of the core libs that eventually became Abseil.<p>I work full-time in Rust these days and everytime I go back to working in C++ it&#x27;s a bit of a cringe. If I look long enough, I almost always find a use-after-free, even from extremely competent developers. Footgun language.</div><br/></div></div></div></div></div></div><div id="42236025" class="c"><input type="checkbox" id="c-42236025" checked=""/><div class="controls bullet"><span class="by">protomolecule</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42238019">prev</a><span>|</span><a href="#42237316">next</a><span>|</span><label class="collapse" for="c-42236025">[-]</label><label class="expand" for="c-42236025">[4 more]</label></div><br/><div class="children"><div class="content">&gt; riddled with state machines<p>What&#x27;s wrong with state machines? Beats the tangled mess of nested ifs and fors.</div><br/><div id="42236587" class="c"><input type="checkbox" id="c-42236587" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236025">parent</a><span>|</span><a href="#42237316">next</a><span>|</span><label class="collapse" for="c-42236587">[-]</label><label class="expand" for="c-42236587">[3 more]</label></div><br/><div class="children"><div class="content">That depends on your problem. I&#x27;ve seen useful state machines. I&#x27;ve seen someone implement a simple decoder as a complex any-to-any state machine that couldn&#x27;t be understood - a single switch statement would have been better. Nothing about state machines, but some people have a hammer and are determined to prove it can drive any screw - it works but isn&#x27;t how you should do it.</div><br/><div id="42238395" class="c"><input type="checkbox" id="c-42238395" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236587">parent</a><span>|</span><a href="#42239434">next</a><span>|</span><label class="collapse" for="c-42238395">[-]</label><label class="expand" for="c-42238395">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve adopted a rule of thumb to have a very low bar to skip straight to writing a state machine. I&#x27;ve never once regretted it, personally. I&#x27;m sure they can be misused but I haven&#x27;t came across that.</div><br/></div></div><div id="42239434" class="c"><input type="checkbox" id="c-42239434" checked=""/><div class="controls bullet"><span class="by">garethrowlands</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236587">parent</a><span>|</span><a href="#42238395">prev</a><span>|</span><a href="#42237316">next</a><span>|</span><label class="collapse" for="c-42239434">[-]</label><label class="expand" for="c-42239434">[1 more]</label></div><br/><div class="children"><div class="content">Switch + goto is the classic way to implement a state machine in C.</div><br/></div></div></div></div></div></div><div id="42237316" class="c"><input type="checkbox" id="c-42237316" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42236025">prev</a><span>|</span><a href="#42234855">next</a><span>|</span><label class="collapse" for="c-42237316">[-]</label><label class="expand" for="c-42237316">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I compile a lot of C++ code from a lot of places, and the only time I run into code that somehow simply <i>doesn&#x27;t work</i> on newer versions of C++<p>I&#x27;m impressed that you even get as far as finding out whether that much C++ from disparate sources works on a newer version of C++. The myriad, often highly customized and correspondingly poorly documented build systems invented for each project, the maze of dependencies, the weird and conflicting source tree layouts and preprocessor tricks that many projects use... it&#x27;s usually a pain in the neck to get a new library to even attempt to build, let alone integrate it successfully.<p>Don&#x27;t get me wrong, we use C++ and ship a product using it, and I occasionally have to integrate new libraries, but it&#x27;s very much not something I look forward to.</div><br/></div></div><div id="42237308" class="c"><input type="checkbox" id="c-42237308" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42234855">prev</a><span>|</span><a href="#42237594">next</a><span>|</span><label class="collapse" for="c-42237308">[-]</label><label class="expand" for="c-42237308">[1 more]</label></div><br/><div class="children"><div class="content">This phenomenon is mostly because, as the article notes, Google has one of the largest C++ deployments in the world. And since much of the C++ code needs to be extremely platform-agnostic (any given library might be running in a web service, a piece of Chromium or Android, and an embedded smart home device), they tend to be very conservative about new features because their code always has to compile to the lowest-common-denominator (and, more importantly, they&#x27;re very, very sensitive to performance regressions; the devil you know is always preferred to risking that the devil you don&#x27;t know is slower, even if it could be faster).<p>Google can embrace modern <i>processes</i>, but the <i>language itself</i> had better be compilable on whatever ancient version of gcc works on the one mission-critical architecture they can&#x27;t upgrade yet...</div><br/></div></div><div id="42237594" class="c"><input type="checkbox" id="c-42237594" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42237308">prev</a><span>|</span><a href="#42233157">next</a><span>|</span><label class="collapse" for="c-42237594">[-]</label><label class="expand" for="c-42237594">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Like... I honestly feel bad for the Rust people, as I do not think the increasing attention they are going to get from Google is going to be at all positive for that ecosystem<p>We are just now feeling this. Some original contributors left the field, and lately the language has went in directions I don&#x27;t agree with.</div><br/><div id="42238191" class="c"><input type="checkbox" id="c-42238191" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237594">parent</a><span>|</span><a href="#42238120">next</a><span>|</span><label class="collapse" for="c-42238191">[-]</label><label class="expand" for="c-42238191">[3 more]</label></div><br/><div class="children"><div class="content">As an outsider, I&#x27;m curious what directions those are. Are you referring to effects or keyword generics or something else?</div><br/><div id="42239784" class="c"><input type="checkbox" id="c-42239784" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42238191">parent</a><span>|</span><a href="#42238120">next</a><span>|</span><label class="collapse" for="c-42239784">[-]</label><label class="expand" for="c-42239784">[2 more]</label></div><br/><div class="children"><div class="content">Endless bikeshedding about `Pin` would be one example. I&#x27;m also not sure keyword generics are the correct way.</div><br/><div id="42240983" class="c"><input type="checkbox" id="c-42240983" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42239784">parent</a><span>|</span><a href="#42238120">next</a><span>|</span><label class="collapse" for="c-42240983">[-]</label><label class="expand" for="c-42240983">[1 more]</label></div><br/><div class="children"><div class="content">The discussions around &#x27;Pin&#x27; are the opposite of bikeshedding.  It&#x27;s not about what color to pick for the shed, it&#x27;s about reworking the feature to make it hopefully easier to reason about and use.</div><br/></div></div></div></div></div></div><div id="42238120" class="c"><input type="checkbox" id="c-42238120" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42237594">parent</a><span>|</span><a href="#42238191">prev</a><span>|</span><a href="#42233157">next</a><span>|</span><label class="collapse" for="c-42238120">[-]</label><label class="expand" for="c-42238120">[1 more]</label></div><br/><div class="children"><div class="content">But Google is not even the first. Amazon has had their eyes in Rust for quite some time already.</div><br/></div></div></div></div><div id="42233157" class="c"><input type="checkbox" id="c-42233157" checked=""/><div class="controls bullet"><span class="by">returningfory2</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42237594">prev</a><span>|</span><a href="#42234540">next</a><span>|</span><label class="collapse" for="c-42233157">[-]</label><label class="expand" for="c-42233157">[1 more]</label></div><br/><div class="children"><div class="content">I think the article is pretty interesting. There are so many more interesting takes than just another boring Hacker News moan about Google.</div><br/></div></div><div id="42236272" class="c"><input type="checkbox" id="c-42236272" checked=""/><div class="controls bullet"><span class="by">trmantrl</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42234540">prev</a><span>|</span><a href="#42232004">next</a><span>|</span><label class="collapse" for="c-42236272">[-]</label><label class="expand" for="c-42236272">[2 more]</label></div><br/><div class="children"><div class="content">The technical pressure exerted on Python (which was resisted) is one thing. The social pressure incubated the most radical culture warriors the Internet has ever seen and its proponents have ruined the Python organization, driven away many people and have established a totalitarian and oppressive regime.<p>Interestingly, Google has fired the Python team this year. The revolution eats its own?<p>Anyway, Rust should take note and be <i>extremely</i> careful.</div><br/><div id="42239312" class="c"><input type="checkbox" id="c-42239312" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42236272">parent</a><span>|</span><a href="#42232004">next</a><span>|</span><label class="collapse" for="c-42239312">[-]</label><label class="expand" for="c-42239312">[1 more]</label></div><br/><div class="children"><div class="content">Based on what an ex-Google developer said in conversation at a party at the weekend (the discussion was about the choice of First Language for a Computer Science degree course, yes, I do go to exciting parties, many of those attending have never even been a CS lecturer):<p>Some years ago Google decided that Go projects were similar engineering effort, better performance, lower maintenance, and so on that basis there was no reason to authorise new Python software and their existing projects would migrate as-and-when.</div><br/></div></div></div></div></div></div><div id="42232004" class="c"><input type="checkbox" id="c-42232004" checked=""/><div class="controls bullet"><span class="by">bagxrvxpepzn</span><span>|</span><a href="#42232183">prev</a><span>|</span><a href="#42243069">next</a><span>|</span><label class="collapse" for="c-42232004">[-]</label><label class="expand" for="c-42232004">[109 more]</label></div><br/><div class="children"><div class="content">To the people who work on C++ standards: I approve of the current C++ trajectory and please ignore all of the online noise about &quot;the future of C++.&quot; To anyone that disagrees severely with the C++ trajectory as stated, please just consider another language, e.g. Rust. I don&#x27;t want static lifetime checking in C++ and if you want static lifetime checking, please use Rust. I am not a government contractor, if you are a government contractor who must meet bureaucratic risk-averse government requirements, please use Rust. I have an existing development process that works for me and my customers, I have no significant demand for lifetime checking. If your development process is shiny and new and necessitates lifetime checking, then please use Rust. To Rust advocates, you can have the US government and big tech. You can even have Linux. Just leave my existing C++ process alone. It works and the trade offs we have chosen efficiently accomplish our goals.</div><br/><div id="42239027" class="c"><input type="checkbox" id="c-42239027" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232091">next</a><span>|</span><label class="collapse" for="c-42239027">[-]</label><label class="expand" for="c-42239027">[1 more]</label></div><br/><div class="children"><div class="content">You frame it like &quot;Rust advocates&quot; try to infiltrate into C++ language decision making and inject safety features into it. That&#x27;s not the case at all. For years C++ committee simply ignored the need for safety and they didn&#x27;t take Rust and lifetime analysis seriously. But now they themselves want it.</div><br/></div></div><div id="42232091" class="c"><input type="checkbox" id="c-42232091" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42239027">prev</a><span>|</span><a href="#42237374">next</a><span>|</span><label class="collapse" for="c-42232091">[-]</label><label class="expand" for="c-42232091">[20 more]</label></div><br/><div class="children"><div class="content">C++ has lifetime rules just like Rust. They&#x27;re simply implicit in the code and not enforced by the compiler. Do you prefer the uncertainty of silent miscompilations and undefined behavior to upfront compiler errors?<p>You&#x27;re already using a language with a strong type system, so it&#x27;s confusing to me why you would choose to draw the line here.</div><br/><div id="42232300" class="c"><input type="checkbox" id="c-42232300" checked=""/><div class="controls bullet"><span class="by">bagxrvxpepzn</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232091">parent</a><span>|</span><a href="#42235955">next</a><span>|</span><label class="collapse" for="c-42232300">[-]</label><label class="expand" for="c-42232300">[15 more]</label></div><br/><div class="children"><div class="content">&gt; Do you prefer the uncertainty of silent miscompilations and undefined behavior to upfront compiler errors?<p>Yes because then I don&#x27;t have to spend hours writing esoteric spaghetti code to prove something to the compiler that is trivially known to be true. Your error is assuming static lifetime checking is free. As an engineer, I use judgement to make context-dependent trade offs.<p>If you like playing the compiler olympics, or your employer forces you to, please use Rust.</div><br/><div id="42239501" class="c"><input type="checkbox" id="c-42239501" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42237990">next</a><span>|</span><label class="collapse" for="c-42239501">[-]</label><label class="expand" for="c-42239501">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Trivially known to be true&quot; until the code evolves making your unstated assumptions not hold and everything breaks, often in complex and unintuitive ways involving interactions across modules.  This is why these automated soundness checks are valuable.</div><br/><div id="42241516" class="c"><input type="checkbox" id="c-42241516" checked=""/><div class="controls bullet"><span class="by">restalis</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239501">parent</a><span>|</span><a href="#42237990">next</a><span>|</span><label class="collapse" for="c-42241516">[-]</label><label class="expand" for="c-42241516">[1 more]</label></div><br/><div class="children"><div class="content"><i>&quot;until the code evolves [...]&quot;</i><p>That is already a desirable place to be, where you managed to get a working implementation ready to evolve. My issue with opinionated languages like Rust is that they make development more expensive. I then afford to pay the necessary work-effort for fewer projects than I otherwise could if I was to focus more on the problem(s) at hand instead of that and other mandatory constraints forced upon me by the compiler. I very much want my development tools to limit themselves on being tools, to assist me on the part of the problem I chose to focus on with little to no cost paid for their usage. I want to be able to focus on prototyping some working solution first, and only then, if the project&#x27;s needs really warrant it, to switch on paying the development cost for other aspects, be it safety or whatnot.</div><br/></div></div></div></div><div id="42237990" class="c"><input type="checkbox" id="c-42237990" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42239501">prev</a><span>|</span><a href="#42232448">next</a><span>|</span><label class="collapse" for="c-42237990">[-]</label><label class="expand" for="c-42237990">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Yes because then I don&#x27;t have to spend hours writing esoteric spaghetti code to prove something to the compiler that is trivially known to be true.<p>And thatâs exactly the reason why we need more safety in C++.<p>Iâm terrified at amount of code in real world written with this mindset.</div><br/><div id="42243451" class="c"><input type="checkbox" id="c-42243451" checked=""/><div class="controls bullet"><span class="by">virgilp</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42237990">parent</a><span>|</span><a href="#42232448">next</a><span>|</span><label class="collapse" for="c-42243451">[-]</label><label class="expand" for="c-42243451">[3 more]</label></div><br/><div class="children"><div class="content">At the same time, you should recognize that not all real code in the world is used to run planes &amp; thermonuclear power plants. For a lot of the business software, it&#x27;s actually fine if it&#x27;s not perfectly safe.  So if it&#x27;s cheaper&#x2F; faster to develop it without paying the price of static safety checks, who is to say that this was a bad tradeoff?<p>I actually love the ideas that Rust brought forth. It definitely has a place in the ecosystem, and I&#x27;m glad to hear critical software is being rewritten in Rust! But that doesn&#x27;t mean that C++ should copy it.</div><br/><div id="42243733" class="c"><input type="checkbox" id="c-42243733" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42243451">parent</a><span>|</span><a href="#42243731">next</a><span>|</span><label class="collapse" for="c-42243733">[-]</label><label class="expand" for="c-42243733">[1 more]</label></div><br/><div class="children"><div class="content">C++ doesn&#x27;t permit you to write code that&#x27;s not perfectly safe. By using a C++ compiler, you&#x27;re promising that you <i>will</i> write safe code even if the compiler can&#x27;t verify that, lest nasal demons and other misfortunes fall upon you. If your code isn&#x27;t safe and you expect that to be fine, you&#x27;re not writing C++. This is a discussion about C++, so the default assumption is that you&#x27;ll pay the costs of safe code instead of inventing an ill-specified dialect that happens to do what you want when it&#x27;s shoved into a C++ compiler.<p>If you think we should instead evolve C++ so that safety isn&#x27;t mandatory I&#x27;m right there with you, but it&#x27;s not where the language is today and that discussion has also been shut down by the evolution working group. Moreover, Bjarne&#x27;s policies mean that telling the critical software people to go fuck off to a different language fundamentally isn&#x27;t part of the plan either.</div><br/></div></div><div id="42243731" class="c"><input type="checkbox" id="c-42243731" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42243451">parent</a><span>|</span><a href="#42243733">prev</a><span>|</span><a href="#42232448">next</a><span>|</span><label class="collapse" for="c-42243731">[-]</label><label class="expand" for="c-42243731">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For a lot of the business software, it&#x27;s actually fine if it&#x27;s not perfectly safe.<p>Is it fine if it silently gives the wrong answer? If so, why are you bothering with the software at all?<p>In my experience all nontrivial C++ codebases have silent memory corruption bugs (at least when built with popular compilers).</div><br/></div></div></div></div></div></div><div id="42232448" class="c"><input type="checkbox" id="c-42232448" checked=""/><div class="controls bullet"><span class="by">roland35</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42237990">prev</a><span>|</span><a href="#42232499">next</a><span>|</span><label class="collapse" for="c-42232448">[-]</label><label class="expand" for="c-42232448">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found that often when I am writing esoteric spaghetti rust code... I need to start thinking about what I am trying too do! Most of the time it&#x27;s a bad idea :)</div><br/><div id="42237199" class="c"><input type="checkbox" id="c-42237199" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232448">parent</a><span>|</span><a href="#42232499">next</a><span>|</span><label class="collapse" for="c-42237199">[-]</label><label class="expand" for="c-42237199">[1 more]</label></div><br/><div class="children"><div class="content">If one needs to &quot;prove something to the compiler&quot; it is usually something both complex and against the grain; on the other hand lifetime annotations are usually just &quot;promise something to the compiler&quot; to allow it to make a better job.</div><br/></div></div></div></div><div id="42233639" class="c"><input type="checkbox" id="c-42233639" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42232499">prev</a><span>|</span><a href="#42235836">next</a><span>|</span><label class="collapse" for="c-42233639">[-]</label><label class="expand" for="c-42233639">[3 more]</label></div><br/><div class="children"><div class="content">&gt; As an engineer, I use judgement to make context-dependent trade offs.<p>Well said.<p>This is why i am firmly in the Stroustrup camp of backward compatibility&#x2F;zero overhead&#x2F;better-C&#x2F;etc. goodness of &quot;old C++&quot;. I need to extend&#x2F;maintain&#x2F;rewrite tons of them and that needs to be as painless as possible. The current standards trajectory needs to be maintained.<p>The OP article is a rather poor one with no insights but mere hoopla over nothing.</div><br/><div id="42241423" class="c"><input type="checkbox" id="c-42241423" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233639">parent</a><span>|</span><a href="#42235836">next</a><span>|</span><label class="collapse" for="c-42241423">[-]</label><label class="expand" for="c-42241423">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s hoopla over nothing, why do you firmly identify with one of the factions defined by the article?</div><br/><div id="42243165" class="c"><input type="checkbox" id="c-42243165" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42241423">parent</a><span>|</span><a href="#42235836">next</a><span>|</span><label class="collapse" for="c-42243165">[-]</label><label class="expand" for="c-42243165">[1 more]</label></div><br/><div class="children"><div class="content">What a silly question! There is no major schism in the C++ community as the article implies; merely a strong difference of opinion on certain proposals. This is normal in any committee. But since people are strongly wedded to their own proposals it might seem more severe than it actually is.</div><br/></div></div></div></div></div></div><div id="42235836" class="c"><input type="checkbox" id="c-42235836" checked=""/><div class="controls bullet"><span class="by">th2oi34234234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42233639">prev</a><span>|</span><a href="#42240356">next</a><span>|</span><label class="collapse" for="c-42235836">[-]</label><label class="expand" for="c-42235836">[1 more]</label></div><br/><div class="children"><div class="content">LOL; someone has definitely played with type-systems here.</div><br/></div></div><div id="42240356" class="c"><input type="checkbox" id="c-42240356" checked=""/><div class="controls bullet"><span class="by">oxnrtr</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42235836">prev</a><span>|</span><a href="#42235955">next</a><span>|</span><label class="collapse" for="c-42240356">[-]</label><label class="expand" for="c-42240356">[1 more]</label></div><br/><div class="children"><div class="content">You sound like you can barely code yourself out of a wet paper bag.</div><br/></div></div></div></div><div id="42235955" class="c"><input type="checkbox" id="c-42235955" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232091">parent</a><span>|</span><a href="#42232300">prev</a><span>|</span><a href="#42235608">next</a><span>|</span><label class="collapse" for="c-42235955">[-]</label><label class="expand" for="c-42235955">[3 more]</label></div><br/><div class="children"><div class="content">&gt; C++ has lifetime rules just like Rust. They&#x27;re simply implicit in the code and not enforced by the compiler.<p>The problem is that the rules enforced by Rust is not restricted to lifetime rules, it&#x27;s a much much larger superset that includes quite a lot of safe, legitimate and valid code.</div><br/><div id="42236556" class="c"><input type="checkbox" id="c-42236556" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235955">parent</a><span>|</span><a href="#42236105">next</a><span>|</span><label class="collapse" for="c-42236556">[-]</label><label class="expand" for="c-42236556">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but that&#x27;s not a design philosophy C++ adheres to. Look at the modern C++ guidelines or profiles. The entire <i>point</i> is to rule out large swathes of safe, legitimate, and valid code in an optional and interoperable way.<p>C++ isn&#x27;t beholden to Rust&#x27;s trade-offs either. There&#x27;s a whole spectrum of possibilities that don&#x27;t require broken backwards compatibility. Hence:
&quot;Why draw the line specifically at lifetime annotations?&quot;</div><br/></div></div><div id="42236105" class="c"><input type="checkbox" id="c-42236105" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235955">parent</a><span>|</span><a href="#42236556">prev</a><span>|</span><a href="#42235608">next</a><span>|</span><label class="collapse" for="c-42236105">[-]</label><label class="expand" for="c-42236105">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what the unsafe keyword is for.</div><br/></div></div></div></div><div id="42235608" class="c"><input type="checkbox" id="c-42235608" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232091">parent</a><span>|</span><a href="#42235955">prev</a><span>|</span><a href="#42237374">next</a><span>|</span><label class="collapse" for="c-42235608">[-]</label><label class="expand" for="c-42235608">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;re already using a language with a strong type system<p>I&#x27;ll have you know I made a variable void* just yesterday, to make my compiler shut up about the incorrect type :D</div><br/></div></div></div></div><div id="42237374" class="c"><input type="checkbox" id="c-42237374" checked=""/><div class="controls bullet"><span class="by">natemcintosh</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232091">prev</a><span>|</span><a href="#42233039">next</a><span>|</span><label class="collapse" for="c-42237374">[-]</label><label class="expand" for="c-42237374">[9 more]</label></div><br/><div class="children"><div class="content">And what about, for example, those government contractors who are in the same position as you: they have a large C++ codebase that currently works, and is too big to re-write in rust? Now they&#x27;re being asked to make it safer. How will they do that with the &quot;existing C++ process&quot;?</div><br/><div id="42238206" class="c"><input type="checkbox" id="c-42238206" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42237374">parent</a><span>|</span><a href="#42237615">next</a><span>|</span><label class="collapse" for="c-42238206">[-]</label><label class="expand" for="c-42238206">[6 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t Project Zero publish a blog post a few months ago, saying that old code isn&#x27;t your security problem? They said it&#x27;s new code you have to worry about. Zero also had copious amounts of data to demonstrate their point. In any case, if you really want to rewrite C++ in Rust, LLMs are fantastic at doing that. They&#x27;re not really good yet at writing a new giant codebase from first principles. But if you give them something that already exists and ask them to translate it into a different language, oftentimes the result works for me on the first try. Even if it&#x27;s hundreds of lines long.</div><br/><div id="42242514" class="c"><input type="checkbox" id="c-42242514" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238206">parent</a><span>|</span><a href="#42240770">next</a><span>|</span><label class="collapse" for="c-42242514">[-]</label><label class="expand" for="c-42242514">[3 more]</label></div><br/><div class="children"><div class="content">A link would be helpful, but at face value: of course old code vulnerabilities are still a problem. Vulnerabilities in old code make the headlines all the time.</div><br/><div id="42242734" class="c"><input type="checkbox" id="c-42242734" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42242514">parent</a><span>|</span><a href="#42240770">next</a><span>|</span><label class="collapse" for="c-42242734">[-]</label><label class="expand" for="c-42242734">[2 more]</label></div><br/><div class="children"><div class="content">It was difficult to dig up, but I found it for you. <a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;09&#x2F;eliminating-memory-safety-vulnerabilities-Android.html" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;09&#x2F;eliminating-memory-s...</a> Also headlines do not accurately model reality. The news only reports on things that are newsworthy. It&#x27;s comparatively rare that we&#x27;ll discover new vulnerabilities in old code that&#x27;s commonly used. That&#x27;s what makes it newsworthy.</div><br/><div id="42243200" class="c"><input type="checkbox" id="c-42243200" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42242734">parent</a><span>|</span><a href="#42240770">next</a><span>|</span><label class="collapse" for="c-42243200">[-]</label><label class="expand" for="c-42243200">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. It&#x27;s an interesting analysis around the &quot;vulnerabilities decay exponentially&quot; model, discussing how there are more vulnerabilities to be found in new code than old code given equal attention.</div><br/></div></div></div></div></div></div><div id="42240770" class="c"><input type="checkbox" id="c-42240770" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238206">parent</a><span>|</span><a href="#42242514">prev</a><span>|</span><a href="#42238600">next</a><span>|</span><label class="collapse" for="c-42240770">[-]</label><label class="expand" for="c-42240770">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that newer code often needs to communicate with older code, and interfacing C++ and Rust is not trivial.</div><br/></div></div><div id="42238600" class="c"><input type="checkbox" id="c-42238600" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238206">parent</a><span>|</span><a href="#42240770">prev</a><span>|</span><a href="#42237615">next</a><span>|</span><label class="collapse" for="c-42238600">[-]</label><label class="expand" for="c-42238600">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I remember reading that post about bugs over time.  IIRC 5 years was the time it takes for most bugs to get ferreted out.</div><br/></div></div></div></div><div id="42237615" class="c"><input type="checkbox" id="c-42237615" checked=""/><div class="controls bullet"><span class="by">moregrist</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42237374">parent</a><span>|</span><a href="#42238206">prev</a><span>|</span><a href="#42239061">next</a><span>|</span><label class="collapse" for="c-42237615">[-]</label><label class="expand" for="c-42237615">[1 more]</label></div><br/><div class="children"><div class="content">The funny thing about government funding is that it may be easier to secure capital for a Rust rewrite than for ongoing maintenance to add static lifetimes and other safety features to an existing C++ codebase.<p>Legislatures seem a lot more able to allocate large pots of money for major discrete projects than to guarantee an ongoing stream of revenue to a continuing project.</div><br/></div></div><div id="42239061" class="c"><input type="checkbox" id="c-42239061" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42237374">parent</a><span>|</span><a href="#42237615">prev</a><span>|</span><a href="#42233039">next</a><span>|</span><label class="collapse" for="c-42239061">[-]</label><label class="expand" for="c-42239061">[1 more]</label></div><br/><div class="children"><div class="content">They can use Fil-C++ and then they get memory safety without any rewrites.</div><br/></div></div></div></div><div id="42233039" class="c"><input type="checkbox" id="c-42233039" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42237374">prev</a><span>|</span><a href="#42236649">next</a><span>|</span><label class="collapse" for="c-42233039">[-]</label><label class="expand" for="c-42233039">[26 more]</label></div><br/><div class="children"><div class="content">While programming in Rust, I&#x27;ve never thought to myself, &quot;man, this would be so much easier to express in C++&quot;. I&#x27;ve plenty of times thought the reverse while programming in C++ though.<p>Edit: except when interfacing with C APIs.</div><br/><div id="42241712" class="c"><input type="checkbox" id="c-42241712" checked=""/><div class="controls bullet"><span class="by">throwawayffffas</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233039">parent</a><span>|</span><a href="#42235107">next</a><span>|</span><label class="collapse" for="c-42241712">[-]</label><label class="expand" for="c-42241712">[1 more]</label></div><br/><div class="children"><div class="content">I have had the exact opposite experience.</div><br/></div></div><div id="42235107" class="c"><input type="checkbox" id="c-42235107" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233039">parent</a><span>|</span><a href="#42241712">prev</a><span>|</span><a href="#42233612">next</a><span>|</span><label class="collapse" for="c-42235107">[-]</label><label class="expand" for="c-42235107">[8 more]</label></div><br/><div class="children"><div class="content">Then you must be avoiding situations that traditionally use OOP</div><br/><div id="42235385" class="c"><input type="checkbox" id="c-42235385" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235107">parent</a><span>|</span><a href="#42233612">next</a><span>|</span><label class="collapse" for="c-42235385">[-]</label><label class="expand" for="c-42235385">[7 more]</label></div><br/><div class="children"><div class="content">Most kinds of OOP can be expressed idiomatically in Rust.  The big exception is implementation inheritance, which is highly discouraged in modern code anyway due to its complex and unintuitive semantics.  (Specifically, its reliance on &quot;open recursion&quot;, and the related &quot;fragile base class&quot; problem)</div><br/><div id="42236427" class="c"><input type="checkbox" id="c-42236427" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235385">parent</a><span>|</span><a href="#42240822">next</a><span>|</span><label class="collapse" for="c-42236427">[-]</label><label class="expand" for="c-42236427">[1 more]</label></div><br/><div class="children"><div class="content">People often say that modern c++ doesn&#x27;t have the problems needing a solution like rust. Ironically that means people who write modern c++ haven&#x27;t had any aramp up time needed when joining our rust projects. They were already doing things the right way. At least mostly. But now they don&#x27;t have to worry about that one person who seems to be trying to trick the static analysis tools on purpose.</div><br/></div></div><div id="42240822" class="c"><input type="checkbox" id="c-42240822" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235385">parent</a><span>|</span><a href="#42236427">prev</a><span>|</span><a href="#42233612">next</a><span>|</span><label class="collapse" for="c-42240822">[-]</label><label class="expand" for="c-42240822">[5 more]</label></div><br/><div class="children"><div class="content">Anything that involves object graphs (as opposed to trees) is a pain in Rust.</div><br/><div id="42241139" class="c"><input type="checkbox" id="c-42241139" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42240822">parent</a><span>|</span><a href="#42233612">next</a><span>|</span><label class="collapse" for="c-42241139">[-]</label><label class="expand" for="c-42241139">[4 more]</label></div><br/><div class="children"><div class="content">True, but not in a way that wouldn&#x27;t be just as painful in C++.</div><br/><div id="42241197" class="c"><input type="checkbox" id="c-42241197" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42241139">parent</a><span>|</span><a href="#42233612">next</a><span>|</span><label class="collapse" for="c-42241197">[-]</label><label class="expand" for="c-42241197">[3 more]</label></div><br/><div class="children"><div class="content">In Rust, the de facto standard advice for such cases seems to be, &quot;just use indices into an array instead of references&quot;.<p>While this is sometimes done in C++ as well for various reasons, it&#x27;s certainly not the default pattern there. If you have two things that need to point to each other, you just do that.</div><br/><div id="42241320" class="c"><input type="checkbox" id="c-42241320" checked=""/><div class="controls bullet"><span class="by">empath75</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42241197">parent</a><span>|</span><a href="#42233612">next</a><span>|</span><label class="collapse" for="c-42241320">[-]</label><label class="expand" for="c-42241320">[2 more]</label></div><br/><div class="children"><div class="content">&gt; While this is sometimes done in C++ as well for various reasons, it&#x27;s certainly not the default pattern there. If you have two things that need to point to each other, you just do that.<p>And then you have to handle all the subtle memory bugs that you&#x27;ve introduced by doing that.</div><br/><div id="42242821" class="c"><input type="checkbox" id="c-42242821" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42241320">parent</a><span>|</span><a href="#42233612">next</a><span>|</span><label class="collapse" for="c-42242821">[-]</label><label class="expand" for="c-42242821">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not arguing that there isn&#x27;t a gain here, but GP&#x27;s original assertion was that<p>&gt; While programming in Rust, I&#x27;ve never thought to myself, &quot;man, this would be so much easier to express in C++&quot;.<p>This is a concrete example of something that is much easier to express in C++. And, sure, you do pay the tax for that (although I will also dispute the notion that it is <i>impossible</i> to write C++ without memory bugs; it&#x27;s just hard).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42233612" class="c"><input type="checkbox" id="c-42233612" checked=""/><div class="controls bullet"><span class="by">kkert</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233039">parent</a><span>|</span><a href="#42235107">prev</a><span>|</span><a href="#42236649">next</a><span>|</span><label class="collapse" for="c-42233612">[-]</label><label class="expand" for="c-42233612">[16 more]</label></div><br/><div class="children"><div class="content">This is interesting because i&#x27;m writing quite a bit of embedded Rust, and i always run into limitations of very barebones const generics. I always wish they&#x27;d have half the expressiveness of C++ constexpr and templates.<p>Win some, lose some though, as the overall development workflow is lightyears ahead of C++, mostly due to tooling</div><br/><div id="42234587" class="c"><input type="checkbox" id="c-42234587" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233612">parent</a><span>|</span><a href="#42235270">next</a><span>|</span><label class="collapse" for="c-42234587">[-]</label><label class="expand" for="c-42234587">[1 more]</label></div><br/><div class="children"><div class="content">The expressiveness of const generics (NTTPs) in C++ wouldn&#x27;t go away if it adopted lifetime annotations and &quot;safe&quot; scopes. It&#x27;s entirely orthogonal.<p>Rust decided to have more restrictive generic programming, with the benefit of early diagnostic of mistakes in generic code. C++ defers that detection to instantiation, which allows the generics to be more expressive, but it&#x27;s a tradeoff. But this is an entirely different design decision to lifetime tracking.</div><br/></div></div><div id="42235270" class="c"><input type="checkbox" id="c-42235270" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233612">parent</a><span>|</span><a href="#42234587">prev</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42235270">[-]</label><label class="expand" for="c-42235270">[12 more]</label></div><br/><div class="children"><div class="content">Rust generics are not intended as a one-to-one replacement for C++ templates.  Most complex cases of template-level programming would be addressed with macros (possibly proc macros) in Rust.</div><br/><div id="42236226" class="c"><input type="checkbox" id="c-42236226" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235270">parent</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42236226">[-]</label><label class="expand" for="c-42236226">[11 more]</label></div><br/><div class="children"><div class="content">Const generic expressions are still being worked. They are what is blocking portable simd. They are also a much cleaner way to implement things like matrix operations or really anything where a function with two or more arguments of one or more types returns things that have types that are a combination or modification of the input types.</div><br/><div id="42236589" class="c"><input type="checkbox" id="c-42236589" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236226">parent</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42236589">[-]</label><label class="expand" for="c-42236589">[10 more]</label></div><br/><div class="children"><div class="content">The problem AIUI is that &quot;const generic expressions&quot; in full generality are as powerful as dependent types. It&#x27;s not clear to me that the Rust folks will want to open that particular can of worms.</div><br/><div id="42236748" class="c"><input type="checkbox" id="c-42236748" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236589">parent</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42236748">[-]</label><label class="expand" for="c-42236748">[9 more]</label></div><br/><div class="children"><div class="content">I thought dependent types were types that depended on a value?  What they are proposing are types that depend on types or compile time constants.</div><br/><div id="42236836" class="c"><input type="checkbox" id="c-42236836" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236748">parent</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42236836">[-]</label><label class="expand" for="c-42236836">[8 more]</label></div><br/><div class="children"><div class="content">The problem is combining the &quot;const generic&quot; and &quot;expression&quot; part.  If your &quot;compile time constants&quot; can actually be complex expressions, you arguably end up with the same kind of generality as dependent types.<p>This is true even for expressions that are only evaluated in a compile-time context, since dependently-typed languages do &quot;everything&quot; at compile time anyway, they don&#x27;t have a phase distinction where you can talk about &quot;runtime&quot; being separate.</div><br/><div id="42236922" class="c"><input type="checkbox" id="c-42236922" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236836">parent</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42236922">[-]</label><label class="expand" for="c-42236922">[7 more]</label></div><br/><div class="children"><div class="content">Ah, yeah!  I get it now. So c++ is a dependently typed language. That is hilarious. I want lisp syntax in c++29. That said, too many features are blocked on const generic expressions, so I think they are going to have to bite that off. There is already talk about migrating proceduralacros to be something more like normal rust, this moght fit in with that.</div><br/><div id="42238229" class="c"><input type="checkbox" id="c-42238229" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236922">parent</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42238229">[-]</label><label class="expand" for="c-42238229">[6 more]</label></div><br/><div class="children"><div class="content">C++ is not a dependently typed language, for the same reason that templates do not emit errors until after they are instantiated. All non-type template parameters get fully evaluated at instantiation time so they can be checked concretely.<p>A truly dependently typed language performs these checks <i>before</i> instantiation time, by evaluating those expressions abstractly. Code that is polymorphic over values is checked for all possible instantiations, and thus its types can actually depend on values that will not be known until runtime.<p>The classic example is a dynamic array whose type includes its size- you can write something like `concat(vector&lt;int, N&gt;, vector&lt;int, M&gt;) -&gt; vector&lt;int, N + M&gt;` and call this on e.g. arrays you have read from a file or over the network. The compiler doesn&#x27;t care what N and M are, exactly- it only cares that `concat` always produces a result with the length `N + M`.</div><br/><div id="42241989" class="c"><input type="checkbox" id="c-42241989" checked=""/><div class="controls bullet"><span class="by">groos</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238229">parent</a><span>|</span><a href="#42239469">next</a><span>|</span><label class="collapse" for="c-42241989">[-]</label><label class="expand" for="c-42241989">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what &quot;dependently typed&quot; means but in C++20 and beyond, concepts allow templates to constrain their parameters and issue errors for the templates when they&#x27;re specialized, before the actual instantiation happens. E.g., a function template with constraints can issue errors if the template arguments (either explicit or deduced from the call-site) don&#x27;t satisfy the constraints, before the template body is compiled. This was not the case before C++20, where some errors could be issued only upon instantiation. With C++20, in theory, no template needs to be instantiated to validate the template arguments if constraints are provided to check them at specialization-time.</div><br/><div id="42242269" class="c"><input type="checkbox" id="c-42242269" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42241989">parent</a><span>|</span><a href="#42239469">next</a><span>|</span><label class="collapse" for="c-42242269">[-]</label><label class="expand" for="c-42242269">[1 more]</label></div><br/><div class="children"><div class="content">This is the wrong side of the API to make C++20 dependently typed. Concepts let the compiler report errors at the instantiation site of a template, but they don&#x27;t do anything to let the compiler report errors with the template definition itself (again before instantiation time).<p>To be clear this distinction is not unique to dependent types, either. Most languages with some form of generics or polymorphism check the definition of the generic function&#x2F;type&#x2F;etc against the constraints, so the compiler can report errors before it ever sees any instantiations. This just also happens to be a prerequisite to consider something &quot;dependently typed.&quot;</div><br/></div></div></div></div><div id="42239469" class="c"><input type="checkbox" id="c-42239469" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238229">parent</a><span>|</span><a href="#42241989">prev</a><span>|</span><a href="#42238496">next</a><span>|</span><label class="collapse" for="c-42239469">[-]</label><label class="expand" for="c-42239469">[1 more]</label></div><br/><div class="children"><div class="content">&gt; performs these checks before instantiation time<p>Notably Rust type-based generics do this, a key difference wrt. C++ templates.  (You can use macros if you want checks after instantiation, of course.)</div><br/></div></div><div id="42238496" class="c"><input type="checkbox" id="c-42238496" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238229">parent</a><span>|</span><a href="#42239469">prev</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42238496">[-]</label><label class="expand" for="c-42238496">[2 more]</label></div><br/><div class="children"><div class="content">In c++ it does care what N and M are at compile time, at least the optimizer does for autovectorization and unrolling. Would that not be the case with const generic expressions?</div><br/><div id="42242242" class="c"><input type="checkbox" id="c-42242242" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238496">parent</a><span>|</span><a href="#42239446">next</a><span>|</span><label class="collapse" for="c-42242242">[-]</label><label class="expand" for="c-42242242">[1 more]</label></div><br/><div class="children"><div class="content">The question of whether a language is dependently typed only has to do with how type checking is done. The optimizer doesn&#x27;t come into play until later, so whether it uses the information is unrelated to whether the language is dependently typed.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42239446" class="c"><input type="checkbox" id="c-42239446" checked=""/><div class="controls bullet"><span class="by">smilekzs</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233612">parent</a><span>|</span><a href="#42235270">prev</a><span>|</span><a href="#42233966">next</a><span>|</span><label class="collapse" for="c-42239446">[-]</label><label class="expand" for="c-42239446">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as the overall development workflow is lightyears ahead of C++, mostly due to tooling<p>My experience has been the other way around. Eclipse-based IDEs from NXP, TI, ST all have out-of-the-box usable tooling integration:<p>- MCU pinout and configuration codegen<p>- no need to manually fiddle with linker scripts<p>- static stack and code size analyzers (very helpful for fitting stuff in low-cost MCUs)<p>- stable JTAG-based debugging with:<p><pre><code>  - peripheral registers view (with bitfield definitions)

  - RTOS threads view (run status, blocked on which resources, ...)
</code></pre>
And yes, these are important enough for me to put up with Eclipse and pre-modern C&#x2F;C++. I really want to write Rust for embedded but struggling with the tooling all the time didn&#x27;t help.</div><br/></div></div><div id="42233966" class="c"><input type="checkbox" id="c-42233966" checked=""/><div class="controls bullet"><span class="by">afdbcreid</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233612">parent</a><span>|</span><a href="#42239446">prev</a><span>|</span><a href="#42236649">next</a><span>|</span><label class="collapse" for="c-42233966">[-]</label><label class="expand" for="c-42233966">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually quite interesting because this is not an inherent limitation of Rust, and it is definitely planned to be improved. And AFAIK, today (as opposed to last years) it is even being actively worked on!</div><br/></div></div></div></div></div></div><div id="42236649" class="c"><input type="checkbox" id="c-42236649" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42233039">prev</a><span>|</span><a href="#42235026">next</a><span>|</span><label class="collapse" for="c-42236649">[-]</label><label class="expand" for="c-42236649">[14 more]</label></div><br/><div class="children"><div class="content">C++ is on the trajectory to create a future with more safety. Should we do profiles or static lifetime checking (or something else??) is still an open question (and both may be valid).  However I&#x27;m glad c++ is thinking about that. We have real problems around safety in the real world and people are writing unsafe code even when modern safe code would be easier to write.<p>Of course it remains to be seen how this all plays out.  Static lifetimes can be done good or bad. Profiles can be good or bad. Even if whatever we come up with is done well that doesn&#x27;t mean people will (I know rust programmers who just put unsafe everywhere).</div><br/><div id="42236688" class="c"><input type="checkbox" id="c-42236688" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236649">parent</a><span>|</span><a href="#42239577">next</a><span>|</span><label class="collapse" for="c-42236688">[-]</label><label class="expand" for="c-42236688">[9 more]</label></div><br/><div class="children"><div class="content">Profiles are vaporware.  The C++ folks are pushing a fantasy of &quot;full memory safety with no changes to existing code, not even annotations to enable sound static analysis.&quot;  That&#x27;s just a non-starter, there is no way to get to full memory safety from there unless you count very silly things like making &quot;delete&quot; and &quot;free()&quot; a no-op - and also running everything in a single thread for &quot;concurrency safety&quot;.</div><br/><div id="42237084" class="c"><input type="checkbox" id="c-42237084" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236688">parent</a><span>|</span><a href="#42239549">next</a><span>|</span><label class="collapse" for="c-42237084">[-]</label><label class="expand" for="c-42237084">[5 more]</label></div><br/><div class="children"><div class="content">The only way to get anywhere is provide a path forward.  I have a lot of C++98 code that has been working just find for 14+years (that is since before C++11).  It isn&#x27;t worth changing that unless we discover a bug in the code (after 14+ years unlikely) or we need to add new features (if we haven&#x27;t in 14+ years we probably won&#x27;t need a new feature there anytime soon).  Code I write today is the latest C++. What I really want is a way to say don&#x27;t write the bad things today, but still allow that old code to work.  That is what profiles promises to me.  Sure we will never to get full memory safety that way, but that isn&#x27;t my goal, I just want to make my new code better, and when I come back to old code improve that too.</div><br/><div id="42237341" class="c"><input type="checkbox" id="c-42237341" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42237084">parent</a><span>|</span><a href="#42239549">next</a><span>|</span><label class="collapse" for="c-42237341">[-]</label><label class="expand" for="c-42237341">[4 more]</label></div><br/><div class="children"><div class="content">The case for &quot;100% Safe C++&quot; is that you might be able to annotate that old C++98 code in ways that don&#x27;t otherwise alter its semantics, but still ensure safety.  That would be a one-time cost that might be well-worth paying if the cost is low enough - Where &quot;cost&quot; depends on developer experience as opposed to mere volume of annotations.  A &quot;viral&quot; compiler feature that auto-surfaces all the places that will need annotation for a given level of safety has the potential to be quite easy to learn and use effectively.  It&#x27;s not clear why the C++ folks are rejecting that approach, seemingly out-of-hand.</div><br/><div id="42238568" class="c"><input type="checkbox" id="c-42238568" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42237341">parent</a><span>|</span><a href="#42239549">next</a><span>|</span><label class="collapse" for="c-42238568">[-]</label><label class="expand" for="c-42238568">[3 more]</label></div><br/><div class="children"><div class="content">I have &gt; 10 million lines of C++ that is not annotated.  There are many projects much larger than mine.  If you cannot automatically annotate the code there is no point in trying as you can&#x27;t do it manually. If you can automate it why not just build that into the compiler and skip the syntax?</div><br/><div id="42239681" class="c"><input type="checkbox" id="c-42239681" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238568">parent</a><span>|</span><a href="#42239549">next</a><span>|</span><label class="collapse" for="c-42239681">[-]</label><label class="expand" for="c-42239681">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you cannot automatically annotate the code there is no point in trying as you can&#x27;t do it manually.<p>How can you know this without a &quot;viral&quot; analysis that tells you how much annotation is needed, and where?  Perhaps the code factors out all the low-level, &quot;memory unsafe&quot; hacks to its own module, and that can be feasibly annotated.  It&#x27;s just not something we can know in advance.</div><br/><div id="42240254" class="c"><input type="checkbox" id="c-42240254" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239681">parent</a><span>|</span><a href="#42239549">next</a><span>|</span><label class="collapse" for="c-42240254">[-]</label><label class="expand" for="c-42240254">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Perhaps the code factors out all the low-level, &quot;memory unsafe&quot; hacks to its own module, and that can be feasibly annotated.<p>While it is theoretically not impossible for that scenario to occur, I&#x27;d say it sounds wildly unlikely for anything that can be descried as &#x27;old&#x27; code.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42239549" class="c"><input type="checkbox" id="c-42239549" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236688">parent</a><span>|</span><a href="#42237084">prev</a><span>|</span><a href="#42239577">next</a><span>|</span><label class="collapse" for="c-42239549">[-]</label><label class="expand" for="c-42239549">[3 more]</label></div><br/><div class="children"><div class="content">I suspect the best case scenario is a &quot;Stone soup&quot;. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stone_Soup" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stone_Soup</a><p>The fantasy is enough to get engagement and once you have engagement you can persuade people to do a &quot;little&quot; extra work to get the full benefits. My mother won&#x27;t buy the product for $5, but if you tell her that it costs $10 but they&#x27;re 2-for-1 today, she&#x27;s going to buy that and feel like she got a bargain.<p>In terms of actually solving the problem well, it&#x27;s not even captured in these hypothetical regulatory requirements. What you actually want is a <i>safety culture</i>, Rust has one, C++ does not, and no technology will change that. From what I can tell nobody at WG21 wants that to change anyway.</div><br/><div id="42243371" class="c"><input type="checkbox" id="c-42243371" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239549">parent</a><span>|</span><a href="#42240967">next</a><span>|</span><label class="collapse" for="c-42243371">[-]</label><label class="expand" for="c-42243371">[1 more]</label></div><br/><div class="children"><div class="content">If you have access to the WG21 meeting minutes, it appears the safety discussions of the last meeting were quite entertaining.</div><br/></div></div><div id="42240967" class="c"><input type="checkbox" id="c-42240967" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239549">parent</a><span>|</span><a href="#42243371">prev</a><span>|</span><a href="#42239577">next</a><span>|</span><label class="collapse" for="c-42240967">[-]</label><label class="expand" for="c-42240967">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What you actually want is a safety culture, Rust has one<p>Rust has a safety culture <i>because</i> it involves requirements for Safe Rust that preserve safety while also playing well with modularity and iterative development.  If &quot;Safe C++&quot; can enforce similar requirements, we can expect that a safety culture can be sustained there as well.</div><br/></div></div></div></div></div></div><div id="42239577" class="c"><input type="checkbox" id="c-42239577" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236649">parent</a><span>|</span><a href="#42236688">prev</a><span>|</span><a href="#42235026">next</a><span>|</span><label class="collapse" for="c-42239577">[-]</label><label class="expand" for="c-42239577">[4 more]</label></div><br/><div class="children"><div class="content">Look, we need more than just promises. C++ is charting a future to the past in the most torturously slow process possible, primarily because of absolutely intrasigent performance obsession that won&#x27;t even admit the possibility of a 1% performance overhead for bounds checks. The C++ steering committee are the real extremists that are holding back the entire software industry because of a sacred cow and a free pass to externalize that cost onto the rest of us in terms of significantly less secure software.</div><br/><div id="42239939" class="c"><input type="checkbox" id="c-42239939" checked=""/><div class="controls bullet"><span class="by">bagxrvxpepzn</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239577">parent</a><span>|</span><a href="#42235026">next</a><span>|</span><label class="collapse" for="c-42239939">[-]</label><label class="expand" for="c-42239939">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The C++ steering committee are the real extremists that are holding back the entire software industry because of a sacred cow and a free pass to externalize that cost onto the rest of us in terms of significantly less secure software.<p>The C++ leadership serves the C++ community, not the entire software industry. You and everyone who disagrees with them are free to use and write software based on other languages, e.g. Java and Rust.</div><br/><div id="42243376" class="c"><input type="checkbox" id="c-42243376" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239939">parent</a><span>|</span><a href="#42240955">next</a><span>|</span><label class="collapse" for="c-42243376">[-]</label><label class="expand" for="c-42243376">[1 more]</label></div><br/><div class="children"><div class="content">Many in the C++ community wouldn&#x27;t acknowledge that.<p>Which is why disabling RTTI, disabling exceptions, creating their own standard library replacement, static analysers forbinding specific language constructs, is such a big deal in some C++ circles.</div><br/></div></div><div id="42240955" class="c"><input type="checkbox" id="c-42240955" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239939">parent</a><span>|</span><a href="#42243376">prev</a><span>|</span><a href="#42235026">next</a><span>|</span><label class="collapse" for="c-42240955">[-]</label><label class="expand" for="c-42240955">[1 more]</label></div><br/><div class="children"><div class="content">You can even add nonstandard features to existing compilers!<p>The neat thing is that once the standard committee learns about this use case, it could get de facto support as existing use!</div><br/></div></div></div></div></div></div></div></div><div id="42235026" class="c"><input type="checkbox" id="c-42235026" checked=""/><div class="controls bullet"><span class="by">sumanthvepa</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42236649">prev</a><span>|</span><a href="#42232665">next</a><span>|</span><label class="collapse" for="c-42235026">[-]</label><label class="expand" for="c-42235026">[12 more]</label></div><br/><div class="children"><div class="content">Thank you for this. C++ should NOT try to be Rust. I find modern C++ really nice to program in, for the work I&#x27;m doing - 3D graphics. The combination of very powerful abstractions and excellent performance is what I&#x27;m looking for. I&#x27;m more than willing to endure percived lack of safety in the language.</div><br/><div id="42237636" class="c"><input type="checkbox" id="c-42237636" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235026">parent</a><span>|</span><a href="#42232665">next</a><span>|</span><label class="collapse" for="c-42237636">[-]</label><label class="expand" for="c-42237636">[11 more]</label></div><br/><div class="children"><div class="content">The lack of safety is <i>perceived</i> because it is there. There is no proof that anyone can write a C++ program larger than, say, 100k lines of code that doesn&#x27;t have memory safety issues.</div><br/><div id="42238494" class="c"><input type="checkbox" id="c-42238494" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42237636">parent</a><span>|</span><a href="#42232665">next</a><span>|</span><label class="collapse" for="c-42238494">[-]</label><label class="expand" for="c-42238494">[10 more]</label></div><br/><div class="children"><div class="content">And that memory safety is completely not an issue if you&#x27;re writing something like a game, trading system, simulation, internal application or science calculation where there&#x27;s no potentially hostile users who could do real harm by hacking your code. It&#x27;s just a class of bug that in modern C++ is generally far outnumbered by logic bugs.</div><br/><div id="42239656" class="c"><input type="checkbox" id="c-42239656" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238494">parent</a><span>|</span><a href="#42239626">next</a><span>|</span><label class="collapse" for="c-42239656">[-]</label><label class="expand" for="c-42239656">[8 more]</label></div><br/><div class="children"><div class="content">Games absolutely are a problem for lack of memory safety - because the majority of games played today are connected to the internet explicitly. For trading system I don&#x27;t even know what you mean, but I can&#x27;t think of a trading system where you <i>wouldn&#x27;t</i> care about security.<p>For simulations and scientific calculations, I do agree, to a vast extent. But in a world that is moving more and more towards zero-trust networking, even many of those will start being looked at as potential attack vectors into other systems.</div><br/><div id="42241521" class="c"><input type="checkbox" id="c-42241521" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239656">parent</a><span>|</span><a href="#42240268">next</a><span>|</span><label class="collapse" for="c-42241521">[-]</label><label class="expand" for="c-42241521">[3 more]</label></div><br/><div class="children"><div class="content">As a DAW developer, I find myself chuckling over security concerns in other kinds of apps.<p>You see, it is absolutely expected and required that our applications will load and run arbitrary 3rd party code, generally with the expectation that it lives in the same address space as our application (though this is not formally required).<p>No sockets, no network, no backdoor hacks. You write code, call it a VST plugin, make it sound desirable ... we are expected to load and run it.<p>Yes, several DAWs have made the move toward out-of-process execution of plugins, but that doesn&#x27;t begin to address the myriad problems caused by loosely-written plugin APIs not adequately pinning down threading, thread priority, memory access and more.<p>Filesystem access? Of course! That code runs as you! Because you want it to!</div><br/><div id="42242558" class="c"><input type="checkbox" id="c-42242558" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42241521">parent</a><span>|</span><a href="#42240268">next</a><span>|</span><label class="collapse" for="c-42242558">[-]</label><label class="expand" for="c-42242558">[2 more]</label></div><br/><div class="children"><div class="content">And when someone creates a project file that sends them the personal information of anyone who opens it, is that an issue? Yes, pervasive arbitrary code plugins are game over if you can get anyone to use your plugin, but there&#x27;s at least some awareness that you need to be careful opening a plugin you don&#x27;t trust.</div><br/><div id="42242571" class="c"><input type="checkbox" id="c-42242571" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42242558">parent</a><span>|</span><a href="#42240268">next</a><span>|</span><label class="collapse" for="c-42242571">[-]</label><label class="expand" for="c-42242571">[1 more]</label></div><br/><div class="children"><div class="content">Not sure that&#x27;s true for the majority of DAW users.<p>Plugins are not associated with attack vectors, even though they are literally just that.</div><br/></div></div></div></div></div></div><div id="42240268" class="c"><input type="checkbox" id="c-42240268" checked=""/><div class="controls bullet"><span class="by">PLG88</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42239656">parent</a><span>|</span><a href="#42241521">prev</a><span>|</span><a href="#42239626">next</a><span>|</span><label class="collapse" for="c-42240268">[-]</label><label class="expand" for="c-42240268">[4 more]</label></div><br/><div class="children"><div class="content">I may be off base, but as the world moves to zero-trust networking, we can always embed a zero-trust network into our C++ app so that it can be distributed across the network while having no listening ports on the underlay network  - i.e., my memory safety exploit cannot just be exploited by anyone on the WAN, LAN, or host OS network. My C++ app unattackable via conventional IP-based tooling, all conventional network threats are immediately useless.<p>This capability exists in completely open source, such as OpenZiti - <a href="https:&#x2F;&#x2F;openziti.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;openziti.io&#x2F;</a>.</div><br/><div id="42240851" class="c"><input type="checkbox" id="c-42240851" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42240268">parent</a><span>|</span><a href="#42239626">next</a><span>|</span><label class="collapse" for="c-42240851">[-]</label><label class="expand" for="c-42240851">[3 more]</label></div><br/><div class="children"><div class="content">The way C and C++ are standardized, you can&#x27;t rely on the correct functioning of anything in the presence of undefined behavior, including memory unsafety. For what it&#x27;s worth, I also opened a random file in the OpenZiti C SDK and immediately found safety issues like this: <a href="https:&#x2F;&#x2F;github.com&#x2F;openziti&#x2F;ziti-tunnel-sdk-c&#x2F;blob&#x2F;9993f61e6ad4c975147ab5b15593f1cec3705d3a&#x2F;lib&#x2F;ziti-tunnel&#x2F;ziti_tunnel.c#L671">https:&#x2F;&#x2F;github.com&#x2F;openziti&#x2F;ziti-tunnel-sdk-c&#x2F;blob&#x2F;9993f61e6...</a><p>That&#x27;s why this topic is such a big deal. Even people who really should know better like the OpenZiti authors aren&#x27;t able to reliably write safe code.</div><br/><div id="42242896" class="c"><input type="checkbox" id="c-42242896" checked=""/><div class="controls bullet"><span class="by">drivebyhooting</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42240851">parent</a><span>|</span><a href="#42239626">next</a><span>|</span><label class="collapse" for="c-42242896">[-]</label><label class="expand" for="c-42242896">[2 more]</label></div><br/><div class="children"><div class="content">Why is that a safety issue?</div><br/><div id="42243067" class="c"><input type="checkbox" id="c-42243067" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42242896">parent</a><span>|</span><a href="#42239626">next</a><span>|</span><label class="collapse" for="c-42243067">[-]</label><label class="expand" for="c-42243067">[1 more]</label></div><br/><div class="children"><div class="content">Malloc&#x2F;Calloc can fail even if they typically don&#x27;t on most Linux systems. You should always check for null pointers before accessing the resulting buffer, which doesn&#x27;t happen here. The connections() block is also never explicitly freed anywhere I was able to find in a quick search. That&#x27;s allowed, but definitely bad practice.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42239626" class="c"><input type="checkbox" id="c-42239626" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238494">parent</a><span>|</span><a href="#42239656">prev</a><span>|</span><a href="#42232665">next</a><span>|</span><label class="collapse" for="c-42239626">[-]</label><label class="expand" for="c-42239626">[1 more]</label></div><br/><div class="children"><div class="content">The issue of memory safety goes well beyond adversaries &quot;hacking your code&quot;.  Without memory safety, your code doesn&#x27;t even have any kind of well-defined semantics so it&#x27;s not feasible to defend against even &quot;logic&quot; bugs by automated means.<p>If you care about program correctness in any real sense, memory safety is table stakes.</div><br/></div></div></div></div></div></div></div></div><div id="42232665" class="c"><input type="checkbox" id="c-42232665" checked=""/><div class="controls bullet"><span class="by">feelamee</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42235026">prev</a><span>|</span><a href="#42232130">next</a><span>|</span><label class="collapse" for="c-42232665">[-]</label><label class="expand" for="c-42232665">[7 more]</label></div><br/><div class="children"><div class="content">Ok.
Please, just use your current C++ standard.
But we will go to use the new one with all features we want to use.</div><br/><div id="42243293" class="c"><input type="checkbox" id="c-42243293" checked=""/><div class="controls bullet"><span class="by">blub</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232665">parent</a><span>|</span><a href="#42232130">next</a><span>|</span><label class="collapse" for="c-42243293">[-]</label><label class="expand" for="c-42243293">[6 more]</label></div><br/><div class="children"><div class="content">Whoâs âweâ? The C++ developers that like the âSafe C++â proposal which is tacking Rust on top of C++ are a tiny minority.<p>It seems very fair to tell them to just use Rust and leave C++ alone.</div><br/><div id="42243403" class="c"><input type="checkbox" id="c-42243403" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42243293">parent</a><span>|</span><a href="#42232130">next</a><span>|</span><label class="collapse" for="c-42243403">[-]</label><label class="expand" for="c-42243403">[5 more]</label></div><br/><div class="children"><div class="content">Indeed, that is exactly what many FAANG companies are doing, have you noticed the slow down in velocity in major compilers regarding ISO C++ compliance?</div><br/><div id="42243658" class="c"><input type="checkbox" id="c-42243658" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42243403">parent</a><span>|</span><a href="#42243520">next</a><span>|</span><label class="collapse" for="c-42243658">[-]</label><label class="expand" for="c-42243658">[2 more]</label></div><br/><div class="children"><div class="content">See Appleâs slowdown on clang development and subsequent advances in Swift&lt;-&gt;C++ interop (even going as far as merging Swift code into FoundationDB)<p>And ofc Googleâs investment in Carbon</div><br/><div id="42243727" class="c"><input type="checkbox" id="c-42243727" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42243658">parent</a><span>|</span><a href="#42243520">next</a><span>|</span><label class="collapse" for="c-42243727">[-]</label><label class="expand" for="c-42243727">[1 more]</label></div><br/><div class="children"><div class="content">Or MSVC slow pace with C++23, after being the first to reach full C++20 support.<p>Everyone else outside the big three, is somewhere between C++14 and C++17.</div><br/></div></div></div></div><div id="42243520" class="c"><input type="checkbox" id="c-42243520" checked=""/><div class="controls bullet"><span class="by">blub</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42243403">parent</a><span>|</span><a href="#42243658">prev</a><span>|</span><a href="#42232130">next</a><span>|</span><label class="collapse" for="c-42243520">[-]</label><label class="expand" for="c-42243520">[2 more]</label></div><br/><div class="children"><div class="content">Nope, still using C++17 and not bothered by any slowdown. 
C++ has been moving too fast lately.</div><br/><div id="42243721" class="c"><input type="checkbox" id="c-42243721" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42243520">parent</a><span>|</span><a href="#42232130">next</a><span>|</span><label class="collapse" for="c-42243721">[-]</label><label class="expand" for="c-42243721">[1 more]</label></div><br/><div class="children"><div class="content">It is currently an open debate what will be the very last ISO version the world will care about, C++17 might be the one, or C++26, bets are open.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42232130" class="c"><input type="checkbox" id="c-42232130" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232665">prev</a><span>|</span><a href="#42234700">next</a><span>|</span><label class="collapse" for="c-42232130">[-]</label><label class="expand" for="c-42232130">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, why would I not want these things in C++ if I&#x27;m developing every project with -fsanitize=address,undefined to catch these types of errors anyway?</div><br/></div></div><div id="42234700" class="c"><input type="checkbox" id="c-42234700" checked=""/><div class="controls bullet"><span class="by">Attrecomet</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232130">prev</a><span>|</span><a href="#42235733">next</a><span>|</span><label class="collapse" for="c-42234700">[-]</label><label class="expand" for="c-42234700">[3 more]</label></div><br/><div class="children"><div class="content">What I don&#x27;t understand is why you demand that C++ evolution be halted in a clearly suboptimal position so you don&#x27;t need to change your processes. Just use the version of C++ that meets your needs, you clearly don&#x27;t want nor need new developments. You are fine with being locked into bad designs for hash maps and unique ptr due to the (newly invented, in 2011&#x2F;13) ABI stability being made inviolable, you clearly need no new developments in usability and security.<p>So why not be honest and just use C++01, or 11, or whatever it is that works for you, and let the rest of the ecosystem actually evolve and keep the language we invested so much effort into as a viable alternative? There&#x27;s zero benefit, except to MS who want to sell this year&#x27;s Visual Studio to all the companies with 80&#x27;s-era C++...</div><br/><div id="42235783" class="c"><input type="checkbox" id="c-42235783" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42234700">parent</a><span>|</span><a href="#42239079">next</a><span>|</span><label class="collapse" for="c-42235783">[-]</label><label class="expand" for="c-42235783">[1 more]</label></div><br/><div class="children"><div class="content">&gt; evolution be halted in a clearly suboptimal position<p>Itâs clear itâs imperfect. But not clear there is an obvious path to a nearby local maxima.<p>Design choices have tradeoffs.<p>And even if that were true, who would take advantage of that âbetterâ language in a purely abstract sense? New language standards primarily exist to benefit existing C++ code bases, and the cohort of engineers who work on them. You have to consider that social reality.</div><br/></div></div><div id="42239079" class="c"><input type="checkbox" id="c-42239079" checked=""/><div class="controls bullet"><span class="by">bagxrvxpepzn</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42234700">parent</a><span>|</span><a href="#42235783">prev</a><span>|</span><a href="#42235733">next</a><span>|</span><label class="collapse" for="c-42239079">[-]</label><label class="expand" for="c-42239079">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What I don&#x27;t understand is why you demand that C++ evolution be halted in a clearly suboptimal position so you don&#x27;t need to change your processes.<p>I don&#x27;t demand that C++ evolution be halted. I support the current trajectory of not adding viral annotations for the sake of implementing static lifetime checking. I want C++ to evolve into a better version of itself, I don&#x27;t want it to become something it&#x27;s not. If you want static lifetime checking, please use Rust. It already exists and it&#x27;s great for people who need static lifetime checking.</div><br/></div></div></div></div><div id="42235733" class="c"><input type="checkbox" id="c-42235733" checked=""/><div class="controls bullet"><span class="by">chlorion</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42234700">prev</a><span>|</span><a href="#42238691">next</a><span>|</span><label class="collapse" for="c-42235733">[-]</label><label class="expand" for="c-42235733">[5 more]</label></div><br/><div class="children"><div class="content">Imagine an engineer in any other field acting like this.<p>&quot;I don&#x27;t want to install air bags and these shiny safety gadgets into my cars. We have been shipping cars without them for years and it works for us and our customers.&quot;<p>The problem is that it doesn&#x27;t actually work as well as you think, and you are putting people at risk without realizing it.</div><br/><div id="42237638" class="c"><input type="checkbox" id="c-42237638" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235733">parent</a><span>|</span><a href="#42242396">next</a><span>|</span><label class="collapse" for="c-42237638">[-]</label><label class="expand" for="c-42237638">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re trying to install airbags on a motorcycle, though. The design of the vehicle&#x2F;language is incompatible with airbags&#x2F;lifetimes. So if you want airbags... don&#x27;t use C++.<p>(Yes, I know about airbag vests. Let&#x27;s analogize those with external static checkers.)</div><br/></div></div><div id="42242396" class="c"><input type="checkbox" id="c-42242396" checked=""/><div class="controls bullet"><span class="by">bookspace</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235733">parent</a><span>|</span><a href="#42237638">prev</a><span>|</span><a href="#42236373">next</a><span>|</span><label class="collapse" for="c-42242396">[-]</label><label class="expand" for="c-42242396">[1 more]</label></div><br/><div class="children"><div class="content">What if, bagxrv, is a Rust fan, just playing ya? Everyone knows Rust fans are the most vigorous developers on the internet. Just take a look at <a href="https:&#x2F;&#x2F;izzys.casa&#x2F;2024&#x2F;11&#x2F;on-safe-cxx&#x2F;" rel="nofollow">https:&#x2F;&#x2F;izzys.casa&#x2F;2024&#x2F;11&#x2F;on-safe-cxx&#x2F;</a></div><br/></div></div><div id="42236373" class="c"><input type="checkbox" id="c-42236373" checked=""/><div class="controls bullet"><span class="by">downut</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42235733">parent</a><span>|</span><a href="#42242396">prev</a><span>|</span><a href="#42238691">next</a><span>|</span><label class="collapse" for="c-42236373">[-]</label><label class="expand" for="c-42236373">[2 more]</label></div><br/><div class="children"><div class="content">You are making a general statement about the distribution of general consumers of computer languages, complete with a long tail, and the commenter is explaining that he is an expert car driver, way out there on the long tail.  This tyranny of the less capable mode is really grating, especially on a site named &quot;Hacker News&quot;.<p>As usual, the answer is quite simple: &quot;please use rust&quot;.  We promise to never mention when we break out nasm.<p>Driver anecdote:  I have antilock brakes on my Tundra, but they are annoyingly counterproductive in 4WD descending 6&quot; or larger sandy rocky steps.  Do antilock brakes work overall best for the less capable mode?  Of course!  Do they work best for me?  No.</div><br/><div id="42236588" class="c"><input type="checkbox" id="c-42236588" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42236373">parent</a><span>|</span><a href="#42238691">next</a><span>|</span><label class="collapse" for="c-42236588">[-]</label><label class="expand" for="c-42236588">[1 more]</label></div><br/><div class="children"><div class="content">We learned a long time ago as an industry that the expert car drivers are not immune to causing pile ups, which makes it all our problem to solve.<p>Safety by default with escape hatches when absolutely necessary is the better way to go for all, even if it means some power users have to change their ways.</div><br/></div></div></div></div></div></div><div id="42238691" class="c"><input type="checkbox" id="c-42238691" checked=""/><div class="controls bullet"><span class="by">lubesGordi</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42235733">prev</a><span>|</span><a href="#42232136">next</a><span>|</span><label class="collapse" for="c-42238691">[-]</label><label class="expand" for="c-42238691">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know enough about what it would take to implement static lifetime checking.  Is that fundamentally impossible to do in a backwards compatible way?</div><br/><div id="42238977" class="c"><input type="checkbox" id="c-42238977" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238691">parent</a><span>|</span><a href="#42239066">next</a><span>|</span><label class="collapse" for="c-42238977">[-]</label><label class="expand" for="c-42238977">[1 more]</label></div><br/><div class="children"><div class="content">It depends on what you mean by &quot;backwards compatible,&quot; and what you mean by &quot;static lifetime checking&quot; :)<p>The profiles proposal suggests adding static lifetime checking, &quot;without viral annotations.&quot; I use quotations because I don&#x27;t really agree with this framing, but whatever. The paper is here if you&#x27;d like to read it yourself: <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p3081r0.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p30...</a><p>The core idea here is that you add annotations to opt in or out of certain checks. And opting in may be a compiler flag, requiring no changes to source code. So that would be &quot;backwards compatibility&quot; in that sense. Of course, code may fail these checks, so you&#x27;ll have to add annotations to opt out, or re-write the code. We will see in practice how much change is required once implementations exist and are tried out.<p>But the other part is, these profiles do not attempt to cover all valid cases. And what I mean by that is, there are some lifetime issues that this proposal does not attempt to analyze. And, where the analysis is similar, they offer a subset of what other proposals do. These decisions were made because the authors believe that they&#x27;ll reduce a significant number of issues, and are easier to adopt. And that&#x27;s worth it instead of going for more checks.<p>The competing proposal, Safe C++, has you opt into safety checks on a file-per-file basis. So in that sense, it is also backwards compatible: all existing code compiles as-is. When you opt in to those checks, it adds new syntax, similar to Rust, to do the safety analysis checks. So you gain this benefit for only new code, but it also you get much more power. This syntax is necessary to communicate programmer intent to the checks, but is the &quot;viral annotations&quot; that the proponents of profiles don&#x27;t like.<p>So, basically, that&#x27;s the thing: both are backwards compatible, but offer very different tradeoffs in the design space.</div><br/></div></div><div id="42239066" class="c"><input type="checkbox" id="c-42239066" checked=""/><div class="controls bullet"><span class="by">aiono</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42238691">parent</a><span>|</span><a href="#42238977">prev</a><span>|</span><a href="#42232136">next</a><span>|</span><label class="collapse" for="c-42239066">[-]</label><label class="expand" for="c-42239066">[1 more]</label></div><br/><div class="children"><div class="content">If you want alias tracking and lifetime checking, yes they are backwards incompatible. They need &quot;viral annotations&quot; if we speak with the C++ committee terminology.</div><br/></div></div></div></div><div id="42238728" class="c"><input type="checkbox" id="c-42238728" checked=""/><div class="controls bullet"><span class="by">mempko</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232136">prev</a><span>|</span><a href="#42232540">next</a><span>|</span><label class="collapse" for="c-42238728">[-]</label><label class="expand" for="c-42238728">[1 more]</label></div><br/><div class="children"><div class="content">This! The hardest part of making software is making something that works for people. What I love about C++ is multi-paradigm programming. I can express my ideas directly using the appropriate paradigms. Regarding safety, with modern C++ programming, it&#x27;s not hard to write software that&#x27;s correct. Safety is often never the first thing I worry about.<p>If having strict safety means I can&#x27;t express my mental models in code, I don&#x27;t want it. It will slow me down. It will make it harder to write software that&#x27;s useful.<p>Remember people, we are here to make things that are useful to people. If safety gets in the way of that, then it&#x27;s not worth it.</div><br/></div></div><div id="42232540" class="c"><input type="checkbox" id="c-42232540" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42238728">prev</a><span>|</span><a href="#42243069">next</a><span>|</span><label class="collapse" for="c-42232540">[-]</label><label class="expand" for="c-42232540">[3 more]</label></div><br/><div class="children"><div class="content">The parts of the government that think everything should be written in a memory-safe language (like Rust) are the same parts that already write everything in Java. Most of the high-end systems work is in C++, and that is the type of software where lifetimes and ownership are frequently unknowable at compile-time, obviating Rust&#x27;s main selling point.</div><br/><div id="42232824" class="c"><input type="checkbox" id="c-42232824" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232540">parent</a><span>|</span><a href="#42243069">next</a><span>|</span><label class="collapse" for="c-42232824">[-]</label><label class="expand" for="c-42232824">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a hard dichotomy. Almost all of the rules Rust imposes are also present in C++, enforcement is simply left up to the fallible human programmer. Frankly though, is it that big a deal whether we call it unique_ptr&#x2F;shared_ptr or Box&#x2F;Arc if a lifetime is truly unknowable?<p>Rust shines in the other 95% of code. I spend some time every morning cleaning up the sorts of issues Rust prevents that my coworkers have managed to commit despite  tooling safeguards. I try for 3 a day, the list is growing, and I don&#x27;t have to dig deep to find them. My coworkers aren&#x27;t stupid people, they&#x27;re intelligent people making simple mistakes because they aren&#x27;t computers. It won&#x27;t matter how often I tell them &quot;you made X mistake on Y line, which violates Z rule&quot; because the issue is not their knowledge, it&#x27;s the inherent inability of humans to follow onerous technical rules without mistakes.</div><br/><div id="42236826" class="c"><input type="checkbox" id="c-42236826" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232824">parent</a><span>|</span><a href="#42243069">next</a><span>|</span><label class="collapse" for="c-42236826">[-]</label><label class="expand" for="c-42236826">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I don&#x27;t end up fighting rust very often, and when I do, it is right. And when I run into a case that it isnt, I have unsafe and the rustonimicon to help me. You can do anything in rust you can do in c++, it is just that rust defaults to safe instead of unsafe, and there is no single keyword to let you know the c++ you are looking at is safe.</div><br/></div></div></div></div></div></div></div></div><div id="42243069" class="c"><input type="checkbox" id="c-42243069" checked=""/><div class="controls bullet"><span class="by">Mike4Online</span><span>|</span><a href="#42232004">prev</a><span>|</span><a href="#42235767">next</a><span>|</span><label class="collapse" for="c-42243069">[-]</label><label class="expand" for="c-42243069">[1 more]</label></div><br/><div class="children"><div class="content">C++ is not just C++ but also the C preprocessor, the STL, the linker, the C libraries and SDKs you can&#x27;t help but depend on, the build system, the build scripts, the package manager, the IDEs and IDE add-ons, the various quirks on various platforms, etc.  That&#x27;s on top of knowing the code base of your application.<p>Being really good at C++ almost demands that you surrender entire lobes of your brain to mastering the language.  It is too demanding and too dehumanizing.  Developers need a language and a complete tool chain that is designed as a cohesive whole, with as little implicit behavior, special cases and clever tricks as possible.  Simple and straight-forward.  Performance tweaks, memory optimizations and anything else that is not straightforward should be done exclusively by the compiler.  I.E. we should be leveraging computers to do what they do best, freeing our attention so we can focus on the next nifty feature we&#x27;re adding.<p>Zig is trying to do much of this, and it is a huge undertaking.  I think an even bigger undertaking than what Zig is attempting is needed.  The new &quot;language&quot; would also include a sophisticated IDE&#x2F;compiler&#x2F;static-analyzer&#x2F;AI-advisor&#x2F;Unit-Test-Generator that could detect and block the vast majority of memory safety errors, data races and other difficult bugs, and reveal such issues as the code is being written.  The tool chain would be sophisticated enough to handle the cognitive load rather than force the developer to bear that burden.</div><br/></div></div><div id="42235767" class="c"><input type="checkbox" id="c-42235767" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#42243069">prev</a><span>|</span><a href="#42231943">next</a><span>|</span><label class="collapse" for="c-42235767">[-]</label><label class="expand" for="c-42235767">[3 more]</label></div><br/><div class="children"><div class="content">There will be eventually only one faction left using C++ â the legacy too-big-to-refactor one.<p>The other faction that has lost faith in WG21, and wants newer, safer, nimble language with powerful tooling is already heading for the exits.<p>Herb has even directly said that adding lifetime annotations to C++ would create &quot;an off-ramp from C++&quot;[1] to the other languages â and he&#x27;s right, painful C++ interop is the primary thing slowing down adoption of Rust for new code in mixed codebases.<p>[1]: <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p3465r0.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2024&#x2F;p34...</a></div><br/><div id="42235990" class="c"><input type="checkbox" id="c-42235990" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#42235767">parent</a><span>|</span><a href="#42231943">next</a><span>|</span><label class="collapse" for="c-42235990">[-]</label><label class="expand" for="c-42235990">[2 more]</label></div><br/><div class="children"><div class="content">&gt; newer, safer, nimble<p>&quot;newer&quot; is hopefully a non-goal.<p>Unfortunately, an option that is both safer and nimble doesn&#x27;t appear to exist. I&#x27;m still hopeful, but at the moment it looks like rust is our future. A fate only marginally better than C++.</div><br/><div id="42237427" class="c"><input type="checkbox" id="c-42237427" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42235767">root</a><span>|</span><a href="#42235990">parent</a><span>|</span><a href="#42231943">next</a><span>|</span><label class="collapse" for="c-42237427">[-]</label><label class="expand" for="c-42237427">[1 more]</label></div><br/><div class="children"><div class="content">Everything out there is nimbler than C++. So you only have to select for safer to get those, and anything with managed memory and Rust are safer. (Not an exclusive set, but you&#x27;ll need to actually evaluate other options.)</div><br/></div></div></div></div></div></div><div id="42231943" class="c"><input type="checkbox" id="c-42231943" checked=""/><div class="controls bullet"><span class="by">adambatkin</span><span>|</span><a href="#42235767">prev</a><span>|</span><a href="#42236291">next</a><span>|</span><label class="collapse" for="c-42231943">[-]</label><label class="expand" for="c-42231943">[40 more]</label></div><br/><div class="children"><div class="content">Something that Rust got _really_ right:
 Editions. And not just that they exist, but that they are specified per module, and you can mix and match modules with different Editions within a bigger project. This lets a language make backwards incompatible changes, and projects can adopt the new features piecemeal.<p>If such a thing came to C++, there would obviously be limitations around module boundaries, when different modules used a different Edition. But perhaps this could be a way forward that could allow both camps to have their cake and eat it too.<p>Imagine a world where the main difference between Python 2 and 3 was the frontend syntax parser, and each module could specifically which syntax (&quot;Edition&quot;) it used...</div><br/><div id="42231993" class="c"><input type="checkbox" id="c-42231993" checked=""/><div class="controls bullet"><span class="by">CrendKing</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42234957">next</a><span>|</span><label class="collapse" for="c-42231993">[-]</label><label class="expand" for="c-42231993">[23 more]</label></div><br/><div class="children"><div class="content">But Edition can exist only because Rust intrinsically has the concept of package, which naturally defines the boundary. C++ has nothing. How do you denote a.cpp be of cpp_2017 edition which b.cpp be cpp_2026? Some per-file comment line at top of each file?<p>C++ is a mess in that it has too much historic baggage while trying to adapt to a fiercely changing landscape. Like the article says, it has to make drastic changes to keep up, but such changes will probably kill 80% of its target audiences. I think putting C++ in maintenance mode and keep it as a &quot;legacy&quot; language is the way to go. It is time to either switch to Rust, or pick one of its successor languages and put effort into it.</div><br/><div id="42233728" class="c"><input type="checkbox" id="c-42233728" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42231993">parent</a><span>|</span><a href="#42232044">next</a><span>|</span><label class="collapse" for="c-42233728">[-]</label><label class="expand" for="c-42233728">[6 more]</label></div><br/><div class="children"><div class="content">Rust doesn&#x27;t have the concept of package. (Cargo does, but Cargo is a different thing from Rust, and it&#x27;s entirely possible to use Rust without Cargo).<p>Rust has the concept of _crate_, which is very close to the concept of compilation unit in C++. You build a crate by invoking `rustc` with a particular set of arguments, just as you build a compilation unit by invoking `g++` or `clang++` with a particular set of arguments.<p>One of these arguments defines the edition, for Rust, just like it could for C++.</div><br/><div id="42235370" class="c"><input type="checkbox" id="c-42235370" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42233728">parent</a><span>|</span><a href="#42232044">next</a><span>|</span><label class="collapse" for="c-42235370">[-]</label><label class="expand" for="c-42235370">[5 more]</label></div><br/><div class="children"><div class="content">That only works for C++ code using C++20 modules (i.e. for approximately nothing).
With textual includes, you need to be able to switch back and forth the edition within a single compilation unit.</div><br/><div id="42240971" class="c"><input type="checkbox" id="c-42240971" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42235370">parent</a><span>|</span><a href="#42237141">next</a><span>|</span><label class="collapse" for="c-42240971">[-]</label><label class="expand" for="c-42240971">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not clear that modules alone will solve One Definition Rule issues that you&#x27;re describing. It&#x27;s actually more likely that programs will have different object files building against different Built Module Interfaces for the same module interface. Especially for widely used modules like the standard std one.<p>But! We&#x27;ll be able to see all the extra parsing happen so in theory you could track down the incompatibilities and do something about them.</div><br/></div></div><div id="42237141" class="c"><input type="checkbox" id="c-42237141" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42235370">parent</a><span>|</span><a href="#42240971">prev</a><span>|</span><a href="#42236262">next</a><span>|</span><label class="collapse" for="c-42237141">[-]</label><label class="expand" for="c-42237141">[2 more]</label></div><br/><div class="children"><div class="content">Modules are starting to come out.  They have some growing pains, but they are now ready for early adopters and are looking like they will be good.  I&#x27;m still in wait and see mode (I&#x27;m not an early adopter), but so far everything just looks like growing pains that will be solved and then they will take off.</div><br/><div id="42240875" class="c"><input type="checkbox" id="c-42240875" checked=""/><div class="controls bullet"><span class="by">calibas</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42237141">parent</a><span>|</span><a href="#42236262">next</a><span>|</span><label class="collapse" for="c-42240875">[-]</label><label class="expand" for="c-42240875">[1 more]</label></div><br/><div class="children"><div class="content">At the current rate, we&#x27;ll have full module support for all of the most popular C++ libraries sometime around Apr 7th, 2618.<p><a href="https:&#x2F;&#x2F;arewemodulesyet.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arewemodulesyet.org&#x2F;</a></div><br/></div></div></div></div><div id="42236262" class="c"><input type="checkbox" id="c-42236262" checked=""/><div class="controls bullet"><span class="by">epage</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42235370">parent</a><span>|</span><a href="#42237141">prev</a><span>|</span><a href="#42232044">next</a><span>|</span><label class="collapse" for="c-42236262">[-]</label><label class="expand" for="c-42236262">[1 more]</label></div><br/><div class="children"><div class="content">Mixing editions in a file happens in Rust with the macro system. You write a macro to generate code in your edition and the generation happens in the callers crate, no matter what edition it is.</div><br/></div></div></div></div></div></div><div id="42232044" class="c"><input type="checkbox" id="c-42232044" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42231993">parent</a><span>|</span><a href="#42233728">prev</a><span>|</span><a href="#42236707">next</a><span>|</span><label class="collapse" for="c-42232044">[-]</label><label class="expand" for="c-42232044">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I think putting C++ in maintenance mode and keep it as a &quot;legacy&quot; language is the way to go<p>I agree but also understand this is absolutely wishful thinking. There is so much inertia and natural resistance to change that C++ will be around for the next century barring nuclear armageddon.</div><br/><div id="42232358" class="c"><input type="checkbox" id="c-42232358" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232044">parent</a><span>|</span><a href="#42232275">next</a><span>|</span><label class="collapse" for="c-42232358">[-]</label><label class="expand" for="c-42232358">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think even that would suffice. :)</div><br/></div></div><div id="42232275" class="c"><input type="checkbox" id="c-42232275" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232044">parent</a><span>|</span><a href="#42232358">prev</a><span>|</span><a href="#42236707">next</a><span>|</span><label class="collapse" for="c-42232275">[-]</label><label class="expand" for="c-42232275">[4 more]</label></div><br/><div class="children"><div class="content">Cobol&#x27;s still around. Just because a language exists doesn&#x27;t mean that we have to keep releasing updated specifications and compiler versions rather than moving all those resources to better languages.</div><br/><div id="42232389" class="c"><input type="checkbox" id="c-42232389" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232275">parent</a><span>|</span><a href="#42236707">next</a><span>|</span><label class="collapse" for="c-42232389">[-]</label><label class="expand" for="c-42232389">[3 more]</label></div><br/><div class="children"><div class="content">COBOL&#x27;s most recent standard was released in 2023, which rather ruins your point.</div><br/><div id="42241107" class="c"><input type="checkbox" id="c-42241107" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232389">parent</a><span>|</span><a href="#42236707">next</a><span>|</span><label class="collapse" for="c-42241107">[-]</label><label class="expand" for="c-42241107">[2 more]</label></div><br/><div class="children"><div class="content">I think the existence of COBOL-2023 actually suggests that it&#x27;s not merely possible that in effect C++ 26 is the last C++ but that maybe C++ 17 was (in the same sense) already the last C++ and we just didn&#x27;t know it.<p>After all doubtless COBOL&#x27;s proponents did not regard COBOL-85 as the last COBOL - from their point of view COBOL-2002 was just a somewhat delayed further revision of the language that people had previously overlooked, surely now things were back on track. But in practice yeah, by the time of COBOL-2002 that&#x27;s a dead language.</div><br/><div id="42243426" class="c"><input type="checkbox" id="c-42243426" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42241107">parent</a><span>|</span><a href="#42236707">next</a><span>|</span><label class="collapse" for="c-42243426">[-]</label><label class="expand" for="c-42243426">[1 more]</label></div><br/><div class="children"><div class="content">Fully agree, because for the use cases of being a safer C, and keeping stuff like LLVM and GCC running, that is already good enough.<p>From my point of view C++26 is going to be the last one that actually matters, because too many are looking forward to whatever reflection support it can provide, otherwise that would be C++23.<p>There is also the whole issue that past C++17, all compilers seem like a swiss cheese in language support for the two following language revisions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42236707" class="c"><input type="checkbox" id="c-42236707" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42231993">parent</a><span>|</span><a href="#42232044">prev</a><span>|</span><a href="#42234957">next</a><span>|</span><label class="collapse" for="c-42236707">[-]</label><label class="expand" for="c-42236707">[10 more]</label></div><br/><div class="children"><div class="content">&gt; I think putting C++ in maintenance mode and keep it as a &quot;legacy&quot; language is the way to go<p>That is not possible. The the following function in C++ std::vector&lt;something&gt; doSomething(std::string);  Simple enough, memory safe (at least the interface, who knows what happens inside), performant, but how do you call that function from anything else? If you want to use anything else with C++ it needs to speak C++ and the means vector and string needs to interoperate.</div><br/><div id="42236735" class="c"><input type="checkbox" id="c-42236735" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42236707">parent</a><span>|</span><a href="#42237293">next</a><span>|</span><label class="collapse" for="c-42236735">[-]</label><label class="expand" for="c-42236735">[8 more]</label></div><br/><div class="children"><div class="content">You can interoperate via C ABI and just not use the C++ standard types across modules - which is the sane thing to do.  Every other language that supports FFI via C linkage does this, only C++ insists on this craziness.</div><br/><div id="42236864" class="c"><input type="checkbox" id="c-42236864" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42236735">parent</a><span>|</span><a href="#42237168">next</a><span>|</span><label class="collapse" for="c-42236864">[-]</label><label class="expand" for="c-42236864">[3 more]</label></div><br/><div class="children"><div class="content">Also I wouldn&#x27;t start by rewriting the thing that calls do_something, I&#x27;d start by rewriting do_something. Calling into rust from c++ using something like zngur lets you define rust types in c++ and then call idiomatic rust. You can&#x27;t do it in the opposite direction because you cannot safely represent all c++ types in rust, because some of them aren&#x27;t safe.</div><br/><div id="42237222" class="c"><input type="checkbox" id="c-42237222" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42236864">parent</a><span>|</span><a href="#42237168">next</a><span>|</span><label class="collapse" for="c-42237222">[-]</label><label class="expand" for="c-42237222">[2 more]</label></div><br/><div class="children"><div class="content">I have millions of lines of C++.  do_something exists and is used but a lot of those lines and works well. I have a new feature that needs to call do_something.  I&#x27;m not rewriting any code.  My current code base was a rewrite of previous code into C++ started before rust existed), and it costs a nearly a billion dollars! I cannot go to my bosses and say that expensive rewrite that is only now starting to pay off because of how much better our code is needs to be scrapped.  Maybe in 20 years we can ask for another billion (adjust for inflation) to rewrite again, but today either I write C++, or I interoperate with existing C++ with minimal effort.<p>I&#x27;m working on interoperation with existing C++. It is a hard problem and so far every answer I&#x27;ve found means all of our new features still needs to be written in C++ but now I&#x27;m putting in a framework where that code could be used by non-C++.  I hope in 5 years that framework is in place by enough that early adopters can write something other than C++ - only time will tell though.</div><br/><div id="42237411" class="c"><input type="checkbox" id="c-42237411" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42237222">parent</a><span>|</span><a href="#42237168">next</a><span>|</span><label class="collapse" for="c-42237411">[-]</label><label class="expand" for="c-42237411">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that use case is harder, but I&#x27;m involved in a similar one. Our approach is to split off new work as a separate process when possible and do it entirely in rust. You can call into c++ from rust, it just means more unsafe code in rust wrapping the c++ that has to change when you or your great grandchild finally do get around to writing do_something in rust. I am super aware of how daunting it is, especially if your customer base isn&#x27;t advocating for the switch. Which most don&#x27;t care until they get pwned and then they come with lawyers. Autocxx has proven a painful way to go. The chrome team has had some input to stuff and seem to be making it better.</div><br/></div></div></div></div></div></div><div id="42237168" class="c"><input type="checkbox" id="c-42237168" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42236735">parent</a><span>|</span><a href="#42236864">prev</a><span>|</span><a href="#42237293">next</a><span>|</span><label class="collapse" for="c-42237168">[-]</label><label class="expand" for="c-42237168">[4 more]</label></div><br/><div class="children"><div class="content">Sure I can do that - but my example C++ function is fully memory safe (other than don&#x27;t go off the end of the vector which static rules can enforce by banning []). If I make a C wrapper I just lost all the memory safety and now I&#x27;m at higher risk.  Plus the effort to build that wrapper is not zero (though there are some generators that help)</div><br/><div id="42237747" class="c"><input type="checkbox" id="c-42237747" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42237168">parent</a><span>|</span><a href="#42237293">next</a><span>|</span><label class="collapse" for="c-42237747">[-]</label><label class="expand" for="c-42237747">[3 more]</label></div><br/><div class="children"><div class="content">How about going off the end of the vector with an iterator, or modifying the vector while iterating it, or adding to the vector from two different threads or reading from one thread while another is modifying it or [...].<p>There is nothing memory safe whatsoever about std::vector&lt;something&gt; and std::string. Sure, they give you access to their allocated length, so they&#x27;re better than something[] and char* (which often also know the size of their allocations, but refuse to tell you).</div><br/><div id="42238551" class="c"><input type="checkbox" id="c-42238551" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42237747">parent</a><span>|</span><a href="#42237293">next</a><span>|</span><label class="collapse" for="c-42238551">[-]</label><label class="expand" for="c-42238551">[2 more]</label></div><br/><div class="children"><div class="content">&gt; going off the end of the vector with an iterator,<p>The point of an iterator is to make it hard to do that. You can, but it is easy to not do that.<p>&gt; modifying the vector while iterating it<p>Annoying, but in practice I&#x27;ve not found it hard to avoid.<p>&gt; adding to the vector from two different threads or reading from one thread while another is modifying it<p>Rust doesn&#x27;t help here - they stop you from doing this, but if threads are your answer rust will just say no (or force you into unsafe).  Threads are hard, generally it is best to avoid this in the first place, but in the places where you need to modify data from threads Rust won&#x27;t help.</div><br/><div id="42239435" class="c"><input type="checkbox" id="c-42239435" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42238551">parent</a><span>|</span><a href="#42237293">next</a><span>|</span><label class="collapse" for="c-42239435">[-]</label><label class="expand" for="c-42239435">[1 more]</label></div><br/><div class="children"><div class="content">&gt; rust will just say no<p>This is just not accurate, you can use atomic data types, Mutex&lt;&gt; or RwLock&lt;&gt; to ensure thread-safe access. (Or write your own concurrent data structures, and mark them safe for access from a different thread.)  C++ has equivalent solutions but doesn&#x27;t check that you&#x27;re doing the right thing.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42237293" class="c"><input type="checkbox" id="c-42237293" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42236707">parent</a><span>|</span><a href="#42236735">prev</a><span>|</span><a href="#42234957">next</a><span>|</span><label class="collapse" for="c-42237293">[-]</label><label class="expand" for="c-42237293">[1 more]</label></div><br/><div class="children"><div class="content">Only if using a hardened runtime with bounds checking enabled, without any calls to c_str().</div><br/></div></div></div></div></div></div><div id="42234957" class="c"><input type="checkbox" id="c-42234957" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42231993">prev</a><span>|</span><a href="#42232232">next</a><span>|</span><label class="collapse" for="c-42234957">[-]</label><label class="expand" for="c-42234957">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And not just that they exist, but that they are specified per module<p>Nitpick: editions are specified per crate, not per module.<p>---<p>Also note that editions allow to make mostly syntactic changes (add&#x2F;remove syntax or change the meaning of existing ones), however it is greatly limited in what can be changed in the standard library because ultimately that is a crate dependency shared by all other crates.</div><br/></div></div><div id="42232232" class="c"><input type="checkbox" id="c-42232232" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42234957">prev</a><span>|</span><a href="#42235913">next</a><span>|</span><label class="collapse" for="c-42232232">[-]</label><label class="expand" for="c-42232232">[2 more]</label></div><br/><div class="children"><div class="content">There was a similar proposal for C++, using rustâs original names: epochs. It stalled out.</div><br/><div id="42234908" class="c"><input type="checkbox" id="c-42234908" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232232">parent</a><span>|</span><a href="#42235913">next</a><span>|</span><label class="collapse" for="c-42234908">[-]</label><label class="expand" for="c-42234908">[1 more]</label></div><br/><div class="children"><div class="content">They should call them &#x27;eras&#x27;.  Then they can explain that epochs did not lead to a new era in the language, but eras will mark the next epoch of C++.</div><br/></div></div></div></div><div id="42235913" class="c"><input type="checkbox" id="c-42235913" checked=""/><div class="controls bullet"><span class="by">wink</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42232232">prev</a><span>|</span><a href="#42236039">next</a><span>|</span><label class="collapse" for="c-42235913">[-]</label><label class="expand" for="c-42235913">[11 more]</label></div><br/><div class="children"><div class="content">My C++ knowledge is pretty weak in this regard but couldn&#x27;t you link different compilation units together just like you link shared libraries? I mean it sounds like a nightmare from a layout-my-code perspective, but dumb analogy: foo&#x2F;a&#x2F;* is compiled as C++11 code and foo&#x2F;b&#x2F; is compiled as C++20 code and foo&#x2F;bin&#x2F; uses both? (Not fun to use.. but possible?)<p>Is that an ABI thing? I thought all versions up to and including C++23 were ABI compatible.</div><br/><div id="42235974" class="c"><input type="checkbox" id="c-42235974" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42235913">parent</a><span>|</span><a href="#42236753">next</a><span>|</span><label class="collapse" for="c-42235974">[-]</label><label class="expand" for="c-42235974">[4 more]</label></div><br/><div class="children"><div class="content">How does foo&#x2F;bin use both when foo&#x2F;a&#x2F;* and foo&#x2F;b&#x2F; use ABI-incompatible versions of stdlib types, perhaps in their public interfaces?  This can easily lead to breakage in interop across foo&#x2F;a&#x2F;* and foo&#x2F;b&#x2F; .</div><br/><div id="42240397" class="c"><input type="checkbox" id="c-42240397" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42235974">parent</a><span>|</span><a href="#42236753">next</a><span>|</span><label class="collapse" for="c-42240397">[-]</label><label class="expand" for="c-42240397">[3 more]</label></div><br/><div class="children"><div class="content">How does Rust do it?</div><br/><div id="42241647" class="c"><input type="checkbox" id="c-42241647" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42240397">parent</a><span>|</span><a href="#42241614">next</a><span>|</span><label class="collapse" for="c-42241647">[-]</label><label class="expand" for="c-42241647">[1 more]</label></div><br/><div class="children"><div class="content">By linking both and not allowing mixing types, i.e. it considers types from a totally unrelated with types from b.<p>Also, Rust compiles the whole world at once, so any ABI breakage from mixing code from different compiler versions doesn&#x27;t happen. (Editions are different thing from compiler versions, a single version of the compiler supports multiple editions.)</div><br/></div></div></div></div></div></div><div id="42236753" class="c"><input type="checkbox" id="c-42236753" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42235913">parent</a><span>|</span><a href="#42235974">prev</a><span>|</span><a href="#42236039">next</a><span>|</span><label class="collapse" for="c-42236753">[-]</label><label class="expand" for="c-42236753">[6 more]</label></div><br/><div class="children"><div class="content">What is the point?  C++ is mostly ABI compatible (std::string broke between C++98 and C++11 in GNU - but we can ignore something from 13 years ago).  The is very little valid C++11 code that won&#x27;t build as C++23 without changes  (I can&#x27;t think of anything, but if something exists it is probably something really bad where in C++11 you shouldn&#x27;t have done that).<p>Now there is the possibility that someone could come up with a new breaking syntax and want a C++26 marker.  However nobody really wants that.  In part because C++98 code rebuilt as C++11 often saw a significant runtime improvement.  Even today C code built as C++23 probably runs faster than when compiled as C (the exceptions are rare - generally either the code doesn&#x27;t compile as C++, or it compiles but runs wrong)</div><br/><div id="42237475" class="c"><input type="checkbox" id="c-42237475" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42236753">parent</a><span>|</span><a href="#42236936">next</a><span>|</span><label class="collapse" for="c-42237475">[-]</label><label class="expand" for="c-42237475">[4 more]</label></div><br/><div class="children"><div class="content">There are plenty of things between C++11 and C++23 that have been removed and hence won&#x27;t compile:<p>Implicit capture of this in lambdas by copy.<p>std::iterator removed.<p>std::uncaught_exception() removed.<p>throw () exception specification removed.<p>std::strstream, std::istrstream, and std::ostrstream removed.<p>std::random_shuffle removed.<p>std::mem_fun and std::mem_fun_ref, std::bind1st and std::bind2nd removed.<p>There are numerous other things as well, but this is just off the top of my head.</div><br/><div id="42241571" class="c"><input type="checkbox" id="c-42241571" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42237475">parent</a><span>|</span><a href="#42238514">next</a><span>|</span><label class="collapse" for="c-42241571">[-]</label><label class="expand" for="c-42241571">[1 more]</label></div><br/><div class="children"><div class="content">cppreference say  strstream is removed in C++26, not C++23.<p>I knew they are bad, but I don&#x27;t think it should be removed.</div><br/></div></div><div id="42238514" class="c"><input type="checkbox" id="c-42238514" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42237475">parent</a><span>|</span><a href="#42241571">prev</a><span>|</span><a href="#42236936">next</a><span>|</span><label class="collapse" for="c-42238514">[-]</label><label class="expand" for="c-42238514">[2 more]</label></div><br/><div class="children"><div class="content">None of those things I&#x27;ve never used.  Many of those are in bad practice for C++11.</div><br/><div id="42242582" class="c"><input type="checkbox" id="c-42242582" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42238514">parent</a><span>|</span><a href="#42236936">next</a><span>|</span><label class="collapse" for="c-42242582">[-]</label><label class="expand" for="c-42242582">[1 more]</label></div><br/><div class="children"><div class="content">Sure. But per your own other posts in this thread, you&#x27;ve got &gt; 10 million lines of &quot;legacy C++&quot;. Probably those bad practices are present in that code and not automatically fixable. So switching to compiling everything with a C++23 compiler is every bit as much not an option for you as switching to Rust, no?</div><br/></div></div></div></div></div></div><div id="42236936" class="c"><input type="checkbox" id="c-42236936" checked=""/><div class="controls bullet"><span class="by">wink</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42236753">parent</a><span>|</span><a href="#42237475">prev</a><span>|</span><a href="#42236039">next</a><span>|</span><label class="collapse" for="c-42236936">[-]</label><label class="expand" for="c-42236936">[1 more]</label></div><br/><div class="children"><div class="content">There is no inherent point, I was just wondering, if it&#x27;s possible, why people don&#x27;t use such a homegrown module layout like Rust editions in C++.<p>I only ever worked in a couple of codebases where we had one standard for everything that was compiled and I suppose that&#x27;s what 90% of people do, or link static libs, or shared libs, so externalize at an earlier step.<p>So purely a thought experiment.</div><br/></div></div></div></div></div></div><div id="42236039" class="c"><input type="checkbox" id="c-42236039" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42235913">prev</a><span>|</span><a href="#42238077">next</a><span>|</span><label class="collapse" for="c-42236039">[-]</label><label class="expand" for="c-42236039">[1 more]</label></div><br/><div class="children"><div class="content">The C++ profiles proposal is something like an &quot;editions lite&quot;. It could evolve into more fully featured editions some day, though not without some significant tooling work to support prevention of severe memory and type safety issues across different projects linked into the same program.</div><br/></div></div><div id="42238077" class="c"><input type="checkbox" id="c-42238077" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42236039">prev</a><span>|</span><a href="#42236291">next</a><span>|</span><label class="collapse" for="c-42238077">[-]</label><label class="expand" for="c-42238077">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s irrelevant. Look, the C++ committee has decided yet again not to break ABI. That is to say, they have affirmed that they DO NOT want backwards incompatible changes. So suggesting a way to make backwards incompatible changes is of no interest to the C++ committee. They don&#x27;t want it and they have said so more than once.</div><br/></div></div></div></div><div id="42236291" class="c"><input type="checkbox" id="c-42236291" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#42231943">prev</a><span>|</span><a href="#42236036">next</a><span>|</span><label class="collapse" for="c-42236291">[-]</label><label class="expand" for="c-42236291">[9 more]</label></div><br/><div class="children"><div class="content">Oh no! Herb Sutter is leaving Microsoft?!<p>That does not bode well for Microsoft. At least from the outside perspective it looks like he was the adult in the room, the driving force behind standards adoption and even trying to steer C++-the-language towards a better vision of the future.<p>If he is gone, MSVC will again be the unloved bastard child it has long been before Herb&#x27;s efforts started to pay off. This is very disheartening news.<p>I&#x27;m happy he held out for this long even though he was being stonewalled every step of the way, like when Microsoft proposed std::span and it was adopted but minus the range checking (which was the whole point of std::span).<p>Now he has been pushing for a C++ preprocessor. Consider how desperate you have to be to even consider that as a potential solution for naysayers blocking your every move.</div><br/><div id="42236988" class="c"><input type="checkbox" id="c-42236988" checked=""/><div class="controls bullet"><span class="by">tux3</span><span>|</span><a href="#42236291">parent</a><span>|</span><a href="#42236521">next</a><span>|</span><label class="collapse" for="c-42236988">[-]</label><label class="expand" for="c-42236988">[6 more]</label></div><br/><div class="children"><div class="content">The rumor that has been widely circulating is that the MSVC backend is being reused as a code generator for the Rust compiler (because nobody really understands PDBs anymore, not even Microsoft, and especially LLVM doesn&#x27;t. So rustc could be a MSVC frontend instead to reuse all the existing arcane logic.)<p>MSVC will continue to be used for many years, and especially the backend might see renewed effort. But I don&#x27;t know about the C++ frontend specifically, I&#x27;ve seen complaints about more and more bugs on the cpp subreddit. It&#x27;s possible MS will be investing a little less in C++.</div><br/><div id="42237201" class="c"><input type="checkbox" id="c-42237201" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42236291">root</a><span>|</span><a href="#42236988">parent</a><span>|</span><a href="#42236521">next</a><span>|</span><label class="collapse" for="c-42237201">[-]</label><label class="expand" for="c-42237201">[5 more]</label></div><br/><div class="children"><div class="content">Disregarding the rumor,  it is quite public information that on Azure side, C and C++ are now only allowed for existing code bases, or scenarios where nothing else is available.<p>Meanwhile on Windows side, it was made officially at Ignite that a similar decision is now to be followed upon Windows as well.<p>Here the official stuff, so whatever happens to MSVC is secondary,<p><a href="https:&#x2F;&#x2F;azure.microsoft.com&#x2F;fr-fr&#x2F;blog&#x2F;microsoft-azure-security-evolution-embrace-secure-multitenancy-confidential-compute-and-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;azure.microsoft.com&#x2F;fr-fr&#x2F;blog&#x2F;microsoft-azure-secur...</a><p><a href="https:&#x2F;&#x2F;blogs.windows.com&#x2F;windowsexperience&#x2F;2024&#x2F;11&#x2F;19&#x2F;windows-security-and-resiliency-protecting-your-business&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blogs.windows.com&#x2F;windowsexperience&#x2F;2024&#x2F;11&#x2F;19&#x2F;windo...</a></div><br/><div id="42241661" class="c"><input type="checkbox" id="c-42241661" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#42236291">root</a><span>|</span><a href="#42237201">parent</a><span>|</span><a href="#42237770">next</a><span>|</span><label class="collapse" for="c-42241661">[-]</label><label class="expand" for="c-42241661">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;ve made statements like that for a long time now. But they&#x27;ve never escaped using C++ when performance matters. The game dev roles very clearly ask for C++, for example.<p>Rather, it seems that as computers have gotten faster, there&#x27;s been more places where safety is preferable to performance.</div><br/><div id="42243056" class="c"><input type="checkbox" id="c-42243056" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42236291">root</a><span>|</span><a href="#42241661">parent</a><span>|</span><a href="#42237770">next</a><span>|</span><label class="collapse" for="c-42243056">[-]</label><label class="expand" for="c-42243056">[1 more]</label></div><br/><div class="children"><div class="content">The proof is on the pudding, how performance critical do you consider Pluton firmware, network cards firmware supporting Azure workloads?<p>Two examples of stuff publicly rewritten into Rust.<p>Games are special that isn&#x27;t what Windows security cares about in first instance, when TinyGlade is the first ever commercial success using Rust.<p>Yet most games are done with Unreal and Unity, and yes there is lots of C++ there, but is mostly Blueprints, Verse, C# on top, that large majority of studios reach for.</div><br/></div></div></div></div><div id="42237770" class="c"><input type="checkbox" id="c-42237770" checked=""/><div class="controls bullet"><span class="by">_huayra_</span><span>|</span><a href="#42236291">root</a><span>|</span><a href="#42237201">parent</a><span>|</span><a href="#42241661">prev</a><span>|</span><a href="#42236521">next</a><span>|</span><label class="collapse" for="c-42237770">[-]</label><label class="expand" for="c-42237770">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  in alignment with the Secure Future Initiative, we are adopting safer programming languages, gradually moving functionality from C++ implementation to Rust.<p>This seems like one hell of an initiative for the Windows OS. That is millions of lines of C++ code, often with parts from waaay back. A friend who works on one of the OS teams told me that his team got a boomerang hire that worked on Windows back in the 90s and he was still finding parts of his code in there!<p>I hope this corporate interest bodes well for Rust though. It seems like for C++ it really caused a schism over the ABI break issue where Chandler et al were basically rebuffed finding some timeline to break it, and then Google dropped all their support on the committee in favor of Carbon, Rust, etc.</div><br/><div id="42238182" class="c"><input type="checkbox" id="c-42238182" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42236291">root</a><span>|</span><a href="#42237770">parent</a><span>|</span><a href="#42236521">next</a><span>|</span><label class="collapse" for="c-42238182">[-]</label><label class="expand" for="c-42238182">[1 more]</label></div><br/><div class="children"><div class="content">Apple and Google focusing on their own stuff, is one of the reasons why clang lost velocity in ISO C++ adoption, most of the C++ compiler vendors that fork clang don&#x27;t contribute frontend stuff only LLVM, and with them out, it took some time until new folks jumped in to replace their contributions.<p>Likewise you will noticed MSVC is no longer riding the wave in regards to C++23, after being the first to fully support C++20.<p>Then there are all those other compilers out there, lost somewhere between C++14 and C++17, and most likely never moving beyond that.</div><br/></div></div></div></div></div></div></div></div><div id="42236521" class="c"><input type="checkbox" id="c-42236521" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42236291">parent</a><span>|</span><a href="#42236988">prev</a><span>|</span><a href="#42236530">next</a><span>|</span><label class="collapse" for="c-42236521">[-]</label><label class="expand" for="c-42236521">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Now he has been pushing for a C++ preprocessor.<p>He has been showing it, but not pushing it.  the difference is subtle but important. He is showing a lot of &quot;what ifs&quot; trying them, and pushing the useful ones back into the language.  Reflection is on track for C++26 in large part because he inspired a lot of people with his metaclasses talk (a long time ago, but doing things right takes time)</div><br/></div></div><div id="42236530" class="c"><input type="checkbox" id="c-42236530" checked=""/><div class="controls bullet"><span class="by">chrsig</span><span>|</span><a href="#42236291">parent</a><span>|</span><a href="#42236521">prev</a><span>|</span><a href="#42236036">next</a><span>|</span><label class="collapse" for="c-42236530">[-]</label><label class="expand" for="c-42236530">[1 more]</label></div><br/><div class="children"><div class="content">It looks like he&#x27;s staying on the committee and what not, just changing his day job.  That&#x27;s actually one of the benefits of having a committee &amp; iso standardization process -- things aren&#x27;t so reliant on a single engineer staying employed at a single company.<p>I&#x27;m sure it&#x27;s never as clean a situation as anyone would like, but hey, world is a rough place sometimes.</div><br/></div></div></div></div><div id="42236036" class="c"><input type="checkbox" id="c-42236036" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#42236291">prev</a><span>|</span><a href="#42238684">next</a><span>|</span><label class="collapse" for="c-42236036">[-]</label><label class="expand" for="c-42236036">[14 more]</label></div><br/><div class="children"><div class="content">I have been saying this for a more than a decade, but the number one thing that killed C++ as an attractive modern language is (the lack of) modules - the ability to include C++ code  and libraries from others (perhaps with transitive dependencies), would allow an actual community of devs and companies spring up around the language.<p>Instead we have greybeards and lone warriors, and million-line legacy codebases, half of which have their own idea on what a string or a thread is.</div><br/><div id="42236195" class="c"><input type="checkbox" id="c-42236195" checked=""/><div class="controls bullet"><span class="by">fsloth</span><span>|</span><a href="#42236036">parent</a><span>|</span><a href="#42236210">next</a><span>|</span><label class="collapse" for="c-42236195">[-]</label><label class="expand" for="c-42236195">[3 more]</label></div><br/><div class="children"><div class="content">â killed C++ as an attractive modern languageâ<p>Iâm not sure were you got this perception that itâs dead.<p>C++ remains the only game in town in many domains.<p>That said, _unless you work in those domains_ there is no good reason to use C++ IMHO.<p>Apart from the legacy codebases, thereâs lots of C++ greenfield development.<p>â the ability to include C++ code and libraries from others â<p>Libraries in vcpkg - a large number - are compatible enough to be used in this sense. Itâs possible your specific domain is lacking contributions or youâve been looking from the wrong places?</div><br/><div id="42236441" class="c"><input type="checkbox" id="c-42236441" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236195">parent</a><span>|</span><a href="#42236210">next</a><span>|</span><label class="collapse" for="c-42236441">[-]</label><label class="expand" for="c-42236441">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, a âmoduleâ based system of various language is so much less efficient that it seems absurd to compare them for anything that actually requires that performance.</div><br/><div id="42236733" class="c"><input type="checkbox" id="c-42236733" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236441">parent</a><span>|</span><a href="#42236210">next</a><span>|</span><label class="collapse" for="c-42236733">[-]</label><label class="expand" for="c-42236733">[1 more]</label></div><br/><div class="children"><div class="content">Honestly not sure what you mean by that - in C#, for example it doesn&#x27;t matter to the compiler where the code comes from, it can be JITed&#x2F;inlined just the same even if its coming from a different dll.<p>I haven&#x27;t seen any perf impact of splitting stuff between files&#x2F;js modules in typescript either.<p>What I&#x27;m guessing is that you mean that static compilers, like that of C++, need to be able to &#x27;see&#x27; large amounts of code to make clever inlining optimizations.<p>Which shouldn&#x27;t be the case if the code is well designed, and&#x2F;or the compiler can prove invariants necessary for optimization without having to look at the body of the code.</div><br/></div></div></div></div></div></div><div id="42236210" class="c"><input type="checkbox" id="c-42236210" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42236036">parent</a><span>|</span><a href="#42236195">prev</a><span>|</span><a href="#42238684">next</a><span>|</span><label class="collapse" for="c-42236210">[-]</label><label class="expand" for="c-42236210">[10 more]</label></div><br/><div class="children"><div class="content">Modules could be better, the problem are some greybeards and lone warriors (thankfully not all), that insist using C++ as it was plain old C.<p>Basically, it is no different than renaming .js to .ts to take advantage of some stuff in Visual Studio Code, while keep writing plain old JavaScript.</div><br/><div id="42236278" class="c"><input type="checkbox" id="c-42236278" checked=""/><div class="controls bullet"><span class="by">eej71</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236210">parent</a><span>|</span><a href="#42236622">next</a><span>|</span><label class="collapse" for="c-42236278">[-]</label><label class="expand" for="c-42236278">[7 more]</label></div><br/><div class="children"><div class="content">I think the struggle with modules has much more to do with the complexity of the problem at hand. I think the solution looks very easy should one be willing to dispense with large parts of the ecosystem. But if your goal is to keep the ecosystem together and not break the world (ala python 2&#x2F;3 or perl5&#x2F;6) and solve the problem at hand (<i>waves vaguely at modules</i>) - then its a really hard problem.<p>I wish I could say modules don&#x27;t work, but I have yet to understand them. Which is probably a big part of its problem.</div><br/><div id="42236551" class="c"><input type="checkbox" id="c-42236551" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236278">parent</a><span>|</span><a href="#42236511">next</a><span>|</span><label class="collapse" for="c-42236551">[-]</label><label class="expand" for="c-42236551">[3 more]</label></div><br/><div class="children"><div class="content">All my hobby coding in C++ makes use of modules.<p>Visual C++ and clang, alongside MSBuild and CMake&#x2F;ninja.<p>As for ecosystem fragmentation, it has been the same old story since WG14 and WG21 exist, each compiler and platform is their own snowflake of what they actually support.</div><br/><div id="42237823" class="c"><input type="checkbox" id="c-42237823" checked=""/><div class="controls bullet"><span class="by">_huayra_</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236551">parent</a><span>|</span><a href="#42236511">next</a><span>|</span><label class="collapse" for="c-42237823">[-]</label><label class="expand" for="c-42237823">[2 more]</label></div><br/><div class="children"><div class="content">&gt; All my hobby coding in C++ makes use of modules.<p>Do you have an example (of yours or others) that you could link?<p>I&#x27;ve been trying to get this up and running myself, but can&#x27;t seem to whisper the right CMake prayers.</div><br/><div id="42238192" class="c"><input type="checkbox" id="c-42238192" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42237823">parent</a><span>|</span><a href="#42236511">next</a><span>|</span><label class="collapse" for="c-42238192">[-]</label><label class="expand" for="c-42238192">[1 more]</label></div><br/><div class="children"><div class="content">Sure, <a href="https:&#x2F;&#x2F;github.com&#x2F;pjmlp&#x2F;RaytracingWeekend-CPP">https:&#x2F;&#x2F;github.com&#x2F;pjmlp&#x2F;RaytracingWeekend-CPP</a></div><br/></div></div></div></div></div></div><div id="42236511" class="c"><input type="checkbox" id="c-42236511" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236278">parent</a><span>|</span><a href="#42236551">prev</a><span>|</span><a href="#42236622">next</a><span>|</span><label class="collapse" for="c-42236511">[-]</label><label class="expand" for="c-42236511">[3 more]</label></div><br/><div class="children"><div class="content">Stop using python 3 as an example. It is really tiring to hear about an extreme case of gross incompetence over and over again, while over in say the Grails&#x2F;Spring ecosystem I don&#x27;t even bother upgrading Grails 3 or 4 Plugins to Grails 6, because they still work as intended. When you upgrade a plugin from one version to the next, you&#x27;re just swapping out build.gradle, gradle wrapper and a bunch of ancillary properties files. The build system changes, but everything else stays the same with only a tiny tiny minority of plugins being affected and even then the things that broke are absolute nonissues that can be fixed relatively quickly.<p>It is kind of interesting how the python community hasn&#x27;t learned a thing from python 2&#x2F;3. The problem isn&#x27;t breaking backwards compatiblity. Probably the biggest mistake you can do is act like breaking backwards compatiblity is a big deal, therefore you should pile up as many breaking changes as possible and release them all at once so as to maximize pushback and upgrade friction.<p>It is in fact the exact opposite. If you break 10 libraries out of a million, you as the language developer can step in and upgrade them on behalf of the original maintainer. The users increment a library version when they increment the language version and done.</div><br/><div id="42237270" class="c"><input type="checkbox" id="c-42237270" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236511">parent</a><span>|</span><a href="#42236622">next</a><span>|</span><label class="collapse" for="c-42237270">[-]</label><label class="expand" for="c-42237270">[2 more]</label></div><br/><div class="children"><div class="content">Python3 is a great example. They looked at what others had done. They carefully thought about the problem. They build tools to migrate. They announced plans.  They really thought they had found a better answer that would work out because they had planned for everything.<p>Of course we are now looking at things in hindsight and see what didn&#x27;t work.</div><br/><div id="42237792" class="c"><input type="checkbox" id="c-42237792" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42237270">parent</a><span>|</span><a href="#42236622">next</a><span>|</span><label class="collapse" for="c-42237792">[-]</label><label class="expand" for="c-42237792">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really important to be clear about the lessons to be learned from Python 3.<p>1. Forward compatibility is more important than backward compatibility.
2. Automated refactoring tools don&#x27;t help with 1.<p>The problem wasn&#x27;t that they broke a lot in Python 3. It was that you couldn&#x27;t write your Python 2 in such a way as to be compatible with it until well into the transition process as the six package got popular and the devs fixed needlessly broken things in Python 2.</div><br/></div></div></div></div></div></div></div></div><div id="42236622" class="c"><input type="checkbox" id="c-42236622" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236210">parent</a><span>|</span><a href="#42236278">prev</a><span>|</span><a href="#42238684">next</a><span>|</span><label class="collapse" for="c-42236622">[-]</label><label class="expand" for="c-42236622">[2 more]</label></div><br/><div class="children"><div class="content">I have seen a <i>lot</i> of C++ code that has a lot of &quot;this is clearly just C&quot; in it. None of it is because of &quot;greybeards and lone warriors&quot;. All of it was because it started as a C codebase, and sometime in the mid to late 90s when object-oriented fever swept the world they started just adding C++ on top of the existing C codebase.<p>Given that the general industry approach to technical debt is &quot;yes, more please&quot;, it is unsurprising to me that any sufficiently old C++ project still has lots and lots of plain C inside it.</div><br/><div id="42236837" class="c"><input type="checkbox" id="c-42236837" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42236036">root</a><span>|</span><a href="#42236622">parent</a><span>|</span><a href="#42238684">next</a><span>|</span><label class="collapse" for="c-42236837">[-]</label><label class="expand" for="c-42236837">[1 more]</label></div><br/><div class="children"><div class="content">Except the complaint equally applies to green field projects.</div><br/></div></div></div></div></div></div></div></div><div id="42238684" class="c"><input type="checkbox" id="c-42238684" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#42236036">prev</a><span>|</span><a href="#42234676">next</a><span>|</span><label class="collapse" for="c-42238684">[-]</label><label class="expand" for="c-42238684">[3 more]</label></div><br/><div class="children"><div class="content">I really really like this article. I think the two camps the author describes very much reflect my experience over the past couple of decades at a dotcom startup, then a game developer, and now at Google<p>However, I think the author is a little off on the root cause. They emphasize tooling: the ability to build reliably and cleanly from source. That&#x27;s a piece of it, but a relatively small piece.<p>I think the real distinguishing factor between the two camps is <i>automated testing</i>. The author mentions testing a couple of times, but I want to emphasize how critical that is.<p>If you don&#x27;t have a comprehensive set of test suites that you are willing to rely on when making code changes, then your source code is a black box. It doesn&#x27;t matter if you have the world&#x27;s greatest automated refactoring tools that output the most beautiful looking code changes. If you don&#x27;t have automated tests to validate that the change doesn&#x27;t break an app and cost the company money, you won&#x27;t be able to land it.<p>Working on a &quot;legacy C++ app&quot; (like, for example, Madden NFL back when I was at EA) was like working on a giant black box. You could fairly confidently add new features and new code onto the side. But if you wanted to touch existing code, you needed a very compelling reason to do so in order to outweigh the risk of breaking something unexpectedly. Without automated tests, there was simply no reliable way to determine if a change caused a regression.<p>And, because C++ is C++, even entirely harmless seeming code changes can cause regressions. Once you&#x27;ve got things like reinterpret_cast&lt;&gt;, damn near any change can break damn near anything else.<p>So people working in these codebases behave sort of like surgeons with a &quot;do no harm&quot; philosophy. They touch as little as possible, as non-invasively as possible. Otherwise, the risk of harming the patient is too high.<p>It&#x27;s a miserable way to program long-term. But it&#x27;s <i>really</i> hard to get out of that mess once you&#x27;re in it. It takes a monumental amount of political capital from engineering leadership to build a strong testing culture, re-architect a codebase to be testable, and write all the tests.<p>A lot of C++ committee changes aimed at legacy C++ developers are about &quot;how can we help these people that are already in a mess survive?&quot; That&#x27;s a <i>very</i> different problem than asking, &quot;Given a healthy, tested codebase, how can we make developers working in it go faster?&quot;</div><br/><div id="42240072" class="c"><input type="checkbox" id="c-42240072" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42238684">parent</a><span>|</span><a href="#42234676">next</a><span>|</span><label class="collapse" for="c-42240072">[-]</label><label class="expand" for="c-42240072">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of C++ committee changes aimed at legacy C++ developers are about &quot;how can we help these people that are already in a mess survive?&quot; That&#x27;s a very different problem than asking, &quot;Given a healthy, tested codebase, how can we make developers working in it go faster?&quot;<p>Having also worked at a few gamedev studios, IME there isn&#x27;t a real distinction between the two since it is <i>always</i> a matter of time for the former to become the latter.<p>Sometimes it doesn&#x27;t even take that long, all it takes is a single innocuous vertical slice with a pointlessly immovable deadline to inject enough harm in a codebase so you spend the next year fighting bugs that shouldn&#x27;t have existed in the first place while also having to do everything else at the same time (and all planned timeframes made with only the &quot;everything else&quot; in mind, of course).<p>IMO even if it doesn&#x27;t sound good, it is much more practical to learn how to deal with the mud than assume pigs do not exist :-P</div><br/><div id="42240348" class="c"><input type="checkbox" id="c-42240348" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#42238684">root</a><span>|</span><a href="#42240072">parent</a><span>|</span><a href="#42234676">next</a><span>|</span><label class="collapse" for="c-42240348">[-]</label><label class="expand" for="c-42240348">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Having also worked at a few gamedev studios, IME there isn&#x27;t a real distinction between the two since it is always a matter of time for the former to become the latter.</i><p>That was very much my experience at EA, but has definitely not been my experience at Google. While everyone struggles with tech debt, at Google I&#x27;ve worked in many codebases that have been continuously well-maintained with good test coverage for over a decade.<p>Really, once you build a culture that says, &quot;People not on your team may edit your code without asking and will rely on your tests to make sure they don&#x27;t break things,&quot;, teams get <i>highly</i> incentivized to write tests.</div><br/></div></div></div></div></div></div><div id="42234676" class="c"><input type="checkbox" id="c-42234676" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42238684">prev</a><span>|</span><a href="#42231986">next</a><span>|</span><label class="collapse" for="c-42234676">[-]</label><label class="expand" for="c-42234676">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re comparing Herb Sutter and the Google people at the standard committee, there is one thing that was clear: Herb was good at getting people to agree on compromises that served everybody, while Google was mostly claiming they knew better than everybody else and pushing their own agenda.</div><br/></div></div><div id="42231986" class="c"><input type="checkbox" id="c-42231986" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42234676">prev</a><span>|</span><a href="#42234629">next</a><span>|</span><label class="collapse" for="c-42231986">[-]</label><label class="expand" for="c-42231986">[4 more]</label></div><br/><div class="children"><div class="content">Python similarly has 2-3 factions in my experience: teams doing engineering in Python and using all the modern tooling, linting, packaging, types, testing, etc; teams doing data science and using modern but different tooling (i.e. Anaconda); and teams that don&#x27;t get onboard in any of the language health initiatives and are on unsupported language versions with no packaging, tooling, linting, etc.<p>Javascript&#x2F;Node&#x2F;Typescript has even more identifiable factions.<p>I think developing factions around these things is unfortunately normal as languages grow up and get used in different ways. Rust has arguably tried to stay away from this, but the flip side is a higher learning curve because it just doesn&#x27;t let certain factions exist. Go is probably the best attempt to prevent factions and gain wide adoption, but even then the generics crowd forced the language to adopt them.</div><br/><div id="42232787" class="c"><input type="checkbox" id="c-42232787" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#42231986">parent</a><span>|</span><a href="#42239101">next</a><span>|</span><label class="collapse" for="c-42232787">[-]</label><label class="expand" for="c-42232787">[2 more]</label></div><br/><div class="children"><div class="content">When you put it this way, personas might be a better term than factions.</div><br/><div id="42233009" class="c"><input type="checkbox" id="c-42233009" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42231986">root</a><span>|</span><a href="#42232787">parent</a><span>|</span><a href="#42239101">next</a><span>|</span><label class="collapse" for="c-42233009">[-]</label><label class="expand" for="c-42233009">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think that&#x27;s a much friendlier term. I do think language ecosystems have a hard time, because on the one hand they should be aiming to be as useful as possible, which means doing <i>more</i>, on the other hand they have to acknowledge that any given user will likely not use all the language and that the rest of it may hinder them, which means doing <i>less</i>.<p>C++ does a lot, but has a big disengaged crowd, for many reasons, and that crowd will suffer from the push forward. Python and Node are similar.</div><br/></div></div></div></div><div id="42239101" class="c"><input type="checkbox" id="c-42239101" checked=""/><div class="controls bullet"><span class="by">bogeholm</span><span>|</span><a href="#42231986">parent</a><span>|</span><a href="#42232787">prev</a><span>|</span><a href="#42234629">next</a><span>|</span><label class="collapse" for="c-42239101">[-]</label><label class="expand" for="c-42239101">[1 more]</label></div><br/><div class="children"><div class="content">The first two factions you describe in Python (types, testing etc. vs. data science and Anaconda) can work together just fine.<p>Source: I am in both factions, as are my colleagues :)</div><br/></div></div></div></div><div id="42234629" class="c"><input type="checkbox" id="c-42234629" checked=""/><div class="controls bullet"><span class="by">shultays</span><span>|</span><a href="#42231986">prev</a><span>|</span><a href="#42232125">next</a><span>|</span><label class="collapse" for="c-42234629">[-]</label><label class="expand" for="c-42234629">[17 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  âWe must minimize the need to change existing code. For adoption in existing code, decades of experience has consistently shown that most customers with large code bases cannot and will not change even 1% of their lines of code in order to satisfy strictness rules, not even for safety reasons unless regulatory requirements compel them to do so.â â Herb Sutter

  with large code bases cannot and will not change even 1% of their lines of code in order to satisfy strictness rules
</code></pre>
Do people really say this? Voice this in committee?  I have been in a few companies, and one fairly large one, and all are happy to and looking forward to upgrade newer standards and already spend a lot of time updating their build systems. Changing 1% of code on top of that is probably not really that much compared</div><br/><div id="42235216" class="c"><input type="checkbox" id="c-42235216" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#42234629">parent</a><span>|</span><a href="#42235416">next</a><span>|</span><label class="collapse" for="c-42235216">[-]</label><label class="expand" for="c-42235216">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Changing 1% of code on top of that is probably not really that much compared</i><p>Quite a few companies have millions and millions of lines of code. Changing 1% of it would mean changing more than 10K lines of code, perhaps even more than 100K. In much bigger code bases, where changing anything has a risk of breaking something â not just because you might make a mistake, but because your program is full of Undefined Behaviour, and changing anything might manifest latent bugs.<p>Given that, I&#x27;m not surprised people say that Sutter quote with a straight face.</div><br/></div></div><div id="42235416" class="c"><input type="checkbox" id="c-42235416" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#42234629">parent</a><span>|</span><a href="#42235216">prev</a><span>|</span><a href="#42235380">next</a><span>|</span><label class="collapse" for="c-42235416">[-]</label><label class="expand" for="c-42235416">[8 more]</label></div><br/><div class="children"><div class="content">Many of my customers are in an industry with a huge C++ code base and it&#x27;s all under active development. Safety certification requirements are onerous and lead-times for development are long: many are now experimenting with C++17 and C++20 is on the long-term horizon but not yet a requirement. Because of the safety certification requirements and the fact that the expected lifecycle of the software is the order of decades after their products have been released, changing any lines of their code for any reason is always risky. Lives can be at stake.<p>But this is a multi-billion-dollar industry. If you&#x27;re working on scripting a little browser &quot;app&quot; for a phone things may be different.</div><br/><div id="42237802" class="c"><input type="checkbox" id="c-42237802" checked=""/><div class="controls bullet"><span class="by">titanomachy</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42235416">parent</a><span>|</span><a href="#42236614">next</a><span>|</span><label class="collapse" for="c-42237802">[-]</label><label class="expand" for="c-42237802">[1 more]</label></div><br/><div class="children"><div class="content">âLittle browser apps for phonesâ are a trillion-dollar industry</div><br/></div></div><div id="42236614" class="c"><input type="checkbox" id="c-42236614" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42235416">parent</a><span>|</span><a href="#42237802">prev</a><span>|</span><a href="#42235380">next</a><span>|</span><label class="collapse" for="c-42236614">[-]</label><label class="expand" for="c-42236614">[6 more]</label></div><br/><div class="children"><div class="content">Is there a lot of manual work for getting the new certificate? E.g. is human rewiewing the code? If not, someone should build CI pipeline for the certification process.</div><br/><div id="42236879" class="c"><input type="checkbox" id="c-42236879" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42236614">parent</a><span>|</span><a href="#42235380">next</a><span>|</span><label class="collapse" for="c-42236879">[-]</label><label class="expand" for="c-42236879">[5 more]</label></div><br/><div class="children"><div class="content">Hundreds of hours of manual testing. I don&#x27;t have to do safety certificates, but my code gets 500 hours of manual testing (I&#x27;m not allowed to give real numbers, these numbers are close enough) - they find enough critical can&#x27;t ship issues where the fix is risky enough to start all over that we typically are doing 2500 hours of manual testing. on every release.<p>We have a large automated test suite that runs on every build and takes hours.  The problem with automated tests is they only verify situations you thought of work the way you think they should, while human testers find slight variations of setup that you wouldn&#x27;t think matter until they do. Human tests also find cases where the way you expect things to work don&#x27;t make sense in the real world.</div><br/><div id="42240220" class="c"><input type="checkbox" id="c-42240220" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42236879">parent</a><span>|</span><a href="#42235380">next</a><span>|</span><label class="collapse" for="c-42240220">[-]</label><label class="expand" for="c-42240220">[4 more]</label></div><br/><div class="children"><div class="content">Wait until you find out about the cat test. It found a failure mode no human had thought of. No amount of the developer claiming a test like that was not fair was enough to invalidate the results. No actual cats were harmed but treats may have been given.</div><br/><div id="42241126" class="c"><input type="checkbox" id="c-42241126" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42240220">parent</a><span>|</span><a href="#42235380">next</a><span>|</span><label class="collapse" for="c-42241126">[-]</label><label class="expand" for="c-42241126">[3 more]</label></div><br/><div class="children"><div class="content">Do you have more context? I&#x27;m having trouble googling what you&#x27;re referencing.</div><br/><div id="42242552" class="c"><input type="checkbox" id="c-42242552" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42241126">parent</a><span>|</span><a href="#42235380">next</a><span>|</span><label class="collapse" for="c-42242552">[-]</label><label class="expand" for="c-42242552">[2 more]</label></div><br/><div class="children"><div class="content">Simulate a cat walking on the keyboard to handle weird inputs?</div><br/><div id="42242637" class="c"><input type="checkbox" id="c-42242637" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42242552">parent</a><span>|</span><a href="#42235380">next</a><span>|</span><label class="collapse" for="c-42242637">[-]</label><label class="expand" for="c-42242637">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that just fuzzing? I thought maybe there was a specific thing called the cat test.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42235380" class="c"><input type="checkbox" id="c-42235380" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#42234629">parent</a><span>|</span><a href="#42235416">prev</a><span>|</span><a href="#42234729">next</a><span>|</span><label class="collapse" for="c-42235380">[-]</label><label class="expand" for="c-42235380">[2 more]</label></div><br/><div class="children"><div class="content">People just don&#x27;t make mass changes to existing working code.  Mostly they cannot.  Even if the tooling was available, which it&#x27;s not, it&#x27;s also about reeducating their developers, who don&#x27;t want to or can&#x27;t change. Plus it&#x27;d have to be recertified. It&#x27;s all cost with no benefit.<p>Except, allegedly, at Google.  But is there any evidence they actually do this, eg. in public code bases?  Or is it just hype?</div><br/><div id="42241610" class="c"><input type="checkbox" id="c-42241610" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42235380">parent</a><span>|</span><a href="#42234729">next</a><span>|</span><label class="collapse" for="c-42241610">[-]</label><label class="expand" for="c-42241610">[1 more]</label></div><br/><div class="children"><div class="content">Google do this to their internal monorepo.<p>This is one of the reason why they are bad at open sourcing - their internal code almost never match what is released</div><br/></div></div></div></div><div id="42234729" class="c"><input type="checkbox" id="c-42234729" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#42234629">parent</a><span>|</span><a href="#42235380">prev</a><span>|</span><a href="#42236320">next</a><span>|</span><label class="collapse" for="c-42234729">[-]</label><label class="expand" for="c-42234729">[1 more]</label></div><br/><div class="children"><div class="content">Could be selection bias. Companies (or departments within companies) who are still actively developing their C++ code probably tend to hire more developers and consultants than companies who are doing minimal maintenance on their code base, and that might correlate well with the âtwo factions of C++â discussed here.<p>âOur code is an assetâ â code kept up-to-date<p>âOur code is a burden, but we need itâ â change averse</div><br/></div></div><div id="42236320" class="c"><input type="checkbox" id="c-42236320" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42234629">parent</a><span>|</span><a href="#42234729">prev</a><span>|</span><a href="#42241942">next</a><span>|</span><label class="collapse" for="c-42236320">[-]</label><label class="expand" for="c-42236320">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Changing 1% of code on top of that is probably not really that much compared<p>Changing 1% across all modules is a nightmare. Changing one module which is 1% of the code is nothing.</div><br/></div></div><div id="42241942" class="c"><input type="checkbox" id="c-42241942" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42234629">parent</a><span>|</span><a href="#42236320">prev</a><span>|</span><a href="#42234689">next</a><span>|</span><label class="collapse" for="c-42241942">[-]</label><label class="expand" for="c-42241942">[2 more]</label></div><br/><div class="children"><div class="content">A company that I worked at had a few very large C++ related migrations, and they were all very very expensive.<p>The first was removing `long` from the code, since a lot of code assumed its size (is it like `int` or like `long long int`?) and as machines were upgraded it caused problems.<p>The second was moving to C++11&#x2F;14&#x2F;17. Most of the difficulty was toolchains on unixen that did not support the new versions of the language, or for which support was incomplete, or for which upgrading to a version with support broke existing builds.<p>The third was moving to Linux from big iron unixen. As far as I understand, this initiative is still underway. It was already underway in 2011 when I joined the company.<p>This is a rich company with a large, healthy engineering department. I imagine that most other companies would not or could not bother.</div><br/><div id="42242646" class="c"><input type="checkbox" id="c-42242646" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42234629">root</a><span>|</span><a href="#42241942">parent</a><span>|</span><a href="#42234689">next</a><span>|</span><label class="collapse" for="c-42242646">[-]</label><label class="expand" for="c-42242646">[1 more]</label></div><br/><div class="children"><div class="content">That old joke about Stroustrup inventing C++ to keep developers perpetually employed keeps ringing true.</div><br/></div></div></div></div><div id="42234689" class="c"><input type="checkbox" id="c-42234689" checked=""/><div class="controls bullet"><span class="by">Hilift</span><span>|</span><a href="#42234629">parent</a><span>|</span><a href="#42241942">prev</a><span>|</span><a href="#42232125">next</a><span>|</span><label class="collapse" for="c-42234689">[-]</label><label class="expand" for="c-42234689">[1 more]</label></div><br/><div class="children"><div class="content">Are you referring to his book written 20 years ago or 25 years ago? &quot;customers with large [C++] code bases&quot; there aren&#x27;t that many of these. Vendors, government. With code bases that have stewards, not programmers.</div><br/></div></div></div></div><div id="42232125" class="c"><input type="checkbox" id="c-42232125" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#42234629">prev</a><span>|</span><a href="#42231991">next</a><span>|</span><label class="collapse" for="c-42232125">[-]</label><label class="expand" for="c-42232125">[20 more]</label></div><br/><div class="children"><div class="content">One thing I cannot stand about C++ is the fractured nature of <i>everything</i>. Compilers, build tools, package management, etc... It feels like you need to be a wizard just to get a project compiling and start writing some code.</div><br/><div id="42232234" class="c"><input type="checkbox" id="c-42232234" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232125">parent</a><span>|</span><a href="#42232193">next</a><span>|</span><label class="collapse" for="c-42232234">[-]</label><label class="expand" for="c-42232234">[10 more]</label></div><br/><div class="children"><div class="content">The worst part is when you want to bring along people that are not as much of a wizard as you are. I&#x27;ve been prototyping some multiplayer, online video game with MMO-like sharding for a while now, mostly the backend and core stuff for the project and wanted to get two of my friends on the project to develop the gameplay logic which is largely done through a dynamic scripting language, but some features (that, say, I did not foresee needed yet), require source changes to expose the APIs to the scripting language, now, these guys are capable of doing these changes but the onboarding process for a single potential co-developer is such a pain, I basically have to explain to them how to download a compiler, a package manager like vcpkg (which wasn&#x27;t even that much usable for these types of things pre-versioning, and is still not working properly - i.e. trying to pin LuaJIT version to 2.0.5 for VM bytecode compatibility will attempt to build LuaJIT with cl.exe on Linux), a build system like CMake, and so on, then guide them through all the steps to get the compiler, the build system, and the libraries working, and then hope that in the end they will actually work and not force you to spend an entire day over a remote desktop software trying to get them to become productive.</div><br/><div id="42232404" class="c"><input type="checkbox" id="c-42232404" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232234">parent</a><span>|</span><a href="#42232305">next</a><span>|</span><label class="collapse" for="c-42232404">[-]</label><label class="expand" for="c-42232404">[7 more]</label></div><br/><div class="children"><div class="content">Include more of your dependencies in the repo and build them aa part of the ordinary build process. Now a package manager does not need to get involved.</div><br/><div id="42232551" class="c"><input type="checkbox" id="c-42232551" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232404">parent</a><span>|</span><a href="#42238399">next</a><span>|</span><label class="collapse" for="c-42232551">[-]</label><label class="expand" for="c-42232551">[5 more]</label></div><br/><div class="children"><div class="content">Manually copy-pasting source trees around sounds like such an outdated idea from decades ago on how to approach dependency management in a modern programming language. Not to mention that you then have to hook them up to the build system that you are using and not all of them will work out of the box with the one you are using for your project, sure, if you are using CMake and your dependency uses CMake, you can add a subproject, how do you deal with it when they&#x27;re mixed-and-matched aside from rewriting the builds for every dependency you&#x27;re pulling in; or without manually writing glue shell scripts to build them independently and put them into a directory? How do you then ensure the said shell script works across different platforms? There are way too many issues with that approach that are solved in other languages through a standardized project management tool.</div><br/><div id="42233757" class="c"><input type="checkbox" id="c-42233757" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232551">parent</a><span>|</span><a href="#42234413">next</a><span>|</span><label class="collapse" for="c-42233757">[-]</label><label class="expand" for="c-42233757">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to actually copypaste. You can use CMake and FetchContent&#x2F;CPM. You can specify custom build commands or inline declare a project for anything small that you pull in that doesn&#x27;t use CMake (you can call add_library with a glob on the folder FetchContent pulled in, for example - I&#x27;ve done so here <a href="https:&#x2F;&#x2F;github.com&#x2F;basis-robotics&#x2F;basis&#x2F;blob&#x2F;main&#x2F;cpp&#x2F;CMakeLists.txt#L75">https:&#x2F;&#x2F;github.com&#x2F;basis-robotics&#x2F;basis&#x2F;blob&#x2F;main&#x2F;cpp&#x2F;CMakeL...</a> for a header only lib). For large external dependencies that are either very slow to compile or for some reason aren&#x27;t CMake, reach for the system package manager or similar. If you want to be really cross platform and are supporting Qt&#x2F;wxwidgets&#x2F;etc, vcpkg+CMake+clang is solid combo, if a bit slow and a bit disk space heavy with the build cache.</div><br/></div></div><div id="42234413" class="c"><input type="checkbox" id="c-42234413" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232551">parent</a><span>|</span><a href="#42233757">prev</a><span>|</span><a href="#42234660">next</a><span>|</span><label class="collapse" for="c-42234413">[-]</label><label class="expand" for="c-42234413">[1 more]</label></div><br/><div class="children"><div class="content">Have you taken a look at CPM ? <a href="https:&#x2F;&#x2F;github.com&#x2F;cpm-cmake&#x2F;CPM.cmake">https:&#x2F;&#x2F;github.com&#x2F;cpm-cmake&#x2F;CPM.cmake</a> . It makes CMake project management easy - no need for separate package manager tool.</div><br/></div></div><div id="42234660" class="c"><input type="checkbox" id="c-42234660" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232551">parent</a><span>|</span><a href="#42234413">prev</a><span>|</span><a href="#42237893">next</a><span>|</span><label class="collapse" for="c-42234660">[-]</label><label class="expand" for="c-42234660">[1 more]</label></div><br/><div class="children"><div class="content">And yet that&#x27;s the right approach. It&#x27;s not really copying but rather onboarding.<p>You don&#x27;t want to depend on a third-party hosting the code, so you need to copy it, and pin it to a specific version. You might also need to patch it since you&#x27;ll be using it and most likely will run into problems with it.<p>Using third-party code means taking ownership of all the problems one might encounter when trying to use it in your project, so you might as well just adapt it for it to work with your tools and processes.<p>If you use a modular system this is essentially just maintaining a fork.</div><br/></div></div><div id="42237893" class="c"><input type="checkbox" id="c-42237893" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232551">parent</a><span>|</span><a href="#42234660">prev</a><span>|</span><a href="#42238399">next</a><span>|</span><label class="collapse" for="c-42237893">[-]</label><label class="expand" for="c-42237893">[1 more]</label></div><br/><div class="children"><div class="content">People vendor dependencies in Go too!</div><br/></div></div></div></div><div id="42238399" class="c"><input type="checkbox" id="c-42238399" checked=""/><div class="controls bullet"><span class="by">cshokie</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232404">parent</a><span>|</span><a href="#42232551">prev</a><span>|</span><a href="#42232305">next</a><span>|</span><label class="collapse" for="c-42238399">[-]</label><label class="expand" for="c-42238399">[1 more]</label></div><br/><div class="children"><div class="content">Thatâs similar to what vcpkg does under the covers. It clones the repo containing the dependencyâs source code and then compiles it using the same compiler as the rest of your project. This avoids static libraries and ABI considerations while also avoiding having to copy&#x2F;paste their entire source tree into your own.</div><br/></div></div></div></div><div id="42232305" class="c"><input type="checkbox" id="c-42232305" checked=""/><div class="controls bullet"><span class="by">cyclopeanutopia</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232234">parent</a><span>|</span><a href="#42232404">prev</a><span>|</span><a href="#42232193">next</a><span>|</span><label class="collapse" for="c-42232305">[-]</label><label class="expand" for="c-42232305">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you just put that into a docker container?</div><br/><div id="42232554" class="c"><input type="checkbox" id="c-42232554" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232305">parent</a><span>|</span><a href="#42232193">next</a><span>|</span><label class="collapse" for="c-42232554">[-]</label><label class="expand" for="c-42232554">[1 more]</label></div><br/><div class="children"><div class="content">This is more of a workaround than a solution; see my other comment in this thread.</div><br/></div></div></div></div></div></div><div id="42232193" class="c"><input type="checkbox" id="c-42232193" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42232125">parent</a><span>|</span><a href="#42232234">prev</a><span>|</span><a href="#42231991">next</a><span>|</span><label class="collapse" for="c-42232193">[-]</label><label class="expand" for="c-42232193">[9 more]</label></div><br/><div class="children"><div class="content">you DO need to be a wizard to launch a large C++ project.<p>Yes, languages that are beginner friendly are ... friendlier. Yes, languages that stick to one or a small number of programming paradigms are friendlier. But if you want the &quot;flexible efficiency and raw power of C&quot; and &quot;something higher level than C&quot;, C++ is your baby.<p>Maybe it would be better if we all used Java, Rust, and Go, but C++ sings its siren von Neumann song to the wizards, and there will always be wizard musicologists who steer their projects toward those rocks and, when they have just enough wax in their ears, they sail right past the rocks and come out the other side of the straits leading the rest of the fleet.<p>You can choose to follow them or not, for there&#x27;s no shame in coming in 4th.</div><br/><div id="42234435" class="c"><input type="checkbox" id="c-42234435" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232193">parent</a><span>|</span><a href="#42235413">next</a><span>|</span><label class="collapse" for="c-42234435">[-]</label><label class="expand" for="c-42234435">[3 more]</label></div><br/><div class="children"><div class="content">Even the wizards are moving to Rust&#x2F;Zig since C++ stdlib performance is becoming terrible thanks to the ABI-frozen till heat-death of the universe decision. Even wizards don&#x27;t want to build a stdlib of their own from scratch.<p>Feel the committee was smoking weed that day in la-la land. You can ignore all the safety stuff from Sean Baxter, but saying no to performance on the altar of permanent, un-specified ABI backward compatibility - when such was never mentioned as a design goal of C++ -  means its &quot;Goodbye C++&quot; for a long, long list of orgs and &quot;wizards&quot;. The ABI was NEVER specified formally by the C++ standard - so why bother sacrificing the world for its immortal existence ?<p>C++ is NO longer the choice of language for greenfield native projects and the committee takes the full blame.</div><br/><div id="42234525" class="c"><input type="checkbox" id="c-42234525" checked=""/><div class="controls bullet"><span class="by">asyx</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42234435">parent</a><span>|</span><a href="#42239761">next</a><span>|</span><label class="collapse" for="c-42234525">[-]</label><label class="expand" for="c-42234525">[1 more]</label></div><br/><div class="children"><div class="content">Really looking forward to zig 1.0. I feel like C++ has become a language where professionals are fine with the historical grime but for hobbyist and people that need C++ occasionally there is just no motivation in the community to make this language more ergonomic.</div><br/></div></div><div id="42239761" class="c"><input type="checkbox" id="c-42239761" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42234435">parent</a><span>|</span><a href="#42234525">prev</a><span>|</span><a href="#42235413">next</a><span>|</span><label class="collapse" for="c-42239761">[-]</label><label class="expand" for="c-42239761">[1 more]</label></div><br/><div class="children"><div class="content">ABI compatibility is one of those things that is necessary with such a long history, especially with commercial libraries that don&#x27;t really have an equivalent in the newer languages. The issue with C++ that doesn&#x27;t exist with it&#x27;s competitors is that there is a long tail of software people use commercially that isn&#x27;t source available that&#x27;s incredibly important in certain use cases.<p>I worked in a previous role on C++ CAD&#x2F;simulation software that required vendored things like solid modelling kernels and it was incredibly painful. Occasionally one of the vendors would just not do the work and you&#x27;d end up having to spend half a year ripping out the dependency that worked perfectly well. The team working on the software were generally in favour of moving up through to modern standards, while I was there we did 03 -&gt; 17 for e.g. but that didn&#x27;t finish til 4 years after the C++17 standard came out for all sorts of reasons. When VS2017 came out everyone breathed a sigh of relief because suddenly we didn&#x27;t have to wait to upgrade the compiler.</div><br/></div></div></div></div><div id="42235413" class="c"><input type="checkbox" id="c-42235413" checked=""/><div class="controls bullet"><span class="by">panstromek</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232193">parent</a><span>|</span><a href="#42234435">prev</a><span>|</span><a href="#42234382">next</a><span>|</span><label class="collapse" for="c-42235413">[-]</label><label class="expand" for="c-42235413">[3 more]</label></div><br/><div class="children"><div class="content">So here&#x27;s the thing. Almost none of the problems I have with C++ are related to &quot;flexible efficiency and raw power of C&quot;. You could easily have language that is even more flexible and powerful, but much easier to use. Or not even use, just install.<p>C++ was always by far the most inefficient langauge to work with for me, because there&#x27;s just so much chore and nonsense that you have to get through to get anything done, and almost none of it has any reasonable purpose, there&#x27;s no efficency tradeoff. I&#x27;m pretty sure that the insane build situation or UB in uninitialized variables or unspecified argument evaluation order never really benefited anybody, they are just bad decisions in the language, and that&#x27;s all.</div><br/><div id="42236924" class="c"><input type="checkbox" id="c-42236924" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42235413">parent</a><span>|</span><a href="#42234382">next</a><span>|</span><label class="collapse" for="c-42236924">[-]</label><label class="expand" for="c-42236924">[2 more]</label></div><br/><div class="children"><div class="content">&gt; UB in uninitialized variables<p>You will be happy to learn the uninitialized variables are not UB as of C++26.</div><br/><div id="42241027" class="c"><input type="checkbox" id="c-42241027" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42236924">parent</a><span>|</span><a href="#42234382">next</a><span>|</span><label class="collapse" for="c-42241027">[-]</label><label class="expand" for="c-42241027">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re just initialized to some unspecified value and cause almost-as-hard-to-diagnose faults.</div><br/></div></div></div></div></div></div><div id="42234382" class="c"><input type="checkbox" id="c-42234382" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232193">parent</a><span>|</span><a href="#42235413">prev</a><span>|</span><a href="#42236498">next</a><span>|</span><label class="collapse" for="c-42234382">[-]</label><label class="expand" for="c-42234382">[1 more]</label></div><br/><div class="children"><div class="content">So much for the theory, then there is the hard reality how standard library is implemented, the variantions across implementations, and how the ongoing ABI drama is preventing any performance improvements to it.</div><br/></div></div><div id="42236498" class="c"><input type="checkbox" id="c-42236498" checked=""/><div class="controls bullet"><span class="by">chrsig</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232193">parent</a><span>|</span><a href="#42234382">prev</a><span>|</span><a href="#42231991">next</a><span>|</span><label class="collapse" for="c-42236498">[-]</label><label class="expand" for="c-42236498">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but C++ sings its siren von Neumann song to the wizards, and there will always be wizard musicologists who steer their projects toward those rocks and, when they have just enough wax in their ears, they sail right past the rocks and come out the other side of the straits leading the rest of the fleet.<p>beautiful, in equal parts true, sad, and endearing.<p>but also remember the vasa.</div><br/></div></div></div></div></div></div><div id="42231991" class="c"><input type="checkbox" id="c-42231991" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232125">prev</a><span>|</span><a href="#42235140">next</a><span>|</span><label class="collapse" for="c-42231991">[-]</label><label class="expand" for="c-42231991">[1 more]</label></div><br/><div class="children"><div class="content">Profiles aren&#x27;t a mess because they&#x27;re intended for legacy codebases instead of big tech monorepos. They&#x27;re a mess because they&#x27;re not a serious effort. There&#x27;s no actual vision of what problems they&#x27;re trying to solve or what the use cases are, or even what kind of guarantee profiles are going to make.</div><br/></div></div><div id="42235140" class="c"><input type="checkbox" id="c-42235140" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#42231991">prev</a><span>|</span><a href="#42243000">next</a><span>|</span><label class="collapse" for="c-42235140">[-]</label><label class="expand" for="c-42235140">[4 more]</label></div><br/><div class="children"><div class="content">Ports of massive legacy codebases are possible and they happen. They can be extremely difficult, they take will and effort but they can get done. The idea that you have to slow down the development of the language standard for people who won&#x27;t port to the new version is weird- Those people won&#x27;t be updating compilers anyway.<p>How do I know this? I migrated a codebase of about 20m lines of C++ at a major investment bank from pre-ansi compilers to ansi conformance across 3 platforms (Linux, Solaris and Windows).  Not all the code ran on all 3 platforms (I&#x27;m looking at you, Solaris) but the vast majority did. Some of it was 20 years old before I touched it - we&#x27;re talking pre-STL not even just pre ansi. The team was me + one other dude for Linux and Solaris and me + one other different dude for windows, and to give you an idea the target for gcc went from gcc 2.7[1] to gcc 4[2], so a pretty massive change. The build tooling was all CMake + a bunch of special custom shell we had developed to set env vars etc and a CI&#x2F;CD pipeline that was all custom (and years ahead of its time). Version control was CVS.  So, single central code repo and if there was a version conflict an expert (of which I was one but it gives me cold sweats) had to go in, edit the RCS files by hand and if they screwed up all version control for everyone was totally hosed until someone restored from backup and redid the fix successfully.<p>While we were doing the port to make things harder there was a community of 667 developers[3] actively developing features on this codebase and it had to get pushed out come hell or high water every 2 weeks.  Also, this being the securities division of a major investment bank, if anything screwed up real money would be lost.<p>It was a lot of work, but it got done. I did all my work using vim and quickfix lists (not any fancy pants tooling) including on windows but my windows colleague used visual C++ for his work.[4]<p>[1] Released in 1995<p>[2] Released in 2005<p>[3] yes.  The CTO once memorably described it to me as &quot;The number of the beast plus Kirat&quot;. Referring to one particularly prolific developer who is somewhat of a legend on Wall Street.<p>[4] This was in the era of &quot;debugging the error novel&quot; so you&#x27;re talking 70 pages of ascii sometimes for a single error message with a template backtrace, and of course when you&#x27;re porting you&#x27;re getting tens of thousands of these errors. I actually wrote FAQs (for myself as much as anything) about when you were supposed to change &quot;class&quot; to &quot;typename&quot;, when you needed &quot;typedef typename&quot; and when you just needed &quot;typedef&quot; etc.  So glad I don&#x27;t do that any more.</div><br/><div id="42235631" class="c"><input type="checkbox" id="c-42235631" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#42235140">parent</a><span>|</span><a href="#42243000">next</a><span>|</span><label class="collapse" for="c-42235631">[-]</label><label class="expand" for="c-42235631">[3 more]</label></div><br/><div class="children"><div class="content">Was it Morgan Stanley?  That is the only shop I can think of that is so focused on C++.  Hell, they hired Bjarne Stroustrup.<p>But since you say version control was CVS, then I guess it was Goldman.  They still have that sheizen for SecDB&#x2F;Slang today.<p>And I assume that &quot;Kirat&quot; is Kirat Singh of Goldman SecDB&#x2F;JPM Athena&#x2F;BofA Quartz&#x2F;Beacon?</div><br/><div id="42235744" class="c"><input type="checkbox" id="c-42235744" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#42235140">root</a><span>|</span><a href="#42235631">parent</a><span>|</span><a href="#42236465">next</a><span>|</span><label class="collapse" for="c-42235744">[-]</label><label class="expand" for="c-42235744">[1 more]</label></div><br/><div class="children"><div class="content">Yes goldman and yes that Kirat. Fun fact, the Windows port colleague was John Madsen who later became CTO of Goldman I think.</div><br/></div></div><div id="42236465" class="c"><input type="checkbox" id="c-42236465" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42235140">root</a><span>|</span><a href="#42235631">parent</a><span>|</span><a href="#42235744">prev</a><span>|</span><a href="#42243000">next</a><span>|</span><label class="collapse" for="c-42236465">[-]</label><label class="expand" for="c-42236465">[1 more]</label></div><br/><div class="children"><div class="content">Google brought up this; Kirat Singh - <a href="https:&#x2F;&#x2F;apacentrepreneur.com&#x2F;kirat-singh-passion-and-determination-personified&#x2F;" rel="nofollow">https:&#x2F;&#x2F;apacentrepreneur.com&#x2F;kirat-singh-passion-and-determi...</a><p>Very impressive indeed.</div><br/></div></div></div></div></div></div><div id="42243000" class="c"><input type="checkbox" id="c-42243000" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42235140">prev</a><span>|</span><a href="#42235614">next</a><span>|</span><label class="collapse" for="c-42243000">[-]</label><label class="expand" for="c-42243000">[1 more]</label></div><br/><div class="children"><div class="content">Iâm not sure I understand the whole ABI argument. Isnât the raison dâÃªtre for namespace versions precisely to evolve the language? Why canât the existing implementations be copied into a std::v2 but with a changed ABI. Existing ABI issues are non-issues because the old code remains while new code will by default compile against v2 picking up all the goodies and can downgrade the types they actually use across ABI in the places they need by changing the namespace version used for a given compilation unit via compile-time flags (or something along these lines)?<p>Were namespace versions determined to not solve this problem? That would be the most ironic thing after all if the change management system introduced in c++11 to avoid std::string is either unused, untrusted, or unworkable for the purpose it was intended.</div><br/></div></div><div id="42235614" class="c"><input type="checkbox" id="c-42235614" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42243000">prev</a><span>|</span><a href="#42232176">next</a><span>|</span><label class="collapse" for="c-42235614">[-]</label><label class="expand" for="c-42235614">[1 more]</label></div><br/><div class="children"><div class="content">âGovernments are telling you to stop using C++â.<p>This invokes the imagery of a  1950s Apollo era scientist saying something serious. But I promise you there is no visionary low level language authority in the background. Itâs just a staffer being influenced by the circle of blogs prominent on programming Reddit and twitter.<p>&gt; no overhead principle<p>Itâs actually nice to hear they are asserting a more conservative outlook and have some guiding design principle.<p>Bjarne is more of a super-bureaucrat than a designer. In the early days he pulled C++ into whatever language movements were popular. For a while it looked like Rust was having that influence.<p>But the outcome has been a refinement of C++ library safety features which are moderate and easy to adopt.</div><br/></div></div><div id="42232176" class="c"><input type="checkbox" id="c-42232176" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42235614">prev</a><span>|</span><a href="#42243287">next</a><span>|</span><label class="collapse" for="c-42232176">[-]</label><label class="expand" for="c-42232176">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Nimble, modern, highly capable tech corporations that understand that their code is an asset. (This isnât strictly big tech. Any sane greenfield C++ startup will also fall into this category.)<p>Oh I see, this is a fantasy.</div><br/><div id="42234609" class="c"><input type="checkbox" id="c-42234609" checked=""/><div class="controls bullet"><span class="by">badmintonbaseba</span><span>|</span><a href="#42232176">parent</a><span>|</span><a href="#42237025">next</a><span>|</span><label class="collapse" for="c-42234609">[-]</label><label class="expand" for="c-42234609">[1 more]</label></div><br/><div class="children"><div class="content">Keyword is &quot;sane&quot;. You can probably count all &quot;sane greenfield C++ startups&quot; on one hand.</div><br/></div></div><div id="42237025" class="c"><input type="checkbox" id="c-42237025" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#42232176">parent</a><span>|</span><a href="#42234609">prev</a><span>|</span><a href="#42234328">next</a><span>|</span><label class="collapse" for="c-42237025">[-]</label><label class="expand" for="c-42237025">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also just plain wrong. Even the cleanest most beautiful and efficient code is a liability. You sell software, not code.<p>It&#x27;s all about the magnitude of the liability, not the direction</div><br/><div id="42238113" class="c"><input type="checkbox" id="c-42238113" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#42232176">root</a><span>|</span><a href="#42237025">parent</a><span>|</span><a href="#42234328">next</a><span>|</span><label class="collapse" for="c-42238113">[-]</label><label class="expand" for="c-42238113">[2 more]</label></div><br/><div class="children"><div class="content">Code is an asset in the same way that any process documents in your organization are. They represent codified solutions to problems.<p>You do not need to re-solve this problem, and when a similar problem occurs, you can adapt the existing solution to the new problem.<p>Another way to think about it: if code was not an asset, we would delete it immediately after compilation.</div><br/><div id="42241495" class="c"><input type="checkbox" id="c-42241495" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#42232176">root</a><span>|</span><a href="#42238113">parent</a><span>|</span><a href="#42234328">next</a><span>|</span><label class="collapse" for="c-42241495">[-]</label><label class="expand" for="c-42241495">[1 more]</label></div><br/><div class="children"><div class="content">Having no code corresponding to the software in service is a bigger liability than having it</div><br/></div></div></div></div></div></div><div id="42234328" class="c"><input type="checkbox" id="c-42234328" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#42232176">parent</a><span>|</span><a href="#42237025">prev</a><span>|</span><a href="#42243287">next</a><span>|</span><label class="collapse" for="c-42234328">[-]</label><label class="expand" for="c-42234328">[1 more]</label></div><br/><div class="children"><div class="content">The Rust people pursue &quot;solidarity&quot; as a virtue. They don&#x27;t understand that factions is a way of life, so any sufficiently impactful technology will be &quot;fractured&quot; to some extent. This is a good thing. Unitarity, solidarity, homogenous philosophiesâare not, but they would have to learn it the hard way like everybody else.</div><br/></div></div></div></div><div id="42243287" class="c"><input type="checkbox" id="c-42243287" checked=""/><div class="controls bullet"><span class="by">ramshanker</span><span>|</span><a href="#42232176">prev</a><span>|</span><a href="#42237780">next</a><span>|</span><label class="collapse" for="c-42243287">[-]</label><label class="expand" for="c-42243287">[1 more]</label></div><br/><div class="children"><div class="content">I am working on a new C++ project in 2024 for my part time project. And this article provided me enough information to battle future &quot;Why not use XYZ instead&quot; discussion. ;)<p>My Rational for Using C++ in 2024: (A) Extreme computational performance desired. (B) I learned C++ 20 years back. (C) C++ has good enough Cross-Platform (OS) compatibility.</div><br/></div></div><div id="42237780" class="c"><input type="checkbox" id="c-42237780" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42243287">prev</a><span>|</span><a href="#42241230">next</a><span>|</span><label class="collapse" for="c-42237780">[-]</label><label class="expand" for="c-42237780">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Stories of people trying their best to participate in the C++-standard committee process across multiple years<p>This links to:<p><a href="https:&#x2F;&#x2F;thephd.dev&#x2F;finally-embed-in-c23" rel="nofollow">https:&#x2F;&#x2F;thephd.dev&#x2F;finally-embed-in-c23</a><p>It was a fascinating story, particularly about how people finally coming to terms with accepting that a seemly ugly way of doing things really is the best way (you just can&#x27;t &quot;parse better&quot;).<p>The feature itself is interesting too.<p><a href="https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;jGajc6xd5" rel="nofollow">https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;jGajc6xd5</a></div><br/><div id="42241358" class="c"><input type="checkbox" id="c-42241358" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42237780">parent</a><span>|</span><a href="#42241230">next</a><span>|</span><label class="collapse" for="c-42241358">[-]</label><label class="expand" for="c-42241358">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fascinating how much <i>more complicated</i> this ends up being to deliver in the C and C++ ecosystem.<p>#embed has to pretend - in principle - that we&#x27;re going to conjure all these byte values into existence, as actual numbers, and then by the &quot;as if&quot; rule the compiler is not really going to do that because it would be crazy slow. The reality that we&#x27;re just going to shove the data into the program as if it was an array is an (obviously, implemented everywhere) optimisation, rather than part of the language specification.<p>The analogous Rust `include_bytes!` just gets you a &amp;&#x27;static [u8; N]  -- an immutable reference to an array of N bytes which lives forever.<p>At first I thought OK, well, maybe the C approach lets you do some clever compile stuff that Rust can&#x27;t do. Nope. If I have a compile time function checksum which calculates a 64-bit checksum of the slice passed by immutable reference - and a file of 128MB of data called firmware.bin, Rust is completely fine with let sum = checksum(include_bytes!(&quot;firmware.bin&quot;));  and that results in a 64-bit value, the 128MB file evaporated after being checksummed.</div><br/></div></div></div></div><div id="42241230" class="c"><input type="checkbox" id="c-42241230" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42237780">prev</a><span>|</span><a href="#42237117">next</a><span>|</span><label class="collapse" for="c-42241230">[-]</label><label class="expand" for="c-42241230">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Relatively modern, capable tech corporations that understand that their code is an asset.<p>I strongly disagree with this. The more code you have, the more resources you have to spend maintaining it. There is a very relevant example close by in the post: the bit about Google having a clang-based tool that can refqactor the entire codebase. Great! Problem is, an engineer had to spend their time writing that, and you had to pay that engineer money - all because you have an unmanageable amount of code.<p>The real tech asset is processes: the things you have figured out in order to manage such an ungodly amount of code. Your most senior engineers, specifically what&#x27;s in their heads, are an asset too.</div><br/></div></div><div id="42237117" class="c"><input type="checkbox" id="c-42237117" checked=""/><div class="controls bullet"><span class="by">serjts</span><span>|</span><a href="#42241230">prev</a><span>|</span><a href="#42242579">next</a><span>|</span><label class="collapse" for="c-42237117">[-]</label><label class="expand" for="c-42237117">[8 more]</label></div><br/><div class="children"><div class="content">The real, everpresent and probably future nail in the coffin of C++ is the lack of a standard apckage manager and build system. The rest is just what happened to be picked up by social&#x2F;news as it is easier and flashier to talk about.</div><br/><div id="42237157" class="c"><input type="checkbox" id="c-42237157" checked=""/><div class="controls bullet"><span class="by">matt3210</span><span>|</span><a href="#42237117">parent</a><span>|</span><a href="#42242579">next</a><span>|</span><label class="collapse" for="c-42237157">[-]</label><label class="expand" for="c-42237157">[7 more]</label></div><br/><div class="children"><div class="content">Conan and cmake problem solved</div><br/><div id="42237776" class="c"><input type="checkbox" id="c-42237776" checked=""/><div class="controls bullet"><span class="by">serjts</span><span>|</span><a href="#42237117">root</a><span>|</span><a href="#42237157">parent</a><span>|</span><a href="#42242579">next</a><span>|</span><label class="collapse" for="c-42237776">[-]</label><label class="expand" for="c-42237776">[6 more]</label></div><br/><div class="children"><div class="content">Ah, we are from the same tribes! Let&#x27;s go talk to the the bazel and to the vcpkg tribes. But what about the fact that cmake isn&#x27;t a build system, also conan 2.0 was a bit rough the last I saw.. maybe thats why clion&#x2F;intellij dropped support for it out of the box and now uses vcpkg?</div><br/><div id="42240870" class="c"><input type="checkbox" id="c-42240870" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42237117">root</a><span>|</span><a href="#42237776">parent</a><span>|</span><a href="#42239898">next</a><span>|</span><label class="collapse" for="c-42240870">[-]</label><label class="expand" for="c-42240870">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been contributing some C++ packages to xrepo, which personally imo is the best of all worlds. c:</div><br/></div></div><div id="42239898" class="c"><input type="checkbox" id="c-42239898" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#42237117">root</a><span>|</span><a href="#42237776">parent</a><span>|</span><a href="#42240870">prev</a><span>|</span><a href="#42242688">next</a><span>|</span><label class="collapse" for="c-42239898">[-]</label><label class="expand" for="c-42239898">[3 more]</label></div><br/><div class="children"><div class="content">There is a Bazel tribe? I&#x27;ve heard it mentioned a couple of time but I have yet to encounter a C++ project I need to build which supports Bazel but not CMake. In fact, just _any_ Bazel support seems to me quite rare. Am I living in a bubble?<p>As for vcpkg - yeah, that&#x27;s popular, for sure.</div><br/><div id="42240876" class="c"><input type="checkbox" id="c-42240876" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42237117">root</a><span>|</span><a href="#42239898">parent</a><span>|</span><a href="#42242688">next</a><span>|</span><label class="collapse" for="c-42240876">[-]</label><label class="expand" for="c-42240876">[2 more]</label></div><br/><div class="children"><div class="content">Daisy Hollman says she has &quot;drunk the Bazel kool-aid&quot; and is a big proponent of its usage outside Google.</div><br/><div id="42241185" class="c"><input type="checkbox" id="c-42241185" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#42237117">root</a><span>|</span><a href="#42240876">parent</a><span>|</span><a href="#42242688">next</a><span>|</span><label class="collapse" for="c-42241185">[-]</label><label class="expand" for="c-42241185">[1 more]</label></div><br/><div class="children"><div class="content">Bazel is a project created by Google, and Hollman works for Google. So - perhaps the Bazel tribe is people working at Google? There _are_ quite a few of those....</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42242579" class="c"><input type="checkbox" id="c-42242579" checked=""/><div class="controls bullet"><span class="by">up2isomorphism</span><span>|</span><a href="#42237117">prev</a><span>|</span><a href="#42241632">next</a><span>|</span><label class="collapse" for="c-42242579">[-]</label><label class="expand" for="c-42242579">[1 more]</label></div><br/><div class="children"><div class="content">It does not require particular  careful inspection to see that with all these zillions features comes into C++ 20, C++ still does not a have a straightforward string split function. And I still feel printf is more reliable and easier to use than all these âmodernâ fmt.<p>There must be some extremely ideological reason behind these horrible âmodernâ C++ standards.<p>There are some good trend happening during C++ 11, but now it is completely out of control now.</div><br/></div></div><div id="42241632" class="c"><input type="checkbox" id="c-42241632" checked=""/><div class="controls bullet"><span class="by">uluyol</span><span>|</span><a href="#42242579">prev</a><span>|</span><a href="#42233528">next</a><span>|</span><label class="collapse" for="c-42241632">[-]</label><label class="expand" for="c-42241632">[1 more]</label></div><br/><div class="children"><div class="content">I think the discussions in these threads show how accurate the framing of this article is. You have some people celebrating Google and friends (slowly) leaving the C++ ecosystem and those that continue to emphasize the flaws that have driven companies away from it in recent history (safety being #1) on the list.</div><br/></div></div><div id="42233528" class="c"><input type="checkbox" id="c-42233528" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#42241632">prev</a><span>|</span><a href="#42236817">next</a><span>|</span><label class="collapse" for="c-42233528">[-]</label><label class="expand" for="c-42233528">[7 more]</label></div><br/><div class="children"><div class="content">The author doesnât appear to consider the use of binary-only (typically commercial licensed) libraries.  Thereâs still a need for an ABI and âmodern toolingâ isnât a magic wand.</div><br/><div id="42233636" class="c"><input type="checkbox" id="c-42233636" checked=""/><div class="controls bullet"><span class="by">kkert</span><span>|</span><a href="#42233528">parent</a><span>|</span><a href="#42236817">next</a><span>|</span><label class="collapse" for="c-42233636">[-]</label><label class="expand" for="c-42233636">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d guess that majority of such binary-only libraries use C ABI interfaces. The entire Windows ecosystem of COM modules works on top of C ABI&#x27;s.</div><br/><div id="42234555" class="c"><input type="checkbox" id="c-42234555" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#42233528">root</a><span>|</span><a href="#42233636">parent</a><span>|</span><a href="#42236817">next</a><span>|</span><label class="collapse" for="c-42234555">[-]</label><label class="expand" for="c-42234555">[5 more]</label></div><br/><div class="children"><div class="content">Until the moment when you are forced to use a third-party SDK with std:: and boost:: (yeah, WTF?) types in the interface.<p>Oh, and you can&#x27;t avoid that, say, you are working on a trading bot and that&#x27;s the only &quot;supported&quot; way to connect to an exchange.<p>In the end people usually just reverse engineer and reimplement to get rid of such cursed blob. Fortunately, it works - the vendor can&#x27;t effectively push all clients to update their SDK too, so all wire protocols are infinitely backward compatible.</div><br/><div id="42236015" class="c"><input type="checkbox" id="c-42236015" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#42233528">root</a><span>|</span><a href="#42234555">parent</a><span>|</span><a href="#42236246">next</a><span>|</span><label class="collapse" for="c-42236015">[-]</label><label class="expand" for="c-42236015">[2 more]</label></div><br/><div class="children"><div class="content">The last time I was forced to deal with such a proprietary SDK (that required an ancient Windows C++ runtime, and segfaulted like crazy, natch), rather than waste months reverse-engineering it, I wrapped it in a separate process and talked to it via IPC. That got the job done, and every time their shitty code locked up or crashed, I just restarted the wrapper process from the main application.</div><br/><div id="42237611" class="c"><input type="checkbox" id="c-42237611" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42233528">root</a><span>|</span><a href="#42236015">parent</a><span>|</span><a href="#42236246">next</a><span>|</span><label class="collapse" for="c-42237611">[-]</label><label class="expand" for="c-42237611">[1 more]</label></div><br/><div class="children"><div class="content">Serialized data over stdin&#x2F;stdout is becoming my favorite protocol for ABI compatibility.<p>The amount of problems this solves is incredible, and it creates none of the ops issues with configuring and launching some new kind of Docker image.</div><br/></div></div></div></div><div id="42236246" class="c"><input type="checkbox" id="c-42236246" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#42233528">root</a><span>|</span><a href="#42234555">parent</a><span>|</span><a href="#42236015">prev</a><span>|</span><a href="#42236817">next</a><span>|</span><label class="collapse" for="c-42236246">[-]</label><label class="expand" for="c-42236246">[2 more]</label></div><br/><div class="children"><div class="content">For mummified binary dependencies, C# allows tediously fine control over stack frames in DLL function calls, and similar FFI systems are likely to be equally malleable; there&#x27;s probably a blind spot towards reverse engineering in C++, due to the expectation that a random ABI should &quot;just work&quot;.</div><br/><div id="42236683" class="c"><input type="checkbox" id="c-42236683" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#42233528">root</a><span>|</span><a href="#42236246">parent</a><span>|</span><a href="#42236817">next</a><span>|</span><label class="collapse" for="c-42236683">[-]</label><label class="expand" for="c-42236683">[1 more]</label></div><br/><div class="children"><div class="content">The problem is actually not ABI, it&#x27;s ODR violation. You can make it work, just make your own wrapper in C ABI, link it with whatever dependency (and version) that your vendor insists on, then `-fvisibility=hidden` and partial link the entire shit to avoid ODR violation.<p>People reverse these SDK partly because it makes the codebase saner, and partly because, well, this is trading, a saner implementation is almost guaranteed to be faster than vendor&#x27;s bullshit one, and guess who cares about being a little bit faster than everyone else?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42236817" class="c"><input type="checkbox" id="c-42236817" checked=""/><div class="controls bullet"><span class="by">BD103</span><span>|</span><a href="#42233528">prev</a><span>|</span><a href="#42238701">next</a><span>|</span><label class="collapse" for="c-42236817">[-]</label><label class="expand" for="c-42236817">[5 more]</label></div><br/><div class="children"><div class="content">Also see &quot;On &#x27;Safe&#x27; C++&quot;, which goes deeper into many of the insights brought up by this article. &lt;<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42186475">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42186475</a>&gt;</div><br/><div id="42238016" class="c"><input type="checkbox" id="c-42238016" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42236817">parent</a><span>|</span><a href="#42238701">next</a><span>|</span><label class="collapse" for="c-42238016">[-]</label><label class="expand" for="c-42238016">[4 more]</label></div><br/><div class="children"><div class="content">Having skimmed it, I hope more people read that article.</div><br/><div id="42239887" class="c"><input type="checkbox" id="c-42239887" checked=""/><div class="controls bullet"><span class="by">imp0cat</span><span>|</span><a href="#42236817">root</a><span>|</span><a href="#42238016">parent</a><span>|</span><a href="#42242343">next</a><span>|</span><label class="collapse" for="c-42239887">[-]</label><label class="expand" for="c-42239887">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Several months later, I learned I had experienced slight brain damage due to hypoxia and Iâve been slowly recovering ever since. The worst part of all of this is that I said in that post that I was enjoying golang. In other words, I had brain damage and suddenly found writing Go to be fun. Take from that what you will
</code></pre>
OMG. ;) It&#x27;s an interesting rant nonetheless.</div><br/></div></div><div id="42242343" class="c"><input type="checkbox" id="c-42242343" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42236817">root</a><span>|</span><a href="#42238016">parent</a><span>|</span><a href="#42239887">prev</a><span>|</span><a href="#42240633">next</a><span>|</span><label class="collapse" for="c-42242343">[-]</label><label class="expand" for="c-42242343">[1 more]</label></div><br/><div class="children"><div class="content">I read it.<p>To save people the trouble it seemed like a manic rant intended to pick several bones (at least the author is self aware enough to admit as much). It&#x27;s heavy on the &quot;trust me, I have sources&quot; and light on actual content. It&#x27;s got enough drama and insinuations from calling people liars, narcissists, to finally nazis. It veers from committee drama, to Trump, to feminism, to AI... very hard to follow.<p>Worthy of a daytime soap opera but other than that there&#x27;s nothing notable there. Except it does make me want to avoid all these people, on both sides of whatever drama this is.</div><br/></div></div><div id="42240633" class="c"><input type="checkbox" id="c-42240633" checked=""/><div class="controls bullet"><span class="by">imp0cat</span><span>|</span><a href="#42236817">root</a><span>|</span><a href="#42238016">parent</a><span>|</span><a href="#42242343">prev</a><span>|</span><a href="#42238701">next</a><span>|</span><label class="collapse" for="c-42240633">[-]</label><label class="expand" for="c-42240633">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    One example of this is [...] the new proposed (but not yet approved) Boost website. This is located at boost.io and Iâm not going to turn that into a clickable link, and thatâs because this proposed website brings with it a new logo. [...] This logo features a Nazi dog whistle. The Nazi SS lightning bolts. 

    The thing about dog whistles like this is that you can feign ignorance or act like someone is seeing something that isnât there, but for something egregious itâs very hard to defend it in this case.

    Of course, thereâs other political dog whistles out there in the tech world right now. Justine Tunney named her C library, cosmopolitan5, which I personally believe is named after the term Rootless Cosmopolitan. This is a pejorative Soviet epithet which was used primarily during Joseph Stalinâs antisemitic campaign in the late 40s and early 50s. This is obviously much harder to prove6 as Justine has done a very good job of deleting some very eyebrow raising tweets over the years, even having them scrubbed from The Internet Archiveâs Wayback Machine [...]

    Justine, unfortunately, doesnât appear to have made any amends either, at least publicly, or even acknowledged her past behavior, though she is more than happy to reference her time in the Occupy Wall Street movement. These days however, sheâs busy working on llamafiles for Mozilla. For those of you not in the know, a llamafile is basically for turning an LLMâs weights into an executable. 
</code></pre>
And then he makes (yet another!) detour to AI and C++ which I am going to follow.<p>It&#x27;s a massive post though. Right now I am an hour in and probably about 75% done and I am skipping most of the linked articles. Except for the Ender&#x27;s game parts. I highly recommend those.</div><br/></div></div></div></div></div></div><div id="42238701" class="c"><input type="checkbox" id="c-42238701" checked=""/><div class="controls bullet"><span class="by">Mond_</span><span>|</span><a href="#42236817">prev</a><span>|</span><a href="#42235447">next</a><span>|</span><label class="collapse" for="c-42238701">[-]</label><label class="expand" for="c-42238701">[1 more]</label></div><br/><div class="children"><div class="content">Woah, my post made it to the front page and I&#x27;m late. Hi!<p>In hindsight I would&#x27;ve probably written a few things differently, but I really didn&#x27;t want to fall into a trap of getting stuck editing.</div><br/></div></div><div id="42235447" class="c"><input type="checkbox" id="c-42235447" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#42238701">prev</a><span>|</span><a href="#42237771">next</a><span>|</span><label class="collapse" for="c-42235447">[-]</label><label class="expand" for="c-42235447">[2 more]</label></div><br/><div class="children"><div class="content">Two factions? Considering C++ has everything, I&#x27;d assume there are tens of factions.</div><br/><div id="42236152" class="c"><input type="checkbox" id="c-42236152" checked=""/><div class="controls bullet"><span class="by">humanrebar</span><span>|</span><a href="#42235447">parent</a><span>|</span><a href="#42237771">next</a><span>|</span><label class="collapse" for="c-42236152">[-]</label><label class="expand" for="c-42236152">[1 more]</label></div><br/><div class="children"><div class="content">This is true. That is why there is no leadership committee for the C++ ecosystem. There is no way to select one.</div><br/></div></div></div></div><div id="42235929" class="c"><input type="checkbox" id="c-42235929" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#42237771">prev</a><span>|</span><a href="#42243120">next</a><span>|</span><label class="collapse" for="c-42235929">[-]</label><label class="expand" for="c-42235929">[1 more]</label></div><br/><div class="children"><div class="content">I personally like these discussions about C++. Yes, I think C++ should continue to be C++. I also like it that way.<p>On the other hand, having a bit more transparency into the workgroups and their way of doing things may allow the process become a bit more efficient, approachable, and maybe would allow shedding some of the problems which have accumulated due to being so isolated from the world.<p>Some of the alleged events really leave a bad taste in the mouth, and really casts a shade of doubt for the future of C++.<p>Lastly, alienating people by shredding their work and bullying them emotionally is not the best way to build a next generation of caretakers for one of the biggest languages in the world. It might not fall overnight, but it&#x27;ll certainly rot from its core if not tended properly. Nothing is too big to fail.</div><br/></div></div><div id="42243120" class="c"><input type="checkbox" id="c-42243120" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#42235929">prev</a><span>|</span><label class="collapse" for="c-42243120">[-]</label><label class="expand" for="c-42243120">[1 more]</label></div><br/><div class="children"><div class="content">C++ is dead by entropy. So complex nobody can truly learn it anymore.</div><br/></div></div></div></div></div></div></div></body></html>