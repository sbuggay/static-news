<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732525268515" as="style"/><link rel="stylesheet" href="styles.css?v=1732525268515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://herecomesthemoon.net/2024/11/two-factions-of-cpp/">The Two Factions of C++</a> <span class="domain">(<a href="https://herecomesthemoon.net">herecomesthemoon.net</a>)</span></div><div class="subtext"><span>cyclopeanutopia</span> | <span>103 comments</span></div><br/><div><div id="42232183" class="c"><input type="checkbox" id="c-42232183" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42231943">next</a><span>|</span><label class="collapse" for="c-42232183">[-]</label><label class="expand" for="c-42232183">[14 more]</label></div><br/><div class="children"><div class="content">I compile a lot of C++ code from a lot of places, and the only time I run into code that somehow simply <i>doesn&#x27;t work</i> on newer versions of C++ and where the developers aren&#x27;t even sure if they will accept any patches to fix the issue as they claim it &quot;isn&#x27;t supported&quot; to use a newer version of C++--even for the public headers of a library--is, you guessed it: code from Google.<p>Meanwhile, most of the C++ code from Google seems to be written in some mishmash of different ideas, always at some halfway point along a migration between something ancient and something passable... but never anything I would ever dare to call &quot;modern&quot;, and thereby tends to be riddled with state machines and manual weak pointers that lead to memory corruption.<p>So... I really am not sure I buy the entire premise of this article? Honestly, I am extremely glad that Google is finally leaving the ecosystem, as I generally do not enjoy it when Google engineers try to force their ridiculous use cases down peoples&#x27; throats, as they seem to believe they simply know better than everyone else how to develop software.<p>Like... I honestly feel bad for the Rust people, as I do not think the increasing attention they are going to get from Google is going to be at all positive for that ecosystem, any more than I think the massive pressure Google has exerted on the web has been positive or any more than the pressure Google even exerted on Python was positive (not that Python caved to much of it, but the pressure was on and the fact that Python refused to play ball with Google was in no small part what caused Go to exist at all).<p>(FWIW, I do miss Microsoft&#x27;s being in the space, but they honestly left years ago -- Herb&#x27;s existence until recent being kind of a token consideration -- as they have been trying to figure out a tactical exit to C++ ever since Visual J++ and, arguably, Visual Basic, having largely managed to pivot to C# and TypeScript for SDKs long ago. That said... Sun kicking Microsoft out of Java might have been really smart, despite the ramifications?)</div><br/><div id="42234375" class="c"><input type="checkbox" id="c-42234375" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42232925">next</a><span>|</span><label class="collapse" for="c-42234375">[-]</label><label class="expand" for="c-42234375">[1 more]</label></div><br/><div class="children"><div class="content">The issue with Microsoft until recently, has been the power of WinDev, which are the ones responsible for anything C++ on Microsoft dungeons.<p>Hence the failure of Longhorn, or any attempt coming out from Microsoft Research.<p>Ironically, given your Sun remark, Microsoft is back into the Java game, having their own distribution of OpenJDK, and Java is usually the only ecosystem that has day one parity with anything Azure puts out as .NET SDK.</div><br/></div></div><div id="42232925" class="c"><input type="checkbox" id="c-42232925" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42234375">prev</a><span>|</span><a href="#42232287">next</a><span>|</span><label class="collapse" for="c-42232925">[-]</label><label class="expand" for="c-42232925">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Honestly, I am extremely glad that Google is finally leaving the ecosystem, as I generally do not enjoy it when Google engineers try to force their ridiculous use cases down peoples&#x27; throats, as they seem to believe they simply know better than everyone else how to develop software.<p>Well, you may be celebrating a bit prematurely then. Google still has a ton of C++ and they haven&#x27;t stopped writing it. It&#x27;s going to take ~forever until Google has left the C++ ecosystem. What <i>did</i> happen was that Google majorly scaled down their efforts in the committee.<p>When it comes to the current schism on how to improve the safety of C++ there are largely two factions:<p>* The Bjarne&#x2F;Herb [1] side that focuses on minimal changes to the code. The idea here is to add different profiles to the language and then [draw the rest of the fucking owl]. The big issue here is that it&#x27;s entirely unclear on how they will achieve temporal and spatial memory safety.<p>* The other side is represented by Sean Baxter and his work on Safe C++. This is basically a whole-sale adoption of Rust&#x27;s semantics. The big issue here is that it&#x27;s effectively introducing a new language that isn&#x27;t <i>C++</i>.<p>Google decided to pursue Carbon and isn&#x27;t a major playing in either of the above efforts. Last time I checked, that language is not not meant to be memory safe.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;BjarneStroustrup&#x2F;profiles">https:&#x2F;&#x2F;github.com&#x2F;BjarneStroustrup&#x2F;profiles</a>
[2] <a href="https:&#x2F;&#x2F;safecpp.org&#x2F;draft.html" rel="nofollow">https:&#x2F;&#x2F;safecpp.org&#x2F;draft.html</a></div><br/></div></div><div id="42232287" class="c"><input type="checkbox" id="c-42232287" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42232925">prev</a><span>|</span><a href="#42233157">next</a><span>|</span><label class="collapse" for="c-42232287">[-]</label><label class="expand" for="c-42232287">[10 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; riddled with state machines
</code></pre>
Why is this bad?  Normally, state machines are easy to reason about.</div><br/><div id="42232446" class="c"><input type="checkbox" id="c-42232446" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42232443">next</a><span>|</span><label class="collapse" for="c-42232446">[-]</label><label class="expand" for="c-42232446">[2 more]</label></div><br/><div class="children"><div class="content">The set of developers who say &quot;I want to implement this logic as a state machine&quot; is MUCH larger than the set of developers who say &quot;I should make sure I fully understand every possible state and edge case ahead of time before making a state machine!&quot;</div><br/><div id="42232835" class="c"><input type="checkbox" id="c-42232835" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232446">parent</a><span>|</span><a href="#42232443">next</a><span>|</span><label class="collapse" for="c-42232835">[-]</label><label class="expand" for="c-42232835">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t this be said about any alternative solution?  I fail to see how this is specific to state machines.<p>What do you suggest instead of a state machine?</div><br/></div></div></div></div><div id="42232443" class="c"><input type="checkbox" id="c-42232443" checked=""/><div class="controls bullet"><span class="by">risenshinetech</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42232446">prev</a><span>|</span><a href="#42233590">next</a><span>|</span><label class="collapse" for="c-42232443">[-]</label><label class="expand" for="c-42232443">[1 more]</label></div><br/><div class="children"><div class="content">Please describe &quot;normally&quot;. State machines can turn into nightmares, just like any design pattern used poorly.</div><br/></div></div><div id="42233590" class="c"><input type="checkbox" id="c-42233590" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42232443">prev</a><span>|</span><a href="#42232370">next</a><span>|</span><label class="collapse" for="c-42233590">[-]</label><label class="expand" for="c-42233590">[3 more]</label></div><br/><div class="children"><div class="content">State machines don&#x27;t have syntax for &quot;transition here when event is encountered no matter what state you are in&quot; so the whole diagram becomes a spaghetti mess if you have a lot of those escape hatches.</div><br/><div id="42233710" class="c"><input type="checkbox" id="c-42233710" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233590">parent</a><span>|</span><a href="#42232370">next</a><span>|</span><label class="collapse" for="c-42233710">[-]</label><label class="expand" for="c-42233710">[2 more]</label></div><br/><div class="children"><div class="content">I believe HSMs can model this, but don&#x27;t quote me. :)</div><br/><div id="42233963" class="c"><input type="checkbox" id="c-42233963" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42233710">parent</a><span>|</span><a href="#42232370">next</a><span>|</span><label class="collapse" for="c-42233963">[-]</label><label class="expand" for="c-42233963">[1 more]</label></div><br/><div class="children"><div class="content">Yes, of course in theory nested state machines should be able to model this. I feel like adding more complexity and bending the rules is a bit of a concession.</div><br/></div></div></div></div></div></div><div id="42232370" class="c"><input type="checkbox" id="c-42232370" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232287">parent</a><span>|</span><a href="#42233590">prev</a><span>|</span><a href="#42233157">next</a><span>|</span><label class="collapse" for="c-42232370">[-]</label><label class="expand" for="c-42232370">[3 more]</label></div><br/><div class="children"><div class="content">They can be.  Or they can be... less easy.<p>Imagine you have an informally-specified, undocumented, at-least-somewhat-incomplete state machine.  Imagine that it interacts with several other similar state machines.  Still easy to reason about?<p>Now add multithreading.  Still easy?<p>Now add locking.  Still easy?<p>Cleanly-done state machines can be the cleanest way to describe a problem, and the simplest way to implement it.  But badly-done state machines can be a total mess.<p>Alas, I think that the last time I waded in such waters, what I left behind was pretty much on the &quot;mess&quot; side of the scale.  It worked, it worked mostly solidly, and it did so for more than a decade.  But it was still rather messy.</div><br/><div id="42233690" class="c"><input type="checkbox" id="c-42233690" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232370">parent</a><span>|</span><a href="#42233667">next</a><span>|</span><label class="collapse" for="c-42233690">[-]</label><label class="expand" for="c-42233690">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine you have an informally-specified, undocumented, at-least-somewhat-incomplete state machine. Imagine that it interacts with several other similar state machines. Still easy to reason about?<p>You think that developers that wrote an informally-specified, undocumented, at-least-somewhat-incomplete state-machine would have written that logic as a non-state-machine in a formally-specified, documented and at-least-somewhat-complete codebase?<p>State-machines are exceptionally easy to reason about because you can at least reverse-engineer a state-diagram from the state-machine code.<p>Almost-a-state-machine-but-not-quite are exceptionally difficult to reason about because you can not easily reverse-engineer the state-diagram from the state-machine code.</div><br/></div></div><div id="42233667" class="c"><input type="checkbox" id="c-42233667" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42232183">root</a><span>|</span><a href="#42232370">parent</a><span>|</span><a href="#42233690">prev</a><span>|</span><a href="#42233157">next</a><span>|</span><label class="collapse" for="c-42233667">[-]</label><label class="expand" for="c-42233667">[1 more]</label></div><br/><div class="children"><div class="content">But that is just true of any problem-solving&#x2F;programming technique.<p>In general, state&#x2F;event machine transition table and decision table techniques of structuring code are easier to comprehend than adhoc and even worse, poorly understood pattern-based techniques are.</div><br/></div></div></div></div></div></div><div id="42233157" class="c"><input type="checkbox" id="c-42233157" checked=""/><div class="controls bullet"><span class="by">returningfory2</span><span>|</span><a href="#42232183">parent</a><span>|</span><a href="#42232287">prev</a><span>|</span><a href="#42231943">next</a><span>|</span><label class="collapse" for="c-42233157">[-]</label><label class="expand" for="c-42233157">[1 more]</label></div><br/><div class="children"><div class="content">I think the article is pretty interesting. There are so many more interesting takes than just another boring Hacker News moan about Google.</div><br/></div></div></div></div><div id="42231943" class="c"><input type="checkbox" id="c-42231943" checked=""/><div class="controls bullet"><span class="by">adambatkin</span><span>|</span><a href="#42232183">prev</a><span>|</span><a href="#42232004">next</a><span>|</span><label class="collapse" for="c-42231943">[-]</label><label class="expand" for="c-42231943">[8 more]</label></div><br/><div class="children"><div class="content">Something that Rust got _really_ right:
 Editions. And not just that they exist, but that they are specified per module, and you can mix and match modules with different Editions within a bigger project. This lets a language make backwards incompatible changes, and projects can adopt the new features piecemeal.<p>If such a thing came to C++, there would obviously be limitations around module boundaries, when different modules used a different Edition. But perhaps this could be a way forward that could allow both camps to have their cake and eat it too.<p>Imagine a world where the main difference between Python 2 and 3 was the frontend syntax parser, and each module could specifically which syntax (&quot;Edition&quot;) it used...</div><br/><div id="42231993" class="c"><input type="checkbox" id="c-42231993" checked=""/><div class="controls bullet"><span class="by">CrendKing</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42232232">next</a><span>|</span><label class="collapse" for="c-42231993">[-]</label><label class="expand" for="c-42231993">[6 more]</label></div><br/><div class="children"><div class="content">But Edition can exist only because Rust intrinsically has the concept of package, which naturally defines the boundary. C++ has nothing. How do you denote a.cpp be of cpp_2017 edition which b.cpp be cpp_2026? Some per-file comment line at top of each file?<p>C++ is a mess in that it has too much historic baggage while trying to adapt to a fiercely changing landscape. Like the article says, it has to make drastic changes to keep up, but such changes will probably kill 80% of its target audiences. I think putting C++ in maintenance mode and keep it as a &quot;legacy&quot; language is the way to go. It is time to either switch to Rust, or pick one of its successor languages and put effort into it.</div><br/><div id="42233728" class="c"><input type="checkbox" id="c-42233728" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42231993">parent</a><span>|</span><a href="#42232044">next</a><span>|</span><label class="collapse" for="c-42233728">[-]</label><label class="expand" for="c-42233728">[1 more]</label></div><br/><div class="children"><div class="content">Rust doesn&#x27;t have the concept of package. (Cargo does, but Cargo is a different thing from Rust, and it&#x27;s entirely possible to use Rust without Cargo).<p>Rust has the concept of _crate_, which is very close to the concept of compilation unit in C++. You build a crate by invoking `rustc` with a particular set of arguments, just as you build a compilation unit by invoking `g++` or `clang++` with a particular set of arguments.<p>One of these arguments defines the edition, for Rust, just like it could for C++.</div><br/></div></div><div id="42232044" class="c"><input type="checkbox" id="c-42232044" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42231993">parent</a><span>|</span><a href="#42233728">prev</a><span>|</span><a href="#42232232">next</a><span>|</span><label class="collapse" for="c-42232044">[-]</label><label class="expand" for="c-42232044">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I think putting C++ in maintenance mode and keep it as a &quot;legacy&quot; language is the way to go<p>I agree but also understand this is absolutely wishful thinking. There is so much inertia and natural resistance to change that C++ will be around for the next century barring nuclear armageddon.</div><br/><div id="42232358" class="c"><input type="checkbox" id="c-42232358" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232044">parent</a><span>|</span><a href="#42232275">next</a><span>|</span><label class="collapse" for="c-42232358">[-]</label><label class="expand" for="c-42232358">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think even that would suffice. :)</div><br/></div></div><div id="42232275" class="c"><input type="checkbox" id="c-42232275" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232044">parent</a><span>|</span><a href="#42232358">prev</a><span>|</span><a href="#42232232">next</a><span>|</span><label class="collapse" for="c-42232275">[-]</label><label class="expand" for="c-42232275">[2 more]</label></div><br/><div class="children"><div class="content">Cobol&#x27;s still around. Just because a language exists doesn&#x27;t mean that we have to keep releasing updated specifications and compiler versions rather than moving all those resources to better languages.</div><br/><div id="42232389" class="c"><input type="checkbox" id="c-42232389" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42231943">root</a><span>|</span><a href="#42232275">parent</a><span>|</span><a href="#42232232">next</a><span>|</span><label class="collapse" for="c-42232389">[-]</label><label class="expand" for="c-42232389">[1 more]</label></div><br/><div class="children"><div class="content">COBOL&#x27;s most recent standard was released in 2023, which rather ruins your point.</div><br/></div></div></div></div></div></div></div></div><div id="42232232" class="c"><input type="checkbox" id="c-42232232" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42231943">parent</a><span>|</span><a href="#42231993">prev</a><span>|</span><a href="#42232004">next</a><span>|</span><label class="collapse" for="c-42232232">[-]</label><label class="expand" for="c-42232232">[1 more]</label></div><br/><div class="children"><div class="content">There was a similar proposal for C++, using rust’s original names: epochs. It stalled out.</div><br/></div></div></div></div><div id="42232004" class="c"><input type="checkbox" id="c-42232004" checked=""/><div class="controls bullet"><span class="by">bagxrvxpepzn</span><span>|</span><a href="#42231943">prev</a><span>|</span><a href="#42232125">next</a><span>|</span><label class="collapse" for="c-42232004">[-]</label><label class="expand" for="c-42232004">[16 more]</label></div><br/><div class="children"><div class="content">To the people who work on C++ standards: I approve of the current C++ trajectory and please ignore all of the online noise about &quot;the future of C++.&quot; To anyone that disagrees severely with the C++ trajectory as stated, please just consider another language, e.g. Rust. I don&#x27;t want static lifetime checking in C++ and if you want static lifetime checking, please use Rust. I am not a government contractor, if you are a government contractor who must meet bureaucratic risk-averse government requirements, please use Rust. I have an existing development process that works for me and my customers, I have no significant demand for lifetime checking. If your development process is shiny and new and necessitates lifetime checking, then please use Rust. To Rust advocates, you can have the US government and big tech. You can even have Linux. Just leave my existing C++ process alone. It works and the trade offs we have chosen efficiently accomplish our goals.</div><br/><div id="42232091" class="c"><input type="checkbox" id="c-42232091" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42233039">next</a><span>|</span><label class="collapse" for="c-42232091">[-]</label><label class="expand" for="c-42232091">[5 more]</label></div><br/><div class="children"><div class="content">C++ has lifetime rules just like Rust. They&#x27;re simply implicit in the code and not enforced by the compiler. Do you prefer the uncertainty of silent miscompilations and undefined behavior to upfront compiler errors?<p>You&#x27;re already using a language with a strong type system, so it&#x27;s confusing to me why you would choose to draw the line here.</div><br/><div id="42232300" class="c"><input type="checkbox" id="c-42232300" checked=""/><div class="controls bullet"><span class="by">bagxrvxpepzn</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232091">parent</a><span>|</span><a href="#42233039">next</a><span>|</span><label class="collapse" for="c-42232300">[-]</label><label class="expand" for="c-42232300">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Do you prefer the uncertainty of silent miscompilations and undefined behavior to upfront compiler errors?<p>Yes because then I don&#x27;t have to spend hours writing esoteric spaghetti code to prove something to the compiler that is trivially known to be true. Your error is assuming static lifetime checking is free. As an engineer, I use judgement to make context-dependent trade offs.<p>If you like playing the compiler olympics, or your employer forces you to, please use Rust.</div><br/><div id="42232448" class="c"><input type="checkbox" id="c-42232448" checked=""/><div class="controls bullet"><span class="by">roland35</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42232499">prev</a><span>|</span><a href="#42233639">next</a><span>|</span><label class="collapse" for="c-42232448">[-]</label><label class="expand" for="c-42232448">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found that often when I am writing esoteric spaghetti rust code... I need to start thinking about what I am trying too do! Most of the time it&#x27;s a bad idea :)</div><br/></div></div><div id="42233639" class="c"><input type="checkbox" id="c-42233639" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232300">parent</a><span>|</span><a href="#42232448">prev</a><span>|</span><a href="#42233039">next</a><span>|</span><label class="collapse" for="c-42233639">[-]</label><label class="expand" for="c-42233639">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As an engineer, I use judgement to make context-dependent trade offs.<p>Well said.<p>This is why i am firmly in the Stroustrup camp of backward compatibility&#x2F;zero overhead&#x2F;better-C&#x2F;etc. goodness of &quot;old C++&quot;. I need to extend&#x2F;maintain&#x2F;rewrite tons of them and that needs to be as painless as possible. The current standards trajectory needs to be maintained.<p>The OP article is a rather poor one with no insights but mere hoopla over nothing.</div><br/></div></div></div></div></div></div><div id="42233039" class="c"><input type="checkbox" id="c-42233039" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232091">prev</a><span>|</span><a href="#42232665">next</a><span>|</span><label class="collapse" for="c-42233039">[-]</label><label class="expand" for="c-42233039">[3 more]</label></div><br/><div class="children"><div class="content">While programming in Rust, I&#x27;ve never thought to myself, &quot;man, this would be so much easier to express in C++&quot;. I&#x27;ve plenty of times thought the reverse while programming in C++ though.<p>Edit: except when interfacing with C APIs.</div><br/><div id="42233612" class="c"><input type="checkbox" id="c-42233612" checked=""/><div class="controls bullet"><span class="by">kkert</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233039">parent</a><span>|</span><a href="#42232665">next</a><span>|</span><label class="collapse" for="c-42233612">[-]</label><label class="expand" for="c-42233612">[2 more]</label></div><br/><div class="children"><div class="content">This is interesting because i&#x27;m writing quite a bit of embedded Rust, and i always run into limitations of very barebones const generics. I always wish they&#x27;d have half the expressiveness of C++ constexpr and templates.<p>Win some, lose some though, as the overall development workflow is lightyears ahead of C++, mostly due to tooling</div><br/><div id="42233966" class="c"><input type="checkbox" id="c-42233966" checked=""/><div class="controls bullet"><span class="by">afdbcreid</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42233612">parent</a><span>|</span><a href="#42232665">next</a><span>|</span><label class="collapse" for="c-42233966">[-]</label><label class="expand" for="c-42233966">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually quite interesting because this is not an inherent limitation of Rust, and it is definitely planned to be improved. And AFAIK, today (as opposed to last years) it is even being actively worked on!</div><br/></div></div></div></div></div></div><div id="42232665" class="c"><input type="checkbox" id="c-42232665" checked=""/><div class="controls bullet"><span class="by">feelamee</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42233039">prev</a><span>|</span><a href="#42232130">next</a><span>|</span><label class="collapse" for="c-42232665">[-]</label><label class="expand" for="c-42232665">[1 more]</label></div><br/><div class="children"><div class="content">Ok.
Please, just use your current C++ standard.
But we will go to use the new one with all features we want to use.</div><br/></div></div><div id="42232130" class="c"><input type="checkbox" id="c-42232130" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232665">prev</a><span>|</span><a href="#42232136">next</a><span>|</span><label class="collapse" for="c-42232130">[-]</label><label class="expand" for="c-42232130">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, why would I not want these things in C++ if I&#x27;m developing every project with -fsanitize=address,undefined to catch these types of errors anyway?</div><br/></div></div><div id="42232136" class="c"><input type="checkbox" id="c-42232136" checked=""/><div class="controls bullet"><span class="by">616c</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232130">prev</a><span>|</span><a href="#42232540">next</a><span>|</span><label class="collapse" for="c-42232136">[-]</label><label class="expand" for="c-42232136">[3 more]</label></div><br/><div class="children"><div class="content">But why say so under a pseudonym and avoid clarifying what products the process is for? Even if open source and not productized surely the interest goes simply beyond the the US presidents executive order regarding memory safety.<p>I don&#x27;t disagree with the implication that order relies on oversimplification and misunderstanding of the ask but surely it and Rust do not mean as a theme C++ standards must not take anything from it no?</div><br/><div id="42233716" class="c"><input type="checkbox" id="c-42233716" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232136">parent</a><span>|</span><a href="#42232415">next</a><span>|</span><label class="collapse" for="c-42233716">[-]</label><label class="expand" for="c-42233716">[1 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t shame people for using pseudonyms on here, regardless of whether you disagree with their concrete point. It&#x27;s nice to have a place where people don&#x27;t have to think about how their friends, family or colleagues will react before posting something.</div><br/></div></div><div id="42232415" class="c"><input type="checkbox" id="c-42232415" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232136">parent</a><span>|</span><a href="#42233716">prev</a><span>|</span><a href="#42232540">next</a><span>|</span><label class="collapse" for="c-42232415">[-]</label><label class="expand" for="c-42232415">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But why say so under a pseudonym<p>That&#x27;s a rather odd complaint, coming from a pseudonym.</div><br/></div></div></div></div><div id="42232540" class="c"><input type="checkbox" id="c-42232540" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#42232004">parent</a><span>|</span><a href="#42232136">prev</a><span>|</span><a href="#42232125">next</a><span>|</span><label class="collapse" for="c-42232540">[-]</label><label class="expand" for="c-42232540">[2 more]</label></div><br/><div class="children"><div class="content">The parts of the government that think everything should be written in a memory-safe language (like Rust) are the same parts that already write everything in Java. Most of the high-end systems work is in C++, and that is the type of software where lifetimes and ownership are frequently unknowable at compile-time, obviating Rust&#x27;s main selling point.</div><br/><div id="42232824" class="c"><input type="checkbox" id="c-42232824" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42232004">root</a><span>|</span><a href="#42232540">parent</a><span>|</span><a href="#42232125">next</a><span>|</span><label class="collapse" for="c-42232824">[-]</label><label class="expand" for="c-42232824">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a hard dichotomy. Almost all of the rules Rust imposes are also present in C++, enforcement is simply left up to the fallible human programmer. Frankly though, is it that big a deal whether we call it unique_ptr&#x2F;shared_ptr or Box&#x2F;Arc if a lifetime is truly unknowable?<p>Rust shines in the other 95% of code. I spend some time every morning cleaning up the sorts of issues Rust prevents that my coworkers have managed to commit despite  tooling safeguards. I try for 3 a day, the list is growing, and I don&#x27;t have to dig deep to find them. My coworkers aren&#x27;t stupid people, they&#x27;re intelligent people making simple mistakes because they aren&#x27;t computers. It won&#x27;t matter how often I tell them &quot;you made X mistake on Y line, which violates Z rule&quot; because the issue is not their knowledge, it&#x27;s the inherent inability of humans to follow onerous technical rules without mistakes.</div><br/></div></div></div></div></div></div><div id="42232125" class="c"><input type="checkbox" id="c-42232125" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#42232004">prev</a><span>|</span><a href="#42232176">next</a><span>|</span><label class="collapse" for="c-42232125">[-]</label><label class="expand" for="c-42232125">[11 more]</label></div><br/><div class="children"><div class="content">One thing I cannot stand about C++ is the fractured nature of <i>everything</i>. Compilers, build tools, package management, etc... It feels like you need to be a wizard just to get a project compiling and start writing some code.</div><br/><div id="42232234" class="c"><input type="checkbox" id="c-42232234" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232125">parent</a><span>|</span><a href="#42232193">next</a><span>|</span><label class="collapse" for="c-42232234">[-]</label><label class="expand" for="c-42232234">[7 more]</label></div><br/><div class="children"><div class="content">The worst part is when you want to bring along people that are not as much of a wizard as you are. I&#x27;ve been prototyping some multiplayer, online video game with MMO-like sharding for a while now, mostly the backend and core stuff for the project and wanted to get two of my friends on the project to develop the gameplay logic which is largely done through a dynamic scripting language, but some features (that, say, I did not foresee needed yet), require source changes to expose the APIs to the scripting language, now, these guys are capable of doing these changes but the onboarding process for a single potential co-developer is such a pain, I basically have to explain to them how to download a compiler, a package manager like vcpkg (which wasn&#x27;t even that much usable for these types of things pre-versioning, and is still not working properly - i.e. trying to pin LuaJIT version to 2.0.5 for VM bytecode compatibility will attempt to build LuaJIT with cl.exe on Linux), a build system like CMake, and so on, then guide them through all the steps to get the compiler, the build system, and the libraries working, and then hope that in the end they will actually work and not force you to spend an entire day over a remote desktop software trying to get them to become productive.</div><br/><div id="42232404" class="c"><input type="checkbox" id="c-42232404" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232234">parent</a><span>|</span><a href="#42232305">next</a><span>|</span><label class="collapse" for="c-42232404">[-]</label><label class="expand" for="c-42232404">[4 more]</label></div><br/><div class="children"><div class="content">Include more of your dependencies in the repo and build them aa part of the ordinary build process. Now a package manager does not need to get involved.</div><br/><div id="42232551" class="c"><input type="checkbox" id="c-42232551" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232404">parent</a><span>|</span><a href="#42232305">next</a><span>|</span><label class="collapse" for="c-42232551">[-]</label><label class="expand" for="c-42232551">[3 more]</label></div><br/><div class="children"><div class="content">Manually copy-pasting source trees around sounds like such an outdated idea from decades ago on how to approach dependency management in a modern programming language. Not to mention that you then have to hook them up to the build system that you are using and not all of them will work out of the box with the one you are using for your project, sure, if you are using CMake and your dependency uses CMake, you can add a subproject, how do you deal with it when they&#x27;re mixed-and-matched aside from rewriting the builds for every dependency you&#x27;re pulling in; or without manually writing glue shell scripts to build them independently and put them into a directory? How do you then ensure the said shell script works across different platforms? There are way too many issues with that approach that are solved in other languages through a standardized project management tool.</div><br/><div id="42234413" class="c"><input type="checkbox" id="c-42234413" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232551">parent</a><span>|</span><a href="#42233757">next</a><span>|</span><label class="collapse" for="c-42234413">[-]</label><label class="expand" for="c-42234413">[1 more]</label></div><br/><div class="children"><div class="content">Have you taken a look at CPM ? <a href="https:&#x2F;&#x2F;github.com&#x2F;cpm-cmake&#x2F;CPM.cmake">https:&#x2F;&#x2F;github.com&#x2F;cpm-cmake&#x2F;CPM.cmake</a> . It makes CMake project management easy - no need for separate package manager tool.</div><br/></div></div><div id="42233757" class="c"><input type="checkbox" id="c-42233757" checked=""/><div class="controls bullet"><span class="by">a_t48</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232551">parent</a><span>|</span><a href="#42234413">prev</a><span>|</span><a href="#42232305">next</a><span>|</span><label class="collapse" for="c-42233757">[-]</label><label class="expand" for="c-42233757">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to actually copypaste. You can use CMake and FetchContent&#x2F;CPM. You can specify custom build commands or inline declare a project for anything small that you pull in that doesn&#x27;t use CMake (you can call add_library with a glob on the folder FetchContent pulled in, for example - I&#x27;ve done so here <a href="https:&#x2F;&#x2F;github.com&#x2F;basis-robotics&#x2F;basis&#x2F;blob&#x2F;main&#x2F;cpp&#x2F;CMakeLists.txt#L75">https:&#x2F;&#x2F;github.com&#x2F;basis-robotics&#x2F;basis&#x2F;blob&#x2F;main&#x2F;cpp&#x2F;CMakeL...</a> for a header only lib). For large external dependencies that are either very slow to compile or for some reason aren&#x27;t CMake, reach for the system package manager or similar. If you want to be really cross platform and are supporting Qt&#x2F;wxwidgets&#x2F;etc, vcpkg+CMake+clang is solid combo, if a bit slow and a bit disk space heavy with the build cache.</div><br/></div></div></div></div></div></div><div id="42232305" class="c"><input type="checkbox" id="c-42232305" checked=""/><div class="controls bullet"><span class="by">cyclopeanutopia</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232234">parent</a><span>|</span><a href="#42232404">prev</a><span>|</span><a href="#42232193">next</a><span>|</span><label class="collapse" for="c-42232305">[-]</label><label class="expand" for="c-42232305">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you just put that into a docker container?</div><br/><div id="42232554" class="c"><input type="checkbox" id="c-42232554" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232305">parent</a><span>|</span><a href="#42232193">next</a><span>|</span><label class="collapse" for="c-42232554">[-]</label><label class="expand" for="c-42232554">[1 more]</label></div><br/><div class="children"><div class="content">This is more of a workaround than a solution; see my other comment in this thread.</div><br/></div></div></div></div></div></div><div id="42232193" class="c"><input type="checkbox" id="c-42232193" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42232125">parent</a><span>|</span><a href="#42232234">prev</a><span>|</span><a href="#42232176">next</a><span>|</span><label class="collapse" for="c-42232193">[-]</label><label class="expand" for="c-42232193">[3 more]</label></div><br/><div class="children"><div class="content">you DO need to be a wizard to launch a large C++ project.<p>Yes, languages that are beginner friendly are ... friendlier. Yes, languages that stick to one or a small number of programming paradigms are friendlier. But if you want the &quot;flexible efficiency and raw power of C&quot; and &quot;something higher level than C&quot;, C++ is your baby.<p>Maybe it would be better if we all used Java, Rust, and Go, but C++ sings its siren von Neumann song to the wizards, and there will always be wizard musicologists who steer their projects toward those rocks and, when they have just enough wax in their ears, they sail right past the rocks and come out the other side of the straits leading the rest of the fleet.<p>You can choose to follow them or not, for there&#x27;s no shame in coming in 4th.</div><br/><div id="42234435" class="c"><input type="checkbox" id="c-42234435" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232193">parent</a><span>|</span><a href="#42234382">next</a><span>|</span><label class="collapse" for="c-42234435">[-]</label><label class="expand" for="c-42234435">[1 more]</label></div><br/><div class="children"><div class="content">Even the wizards are moving to Rust&#x2F;Zig since C++ stdlib performance is becoming terrible thanks to the ABI-frozen till heat-death of the universe decision. Even wizards don&#x27;t want to build a stdlib of their own from scratch.<p>Feel the committee was smoking weed that day in la-la land. You can ignore all the safety stuff from Sean Baxter, but saying no to performance on the altar of permanent, un-specified ABI backward compatibility - when such was never mentioned as a design goal of C++ -  means its &quot;Goodbye C++&quot; for a long, long list of orgs and &quot;wizards&quot;. The ABI was NEVER specified formally by the C++ standard - so why bother sacrificing the world for its immortal existence ?<p>C++ is NO longer the choice of language for greenfield native projects and the committee takes the full blame.</div><br/></div></div><div id="42234382" class="c"><input type="checkbox" id="c-42234382" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42232125">root</a><span>|</span><a href="#42232193">parent</a><span>|</span><a href="#42234435">prev</a><span>|</span><a href="#42232176">next</a><span>|</span><label class="collapse" for="c-42234382">[-]</label><label class="expand" for="c-42234382">[1 more]</label></div><br/><div class="children"><div class="content">So much for the theory, then there is the hard reality how standard library is implemented, the variantions across implementations, and how the ongoing ABI drama is preventing any performance improvements to it.</div><br/></div></div></div></div></div></div><div id="42232176" class="c"><input type="checkbox" id="c-42232176" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42232125">prev</a><span>|</span><a href="#42231986">next</a><span>|</span><label class="collapse" for="c-42232176">[-]</label><label class="expand" for="c-42232176">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Nimble, modern, highly capable tech corporations that understand that their code is an asset. (This isn’t strictly big tech. Any sane greenfield C++ startup will also fall into this category.)<p>Oh I see, this is a fantasy.</div><br/><div id="42234328" class="c"><input type="checkbox" id="c-42234328" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#42232176">parent</a><span>|</span><a href="#42231986">next</a><span>|</span><label class="collapse" for="c-42234328">[-]</label><label class="expand" for="c-42234328">[1 more]</label></div><br/><div class="children"><div class="content">The Rust people pursue &quot;solidarity&quot; as a virtue. They don&#x27;t understand that factions is a way of life, so any sufficiently impactful technology will be &quot;fractured&quot; to some extent. This is a good thing. Unitarity, solidarity, homogenous philosophies—are not, but they would have to learn it the hard way like everybody else.</div><br/></div></div></div></div><div id="42231986" class="c"><input type="checkbox" id="c-42231986" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42232176">prev</a><span>|</span><a href="#42231991">next</a><span>|</span><label class="collapse" for="c-42231986">[-]</label><label class="expand" for="c-42231986">[3 more]</label></div><br/><div class="children"><div class="content">Python similarly has 2-3 factions in my experience: teams doing engineering in Python and using all the modern tooling, linting, packaging, types, testing, etc; teams doing data science and using modern but different tooling (i.e. Anaconda); and teams that don&#x27;t get onboard in any of the language health initiatives and are on unsupported language versions with no packaging, tooling, linting, etc.<p>Javascript&#x2F;Node&#x2F;Typescript has even more identifiable factions.<p>I think developing factions around these things is unfortunately normal as languages grow up and get used in different ways. Rust has arguably tried to stay away from this, but the flip side is a higher learning curve because it just doesn&#x27;t let certain factions exist. Go is probably the best attempt to prevent factions and gain wide adoption, but even then the generics crowd forced the language to adopt them.</div><br/><div id="42232787" class="c"><input type="checkbox" id="c-42232787" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#42231986">parent</a><span>|</span><a href="#42231991">next</a><span>|</span><label class="collapse" for="c-42232787">[-]</label><label class="expand" for="c-42232787">[2 more]</label></div><br/><div class="children"><div class="content">When you put it this way, personas might be a better term than factions.</div><br/><div id="42233009" class="c"><input type="checkbox" id="c-42233009" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42231986">root</a><span>|</span><a href="#42232787">parent</a><span>|</span><a href="#42231991">next</a><span>|</span><label class="collapse" for="c-42233009">[-]</label><label class="expand" for="c-42233009">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think that&#x27;s a much friendlier term. I do think language ecosystems have a hard time, because on the one hand they should be aiming to be as useful as possible, which means doing <i>more</i>, on the other hand they have to acknowledge that any given user will likely not use all the language and that the rest of it may hinder them, which means doing <i>less</i>.<p>C++ does a lot, but has a big disengaged crowd, for many reasons, and that crowd will suffer from the push forward. Python and Node are similar.</div><br/></div></div></div></div></div></div><div id="42231991" class="c"><input type="checkbox" id="c-42231991" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42231986">prev</a><span>|</span><a href="#42231844">next</a><span>|</span><label class="collapse" for="c-42231991">[-]</label><label class="expand" for="c-42231991">[1 more]</label></div><br/><div class="children"><div class="content">Profiles aren&#x27;t a mess because they&#x27;re intended for legacy codebases instead of big tech monorepos. They&#x27;re a mess because they&#x27;re not a serious effort. There&#x27;s no actual vision of what problems they&#x27;re trying to solve or what the use cases are, or even what kind of guarantee profiles are going to make.</div><br/></div></div><div id="42231844" class="c"><input type="checkbox" id="c-42231844" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42231991">prev</a><span>|</span><a href="#42233528">next</a><span>|</span><label class="collapse" for="c-42231844">[-]</label><label class="expand" for="c-42231844">[24 more]</label></div><br/><div class="children"><div class="content">Languages should not have a package management system. They all have a all the world is my language blindspot and fail hard when you have anything else. Sometimes you can build plugins in a different language but they still assume the one true language is all you want.<p>package management belongs to the os - or at least something else.<p>don&#x27;t get me wrong, package management is a real problem and needs to be solved. I&#x27;m arguing against a language package manager we need a language agnostic package manager.</div><br/><div id="42231937" class="c"><input type="checkbox" id="c-42231937" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42231933">next</a><span>|</span><label class="collapse" for="c-42231937">[-]</label><label class="expand" for="c-42231937">[4 more]</label></div><br/><div class="children"><div class="content">I think C++ is a living proof that not having a standard tooling around the language makes the language a complete pain in the ass to use, with any other language that does standard package managing&#x2F;tooling out of the box, I can just pin the versions, commit a file to the repository, and on any computer that I&#x27;m working on I just issue a single command and everything is handled for me; meanwhile one of the C++ projects I&#x27;ve been working on, it turned out that I cannot build it on my server because one of the libraries I&#x27;m using only worked with clang17 which my desktop OS provides but the Debian I&#x27;m using on my server is shipping with clang16, and the library was not compatible with the earlier version of some C++ implementation, meanwhile Arch on my desktop updated to clang18, which also broke the library in some fashion, so now I&#x27;m sitting here with two systems, one where I want to deploy my software, and one where I want to develop the software, both of which are completely defunct and unable to build my project anymore; now I have to figure out how to build the specific version of clang on both systems and ensure I override a bunch of environment variables when configuring the builds on both of these systems, and then do the same on every new computer I&#x27;m developing&#x2F;deploying on - with a proper tool I could just tell the project file to &quot;use this compiler with this version with this standard&quot; and things would just work. Some people will tell you &quot;yeah bro just use docker with this and that and you will have a reproducible build system everywhere&quot;, but the thing is - I do not want to learn a completely unrelated tool and spend hours writing some scripts just to be able to continue working on my project when in any other programming language (like Go, Rust, JS), I can just install the runtime, clone the repo, run a command, and everything is handled for me seamlessly like it should be in 2024.</div><br/><div id="42232118" class="c"><input type="checkbox" id="c-42232118" checked=""/><div class="controls bullet"><span class="by">beeflet</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42231937">parent</a><span>|</span><a href="#42233361">next</a><span>|</span><label class="collapse" for="c-42232118">[-]</label><label class="expand" for="c-42232118">[2 more]</label></div><br/><div class="children"><div class="content">The problem for me is a &quot;political&quot; one, not a matter of convenience: When I choose a linux distro I implicitly trust the distro maintainers to not backdoor the liveCD, so I might as well trust them to maintain packages transparently. If something happens upstream, we expect the distro maintainers to patch out undesirable behavior, integrate changes into the system as a whole or warn us of changes. Most distros are the same in functionality: the choice of a certain distro is mostly a choice of which political institution (such as a business or non-profit) that we trust to maintain the interoperability of the OS.<p>Languages need to be more agnostic than a package manager requires because I should not have to rope another organization into my trust model.<p>Cargo already goes too far in encouraging a single repository (crates.io) for everything through its default behavior. Who maintains crates.io? Where is the transparency? This is the most important information the user should know when deciding to use crates.io, which is whether or not they can trust the maintainers not to backdoor code, and it is rarely discussed or even mentioned!<p>The default cargo crate (template?) encourages people to use permissive licensing for their code. So that is an example where you are already making implicit political decisions on behalf of the ecosystem and developers. That is alarming and should not be for the language maintainers to decide at all.<p>In C&#x2F;C++ you have a separation of the standard from the implementation. This is really what makes C&#x2F;C++ code long-lived, because you do not have to worry about the standard being hijacked by a single group. You have a standard and multiple competing implementations, like the WWW. I cannot encourage the use of Rust while there is only a single widely-accepted implementation.</div><br/><div id="42232365" class="c"><input type="checkbox" id="c-42232365" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42232118">parent</a><span>|</span><a href="#42233361">next</a><span>|</span><label class="collapse" for="c-42232365">[-]</label><label class="expand" for="c-42232365">[1 more]</label></div><br/><div class="children"><div class="content">The problem with that is that no Linux distro maintainer will ever put effort into maintaining every version of every library and compiler perpetually for a specific, seemingly random, programming language (or at least, reasonably, within few major versions including all minor releases in between), but with a tool that versions dependencies and allows for, say, git-based upstream with tag-versioned releases, you can expect to pick any specific version and for things to just work; managing library code for a specific programming language, be it any language, does not seem like the responsibility of an operating system, if anything, the package manager from your OS should be able to just supply the tool to manage the said language (like you currently can with npm, cargo or go); that also does not touch the topic of making things work across different platforms, sure, you maybe found a way to solve this issue in your imaginary Linux distro, how do you solve the problem for a co-developer that uses Windows, or macOS?<p>Additionally, you do not have to necessarily enforce these things on the language level, the standard and the tooling could live as two independent projects coming from the same entity. You could still use the compiler and the libraries from your OS, and build the code like that, or you could just reach out to an optional standardized tool that serves as a glue for all the external tools in a standardized way.<p>Yes, there are a lot of valid concerns with this approach as well, but personally for me, as a frustrated C++ developer, who is most likely going to still use the language for a decade to come, I feel like all the other languages I had mentioned in my previous post had addressed what is my biggest point of frustration with C++, so it&#x27;s definitely an issue that could be solved. Many tried to do it independently, but due to personal differences, no funding, and different ideas of what should be the scope of such tooling, we ended up with a very fragmented ecosystem of tools, none of which have yet to date been able to fully address an issue that other languages solved.</div><br/></div></div></div></div><div id="42233361" class="c"><input type="checkbox" id="c-42233361" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42231937">parent</a><span>|</span><a href="#42232118">prev</a><span>|</span><a href="#42231933">next</a><span>|</span><label class="collapse" for="c-42233361">[-]</label><label class="expand" for="c-42233361">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend using upstream apt llvm repos if you are using Debian or debian-derivatives like Ubuntu, to make sure you have the same compiler everywhere.</div><br/></div></div></div></div><div id="42231933" class="c"><input type="checkbox" id="c-42231933" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42231937">prev</a><span>|</span><a href="#42232531">next</a><span>|</span><label class="collapse" for="c-42231933">[-]</label><label class="expand" for="c-42231933">[2 more]</label></div><br/><div class="children"><div class="content">Specifications for package interchange are absolutely essential, which is distinct from language endorsed package managers.<p>Python doesn&#x27;t have a language package manager, you&#x27;re free to use pip or poetry or uv or whatever, but it does have PEP 517&#x2F;518, which allow all Python package managers to interact with a common package ecosystem which encompasses polyglot codebases.<p>C++ is only starting to address this problem with efforts like CPS. We have a plethora of packaging formats, Debian, pkg-config, conan, CMake configs, but they cannot speak fluently to one another so the package ecosystem is fractured, presenting an immense obstacle to any integration effort.</div><br/></div></div><div id="42232531" class="c"><input type="checkbox" id="c-42232531" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42231933">prev</a><span>|</span><a href="#42231929">next</a><span>|</span><label class="collapse" for="c-42232531">[-]</label><label class="expand" for="c-42232531">[1 more]</label></div><br/><div class="children"><div class="content">But like…why?<p>Let’s say we make a “thing” which contains packages for all participating languages.<p>98% of the time, aren’t users just going to go “filter down to my language” and just continue what they’re doing, except with a somewhat worse overall experience, depending on whatever the “lowest common denominator” API + semantics we use for this shared package management solution.<p>Multi-language build systems already exist, which happily serve the needs to those projects which find themselves needing cross-language (+distributed) builds. Could there be some easier versions of these? Sure, but I don’t feel like “throw everyone in the same big box” is the solution here.</div><br/></div></div><div id="42231929" class="c"><input type="checkbox" id="c-42231929" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42232531">prev</a><span>|</span><a href="#42231961">next</a><span>|</span><label class="collapse" for="c-42231929">[-]</label><label class="expand" for="c-42231929">[2 more]</label></div><br/><div class="children"><div class="content">Interesting point, and I&#x27;m included to agree with your main point. I don&#x27;t think the OS level is preferable, however:<p>Point 1: I do not want my program to only run on only one OS, or to require custom code to make it multi-platform.<p>Point 2: What if there&#x27;s no OS?</div><br/><div id="42232157" class="c"><input type="checkbox" id="c-42232157" checked=""/><div class="controls bullet"><span class="by">beeflet</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42231929">parent</a><span>|</span><a href="#42231961">next</a><span>|</span><label class="collapse" for="c-42232157">[-]</label><label class="expand" for="c-42232157">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Point 1: I do not want my program to only run on only one OS, or to require custom code to make it multi-platform.<p>To run on only one OS at build time? I usually just set up cross-compilers from linux if I am making cross-platform C&#x2F;C++ code.<p>&gt;Point 2: What if there&#x27;s no OS?<p>You can use a system like bitbake I think.</div><br/></div></div></div></div><div id="42231961" class="c"><input type="checkbox" id="c-42231961" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42231929">prev</a><span>|</span><a href="#42231881">next</a><span>|</span><label class="collapse" for="c-42231961">[-]</label><label class="expand" for="c-42231961">[7 more]</label></div><br/><div class="children"><div class="content">&gt; package management belongs to the os<p>It clearly doesn&#x27;t except if you&#x27;re a fan of dll hell and outdated packages.</div><br/><div id="42232172" class="c"><input type="checkbox" id="c-42232172" checked=""/><div class="controls bullet"><span class="by">beeflet</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42231961">parent</a><span>|</span><a href="#42231881">next</a><span>|</span><label class="collapse" for="c-42232172">[-]</label><label class="expand" for="c-42232172">[6 more]</label></div><br/><div class="children"><div class="content">the solution to DLL hell is to patch the applications to all use the same version of the library.</div><br/><div id="42232447" class="c"><input type="checkbox" id="c-42232447" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42232172">parent</a><span>|</span><a href="#42231881">next</a><span>|</span><label class="collapse" for="c-42232447">[-]</label><label class="expand" for="c-42232447">[5 more]</label></div><br/><div class="children"><div class="content">Oh but of course!<p>The solution to…a problem created directly by a specific approach is to…do even more work ourselves to try and untangle ourselves? And just cross our fingers and just _hope_ that every app&#x2F;library is fully amenable to being patched this way?<p>Alternatively, we could realise that this isn’t really feasible at the scale that the ecosystem operates at now, and that instead of taking an approach that requires us to “do extra work to untangle ourselves” we should try and…not have that problem in the first place.</div><br/><div id="42232518" class="c"><input type="checkbox" id="c-42232518" checked=""/><div class="controls bullet"><span class="by">beeflet</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42232447">parent</a><span>|</span><a href="#42231881">next</a><span>|</span><label class="collapse" for="c-42232518">[-]</label><label class="expand" for="c-42232518">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s unreasonable to have a system where every program uses the same version of a library.<p>&gt;And just cross our fingers and just _hope_ that every app&#x2F;library is fully amenable to being patched this way?<p>It requires some foresight in designing the application, and whether or not you even choose to use that application in the first place. We should strive to decrease the complexity of the system as a whole. The fact that packages are using different versions of the same library in the first place is a canary and the system should disincentivize that use case to some extent. Using static libraries or a chroot or a sandbox for everything is sweeping the problems under the carpet.<p>&gt;taking an approach that requires us to “do extra work to untangle ourselves” we should try and…not have that problem in the first place.<p>I would prefer a system that allows you to link every application to the same library as a default, but also allows for some per-application override, perhaps by using symlinks. That would cover the majority of use cases. But I do not think that dynamic linking is generally in vain.<p>In my own projects, I try to rely on static linking as much as possible, so I understand your perspective as a developer. But as a user I do not want programs to have their own dependencies separate from the rest of the system.</div><br/><div id="42233373" class="c"><input type="checkbox" id="c-42233373" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42232518">parent</a><span>|</span><a href="#42232570">next</a><span>|</span><label class="collapse" for="c-42233373">[-]</label><label class="expand" for="c-42233373">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think it&#x27;s unreasonable to have a system where every program uses the same version of a library.<p>I really think it is. Even at the scale of a single app it may sometimes make sense to have multiple versions of a same library, if for instance it implements a given algorithm in two different ways and both ways have useful properties</div><br/><div id="42233752" class="c"><input type="checkbox" id="c-42233752" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42233373">parent</a><span>|</span><a href="#42232570">next</a><span>|</span><label class="collapse" for="c-42233752">[-]</label><label class="expand" for="c-42233752">[1 more]</label></div><br/><div class="children"><div class="content">Then shouldn&#x27;t these APIs be exposed as different libraries?</div><br/></div></div></div></div><div id="42232570" class="c"><input type="checkbox" id="c-42232570" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42232518">parent</a><span>|</span><a href="#42233373">prev</a><span>|</span><a href="#42231881">next</a><span>|</span><label class="collapse" for="c-42232570">[-]</label><label class="expand" for="c-42232570">[1 more]</label></div><br/><div class="children"><div class="content">Could a more streamlined “conception” of something like Gentoo fix this?<p>Applications ship their lock files + version constraints. Gets merged into a user&#x2F;os level set of packages. You update one package, OS can figure out what it has to rebuild and goes off and does that.<p>Still shit-out-of-luck for anything proprietary, and it’s still super possible for users to end up looking at compile failures, but technically fits the bill?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42231881" class="c"><input type="checkbox" id="c-42231881" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42231961">prev</a><span>|</span><a href="#42231918">next</a><span>|</span><label class="collapse" for="c-42231881">[-]</label><label class="expand" for="c-42231881">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. At least, languages should not require its own package management system to be used. There should be a way to invoke the compiler or interpreter without involving that language&#x27;s own package management system, so that something else (like Bazel) can build on top. Fortunately, most common languages are all like that. You can invoke rustc without cargo. You can use python without pip. You can use javac without maven.</div><br/></div></div><div id="42231918" class="c"><input type="checkbox" id="c-42231918" checked=""/><div class="controls bullet"><span class="by">rileymat2</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42231881">prev</a><span>|</span><a href="#42232145">next</a><span>|</span><label class="collapse" for="c-42231918">[-]</label><label class="expand" for="c-42231918">[1 more]</label></div><br/><div class="children"><div class="content">I think the term &quot;package management system&quot; is a bit over broad a term to talk about.<p>If we are talking about global shared dependencies, sure it may belong in the OS.<p>If we are talking about directly shared code, it may as well belong in the language layer.<p>If we are talking about combining independent opaque libraries, then it might belong in a different &quot;pseudo os&quot; level like NPM.</div><br/></div></div><div id="42231969" class="c"><input type="checkbox" id="c-42231969" checked=""/><div class="controls bullet"><span class="by">RcouF1uZ4gsC</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42232145">prev</a><span>|</span><a href="#42232014">next</a><span>|</span><label class="collapse" for="c-42231969">[-]</label><label class="expand" for="c-42231969">[2 more]</label></div><br/><div class="children"><div class="content">Disagree completely. OS package managers are one of the biggest sources of problems.<p>Basically, once you have an OS level package manager, you have issues of versioning and ABI. You have people writing to the lowest common denominator - see for example being limited to the compiler and libraries available on an old Red Hat version. This need to maintain ABI compatibility has been one of the hugest issues with evolving C++.<p>The OS package manager ends up being a Procrustean bed forcing everything into its mold whether or not it actually fits.<p>Also, this doesn&#x27;t even have the issue of multiple operating systems and even distros which have different package managers.<p>Rust and Go having their own package managers has helped greatly with real world usage and evolution.</div><br/><div id="42232251" class="c"><input type="checkbox" id="c-42232251" checked=""/><div class="controls bullet"><span class="by">beeflet</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42231969">parent</a><span>|</span><a href="#42232014">next</a><span>|</span><label class="collapse" for="c-42232251">[-]</label><label class="expand" for="c-42232251">[1 more]</label></div><br/><div class="children"><div class="content">This is a weird opinion, but I think that the OS package manager&#x27;s complexity is largely owing to the unix directory structure which it just dumps all binaries in &#x2F;bin, all configuration files in &#x2F;etc, all libraries in &#x2F;lib. It comes from a time where everything on the OS was developed by the same group of people.<p>By dumping all the same file types in massive top-level directories, you need a separate program (the package manager) to keep track of which files belong to which packages and dealing with their versions and ABI and stuff. Each package represents code developed by a specific group with a certain model of the system&#x27;s interoperability.<p>GoboLinux has an interesting play on the problem by changing the directory structure so that the filesystem does most of the heavy lifting.</div><br/></div></div></div></div><div id="42232014" class="c"><input type="checkbox" id="c-42232014" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#42231844">parent</a><span>|</span><a href="#42231969">prev</a><span>|</span><a href="#42233528">next</a><span>|</span><label class="collapse" for="c-42232014">[-]</label><label class="expand" for="c-42232014">[2 more]</label></div><br/><div class="children"><div class="content">Honestly I don’t know why more languages don’t just adopt e.g. npm, maven or NuGet. They’re largely language independent at the binary level anyway.</div><br/><div id="42232192" class="c"><input type="checkbox" id="c-42232192" checked=""/><div class="controls bullet"><span class="by">beeflet</span><span>|</span><a href="#42231844">root</a><span>|</span><a href="#42232014">parent</a><span>|</span><a href="#42233528">next</a><span>|</span><label class="collapse" for="c-42232192">[-]</label><label class="expand" for="c-42232192">[1 more]</label></div><br/><div class="children"><div class="content">npm, maven, and NuGet have caused me far more problems in trying to reproduce builds than the OS package manager ever will.</div><br/></div></div></div></div></div></div><div id="42233528" class="c"><input type="checkbox" id="c-42233528" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#42231844">prev</a><span>|</span><a href="#42231758">next</a><span>|</span><label class="collapse" for="c-42233528">[-]</label><label class="expand" for="c-42233528">[2 more]</label></div><br/><div class="children"><div class="content">The author doesn’t appear to consider the use of binary-only (typically commercial licensed) libraries.  There’s still a need for an ABI and “modern tooling” isn’t a magic wand.</div><br/><div id="42233636" class="c"><input type="checkbox" id="c-42233636" checked=""/><div class="controls bullet"><span class="by">kkert</span><span>|</span><a href="#42233528">parent</a><span>|</span><a href="#42231758">next</a><span>|</span><label class="collapse" for="c-42233636">[-]</label><label class="expand" for="c-42233636">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d guess that majority of such binary-only libraries use C ABI interfaces. The entire Windows ecosystem of COM modules works on top of C ABI&#x27;s.</div><br/></div></div></div></div><div id="42231758" class="c"><input type="checkbox" id="c-42231758" checked=""/><div class="controls bullet"><span class="by">minetest2048</span><span>|</span><a href="#42233528">prev</a><span>|</span><a href="#42231490">next</a><span>|</span><label class="collapse" for="c-42231758">[-]</label><label class="expand" for="c-42231758">[2 more]</label></div><br/><div class="children"><div class="content">Any mirrors&#x2F;archives? DNS not resolving for me<p>EDIT: found one on wayback: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20241124225457&#x2F;https:&#x2F;&#x2F;herecomesthemoon.net&#x2F;2024&#x2F;11&#x2F;two-factions-of-cpp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20241124225457&#x2F;https:&#x2F;&#x2F;herecomes...</a></div><br/><div id="42231826" class="c"><input type="checkbox" id="c-42231826" checked=""/><div class="controls bullet"><span class="by">cyclopeanutopia</span><span>|</span><a href="#42231758">parent</a><span>|</span><a href="#42231490">next</a><span>|</span><label class="collapse" for="c-42231826">[-]</label><label class="expand" for="c-42231826">[1 more]</label></div><br/><div class="children"><div class="content">Weird, it works for me.</div><br/></div></div></div></div><div id="42232099" class="c"><input type="checkbox" id="c-42232099" checked=""/><div class="controls bullet"><span class="by">chris_wot</span><span>|</span><a href="#42231490">prev</a><span>|</span><a href="#42232236">next</a><span>|</span><label class="collapse" for="c-42232099">[-]</label><label class="expand" for="c-42232099">[2 more]</label></div><br/><div class="children"><div class="content">I think he has this about right. The project I contribute to (and no, I&#x27;m not a massive contributor) is LibreOffice and it is a C++ codebase. It has a decent build system that is easy for anyone to run out of the box. It uses modern C++17+ code, and though it has a lot of legacy code, it is being constantly modified by people like Noel Grandin via clang plugins (along with a lot of manual effort).<p>This code was originally developed in the late 1980s.<p>A good packaging tool would have helped <i>a lot</i>.</div><br/><div id="42233744" class="c"><input type="checkbox" id="c-42233744" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42232099">parent</a><span>|</span><a href="#42232236">next</a><span>|</span><label class="collapse" for="c-42233744">[-]</label><label class="expand" for="c-42233744">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m stoked to hear they&#x27;re on C++17 now.<p>When I contributed to LibreOffice (GSoC 2012) they were still on C++03 !</div><br/></div></div></div></div></div></div></div></div></div></body></html>