<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703322061317" as="style"/><link rel="stylesheet" href="styles.css?v=1703322061317"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.nand2tetris.org">From Nand to Tetris (2017)</a> <span class="domain">(<a href="https://www.nand2tetris.org">www.nand2tetris.org</a>)</span></div><div class="subtext"><span>mikpanko</span> | <span>144 comments</span></div><br/><div><div id="38735823" class="c"><input type="checkbox" id="c-38735823" checked=""/><div class="controls bullet"><span class="by">meter</span><span>|</span><a href="#38736149">next</a><span>|</span><label class="collapse" for="c-38735823">[-]</label><label class="expand" for="c-38735823">[35 more]</label></div><br/><div class="children"><div class="content">I first attempted this 7 years ago, after I graduated college. I got through the first 2 chapters. It was extremely rewarding. But regrettably, I abandoned it for other side projects.<p>I picked it up again 3 months ago, and it’s been a blast. I’m on chapter 8, having completed the logic gates, ALU, CPU, assembler, and half of the virtual machine.<p>Every chapter is overwhelming — in a good way. I keep thinking to myself, “how the hell is this going to work?” And when it does, it’s so satisfying.<p>As a side project, purely for educational purposes, it’s the most rewarding thing I’ve done. I’ve learned so much. It’s a damn good project. And I’m damn proud of myself for sticking with it.<p>Highly recommended.</div><br/><div id="38737466" class="c"><input type="checkbox" id="c-38737466" checked=""/><div class="controls bullet"><span class="by">wintogreen74</span><span>|</span><a href="#38735823">parent</a><span>|</span><a href="#38740062">next</a><span>|</span><label class="collapse" for="c-38737466">[-]</label><label class="expand" for="c-38737466">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done this too, and it also took me multiple (3!) tries to get through the entire thing. I interleaved it last fall&#x2F;winter with Ben Eater&#x27;s amazing series on building an 8-bit computer on breadboards. I bought everything over several months from China, then built the subsystems as the parts arrived over the winter. You should do that next! Aside from being (maybe even more) rewarding, it looks damn impressive to see all the flashing LEDs <i>and</i> understand what&#x27;s happening.</div><br/><div id="38739269" class="c"><input type="checkbox" id="c-38739269" checked=""/><div class="controls bullet"><span class="by">sunday_serif</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38737466">parent</a><span>|</span><a href="#38739010">next</a><span>|</span><label class="collapse" for="c-38739269">[-]</label><label class="expand" for="c-38739269">[4 more]</label></div><br/><div class="children"><div class="content">Yes! Ben eater’s content accompanies nand to Tetris so well.<p>I did the 6502 project in which you assemble a computer system on bread boards (wiring together the clock, cpu, ram, etc).<p>It helped solidify many of the concepts from nand2tetris. For some reason doing it all physically with real chips and wires made it all a bit more memorable.<p>I’d love to try his other bread board project in which you assemble all the inner workings of a cpu on bread boards as well — I think this is what you were referring to.</div><br/><div id="38739330" class="c"><input type="checkbox" id="c-38739330" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38739269">parent</a><span>|</span><a href="#38739010">next</a><span>|</span><label class="collapse" for="c-38739330">[-]</label><label class="expand" for="c-38739330">[3 more]</label></div><br/><div class="children"><div class="content">&gt;It helped solidify many of the concepts from nand2tetris. For some reason doing it all physically with real chips and wires made it all a bit more memorable.<p>Hang on a second, does nand2tetris not involve real chips and wires?</div><br/><div id="38739414" class="c"><input type="checkbox" id="c-38739414" checked=""/><div class="controls bullet"><span class="by">sircastor</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38739330">parent</a><span>|</span><a href="#38739010">next</a><span>|</span><label class="collapse" for="c-38739414">[-]</label><label class="expand" for="c-38739414">[2 more]</label></div><br/><div class="children"><div class="content">No, nand2tetris is done in virtual environments.<p>This is largely about accessibility. If it’s tied to hardware, fewer people can do it. Additionally, real hardware means there’s additional opportunity for error due to faults in the hardware or environmental variables.<p>That said, Nand2Tetris could, in theory, be done with a bunch of 74xx NAND chips on a breadboard.</div><br/><div id="38741147" class="c"><input type="checkbox" id="c-38741147" checked=""/><div class="controls bullet"><span class="by">apricot</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38739414">parent</a><span>|</span><a href="#38739010">next</a><span>|</span><label class="collapse" for="c-38741147">[-]</label><label class="expand" for="c-38741147">[1 more]</label></div><br/><div class="children"><div class="content">The Nand2Tetris computer is a bad fit for 74xx chips and breadboards. It&#x27;s 16 bit, for one thing, which implies a lot of chips and a lot of wires on a lot of breadboards, and the usual current problems that come with that. Better have a good source and an oscilloscope nearby. Also, the virtual design sweeps a lot of important timing issues under the rug, so you need some EE chops to translate it correctly to real hardware.<p>I know of a few people who managed to get a working Nand2Tetris computer on breadboards, but it took a lot more time and money than they thought it would.<p>On FPGA, though, it works nicely.</div><br/></div></div></div></div></div></div></div></div><div id="38739010" class="c"><input type="checkbox" id="c-38739010" checked=""/><div class="controls bullet"><span class="by">meter</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38737466">parent</a><span>|</span><a href="#38739269">prev</a><span>|</span><a href="#38740062">next</a><span>|</span><label class="collapse" for="c-38739010">[-]</label><label class="expand" for="c-38739010">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the recommendation. I&#x27;ll definitely look into it!</div><br/></div></div></div></div><div id="38740062" class="c"><input type="checkbox" id="c-38740062" checked=""/><div class="controls bullet"><span class="by">shostack</span><span>|</span><a href="#38735823">parent</a><span>|</span><a href="#38737466">prev</a><span>|</span><a href="#38736658">next</a><span>|</span><label class="collapse" for="c-38740062">[-]</label><label class="expand" for="c-38740062">[2 more]</label></div><br/><div class="children"><div class="content">This and books like Code give me such deep respect for the people who originally figured these things out.</div><br/></div></div><div id="38736658" class="c"><input type="checkbox" id="c-38736658" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#38735823">parent</a><span>|</span><a href="#38740062">prev</a><span>|</span><a href="#38736034">next</a><span>|</span><label class="collapse" for="c-38736658">[-]</label><label class="expand" for="c-38736658">[25 more]</label></div><br/><div class="children"><div class="content">How did you learn the prerequisite solid state physics knowledge in order to fully understand the background behind the first two chapters?<p>e.g. The actual mechanism by which an integrated circuit transforms input into useful output. I&#x27;ve never been able to find a solid explanation on how even the simplest real world integrated circuit, such as a TI SN7400, actually does that.</div><br/><div id="38736907" class="c"><input type="checkbox" id="c-38736907" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736658">parent</a><span>|</span><a href="#38736737">next</a><span>|</span><label class="collapse" for="c-38736907">[-]</label><label class="expand" for="c-38736907">[10 more]</label></div><br/><div class="children"><div class="content">You&#x27;re making a category error, I think.  This books&#x2F;course doesn&#x27;t cover physics.  It doesn&#x27;t even cover signal stuff, like stuff about how fast the voltage levels stabilize, or even voltages at all.<p>It&#x27;s not &quot;silicon wafer to Tetris&quot; or &quot;pile of protons and neutrons to Tetris&quot; or &quot;transistors to Tetris&quot;.  You start with nand gates (and later also you get flipflops for free).<p>This course would work equally well on nand gates made of carved wooden gears, or nand gates made with fluidic logic, or nand gates made by encoding the whole thing into O-gauge hobby railroads.<p>If that&#x27;s the level of explanation you seek, this book is incredible.</div><br/><div id="38738351" class="c"><input type="checkbox" id="c-38738351" checked=""/><div class="controls bullet"><span class="by">_fizz_buzz_</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736907">parent</a><span>|</span><a href="#38737464">next</a><span>|</span><label class="collapse" for="c-38738351">[-]</label><label class="expand" for="c-38738351">[2 more]</label></div><br/><div class="children"><div class="content">A “silicon to nand gate” would be a sweet complimentary course. However, probably more difficult to make hands on.</div><br/><div id="38742626" class="c"><input type="checkbox" id="c-38742626" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38738351">parent</a><span>|</span><a href="#38737464">next</a><span>|</span><label class="collapse" for="c-38742626">[-]</label><label class="expand" for="c-38742626">[1 more]</label></div><br/><div class="children"><div class="content">Followed by a prequel &quot;Sand to ingot&quot;</div><br/></div></div></div></div><div id="38737464" class="c"><input type="checkbox" id="c-38737464" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736907">parent</a><span>|</span><a href="#38738351">prev</a><span>|</span><a href="#38738329">next</a><span>|</span><label class="collapse" for="c-38737464">[-]</label><label class="expand" for="c-38737464">[5 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not &quot;silicon wafer to Tetris&quot;...<p>That is a good point, I had just assumed that information was available somewhere online, but it doesn&#x27;t seem likely.</div><br/><div id="38738168" class="c"><input type="checkbox" id="c-38738168" checked=""/><div class="controls bullet"><span class="by">alted</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38737464">parent</a><span>|</span><a href="#38738125">next</a><span>|</span><label class="collapse" for="c-38738168">[-]</label><label class="expand" for="c-38738168">[1 more]</label></div><br/><div class="children"><div class="content">Lower-level teaching resources definitely exist! Here are my favorites:<p>- The Zero to ASIC course (and Tiny Tapeout) [1] explains transistor circuits and teaches you an open source software stack---and you get a chip physically manufactured! You could make the Nand to Tetris computer in actual silicon (if you can get enough transistors).<p>- To learn how things are manufactured on silicon wafers, get textbooks on microfabrication. A decent starting point is [2]. There&#x27;s also a good video series [3] for a quick overview.<p>- To understand how a single transistor or diode works, get textbooks on &quot;semiconductor devices&quot;. A good starting point is the free online [4].<p>[1] <a href="https:&#x2F;&#x2F;www.zerotoasiccourse.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.zerotoasiccourse.com&#x2F;</a> <a href="https:&#x2F;&#x2F;tinytapeout.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tinytapeout.com&#x2F;</a><p>[2] &quot;Introduction to Microelectronic Fabrication&quot; by Jaeger<p>[3] <a href="https:&#x2F;&#x2F;siliconrun.com&#x2F;our-films&#x2F;silicon-run-1&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;siliconrun.com&#x2F;our-films&#x2F;silicon-run-1&#x2F;</a><p>[4] &quot;Modern Semiconductor Devices for Integrated Circuits&quot; by Chenming Hu, <a href="https:&#x2F;&#x2F;www.chu.berkeley.edu&#x2F;modern-semiconductor-devices-for-integrated-circuits-chenming-calvin-hu-2010&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.chu.berkeley.edu&#x2F;modern-semiconductor-devices-fo...</a></div><br/></div></div><div id="38738125" class="c"><input type="checkbox" id="c-38738125" checked=""/><div class="controls bullet"><span class="by">svnt</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38737464">parent</a><span>|</span><a href="#38738168">prev</a><span>|</span><a href="#38737951">next</a><span>|</span><label class="collapse" for="c-38738125">[-]</label><label class="expand" for="c-38738125">[1 more]</label></div><br/><div class="children"><div class="content">Something like this will at least get you conversant. You only need the first few chapters, and can skip BJTs.<p><a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;microelectronicc00jaeg&#x2F;page&#x2F;n11&#x2F;mode&#x2F;1up" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;microelectronicc00jaeg&#x2F;page&#x2F;n11&#x2F;...</a></div><br/></div></div><div id="38737951" class="c"><input type="checkbox" id="c-38737951" checked=""/><div class="controls bullet"><span class="by">amenghra</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38737464">parent</a><span>|</span><a href="#38738125">prev</a><span>|</span><a href="#38738314">next</a><span>|</span><label class="collapse" for="c-38737951">[-]</label><label class="expand" for="c-38737951">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;nandgame.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nandgame.com&#x2F;</a> has a cmos level towards the end. It doesn’t explain the transistor-level physics but does let you play with things.<p>The art of electronics book might be a good place to start if you want to learn the physical&#x2F;electrical layer.</div><br/></div></div></div></div><div id="38738375" class="c"><input type="checkbox" id="c-38738375" checked=""/><div class="controls bullet"><span class="by">SilasX</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736907">parent</a><span>|</span><a href="#38738329">prev</a><span>|</span><a href="#38736737">next</a><span>|</span><label class="collapse" for="c-38738375">[-]</label><label class="expand" for="c-38738375">[1 more]</label></div><br/><div class="children"><div class="content">I vaguely remember someone trying to go the other direction, and teach &quot;Tetris to Quake&quot; but I can&#x27;t find substantiation that course ever existed, and might have confused it with this article:<p><a href="http:&#x2F;&#x2F;archive.gamedev.net&#x2F;archive&#x2F;reference&#x2F;articles&#x2F;article892.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;archive.gamedev.net&#x2F;archive&#x2F;reference&#x2F;articles&#x2F;articl...</a><p>I&#x27;d also be interested in anything that extends the stack from where nand2tetris left off, because, while I loved it[1], it felt unsatisfying that can&#x27;t actually compile to usable binaries for the hardware -- your executable can&#x27;t usually fit in memory and it doesn&#x27;t teach you how swapping (or whatever) would get you to that point. It also doesn&#x27;t cover more common hardware&#x2F;OS issues like interrupts, or having juggle multiple running programs.<p>[1] most interesting technical project I&#x27;ve ever completed, with the possible exception of Microcorruption.com.</div><br/></div></div></div></div><div id="38736737" class="c"><input type="checkbox" id="c-38736737" checked=""/><div class="controls bullet"><span class="by">moritzwarhier</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736658">parent</a><span>|</span><a href="#38736907">prev</a><span>|</span><a href="#38738536">next</a><span>|</span><label class="collapse" for="c-38736737">[-]</label><label class="expand" for="c-38736737">[4 more]</label></div><br/><div class="children"><div class="content">I have only faint memories of my beginner&#x27;s course on this topic at university, and absolutely no knowledge.<p>Somehow I remember the word MOSFET.<p>I think the wikipedia articles about logic gates should provide all necessary cross references.<p>&quot;Fully understand&quot; is an elusive term though. How do you fully understand the solid-state physics of logic gates if you don&#x27;t fully understand all of physics, chemistry, maybe even quantum mechanics...<p>Not meaning to be dismissive though! I love to try to fully understand things and hate having to accept black box logic. But I also have to admit that I&#x27;ve given up on this approach for many things a long time ago.<p>Skimming the course summary, it sounds as if this &quot;Hardware Description Language&quot; might mark the boundary of what this course is about.<p>Makes sense, it&#x27;s not &quot;from physics to NAND&quot;, it&#x27;s &quot;from NAND to Tetris&quot; :)</div><br/><div id="38741733" class="c"><input type="checkbox" id="c-38741733" checked=""/><div class="controls bullet"><span class="by">froggit</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736737">parent</a><span>|</span><a href="#38736925">next</a><span>|</span><label class="collapse" for="c-38741733">[-]</label><label class="expand" for="c-38741733">[1 more]</label></div><br/><div class="children"><div class="content">The term &quot;hardware description language&quot; still gives me nightmares 5 years after my only experience working with them. Was working on my master&#x27;s in an interdisciplinary CS&#x2F;MIS&#x2F;CompEng program for Cybersecurity and needed an elective. &quot;Fundamentals of Computer Architecture&quot; sounded kinda cool.<p>I walk in on the first day not realizing that while I had done my undergrad in MIS (fun fact: this is a business degree), literally every person in the course was either on the last semester of their undergrad in CompEng or were grad students that already had a BS in CompEng (this school combined some undergrad&#x2F;grad lectures).<p>Suddenly i hear the teacher say like &quot;grad students will also need to use an HDL and design a processor compatible with the basic MIPS instruction set.&quot; 
I started at &quot;what&#x27;s HDL mean?&quot; Teacher responds &quot;If that&#x27;s a real question then it means: Hurry and Drop this Lecture.&quot; Day 1 and I already have the wrong questions for the wrong reasons.<p>That was a really bad 3.5 months...  But it&#x27;s also proof that if you hate literally everything hard enough, then it is absolutely possible to pull a 100 day &quot;zero to MIPS HDL prototyping&quot; speedrun.</div><br/></div></div><div id="38736925" class="c"><input type="checkbox" id="c-38736925" checked=""/><div class="controls bullet"><span class="by">FredPret</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736737">parent</a><span>|</span><a href="#38741733">prev</a><span>|</span><a href="#38738536">next</a><span>|</span><label class="collapse" for="c-38736925">[-]</label><label class="expand" for="c-38736925">[2 more]</label></div><br/><div class="children"><div class="content">As frustrating as it is to black-box certain domains of knowledge, it’s an incredibly useful mental shortcut when used judiciously.</div><br/><div id="38738527" class="c"><input type="checkbox" id="c-38738527" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736925">parent</a><span>|</span><a href="#38738536">next</a><span>|</span><label class="collapse" for="c-38738527">[-]</label><label class="expand" for="c-38738527">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also just plain necessary as human knowledge gets more and more complex. The more time you spend on learning, the less time you have to actually make use of that knowledge. Ars longa, vita brevis.</div><br/></div></div></div></div></div></div><div id="38738536" class="c"><input type="checkbox" id="c-38738536" checked=""/><div class="controls bullet"><span class="by">1000100_1000101</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736658">parent</a><span>|</span><a href="#38736737">prev</a><span>|</span><a href="#38736730">next</a><span>|</span><label class="collapse" for="c-38738536">[-]</label><label class="expand" for="c-38738536">[1 more]</label></div><br/><div class="children"><div class="content">Aside from his basic 8-bit CPU, Ben Eater goes into how transistors work too: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=DXvAlwMAxiA" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=DXvAlwMAxiA</a> .  Once you&#x27;ve got transistors, his videos walk you through making gates.  Once you&#x27;ve got gates, he switches to the 74xx series and builds a CPU.</div><br/></div></div><div id="38736730" class="c"><input type="checkbox" id="c-38736730" checked=""/><div class="controls bullet"><span class="by">jon-wood</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736658">parent</a><span>|</span><a href="#38738536">prev</a><span>|</span><a href="#38737428">next</a><span>|</span><label class="collapse" for="c-38736730">[-]</label><label class="expand" for="c-38736730">[1 more]</label></div><br/><div class="children"><div class="content">The course explicitly states that it’s not a physics, or even really an electronics, course. It doesn’t go into the gritty details of how all this stuff works in the real world, just how once it does work you can string it all together to build a computer and then a virtual machine to run on it.</div><br/></div></div><div id="38737428" class="c"><input type="checkbox" id="c-38737428" checked=""/><div class="controls bullet"><span class="by">wintogreen74</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736658">parent</a><span>|</span><a href="#38736730">prev</a><span>|</span><a href="#38737513">next</a><span>|</span><label class="collapse" for="c-38737428">[-]</label><label class="expand" for="c-38737428">[1 more]</label></div><br/><div class="children"><div class="content">The book is a great example of how we do pretty much everything with computers today: abstraction. You can definitely learn how a transistor works but this book&#x2F;course explicitly starts with &quot;you&#x27;ve got a NAND chip - GO!&quot;</div><br/></div></div><div id="38737513" class="c"><input type="checkbox" id="c-38737513" checked=""/><div class="controls bullet"><span class="by">cdcarter</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736658">parent</a><span>|</span><a href="#38737428">prev</a><span>|</span><a href="#38737700">next</a><span>|</span><label class="collapse" for="c-38737513">[-]</label><label class="expand" for="c-38737513">[1 more]</label></div><br/><div class="children"><div class="content">Ben Eater does have a handful of early videos on his YouTube page that gave me a much better understanding of what&#x27;s happening down at the physical and particle level. But at the end of the day, to succeed with this material you just need to understand the theoretically digital function of a transistor, not the physical properties.</div><br/></div></div><div id="38737700" class="c"><input type="checkbox" id="c-38737700" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38736658">parent</a><span>|</span><a href="#38737513">prev</a><span>|</span><a href="#38736034">next</a><span>|</span><label class="collapse" for="c-38737700">[-]</label><label class="expand" for="c-38737700">[6 more]</label></div><br/><div class="children"><div class="content">btw the sn7400 is already a fairly advanced ic; something like an uln2003 is closer to &#x27;the simplest real world integrated circuit&#x27;<p>probably the best place to start for this, in a top-down sequence, is <i>the art of electronics</i> by horowitz and hill.  it explains how transistors and diodes act in §1.6, §2, and §3, initially explaining transistors with the simplified &#x27;current amplifier&#x27; model (which already goes beyond the &#x27;transistor switch&#x27; model you&#x27;re thinking of), then quantitatively with the ebers–moll model; they&#x27;re focused on how to use this information to design working circuits from discrete components you can put together on a circuit board.  camenzind&#x27;s <i>designing analog chips</i> (available free online) goes into how to use this information to design actual chips (not only does nand2tetris get into things like metastability and noise margin, the authors seem to be confused about what a chip even is, thinking you can make a chip by assembling other chips)<p>but the ebers–moll model is still not solid-state physics knowledge.  so far the best overview i&#x27;ve found of that is madou&#x27;s &#x27;fundamentals of microfabrication and nanotechnology&#x27; which has a couple of chapters about solid-state physics, going into the historical development of quantum mechanics.  but it&#x27;s not really a quantum mechanics textbook; it&#x27;s just an overview that shows where quantum-mechanical knowledge fits into understanding solid-state physics<p>&#x27;the feynman lectures on physics&#x27; is the best quantum mechanics textbook i&#x27;ve found so far, but because my knowledge of quantum mechanics is even more minimal, please don&#x27;t trust my recommendation on this<p>hope this helps.  good luck in your learning voyage!</div><br/><div id="38738608" class="c"><input type="checkbox" id="c-38738608" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38737700">parent</a><span>|</span><a href="#38740295">next</a><span>|</span><label class="collapse" for="c-38738608">[-]</label><label class="expand" for="c-38738608">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  btw the sn7400 is already a fairly advanced ic; something like an uln2003 is closer to &#x27;the simplest real world integrated circuit&#x27;<p>If the goal is to explain how logic is implemented in general, skipping bipolar transistors and TTL and jumping directly to MOS may be easier. The behavior of a FET is fairly easy to explain, especially if you don&#x27;t care about the ohmic region (which you usually don&#x27;t in logic ICs), and it&#x27;s straightforward to step from there to a practical implementation of a simple gate like an unbuffered NAND -- the latter of which can be trivially assembled on a breadboard with as little as two FETs and a resistor for a NMOS implementation.</div><br/><div id="38741999" class="c"><input type="checkbox" id="c-38741999" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38738608">parent</a><span>|</span><a href="#38740272">next</a><span>|</span><label class="collapse" for="c-38741999">[-]</label><label class="expand" for="c-38741999">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>especially if you don&#x27;t care about the ohmic region (which you usually don&#x27;t in logic ICs),</i><p>you have to care about the ohmic region to be confident you&#x27;ve safely steered clear of it; at least one fet moves through the ohmic region every time a mos gate&#x27;s output transitions<p>rtl is the bipolar equivalent of nmos (see the analog simulation at <a href="http:&#x2F;&#x2F;tinyurl.com&#x2F;ylnljbgz" rel="nofollow noreferrer">http:&#x2F;&#x2F;tinyurl.com&#x2F;ylnljbgz</a>) but you do need base resistors if you&#x27;re going to try to drive its inputs with voltage sources instead of the outputs of other rtl gates.  but you can omit them when the inputs are connected to rtl outputs <a href="http:&#x2F;&#x2F;tinyurl.com&#x2F;ywja8z28" rel="nofollow noreferrer">http:&#x2F;&#x2F;tinyurl.com&#x2F;ywja8z28</a><p>the flip side of that is that, though you need a base resistor to provide a constant logic high to an rtl  gate, you can provide a low just by leaving the input open, you don&#x27;t even need a wire like you do for nmos<p>bipolar logic is also a lot harder for students to blow up if your lab power supply has a current limit on its output</div><br/></div></div><div id="38740272" class="c"><input type="checkbox" id="c-38740272" checked=""/><div class="controls bullet"><span class="by">throwaway3090</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38738608">parent</a><span>|</span><a href="#38741999">prev</a><span>|</span><a href="#38740295">next</a><span>|</span><label class="collapse" for="c-38740272">[-]</label><label class="expand" for="c-38740272">[1 more]</label></div><br/><div class="children"><div class="content">Some older parts are specifically made to make creating complex PCB-level CMOS gates easy.  i.e. <a href="https:&#x2F;&#x2F;www.ti.com&#x2F;lit&#x2F;ds&#x2F;symlink&#x2F;cd4007ub.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ti.com&#x2F;lit&#x2F;ds&#x2F;symlink&#x2F;cd4007ub.pdf</a></div><br/></div></div></div></div><div id="38740295" class="c"><input type="checkbox" id="c-38740295" checked=""/><div class="controls bullet"><span class="by">throwaway3090</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38737700">parent</a><span>|</span><a href="#38738608">prev</a><span>|</span><a href="#38736034">next</a><span>|</span><label class="collapse" for="c-38740295">[-]</label><label class="expand" for="c-38740295">[2 more]</label></div><br/><div class="children"><div class="content">I think pretty much every sophomore level microelectronics book starts at basic semiconductor physics, works that into pn junctions, then transistors, then amplifiers, then gates and sequential elements.<p>A typical choice is Sedra &amp; Smith
<a href="https:&#x2F;&#x2F;learninglink.oup.com&#x2F;access&#x2F;sedra8e" rel="nofollow noreferrer">https:&#x2F;&#x2F;learninglink.oup.com&#x2F;access&#x2F;sedra8e</a><p>But there is no shortage of choices.</div><br/><div id="38742443" class="c"><input type="checkbox" id="c-38742443" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38735823">root</a><span>|</span><a href="#38740295">parent</a><span>|</span><a href="#38736034">next</a><span>|</span><label class="collapse" for="c-38742443">[-]</label><label class="expand" for="c-38742443">[1 more]</label></div><br/><div class="children"><div class="content">sedra &amp; smith is widely considered an excellent recommendation, but on skimming it, it seems that it does not cover solid-state physics at all or even mention any quantum effects; madou does spend a few chapters on solid-state physics, and of course feynman covers elementary quantum mechanics quite comprehensively.  sedra &amp; smith does go into a lot more depth on some aspects of chip design than horowitz &amp; hill or even camenzind. it gives the ebers–moll equation in table 6.2, just not by name, and describes the inner workings of transistors in considerably more detail than the other books<p>horowitz &amp; hill, camenzind, and feynman are much better written than sedra &amp; smith or madou.  the quality of the writing in sedra &amp; smith in particular is quite poor; it contradicts itself every few pages, and often says things that require great effort to interpret as a correct statement, at least in the 7th edition i&#x27;m looking at<p>horowitz &amp; hill also have much nicer schematics than sedra &amp; smith or, especially, camenzind</div><br/></div></div></div></div></div></div></div></div><div id="38736034" class="c"><input type="checkbox" id="c-38736034" checked=""/><div class="controls bullet"><span class="by">superfunny</span><span>|</span><a href="#38735823">parent</a><span>|</span><a href="#38736658">prev</a><span>|</span><a href="#38736149">next</a><span>|</span><label class="collapse" for="c-38736034">[-]</label><label class="expand" for="c-38736034">[1 more]</label></div><br/><div class="children"><div class="content">We did the whole project as part of a class; it was one of the best classes I took in my CompSci program.  It was excellent.</div><br/></div></div></div></div><div id="38736149" class="c"><input type="checkbox" id="c-38736149" checked=""/><div class="controls bullet"><span class="by">emschwartz</span><span>|</span><a href="#38735823">prev</a><span>|</span><a href="#38735625">next</a><span>|</span><label class="collapse" for="c-38736149">[-]</label><label class="expand" for="c-38736149">[6 more]</label></div><br/><div class="children"><div class="content">I loved this course and would strongly recommend it to anyone who works with computers that hasn&#x27;t taken low-level CS classes.<p>This course does an exceptional job of giving you an intuitive understanding of some critical parts of how a computer works that affect higher-level programs and programming languages (for me the biggest aha! was grokking the difference between the stack and the heap). It is also incredibly fun to appreciate how magical it is that these complicated machines we use are just built from these simple circuits that you keep building up and building up through the course. Finally, the teachers did a fantastic job of simplifying what could be multiple semesters worth of material to quickly give you the gist of things like assembly languages, without oversimplifying.<p>Really can&#x27;t recommend this enough if you have the time to do it. FWIW, the first part of the course (from NAND gates to building a CPU) is very fun and fairly easy. The second part (going from a computer to a full operating system) is quite a bit more work.</div><br/><div id="38737957" class="c"><input type="checkbox" id="c-38737957" checked=""/><div class="controls bullet"><span class="by">CWIZO</span><span>|</span><a href="#38736149">parent</a><span>|</span><a href="#38735625">next</a><span>|</span><label class="collapse" for="c-38737957">[-]</label><label class="expand" for="c-38737957">[5 more]</label></div><br/><div class="children"><div class="content">Is the online course and the book the same material? Trying to figure out if I need both or either.</div><br/><div id="38738697" class="c"><input type="checkbox" id="c-38738697" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#38736149">root</a><span>|</span><a href="#38737957">parent</a><span>|</span><a href="#38739372">next</a><span>|</span><label class="collapse" for="c-38738697">[-]</label><label class="expand" for="c-38738697">[1 more]</label></div><br/><div class="children"><div class="content">The two online courses at Coursera are based on the First Edition of &quot;The Elements of Computing Systems: Building a Modern Computer from First Principles&quot;: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Elements-Computing-Systems-Building-Principles&#x2F;dp&#x2F;0262640686&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amazon.com&#x2F;Elements-Computing-Systems-Building-P...</a><p>The most recent edition of this book is the Second Edition: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;dp&#x2F;0262539802&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amazon.com&#x2F;dp&#x2F;0262539802&#x2F;</a><p>To quote from the Preface concerning what the difference between these two editions is:<p>&quot;The Second Edition<p>Although Nand to Tetris was always structured around two themes, the
second edition makes this structure explicit: The book is now divided into
two distinct and standalone parts, Part I: Hardware and Part II: Software.
Each part consists of six chapters and six projects and begins with a newly
written introduction that sets the stage for the part’s chapters. Importantly,
the two parts are independent of each other. Thus, the new book structure
lends itself well to quarter-long as well as semester-long courses.<p>In addition to the two new introduction chapters, the second edition
features four new appendices. Following the requests of many learners,
these new appendices give focused presentations of various technical topics
that, in the first edition, were scattered across the chapters. Another new
appendix provides a formal proof that any Boolean function can be built
from Nand operators, adding a theoretical perspective to the applied
hardware construction projects. Many new sections, figures, and examples
were added.<p>All the chapters and project materials were rewritten with an emphasis on
separating abstraction from implementation—a major theme in Nand to
Tetris. We took special care to add examples and sections that address the
thousands of questions that were posted over the years in Nand to Tetris
Q&amp;A forums.&quot;</div><br/></div></div><div id="38739372" class="c"><input type="checkbox" id="c-38739372" checked=""/><div class="controls bullet"><span class="by">brailsafe</span><span>|</span><a href="#38736149">root</a><span>|</span><a href="#38737957">parent</a><span>|</span><a href="#38738697">prev</a><span>|</span><a href="#38738427">next</a><span>|</span><label class="collapse" for="c-38739372">[-]</label><label class="expand" for="c-38739372">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d recommend watching the course material and reading each chapter. It depends on a little luck which material clicks and how quickly, for me it varied from chapter to chapter whether or not I could get by with just the videos.</div><br/></div></div><div id="38738427" class="c"><input type="checkbox" id="c-38738427" checked=""/><div class="controls bullet"><span class="by">molly0</span><span>|</span><a href="#38736149">root</a><span>|</span><a href="#38737957">parent</a><span>|</span><a href="#38739372">prev</a><span>|</span><a href="#38739070">next</a><span>|</span><label class="collapse" for="c-38738427">[-]</label><label class="expand" for="c-38738427">[1 more]</label></div><br/><div class="children"><div class="content">Im currently taking this course without having the book and it works great. I might buy the book later but for me it’s important to have the imposed weekly deadlines in order to not just drift away and do something else instead.</div><br/></div></div><div id="38739070" class="c"><input type="checkbox" id="c-38739070" checked=""/><div class="controls bullet"><span class="by">emschwartz</span><span>|</span><a href="#38736149">root</a><span>|</span><a href="#38737957">parent</a><span>|</span><a href="#38738427">prev</a><span>|</span><a href="#38735625">next</a><span>|</span><label class="collapse" for="c-38739070">[-]</label><label class="expand" for="c-38739070">[1 more]</label></div><br/><div class="children"><div class="content">I did the course without the book. I haven’t actually looked through the book, but the Coursera class was definitely enough on its own.</div><br/></div></div></div></div></div></div><div id="38735625" class="c"><input type="checkbox" id="c-38735625" checked=""/><div class="controls bullet"><span class="by">Semitangent</span><span>|</span><a href="#38736149">prev</a><span>|</span><a href="#38735112">next</a><span>|</span><label class="collapse" for="c-38735625">[-]</label><label class="expand" for="c-38735625">[5 more]</label></div><br/><div class="children"><div class="content">I found nand2tetris a very natural progression for me after finishing Ben Eater&#x27;s great 8bit computer series (<a href="https:&#x2F;&#x2F;eater.net&#x2F;8bit&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eater.net&#x2F;8bit&#x2F;</a>). It just makes you grok so many basic concepts of computer design which are quite often glossed over. A perfect project to start over the holidays!</div><br/><div id="38736157" class="c"><input type="checkbox" id="c-38736157" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#38735625">parent</a><span>|</span><a href="#38736415">next</a><span>|</span><label class="collapse" for="c-38736157">[-]</label><label class="expand" for="c-38736157">[2 more]</label></div><br/><div class="children"><div class="content">Second recommending Ben Eater. I love his videos. Two of my favorites are the introduction of loops, and the introduction of interrupts. Seeing the code he wrote re-written using these to be so much more elegant was very satisfying.</div><br/><div id="38740796" class="c"><input type="checkbox" id="c-38740796" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#38735625">root</a><span>|</span><a href="#38736157">parent</a><span>|</span><a href="#38736415">next</a><span>|</span><label class="collapse" for="c-38740796">[-]</label><label class="expand" for="c-38740796">[1 more]</label></div><br/><div class="children"><div class="content">For me the &#x27;aha&#x27; moment was the microcode section of the 8-bit computer project. Just the physical understanding of how it can take a different number of clock cycles to execute an &#x27;instruction&#x27; - and how (in this architecture) every instruction cycle has to start with the memory address switching to the current program counter, and the data from that address being loaded into a register.<p>I haven&#x27;t gone as far as actually building a breadboard CPU, but I was able to apply what Ben teaches to build several functional microprocessors in <a href="https:&#x2F;&#x2F;www.falstad.com&#x2F;circuit&#x2F;circuitjs.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.falstad.com&#x2F;circuit&#x2F;circuitjs.html</a>, starting with basically reimplementing the breadboard model he built out.. but then after watching the 6502 series, going back and being able to see and even <i>implement</i> some of the things that implies about the internals of a 6502 processor.</div><br/></div></div></div></div><div id="38736415" class="c"><input type="checkbox" id="c-38736415" checked=""/><div class="controls bullet"><span class="by">JKCalhoun</span><span>|</span><a href="#38735625">parent</a><span>|</span><a href="#38736157">prev</a><span>|</span><a href="#38736280">next</a><span>|</span><label class="collapse" for="c-38736415">[-]</label><label class="expand" for="c-38736415">[1 more]</label></div><br/><div class="children"><div class="content">Did Ben Eaters 6502 computer this past summer. Can also recommend.<p>Guess I&#x27;ll have to look into <i>NAND to Tetris</i> now.</div><br/></div></div><div id="38736280" class="c"><input type="checkbox" id="c-38736280" checked=""/><div class="controls bullet"><span class="by">captn3m0</span><span>|</span><a href="#38735625">parent</a><span>|</span><a href="#38736415">prev</a><span>|</span><a href="#38735112">next</a><span>|</span><label class="collapse" for="c-38736280">[-]</label><label class="expand" for="c-38736280">[1 more]</label></div><br/><div class="children"><div class="content">I did nand2tetris during my time at Recurse, and I spent a lot of time watching Ben Eater  those days. They paired nicely.</div><br/></div></div></div></div><div id="38735112" class="c"><input type="checkbox" id="c-38735112" checked=""/><div class="controls bullet"><span class="by">mikpanko</span><span>|</span><a href="#38735625">prev</a><span>|</span><a href="#38737900">next</a><span>|</span><label class="collapse" for="c-38735112">[-]</label><label class="expand" for="c-38735112">[14 more]</label></div><br/><div class="children"><div class="content">Here is a fun Nand game inspired by the course: <a href="https:&#x2F;&#x2F;nandgame.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nandgame.com&#x2F;</a></div><br/><div id="38735325" class="c"><input type="checkbox" id="c-38735325" checked=""/><div class="controls bullet"><span class="by">AlchemistCamp</span><span>|</span><a href="#38735112">parent</a><span>|</span><a href="#38736167">next</a><span>|</span><label class="collapse" for="c-38735325">[-]</label><label class="expand" for="c-38735325">[10 more]</label></div><br/><div class="children"><div class="content">Here’s an even more fun one with overwhelmingly positive Steam reviews! <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1444480&#x2F;Turing_Complete&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1444480&#x2F;Turing_Complete&#x2F;</a></div><br/><div id="38736844" class="c"><input type="checkbox" id="c-38736844" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38735325">parent</a><span>|</span><a href="#38738966">next</a><span>|</span><label class="collapse" for="c-38736844">[-]</label><label class="expand" for="c-38736844">[1 more]</label></div><br/><div class="children"><div class="content">I played both of them.
Turing complete has a more non-linear arcade mode. I mean that you can choose which level you want to complete first.<p>There is also soundtrack and a little bit of story line present.
There is also gog version of this game.<p>I feel that I learned almost no new skills this semester, but I remember asking my circuit design lecturer questions about this game (in particular, about the possibility of constructing full-adder with fewer elements). That was fun<p>You can stick to nandgame, if you don&#x27;t want to pay, you loose almost nothing, but playing Turing Complete is more handy because it keeps progress on your computer and&#x2F;or on the steam account.
So, if you clean cookies every time you restart your browser, when using ungoogled-chromium for example, you better play Turing complete.<p>Also one internet friend advised me to play incredible pm
<a href="https:&#x2F;&#x2F;incredible.pm&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;incredible.pm&#x2F;</a><p>It is a similar game, but the main theme is proofs rather than digital circuits. Hasn&#x27;t played yet, unfortunately.</div><br/></div></div><div id="38738966" class="c"><input type="checkbox" id="c-38738966" checked=""/><div class="controls bullet"><span class="by">geoelectric</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38735325">parent</a><span>|</span><a href="#38736844">prev</a><span>|</span><a href="#38735348">next</a><span>|</span><label class="collapse" for="c-38738966">[-]</label><label class="expand" for="c-38738966">[1 more]</label></div><br/><div class="children"><div class="content">Turing Complete is a great game. Finishing it was a major sense of accomplishment for me, particularly since I rarely complete games (though Zachlikes are a common exception).<p>This is from my Steam review (one of two ever, I liked it so much):<p>&gt; Man, what a trip. I’ve played the NAND game and MRHD, among others, but never quite got to the “build a computer” endgame. I did with this one. At this point I’ve built a 256-byte RAM system that does six math instructions, six conditional jumps, and subroutine calls using its own stack—then developed my own assembly language for it which I&#x27;m now using in the endgame to solve more traditional programming puzzles.<p>&gt; And I designed and built the entire architecture for it myself. The initial levels are mostly &quot;one solution only&quot; problems that each results in you designing a component. But by the time you&#x27;re at midgame, all the decisions are yours as long as the output is correct. Previous problems tend to hint towards partial solutions of later problems, but very little is given to you outright. That gives you an incredible sense of accomplishment for what you put together.<p>That said, unless they improved the bit where wiring tends to merge together and virtually short out during edits, it can be a little frustrating once things get very complex. It&#x27;s not enough for me to not recommend it, but there was a point where I felt like I was having to master the tricky interface quirks as much or more than the logic. Shenzen IO did that part much better.</div><br/></div></div><div id="38735348" class="c"><input type="checkbox" id="c-38735348" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38735325">parent</a><span>|</span><a href="#38738966">prev</a><span>|</span><a href="#38736717">next</a><span>|</span><label class="collapse" for="c-38735348">[-]</label><label class="expand" for="c-38735348">[5 more]</label></div><br/><div class="children"><div class="content">Here is another game on steam that is nearer to the first part of &quot;From Nand to Tetris&quot;:<p>MHRD<p><a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;576030&#x2F;MHRD&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;576030&#x2F;MHRD&#x2F;</a></div><br/><div id="38736239" class="c"><input type="checkbox" id="c-38736239" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38735348">parent</a><span>|</span><a href="#38736717">next</a><span>|</span><label class="collapse" for="c-38736239">[-]</label><label class="expand" for="c-38736239">[4 more]</label></div><br/><div class="children"><div class="content">While we&#x27;re recommending programming games, I think Virtual Circuit Board is a bit underappreciated. It&#x27;s a pure sandbox, not a game, so you have to bring the ideas yourself, but it hits a really sweet spot somewhere between Minecraft redstone and Logisim.<p>You just draw traces and add gates on a grid, with a few special IO components like the Nand2Tetris course. But there&#x27;s some kind of compilation of the circuit, and simulation can be blazing fast, way faster than other programming games&#x2F;programming friendly sandbox games.</div><br/><div id="38736569" class="c"><input type="checkbox" id="c-38736569" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38736239">parent</a><span>|</span><a href="#38736959">next</a><span>|</span><label class="collapse" for="c-38736569">[-]</label><label class="expand" for="c-38736569">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Virtual Circuit Board is a bit underappreciated.<p>For the convenience of the reader:<p>- Website: <a href="https:&#x2F;&#x2F;www.virtualcircuitboard.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.virtualcircuitboard.com&#x2F;</a><p>- Steam: <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1885690&#x2F;Virtual_Circuit_Board&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1885690&#x2F;Virtual_Circuit_B...</a></div><br/></div></div><div id="38736959" class="c"><input type="checkbox" id="c-38736959" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38736239">parent</a><span>|</span><a href="#38736569">prev</a><span>|</span><a href="#38736717">next</a><span>|</span><label class="collapse" for="c-38736959">[-]</label><label class="expand" for="c-38736959">[2 more]</label></div><br/><div class="children"><div class="content">There is an emulator on steam called CRUMB.<p>Rather than being schematic, it is almost too real.<p>The 3D lab is equipped with a breadboard, power supplies, signal generators, various passive and active components, and chips such as the timer 555.<p>I attempted to use it to complete a lab from my university, where I had to construct a trigger from a chip with 3 NAND gates.<p>But at this point getting membership at nearest hackerspace may be a decent option.<p>&gt; But there&#x27;s some kind of compilation of the circuit
Realistic enough.
Back then you could compile your PCB project in altium designer, but now this button would be called validate.<p>Sorry, if I wrote too much in this discussion thread.</div><br/><div id="38737255" class="c"><input type="checkbox" id="c-38737255" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38736959">parent</a><span>|</span><a href="#38736717">next</a><span>|</span><label class="collapse" for="c-38737255">[-]</label><label class="expand" for="c-38737255">[1 more]</label></div><br/><div class="children"><div class="content">s&#x2F;trigger&#x2F;flip-flop&#x2F;<p>I forget that in English it is more often called latch and that there are also flip-flops, two different types of what is called triggers in the East.</div><br/></div></div></div></div></div></div></div></div><div id="38736717" class="c"><input type="checkbox" id="c-38736717" checked=""/><div class="controls bullet"><span class="by">NanoCoaster</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38735325">parent</a><span>|</span><a href="#38735348">prev</a><span>|</span><a href="#38740170">next</a><span>|</span><label class="collapse" for="c-38736717">[-]</label><label class="expand" for="c-38736717">[1 more]</label></div><br/><div class="children"><div class="content">Definitely recommend Turing Complete. I&#x27;ve been playing it off and on over the last few weeks, just finished the first working CPU. It includes small hints and solutions for most levels, so if you get stuck, you&#x27;ll always have a way forward. The interesting thing is, for a lot of levels, you can just google the component you&#x27;re trying to build and use actual logic diagrams as guidance.<p>The game makes the whole topic a bit easier to grok with its visuals and the ability to step through your circuits when they&#x27;re running. So, great fun. But beware, if you&#x27;ve been bitten by Factorio addiction, you might be in danger of missing a lot of sleep :)<p>Also, as some other comments mentioned, I highly recommend the Zachtronics games. Exapunks is amazing. But they&#x27;re quite different, they&#x27;re more like puzzle games about programming.</div><br/></div></div><div id="38740170" class="c"><input type="checkbox" id="c-38740170" checked=""/><div class="controls bullet"><span class="by">SilasX</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38735325">parent</a><span>|</span><a href="#38736717">prev</a><span>|</span><a href="#38736167">next</a><span>|</span><label class="collapse" for="c-38740170">[-]</label><label class="expand" for="c-38740170">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve completed both nand2tetris and Turing Complete. A note about differences:<p>- TC only goes up to the level of writing programs in assembly, while nand2tetris has you build layers of abstraction on top of that so you can program in a Java-like language. In fact, TC doesn&#x27;t give you &quot;assembly code&quot; at all, you just implement binary instructions, and they leave it to you to decide your own mnemonics for each byte of the 4-byte instructions (on the second computer you implement).<p>- TC lets you make more of the decisions yourself regarding architecture, like how to address memory.<p>One thing I didn&#x27;t like about TC is that, when doing the projects to build the (second) computer, it doesn&#x27;t regression test. When you implement new opcodes, you can be credited for completing the level, even though you broke the previous ones you implemented, and you might not realize it until several projects later, when your computer doesn&#x27;t work.</div><br/></div></div></div></div><div id="38736167" class="c"><input type="checkbox" id="c-38736167" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#38735112">parent</a><span>|</span><a href="#38735325">prev</a><span>|</span><a href="#38737900">next</a><span>|</span><label class="collapse" for="c-38736167">[-]</label><label class="expand" for="c-38736167">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit different, but I also recommend both TIS-100 and Shenzhen IO. Both of them involve writing in an assembly-esque language, and it&#x27;s very fun to learn!</div><br/><div id="38736332" class="c"><input type="checkbox" id="c-38736332" checked=""/><div class="controls bullet"><span class="by">captn3m0</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38736167">parent</a><span>|</span><a href="#38737900">next</a><span>|</span><label class="collapse" for="c-38736332">[-]</label><label class="expand" for="c-38736332">[2 more]</label></div><br/><div class="children"><div class="content">I gave up early on TOS-100, but that was before I did nand2tetris. I did Nand2tetris before Shenzhen-IO and really enjoyed it.<p>Yet to finish Shenzhen IO, but I blame it on me stupidly doing premature optimisation.</div><br/><div id="38736357" class="c"><input type="checkbox" id="c-38736357" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#38735112">root</a><span>|</span><a href="#38736332">parent</a><span>|</span><a href="#38737900">next</a><span>|</span><label class="collapse" for="c-38736357">[-]</label><label class="expand" for="c-38736357">[1 more]</label></div><br/><div class="children"><div class="content">Both TIS and Shenzhen are cases where I&#x27;d say make something ugly that works, then go back and fix it hours later when you have new tools and experience.<p>IE, the very first puzzle gets an easier solution once you learn about a hidden command.<p>There&#x27;s satisfaction to leaving a solution to come back days later and go &quot;whoah, this better solution is so obvious&quot; which is easy to miss when you&#x27;re stuck on it for hours.</div><br/></div></div></div></div></div></div></div></div><div id="38737900" class="c"><input type="checkbox" id="c-38737900" checked=""/><div class="controls bullet"><span class="by">shpx</span><span>|</span><a href="#38735112">prev</a><span>|</span><a href="#38735650">next</a><span>|</span><label class="collapse" for="c-38737900">[-]</label><label class="expand" for="c-38737900">[2 more]</label></div><br/><div class="children"><div class="content">I can also recommend the Digital Design and Computer Architecture lectures from ETH Zürich if you&#x27;re trying to understand computers at a lower level:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PL5Q2soXY2Zi-EImKxYYY1SZuGiOAOBKaf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list=PL5Q2soXY2Zi-EImKxYYY1...</a></div><br/><div id="38740091" class="c"><input type="checkbox" id="c-38740091" checked=""/><div class="controls bullet"><span class="by">naitgacem</span><span>|</span><a href="#38737900">parent</a><span>|</span><a href="#38735650">next</a><span>|</span><label class="collapse" for="c-38740091">[-]</label><label class="expand" for="c-38740091">[1 more]</label></div><br/><div class="children"><div class="content">this is a gold mine! 
I&#x27;ve taken an introductory course on computer architecture, unfortunately we didn&#x27;t get far and definitely didn&#x27;t touch on anything about out-of-order execution or the similar magic CPUs do nowadays. this&#x27;ll playlist will be my holidays theme<p>thanks for sharing!</div><br/></div></div></div></div><div id="38735650" class="c"><input type="checkbox" id="c-38735650" checked=""/><div class="controls bullet"><span class="by">pythops</span><span>|</span><a href="#38737900">prev</a><span>|</span><a href="#38735922">next</a><span>|</span><label class="collapse" for="c-38735650">[-]</label><label class="expand" for="c-38735650">[7 more]</label></div><br/><div class="children"><div class="content">There is also this repo from george hotz, very interesting ! 
<a href="https:&#x2F;&#x2F;github.com&#x2F;geohot&#x2F;fromthetransistor">https:&#x2F;&#x2F;github.com&#x2F;geohot&#x2F;fromthetransistor</a></div><br/><div id="38736011" class="c"><input type="checkbox" id="c-38736011" checked=""/><div class="controls bullet"><span class="by">jpcfl</span><span>|</span><a href="#38735650">parent</a><span>|</span><a href="#38736455">next</a><span>|</span><label class="collapse" for="c-38736011">[-]</label><label class="expand" for="c-38736011">[1 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t sure what I was looking at at first, since there&#x27;s no material, just a rough outline of a hypothetical course. The initial commit makes it a little clearer:<p>&gt; <i>Wrote this a few years ago, wanted to put it online. Hiring is hard, a lot of modern CS education is really bad, and it&#x27;s so hard to find people who understand the modern computer stack from first principles. Maybe if I ever get 12 free weeks again I&#x27;ll offer this as a play at home course. I want to play too.</i></div><br/></div></div><div id="38736455" class="c"><input type="checkbox" id="c-38736455" checked=""/><div class="controls bullet"><span class="by">slalomskiing</span><span>|</span><a href="#38735650">parent</a><span>|</span><a href="#38736011">prev</a><span>|</span><a href="#38735922">next</a><span>|</span><label class="collapse" for="c-38736455">[-]</label><label class="expand" for="c-38736455">[5 more]</label></div><br/><div class="children"><div class="content">It’s funny he says a lot of modern CS education is bad<p>I did Computer Engineering rather than CS for undergrad and we covered like 80% of the topics in that list<p>Had multiple courses in Verilog&#x2F;OS and worked a lot with microcontrollers&#x2F;FPGAs. Building a CPU in verilog then writing an assembler&#x2F;compiler was definitely the highlight.<p>Was a hard program but I felt like I had a really good understanding of the full stack coming out of it.<p>Maybe he just isn’t familiar with CE?</div><br/><div id="38736645" class="c"><input type="checkbox" id="c-38736645" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#38735650">root</a><span>|</span><a href="#38736455">parent</a><span>|</span><a href="#38736994">next</a><span>|</span><label class="collapse" for="c-38736645">[-]</label><label class="expand" for="c-38736645">[3 more]</label></div><br/><div class="children"><div class="content">Where I’m did you do undergrad. My son is not having much success finding a college to shoot for in terms of having a goal. I think a curriculum like you describe would at least show him some options that exist.</div><br/><div id="38737238" class="c"><input type="checkbox" id="c-38737238" checked=""/><div class="controls bullet"><span class="by">bhasi</span><span>|</span><a href="#38735650">root</a><span>|</span><a href="#38736645">parent</a><span>|</span><a href="#38736662">next</a><span>|</span><label class="collapse" for="c-38737238">[-]</label><label class="expand" for="c-38737238">[1 more]</label></div><br/><div class="children"><div class="content">Gatech, UPenn, U Colorado Boulder all have great CompE programs at both undergrad and graduate levels.</div><br/></div></div><div id="38736662" class="c"><input type="checkbox" id="c-38736662" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#38735650">root</a><span>|</span><a href="#38736645">parent</a><span>|</span><a href="#38737238">prev</a><span>|</span><a href="#38736994">next</a><span>|</span><label class="collapse" for="c-38736662">[-]</label><label class="expand" for="c-38736662">[1 more]</label></div><br/><div class="children"><div class="content">Georgia Tech has (when I was there at least) a good CMPE program.</div><br/></div></div></div></div><div id="38736994" class="c"><input type="checkbox" id="c-38736994" checked=""/><div class="controls bullet"><span class="by">jholman</span><span>|</span><a href="#38735650">root</a><span>|</span><a href="#38736455">parent</a><span>|</span><a href="#38736645">prev</a><span>|</span><a href="#38735922">next</a><span>|</span><label class="collapse" for="c-38736994">[-]</label><label class="expand" for="c-38736994">[1 more]</label></div><br/><div class="children"><div class="content">Seems to me that CE covers sections 1, 2, 3, 7, and a bit of 5, and CS covers 4, 5, and 6.  A traditional CS education should teach 3, even though doing 3 is absolutely not the job of CS grads.</div><br/></div></div></div></div></div></div><div id="38735922" class="c"><input type="checkbox" id="c-38735922" checked=""/><div class="controls bullet"><span class="by">elevaet</span><span>|</span><a href="#38735650">prev</a><span>|</span><a href="#38739430">next</a><span>|</span><label class="collapse" for="c-38735922">[-]</label><label class="expand" for="c-38735922">[8 more]</label></div><br/><div class="children"><div class="content">I wonder if the prequel &quot;sand2nand&quot; would be possible as a DIY project?</div><br/><div id="38736043" class="c"><input type="checkbox" id="c-38736043" checked=""/><div class="controls bullet"><span class="by">samvher</span><span>|</span><a href="#38735922">parent</a><span>|</span><a href="#38739430">next</a><span>|</span><label class="collapse" for="c-38736043">[-]</label><label class="expand" for="c-38736043">[7 more]</label></div><br/><div class="children"><div class="content">Sure: <a href="http:&#x2F;&#x2F;sam.zeloof.xyz&#x2F;first-ic&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;sam.zeloof.xyz&#x2F;first-ic&#x2F;</a></div><br/><div id="38738276" class="c"><input type="checkbox" id="c-38738276" checked=""/><div class="controls bullet"><span class="by">cjpearson</span><span>|</span><a href="#38735922">root</a><span>|</span><a href="#38736043">parent</a><span>|</span><a href="#38737373">next</a><span>|</span><label class="collapse" for="c-38738276">[-]</label><label class="expand" for="c-38738276">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Native oxide is stripped off the wafer with a quick dilute HF dip and then they are extensively cleaned in Piranha solution (H2SO4:H2O2), RCA 1 (H2O:NH3:H2O2), RCA 2 (H2O:HCL:H2O2), followed by another dilute HF dip.<p>Fascinating project, but I&#x27;m not going to try this one at home</div><br/></div></div><div id="38737373" class="c"><input type="checkbox" id="c-38737373" checked=""/><div class="controls bullet"><span class="by">Two9A</span><span>|</span><a href="#38735922">root</a><span>|</span><a href="#38736043">parent</a><span>|</span><a href="#38738276">prev</a><span>|</span><a href="#38737152">next</a><span>|</span><label class="collapse" for="c-38737373">[-]</label><label class="expand" for="c-38737373">[2 more]</label></div><br/><div class="children"><div class="content">Oh goodness, this is the kind of thing I&#x27;ve been trying to find for years now: some method of making a computer from scratch, as in from raw materials.<p>Will have to look into your progress, thanks.</div><br/><div id="38737854" class="c"><input type="checkbox" id="c-38737854" checked=""/><div class="controls bullet"><span class="by">samvher</span><span>|</span><a href="#38735922">root</a><span>|</span><a href="#38737373">parent</a><span>|</span><a href="#38737152">next</a><span>|</span><label class="collapse" for="c-38737854">[-]</label><label class="expand" for="c-38737854">[1 more]</label></div><br/><div class="children"><div class="content">Just to clarify, not my project! :)</div><br/></div></div></div></div><div id="38737152" class="c"><input type="checkbox" id="c-38737152" checked=""/><div class="controls bullet"><span class="by">elevaet</span><span>|</span><a href="#38735922">root</a><span>|</span><a href="#38736043">parent</a><span>|</span><a href="#38737373">prev</a><span>|</span><a href="#38739430">next</a><span>|</span><label class="collapse" for="c-38737152">[-]</label><label class="expand" for="c-38737152">[3 more]</label></div><br/><div class="children"><div class="content">Are you the same Sam? Either way, nice project wow!</div><br/><div id="38737832" class="c"><input type="checkbox" id="c-38737832" checked=""/><div class="controls bullet"><span class="by">samvher</span><span>|</span><a href="#38735922">root</a><span>|</span><a href="#38737152">parent</a><span>|</span><a href="#38737838">next</a><span>|</span><label class="collapse" for="c-38737832">[-]</label><label class="expand" for="c-38737832">[1 more]</label></div><br/><div class="children"><div class="content">Different Sam! :)</div><br/></div></div><div id="38737838" class="c"><input type="checkbox" id="c-38737838" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38735922">root</a><span>|</span><a href="#38737152">parent</a><span>|</span><a href="#38737832">prev</a><span>|</span><a href="#38739430">next</a><span>|</span><label class="collapse" for="c-38737838">[-]</label><label class="expand" for="c-38737838">[1 more]</label></div><br/><div class="children"><div class="content">different sam, still has a lot of awesome projects</div><br/></div></div></div></div></div></div></div></div><div id="38739430" class="c"><input type="checkbox" id="c-38739430" checked=""/><div class="controls bullet"><span class="by">AlecSchueler</span><span>|</span><a href="#38735922">prev</a><span>|</span><a href="#38735396">next</a><span>|</span><label class="collapse" for="c-38739430">[-]</label><label class="expand" for="c-38739430">[1 more]</label></div><br/><div class="children"><div class="content">Great memories of this book, and of the period of my life I picked it up in. I was at coffee with my girlfriend saying I&#x27;d read you could make all the logic gates using only NANDs, so we got curious and wrote NAND on a bunch of napkins to see if we could figure them all out.<p>We did and it was great fun. For each gate we figured it with NANDs we would write the name of the new gate on a napkin.<p>We took the napkins and the joy of it home and sheet a few days we started combining those gates up as well, trying to eventually figure out an entire ALU. And so along came multiplexors and a bunch of other fascinating stuff.<p>Eventually we got stumped, but I&#x27;d heard about this book and we decided to order it. The rest of the chapters really did help us get an understanding of the low level that had always been mysterious to me as someone with software experience only.<p>Can&#x27;t say I ever did make it all the way through in terms of building around, though. Once it got more into the low software levels I felt I already had enough of an understanding that the work didn&#x27;t seem so appealing, but the read was still fantastic.</div><br/></div></div><div id="38735396" class="c"><input type="checkbox" id="c-38735396" checked=""/><div class="controls bullet"><span class="by">yoyohello13</span><span>|</span><a href="#38739430">prev</a><span>|</span><a href="#38736688">next</a><span>|</span><label class="collapse" for="c-38735396">[-]</label><label class="expand" for="c-38735396">[4 more]</label></div><br/><div class="children"><div class="content">I took this course on a lark when I was working as a data analyst. It inspired me to change careers. Absolutely excellent course. Definitely do it if you&#x27;ve got the time.</div><br/><div id="38735426" class="c"><input type="checkbox" id="c-38735426" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#38735396">parent</a><span>|</span><a href="#38736688">next</a><span>|</span><label class="collapse" for="c-38735426">[-]</label><label class="expand" for="c-38735426">[3 more]</label></div><br/><div class="children"><div class="content">Congratulations! Did you switch to a lower level programming career path?</div><br/><div id="38736085" class="c"><input type="checkbox" id="c-38736085" checked=""/><div class="controls bullet"><span class="by">yoyohello13</span><span>|</span><a href="#38735396">root</a><span>|</span><a href="#38735426">parent</a><span>|</span><a href="#38736688">next</a><span>|</span><label class="collapse" for="c-38736085">[-]</label><label class="expand" for="c-38736085">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m making apps for a local company now. Still valuable info though. I use the text parsing knowledge I gained from this course quite a bit.</div><br/><div id="38737467" class="c"><input type="checkbox" id="c-38737467" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#38735396">root</a><span>|</span><a href="#38736085">parent</a><span>|</span><a href="#38736688">next</a><span>|</span><label class="collapse" for="c-38737467">[-]</label><label class="expand" for="c-38737467">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty good. I&#x27;m glad that you made the switch you wanted.</div><br/></div></div></div></div></div></div></div></div><div id="38736688" class="c"><input type="checkbox" id="c-38736688" checked=""/><div class="controls bullet"><span class="by">skripp</span><span>|</span><a href="#38735396">prev</a><span>|</span><a href="#38736552">next</a><span>|</span><label class="collapse" for="c-38736688">[-]</label><label class="expand" for="c-38736688">[1 more]</label></div><br/><div class="children"><div class="content">I highly recommend you play the game “Turing complete” alongside this course. Will give you an additional visual way of looking at the problems.</div><br/></div></div><div id="38736552" class="c"><input type="checkbox" id="c-38736552" checked=""/><div class="controls bullet"><span class="by">cushychicken</span><span>|</span><a href="#38736688">prev</a><span>|</span><a href="#38737872">next</a><span>|</span><label class="collapse" for="c-38736552">[-]</label><label class="expand" for="c-38736552">[5 more]</label></div><br/><div class="children"><div class="content">Does this still use a custom hardware description language?<p>The curriculum here is very solid - my only critique is that it uses a custom HDL instead of Verilog, VHDL, or SystemVerilog.<p>It wouldn’t have been a huge stretch to do that, and make the skills taught that much more real as a result. Without the practical aspect of exposure to real HDLs, it seems more like a toy than a tool.</div><br/><div id="38739320" class="c"><input type="checkbox" id="c-38739320" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#38736552">parent</a><span>|</span><a href="#38739422">next</a><span>|</span><label class="collapse" for="c-38739320">[-]</label><label class="expand" for="c-38739320">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there&#x27;s anything to be gained by switching to VHDL or Verilog. Their custom HDL is a fine HDL for the uses of the course. There&#x27;s so much commonality that they&#x27;re effectively interchangeable syntactically. If the idea was to use VHDL or Verilog such that one could actually make the CPU on silicon or an FPGA, then that opens up a whole can of worms that is well beyond the scope of the course. I do think it would be awesome if they had a sequel that did this, but I think it doesn&#x27;t make sense in the context of the existing course.</div><br/></div></div><div id="38739422" class="c"><input type="checkbox" id="c-38739422" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#38736552">parent</a><span>|</span><a href="#38739320">prev</a><span>|</span><a href="#38736841">next</a><span>|</span><label class="collapse" for="c-38739422">[-]</label><label class="expand" for="c-38739422">[1 more]</label></div><br/><div class="children"><div class="content">This was my experience with the course as well. It was fun but not useful.<p>Learning Verilog later really opened the world of digital design for me and has let me build actually useful things. It&#x27;s probably a non-goal though for this coarse to turn people into digital designers, this seems more aimed at people with a passing interest in HW as opposed to those who really want to go deep.</div><br/></div></div><div id="38736841" class="c"><input type="checkbox" id="c-38736841" checked=""/><div class="controls bullet"><span class="by">warkanlock</span><span>|</span><a href="#38736552">parent</a><span>|</span><a href="#38739422">prev</a><span>|</span><a href="#38737872">next</a><span>|</span><label class="collapse" for="c-38736841">[-]</label><label class="expand" for="c-38736841">[2 more]</label></div><br/><div class="children"><div class="content">Knowing Verilog, I must disagree. Although it would be more beneficial if the book focused on hardware, its primary goal is to teach something other than hardware-specific definitions. HDL serves as a bridge to illustrate communication with predefined logic gates.<p>The book should include a mention or an appendix to clarify its real-world applications. By the end of chapter five, I was dissatisfied, feeling a lack of control over the crucial aspects of the hardware I just built. However, a book can only do justice to some of the missing pieces of information we have.</div><br/><div id="38739402" class="c"><input type="checkbox" id="c-38739402" checked=""/><div class="controls bullet"><span class="by">brailsafe</span><span>|</span><a href="#38736552">root</a><span>|</span><a href="#38736841">parent</a><span>|</span><a href="#38737872">next</a><span>|</span><label class="collapse" for="c-38739402">[-]</label><label class="expand" for="c-38739402">[1 more]</label></div><br/><div class="children"><div class="content">I found Chapter 5 to be quite challenging, largely because it took a while to understand the combinatorial way in which any of the chip parts would get new inputs and so on, especially coming from a traditional sequential programming background.<p>What specifically did you feel like you were lacking from the language?</div><br/></div></div></div></div></div></div><div id="38737872" class="c"><input type="checkbox" id="c-38737872" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38736552">prev</a><span>|</span><a href="#38737573">next</a><span>|</span><label class="collapse" for="c-38737872">[-]</label><label class="expand" for="c-38737872">[10 more]</label></div><br/><div class="children"><div class="content">I wish there was something like that for computability theory.<p>Presumably for historical reasons, professors of theoretical computer science love to talk about abstract machines like finite-state machines, pushdown automata, Turing machines etc. Not about logical circuits.<p>But arguably, logical gates are much more conceptually primitive than most of those automata above! They are basically an implementation of propositional logic, albeit potentially with a dimension of time and delay. And they are nonetheless somewhat close to how actual computers work. So why do they ignore them as a model of computation?<p>My guess is that they don&#x27;t talk about them because they only awkwardly harmonize with the classical models of computation: FSMs, TMs and the like, and the neat hierarchy of computability they place them (what languages in the Chomsky hierarchy they recognize).<p>For example, Turing machines have two kinds of states: Objects called &quot;states&quot;, and the states of the tape cells. The former are finite and the latter are infinite. Pushdown automata make a similar distinction into two types of states. Logical circuits, on the other hand, don&#x27;t distinguish two different kinds of states in such a way. It&#x27;s all just circuits.<p>The classical abstract machines have other problems as well: Arguably, among abstract machines, a real CPU is most similar to a universal Turing machine, because it can execute arbitrary programs. But according to the theory of computation, CPUs are merely equivalent to finite-state machines! Because they lack an equivalent of an infinite tape. Infinity is a strange detail to emphasize here, as logical circuits are merely &quot;potentially infinite&quot; in the same way finite-state machines are merely potentially infinite. But that doesn&#x27;t make them similar to each other. The relevant difference seems to be that circuits with delay allow for &quot;memory&quot; (like flip-flops), while finite-state automata don&#x27;t.<p>I would like to see a course or book on theoretical computer science that tackles this issue: &quot;From NAND to Turing Machines&quot;.</div><br/><div id="38738796" class="c"><input type="checkbox" id="c-38738796" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#38737872">parent</a><span>|</span><a href="#38737932">next</a><span>|</span><label class="collapse" for="c-38738796">[-]</label><label class="expand" for="c-38738796">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But arguably, logical gates are much more conceptually primitive than most of those automata above! They are basically an implementation of propositional logic, albeit potentially with a dimension of time and delay. And they are nonetheless somewhat close to how actual computers work. So why do they ignore them as a model of computation?<p>Simple: logic circuits for propositional logic are not Turing-complete, and in a lecture about theoretical computer science one wants to teach such more sophisticated, mathematical models of computation.<p>On the other hand, in basically every beginner lecture about computer engineering (in German: &quot;technische Informatik&quot;), they will teach you how how the transition function of a finite-state machine can be implemented via combinational logic (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Combinational_logic" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Combinational_logic</a>), which can be transformed into logic gates for implementing a Mealy machine (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mealy_machine" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mealy_machine</a>) or Moore machine (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Moore_machine" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Moore_machine</a>) in hardware.</div><br/><div id="38739197" class="c"><input type="checkbox" id="c-38739197" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38737872">root</a><span>|</span><a href="#38738796">parent</a><span>|</span><a href="#38737932">next</a><span>|</span><label class="collapse" for="c-38739197">[-]</label><label class="expand" for="c-38739197">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Simple: logic circuits for propositional logic are not Turing-complete, and in a lecture about theoretical computer science one wants to teach such more sophisticated, mathematical models of computation.<p>Logical circuits with delay (sequential [1] rather than combinational logic) are indeed not Turing complete -- but in the same uninteresting sense that a CPU is not Turing complete: In a conceptually irrelevant way. As I argued, Turing machines are precisely <i>not</i> &quot;much more sophisticated&quot; than CPUs or the circuits they are made out of. Turing machines merely have infinite rather than potentially infinite memory.<p>You could modify the concept of a Turing machine such that its tape is potentially rather than actually infinite, and it would change nothing of substance. Yet this machine would suddenly only be considered equivalent to a finite-state machine.<p>Apart from that, a perhaps theoretically interesting point about combinational logic (circuits without time&#x2F;delay) and finite state machines would be that combinational logic is apparently computationally weaker than finite-state machines. Wikipedia doesn&#x27;t say anything about that explicitly, but the &quot;classes of automata&quot; image [2] they include in the article does suggest it. But that, assuming it&#x27;s true, should be taught in theoretical computer science class, not in computer engineering (if the latter mentions it at all).<p>But, much more importantly, they -- the theoretical computer science professors, not the engineering guys -- should explain the theoretical relation between circuits with delay (sequential logic) and various automata, including Turing machines.<p>The likely fact is that they ignore circuits because they don&#x27;t fit well into their supposedly neat picture of abstract machines. In fact, they call their reliance on infinity as an important difference between models of computation in question.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequential_logic" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequential_logic</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;File:Automata_theory.svg" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;File:Automata_theory.svg</a></div><br/></div></div></div></div><div id="38737932" class="c"><input type="checkbox" id="c-38737932" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38737872">parent</a><span>|</span><a href="#38738796">prev</a><span>|</span><a href="#38737914">next</a><span>|</span><label class="collapse" for="c-38737932">[-]</label><label class="expand" for="c-38737932">[5 more]</label></div><br/><div class="children"><div class="content">as you say, the chomsky hierarchy is surely an influence, but i don&#x27;t think that&#x27;s the main thing<p>i think it&#x27;s probably because a turing machine can do universal computation and can be described completely in a couple of paragraphs, while you need at least several hundred logic gates to describe something that can do universal computation (if you give it infinite memory), and then you still don&#x27;t have a convincing argument that what it does is <i>universal</i> in any interesting sense<p>until you bring in turing machines, anyway<p>you can write a turing machine in about one line of c; the description of a computer in terms of nands doesn&#x27;t give you that</div><br/><div id="38738188" class="c"><input type="checkbox" id="c-38738188" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38737872">root</a><span>|</span><a href="#38737932">parent</a><span>|</span><a href="#38739512">next</a><span>|</span><label class="collapse" for="c-38738188">[-]</label><label class="expand" for="c-38738188">[2 more]</label></div><br/><div class="children"><div class="content">That seems to be a somewhat strange comparison. Logical circuits are arguably not much more complex than finite-state machines, and theoretical computer science professors don&#x27;t have an aversion to those. So it doesn&#x27;t seem like they find logical circuits too primitive. They even seem to strive for primitivity, as Turing machines are much more conceptually primitive than things like register machines or actual CPUs.<p>Moreover, a logical circuit itself is actually easier to describe than a Turing machine. Both logical circuits with delay and Turing machines can do &quot;universal computation&quot; for any reasonable sense of the term (demanding an infinite element is arguably not reasonable).<p>And to give a &quot;convincing argument&quot; that they are universal is quite difficult even for Turing machines. What would such an argument even be? In practice, it&#x27;s more the fact that there are <i>no known counterexamples</i> which causes us to believe in the Church-Turing thesis (that any problem that we would intuitively consider &quot;computable&quot; is also computable with a Turing machine or logical circuit, and vice versa), rather than any one (positive) &quot;convincing argument&quot;.</div><br/><div id="38741934" class="c"><input type="checkbox" id="c-38741934" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38737872">root</a><span>|</span><a href="#38738188">parent</a><span>|</span><a href="#38739512">next</a><span>|</span><label class="collapse" for="c-38741934">[-]</label><label class="expand" for="c-38741934">[1 more]</label></div><br/><div class="children"><div class="content">a nand gate is not too primitive, of course, but building an actual cpu out of nand gates involves several hundred of them, and that circuit is harder to describe than a universal turing machine<p>turing&#x27;s original paper gave a convincing argument that turing machines were universal; he said that they could do anything a mathematician could do, since the mathematician can only hold a finite number of symbols from a finite set in his memory at once, and can only fit a finite set of symbols from a finite set on a page in his field of view.  so the squares on the turing-machine tape were originally pages in a notebook<p>it seems like you would benefit more from exposing yourself to things you find strange; you could start by reading turing&#x27;s strange paper <a href="https:&#x2F;&#x2F;www.cs.virginia.edu&#x2F;~robins&#x2F;Turing_Paper_1936.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.virginia.edu&#x2F;~robins&#x2F;Turing_Paper_1936.pdf</a><p>strangeness doesn&#x27;t guarantee insightfulness, but it&#x27;s a necessary precondition to it; if you continue to dismiss all strange arguments you will dismiss everything from which you could possibly learn anything, preserving your ignorance like a precious jewel</div><br/></div></div></div></div><div id="38739512" class="c"><input type="checkbox" id="c-38739512" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#38737872">root</a><span>|</span><a href="#38737932">parent</a><span>|</span><a href="#38738188">prev</a><span>|</span><a href="#38737914">next</a><span>|</span><label class="collapse" for="c-38739512">[-]</label><label class="expand" for="c-38739512">[2 more]</label></div><br/><div class="children"><div class="content">You might get more mileage out of Abstract, State Machines. They operate on structures instead of characters. Quite a few tools exist for them, too.</div><br/><div id="38741919" class="c"><input type="checkbox" id="c-38741919" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38737872">root</a><span>|</span><a href="#38739512">parent</a><span>|</span><a href="#38737914">next</a><span>|</span><label class="collapse" for="c-38741919">[-]</label><label class="expand" for="c-38741919">[1 more]</label></div><br/><div class="children"><div class="content">not sure what you mean but i&#x27;m glad to hear from you again</div><br/></div></div></div></div></div></div><div id="38737914" class="c"><input type="checkbox" id="c-38737914" checked=""/><div class="controls bullet"><span class="by">credit_guy</span><span>|</span><a href="#38737872">parent</a><span>|</span><a href="#38737932">prev</a><span>|</span><a href="#38737573">next</a><span>|</span><label class="collapse" for="c-38737914">[-]</label><label class="expand" for="c-38737914">[2 more]</label></div><br/><div class="children"><div class="content">Maybe something like this?<p><a href="https:&#x2F;&#x2F;computationbook.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;computationbook.com&#x2F;</a></div><br/><div id="38738291" class="c"><input type="checkbox" id="c-38738291" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38737872">root</a><span>|</span><a href="#38737914">parent</a><span>|</span><a href="#38737573">next</a><span>|</span><label class="collapse" for="c-38738291">[-]</label><label class="expand" for="c-38738291">[1 more]</label></div><br/><div class="children"><div class="content">Judging from the overview, they seem to implement classical abstract machines using Ruby. Implementing something relatively simple (an abstract machine) with something complex (Ruby) is quite unilluminating. I was asking for someone who implements them using logical circuits. While also explaining how their different &quot;power&quot; (in terms of languages they recognize in the Chomsky hierarchy) is reflected in their logical circuits.</div><br/></div></div></div></div></div></div><div id="38737573" class="c"><input type="checkbox" id="c-38737573" checked=""/><div class="controls bullet"><span class="by">Kortaggio</span><span>|</span><a href="#38737872">prev</a><span>|</span><a href="#38735639">next</a><span>|</span><label class="collapse" for="c-38737573">[-]</label><label class="expand" for="c-38737573">[3 more]</label></div><br/><div class="children"><div class="content">This was an amazing course and is one of the most rewarding computer science courses I&#x27;ve taken! I loved that there was nothing left to &quot;magic&quot; and it was the first time I felt like I understood the &quot;full stack&quot; of the Java-like code I was writing right down to the transistors.<p>Self-plug for a full-blown minesweeper game I made for the final project: <a href="https:&#x2F;&#x2F;github.com&#x2F;billmei&#x2F;nand2minesweeper">https:&#x2F;&#x2F;github.com&#x2F;billmei&#x2F;nand2minesweeper</a> It&#x27;s a complete game with a tutorial, custom RNG, and unit tests, using their hardware simulator.</div><br/><div id="38740767" class="c"><input type="checkbox" id="c-38740767" checked=""/><div class="controls bullet"><span class="by">mentos</span><span>|</span><a href="#38737573">parent</a><span>|</span><a href="#38735639">next</a><span>|</span><label class="collapse" for="c-38740767">[-]</label><label class="expand" for="c-38740767">[2 more]</label></div><br/><div class="children"><div class="content">How many hours&#x2F;weeks would you estimate it took you to complete the course?</div><br/><div id="38741460" class="c"><input type="checkbox" id="c-38741460" checked=""/><div class="controls bullet"><span class="by">Kortaggio</span><span>|</span><a href="#38737573">root</a><span>|</span><a href="#38740767">parent</a><span>|</span><a href="#38735639">next</a><span>|</span><label class="collapse" for="c-38741460">[-]</label><label class="expand" for="c-38741460">[1 more]</label></div><br/><div class="children"><div class="content">Part 1 was significantly easier than Part 2; Part 1 (the hardware part) only took 2 weekends for me, but <i>every assignment</i> on Part 2 took several weekends each. Granted, this was also because I was learning about operating systems and compilers at the same time; if you&#x27;re already familiar you could considering skipping Part 2 altogether, or otherwise you might have an easier time than I did.</div><br/></div></div></div></div></div></div><div id="38735639" class="c"><input type="checkbox" id="c-38735639" checked=""/><div class="controls bullet"><span class="by">grendelt</span><span>|</span><a href="#38737573">prev</a><span>|</span><a href="#38741365">next</a><span>|</span><label class="collapse" for="c-38735639">[-]</label><label class="expand" for="c-38735639">[1 more]</label></div><br/><div class="children"><div class="content">The book is great - so, so cool seeing the layer upon layer of logic (and abstractions) that build up.</div><br/></div></div><div id="38741365" class="c"><input type="checkbox" id="c-38741365" checked=""/><div class="controls bullet"><span class="by">nyxtom</span><span>|</span><a href="#38735639">prev</a><span>|</span><a href="#38737194">next</a><span>|</span><label class="collapse" for="c-38741365">[-]</label><label class="expand" for="c-38741365">[1 more]</label></div><br/><div class="children"><div class="content">Loved this course, seriously one of my all time favorites end to end. Have yet to find a course that had the same level of fluid journey</div><br/></div></div><div id="38737194" class="c"><input type="checkbox" id="c-38737194" checked=""/><div class="controls bullet"><span class="by">kebsup</span><span>|</span><a href="#38741365">prev</a><span>|</span><a href="#38736437">next</a><span>|</span><label class="collapse" for="c-38737194">[-]</label><label class="expand" for="c-38737194">[4 more]</label></div><br/><div class="children"><div class="content">What I remember from this course is that the first few homeworks can be done in a few hours in one evening, and then you suddenly spend your weekend building a compiler.</div><br/><div id="38737840" class="c"><input type="checkbox" id="c-38737840" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38737194">parent</a><span>|</span><a href="#38736437">next</a><span>|</span><label class="collapse" for="c-38737840">[-]</label><label class="expand" for="c-38737840">[3 more]</label></div><br/><div class="children"><div class="content">So, here the question I want to ask someone who dealt with this course:<p>How much of the topic of compilers is covered in this course? Have you built an optimizing compiler that creates binaries from a [relatively] high-level language such as C?  Or you have just created an assembly for a specific architecture?</div><br/><div id="38741141" class="c"><input type="checkbox" id="c-38741141" checked=""/><div class="controls bullet"><span class="by">CatchSwitch</span><span>|</span><a href="#38737194">root</a><span>|</span><a href="#38737840">parent</a><span>|</span><a href="#38738920">next</a><span>|</span><label class="collapse" for="c-38741141">[-]</label><label class="expand" for="c-38741141">[1 more]</label></div><br/><div class="children"><div class="content">It mimics Java, so your compiler compiles to a bytecode IR. The compiler as described by the book is a bare-bones recursive descent compiler that doesn&#x27;t do any AST analysis. The compiler is for a toy language called Jack (fake Java) that was intentionally designed to be easy to write a compiler for. L(1) grammar I believe. They don&#x27;t really talk about error handling or more complex compiler topics. No optimization methods are covered.<p>N2Tetris is like doing the 20% to get the 80% of every layer of abstraction. It really scopes down each project so you can cover every layer between logic gates and a high level language with built in OS APIs. I think it&#x27;s a fantastic course but if you&#x27;re looking to learn specifically about compilers I&#x27;m not sure if it&#x27;ll meet your needs.</div><br/></div></div><div id="38738920" class="c"><input type="checkbox" id="c-38738920" checked=""/><div class="controls bullet"><span class="by">rmshin</span><span>|</span><a href="#38737194">root</a><span>|</span><a href="#38737840">parent</a><span>|</span><a href="#38741141">prev</a><span>|</span><a href="#38736437">next</a><span>|</span><label class="collapse" for="c-38738920">[-]</label><label class="expand" for="c-38738920">[1 more]</label></div><br/><div class="children"><div class="content">Without too much experience in writing compilers beyond this course, I&#x27;d say that the course focuses on grounding your conceptual&#x2F;intuitive knowledge of how compilers work rather than any serious exposition into modern-day production-grade compilers.<p>You write the assembler for the course&#x27;s own hardware architecture called Hack, then a compiler backend that converts a stack-based VM intermediate representation (IR) to assembly, and finally a compiler frontend that does syntax analysis and code generation to translate the book&#x27;s high-level language Jack to the IR.</div><br/></div></div></div></div></div></div><div id="38736437" class="c"><input type="checkbox" id="c-38736437" checked=""/><div class="controls bullet"><span class="by">cadr</span><span>|</span><a href="#38737194">prev</a><span>|</span><a href="#38735751">next</a><span>|</span><label class="collapse" for="c-38736437">[-]</label><label class="expand" for="c-38736437">[1 more]</label></div><br/><div class="children"><div class="content">My favorite thing about the book is that each section builds on things, but you don&#x27;t have to go through the whole thing to get there.  So, for example, if you did a lot of hardware in the past but never got around to writing a compiler, you could in theory start there.  Or if you did a lot of software before but never actually built an ALU, etc, you can get a lot out of just doing the hardware sections.</div><br/></div></div><div id="38738620" class="c"><input type="checkbox" id="c-38738620" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#38735751">prev</a><span>|</span><a href="#38737853">next</a><span>|</span><label class="collapse" for="c-38738620">[-]</label><label class="expand" for="c-38738620">[1 more]</label></div><br/><div class="children"><div class="content">This is a great course, well put together, and very fun.<p>I did the second part in Haskell too! I wasn&#x27;t sure what their container environment is like so I stuck with only the `base` library and it worked out well enough.</div><br/></div></div><div id="38737853" class="c"><input type="checkbox" id="c-38737853" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38738620">prev</a><span>|</span><a href="#38740458">next</a><span>|</span><label class="collapse" for="c-38737853">[-]</label><label class="expand" for="c-38737853">[1 more]</label></div><br/><div class="children"><div class="content">Similar: &quot;Show HN: Tetris, but the blocks are ARM instructions that execute in the browser&quot; <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37086102">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37086102</a></div><br/></div></div><div id="38740458" class="c"><input type="checkbox" id="c-38740458" checked=""/><div class="controls bullet"><span class="by">mitsu_at</span><span>|</span><a href="#38737853">prev</a><span>|</span><a href="#38735311">next</a><span>|</span><label class="collapse" for="c-38740458">[-]</label><label class="expand" for="c-38740458">[1 more]</label></div><br/><div class="children"><div class="content">Reminded of the Code Golf challenge to build a working game of Tetris in Conway&#x27;s Game of Life: <a href="https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;questions&#x2F;11880&#x2F;build-a-working-game-of-tetris-in-conways-game-of-life" rel="nofollow noreferrer">https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;questions&#x2F;11880&#x2F;build-a-w...</a></div><br/></div></div><div id="38735311" class="c"><input type="checkbox" id="c-38735311" checked=""/><div class="controls bullet"><span class="by">ess3</span><span>|</span><a href="#38740458">prev</a><span>|</span><a href="#38735891">next</a><span>|</span><label class="collapse" for="c-38735311">[-]</label><label class="expand" for="c-38735311">[1 more]</label></div><br/><div class="children"><div class="content">Cannot recommend this course enough</div><br/></div></div><div id="38735891" class="c"><input type="checkbox" id="c-38735891" checked=""/><div class="controls bullet"><span class="by">datameta</span><span>|</span><a href="#38735311">prev</a><span>|</span><a href="#38735894">next</a><span>|</span><label class="collapse" for="c-38735891">[-]</label><label class="expand" for="c-38735891">[1 more]</label></div><br/><div class="children"><div class="content">I intend to pick back up from where I left off about a year and a half ago, I believe chapter 6. Super interesting project where I learned a lot about using an HDL, computer architecture, and gates in general.</div><br/></div></div><div id="38735894" class="c"><input type="checkbox" id="c-38735894" checked=""/><div class="controls bullet"><span class="by">pkilgore</span><span>|</span><a href="#38735891">prev</a><span>|</span><a href="#38736408">next</a><span>|</span><label class="collapse" for="c-38735894">[-]</label><label class="expand" for="c-38735894">[1 more]</label></div><br/><div class="children"><div class="content">I graduated from this and I cannot recommend it highly enough.<p>If you don&#x27;t have a computer science or EE background, it completely de-mystifies the fundamentals of your machine in a deeply engaging way.</div><br/></div></div><div id="38736408" class="c"><input type="checkbox" id="c-38736408" checked=""/><div class="controls bullet"><span class="by">atulvi</span><span>|</span><a href="#38735894">prev</a><span>|</span><a href="#38740534">next</a><span>|</span><label class="collapse" for="c-38736408">[-]</label><label class="expand" for="c-38736408">[3 more]</label></div><br/><div class="children"><div class="content">I want sand2tetris next.</div><br/><div id="38736457" class="c"><input type="checkbox" id="c-38736457" checked=""/><div class="controls bullet"><span class="by">JKCalhoun</span><span>|</span><a href="#38736408">parent</a><span>|</span><a href="#38738371">next</a><span>|</span><label class="collapse" for="c-38736457">[-]</label><label class="expand" for="c-38736457">[1 more]</label></div><br/><div class="children"><div class="content">Sand2NAND is the only thing missing.<p>I&#x27;m reminded though of the late Dave Gingery&#x27;s series of books, <i>Shop From Scrap</i> [1] where he tries to take you from building a foundry up to machine tools:<p>[1] <a href="https:&#x2F;&#x2F;gingerybookstore.com&#x2F;MetalWorkingShopFromScrapSeries.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gingerybookstore.com&#x2F;MetalWorkingShopFromScrapSeries...</a></div><br/></div></div><div id="38738371" class="c"><input type="checkbox" id="c-38738371" checked=""/><div class="controls bullet"><span class="by">shpx</span><span>|</span><a href="#38736408">parent</a><span>|</span><a href="#38736457">prev</a><span>|</span><a href="#38740534">next</a><span>|</span><label class="collapse" for="c-38738371">[-]</label><label class="expand" for="c-38738371">[1 more]</label></div><br/><div class="children"><div class="content">Still waiting for Quantum Mechanics to Tetris</div><br/></div></div></div></div><div id="38740534" class="c"><input type="checkbox" id="c-38740534" checked=""/><div class="controls bullet"><span class="by">yeswecatan</span><span>|</span><a href="#38736408">prev</a><span>|</span><a href="#38735983">next</a><span>|</span><label class="collapse" for="c-38740534">[-]</label><label class="expand" for="c-38740534">[1 more]</label></div><br/><div class="children"><div class="content">Those who have completed this, do you recommend the book or MOOC?</div><br/></div></div><div id="38735983" class="c"><input type="checkbox" id="c-38735983" checked=""/><div class="controls bullet"><span class="by">jackphilson</span><span>|</span><a href="#38740534">prev</a><span>|</span><a href="#38736253">next</a><span>|</span><label class="collapse" for="c-38735983">[-]</label><label class="expand" for="c-38735983">[16 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m into web development, how practically useful is learning low level stuff like this, factoring in opportunity cost?</div><br/><div id="38736579" class="c"><input type="checkbox" id="c-38736579" checked=""/><div class="controls bullet"><span class="by">brailsafe</span><span>|</span><a href="#38735983">parent</a><span>|</span><a href="#38736086">next</a><span>|</span><label class="collapse" for="c-38736579">[-]</label><label class="expand" for="c-38736579">[2 more]</label></div><br/><div class="children"><div class="content">It depends whether you have any opportunities at the moment that are directly attributable to a singular focus on &quot;web development&quot;. That&#x27;s not a productive or healthy way to look at things imo—though it might seem like it if you&#x27;re relatively knew—but if your prospects are good right now, then this won&#x27;t help you necessarily keep your current job or get another one. It will help you reason about code, logic, and computers in a way you wouldn&#x27;t otherwise, but you&#x27;ll have a hard time if you&#x27;re not enthusiastic about learning for the novelty of it, because it will eventually be quite challenging and you&#x27;ll need to allocate significant amounts of time.<p>I say that it&#x27;s not a productive way to look at it, because intensity and longevity of singular professional focus only lasts as long as your intellectual and physical infrastructure around it, which means doing things that are somewhere between a short and long distance away from your core subject; sleeping, learning fundamentals, algorithms, design, hiking etc.. (Web Dev, as with anything, can get just as intensely unstimulating as it can stimulating)<p>Also, learning how your language kind of gets compiled is just fascinating.</div><br/><div id="38738417" class="c"><input type="checkbox" id="c-38738417" checked=""/><div class="controls bullet"><span class="by">brailsafe</span><span>|</span><a href="#38735983">root</a><span>|</span><a href="#38736579">parent</a><span>|</span><a href="#38736086">next</a><span>|</span><label class="collapse" for="c-38738417">[-]</label><label class="expand" for="c-38738417">[1 more]</label></div><br/><div class="children"><div class="content">To elaborate on this slightly, when I eventually burnt out from just grinding frontend and working a stressful frontend job, I spoke to someone much more experienced than me in medicine who suggested that basically anything can be interesting if you keep going deeper. That&#x27;s stuck with me in the 6 years since, and I don&#x27;t worry much about drilling web stuff as much</div><br/></div></div></div></div><div id="38736086" class="c"><input type="checkbox" id="c-38736086" checked=""/><div class="controls bullet"><span class="by">gorjusborg</span><span>|</span><a href="#38735983">parent</a><span>|</span><a href="#38736579">prev</a><span>|</span><a href="#38736025">next</a><span>|</span><label class="collapse" for="c-38736086">[-]</label><label class="expand" for="c-38736086">[7 more]</label></div><br/><div class="children"><div class="content">I see this question as analogous to &#x27;how useful is building a car from scratch?&#x27;<p>The person building a cat from scratch will undoubtedly understand more than others, and may be able to fix that home brew car. They may, with some difficulty be able to apply that understanding to other cars.<p>But, you definitely don&#x27;t need to build a car from scratch to be a race car driver.</div><br/><div id="38736225" class="c"><input type="checkbox" id="c-38736225" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#38735983">root</a><span>|</span><a href="#38736086">parent</a><span>|</span><a href="#38736025">next</a><span>|</span><label class="collapse" for="c-38736225">[-]</label><label class="expand" for="c-38736225">[6 more]</label></div><br/><div class="children"><div class="content"><i>building a cat from scratch </i><p>That <i>would</i> be an interesting project.</div><br/><div id="38736883" class="c"><input type="checkbox" id="c-38736883" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#38735983">root</a><span>|</span><a href="#38736225">parent</a><span>|</span><a href="#38736025">next</a><span>|</span><label class="collapse" for="c-38736883">[-]</label><label class="expand" for="c-38736883">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>building a cat from scratch</i><p>&gt; That <i>would</i> be an interesting project.<p>Here is the source code of the OpenBSD implementation of cat:<p>&gt; <a href="https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;bin&#x2F;cat&#x2F;cat.c">https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;bin&#x2F;cat&#x2F;cat.c</a><p>and here of the GNU coreutils implementation:<p>&gt; <a href="https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;cat.c">https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;cat.c</a><p>Thus: I don&#x27;t think building a cat from scratch or creating a tutorial about that topic is particularly hard (even though the HN audience would likely be interested in it). :-)</div><br/><div id="38737103" class="c"><input type="checkbox" id="c-38737103" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38735983">root</a><span>|</span><a href="#38736883">parent</a><span>|</span><a href="#38738818">next</a><span>|</span><label class="collapse" for="c-38737103">[-]</label><label class="expand" for="c-38737103">[1 more]</label></div><br/><div class="children"><div class="content">Building a shell from scratch (or some pre-made starting point) seems to be an exercise in a lot of operating systems courses and also in Tanenbaum&#x27;s book on Operating Systems.<p>There is this guide, divided in parts:
<a href="https:&#x2F;&#x2F;github.com&#x2F;tokenrove&#x2F;build-your-own-shell">https:&#x2F;&#x2F;github.com&#x2F;tokenrove&#x2F;build-your-own-shell</a><p>I think you right, and implementing core utils is a nice exercise in system programming.
Maybe, it even can be used to create some automated tasks with tests on codewars.<p>Once upon a time I implemented expr(1) but it was too simple, without regex part.</div><br/></div></div><div id="38738818" class="c"><input type="checkbox" id="c-38738818" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#38735983">root</a><span>|</span><a href="#38736883">parent</a><span>|</span><a href="#38737103">prev</a><span>|</span><a href="#38736025">next</a><span>|</span><label class="collapse" for="c-38738818">[-]</label><label class="expand" for="c-38738818">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m 99% sure that kjs3 was joking about building the kind of cat that goes &quot;meow&quot;, not a program. ;)</div><br/><div id="38739236" class="c"><input type="checkbox" id="c-38739236" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#38735983">root</a><span>|</span><a href="#38738818">parent</a><span>|</span><a href="#38739060">next</a><span>|</span><label class="collapse" for="c-38739236">[-]</label><label class="expand" for="c-38739236">[1 more]</label></div><br/><div class="children"><div class="content">You should then alias &quot;cat&quot; to print &quot;meow&quot; instead of concatenating files.<p>;-) ;-) ;-)</div><br/></div></div><div id="38739060" class="c"><input type="checkbox" id="c-38739060" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#38735983">root</a><span>|</span><a href="#38738818">parent</a><span>|</span><a href="#38739236">prev</a><span>|</span><a href="#38736025">next</a><span>|</span><label class="collapse" for="c-38739060">[-]</label><label class="expand" for="c-38739060">[1 more]</label></div><br/><div class="children"><div class="content">100%.  And considering the OP mistyped &quot;car&quot; as &quot;cat&quot;, I&#x27;m really, really hoping   
aleph_minus_one was making a different kind of attempt at humor, but around here you never know.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38736025" class="c"><input type="checkbox" id="c-38736025" checked=""/><div class="controls bullet"><span class="by">frakt0x90</span><span>|</span><a href="#38735983">parent</a><span>|</span><a href="#38736086">prev</a><span>|</span><a href="#38737606">next</a><span>|</span><label class="collapse" for="c-38736025">[-]</label><label class="expand" for="c-38736025">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion, learning anything in your field is useful because it helps you form a better mental representation of what you&#x27;re doing. Will building electronics directly help with mundane web dev? Maybe not. But if you think it&#x27;s cool, do it! Have fun! Broaden your horizons!</div><br/></div></div><div id="38737606" class="c"><input type="checkbox" id="c-38737606" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38735983">parent</a><span>|</span><a href="#38736025">prev</a><span>|</span><a href="#38736413">next</a><span>|</span><label class="collapse" for="c-38737606">[-]</label><label class="expand" for="c-38737606">[1 more]</label></div><br/><div class="children"><div class="content">As a backend web developer you can learn about the difference in pre-fork and polling model  in web servers, which interconnected with c10k<p><a href="http:&#x2F;&#x2F;www.kegel.com&#x2F;c10k.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.kegel.com&#x2F;c10k.html</a><p>This will give you ability to reason about the web server configuration you want to use.<p>But both fork(2) and epoll(7) [kqueue(2), iocp] would stay at low level relatively of place where you operate.<p>Don&#x27;t know what to say about fronted though, but there are probably some new points of view on JS you can get by implementing it as an interpreter in courses like crafting interpreters.</div><br/></div></div><div id="38736413" class="c"><input type="checkbox" id="c-38736413" checked=""/><div class="controls bullet"><span class="by">jobs_throwaway</span><span>|</span><a href="#38735983">parent</a><span>|</span><a href="#38737606">prev</a><span>|</span><a href="#38736897">next</a><span>|</span><label class="collapse" for="c-38736413">[-]</label><label class="expand" for="c-38736413">[1 more]</label></div><br/><div class="children"><div class="content">Understanding intuitively how compilers work, and how the various translators to&#x2F;from VMs and machine code, is, I think, pretty useful. Maybe not in day-to-day web dev work, but it will help you around the edges.</div><br/></div></div><div id="38737884" class="c"><input type="checkbox" id="c-38737884" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38735983">parent</a><span>|</span><a href="#38736897">prev</a><span>|</span><a href="#38736211">next</a><span>|</span><label class="collapse" for="c-38737884">[-]</label><label class="expand" for="c-38737884">[1 more]</label></div><br/><div class="children"><div class="content">opportunity cost is like 100 hours, which is pretty small<p>usefulness for web development is that probably right now there are things you think are &#x27;too hard&#x27; or even inconceivable<p>after those 100 hours nothing will be inconceivable</div><br/></div></div><div id="38736211" class="c"><input type="checkbox" id="c-38736211" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#38735983">parent</a><span>|</span><a href="#38737884">prev</a><span>|</span><a href="#38736253">next</a><span>|</span><label class="collapse" for="c-38736211">[-]</label><label class="expand" for="c-38736211">[1 more]</label></div><br/><div class="children"><div class="content">If opportunity cost is how you decide such things, I&#x27;m guessing this is not for you.  There&#x27;s undoubtedly some new JS framework that&#x27;s about to be The Next Big Thing.</div><br/></div></div></div></div><div id="38736253" class="c"><input type="checkbox" id="c-38736253" checked=""/><div class="controls bullet"><span class="by">j_m_b</span><span>|</span><a href="#38735983">prev</a><span>|</span><a href="#38736197">next</a><span>|</span><label class="collapse" for="c-38736253">[-]</label><label class="expand" for="c-38736253">[1 more]</label></div><br/><div class="children"><div class="content">I loved and completed this course, just wish I could actually be working on this in my day job!</div><br/></div></div><div id="38736197" class="c"><input type="checkbox" id="c-38736197" checked=""/><div class="controls bullet"><span class="by">mnsc</span><span>|</span><a href="#38736253">prev</a><span>|</span><a href="#38736014">next</a><span>|</span><label class="collapse" for="c-38736197">[-]</label><label class="expand" for="c-38736197">[6 more]</label></div><br/><div class="children"><div class="content">Is the estimated hours realistic? 43 hours for part 1 and 89 for part.</div><br/><div id="38736540" class="c"><input type="checkbox" id="c-38736540" checked=""/><div class="controls bullet"><span class="by">dbrueck</span><span>|</span><a href="#38736197">parent</a><span>|</span><a href="#38736406">next</a><span>|</span><label class="collapse" for="c-38736540">[-]</label><label class="expand" for="c-38736540">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;ll vary a lot by your background and how much you play around along the way.<p>If you&#x27;re pretty familiar with most of the concepts and stick to the requirements, you can do the whole thing in 40-50h. OTOH, if you&#x27;re encountering new concepts and really want to internalize them and&#x2F;or if you take fun detours then I&#x27;d plan on 100-150h or more.</div><br/><div id="38739331" class="c"><input type="checkbox" id="c-38739331" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#38736197">root</a><span>|</span><a href="#38736540">parent</a><span>|</span><a href="#38736406">next</a><span>|</span><label class="collapse" for="c-38739331">[-]</label><label class="expand" for="c-38739331">[1 more]</label></div><br/><div class="children"><div class="content">It also varies by how professional you provide your solutions. If you start wanting to test things, give proper errors, etc., it will start increasing the time needed by quite a lot.</div><br/></div></div></div></div><div id="38736406" class="c"><input type="checkbox" id="c-38736406" checked=""/><div class="controls bullet"><span class="by">brailsafe</span><span>|</span><a href="#38736197">parent</a><span>|</span><a href="#38736540">prev</a><span>|</span><a href="#38736396">next</a><span>|</span><label class="collapse" for="c-38736406">[-]</label><label class="expand" for="c-38736406">[1 more]</label></div><br/><div class="children"><div class="content">Much like any software, it depends on how quickly you get the hang of it, how many blocks of good time you can allocate, and what your existing exposure is to digital logic and circuits.<p>I&#x27;m on the final chapter of the hardware section after probably 5 months, where the last 2 months haven&#x27;t been nearly as focused and it showed immediately in my progress, and overall I feel like my success rate looks like a bell curve; confusing at first and slow, then not confusing and more productive, and then the CPU took me like a month of taking periodic goes at it. Now at the assembler, I feel like this the easier part of any sequential programming involved in the latter half of the course, and it&#x27;ll ramp up significantly.<p>89 seems plausible, if you get lucky, have good combinatorial logic exposure already, and can really dedicate a decent portion of most days to it, but I&#x27;d probably say that&#x27;s a generous minimum.</div><br/></div></div><div id="38736396" class="c"><input type="checkbox" id="c-38736396" checked=""/><div class="controls bullet"><span class="by">jobs_throwaway</span><span>|</span><a href="#38736197">parent</a><span>|</span><a href="#38736406">prev</a><span>|</span><a href="#38737110">next</a><span>|</span><label class="collapse" for="c-38736396">[-]</label><label class="expand" for="c-38736396">[1 more]</label></div><br/><div class="children"><div class="content">Sounds about right from my experience. I did this in a 10-week academic quarter spending ~10-15 hours a week on the projects. Might be a bit more time if you have little background or lack someone to explain things to you if&#x2F;when you get stuck. The compiler and OS are by far the most arduous parts.</div><br/></div></div><div id="38737110" class="c"><input type="checkbox" id="c-38737110" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#38736197">parent</a><span>|</span><a href="#38736396">prev</a><span>|</span><a href="#38736014">next</a><span>|</span><label class="collapse" for="c-38737110">[-]</label><label class="expand" for="c-38737110">[1 more]</label></div><br/><div class="children"><div class="content">I only did part 1 so far, but it felt like less than that. Whether that was because of experience, or because it was fun enough that it felt shorter, I don&#x27;t know!</div><br/></div></div></div></div><div id="38736014" class="c"><input type="checkbox" id="c-38736014" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><a href="#38736197">prev</a><span>|</span><label class="collapse" for="c-38736014">[-]</label><label class="expand" for="c-38736014">[1 more]</label></div><br/><div class="children"><div class="content">Cannot recommend it enough.</div><br/></div></div></div></div></div></div></div></body></html>