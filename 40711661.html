<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718701258927" as="style"/><link rel="stylesheet" href="styles.css?v=1718701258927"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://olano.dev/blog/a-note-on-essential-complexity">A Note on Essential Complexity</a> <span class="domain">(<a href="https://olano.dev">olano.dev</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>21 comments</span></div><br/><div><div id="40713897" class="c"><input type="checkbox" id="c-40713897" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#40713802">next</a><span>|</span><label class="collapse" for="c-40713897">[-]</label><label class="expand" for="c-40713897">[5 more]</label></div><br/><div class="children"><div class="content">Complexity builds rockets with thrust vectoring and lands modules on the moon, simplicity is good for fire crackers.<p>Once you scale past simple prototypes, you need performance and new features. And the architecture stops being simple and complexity eventually creeps in.<p>I’ve implented 4 iterations of a product from scratch, and eventually they all get complex, even though each one started out with the goal of being simpler than the previous iteration. Yes, iteration #4 is more complex than #1, but it is more performant.<p>In parallel I’m building a new house, and each iteration of the plans is more complex. You try to manage compromises. You take 2 steps forward, one back. Which way do windows face, can an older person navigate, is there enough storage space, cost, esthetics, where does a dirty dog enter, where is the chimney for preppers, driveway and orchard, septics and wells, drainage and water collection, guest rooms and hot tubs, all on a budget …  Simple wont do.</div><br/><div id="40714186" class="c"><input type="checkbox" id="c-40714186" checked=""/><div class="controls bullet"><span class="by">danybittel</span><span>|</span><a href="#40713897">parent</a><span>|</span><a href="#40714675">next</a><span>|</span><label class="collapse" for="c-40714186">[-]</label><label class="expand" for="c-40714186">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say these are essential complexities, they are features necessary for the client.
Accidental complexity would be, if you for example, assigned the work on your new house to different &quot;teams&quot;. Then the &quot;guest room&quot; team also build a drainage, or used a prebuilt drainage, not connected to the drainage the other team built.<p>To quote a quote from the article:
&quot;In my experience most of the complexities which are encountered in systems work are symptoms of organizational malfunctions.&quot;</div><br/></div></div><div id="40714675" class="c"><input type="checkbox" id="c-40714675" checked=""/><div class="controls bullet"><span class="by">langsoul-com</span><span>|</span><a href="#40713897">parent</a><span>|</span><a href="#40714186">prev</a><span>|</span><a href="#40714742">next</a><span>|</span><label class="collapse" for="c-40714675">[-]</label><label class="expand" for="c-40714675">[1 more]</label></div><br/><div class="children"><div class="content">You want to start with simple, because simple will become complex overtime. Starting with complicated means it&#x27;d only become more complicated.<p>Simple is also relative though. No point preparing for Google scale, when there&#x27;s less than 10 users a month. But, if the objective is something like discord, real time comms, then it&#x27;d be simpler to start with the correct language and framework for that use case.</div><br/></div></div><div id="40714742" class="c"><input type="checkbox" id="c-40714742" checked=""/><div class="controls bullet"><span class="by">tristramb</span><span>|</span><a href="#40713897">parent</a><span>|</span><a href="#40714675">prev</a><span>|</span><a href="#40713802">next</a><span>|</span><label class="collapse" for="c-40714742">[-]</label><label class="expand" for="c-40714742">[2 more]</label></div><br/><div class="children"><div class="content">The vast complexity of the 21st Century has still not managed to land a single person on the Moon.</div><br/><div id="40715146" class="c"><input type="checkbox" id="c-40715146" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#40713897">root</a><span>|</span><a href="#40714742">parent</a><span>|</span><a href="#40713802">next</a><span>|</span><label class="collapse" for="c-40715146">[-]</label><label class="expand" for="c-40715146">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not on technology, that&#x27;s on people holding the purse strings only caring about growing their purses. Capitalism grew up, and is a boring old fart now.</div><br/></div></div></div></div></div></div><div id="40713802" class="c"><input type="checkbox" id="c-40713802" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40713897">prev</a><span>|</span><a href="#40714523">next</a><span>|</span><label class="collapse" for="c-40713802">[-]</label><label class="expand" for="c-40713802">[1 more]</label></div><br/><div class="children"><div class="content"><i>Left to their own devices, software engineers would act as the philosophical razor, removing the complexity of the world; automating employees —the engineers themselves included— out of a job; simplifying systems, along with the organizations that own them, out of existence.</i><p>A lot of people I&#x27;ve worked with appear to have realised that and taken it to the other extreme --- for them, complexity is what keeps them employed, so they find other excuses for justifying its (and their) existence and continue taking the abstractions beyond 11. Some communities&#x2F;languages like Enterprise Java and .NET are an example of that; and more recently, JS. The old Stroustrup C++ satire also comes to mind.</div><br/></div></div><div id="40714523" class="c"><input type="checkbox" id="c-40714523" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#40713802">prev</a><span>|</span><a href="#40714974">next</a><span>|</span><label class="collapse" for="c-40714523">[-]</label><label class="expand" for="c-40714523">[1 more]</label></div><br/><div class="children"><div class="content">Good Article on a very important topic.<p>Generally, <i>Problem&#x2F;Systems&#x2F;Requirements Analysis should be done Top-Down but Solution Design&#x2F;Implementation should be done Bottom-Up</i>. This approach is key to managing Essential Complexity.<p>The Analysis starts with the &quot;system-as-a-whole&quot; and uses the scientific reductionist approach to figure out the constituent sub-modules and their interactions. This is applied recursively to sub-modules until we choose to stop at a desired level. This identifies the essential complexity at the module level (eg. need for DSP processing algorithms on certain media RTP&#x2F;RTCP data flows). But in the process of breaking down the system we also will have identified the essential complexity in the interactions between modules (eg. the SIP&#x2F;etc. protocol module responsible for setting up the above media data flows) and cross-cutting all modules (eg. performance, logging, exception-handling). So while constructing the solution we now can take care of all the identified essential complexities involved by spreading our <i>functional modules</i> over a layering of <i>policy and mechanism modules</i> (see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Separation_of_mechanism_and_policy" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Separation_of_mechanism_and_po...</a> and <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Separation_of_concerns" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Separation_of_concerns</a>). This distribution of <i>Function, Policy and Mechanism</i> is what constitutes the <i>Architecture</i> of the System.</div><br/></div></div><div id="40714974" class="c"><input type="checkbox" id="c-40714974" checked=""/><div class="controls bullet"><span class="by">CRConrad</span><span>|</span><a href="#40714523">prev</a><span>|</span><a href="#40712917">next</a><span>|</span><label class="collapse" for="c-40714974">[-]</label><label class="expand" for="c-40714974">[1 more]</label></div><br/><div class="children"><div class="content">Related: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40704267">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40704267</a></div><br/></div></div><div id="40712917" class="c"><input type="checkbox" id="c-40712917" checked=""/><div class="controls bullet"><span class="by">jt2190</span><span>|</span><a href="#40714974">prev</a><span>|</span><a href="#40712580">next</a><span>|</span><label class="collapse" for="c-40712917">[-]</label><label class="expand" for="c-40712917">[3 more]</label></div><br/><div class="children"><div class="content">I feel like this article over-complicates things by using a strange definition of “essential complexity”: That if a <i>user</i> says that something is necessary, than that is essential complexity.
Personally I never assume that the user has distilled a problem down to its essence. Regardless, my process looks a lot like what the author recommends: Question assumptions, propose alternatives, eliminate work, etc.</div><br/><div id="40712978" class="c"><input type="checkbox" id="c-40712978" checked=""/><div class="controls bullet"><span class="by">lantry</span><span>|</span><a href="#40712917">parent</a><span>|</span><a href="#40712580">next</a><span>|</span><label class="collapse" for="c-40712978">[-]</label><label class="expand" for="c-40712978">[2 more]</label></div><br/><div class="children"><div class="content">This is addressed in the second half of the article<p>&gt; Strictly following Moseley and Marks’s definition, the fact that we can get the user (or the customer, or the product owner) to accept a change of requirements, implies that the removed complexity wasn’t essential in the first place.</div><br/><div id="40713425" class="c"><input type="checkbox" id="c-40713425" checked=""/><div class="controls bullet"><span class="by">jt2190</span><span>|</span><a href="#40712917">root</a><span>|</span><a href="#40712978">parent</a><span>|</span><a href="#40712580">next</a><span>|</span><label class="collapse" for="c-40713425">[-]</label><label class="expand" for="c-40713425">[1 more]</label></div><br/><div class="children"><div class="content">Let me editorialize that:<p>&gt; Strictly following Mosley and Marks’s <i>different</i> definition because it’s strange and I can easily poke holes in it…<p>Again, I’m not sure why it was necessary to “strictly follow” that bizarre definition of essential complexity, one that seems to define anything a user says as “essential”.</div><br/></div></div></div></div></div></div><div id="40712580" class="c"><input type="checkbox" id="c-40712580" checked=""/><div class="controls bullet"><span class="by">kashyapc</span><span>|</span><a href="#40712917">prev</a><span>|</span><a href="#40712390">next</a><span>|</span><label class="collapse" for="c-40712580">[-]</label><label class="expand" for="c-40712580">[1 more]</label></div><br/><div class="children"><div class="content">A well-written article. On a similar theme of essential vs. accidental complexity: FWIW, I summarised a talk gave by Paolo Bonzini (a Linux&#x2F;KVM&#x2F;QEMU maintainer) here in the past:<p><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;872321&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;872321&#x2F;</a> -- A QEMU case study in grappling with software complexity<p>Although it was in context of QEMU, the lessons from it can be applied to many other projects.</div><br/></div></div><div id="40712390" class="c"><input type="checkbox" id="c-40712390" checked=""/><div class="controls bullet"><span class="by">boznz</span><span>|</span><a href="#40712580">prev</a><span>|</span><a href="#40713913">next</a><span>|</span><label class="collapse" for="c-40712390">[-]</label><label class="expand" for="c-40712390">[7 more]</label></div><br/><div class="children"><div class="content">Humans simply cannot keep the whole stack for a complex system in memory, that is why we abstract layers with APIs etc and generally specialize on one layer only.<p>My (Sci-Fi) book postulated that an AGI (a real AGI, after all it was Sci-Fi) would simply discard everything the humans wrote and rewrite the complete stack (including later on the Hardware and ISA) in machine code without anything unnecessary for the task and of course totally unreadable to a human. It is an interesting scenario to ponder.</div><br/><div id="40714181" class="c"><input type="checkbox" id="c-40714181" checked=""/><div class="controls bullet"><span class="by">philipswood</span><span>|</span><a href="#40712390">parent</a><span>|</span><a href="#40712588">next</a><span>|</span><label class="collapse" for="c-40714181">[-]</label><label class="expand" for="c-40714181">[1 more]</label></div><br/><div class="children"><div class="content">I wish we would refactor our stack!<p>Each level throws away a lot of the effort of the preceding layer.<p>E.g. after heroic engineering for the OS and memory management systems to present the illusory abstraction of a flat memory address space to the runtime, it almost immediately chops it up into smaller independent &quot;packets&quot; that don&#x27;t interact directly.<p>Or the whole storage &lt;-&gt; memory &lt;-&gt; slow cache &lt;-&gt; fast cache &lt;-&gt; register divide.<p>I think we should be building processors that are made of tens of millions of very simple processors, each with their own memory and with dedicated &quot;network on chip&quot;-like communication electronics. These processors would directly map to language structures like objects&#x2F;structs&#x2F;functions.<p>Essentially flattening the stack so that there is just one level between language and silicon.</div><br/></div></div><div id="40712588" class="c"><input type="checkbox" id="c-40712588" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40712390">parent</a><span>|</span><a href="#40714181">prev</a><span>|</span><a href="#40712536">next</a><span>|</span><label class="collapse" for="c-40712588">[-]</label><label class="expand" for="c-40712588">[1 more]</label></div><br/><div class="children"><div class="content">While AIs are able to keep more in their “mind” at the same time than humans, there is still a cost to consider (e.g. token limit). If software requires more effort to change (adding a feature, fixing a bug) due to spaghetti architecture, then that will also add to the cost.<p>Secondly, we may want to keep software on a complexity level understandable by humans, in order to not become completely dependent on the software engineering AIs.<p>Thirdly, the same effect that we observe with software written by humans getting to complex to understand by any human, is likely to also occur with AIs of any given capacity. AIs will have to take care, just like humans have to, that the complexity doesn’t grow to exceed their abilities to maintain the software. The old adage “Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.” probably also applies to AIs.<p>The essential complexity of software doesn’t depend on whether a human or an AI writes it. AIs may be able to handle more accidental complexity, but it’s unclear if that is an actual benefit under the cost arguments mentioned above. So maybe it will only be useful to create and maintain software with more <i>essential</i> complexity than humans can handle. The question is if we want to depend on such software.</div><br/></div></div><div id="40712536" class="c"><input type="checkbox" id="c-40712536" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#40712390">parent</a><span>|</span><a href="#40712588">prev</a><span>|</span><a href="#40712846">next</a><span>|</span><label class="collapse" for="c-40712536">[-]</label><label class="expand" for="c-40712536">[2 more]</label></div><br/><div class="children"><div class="content">OTOH a lot of the abstractions are created because problems aren&#x27;t solved coherently but rather partitioned into organizational structures adding incidental complexity. The worst are &lt;noun&gt;-services that seem to always do too much&#x2F;too little or have interface designs that suit itself than needs of clients&#x2F;consumers. I spend a fair amount of time decomplexifying the org out of architectures when we realize that performance sucks because reasons.<p>We can do a lot of that discarding of excess by realizing that there&#x27;s the data that&#x27;s read, the rules applied, and the data that&#x27;s written. Everything else is ephemeral and plumbing. Looking at a process that way, and seeing the amount of complexity&#x2F;abstractions one can ask what all that really necessary? Does it pay for itself in some way? It has to justify its existence beyond implementing the needed process.<p>I question the value of frameworks sometimes[0].<p>[0] <a href="https:&#x2F;&#x2F;ptrthomas.wordpress.com&#x2F;2006&#x2F;06&#x2F;06&#x2F;java-call-stack-from-http-upto-jdbc-as-a-picture&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ptrthomas.wordpress.com&#x2F;2006&#x2F;06&#x2F;06&#x2F;java-call-stack-f...</a></div><br/><div id="40714148" class="c"><input type="checkbox" id="c-40714148" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#40712390">root</a><span>|</span><a href="#40712536">parent</a><span>|</span><a href="#40712846">next</a><span>|</span><label class="collapse" for="c-40714148">[-]</label><label class="expand" for="c-40714148">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>there&#x27;s the data that&#x27;s read, the rules applied, and the data that&#x27;s written</i><p>and each rule applied can do one of three basic things: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32498382">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32498382</a><p>I like to collapse layers that are doing the &quot;same kind&quot; of thing according to the taxonomy above.</div><br/></div></div></div></div><div id="40712846" class="c"><input type="checkbox" id="c-40712846" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40712390">parent</a><span>|</span><a href="#40712536">prev</a><span>|</span><a href="#40713913">next</a><span>|</span><label class="collapse" for="c-40712846">[-]</label><label class="expand" for="c-40712846">[2 more]</label></div><br/><div class="children"><div class="content">I checked out your book link &lt; <a href="https:&#x2F;&#x2F;rodyne.com&#x2F;?p=1252" rel="nofollow">https:&#x2F;&#x2F;rodyne.com&#x2F;?p=1252</a> &gt;, is there a preview chapter or two somewhere?  That&#x27;s cool you wrote a compelling sci-fi but my list is competitive :)</div><br/><div id="40714587" class="c"><input type="checkbox" id="c-40714587" checked=""/><div class="controls bullet"><span class="by">boznz</span><span>|</span><a href="#40712390">root</a><span>|</span><a href="#40712846">parent</a><span>|</span><a href="#40713913">next</a><span>|</span><label class="collapse" for="c-40714587">[-]</label><label class="expand" for="c-40714587">[1 more]</label></div><br/><div class="children"><div class="content">I doubt the first two or three chapters will do it justice. I have put a free to download link on the bottom of that page for the complete book as an ePub, I will keep the link valid for a few days. Enjoy.</div><br/></div></div></div></div></div></div><div id="40713913" class="c"><input type="checkbox" id="c-40713913" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#40712390">prev</a><span>|</span><label class="collapse" for="c-40713913">[-]</label><label class="expand" for="c-40713913">[1 more]</label></div><br/><div class="children"><div class="content">Complexity is just one of the many kinds of requirements.  And yes, requirements (despite their name) can be somewhat fungible.  And if you keep going, you&#x27;ll think of yourself as a forcing function for humanizing humanity.<p>For me the best perspective is evolution: what system will it be best for those handling my consequences to have?  And the more concrete, the better.<p>So, not essential complexity, but essential.</div><br/></div></div></div></div></div></div></div></body></html>