<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1682758855241" as="style"/><link rel="stylesheet" href="styles.css?v=1682758855241"/><link rel="apple-touch-startup-image" href="https://png.pngtree.com/png-clipart/20210309/original/pngtree-a-squatting-tabby-cat-png-image_5803660.jpg"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://knivesandpaintbrushes.org/projects/why-oatmeal-is-cheap/why_oatmeal_is_cheap_fdg2023.pdf">Why Oatmeal Is Cheap: Kolmogorov Complexity and Procedural Generation [pdf]</a>¬†<span class="domain">(<a href="https://knivesandpaintbrushes.org">knivesandpaintbrushes.org</a>)</span></div><div class="subtext"><span>kelseyfrog</span> | <span>18 comments</span></div><br/><div><div id="35750587" class="c"><input type="checkbox" id="c-35750587" checked=""/><div class="controls bullet"><span class="by">martinpw</span><span>|</span><a href="#35750522">next</a><span>|</span><label class="collapse" for="c-35750587">[-]</label><label class="expand" for="c-35750587">[2 more]</label></div><br/><div class="children"><div class="content">Context for title, from the Background section of the paper:<p><i>One well-known example of this is The Ten Thousands Bowls of Oatmeal Problem, a term coined by Kate Compton and now one of the best-known idioms among procedural generation practitioners. In this analogy, Compton likens procedurally generated content to bowls of oatmeal, and uses this to highlight the meaninglessness of appeals to variety or unpredictability which often accompany sales pitches related to procedural generation. Every bowl of oatmeal is unique, Compton explains, but that does not make them interesting or valuable. Designers use this to understand that procedural generation alone does not guarantee variety or interest, and that systems must be carefully designed to use generative methods as an expressive tool, rather than a solution in and of itself.</i></div><br/><div id="35751143" class="c"><input type="checkbox" id="c-35751143" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#35750587">parent</a><span>|</span><a href="#35750522">next</a><span>|</span><label class="collapse" for="c-35751143">[-]</label><label class="expand" for="c-35751143">[1 more]</label></div><br/><div class="children"><div class="content">This is important to note.<p>As a VFX-person I have to add that the variation can be a value in itself.<p>E.g. imagine a level in a computer game that plays in an office building. Having procedural desks with different heights and stuff on it with various dagrees of use and personalization seems boring, but in sum it makes a big room look more like the real thing, because most real things have these tiny imperfections. In games where e.g. you have items to find the variance of the environment is a major factor in the enjoyability of the game. Too much and nobody can tell items from assets, too little and items feel like on a board game.<p>That being said, procedural systems must either be incredibly intricate or use a lot of artistic input to produce good results.<p>E.g. a good level artist might tell a whole story of human relationships with the way a room is set up, with the pictures&#x2F;notes those office workers hung at the walls, which objects decorated their work places.<p>A purely procedural approach will look very arbitrary <i>unless</i> it tries to model the same underlying rules (e.g. &quot;simulating&quot; the owner of said desk). If done correctly this <i>can</i> look extremely good (better than mediocre level designers) ‚Äî but this is rarely done.</div><br/></div></div></div></div><div id="35750522" class="c"><input type="checkbox" id="c-35750522" checked=""/><div class="controls bullet"><span class="by">mherrmann</span><span>|</span><a href="#35750587">prev</a><span>|</span><a href="#35750817">next</a><span>|</span><label class="collapse" for="c-35750522">[-]</label><label class="expand" for="c-35750522">[1 more]</label></div><br/><div class="children"><div class="content">Mike Cook and Azalea Raad (mentioned in the acknowledgements) were in my undergrad class at Imperial College London. They&#x27;re both very smart and were somewhere around the top of the class. It&#x27;s funny and nice to see both of their names again after 17 years.<p>If you&#x27;re reading this Mike or Azalea: Hi!</div><br/></div></div><div id="35750817" class="c"><input type="checkbox" id="c-35750817" checked=""/><div class="controls bullet"><span class="by">arketyp</span><span>|</span><a href="#35750522">prev</a><span>|</span><a href="#35750976">next</a><span>|</span><label class="collapse" for="c-35750817">[-]</label><label class="expand" for="c-35750817">[1 more]</label></div><br/><div class="children"><div class="content">This has me thinking about Wolfram&#x27;s four classes of behavior for simple programs [1]. He hypothesizes that the irreducible complexity of class 3 rules means that they are Turing complete, and in a sense maximally complex, which has been proved for at least some class 4 rules. The class 4 behavior is more &quot;interesting&quot; though, if only in the way those patterns yield to analysis, but to determine what types of programs express such behavior may be a priori impossible. In the end, finding &quot;useful&quot; patterns may come down to a brute force &quot;mining of computational space&quot;.<p>[1] <a href="https:&#x2F;&#x2F;www.wolframscience.com&#x2F;nks&#x2F;p231--four-classes-of-behavior&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.wolframscience.com&#x2F;nks&#x2F;p231--four-classes-of-beh...</a></div><br/></div></div><div id="35750976" class="c"><input type="checkbox" id="c-35750976" checked=""/><div class="controls bullet"><span class="by">lgdw</span><span>|</span><a href="#35750817">prev</a><span>|</span><a href="#35750764">next</a><span>|</span><label class="collapse" for="c-35750976">[-]</label><label class="expand" for="c-35750976">[1 more]</label></div><br/><div class="children"><div class="content">Having a hard time following the lower bound proof, especially this part:<p>&gt; By the definition of ùëÉùëé , we know there are at least as many programs in ùëÉùëé as there are artefacts in ùúã (ùê∫), i.e. |ùëùùëé | ‚â• #ùúã (ùê∫).<p>I&#x27;m not sure how the definition of P_a leads to |p_a| &gt;= #\pi(G)...</div><br/></div></div><div id="35750764" class="c"><input type="checkbox" id="c-35750764" checked=""/><div class="controls bullet"><span class="by">davesque</span><span>|</span><a href="#35750976">prev</a><span>|</span><a href="#35750619">next</a><span>|</span><label class="collapse" for="c-35750764">[-]</label><label class="expand" for="c-35750764">[2 more]</label></div><br/><div class="children"><div class="content">As an aside, I feel like the whole notion of Kolmogorov complexity seems to just be moving the goal posts. With the classic example of the Mandelbrot fractal, is the representation of the fractal as an iterated formula really any more compact when you include the complexity of the computer that has to execute the program to produce a meaningful result?</div><br/><div id="35750913" class="c"><input type="checkbox" id="c-35750913" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#35750764">parent</a><span>|</span><a href="#35750619">next</a><span>|</span><label class="collapse" for="c-35750913">[-]</label><label class="expand" for="c-35750913">[1 more]</label></div><br/><div class="children"><div class="content">If you want to generate lots of pictures of your Mandelbrot fractal zoomed into different spots, then yes, shipping the program is much smaller.<p>I remember spending countless hours with Fractint (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fractint" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fractint</a>) in the 1990s.  Back then the programme fit on a floppy disk (or so).  Today the latest version from <a href="https:&#x2F;&#x2F;fractint.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fractint.org&#x2F;</a> is about 9 MiB in size.<p>If you want to transmit n pictures of the Mandelbrot set, you can either send me n PNGs, or you can transmit Fractint once and n tuples of (top, left, bottom, right) coordinates.  You can do the math what size n you need before the former becomes much, much bigger than the latter.<p>But, I like the spirit of your comment.  So perhaps the thought-provoking thing might be the following observation:<p>Most of the bytes and complexity in the fractint binary are not at all necessary for displaying the fractals.  You could generate them with much simpler software.  No, most of the bytes are there to generate the fractals _quickly_.<p>Kolmogorov complexity doesn&#x27;t care about runtimes as long as they are finite.  Humans do.</div><br/></div></div></div></div><div id="35750619" class="c"><input type="checkbox" id="c-35750619" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#35750764">prev</a><span>|</span><a href="#35751019">next</a><span>|</span><label class="collapse" for="c-35750619">[-]</label><label class="expand" for="c-35750619">[4 more]</label></div><br/><div class="children"><div class="content"> &gt; Pattern Density. Players naturally learn to identify patterns in game content over time. This is not exclusive to procedurally generated content;  ... procedurally generated content is more susceptible to pattern identification in this way. Generated content might be described as ‚Äòrepetitive‚Äô if it is too easy to notice patterns.<p>Not necessarily - just feed in a stream of pseudorandom data?<p>Even a 32 bit seed space can generate more environments than a player could ever explore, each with arbitrary levels of detail.<p>The data stream may be lacking in true complexity, but (done right) it would be indistinguishable from the player&#x27;s perspective.<p>(Or am I missing something?)</div><br/><div id="35750958" class="c"><input type="checkbox" id="c-35750958" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#35750619">parent</a><span>|</span><a href="#35750979">next</a><span>|</span><label class="collapse" for="c-35750958">[-]</label><label class="expand" for="c-35750958">[1 more]</label></div><br/><div class="children"><div class="content">As a thought experiment, think about reading a text.<p>In some sense, if you feed your reader truly random letters (generate uniformly and independently), they should be maximally surprised.<p>But they aren&#x27;t.  They will be bored.  And they will be able to predict roughly how many spaces there will be in next million characters.  Or roughly how many repetitions of the sequence &#x27;xyz&#x27;.<p>And they will notice that there&#x27;s no overarching structure.<p>If you give people a carefully written text, the individual letters will be more predictable, but your readers &#x2F; viewers will feel more surprised when they learn that Darth Vader is Luke&#x27;s father.</div><br/></div></div><div id="35750979" class="c"><input type="checkbox" id="c-35750979" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#35750619">parent</a><span>|</span><a href="#35750958">prev</a><span>|</span><a href="#35750749">next</a><span>|</span><label class="collapse" for="c-35750979">[-]</label><label class="expand" for="c-35750979">[1 more]</label></div><br/><div class="children"><div class="content">See the explanation of the &quot;oatmeal&quot; reference elsewhere in this thread. Having a bowl of oatmeal each day will quickly feel repetitive, even if each bowl of oatmeal technically has a unique arrangement. Adding more &quot;randomness&quot; to the arrangement of oatmeal won&#x27;t change that. This relates to high entropy. The macroscopic pattern can remain largely the same even if the microscopic configurations differ a lot.</div><br/></div></div><div id="35750749" class="c"><input type="checkbox" id="c-35750749" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#35750619">parent</a><span>|</span><a href="#35750979">prev</a><span>|</span><a href="#35751019">next</a><span>|</span><label class="collapse" for="c-35750749">[-]</label><label class="expand" for="c-35750749">[1 more]</label></div><br/><div class="children"><div class="content">I had this experience playing No Mans Sky. At first it‚Äôs amazing, but after you visit a few planets, you start to see repeated elements. After a while, you see The Matrix: the knobs that the PRNG can turn become more obvious than the game world itself! Then the illusion is broken.</div><br/></div></div></div></div></div></div></div></div></div></body></html>