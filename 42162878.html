<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731920460311" as="style"/><link rel="stylesheet" href="styles.css?v=1731920460311"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bitfieldconsulting.com/posts/constraints">Constraints in Go</a> <span class="domain">(<a href="https://bitfieldconsulting.com">bitfieldconsulting.com</a>)</span></div><div class="subtext"><span>gus_leonel</span> | <span>76 comments</span></div><br/><div><div id="42163816" class="c"><input type="checkbox" id="c-42163816" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42163167">next</a><span>|</span><label class="collapse" for="c-42163816">[-]</label><label class="expand" for="c-42163816">[15 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised by the complexity of Go&#x27;s generic constraints, given the language&#x27;s focus on simplicity. Things like the difference between &quot;implementing&quot; and &quot;satisfying&quot; a constraint [0], and exceptions around what a constraint can contain [1]:<p>&gt; <i>A union (with more than one term) cannot contain the predeclared identifier comparable or interfaces that specify methods, or embed comparable or interfaces that specify methods.</i><p>Is this level of complexity unavoidable when implementing generics (in any language)? If not, could it have been avoided if Go&#x27;s design had included generics from the start?<p>[0] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;77445861&#x2F;whats-the-difference-between-types-implements-and-types-satisfies" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;77445861&#x2F;whats-the-diffe...</a><p>[1] <a href="https:&#x2F;&#x2F;blog.merovius.de&#x2F;posts&#x2F;2024-01-05_constraining_complexity&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.merovius.de&#x2F;posts&#x2F;2024-01-05_constraining_compl...</a></div><br/><div id="42164048" class="c"><input type="checkbox" id="c-42164048" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#42163816">parent</a><span>|</span><a href="#42164801">next</a><span>|</span><label class="collapse" for="c-42164048">[-]</label><label class="expand" for="c-42164048">[1 more]</label></div><br/><div class="children"><div class="content">Generics are a powerful mechanism, and there is a spectrum. The act of retrofitting generics on go without generics certainly meant that some points in the design space were not available.
On the other hand, when making a language change as adding generics, one wants to be careful that it pulls its own weight: it would be be sad if generics had been added and then many useful patterns could not be typed.
The design choices revolve around expressivity (what patterns can be typed) and inference (what annotations are required). Combining generics with subtyping and inference is difficult as undecidability looms. In a language with subtyping it cannot be avoided (or the resulting language would be very bland).
So I think the answer is no, this part of the complexity could not have been avoided. I think they did a great job at retrofitting and leaving the basic style of the language intact - even if I&#x27;d personally prefer a language design with a different style but more expressive typing.</div><br/></div></div><div id="42164801" class="c"><input type="checkbox" id="c-42164801" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42163816">parent</a><span>|</span><a href="#42164048">prev</a><span>|</span><a href="#42164982">next</a><span>|</span><label class="collapse" for="c-42164801">[-]</label><label class="expand" for="c-42164801">[6 more]</label></div><br/><div class="children"><div class="content">In practice, none of this impacts your program. The standard advice I give to people messing around with this stuff is, never use the pipe operator. The standard library already implements all the sensible uses of it.<p>In particular, people tend to read it as the &quot;sum type&quot; operator, which it is not. I kind of wish the syntax has used &amp; instead of |, what it is doing is closer to an &quot;and&quot; then an &quot;or&quot;.<p>By the time you know enough to know you can ignore that advice, you will. But you&#x27;ll also likely find it never comes up, because, again, the standard library has already implemented all the sensible variants of this, not because the standard library is magic but because there&#x27;s really only a limited number of useful cases anyhow. I haven&#x27;t gone too crazy with generics, but I have used them nontrivially, even done s could tricks [1], and the pipe operator is not that generally useful.<p>When the generic constraint is an interface with methods is the case that can actually come up, but that makes sense, if generics make sense to you at all.<p>It probably is a good demonstration of the sort of things that come up on generic implementations, though. Despite the rhetoric people often deployed prior to Go having them, no, they are never easy, never without corner cases, never without a lot of complications and tradeoffs under the hood. Even languages designed with them from the beginning have them, just better stuffed under the rug and with less obvious conflict with other features. They&#x27;re obviously not impossible, and can be worthwhile when deployed, certainly, but it&#x27;s always because of a lot of work done by the language designers and implementations, it&#x27;s never just &quot;hey let&#x27;s use generics, ok, that one sentence finishes the design I guess let&#x27;s go implement them in a could of hours&quot;.<p>[1]: Just about the edge of the &quot;tricky&quot; I&#x27;d advise: <a href="https:&#x2F;&#x2F;github.com&#x2F;thejerf&#x2F;mtmap">https:&#x2F;&#x2F;github.com&#x2F;thejerf&#x2F;mtmap</a></div><br/><div id="42164999" class="c"><input type="checkbox" id="c-42164999" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42164801">parent</a><span>|</span><a href="#42164982">next</a><span>|</span><label class="collapse" for="c-42164999">[-]</label><label class="expand" for="c-42164999">[5 more]</label></div><br/><div class="children"><div class="content">&gt; In particular, people tend to read it as the &quot;sum type&quot; operator, which it is not. I kind of wish the syntax has used &amp; instead of |, what it is doing is closer to an &quot;and&quot; then an &quot;or&quot;.<p>I don&#x27;t understand here. In my understanding, the pipe operator is indeed closer to &quot;or&quot; and &quot;sum type&quot; operator. Interpreting it as &quot;and&quot; is weird to me.</div><br/><div id="42165029" class="c"><input type="checkbox" id="c-42165029" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42164999">parent</a><span>|</span><a href="#42164982">next</a><span>|</span><label class="collapse" for="c-42165029">[-]</label><label class="expand" for="c-42165029">[4 more]</label></div><br/><div class="children"><div class="content">I think they&#x27;re reading it as &quot;a bitwise-and of the functionality of the types passed&quot;, which is accurate (since you&#x27;re getting the lowest common denominator of all |&#x27;d types).<p>I&#x27;m... not sure which way I lean tbh, now that I&#x27;ve seen that idea.  Both have merit, it&#x27;s more of a problem for educational material than anything.  If you present it as &quot;these types&quot;, | makes sense.  If you instead use &quot;these behaviors&quot;, &amp; makes sense.  | is slightly easier to type for me though, and &amp; has more meanings already (address-of), so maybe I&#x27;d still favor |.</div><br/><div id="42165169" class="c"><input type="checkbox" id="c-42165169" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42165029">parent</a><span>|</span><a href="#42164982">next</a><span>|</span><label class="collapse" for="c-42165169">[-]</label><label class="expand" for="c-42165169">[3 more]</label></div><br/><div class="children"><div class="content">Okay, it is some reasonable if the operator is viewed as a behavior operator. But it is not, it is a type set operator.</div><br/><div id="42165887" class="c"><input type="checkbox" id="c-42165887" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42165169">parent</a><span>|</span><a href="#42164982">next</a><span>|</span><label class="collapse" for="c-42165887">[-]</label><label class="expand" for="c-42165887">[2 more]</label></div><br/><div class="children"><div class="content">And the real point I&#x27;m making here is that &quot;the type set operator&quot; is <i>not</i> &quot;a sum type&quot;. A sum type with, say, three branches is either the first, or the second, or the third, and to do anything with any of them, you have to deconstruct it, at which point you have full access to the deconstructed branch you are in. The | operator in a Go generic is more a declaration of &quot;I want to operate on all of these at once&quot;, so, you can put multiple numeric types into it because you can do a + or a - on any of them, but while the syntax permits you to put three struct types into it, and it&#x27;ll compile, it does not produce a &quot;sum type&quot;. Instead you get &quot;I can operate on this value with the intersection of all the operations they can do&quot;, which is more or less &quot;nothing&quot;. (&quot;Methods&quot; aren&#x27;t &quot;operations&quot;; methods you can already declare in interfaces.) Some people particularly fool themselves because you can still take that type, cast it into an &quot;any&quot;, and then type switch on it, but it turns out you can <i>always</i> do that, the | operator isn&#x27;t helping you in any particular way, and if you want to have a closed set of types, a closed interface is a much better way to do it, on many levels.<p>It also doesn&#x27;t currently do anything else people may want it to do, like, accept three structs that each have a field &quot;A&quot; of type &quot;int&quot; and allow the generic to operate on at least that field because they all share it. There&#x27;s a proposal I&#x27;ve seen to enable that, as the current syntax would at least support that, but I don&#x27;t know what its status is.</div><br/><div id="42166057" class="c"><input type="checkbox" id="c-42166057" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42165887">parent</a><span>|</span><a href="#42164982">next</a><span>|</span><label class="collapse" for="c-42166057">[-]</label><label class="expand" for="c-42166057">[1 more]</label></div><br/><div class="children"><div class="content">There is actually a proposal to make type constraints act as sum types: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57644">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57644</a><p>But I doubt sum types will be supported perfectly in Go. The current poor-men&#x27;s sum type mechanism (type-switch syntax) might be still useful in future Go custom generic age.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42164982" class="c"><input type="checkbox" id="c-42164982" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#42163816">parent</a><span>|</span><a href="#42164801">prev</a><span>|</span><a href="#42164004">next</a><span>|</span><label class="collapse" for="c-42164982">[-]</label><label class="expand" for="c-42164982">[1 more]</label></div><br/><div class="children"><div class="content">The difference between types.Implements and types.Satisfies is mainly caused by a history reason. It is just a tradeoff between keeping backward compatibility and theory perfection.<p>It is pity that Go didn&#x27;t support the &quot;comparable&quot; interface from the beginning. If it has been supported since Go 1.0, then this tradeoff can be avoided.<p>There are more limitations in current Go custom generics, much of them could be removed when this proposal (<a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;70128">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;70128</a>) is done.<p>I recommend people to read Go Generics 101 (<a href="https:&#x2F;&#x2F;go101.org&#x2F;generics&#x2F;101.html" rel="nofollow">https:&#x2F;&#x2F;go101.org&#x2F;generics&#x2F;101.html</a>, author here) for a thoroughly understanding the status quo of Go custom generics.</div><br/></div></div><div id="42164004" class="c"><input type="checkbox" id="c-42164004" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#42163816">parent</a><span>|</span><a href="#42164982">prev</a><span>|</span><a href="#42163167">next</a><span>|</span><label class="collapse" for="c-42164004">[-]</label><label class="expand" for="c-42164004">[6 more]</label></div><br/><div class="children"><div class="content">There are tons of random limitations not present in other languages too, like no generic methods.</div><br/><div id="42170829" class="c"><input type="checkbox" id="c-42170829" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42164004">parent</a><span>|</span><a href="#42164827">next</a><span>|</span><label class="collapse" for="c-42170829">[-]</label><label class="expand" for="c-42170829">[1 more]</label></div><br/><div class="children"><div class="content">Rust has a similar restriction on trait objects, for similar reasons.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;traits.html#object-safety" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;traits.html#object...</a></div><br/></div></div><div id="42164827" class="c"><input type="checkbox" id="c-42164827" checked=""/><div class="controls bullet"><span class="by">bigdubs</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42164004">parent</a><span>|</span><a href="#42170829">prev</a><span>|</span><a href="#42163167">next</a><span>|</span><label class="collapse" for="c-42164827">[-]</label><label class="expand" for="c-42164827">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not a random limitation, there are very specific reasons[1] you cannot easily add generic methods as struct receiver functions.<p>[1] <a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;design&#x2F;43651-type-parameters.md#No-parameterized-methods" rel="nofollow">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;des...</a></div><br/><div id="42165247" class="c"><input type="checkbox" id="c-42165247" checked=""/><div class="controls bullet"><span class="by">abound</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42164827">parent</a><span>|</span><a href="#42168728">next</a><span>|</span><label class="collapse" for="c-42165247">[-]</label><label class="expand" for="c-42165247">[2 more]</label></div><br/><div class="children"><div class="content">For someone not well-versed in language implementation details, it may very well feel random.<p>I&#x27;ve been using Go as my primary language for a decade, and the lack of generics on methods was surprising to me the first time I ran into it, and the reasoning not obvious.</div><br/><div id="42169404" class="c"><input type="checkbox" id="c-42169404" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42165247">parent</a><span>|</span><a href="#42168728">next</a><span>|</span><label class="collapse" for="c-42169404">[-]</label><label class="expand" for="c-42169404">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. I&#x27;m not claiming they didn&#x27;t back themselves into a corner here.<p>There&#x27;s no theoretical reason not to have it, the reason is because of a random intersection of other design decisions... unless you&#x27;re saying they made those choices fully expecting to have these restrictions on generics later?</div><br/></div></div></div></div><div id="42168728" class="c"><input type="checkbox" id="c-42168728" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#42163816">root</a><span>|</span><a href="#42164827">parent</a><span>|</span><a href="#42165247">prev</a><span>|</span><a href="#42163167">next</a><span>|</span><label class="collapse" for="c-42168728">[-]</label><label class="expand" for="c-42168728">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Or, we could decide that parameterized methods do not, in fact, implement interfaces, but then it&#x27;s much less clear why we need methods at all. If we disregard interfaces, any parameterized method can be implemented as a parameterized function.<p>What? Methods are not needed if not for implementing an interface?<p>Anyway, functions could also be implementing interfaces, some languages allow that.<p>I swear the go docs read like a cult.</div><br/></div></div></div></div></div></div></div></div><div id="42163167" class="c"><input type="checkbox" id="c-42163167" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#42163816">prev</a><span>|</span><a href="#42165276">next</a><span>|</span><label class="collapse" for="c-42163167">[-]</label><label class="expand" for="c-42163167">[59 more]</label></div><br/><div class="children"><div class="content">i have been writing Go exclusively for 5+ years and to this day i use generics only in a dedicated library that works with arrays(slices in Go world) and provides basic functionality like pop, push, shift, reverse, filter and so on.<p>Other than that, generics have not really solved an actual problem for me in the real world. Nice to have, but too mush fuss about nothing relevant.</div><br/><div id="42165141" class="c"><input type="checkbox" id="c-42165141" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42163244">next</a><span>|</span><label class="collapse" for="c-42165141">[-]</label><label class="expand" for="c-42165141">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kinda the point.  Generics are mostly a library concern, improving end-user experience and performance.  End-user <i>creation</i> of generic types is relatively rare, and you can use them in very simple ways and that&#x27;s almost always good enough because you don&#x27;t need them to be <i>maximally correct</i>, only good enough.<p>For libraries (that adopt generics): yes they can be complicated.  But using them is mostly zero-effort and gets rid of a ton of reflection.</div><br/><div id="42166190" class="c"><input type="checkbox" id="c-42166190" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42165141">parent</a><span>|</span><a href="#42163244">next</a><span>|</span><label class="collapse" for="c-42166190">[-]</label><label class="expand" for="c-42166190">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately not everyone shares that opinion of their restricted use-cases.<p>I&#x27;ve seen ~100 line HTTP handler methods that are implemented using generics and then a bunch of type-specific parameters inevitably get added when the codepaths start to diverge and now you&#x27;ve got a giant spaghetti ball of generics to untangle, for what was originally just trying to deduplicate a few hundred lines of code.</div><br/><div id="42166854" class="c"><input type="checkbox" id="c-42166854" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42166190">parent</a><span>|</span><a href="#42163244">next</a><span>|</span><label class="collapse" for="c-42166854">[-]</label><label class="expand" for="c-42166854">[1 more]</label></div><br/><div class="children"><div class="content">tbh I&#x27;ll still take it over a similar Gordian knot with interfaces.  At least you can tell the restrictions are met at compile time, rather than silently failing at runtime because you (and&#x2F;or someone else in the past) didn&#x27;t notice one edge case lodged somewhere surprising.</div><br/></div></div></div></div></div></div><div id="42163244" class="c"><input type="checkbox" id="c-42163244" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42165141">prev</a><span>|</span><a href="#42165680">next</a><span>|</span><label class="collapse" for="c-42163244">[-]</label><label class="expand" for="c-42163244">[4 more]</label></div><br/><div class="children"><div class="content">Just checked, in my current project, the only place where I use generics is in a custom cache implementation. From my experience in C#, generics are mostly useful for implementing custom containers. It&#x27;s nice to have a clean interface which doesn&#x27;t force users to cast types from any.</div><br/><div id="42163435" class="c"><input type="checkbox" id="c-42163435" checked=""/><div class="controls bullet"><span class="by">BlackFly</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163244">parent</a><span>|</span><a href="#42163970">next</a><span>|</span><label class="collapse" for="c-42163435">[-]</label><label class="expand" for="c-42163435">[1 more]</label></div><br/><div class="children"><div class="content">Containers are sort of the leading order use of generics: I put something in and want to statically get that type back (so no cast, still safe).<p>Second use I usually find is when I have some structs with some behavior and some associated but parameterizable helper. In my case, differential equations together with guess initializers for those differential equations. You can certainly do it without generics, but then the initial guess can be the wrong shape if you copy paste and don&#x27;t change the bits accordingly. The differential equation solver can then take equations that are parameterized by a solution type (varying in dimension, discretisation and variables) together with an initializer that produces an initial guess of that shape.<p>Finally, when your language can do a bit of introspection on the type or the type may have static methods or you have type classes, you can use the generic to control the output.<p>Basically, they are useful (like the article implies) when you want to statically enforce constraints. Some people prefer implicitly enforcing the constraint (if the code works the constraint is satisfied) or with tests (if the tests pass the constraint is satisfied). Other people prefer to have the constraints impossible to not satisfy.</div><br/></div></div><div id="42163970" class="c"><input type="checkbox" id="c-42163970" checked=""/><div class="controls bullet"><span class="by">aljarry</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163244">parent</a><span>|</span><a href="#42163435">prev</a><span>|</span><a href="#42164712">next</a><span>|</span><label class="collapse" for="c-42163970">[-]</label><label class="expand" for="c-42163970">[1 more]</label></div><br/><div class="children"><div class="content">&gt; From my experience in C#, generics are mostly useful for implementing custom containers.<p>That&#x27;s my experience as well in C# - most of other usages of generics are painful to maintain in the long run. I&#x27;ve had most problems with code that joins generics with inheritance.</div><br/></div></div><div id="42164712" class="c"><input type="checkbox" id="c-42164712" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163244">parent</a><span>|</span><a href="#42163970">prev</a><span>|</span><a href="#42165680">next</a><span>|</span><label class="collapse" for="c-42164712">[-]</label><label class="expand" for="c-42164712">[1 more]</label></div><br/><div class="children"><div class="content">C# generics are way more powerful than that when it comes to writing high-performance or just very, err, generic code. Generic constraints and static interface members are immensely useful - you can have a constraint that lets you write ‘T.Parse(text[2..8])’.<p>They are far closer to Rust in <i>some</i> areas (definitely not in type inference sadly, but F# is a different story) than it seems.<p>Of course if one declares that they are an expert in a dozen of languages, most of which have poorly expressive type systems, the final product will end up not taking advantage of having proper generics.</div><br/></div></div></div></div><div id="42165680" class="c"><input type="checkbox" id="c-42165680" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42163244">prev</a><span>|</span><a href="#42163834">next</a><span>|</span><label class="collapse" for="c-42165680">[-]</label><label class="expand" for="c-42165680">[1 more]</label></div><br/><div class="children"><div class="content">this is wild because i use parametric polymorphism by writing `forall` in basically every Haskell PR i do for work ever<p>i think Go having a pretty bad implementation of parametric polymorphism (a programming concept from the 70s) is probably the root cause here</div><br/></div></div><div id="42163834" class="c"><input type="checkbox" id="c-42163834" checked=""/><div class="controls bullet"><span class="by">gregwebs</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42165680">prev</a><span>|</span><a href="#42165270">next</a><span>|</span><label class="collapse" for="c-42163834">[-]</label><label class="expand" for="c-42163834">[2 more]</label></div><br/><div class="children"><div class="content">There’s an existing ecosystem that already works with the constraints of not having generics. If you can write all your code with that, then you won’t need generic much. That ecosystem was created with the sweat of library authors, dealing with not having generics and also with users learning to deal with the limitations and avoid panics.<p>Generics have been tremendously helpful for me and my team anytime we are not satisfied with the existing ecosystem and need to write our own library code. And as time goes on the libraries that everyone uses will be using generics more.</div><br/><div id="42169668" class="c"><input type="checkbox" id="c-42169668" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163834">parent</a><span>|</span><a href="#42165270">next</a><span>|</span><label class="collapse" for="c-42169668">[-]</label><label class="expand" for="c-42169668">[1 more]</label></div><br/><div class="children"><div class="content">The libraries will, yes. But folks just using the libraries still won&#x27;t need generics.<p>If you know your concrete types, they&#x27;re just not that useful.<p>Even in home-grown libraries, I find generics to be a convenience rather than a necessity. It&#x27;s useful to not have my library code so tightly coupled to my non-library code. But it does also come with a cost: every so often I have to check what the library actually does because being loosely coupled meant that iterations in the rest of the system didn&#x27;t automatically have to involve the library, so the library code can get left behind.</div><br/></div></div></div></div><div id="42165270" class="c"><input type="checkbox" id="c-42165270" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42163834">prev</a><span>|</span><a href="#42163415">next</a><span>|</span><label class="collapse" for="c-42165270">[-]</label><label class="expand" for="c-42165270">[1 more]</label></div><br/><div class="children"><div class="content">My most common use of generics is when testing — check out my library for typesafe test comparisons. I find it really useful because I like having readable helpers for asserting in tests, but I also want compiler errors if I refactor things.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;peterldowns&#x2F;testy">https:&#x2F;&#x2F;github.com&#x2F;peterldowns&#x2F;testy</a></div><br/></div></div><div id="42163415" class="c"><input type="checkbox" id="c-42163415" checked=""/><div class="controls bullet"><span class="by">tonyedgecombe</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42165270">prev</a><span>|</span><a href="#42164296">next</a><span>|</span><label class="collapse" for="c-42163415">[-]</label><label class="expand" for="c-42163415">[20 more]</label></div><br/><div class="children"><div class="content">I sometimes wonder if they should have implemented generics. On the one hand you had a group of people using go as it was and presumably mostly happy with the lack of generics. On the other side you have people (like me) complaining about the lack of generics but who were unlikely to use the language once they were added.<p>It&#x27;s very subjective but my gut feeling is they probably didn&#x27;t expand their community much by adding generics to the language.</div><br/><div id="42164299" class="c"><input type="checkbox" id="c-42164299" checked=""/><div class="controls bullet"><span class="by">sbrother</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163415">parent</a><span>|</span><a href="#42169802">next</a><span>|</span><label class="collapse" for="c-42164299">[-]</label><label class="expand" for="c-42164299">[12 more]</label></div><br/><div class="children"><div class="content">Having recently had to work on a Go project for the first time, I think I agree with you here. I&#x27;d tried Go a little bit when it came out, had zero interest in what it offered, and then when I was asked to work on this project a couple months ago I thought it would be fun to try it out again since I had read the language had improved.<p>No, it still feels like programming with a blindfold on and one hand tied behind my back. I truly don&#x27;t get it. I&#x27;ve worked with a <i>lot</i> of languages and paradigms, am not a zealot by any means. Other than fast compiles and easy binary distribution, I don&#x27;t see any value here, and I see even experienced Go programmers constantly wasting time writing unreadable boilerplate to work around the bad language design. I know I must be missing something because some people much smarter than me like this language, but... what is it?</div><br/><div id="42169013" class="c"><input type="checkbox" id="c-42169013" checked=""/><div class="controls bullet"><span class="by">rwiggins</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164299">parent</a><span>|</span><a href="#42167124">next</a><span>|</span><label class="collapse" for="c-42169013">[-]</label><label class="expand" for="c-42169013">[1 more]</label></div><br/><div class="children"><div class="content">I felt the same way initially, but the language has grown on me. The turning point was writing a <i>lot</i> of Go, like full-time project work for a few months.<p>But as I&#x27;ve gotten older, I&#x27;ve started striving more and more for <i>simplicity</i> above all else, especially in systems design (disclaimer: I&#x27;m an SRE). Go is pretty good at being simple.<p>There are some things that still annoy me a whole bunch, though. Like - just one example - `fmt.Errorf` not being a first-class syntactic construct (or the difference between `%v` and `%w` in `fmt.Errorf`).</div><br/></div></div><div id="42167124" class="c"><input type="checkbox" id="c-42167124" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164299">parent</a><span>|</span><a href="#42169013">prev</a><span>|</span><a href="#42165159">next</a><span>|</span><label class="collapse" for="c-42167124">[-]</label><label class="expand" for="c-42167124">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Other than fast compiles and easy binary distribution, I don&#x27;t see any value here, and I see even experienced Go programmers constantly wasting time writing unreadable boilerplate to work around the bad language design. I know I must be missing something because some people much smarter than me like this language, but... what is it?<p>If you &quot;other than&quot; two huge-for-many-use-cases good things, sure, it might look bad. ;)<p>But I would add good overall performance and in particular straightforward flexible concurrency support to the list of good things.<p>And IMO once you&#x27;re in the set of &quot;things with good perf&quot; there&#x27;s generally a lot of &quot;boilerplate&quot; of one sort or another anyway.</div><br/><div id="42167192" class="c"><input type="checkbox" id="c-42167192" checked=""/><div class="controls bullet"><span class="by">sbrother</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42167124">parent</a><span>|</span><a href="#42167582">next</a><span>|</span><label class="collapse" for="c-42167192">[-]</label><label class="expand" for="c-42167192">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s fair. In terms of &quot;things with good perf&quot; I&#x27;d rather be writing C++ or Rust, but there are significant issues with using either of those on a large team.<p>I&#x27;m more comparing it against languages like Kotlin and Swift, or even Scala.</div><br/></div></div><div id="42167582" class="c"><input type="checkbox" id="c-42167582" checked=""/><div class="controls bullet"><span class="by">LinXitoW</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42167124">parent</a><span>|</span><a href="#42167192">prev</a><span>|</span><a href="#42165159">next</a><span>|</span><label class="collapse" for="c-42167582">[-]</label><label class="expand" for="c-42167582">[1 more]</label></div><br/><div class="children"><div class="content">It might be nit picking, but that&#x27;s more the ecosystem or tooling that&#x27;s great. The language is mediocre, but it&#x27;s what everyone gushes about.<p>I still remember people gaslighting everyone that any feature Go had was ESSENTIAL, and every feature Go didn&#x27;t have was USELESS or too complicated for mere mortals &quot;delivering value&quot;.<p>And the fast compiles at least are in big parts because the language is so horrendously basic. Can&#x27;t get hung up on checking type constraints if you barely have any.</div><br/></div></div></div></div><div id="42165914" class="c"><input type="checkbox" id="c-42165914" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164299">parent</a><span>|</span><a href="#42165159">prev</a><span>|</span><a href="#42164896">next</a><span>|</span><label class="collapse" for="c-42165914">[-]</label><label class="expand" for="c-42165914">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I see even experienced Go programmers constantly wasting time writing unreadable boilerplate<p>if it is unreadable, in Go, probably the most readable language used today, i would question the aforementioned experience.</div><br/><div id="42167645" class="c"><input type="checkbox" id="c-42167645" checked=""/><div class="controls bullet"><span class="by">LinXitoW</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42165914">parent</a><span>|</span><a href="#42166542">next</a><span>|</span><label class="collapse" for="c-42167645">[-]</label><label class="expand" for="c-42167645">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think a language where for every 1 line of functionality, you need 3 lines of error handling boilerplate gets to be called readable.<p>Heck, Go went out of it&#x27;s way to &quot;subvert expectations&quot; more than the last season of Game of Thrones.<p>99% of decent C-ish languages either do &quot;String thing&quot; or &quot;thing: String&quot;, but Go is so fancy and quirky, it does &quot;thing String&quot; for no freaking reason. Don&#x27;t get me started on the nightmare that is map types.</div><br/><div id="42168136" class="c"><input type="checkbox" id="c-42168136" checked=""/><div class="controls bullet"><span class="by">kweingar</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42167645">parent</a><span>|</span><a href="#42166542">next</a><span>|</span><label class="collapse" for="c-42168136">[-]</label><label class="expand" for="c-42168136">[2 more]</label></div><br/><div class="children"><div class="content">I like Go&#x27;s error handling. The reader knows exactly which lines of code can encounter an error, and exactly how the error is handled.<p>I find that exception-based code is much harder to read. The happy path is clearer, but exceptional code paths are often completely obscured. It&#x27;s harder to reason about what state the program is in when the exception is handled.</div><br/><div id="42168746" class="c"><input type="checkbox" id="c-42168746" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42168136">parent</a><span>|</span><a href="#42166542">next</a><span>|</span><label class="collapse" for="c-42168746">[-]</label><label class="expand" for="c-42168746">[1 more]</label></div><br/><div class="children"><div class="content">Exceptions have been a mistake, the alternative are Result types, a concept which predates go.</div><br/></div></div></div></div></div></div><div id="42166542" class="c"><input type="checkbox" id="c-42166542" checked=""/><div class="controls bullet"><span class="by">DangitBobby</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42165914">parent</a><span>|</span><a href="#42167645">prev</a><span>|</span><a href="#42164896">next</a><span>|</span><label class="collapse" for="c-42166542">[-]</label><label class="expand" for="c-42166542">[1 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re doing right now is called &quot;coping&quot;.</div><br/></div></div></div></div><div id="42164896" class="c"><input type="checkbox" id="c-42164896" checked=""/><div class="controls bullet"><span class="by">quinnirill</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164299">parent</a><span>|</span><a href="#42165914">prev</a><span>|</span><a href="#42169802">next</a><span>|</span><label class="collapse" for="c-42164896">[-]</label><label class="expand" for="c-42164896">[1 more]</label></div><br/><div class="children"><div class="content">Mad LoCs, dude, gotta make alotta lines, that’s what productivity is!</div><br/></div></div></div></div><div id="42169802" class="c"><input type="checkbox" id="c-42169802" checked=""/><div class="controls bullet"><span class="by">brokencode</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163415">parent</a><span>|</span><a href="#42164299">prev</a><span>|</span><a href="#42169690">next</a><span>|</span><label class="collapse" for="c-42169802">[-]</label><label class="expand" for="c-42169802">[1 more]</label></div><br/><div class="children"><div class="content">Most of the improvements made to any language don’t expand the community much. And they don’t have to, because that’s not the point. The point is to improve the language and ecosystem to help make better software.<p>Generics support is a ubiquitous feature in static programming languages. If it was included on day one in Go, nobody would have blinked an eye. This is only such a controversial topic in Go because the language maintainers made it one.</div><br/></div></div><div id="42169690" class="c"><input type="checkbox" id="c-42169690" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163415">parent</a><span>|</span><a href="#42169802">prev</a><span>|</span><a href="#42163612">next</a><span>|</span><label class="collapse" for="c-42169690">[-]</label><label class="expand" for="c-42169690">[1 more]</label></div><br/><div class="children"><div class="content">Library authors were the main target group, I think.<p>Without generics, your library has to define interfaces that your users have to implement and it all gets a bit strange and unintuitive.<p>With generics you can write library code that is easier to use.<p>The thing I was worried about with this (adding generics) is that we&#x27;d start moving more towards the NPM Hell of everyone just writing plumbing code for imported packages. But thankfully that hasn&#x27;t happened and idiomatic Go still tends to just use the standard lib and very few external packages.</div><br/></div></div><div id="42163612" class="c"><input type="checkbox" id="c-42163612" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163415">parent</a><span>|</span><a href="#42169690">prev</a><span>|</span><a href="#42163502">next</a><span>|</span><label class="collapse" for="c-42163612">[-]</label><label class="expand" for="c-42163612">[1 more]</label></div><br/><div class="children"><div class="content">Generic containers are needed in some cases. Using generic containers with interface{} is very slow and memory-intensive. Not a problem for small containers, but for big containers it&#x27;s just not feasible, so you would need to either copy&amp;paste huge chunks of code or generate code. Compared to those approaches, generic support is superior in every way, so it&#x27;s needed. But creating STL on top of them is not the indended use-case.</div><br/></div></div><div id="42163502" class="c"><input type="checkbox" id="c-42163502" checked=""/><div class="controls bullet"><span class="by">cherryteastain</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163415">parent</a><span>|</span><a href="#42163612">prev</a><span>|</span><a href="#42164296">next</a><span>|</span><label class="collapse" for="c-42163502">[-]</label><label class="expand" for="c-42163502">[4 more]</label></div><br/><div class="children"><div class="content">I think a lot of the people who wanted generics wanted them more to be like C++ templates, with compile time duck typing. Go maintainers were unwilling to go that route because of complexity. However, as a result, any time I think &quot;oh this looks like it could be made generic&quot; I fall into a rabbit hole regarding what Go generics do and dont allow you to do and usually end up copy pasting code instead.</div><br/><div id="42164231" class="c"><input type="checkbox" id="c-42164231" checked=""/><div class="controls bullet"><span class="by">wyufro</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163502">parent</a><span>|</span><a href="#42164296">next</a><span>|</span><label class="collapse" for="c-42164231">[-]</label><label class="expand" for="c-42164231">[3 more]</label></div><br/><div class="children"><div class="content">I think &quot;oh this looks like it could be made generic&quot; is the wrong time to convert to generics.<p>You should convert when you reach the point &quot;I wish I had that code but with this other type&quot;. Even then, sometimes interfaces are the right answer, rather than generics.</div><br/><div id="42167163" class="c"><input type="checkbox" id="c-42167163" checked=""/><div class="controls bullet"><span class="by">cherryteastain</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164231">parent</a><span>|</span><a href="#42165199">prev</a><span>|</span><a href="#42164296">next</a><span>|</span><label class="collapse" for="c-42167163">[-]</label><label class="expand" for="c-42167163">[1 more]</label></div><br/><div class="children"><div class="content">I mostly agree, hence the<p>&gt; end up copy pasting code instead<p>bit of my original comment</div><br/></div></div></div></div></div></div></div></div><div id="42164296" class="c"><input type="checkbox" id="c-42164296" checked=""/><div class="controls bullet"><span class="by">jppittma</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42163415">prev</a><span>|</span><a href="#42163189">next</a><span>|</span><label class="collapse" for="c-42164296">[-]</label><label class="expand" for="c-42164296">[1 more]</label></div><br/><div class="children"><div class="content">The most frequent use case I and my coworkers run into where we use them is when we want type covariance on a slice.<p>I.e., when you want to write a function that take some slice of any type T that implements interface I, such that []T is a valid input instead of just explicitly []I.</div><br/></div></div><div id="42163189" class="c"><input type="checkbox" id="c-42163189" checked=""/><div class="controls bullet"><span class="by">throwaway63467</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42164296">prev</a><span>|</span><a href="#42164983">next</a><span>|</span><label class="collapse" for="c-42163189">[-]</label><label class="expand" for="c-42163189">[24 more]</label></div><br/><div class="children"><div class="content">Honestly so many things profit from generics, e.g. ORM code was very awkward before especially when returning slices of objects as everything was []any. Now you can say var users []User = orm.Get[User](…) as opposed to e.g var users []any = orm.Get(&amp;User{}, …), that alone is incredibly useful and reduces boilerplate by a ton.</div><br/><div id="42168753" class="c"><input type="checkbox" id="c-42168753" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163189">parent</a><span>|</span><a href="#42163295">next</a><span>|</span><label class="collapse" for="c-42168753">[-]</label><label class="expand" for="c-42168753">[1 more]</label></div><br/><div class="children"><div class="content">gorm just takes a pointer of your type and does reflection magic. It&#x27;s worse than generica, I agree, but you don&#x27;t get []any.</div><br/></div></div><div id="42163295" class="c"><input type="checkbox" id="c-42163295" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163189">parent</a><span>|</span><a href="#42168753">prev</a><span>|</span><a href="#42163242">next</a><span>|</span><label class="collapse" for="c-42163295">[-]</label><label class="expand" for="c-42163295">[1 more]</label></div><br/><div class="children"><div class="content">understandable. thee are always valid uses cases. although ORM in Go is not something that is widely used.</div><br/></div></div><div id="42163242" class="c"><input type="checkbox" id="c-42163242" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163189">parent</a><span>|</span><a href="#42163295">prev</a><span>|</span><a href="#42164983">next</a><span>|</span><label class="collapse" for="c-42163242">[-]</label><label class="expand" for="c-42163242">[21 more]</label></div><br/><div class="children"><div class="content">ORM is anti-pattern and reducing boilerplate is bad.</div><br/><div id="42163626" class="c"><input type="checkbox" id="c-42163626" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163242">parent</a><span>|</span><a href="#42163744">next</a><span>|</span><label class="collapse" for="c-42163626">[-]</label><label class="expand" for="c-42163626">[1 more]</label></div><br/><div class="children"><div class="content">&gt; reducing boilerplate is bad<p>Programming is about building abstractions, abstractions are a way to reduce boilerplate.<p>Why do we need `func x(&#x2F;* args <i>&#x2F; ) { &#x2F;</i> body *&#x2F; }`, when you can just inline the function at each callsite and only have a single main function? Functions are simply a way to reduce boilerplate by deduplicating and naming code.<p>If &#x27;reducing boilerplate is bad&#x27;, then functions are bad, and practically any abstraction is bad.<p>In my opinion, &quot;reducing boilerplate is bad in some scenarios where it leads to a worse abstraction than the boilerplate-ful code would lead to&quot;.<p>I think you have to evaluate those things on a case-by-case basis, and some ORMs make sense for some use-cases, where they provide a coherent abstraction that reduces boilerplate... and sometimes they reduce boilerplate, but lead to a poor abstraction which requires more code to fight around it.</div><br/></div></div><div id="42163744" class="c"><input type="checkbox" id="c-42163744" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163242">parent</a><span>|</span><a href="#42163626">prev</a><span>|</span><a href="#42163314">next</a><span>|</span><label class="collapse" for="c-42163744">[-]</label><label class="expand" for="c-42163744">[9 more]</label></div><br/><div class="children"><div class="content">Not liking ORM I can understand, db table &lt;-&gt; object impedance mismatch is real, but &quot;reducing boilerplate is bad&quot; is an interesting take.<p>Can you elaborate and give some examples of why reducing boilerplate is generally &quot;bad&quot;?</div><br/><div id="42164240" class="c"><input type="checkbox" id="c-42164240" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163744">parent</a><span>|</span><a href="#42163929">next</a><span>|</span><label class="collapse" for="c-42164240">[-]</label><label class="expand" for="c-42164240">[1 more]</label></div><br/><div class="children"><div class="content">What I mean is reducing boilerplate is not something one should strive to achieve. It is not bad in the sense that one should introduce more boilerplate for the sake of it. But reducing boilerplate for the sake of it is not good thing either.<p>If you need to make code more complex just to reduce boilerplate, it&#x27;s a bad thing. If you managed go make code simpler and reduced boilerplate at the same time, it&#x27;s a good thing.<p>And boilerplate might be a good thing when you need to type something twice and if you would make error once, the whole thing wouldn&#x27;t work, so basically you&#x27;ll reduce the possibility of typo. It might look counter intuitive. Just unrelated example: recently I wrote C code where I need to type the same signature in the header file and in the source file. I made mistake in the source file, but I didn&#x27;t make the same mistake in the header file and the whole program didn&#x27;t link. I figured out the mistake and corrected it. Without this boilerplate it&#x27;s possible that I wouldn&#x27;t notice the mistake and &quot;helpful&quot; autocomplete would keep the mistake forever. That&#x27;s how HTTP Referer header made it into standards, I guess.</div><br/></div></div><div id="42163929" class="c"><input type="checkbox" id="c-42163929" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163744">parent</a><span>|</span><a href="#42164240">prev</a><span>|</span><a href="#42163314">next</a><span>|</span><label class="collapse" for="c-42163929">[-]</label><label class="expand" for="c-42163929">[7 more]</label></div><br/><div class="children"><div class="content">Not the person you’re replying to. The orm sucks because as soon as you go out of the beaten path of your average select&#x2F;insert&#x2F;update&#x2F;delete, you are inevitably going to end up writing raw sql strings. Two cases in point: postgres cte and jsonb queries, there are no facilities in gorm for those, you will be just shoving raw sql into gorm. You might as well stop pretending. There’s a difference between having something writing the sql and mapping results into structs. The latter one can be done with the stdlib sql package and doesn’t require an „orm”.<p>There are two things an sql lib must do to be very useful: prepared statements and mapping results. That’s enough.</div><br/><div id="42164006" class="c"><input type="checkbox" id="c-42164006" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163929">parent</a><span>|</span><a href="#42163980">next</a><span>|</span><label class="collapse" for="c-42164006">[-]</label><label class="expand" for="c-42164006">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps you have to yet use a good ORM? I could probably count on my fingers the times I had to drop to raw SQL in EFCore. Even when you do that you can still have mapped results, which reduces boilerplate.</div><br/><div id="42164459" class="c"><input type="checkbox" id="c-42164459" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164006">parent</a><span>|</span><a href="#42163980">next</a><span>|</span><label class="collapse" for="c-42164459">[-]</label><label class="expand" for="c-42164459">[2 more]</label></div><br/><div class="children"><div class="content">I’m doing this job for 25 years and I haven’t seen a good orm. Sorry. Look, linq is nice. But linq is not enough of a productivity gain to switch the whole stack from go to .net. I used linq 15 years ago extensively and it feel like magic. But then again, how would you model jsonb select for a variable set of of properties and include nested or and and conditions using its notation? Maybe you could but how much longer is it going to take you rather than templating a string?</div><br/><div id="42169720" class="c"><input type="checkbox" id="c-42169720" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164459">parent</a><span>|</span><a href="#42163980">next</a><span>|</span><label class="collapse" for="c-42169720">[-]</label><label class="expand" for="c-42169720">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing this job for over 30 years and I agree.<p>Entity Framework was the thing that made me spit the dummy with C#, uninstall Windows, install Linux and discover Go in the first place.<p>Knowing how to write good SQL is a superpower as a developer, and every time I&#x27;ve worked with an ORM fan I get this reinforced. &quot;The database is too slow!&quot; No, your SQL just sucks.</div><br/></div></div></div></div></div></div><div id="42163980" class="c"><input type="checkbox" id="c-42163980" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163929">parent</a><span>|</span><a href="#42164006">prev</a><span>|</span><a href="#42167612">next</a><span>|</span><label class="collapse" for="c-42163980">[-]</label><label class="expand" for="c-42163980">[2 more]</label></div><br/><div class="children"><div class="content">You haven’t answered my question at all.<p>The parent comment made two claims: ORM not great (I agree) and “boilerplate reduction bad” which still needs some elaboration</div><br/><div id="42164432" class="c"><input type="checkbox" id="c-42164432" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163980">parent</a><span>|</span><a href="#42167612">next</a><span>|</span><label class="collapse" for="c-42164432">[-]</label><label class="expand" for="c-42164432">[1 more]</label></div><br/><div class="children"><div class="content">I answered it, you just don’t see it. One ends up with the boilerplate anyway as soon as one attempts to step out of the usual crud path. There’s no gain, there’s no difference in templating an sql string vs fighting an orm api.</div><br/></div></div></div></div><div id="42167612" class="c"><input type="checkbox" id="c-42167612" checked=""/><div class="controls bullet"><span class="by">LinXitoW</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163929">parent</a><span>|</span><a href="#42163980">prev</a><span>|</span><a href="#42163314">next</a><span>|</span><label class="collapse" for="c-42167612">[-]</label><label class="expand" for="c-42167612">[1 more]</label></div><br/><div class="children"><div class="content">Any ORM worth it&#x27;s salt has an escape hatch that allows you to do all those fancy raw SQL queries.<p>But the amount of queries that aren&#x27;t fancy, and that an ORM is perfectly capable of abstracting away is (imho) 90% of all queries run.<p>Why make 90% or queries more tedious and error prone, just to make 10% slightly easier?</div><br/></div></div></div></div></div></div><div id="42163314" class="c"><input type="checkbox" id="c-42163314" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163242">parent</a><span>|</span><a href="#42163744">prev</a><span>|</span><a href="#42168321">next</a><span>|</span><label class="collapse" for="c-42163314">[-]</label><label class="expand" for="c-42163314">[1 more]</label></div><br/><div class="children"><div class="content">I agree. The best language to handle data in a RDBMs is SQL, and in that case the best language to handle application logic is Go (or Kotlin, Python or whatever). So there must be some meeting point. Handling everything in Go is not optimal, and all in sql not always practical. So how to avoid redundant data description ? I often have structs in a model Go file that reflect <i>queries</i> I do, but that&#x27;s not optimal since I tend to have to repeat what&#x27;s in a query to the language and the query to struct gathering is often boilerplate. I also almost can reuse the info I need for a query for another query but leave some fields blank since they&#x27;re not needed.. the approaches are not optimal. Maybe a codegen sql to result structs &#x2F; gathering info ?</div><br/></div></div><div id="42163315" class="c"><input type="checkbox" id="c-42163315" checked=""/><div class="controls bullet"><span class="by">bluesnews</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163242">parent</a><span>|</span><a href="#42168321">prev</a><span>|</span><a href="#42164983">next</a><span>|</span><label class="collapse" for="c-42163315">[-]</label><label class="expand" for="c-42163315">[8 more]</label></div><br/><div class="children"><div class="content">Could you expand on this?<p>I don&#x27;t like ORM because in my experience you inevitably want full SQL features at some point but not sure if you have the same issues in mind or not</div><br/><div id="42163404" class="c"><input type="checkbox" id="c-42163404" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163315">parent</a><span>|</span><a href="#42164983">next</a><span>|</span><label class="collapse" for="c-42163404">[-]</label><label class="expand" for="c-42163404">[7 more]</label></div><br/><div class="children"><div class="content">ORM is for object-relation mapping. Go is not object-oriented language and OOP-patterns are not idiomatic Go, so using ORM for Go cannot be idiomatic. That&#x27;s generic answer. As for more concrete points:<p>1. Mapping SQL response to maps&#x2F;structs or mapping maps&#x2F;structs to SQL parameters might be useful, but that&#x27;s rather trivial functionality and probably doesn&#x27;t qualify as ORM. Things get harder when we&#x27;re talking about complex joins and structs with relationships, but still manageable.<p>2. Introducing intermediate language which is converted to SQL is bad. Inevitably it will have less features. It will stay in the way for query optimisations. It&#x27;ll make things much less obvious, as you would need to understand not only SQL, but also the process of translating intermediate language to SQL.<p>3. Automatic caching is bad. Database has its own caching and if that&#x27;s not enough, application can implement custom caching where it makes sense.<p>In my opinion the only worthy database integration could be implemented with full language support. So far I only saw it with C# LINQ or with database-first languages (PL&#x2F;SQL, etc). C# and Go are like on opposite spectrum of language design, so those who use Go probably should keep its approach by writing simple, verbose and obvious code.</div><br/><div id="42163647" class="c"><input type="checkbox" id="c-42163647" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163404">parent</a><span>|</span><a href="#42163641">next</a><span>|</span><label class="collapse" for="c-42163647">[-]</label><label class="expand" for="c-42163647">[1 more]</label></div><br/><div class="children"><div class="content">I find libraries like sqlx more than enough. Instead of a full-blown ORM, they simply help hydrate Go structs from returned SQL data, reducing boilerplate. I prefer the repository pattern, where a repository is responsible for retrieving data from storage (using sqlx) using simple, clean code. Often, projects which use full-blown ORMs, tend to equate SQL table = business object (aka ActiveRecord) which leads to lots of problems. Business logic should be completely decoupled from underlying storage, which is an implementation detail. But more often than not, ORM idiosyncracies end up leaking inside business logic all over the place. As for complex joins and what not, CQRS can be an answer. For read queries, you can write complex raw SQL queries and simply hydrate the results into lightweight structs, without having to construct business objects at all (i.e. no need for object-relational mapping in the first place). Stuff like aggregated results, etc. Such structs can be ad hoc, for very specific use cases, and they are easy to maintain and are very fast (no N+1 problems, etc). With projects like sqlx, it&#x27;s a matter of defining an additional struct and making a Select call.</div><br/></div></div><div id="42163641" class="c"><input type="checkbox" id="c-42163641" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163404">parent</a><span>|</span><a href="#42163647">prev</a><span>|</span><a href="#42164983">next</a><span>|</span><label class="collapse" for="c-42163641">[-]</label><label class="expand" for="c-42163641">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Go is not object-oriented language<p>That is most definitely not true. Go just uses composition instead of inheritance. Still OOP, just the data flow is reversed from bottom to the top.</div><br/><div id="42164085" class="c"><input type="checkbox" id="c-42164085" checked=""/><div class="controls bullet"><span class="by">nordsieck</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163641">parent</a><span>|</span><a href="#42163740">prev</a><span>|</span><a href="#42164581">next</a><span>|</span><label class="collapse" for="c-42164085">[-]</label><label class="expand" for="c-42164085">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Go is not object-oriented language<p>&gt; That is most definitely not true.<p>I think at best, you could say that Go is a multi-paradigm language.<p>It&#x27;s possible to write Go in an object oriented style.<p>It&#x27;s also possible to write programs with no methods at all (although you&#x27;d probably have to call methods from the standard library).<p>That&#x27;s in contrast to a language like Java or Ruby where it&#x27;s actually impossible to avoid creating objects.</div><br/><div id="42164205" class="c"><input type="checkbox" id="c-42164205" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42164085">parent</a><span>|</span><a href="#42164581">next</a><span>|</span><label class="collapse" for="c-42164205">[-]</label><label class="expand" for="c-42164205">[1 more]</label></div><br/><div class="children"><div class="content">Unless you happen to want to warm up the CPU, there is very little Go code that is possible to write that does anything useful without OOP concepts, like interfaces, methods and dynamic dispatch.<p>Creating objects on the heap isn&#x27;t the only defining feature how a language does OOP or not.</div><br/></div></div></div></div><div id="42164581" class="c"><input type="checkbox" id="c-42164581" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#42163167">root</a><span>|</span><a href="#42163641">parent</a><span>|</span><a href="#42164085">prev</a><span>|</span><a href="#42164983">next</a><span>|</span><label class="collapse" for="c-42164581">[-]</label><label class="expand" for="c-42164581">[1 more]</label></div><br/><div class="children"><div class="content">Go has objects, but objects alone does not imply orientation. For that, you need message passing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42164983" class="c"><input type="checkbox" id="c-42164983" checked=""/><div class="controls bullet"><span class="by">eweise</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42163189">prev</a><span>|</span><a href="#42163694">next</a><span>|</span><label class="collapse" for="c-42164983">[-]</label><label class="expand" for="c-42164983">[1 more]</label></div><br/><div class="children"><div class="content">here you go.<p>func Ptr[T any](v T) *T {
 return &amp;v
}</div><br/></div></div><div id="42163694" class="c"><input type="checkbox" id="c-42163694" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42163167">parent</a><span>|</span><a href="#42164983">prev</a><span>|</span><a href="#42165276">next</a><span>|</span><label class="collapse" for="c-42163694">[-]</label><label class="expand" for="c-42163694">[1 more]</label></div><br/><div class="children"><div class="content">Well, generics are mostly meant for library code. Just because you don&#x27;t need it, doesn&#x27;t mean that code you use doesn&#x27;t need it.</div><br/></div></div></div></div><div id="42165276" class="c"><input type="checkbox" id="c-42165276" checked=""/><div class="controls bullet"><span class="by">guilhas</span><span>|</span><a href="#42163167">prev</a><span>|</span><label class="collapse" for="c-42165276">[-]</label><label class="expand" for="c-42165276">[1 more]</label></div><br/><div class="children"><div class="content">I like in Go how the code looks like a execution graph, by avoiding smarts and just copying code, when you have an error in the log you can generally just follow it through the code as there is only one path to get there. In C# I would have mostly to debug to understand where did it came from<p>Not just because of the language, but of the simplify culture. Let&#x27;s see how generics will change that</div><br/></div></div></div></div></div></div></div></body></html>