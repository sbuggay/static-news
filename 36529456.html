<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688115646420" as="style"/><link rel="stylesheet" href="styles.css?v=1688115646420"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ziglang/zig/issues/16270">File for divorce from LLVM</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>detaro</span> | <span>83 comments</span></div><br/><div><div id="36530849" class="c"><input type="checkbox" id="c-36530849" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#36529777">next</a><span>|</span><label class="collapse" for="c-36530849">[-]</label><label class="expand" for="c-36530849">[6 more]</label></div><br/><div class="children"><div class="content">Andrew is super sharp so I imagine he and the team will get there now that it&#x27;s declared as a goal.<p>But man, it seems to me (uneducated on the challenges zig faces w&#x2F;LLVM) that this shifts the team&#x27;s capacity away from zig and towards things like binutils.  When I read the headline I assumed that they were throwing out the compiler (IIRC they had mostly&#x2F;totally excised it already).  But for a project like zig it just seems like there&#x27;s a lot to be gained from keeping it.<p>That said -- the prospect of rewriting a lot of the stuff that&#x27;s in the LLVM project now in zig instead of c++ - that&#x27;s pretty cool and ambitious.  Just as ambitious as it was for Lattner to create LLVM, I suppose.<p>But code that&#x27;s accidentally quadratic - well, that&#x27;s bound to happen to zig too, if it&#x27;s as popular and useful as LLVM project is.</div><br/><div id="36531038" class="c"><input type="checkbox" id="c-36531038" checked=""/><div class="controls bullet"><span class="by">Hermitian909</span><span>|</span><a href="#36530849">parent</a><span>|</span><a href="#36531370">next</a><span>|</span><label class="collapse" for="c-36531038">[-]</label><label class="expand" for="c-36531038">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m reminded of a recent interview with Chris Latner about the success of Swift - he credits the success to the fact that you could start with a large objective C project and begin writing Swift without rewriting anything. Part of Rust&#x27;s success is off the back of a similar compatibility with C&#x2F;C++.<p>It is difficult for me to imagine Zig succeeding without a similar capability - which is to say I hope they do not follow through on this milestone.</div><br/><div id="36531247" class="c"><input type="checkbox" id="c-36531247" checked=""/><div class="controls bullet"><span class="by">Ashymad</span><span>|</span><a href="#36530849">root</a><span>|</span><a href="#36531038">parent</a><span>|</span><a href="#36531370">next</a><span>|</span><label class="collapse" for="c-36531247">[-]</label><label class="expand" for="c-36531247">[2 more]</label></div><br/><div class="children"><div class="content">But rust absolutely does not have any C&#x2F;C++ compatibilty besides arguably very good FFI. And that&#x27;s where zig shines. They have a c&#x2F;c++ compiler built into the zig compiler via zig cc, that&#x27;s even easier to use than clang or GCC due to having the benefits of a buildscript and baked in libcs for different architectures, making crosscompilation a breeze.<p>In zig you _can_ actually start with a c codebase and rewrite it file by file in zig and you _can_ include c headers in your zig files verbatim. Both of these are not possible in rust.<p>This milestone is only gonna remove the c++ (and objective c&#x2F;c++) compiler for now from zig cc. So while you could argue this will ostracize people rewriting their c++ codebases in zig, I don&#x27;t imagine there&#x27;s actually many people like that.
EDIT: I just looked at the discussion and there&#x27;s actually a lot of people that use the c++ capapbilities.</div><br/><div id="36531633" class="c"><input type="checkbox" id="c-36531633" checked=""/><div class="controls bullet"><span class="by">colinsane</span><span>|</span><a href="#36530849">root</a><span>|</span><a href="#36531247">parent</a><span>|</span><a href="#36531370">next</a><span>|</span><label class="collapse" for="c-36531633">[-]</label><label class="expand" for="c-36531633">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In zig you _can_ actually start with a c codebase and rewrite it file by file in zig and you _can_ include c headers in your zig files verbatim. Both of these are not possible in rust.<p>well, you can: i <i>have</i> done this, with Rust. but yes, it’s more the type of thing that well-resourced companies do rather than solo devs, because even with Bindgen and the like Rust really wants the atomic codegen unit to be the “library”, not C’s notion of a “compilation unit”. still, C FFI compatibility is exactly why porting from C to rust incrementally is feasible while C to, say Java, is probably a bigger leap.</div><br/></div></div></div></div></div></div><div id="36531370" class="c"><input type="checkbox" id="c-36531370" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36530849">parent</a><span>|</span><a href="#36531038">prev</a><span>|</span><a href="#36532007">next</a><span>|</span><label class="collapse" for="c-36531370">[-]</label><label class="expand" for="c-36531370">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just as ambitious as it was for Lattner to create LLVM, I suppose.<p>A big difference is there was an element of no choice to LLVM, at least in Apple’s takeover of the project: GCC didn’t want to allow &#x2F; do what Apple wanted &#x2F; needed out of it.</div><br/></div></div><div id="36532007" class="c"><input type="checkbox" id="c-36532007" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#36530849">parent</a><span>|</span><a href="#36531370">prev</a><span>|</span><a href="#36529777">next</a><span>|</span><label class="collapse" for="c-36532007">[-]</label><label class="expand" for="c-36532007">[1 more]</label></div><br/><div class="children"><div class="content">binutils is quite a bit of a jack-of-all-trades code for handling binary code formats in portable ways, a compiler doesn&#x27;t need half of it (incl legacy) if you focus it more like TCC, the larger part will be code-generation across a bunch of architectures.</div><br/></div></div></div></div><div id="36529777" class="c"><input type="checkbox" id="c-36529777" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#36530849">prev</a><span>|</span><a href="#36530091">next</a><span>|</span><label class="collapse" for="c-36529777">[-]</label><label class="expand" for="c-36529777">[6 more]</label></div><br/><div class="children"><div class="content">With the amount Zig promoted being able to use it to compile c (and maybe c++ I forget) only to decide no LLVM at all seems wild. Without a LOT more people chipping in to support the odds of even coming close to the platform support of LLVM seems incredibly unlikely as well. I would understand planning to add another backend of their own for those who want that, but just getting rid of LLVM seems... rash?</div><br/><div id="36529962" class="c"><input type="checkbox" id="c-36529962" checked=""/><div class="controls bullet"><span class="by">hryx</span><span>|</span><a href="#36529777">parent</a><span>|</span><a href="#36530439">next</a><span>|</span><label class="collapse" for="c-36529962">[-]</label><label class="expand" for="c-36529962">[1 more]</label></div><br/><div class="children"><div class="content">It might be rash if work had already started on it, but as with the other proposals on the issue tracker not labeled with &quot;accepted&quot;, this is just a call for discussion and counter-proposals. At this point it&#x27;s just the team collecting feedback, learning about affected use cases, and gauging feasibility -- opposite of rash, I&#x27;d say.</div><br/></div></div><div id="36530439" class="c"><input type="checkbox" id="c-36530439" checked=""/><div class="controls bullet"><span class="by">audunw</span><span>|</span><a href="#36529777">parent</a><span>|</span><a href="#36529962">prev</a><span>|</span><a href="#36530080">next</a><span>|</span><label class="collapse" for="c-36530439">[-]</label><label class="expand" for="c-36530439">[1 more]</label></div><br/><div class="children"><div class="content">If you read the text in the linked issue you&#x27;ll see that there they&#x27;re not entirely removing the LLVM backend. They&#x27;re just decoupling it from the main binary, so you can still easily use LLVM as a backend if you have it installed on your system.<p>Makes sense, kind of silly to have to bundle a 100MB+ copy of LLVM if you don&#x27;t need it for the common case, and if you&#x27;re a developer you&#x27;ll probably have it installed already anyway.<p>The problem could be that it&#x27;ll be hard to guarantee that your Zig installation works properly with the version of LLVM you have installed? We&#x27;ll see..</div><br/></div></div><div id="36530080" class="c"><input type="checkbox" id="c-36530080" checked=""/><div class="controls bullet"><span class="by">cobbzilla</span><span>|</span><a href="#36529777">parent</a><span>|</span><a href="#36530439">prev</a><span>|</span><a href="#36530484">next</a><span>|</span><label class="collapse" for="c-36530080">[-]</label><label class="expand" for="c-36530080">[1 more]</label></div><br/><div class="children"><div class="content">It’ll still output LLVM bitcode, but it won’t depend on LLVM libs anymore<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;13265">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;13265</a></div><br/></div></div><div id="36530484" class="c"><input type="checkbox" id="c-36530484" checked=""/><div class="controls bullet"><span class="by">chrsig</span><span>|</span><a href="#36529777">parent</a><span>|</span><a href="#36530080">prev</a><span>|</span><a href="#36530477">next</a><span>|</span><label class="collapse" for="c-36530484">[-]</label><label class="expand" for="c-36530484">[1 more]</label></div><br/><div class="children"><div class="content">This was exactly my take on it.<p>I&#x27;d recently been reading a bit more about zig, and even tried out using it as an easy way to compile c++ with llvm without having to fuss with system packages -- transitioning from c&#x2F;c++ to zig was a major selling point<p>It just seems really abrupt, certainly unexpected.  I&#x27;m not saying it&#x27;s the right&#x2F;wrong thing for the project -- just really really out of left field from my point of view</div><br/></div></div><div id="36530477" class="c"><input type="checkbox" id="c-36530477" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#36529777">parent</a><span>|</span><a href="#36530484">prev</a><span>|</span><a href="#36530091">next</a><span>|</span><label class="collapse" for="c-36530477">[-]</label><label class="expand" for="c-36530477">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>and maybe c++ I forget</i><p>I use Zig as a C++ compiler on my Rust project since it was the least painful way to do cross-compilation in GitHub Actions.</div><br/></div></div></div></div><div id="36530091" class="c"><input type="checkbox" id="c-36530091" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#36529777">prev</a><span>|</span><a href="#36529670">next</a><span>|</span><label class="collapse" for="c-36530091">[-]</label><label class="expand" for="c-36530091">[5 more]</label></div><br/><div class="children"><div class="content">The DLang has 3 compilers:<p>1. gdc - based on the Gnu compiler collection back end<p>2. ldc - based on the LLVM back end<p>3. dmd - based on the x86 code generator that I wrote for Zortech&#x2F;Symantec&#x2F;Digital Mars<p>They each have their pluses, minuses, and targets. But the D language each supports is the same.<p>Overall, our users like the choice. Some even use more than one.</div><br/><div id="36531161" class="c"><input type="checkbox" id="c-36531161" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36530091">parent</a><span>|</span><a href="#36530404">next</a><span>|</span><label class="collapse" for="c-36531161">[-]</label><label class="expand" for="c-36531161">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool. Another language with multiple compilers is Common Lisp, which has a dozen or so production-ready compilers (some commercial, but most free).<p>That allows people to use the fastest compiler during development, and the fastest runtime (or smallest memory footprint) compiler for the final release, which is really useful.<p>Also, just having a language specification which all compilers adhere to ensures that the language is stable and won&#x27;t just break things under you (for better or worse, there are advantages for languages like Zig that can still change anything they want in order to make the language more consistent&#x2F;cleaner&#x2F;more powerful). I tend to value this stability a lot more these days - it lets me put all my effort in creating real value for users instead of constantly keeping up with development tools.</div><br/></div></div><div id="36530404" class="c"><input type="checkbox" id="c-36530404" checked=""/><div class="controls bullet"><span class="by">audunw</span><span>|</span><a href="#36530091">parent</a><span>|</span><a href="#36531161">prev</a><span>|</span><a href="#36530659">next</a><span>|</span><label class="collapse" for="c-36530404">[-]</label><label class="expand" for="c-36530404">[2 more]</label></div><br/><div class="children"><div class="content">Ah, the obligatory comment from Walter Bright talking about D in posts about Zig<p>(Nothing wrong with it, just a bit funny how predictable it has become)<p>I guess the interesting difference in approach here, is that D seems to have  completely separate compilers, while it looks like the main Zig compiler will support LLVM as a backend if you have it installed? If true, I like the approach Zig is going for.</div><br/><div id="36531794" class="c"><input type="checkbox" id="c-36531794" checked=""/><div class="controls bullet"><span class="by">agos</span><span>|</span><a href="#36530091">root</a><span>|</span><a href="#36530404">parent</a><span>|</span><a href="#36530659">next</a><span>|</span><label class="collapse" for="c-36531794">[-]</label><label class="expand" for="c-36531794">[1 more]</label></div><br/><div class="children"><div class="content">yesterday on a thread on DMD somebody quipped &quot;Funny how WalterBright seems to comment in every single HN thread other than this one...&quot; and I thought it was hyperbole. Next HN thread I open, I&#x27;m proven wrong</div><br/></div></div></div></div><div id="36530659" class="c"><input type="checkbox" id="c-36530659" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36530091">parent</a><span>|</span><a href="#36530404">prev</a><span>|</span><a href="#36529670">next</a><span>|</span><label class="collapse" for="c-36530659">[-]</label><label class="expand" for="c-36530659">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Overall, our users like the choice.</i><p>All 10 of them? I mean, if Zig&#x27;s target is eventual wide adoption, DLang is not a good precedent to model upon.</div><br/></div></div></div></div><div id="36529670" class="c"><input type="checkbox" id="c-36529670" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#36530091">prev</a><span>|</span><a href="#36530525">next</a><span>|</span><label class="collapse" for="c-36529670">[-]</label><label class="expand" for="c-36529670">[7 more]</label></div><br/><div class="children"><div class="content">While on one hand, I admire the fastidious desire to reduce dependencies, the trade offs seem pretty dire.<p>The loss of C++ compatibility effectively removes the biggest thing that my Zig fan friends mention to me.<p>The loss of performance (however temporary they say) is the other piece they mention.</div><br/><div id="36529675" class="c"><input type="checkbox" id="c-36529675" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#36529670">parent</a><span>|</span><a href="#36530525">next</a><span>|</span><label class="collapse" for="c-36529675">[-]</label><label class="expand" for="c-36529675">[6 more]</label></div><br/><div class="children"><div class="content">Yeah it seems like most of the responses are against this proposal<p>For casual readers, it&#x27;s a proposal, not something decided</div><br/><div id="36529802" class="c"><input type="checkbox" id="c-36529802" checked=""/><div class="controls bullet"><span class="by">tyg13</span><span>|</span><a href="#36529670">root</a><span>|</span><a href="#36529675">parent</a><span>|</span><a href="#36530525">next</a><span>|</span><label class="collapse" for="c-36529802">[-]</label><label class="expand" for="c-36529802">[5 more]</label></div><br/><div class="children"><div class="content">Sure, but it&#x27;s a proposal from Andrew Kelley, the language creator, and it&#x27;s got a bunch of thought-out subitems that seem to have real progress being made. It seems more likely than not that this will come to pass, unless the community reaction really is heavily against.</div><br/><div id="36529939" class="c"><input type="checkbox" id="c-36529939" checked=""/><div class="controls bullet"><span class="by">tiehuis</span><span>|</span><a href="#36529670">root</a><span>|</span><a href="#36529802">parent</a><span>|</span><a href="#36529853">next</a><span>|</span><label class="collapse" for="c-36529939">[-]</label><label class="expand" for="c-36529939">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t assume that just because Andrew has written the proposal it will be accepted. There have been plenty of times where proposals from Andrew have been rejected and&#x2F;or reworked.<p>The sub-items of this task are still valuable to complete even if this overarching proposal were declined. Most of them are not being completed as a prerequisite for this proposal. There are benefits gained even without the full removal of LLVM.<p>I can really respect the really wide-reaching views and goals of Andrew with zig and in proposals like this, even if I don&#x27;t agree.</div><br/></div></div><div id="36529853" class="c"><input type="checkbox" id="c-36529853" checked=""/><div class="controls bullet"><span class="by">paddw</span><span>|</span><a href="#36529670">root</a><span>|</span><a href="#36529802">parent</a><span>|</span><a href="#36529939">prev</a><span>|</span><a href="#36529838">next</a><span>|</span><label class="collapse" for="c-36529853">[-]</label><label class="expand" for="c-36529853">[2 more]</label></div><br/><div class="children"><div class="content">I mean, one of the checkboxes under LLVM is literally &quot;optimization passes&quot;, so... I don&#x27;t know how close they are to the end goal in terms of progress actually</div><br/><div id="36529869" class="c"><input type="checkbox" id="c-36529869" checked=""/><div class="controls bullet"><span class="by">tyg13</span><span>|</span><a href="#36529670">root</a><span>|</span><a href="#36529853">parent</a><span>|</span><a href="#36529838">next</a><span>|</span><label class="collapse" for="c-36529869">[-]</label><label class="expand" for="c-36529869">[1 more]</label></div><br/><div class="children"><div class="content">I did get quite a hearty chuckle out of that.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36530525" class="c"><input type="checkbox" id="c-36530525" checked=""/><div class="controls bullet"><span class="by">blindseer</span><span>|</span><a href="#36529670">prev</a><span>|</span><a href="#36529931">next</a><span>|</span><label class="collapse" for="c-36530525">[-]</label><label class="expand" for="c-36530525">[1 more]</label></div><br/><div class="children"><div class="content">One of the main reasons Zig was interesting to me was the fact that I could drop it in as an alternative to a C&#x2F;C++ compiler. On Windows, my friends have mentioned how it is easier to install Zig as a C&#x2F;C++ compiler than any other alternative.<p>If this proposal is accepted, I personally think Zig will drop to the popularity level of Hare or other extremely niche languages. Getting my colleagues to even try Zig out required me sending them articles about how Uber was using it in production. There is no way my colleagues would even have given it a second thought if it didn&#x27;t have immediate value to their existing projects.<p>But I get where the proposal is coming from. LLVM compile times can seem awful, and there&#x27;s lots of neat optimization tricks you could implement with your own byte code. And dealing with bugs in LLVM is basically a no-go, I&#x27;ve seen this happen in the Julia ecosystem as well.<p>If my recommendations are worth anything, I think Zig should<p>1. Use a custom bytecode for debug builds - fast build times, fast debug times etc
2. Use LLVM for release builds - fast runtime performance, slow release performance<p>If they can manage 1.) while still maintaining support for cross compiling C&#x2F;C++ (just pass that part off to LLVM?) I think that might be the best of all worlds, with the tradeoff that there&#x27;s additional backend code to maintain.</div><br/></div></div><div id="36529931" class="c"><input type="checkbox" id="c-36529931" checked=""/><div class="controls bullet"><span class="by">frmdstryr</span><span>|</span><a href="#36530525">prev</a><span>|</span><a href="#36529694">next</a><span>|</span><label class="collapse" for="c-36529931">[-]</label><label class="expand" for="c-36529931">[11 more]</label></div><br/><div class="children"><div class="content">So I spent ~4 years writing all my embedded projects (and libraries) in Zig and now several &quot;tier 1&quot; supported arches are just going to be dropped?<p>It&#x27;s your language so do whatever you want but please adjust the branding accordingly...</div><br/><div id="36530466" class="c"><input type="checkbox" id="c-36530466" checked=""/><div class="controls bullet"><span class="by">audunw</span><span>|</span><a href="#36529931">parent</a><span>|</span><a href="#36530089">next</a><span>|</span><label class="collapse" for="c-36530466">[-]</label><label class="expand" for="c-36530466">[1 more]</label></div><br/><div class="children"><div class="content">Are they being dropped?<p>Im guessing you&#x27;ll have two categories of tier 1 support: 
- Built-in tier 1 support.
- Tier 1 support through the optional LLVM backend.<p>If they already have tier 1 support for an architecture, I don&#x27;t see why they&#x27;d loose that support when they make the LLVM backend an optional dependency?<p>And as Andrew writes in the proposal, this way might provide a path for better support for more obscure architectures. I would happily work on a backend for Zig for some interesting processor architecture. No way I will ever contribute to LLVM. Working with C++ in not something I&#x27;ll ever do to fun</div><br/></div></div><div id="36530089" class="c"><input type="checkbox" id="c-36530089" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#36529931">parent</a><span>|</span><a href="#36530466">prev</a><span>|</span><a href="#36530399">next</a><span>|</span><label class="collapse" for="c-36530089">[-]</label><label class="expand" for="c-36530089">[6 more]</label></div><br/><div class="children"><div class="content">They&#x27;re dropping LLVM by re-implementing everything it does in their own homegrown fashion?...<p>To what benefit? Isn&#x27;t this a waste of resources?</div><br/><div id="36531533" class="c"><input type="checkbox" id="c-36531533" checked=""/><div class="controls bullet"><span class="by">delphLonepaw</span><span>|</span><a href="#36529931">root</a><span>|</span><a href="#36530089">parent</a><span>|</span><a href="#36530241">next</a><span>|</span><label class="collapse" for="c-36531533">[-]</label><label class="expand" for="c-36531533">[3 more]</label></div><br/><div class="children"><div class="content">LLVM just works well on the front that clang uses, after that, llvm itself is a wild beast full of worms, which is becoming more and more painful to work with if you are a language creator&#x2F;mantainer, A lot of untested paths, and hidden bugs that zig has hit before... many times.<p>It will NOT reimplement everything, if you read the proposal, it&#x27;s in favour of changing the LLVM dependency (the libs) not dropping LLVM IR generation, this will come with performance regression since now will be up to the team to get the correct IR, and making decisions LLVM IR generation does already in LLVM<p>The problem is that clang is being dropped, which means, unless we have a new C++ front made in zig (a-la AroCC for C) we are gonna suffer quite a bit for projects using C++ with zig.</div><br/><div id="36532170" class="c"><input type="checkbox" id="c-36532170" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#36529931">root</a><span>|</span><a href="#36531533">parent</a><span>|</span><a href="#36532106">next</a><span>|</span><label class="collapse" for="c-36532170">[-]</label><label class="expand" for="c-36532170">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unless we have a new C++ front made in zig<p>Writing a C++ compiler is several order of magnitude more complicated than writing a C, Java, Go or Zig compiler. There&#x27;s a very good reason there are only 3 in existence despite how ubiquitous C++ is (and even then, it takes years for them to keep up with the latest standards). C++&#x27;s grammar is type 0, there&#x27;s isn&#x27;t even an EBNF definition of it because it&#x27;s pratically impossible to write a complete one. Clang only succeeded thanks to massive investments from the biggest players in the industry, and GCC&#x2F;MSVC simply grew alongside the language. All other C++ compilers died a horrible death a long time ago.</div><br/></div></div><div id="36532106" class="c"><input type="checkbox" id="c-36532106" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#36529931">root</a><span>|</span><a href="#36531533">parent</a><span>|</span><a href="#36532170">prev</a><span>|</span><a href="#36530241">next</a><span>|</span><label class="collapse" for="c-36532106">[-]</label><label class="expand" for="c-36532106">[1 more]</label></div><br/><div class="children"><div class="content">&gt; unless we have a new C++ front made in zig<p>that seems a monumental undertaking.</div><br/></div></div></div></div><div id="36530241" class="c"><input type="checkbox" id="c-36530241" checked=""/><div class="controls bullet"><span class="by">brucethemoose2</span><span>|</span><a href="#36529931">root</a><span>|</span><a href="#36530089">parent</a><span>|</span><a href="#36531533">prev</a><span>|</span><a href="#36530399">next</a><span>|</span><label class="collapse" for="c-36530241">[-]</label><label class="expand" for="c-36530241">[2 more]</label></div><br/><div class="children"><div class="content">The reasoning seems to be the flood of LLVM bugs, but I don&#x27;t think reinventing such a large wheel will be any easier.</div><br/><div id="36530837" class="c"><input type="checkbox" id="c-36530837" checked=""/><div class="controls bullet"><span class="by">prpl</span><span>|</span><a href="#36529931">root</a><span>|</span><a href="#36530241">parent</a><span>|</span><a href="#36530399">next</a><span>|</span><label class="collapse" for="c-36530837">[-]</label><label class="expand" for="c-36530837">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like some of those bugs are just related to people using distro compilers?</div><br/></div></div></div></div></div></div><div id="36530399" class="c"><input type="checkbox" id="c-36530399" checked=""/><div class="controls bullet"><span class="by">TUSF</span><span>|</span><a href="#36529931">parent</a><span>|</span><a href="#36530089">prev</a><span>|</span><a href="#36530057">next</a><span>|</span><label class="collapse" for="c-36530399">[-]</label><label class="expand" for="c-36530399">[1 more]</label></div><br/><div class="children"><div class="content">This is only still at the proposal stage. The Github issue is mostly for posting usecases for and against, etc… It&#x27;s not &quot;Accepted&quot;.</div><br/></div></div><div id="36530057" class="c"><input type="checkbox" id="c-36530057" checked=""/><div class="controls bullet"><span class="by">harerazer</span><span>|</span><a href="#36529931">parent</a><span>|</span><a href="#36530399">prev</a><span>|</span><a href="#36529694">next</a><span>|</span><label class="collapse" for="c-36530057">[-]</label><label class="expand" for="c-36530057">[2 more]</label></div><br/><div class="children"><div class="content">I mean, it’s no secret that zig is pre 1.0. I’m not sure this is on them, although it does seem like a drastic proposal.</div><br/><div id="36531114" class="c"><input type="checkbox" id="c-36531114" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36529931">root</a><span>|</span><a href="#36530057">parent</a><span>|</span><a href="#36529694">next</a><span>|</span><label class="collapse" for="c-36531114">[-]</label><label class="expand" for="c-36531114">[1 more]</label></div><br/><div class="children"><div class="content">One of the mantras for Andrew Kelly has been &quot;do not use Zig in production&quot; until it hits 1.0.<p>People know that, but it&#x27;s difficult to avoid using it for real things once you&#x27;ve tried it and it works :D.<p>I haven&#x27;t done that with Zig, but with Kotlin things like serialization&#x2F;coroutines&#x2F;kotest&#x2F;KAPT (it was the same feeling: oh this stuff is &quot;Experimental&quot; but so cool, I can&#x27;t do real Kotlin without them!!)... well yeah, I spent many hours rewriting stuff due to that, and totally acknowledge that was on me.</div><br/></div></div></div></div></div></div><div id="36529694" class="c"><input type="checkbox" id="c-36529694" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#36529931">prev</a><span>|</span><a href="#36530560">next</a><span>|</span><label class="collapse" for="c-36529694">[-]</label><label class="expand" for="c-36529694">[5 more]</label></div><br/><div class="children"><div class="content">The correct time to build something without LLVM was years ago, but taking the C++ functionality out now will probably be the end of Zig. I&#x27;m surprised they didn&#x27;t announce a plan to write their own C++ compiler in Zig instead of phasing it out.</div><br/><div id="36529792" class="c"><input type="checkbox" id="c-36529792" checked=""/><div class="controls bullet"><span class="by">sidewndr46</span><span>|</span><a href="#36529694">parent</a><span>|</span><a href="#36530560">next</a><span>|</span><label class="collapse" for="c-36529792">[-]</label><label class="expand" for="c-36529792">[4 more]</label></div><br/><div class="children"><div class="content">Just writing a parser for C++ is a gargantuan project. I&#x27;m not even sure if an individual can write a C++ compiler if they started on their 18th birthday. There may not be enough hours left in their life to write a functioning compiler.</div><br/><div id="36531982" class="c"><input type="checkbox" id="c-36531982" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36529694">root</a><span>|</span><a href="#36529792">parent</a><span>|</span><a href="#36531705">next</a><span>|</span><label class="collapse" for="c-36531982">[-]</label><label class="expand" for="c-36531982">[1 more]</label></div><br/><div class="children"><div class="content">Check the history of Circle, not only did Sean Baxter implement a full C++ compiler frontend, it has lots of extensions from all C++ wannabe replacements and a Rust like borrow checker.</div><br/></div></div><div id="36531705" class="c"><input type="checkbox" id="c-36531705" checked=""/><div class="controls bullet"><span class="by">strager</span><span>|</span><a href="#36529694">root</a><span>|</span><a href="#36529792">parent</a><span>|</span><a href="#36531982">prev</a><span>|</span><a href="#36530527">next</a><span>|</span><label class="collapse" for="c-36531705">[-]</label><label class="expand" for="c-36531705">[1 more]</label></div><br/><div class="children"><div class="content">Sean Baxter is doing a decent job with his Circle compiler, so I hear. <a href="https:&#x2F;&#x2F;www.circle-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.circle-lang.org&#x2F;</a></div><br/></div></div><div id="36530527" class="c"><input type="checkbox" id="c-36530527" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#36529694">root</a><span>|</span><a href="#36529792">parent</a><span>|</span><a href="#36531705">prev</a><span>|</span><a href="#36530560">next</a><span>|</span><label class="collapse" for="c-36530527">[-]</label><label class="expand" for="c-36530527">[1 more]</label></div><br/><div class="children"><div class="content">I forget, but what was that C++ parser test suite that almost no compiler passed?<p>I bet you&#x27;ll solve P=NP before finishing that C++ parser.</div><br/></div></div></div></div></div></div><div id="36530560" class="c"><input type="checkbox" id="c-36530560" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#36529694">prev</a><span>|</span><a href="#36530293">next</a><span>|</span><label class="collapse" for="c-36530560">[-]</label><label class="expand" for="c-36530560">[1 more]</label></div><br/><div class="children"><div class="content">Zig wants to be the world new <i>C</i> not so much the worlds new <i>C++</i>. You’ll note that <i>C</i> cross compilation would still be supported under this proposal.<p>I think this might be the right choice. C is currently used heavily in the embedded world, and that’s a space where llvm is not good. If I was Zig, I’d want to be able to target all the microcontrollers and this is the only real way to achieve that.</div><br/></div></div><div id="36530293" class="c"><input type="checkbox" id="c-36530293" checked=""/><div class="controls bullet"><span class="by">CTDOCodebases</span><span>|</span><a href="#36530560">prev</a><span>|</span><a href="#36531404">next</a><span>|</span><label class="collapse" for="c-36530293">[-]</label><label class="expand" for="c-36530293">[3 more]</label></div><br/><div class="children"><div class="content">I misread the title and expected to see a LLM that was designed for the specific use case of filing for divorce.</div><br/><div id="36531072" class="c"><input type="checkbox" id="c-36531072" checked=""/><div class="controls bullet"><span class="by">yathaid</span><span>|</span><a href="#36530293">parent</a><span>|</span><a href="#36530434">prev</a><span>|</span><a href="#36531404">next</a><span>|</span><label class="collapse" for="c-36531072">[-]</label><label class="expand" for="c-36531072">[1 more]</label></div><br/><div class="children"><div class="content">Same! :)</div><br/></div></div></div></div><div id="36531404" class="c"><input type="checkbox" id="c-36531404" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#36530293">prev</a><span>|</span><a href="#36530387">next</a><span>|</span><label class="collapse" for="c-36531404">[-]</label><label class="expand" for="c-36531404">[1 more]</label></div><br/><div class="children"><div class="content">Surprising that the issue is full of comments from users who are currently using Zig to compile C++. Hopefully this won&#x27;t be the deciding thing.</div><br/></div></div><div id="36530387" class="c"><input type="checkbox" id="c-36530387" checked=""/><div class="controls bullet"><span class="by">DannyBee</span><span>|</span><a href="#36531404">prev</a><span>|</span><a href="#36529912">next</a><span>|</span><label class="collapse" for="c-36530387">[-]</label><label class="expand" for="c-36530387">[8 more]</label></div><br/><div class="children"><div class="content">Some of this reasoning is just wild.<p>1. &quot;We can attract direct contributions from Intel, ARM, RISC-V chip manufacturers, etc., who have a vested interest in making our machine code better on their CPUs.&quot;<p>They are nowhere near popular enough (or used enough by some particularly important customer) for any major architecture vendor to spend any time contributing except as someone&#x27;s random side project. To think otherwise is ... really out there.<p>2. &quot;We can implement our own optimization passes that push the state of the art of computing forward.&quot;<p>There are in fact, no magic bullets.  Once you pass the baseline of optimization capability, the reason these compilers do well is because they&#x27;ve been worked on forever, and made better 0.2% at a time.<p>Also, anything you implement they can implement.  Maybe it takes annotations, or whatever, but that&#x27;s about speed and not capability.<p>3. &quot;Compilation speed is increased by orders of magnitude.&quot;<p>Uh, not if you are doing #2.  Most optimization passes, especially when you are first productionizing research, are quite bad.  It takes a tremendous amount of applied engineering to make them fast.<p>This is what i did on both GCC and LLVM.  Implement and speed up ad nauseum.  I implemented plenty of high-optimization-value, never been productionized before algorithms.  It usually took a few versions and lots of slow-compiler bugs to figure out the best way to implement.  It turns out most researchers are not spending their time working on the compilation speed. At best, they care that it&#x27;s passable.<p>For existing well-productionized algorithms (which don&#x27;t push the state of the art), you will not get orders of magnitude speedup.  You may get some percent depending on how you structure your compiler.<p>There are certainly slow parts of LLVM, but it&#x27;s hubris to believe you are going to make something both better optimizing, and seriously faster, for this kind of language.
There are other languages for which it is true. Zig is super unlikely to to be one of them.<p>The way you gain compilation speed for this kind of language is to optimize less.  Spend as little time processing things into machine code as possible, using as fast of algorithms as possible, and where you can&#x27;t, relying on heuristics and such more to help generate good enough code most of the time.<p>There is more, but man, this feels out there.<p>If they said &quot;we want to get 90% of the performance at 60% of the cost&quot;, sure, maybe.
But saying, basically, we will get &gt;100% of the performance at &quot;orders of magnitude&quot; (their claim) less cost is just, as i said, a wild idea. 
I wish them the best of luck.<p>Everyone who tries to reinvent good infrastructure is doomed to discover why that infrastructure was invented in the first place
.</div><br/><div id="36530864" class="c"><input type="checkbox" id="c-36530864" checked=""/><div class="controls bullet"><span class="by">jroesch</span><span>|</span><a href="#36530387">parent</a><span>|</span><a href="#36530542">next</a><span>|</span><label class="collapse" for="c-36530864">[-]</label><label class="expand" for="c-36530864">[2 more]</label></div><br/><div class="children"><div class="content">Long time compiler hacker&#x2F;engineer and compiler&#x2F;programming language PhD here all great points. Worth saying out loud that many reasons why this stuff is slow is not due to bad code, its due to the fact that many of the best algorithms are in higher complexity classes and just scale poorly with program&#x2F;translation unit size. For example when I was working on `rustc` a big challenge was heavy reliance on inlining and inlining has a cost, plus it increases program sizes making everything else take longer as well.<p>I feel like Go already went through a whole saga of this where the community started with &quot;LLVM and SSA are bad and slow&quot;, then a few years go by and they end up building their own SSA IR and spending a bunch of time trying to bring compilation time closer to what it was before as it made everything much slower.</div><br/><div id="36531563" class="c"><input type="checkbox" id="c-36531563" checked=""/><div class="controls bullet"><span class="by">vocx2tx</span><span>|</span><a href="#36530387">root</a><span>|</span><a href="#36530864">parent</a><span>|</span><a href="#36530542">next</a><span>|</span><label class="collapse" for="c-36531563">[-]</label><label class="expand" for="c-36531563">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I feel like Go already went through a whole saga of this where the community started with &quot;LLVM and SSA are bad and slow&quot;<p>I&#x27;ve been a contributor since the Go compiler was a tree-based C program and I&#x27;ve never heard anyone say that. What they said (and it&#x27;s in the Go FAQ page) is: &quot;At the beginning of the project we considered using LLVM for gc but decided it was too large and slow to meet our performance goals.&quot; [1]<p>If you&#x27;re building a language with the explicit goal to make it compile fast, it&#x27;s objectively true that starting out with LLVM is not the best approach. You&#x27;ll get incredible runtime performance of the generated code since the early days, but NOT fast compilation. The Go makers choose a different tradeoff.<p>&gt; and they end up building their own SSA IR<p>They switched to a SSA IR because it was a good idea to begin with, after an initial phase with the tree-base prototype. I&#x27;ve also never heard anyone argue that &quot;SSA is bad&quot;, despite what you claim. The first compiler was tree-based because they reused a simple tree-based C compiler from plan9.<p>&gt; building their own SSA IR and  spending a bunch of time trying to bring compilation time closer to what it was before as it made everything much slower<p>The new compiler was ported to Go (machine-rewritten from C) and that&#x27;s the main reason it was ~2x slower than the old compiler. It&#x27;s not due to the switch to a SSA-IR.<p>[1] <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#Implementation" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;faq#Implementation</a></div><br/></div></div></div></div><div id="36530542" class="c"><input type="checkbox" id="c-36530542" checked=""/><div class="controls bullet"><span class="by">defen</span><span>|</span><a href="#36530387">parent</a><span>|</span><a href="#36530864">prev</a><span>|</span><a href="#36530708">next</a><span>|</span><label class="collapse" for="c-36530542">[-]</label><label class="expand" for="c-36530542">[4 more]</label></div><br/><div class="children"><div class="content">I agree that it&#x27;s probably impossible to write something that is orders of magnitude faster than LLVM <i>and</i> better than LLVM at optimizing, but I don&#x27;t see that claim in the original text.<p>It seems like a lot of work but also doable to create something that is orders of magnitude faster than LLVM for unoptimized debug builds. Furthermore, the Zig compiler might be an easier thing to work with than LLVM&#x2F;Clang for doing productionizing of optimization research.</div><br/><div id="36530673" class="c"><input type="checkbox" id="c-36530673" checked=""/><div class="controls bullet"><span class="by">Solvency</span><span>|</span><a href="#36530387">root</a><span>|</span><a href="#36530542">parent</a><span>|</span><a href="#36530708">next</a><span>|</span><label class="collapse" for="c-36530673">[-]</label><label class="expand" for="c-36530673">[3 more]</label></div><br/><div class="children"><div class="content">Just to play devils advocate..who would&#x27;ve thought Javascript would ever end up as blazingly fast as it has become since V8. Maybe Zigworld can do it.</div><br/><div id="36530898" class="c"><input type="checkbox" id="c-36530898" checked=""/><div class="controls bullet"><span class="by">jroesch</span><span>|</span><a href="#36530387">root</a><span>|</span><a href="#36530673">parent</a><span>|</span><a href="#36530708">next</a><span>|</span><label class="collapse" for="c-36530898">[-]</label><label class="expand" for="c-36530898">[2 more]</label></div><br/><div class="children"><div class="content">As the parent comment said, and I mentioned in my reply. JavaScript was just incredibly poorly optimized&#x2F;not compiled and they applied 20-30 years worth of compiler research to make it significantly faster. You also had an alliance of every hyperscaler working on the tooling for a decade plus with help from all major hardware vendors to bring the best performance out of it. One driver of LLVM was Apple and WebKit which at one point was using LLVM for its JIT compiler so many improvements figured out in that period have also already been applied to LLVM.<p>LLVM already has decades of research applied to it to make it produce fast code, it will be incredibly challenging to even match its performance across all the targets it supports let alone improve on it in significant ways. It would be better to spend the time building an optimization pipeline for Zig itself and being more thoughtful about what code you send to LLVM versus trying to replace it wholesale.</div><br/><div id="36531348" class="c"><input type="checkbox" id="c-36531348" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36530387">root</a><span>|</span><a href="#36530898">parent</a><span>|</span><a href="#36530708">next</a><span>|</span><label class="collapse" for="c-36531348">[-]</label><label class="expand" for="c-36531348">[1 more]</label></div><br/><div class="children"><div class="content">Apple, of course, dropped LLVM at some point after it didn’t meet their latency needs.</div><br/></div></div></div></div></div></div></div></div><div id="36530708" class="c"><input type="checkbox" id="c-36530708" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#36530387">parent</a><span>|</span><a href="#36530542">prev</a><span>|</span><a href="#36529912">next</a><span>|</span><label class="collapse" for="c-36530708">[-]</label><label class="expand" for="c-36530708">[1 more]</label></div><br/><div class="children"><div class="content">My impression is that LLVM spends the bulk of its time chasing pointers, so one could fix the issue by &quot;only&quot; changing the layout of the data to one that is friendlier to computers.</div><br/></div></div></div></div><div id="36529912" class="c"><input type="checkbox" id="c-36529912" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#36530387">prev</a><span>|</span><a href="#36530703">next</a><span>|</span><label class="collapse" for="c-36529912">[-]</label><label class="expand" for="c-36529912">[5 more]</label></div><br/><div class="children"><div class="content">This move... is it for great justice?</div><br/><div id="36530365" class="c"><input type="checkbox" id="c-36530365" checked=""/><div class="controls bullet"><span class="by">timmytokyo</span><span>|</span><a href="#36529912">parent</a><span>|</span><a href="#36530703">next</a><span>|</span><label class="collapse" for="c-36530365">[-]</label><label class="expand" for="c-36530365">[4 more]</label></div><br/><div class="children"><div class="content">I see your comment is getting downvotes, but that&#x27;s probably because people didn&#x27;t get the joke. In addition to being the name of the programming language, Zig is a character in the old Namco &#x27;Zero Wing&#x27; game, which is where the meme &quot;All your base are belong to us&quot; comes from [1]. &quot;For great justice&quot; is part of the same meme.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;All_your_base_are_belong_to_us" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;All_your_base_are_belong_to_us</a></div><br/><div id="36530605" class="c"><input type="checkbox" id="c-36530605" checked=""/><div class="controls bullet"><span class="by">thaliaarchi</span><span>|</span><a href="#36529912">root</a><span>|</span><a href="#36530365">parent</a><span>|</span><a href="#36530372">next</a><span>|</span><label class="collapse" for="c-36530605">[-]</label><label class="expand" for="c-36530605">[1 more]</label></div><br/><div class="children"><div class="content">Andrew Kelley even referenced this in the proposal:<p>&gt; In exchange, Zig gains these benefits:<p>&gt; - All our bugs are belong to us.<p>&gt; - …</div><br/></div></div><div id="36530372" class="c"><input type="checkbox" id="c-36530372" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#36529912">root</a><span>|</span><a href="#36530365">parent</a><span>|</span><a href="#36530605">prev</a><span>|</span><a href="#36530703">next</a><span>|</span><label class="collapse" for="c-36530372">[-]</label><label class="expand" for="c-36530372">[2 more]</label></div><br/><div class="children"><div class="content">I did not get this, and appreciate you providing the context</div><br/><div id="36530459" class="c"><input type="checkbox" id="c-36530459" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#36529912">root</a><span>|</span><a href="#36530372">parent</a><span>|</span><a href="#36530703">next</a><span>|</span><label class="collapse" for="c-36530459">[-]</label><label class="expand" for="c-36530459">[1 more]</label></div><br/><div class="children"><div class="content">It does require a bit of a PhD on gaming and Internet history.</div><br/></div></div></div></div></div></div></div></div><div id="36530703" class="c"><input type="checkbox" id="c-36530703" checked=""/><div class="controls bullet"><span class="by">schemescape</span><span>|</span><a href="#36529912">prev</a><span>|</span><a href="#36529774">next</a><span>|</span><label class="collapse" for="c-36530703">[-]</label><label class="expand" for="c-36530703">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll admit that I&#x27;ve only considered using Zig for its ability to easily compile (and cross-compile) C&#x2F;C++ code into static binaries.<p>Hopefully if any of that functionality gets removed someone manages to fork off the &quot;C&#x2F;C++ magic&quot; part into its own project. Clang itself is much less convenient to use.</div><br/></div></div><div id="36529774" class="c"><input type="checkbox" id="c-36529774" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36530703">prev</a><span>|</span><a href="#36529874">next</a><span>|</span><label class="collapse" for="c-36529774">[-]</label><label class="expand" for="c-36529774">[8 more]</label></div><br/><div class="children"><div class="content">Every time I hear about LLVM, it turns into a rant. Clearly there is a problem there that needs to be fixed. Maybe the LLVM project team should address those issues.</div><br/><div id="36529856" class="c"><input type="checkbox" id="c-36529856" checked=""/><div class="controls bullet"><span class="by">tyg13</span><span>|</span><a href="#36529774">parent</a><span>|</span><a href="#36530004">next</a><span>|</span><label class="collapse" for="c-36529856">[-]</label><label class="expand" for="c-36529856">[4 more]</label></div><br/><div class="children"><div class="content">The &quot;problem&quot; with the LLVM project is its massive success, coupled with its incredibly difficult problem domain. Turns out it&#x27;s actually <i>really hard</i> to write modular compiler infrastructure that serves as the optimizer <i>and</i> code generator for N different arbitrary programming languages. The fact that it works in this capacity at all, and still manages to be competitive with GCC in its original use-case (being a C&#x2F;C++ backend) is a monumental and unmatched achievement.<p>As someone who works on an LLVM-based compiler at $DayJob and also has written a compiler front-end that uses LLVM in my free time, I do have a ton of gripes, but any time I feel particularly frustrated by them, I spend a little bit of time working on my non-LLVM backend. After a few days of angry swearing with little to show for it, I go back to working with LLVM with a much greater appreciation for what it&#x27;s giving me.</div><br/><div id="36531993" class="c"><input type="checkbox" id="c-36531993" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36529774">root</a><span>|</span><a href="#36529856">parent</a><span>|</span><a href="#36531569">next</a><span>|</span><label class="collapse" for="c-36531993">[-]</label><label class="expand" for="c-36531993">[1 more]</label></div><br/><div class="children"><div class="content">When clang came about, GCC was already renamed into GNU Compiler Collection.</div><br/></div></div><div id="36531569" class="c"><input type="checkbox" id="c-36531569" checked=""/><div class="controls bullet"><span class="by">bitcoinmoney</span><span>|</span><a href="#36529774">root</a><span>|</span><a href="#36529856">parent</a><span>|</span><a href="#36531993">prev</a><span>|</span><a href="#36530447">next</a><span>|</span><label class="collapse" for="c-36531569">[-]</label><label class="expand" for="c-36531569">[1 more]</label></div><br/><div class="children"><div class="content">Btw, is there a good learning pathway for LLVM&#x2F;MLIR for folks w&#x2F;o compiler background? I come mostly from HW but is super interested in the topic due to work-related stuff. Since your day job is LLVM related maybe you can give great advice.</div><br/></div></div><div id="36530447" class="c"><input type="checkbox" id="c-36530447" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#36529774">root</a><span>|</span><a href="#36529856">parent</a><span>|</span><a href="#36531569">prev</a><span>|</span><a href="#36530004">next</a><span>|</span><label class="collapse" for="c-36530447">[-]</label><label class="expand" for="c-36530447">[1 more]</label></div><br/><div class="children"><div class="content">You got pro tips for working with LLVM types after parsing LLVM IR? I can&#x27;t for the life of me figure out where in the class hierarchy I am, and the doxygen is... interesting. Language wrangling is much nicer in a language with proper ADTs like Haskell, but I also feel like there&#x27;s probably that bit of LLVM documentation that I haven&#x27;t read.</div><br/></div></div></div></div><div id="36530004" class="c"><input type="checkbox" id="c-36530004" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#36529774">parent</a><span>|</span><a href="#36529856">prev</a><span>|</span><a href="#36530127">next</a><span>|</span><label class="collapse" for="c-36530004">[-]</label><label class="expand" for="c-36530004">[1 more]</label></div><br/><div class="children"><div class="content">Part of the issue is that LLVM is stuck between two very hard places.<p>1. Needing to support tons of different platforms with various different documented and undocumented behaviours<p>2. Needing to support many languages with specifically undefined behaviour.<p>Trying to bridge the  undefined nature of the two sides means that things can be fragile. Assumptions that worked for one set of undefined problems may not work for another.<p>But so much depends on LLVM these days that I can’t think of it as anything but a success. A flawed success but one that is doing its best to bring order to a naturally chaotic problem space.<p>GCC and MSVC have similar problems because it’s inherent to the problem space. So while it’s frustrating hitting those bugs, everyone in the space knows they aren’t fundamental issues with the project itself.</div><br/></div></div><div id="36530127" class="c"><input type="checkbox" id="c-36530127" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#36529774">parent</a><span>|</span><a href="#36530004">prev</a><span>|</span><a href="#36529874">next</a><span>|</span><label class="collapse" for="c-36530127">[-]</label><label class="expand" for="c-36530127">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not obvious that &quot;LLVM, but not incredibly frustrating&quot; is a thing which can exist. I don&#x27;t think it&#x27;s likely, but it&#x27;s possible that in a few decades the widespread view will be that the very concept of LLVM was a mistake, and a universal compiler backend is just a trap which makes it easy to bootstrap a language but inevitably causes massive problems down the road.<p>LLVM does have plenty of incidental problems which are clearly fixable and just need a lot of work, but even if you fixed all of them you&#x27;d still have people who use LLVM ranting about it.</div><br/><div id="36531797" class="c"><input type="checkbox" id="c-36531797" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36529774">root</a><span>|</span><a href="#36530127">parent</a><span>|</span><a href="#36529874">next</a><span>|</span><label class="collapse" for="c-36531797">[-]</label><label class="expand" for="c-36531797">[1 more]</label></div><br/><div class="children"><div class="content">MLIR is &quot;LLVM done better&quot;, in fact by the same person. It fixes many of unforced LLVM problems, for example LLVM&#x27;s inability to parallelize code generation.</div><br/></div></div></div></div></div></div><div id="36529874" class="c"><input type="checkbox" id="c-36529874" checked=""/><div class="controls bullet"><span class="by">fouc</span><span>|</span><a href="#36529774">prev</a><span>|</span><a href="#36529824">next</a><span>|</span><label class="collapse" for="c-36529874">[-]</label><label class="expand" for="c-36529874">[2 more]</label></div><br/><div class="children"><div class="content">Since they only mention dropping support for C++, Objective-C, and Objective-C++, I assume this means C is still supported?</div><br/><div id="36531545" class="c"><input type="checkbox" id="c-36531545" checked=""/><div class="controls bullet"><span class="by">xouncle</span><span>|</span><a href="#36529874">parent</a><span>|</span><a href="#36529824">next</a><span>|</span><label class="collapse" for="c-36531545">[-]</label><label class="expand" for="c-36531545">[1 more]</label></div><br/><div class="children"><div class="content">yeah, but not using Clang</div><br/></div></div></div></div><div id="36529824" class="c"><input type="checkbox" id="c-36529824" checked=""/><div class="controls bullet"><span class="by">vsskanth</span><span>|</span><a href="#36529874">prev</a><span>|</span><a href="#36531221">next</a><span>|</span><label class="collapse" for="c-36529824">[-]</label><label class="expand" for="c-36529824">[2 more]</label></div><br/><div class="children"><div class="content">Did they consider MLIR ? If not, Did they mention why?</div><br/><div id="36530135" class="c"><input type="checkbox" id="c-36530135" checked=""/><div class="controls bullet"><span class="by">trogdc</span><span>|</span><a href="#36529824">parent</a><span>|</span><a href="#36531221">next</a><span>|</span><label class="collapse" for="c-36530135">[-]</label><label class="expand" for="c-36530135">[1 more]</label></div><br/><div class="children"><div class="content">Not sure how MLIR would solve anything, there&#x27;s no bridge from C++ to MLIR, or from MLIR to assembly, other than going through LLVM.</div><br/></div></div></div></div><div id="36531221" class="c"><input type="checkbox" id="c-36531221" checked=""/><div class="controls bullet"><span class="by">hota_mazi</span><span>|</span><a href="#36529824">prev</a><span>|</span><a href="#36529975">next</a><span>|</span><label class="collapse" for="c-36531221">[-]</label><label class="expand" for="c-36531221">[2 more]</label></div><br/><div class="children"><div class="content">Given the barrage of negative comments on the PR and here as well, it really feels like Andrew is the only person in favor of that change.<p>It&#x27;s his language, obviously, but I strongly suspect that if this PR goes through, it will completely kill any kind of momentum that Zig has today and will most likely doom the language to obscurity.<p>Which would be a real shame.</div><br/><div id="36532003" class="c"><input type="checkbox" id="c-36532003" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36531221">parent</a><span>|</span><a href="#36529975">next</a><span>|</span><label class="collapse" for="c-36532003">[-]</label><label class="expand" for="c-36532003">[1 more]</label></div><br/><div class="children"><div class="content">Unless they sort out the issues related to use-after-free, the value preposition is hardly any better than using C and C++, with the memory corruption tooling there is around from the last 30 years.</div><br/></div></div></div></div></div></div></div></div></div></body></html>