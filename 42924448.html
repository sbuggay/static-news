<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738659674228" as="style"/><link rel="stylesheet" href="styles.css?v=1738659674228"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.reverberate.org/2025/02/03/no-panic-rust.html">No-Panic Rust: A Nice Technique for Systems Programming</a> <span class="domain">(<a href="https://blog.reverberate.org">blog.reverberate.org</a>)</span></div><div class="subtext"><span>chmaynard</span> | <span>80 comments</span></div><br/><div><div id="42925220" class="c"><input type="checkbox" id="c-42925220" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42925122">next</a><span>|</span><label class="collapse" for="c-42925220">[-]</label><label class="expand" for="c-42925220">[9 more]</label></div><br/><div class="children"><div class="content">The approach at the end of declaring invariants to the compiler so the compiler can eliminate panics seems accidentally genius. You can now add the same invariants as panicking asserts at the end of each function, and the compiler will prove to you that your functions are upholding the invariants. And of course you can add more panicking asserts to show other claims to be true, all tested at compile time. You&#x27;ve basically built a little proof system.<p>Sure, Rust is hardly the first language to include something like that and adoption of such systems tends to be ... spotty. But if it was reliable enough and had a better interface (that preferably allowed the rest of your program to sill have panics) this might be very useful for writing correct software.</div><br/><div id="42927810" class="c"><input type="checkbox" id="c-42927810" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#42925220">parent</a><span>|</span><a href="#42925731">next</a><span>|</span><label class="collapse" for="c-42927810">[-]</label><label class="expand" for="c-42927810">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>and the compiler will prove to you that your functions are upholding the invariants</i><p>From the article and only vague background Rust knowledge, I&#x27;m under the impression that the opposite is true: the compiler <i>does not</i> prove that.  Hence why it&#x27;s &quot;assert_<i>unchecked</i>&quot; - you are informing the compiler that you know more than it does.<p>You do get panics during debug, which is great for checking your assumptions, but that relies on you having adequate tests.</div><br/></div></div><div id="42925731" class="c"><input type="checkbox" id="c-42925731" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42925220">parent</a><span>|</span><a href="#42927810">prev</a><span>|</span><a href="#42925627">next</a><span>|</span><label class="collapse" for="c-42925731">[-]</label><label class="expand" for="c-42925731">[3 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t quite the same, but it reminds me of something a bit less clever (and a lot less powerful) I came up with  a little while back when writing some code to handle a binary format that used a lot of 32-bit integers that I needed to use for math on indexes in vectors. I was fairly confident that the code would never need to run on 16-bit platforms, but converting from a 32-bit integer to a usize in Rust technically is considered fallible due to the fact that you can&#x27;t necessarily assume that a usize is more 16 bits, and frustrating `usize` only implements `TryFrom&lt;u32&gt;` rather than conditionally implementing `From&lt;u32&gt;` on 32-bit and 64-bit platforms. I wanted to avoid having to do any casting that could silently get messed up if I happened to switch any of the integer types I used later, but I also was irrationally upset at the idea of having to check at runtime for something that should be obvious at compile time. The solution I came up with was putting a static assertion that the target pointer width was either 32 or 64 bits inside the error-handling path, followed by marking the code path as `unreachable!()` that would never get executed (because either the error handling path wouldn&#x27;t be taken, or the static assertion would stop the code from having been compiled in the first place. Even though this wasn&#x27;t meaningfully different from just conditionally compiling to make sure the platform was suitable and then putting `unreachable!()` unconditionally in the error handling path, having the compile-time insertion locally in the spot where the error was being handled felt like I magically turned the runtime error into a compile-time one; it was quite literally possible to write it as a function that could be dropped into any codebase without having to make any other changes to ensure it was used safely.</div><br/><div id="42926154" class="c"><input type="checkbox" id="c-42926154" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#42925220">root</a><span>|</span><a href="#42925731">parent</a><span>|</span><a href="#42925627">next</a><span>|</span><label class="collapse" for="c-42926154">[-]</label><label class="expand" for="c-42926154">[2 more]</label></div><br/><div class="children"><div class="content">What about just doing something like<p><pre><code>  #[cfg(any(target_pointer_width = &quot;32&quot;, target_pointer_width = &quot;64&quot;))]
  #[inline(always)]
  const fn usize_to_u32(x: usize) -&gt; u32 {
      x as u32
  }
</code></pre>
and this way you can just call this function and you&#x27;ll get a compile-time error (no such function) if you&#x27;re on a 16-bit platform.</div><br/><div id="42926784" class="c"><input type="checkbox" id="c-42926784" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42925220">root</a><span>|</span><a href="#42926154">parent</a><span>|</span><a href="#42925627">next</a><span>|</span><label class="collapse" for="c-42926784">[-]</label><label class="expand" for="c-42926784">[1 more]</label></div><br/><div class="children"><div class="content">Even though I can visually verify that it&#x27;s safe in this context, I really don&#x27;t like casting integers as a rule when there&#x27;s a reasonable alternative. The solution I came up with is pretty much equally readable in my opinion but has the distinction of not having code that might in other contexts look like it could silently have issues (compared to an `unreachable!()` macro which might also look sketchy but certainly wouldn&#x27;t be quiet if it accidentally was used in the wrong spot). I also prefer having a compiler error explaining the invariant that&#x27;s expected rather than a missing function (which could just as easily be due to a typo or something). You could put a `compile_error!()` invocation to conditionally compile when the pointer width isn&#x27;t at least 32, but I&#x27;d argue that tilts the balance even more in favor of the solution I came up with; having a single item instead of two defined is more readable in my opinion.<p>This wasn&#x27;t a concern for me but I could also imagine some sort of linting being used to ensure that potentially lossy casts aren&#x27;t done, and while it presumably could be manually suppressed, that also would just add to the noisiness.</div><br/></div></div></div></div></div></div><div id="42925627" class="c"><input type="checkbox" id="c-42925627" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#42925220">parent</a><span>|</span><a href="#42925731">prev</a><span>|</span><a href="#42925549">next</a><span>|</span><label class="collapse" for="c-42925627">[-]</label><label class="expand" for="c-42925627">[3 more]</label></div><br/><div class="children"><div class="content">While I would love this to be true, I&#x27;m not sure that this design can statically prove anything.  For an assert to fail, you would have to actually execute a code sequence that causes the invariant to be violated.  I don&#x27;t see how the compiler could prove at compile time that the invariants are upheld.</div><br/><div id="42925732" class="c"><input type="checkbox" id="c-42925732" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42925220">root</a><span>|</span><a href="#42925627">parent</a><span>|</span><a href="#42925549">next</a><span>|</span><label class="collapse" for="c-42925732">[-]</label><label class="expand" for="c-42925732">[2 more]</label></div><br/><div class="children"><div class="content">An assert is just a fancy `if condition { panic(message) }`. If the optimizer can show that condition is always false, the panic is declared as dead code and eliminated. The post uses that to get the compiler to remove all panics to reduce the binary size. But you can also just check if panic code was generated (or associated code linked in), and if it was then the optimizer wasn&#x27;t able to show that your assert can&#x27;t happen.<p>Of course this doesn&#x27;t prove that the assert will happen. You would have to execute the code for that. But you can treat the fact that the optimizer couldn&#x27;t eliminate your assert as failure, showing that either your code violates the assert, your preconditions in combination with the code aren&#x27;t enough to show that the assert isn&#x27;t violated, or the whole thing was too complicated for the optimizer to figure out and you have to restructure some code</div><br/><div id="42925802" class="c"><input type="checkbox" id="c-42925802" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#42925220">root</a><span>|</span><a href="#42925732">parent</a><span>|</span><a href="#42925549">next</a><span>|</span><label class="collapse" for="c-42925802">[-]</label><label class="expand" for="c-42925802">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I see what you are saying.  Yes, if the optimizer is able to eliminate the postcondition check, I agree that it would constitute a proof that the code upholds the invariant.<p>The big question is how much real-world code the optimizer would be capable of &quot;solving&quot; in this way.<p>I wonder if most algorithms would eventually be solvable if you keep breaking them down into smaller pieces.  Or if some would have some step of irreducible complexity that the optimizer cannot figure out, now matter how much you break it down.</div><br/></div></div></div></div></div></div><div id="42925549" class="c"><input type="checkbox" id="c-42925549" checked=""/><div class="controls bullet"><span class="by">jwatte</span><span>|</span><a href="#42925220">parent</a><span>|</span><a href="#42925627">prev</a><span>|</span><a href="#42925122">next</a><span>|</span><label class="collapse" for="c-42925549">[-]</label><label class="expand" for="c-42925549">[1 more]</label></div><br/><div class="children"><div class="content">For systems where correctness is <i>actually</i> important, not just a nice-to-have (in most systems, it&#x27;s nice-to-have,) we have had an increasing number of options over the years.<p>From tools like &quot;spin&quot; and &quot;tla+&quot; to proof assistants like Coq to full languages like Idris and Agda.<p>Some of the stronger-typed languages already give us some of those benefits (Haskell, OCaml) and with restricted effects (like Haskell) we can even make the compiler do much of this work without it leaking into other parts of the program if we don&#x27;t want it to.</div><br/></div></div></div></div><div id="42925122" class="c"><input type="checkbox" id="c-42925122" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42925220">prev</a><span>|</span><a href="#42925117">next</a><span>|</span><label class="collapse" for="c-42925122">[-]</label><label class="expand" for="c-42925122">[23 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had an unpleasant amount of crashes with Rust software because people are way too quick to grab `panic!` as an out.<p>This was most shocking to me in some of the Rust code Mozilla had integrated into Firefox (the CSS styling code). There was some font cache shenanigans that was causing their font loading to work only semi-consistently, and that would outright crash this subsystem, and tofu-ify CJK text entirely as a result.<p>And the underlying panic was totally recoverable in theory if you looked at the call stack! Just people had decided to not Result-ify a bunch of falliable code.</div><br/><div id="42925382" class="c"><input type="checkbox" id="c-42925382" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42925122">parent</a><span>|</span><a href="#42925254">next</a><span>|</span><label class="collapse" for="c-42925382">[-]</label><label class="expand" for="c-42925382">[8 more]</label></div><br/><div class="children"><div class="content">Sometimes the program is in an invalid state. You don&#x27;t want to keep running the program. Better to fail spectacularly and clearly then to fail silently and try to hobble along.</div><br/><div id="42928166" class="c"><input type="checkbox" id="c-42928166" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925382">parent</a><span>|</span><a href="#42925586">next</a><span>|</span><label class="collapse" for="c-42928166">[-]</label><label class="expand" for="c-42928166">[2 more]</label></div><br/><div class="children"><div class="content">I understand this belief abstractly. In the cases I was hitting, there would have been easy recovery mechanisms possible (that would have been wanted because there are many ways for the system to hit the error!), but due to the lowest level &quot;key lookup&quot; step just blowing up rather than Result (or Option)-ing their lookup, not only would the patch have been messy, but it would have required me to make many decisions in &quot;unrelated&quot; code in the meanwhile.<p>I understand your point in general, I just find that if you&#x27;re writing a program that is running on unconstrained environments, not panic&#x27;ing (or at least not doing it so bluntly at a low level) can at the very least help with debugging.<p>At least have the courtesy to put the panic at a higher level to provide context beyond &quot;key not found!&quot;!</div><br/><div id="42928753" class="c"><input type="checkbox" id="c-42928753" checked=""/><div class="controls bullet"><span class="by">ratorx</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42928166">parent</a><span>|</span><a href="#42925586">next</a><span>|</span><label class="collapse" for="c-42928753">[-]</label><label class="expand" for="c-42928753">[1 more]</label></div><br/><div class="children"><div class="content">Without knowing the exact situation, if you follow the guidelines in this article, this is a library bug (documentation or actual code).<p>Either the library should have enforced the invariant of the key existing (and returned an equivalent error, or handled it internally), or documented the preconditions at a higher level function that you could see.</div><br/></div></div></div></div><div id="42925586" class="c"><input type="checkbox" id="c-42925586" checked=""/><div class="controls bullet"><span class="by">jwatte</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925382">parent</a><span>|</span><a href="#42928166">prev</a><span>|</span><a href="#42925254">next</a><span>|</span><label class="collapse" for="c-42925586">[-]</label><label class="expand" for="c-42925586">[5 more]</label></div><br/><div class="children"><div class="content">The thing with functional programming (specifically, immutable data,) is that as long as the invalid state is immutable, you can just back up to some previous caller, and they can figure out whether to deal with it or whether to reject up the its previous caller.<p>This is why Result (or Maybe, or runExceptT, and so on in other languages) is a perfectly safe way of handling unexpected or invalid data. As long as you enforce your invariants in pure code (code without side effects) then failure is safe.<p>This is also why effects should ideally be restricted and traceable by the compiler, which, unfortunately, Rust, ML, and that chain of the evolution tree didn&#x27;t quite stretch to encompass.</div><br/><div id="42925971" class="c"><input type="checkbox" id="c-42925971" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925586">parent</a><span>|</span><a href="#42927913">next</a><span>|</span><label class="collapse" for="c-42925971">[-]</label><label class="expand" for="c-42925971">[2 more]</label></div><br/><div class="children"><div class="content">Say a function has some return type Result&lt;T, E&gt;. If our only error handling mechanism is Err(e) then were restricted to E representing the set of errors due to invalid arguments and state, <i>and</i> the set of errors due to the program itself being implemented incorrectly.<p>In a good software architecture (imo) panics and other hard failure mechanisms are there for splitting E into E1 and E2, where E1 is the set of errors that can happen due to the caller screwing up and E2 being the set of errors that the caller screwed up. The caller shouldn&#x27;t have to reason about the callee possibly being incorrect!<p>Functional programming doesn&#x27;t really come into the discussion here - oftentimes this crops up in imperative or object oriented code where function signatures are lossy because code relies on side effects or state that the type system can&#x27;t&#x2F;won&#x27;t capture (for example, a database or file persisted somewhere). Thats where you&#x27;ll drop an assert or panic - not as a routine part of error handling.</div><br/><div id="42929229" class="c"><input type="checkbox" id="c-42929229" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925971">parent</a><span>|</span><a href="#42927913">next</a><span>|</span><label class="collapse" for="c-42929229">[-]</label><label class="expand" for="c-42929229">[1 more]</label></div><br/><div class="children"><div class="content">You shouldn&#x27;t pass invalid values to a function. If a function can return some sensible value for some input, then the input is not invalid - even if the return type is an error by name.<p>Ideally, you can constrain the set of inputs to only valid ones by leveraging types. But if that&#x27;s not possible and a truly invalid input is passed, then you should panic. At least that&#x27;s the mental model that Rust is going with.<p>You do lose out on the ability to &quot;catch&quot; programming errors in subcomponents of your program. For example, it&#x27;s extremely useful to catch exceptions related to programming errors for called code in response to a web request, and return a 500 in those cases. One could imagine a &quot;try&quot; &quot;catch&quot; for panics.<p>The thing is, it takes a lot of discipline by authors to not riddle their code with panics&#x2F;exceptions when the language provides a try&#x2F;catch mechanism (see C# and Java), even when a sensible error as value could be returned. So Rust opts to not introduce the footgun and extra complexity, at the expense of ungraceful handling of programming errors.</div><br/></div></div></div></div><div id="42927913" class="c"><input type="checkbox" id="c-42927913" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925586">parent</a><span>|</span><a href="#42925971">prev</a><span>|</span><a href="#42925254">next</a><span>|</span><label class="collapse" for="c-42927913">[-]</label><label class="expand" for="c-42927913">[2 more]</label></div><br/><div class="children"><div class="content">The program can detect invalid state, but your intention was to never get to that state in the first place. The fact that the program arrived there is a Logic error in your program. No amount of runtime shenanigans can repair it because the error exists without your knowledge of where it came from. You just know it&#x27;s invalid state and you made a mistake in your code.<p>The best way to handle this is to crash the program. If you need constant uptime, then restart the program. If you absolutely need to keep things running then, yeah try to recover then. The last option isn&#x27;t as bad for something like an http server where one request caused it to error and you just handle that error and keep the other threads running.<p>But for something like a 3D video game. If you arrive at erroneous state, man. Don&#x27;t try to keep that thing going. Kill it now.</div><br/><div id="42929644" class="c"><input type="checkbox" id="c-42929644" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42927913">parent</a><span>|</span><a href="#42925254">next</a><span>|</span><label class="collapse" for="c-42929644">[-]</label><label class="expand" for="c-42929644">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The fact that the program arrived there is a Logic error in your program.<p>No, your program correctly determined that user input was invalid.<p>Or your parser backtracked from parsing a Bool and decided to try to parse an Int instead.</div><br/></div></div></div></div></div></div></div></div><div id="42925254" class="c"><input type="checkbox" id="c-42925254" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42925122">parent</a><span>|</span><a href="#42925382">prev</a><span>|</span><a href="#42925836">next</a><span>|</span><label class="collapse" for="c-42925254">[-]</label><label class="expand" for="c-42925254">[11 more]</label></div><br/><div class="children"><div class="content">At least sources of panic! are easily greppable.  Cutting corners on error handling is usually pretty obvious</div><br/><div id="42925737" class="c"><input type="checkbox" id="c-42925737" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925254">parent</a><span>|</span><a href="#42928181">next</a><span>|</span><label class="collapse" for="c-42925737">[-]</label><label class="expand" for="c-42925737">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think grepping for panics is practical, unless you are trying to depend on exclusively no-panic libraries.<p>Even if you are no_std, core has tons of APIs like unwrap(), index slicing, etc. that can panic if you violate the preconditions.  It&#x27;s not practical to grep for all of them.</div><br/><div id="42925932" class="c"><input type="checkbox" id="c-42925932" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925737">parent</a><span>|</span><a href="#42928181">next</a><span>|</span><label class="collapse" for="c-42925932">[-]</label><label class="expand" for="c-42925932">[3 more]</label></div><br/><div class="children"><div class="content">There is panic-analyzer [1] that searches for code that needlessly panics. You can also use the no-panic macro [2] to turn possible panics in a specific function (including main) into a compile error<p>1: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;panic-analyzer" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;panic-analyzer</a><p>2: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;no-panic" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;no-panic</a></div><br/><div id="42926108" class="c"><input type="checkbox" id="c-42926108" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925932">parent</a><span>|</span><a href="#42928181">next</a><span>|</span><label class="collapse" for="c-42926108">[-]</label><label class="expand" for="c-42926108">[2 more]</label></div><br/><div class="children"><div class="content">Panic-analyzer looks like it is based on heuristics, searching for known-panicing APIs.  I tried it on a workspace that uses io::stdout() and it did not flag this as potentially panicing.<p>No-panic looks nifty: it appears to be reliable, which is great.  I wish there was an easy way to automatically apply this annotation to every single function in a given file or crate.</div><br/><div id="42926969" class="c"><input type="checkbox" id="c-42926969" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42926108">parent</a><span>|</span><a href="#42928181">next</a><span>|</span><label class="collapse" for="c-42926969">[-]</label><label class="expand" for="c-42926969">[1 more]</label></div><br/><div class="children"><div class="content">I think the article is wrong in that std::io::stdout would be panicking, or that &quot;the panic is reachable somehow&quot;. It&#x27;s just the optimizer doesn&#x27;t see it doesn&#x27;t panic.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;src&#x2F;std&#x2F;io&#x2F;stdio.rs.html#674-679" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;src&#x2F;std&#x2F;io&#x2F;stdio.rs.html#674-...</a><p>The implementation calls indeed a panicking API, OnceLock::get_or_init:<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;std&#x2F;sync&#x2F;struct.OnceLock.html#method.get_or_init" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;std&#x2F;sync&#x2F;struct.OnceLock.html...</a><p>But it only panicks if it is being used in a wrong way, which it isn&#x27;t. The usage is contained within the implementation of std::io::stdout, so it&#x27;s an implementation detail.<p>It&#x27;s a shame that there are no better ways to eliminate panics in case they are impossible to trigger. The article shows some tricks, but I think the language is missing still some expressability around this, and the stdlib should also thrive harder to actually get rid of hard-to-optimize links to panic runtime in case of APIs that don&#x27;t actually panic.</div><br/></div></div></div></div></div></div></div></div><div id="42928181" class="c"><input type="checkbox" id="c-42928181" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925254">parent</a><span>|</span><a href="#42925737">prev</a><span>|</span><a href="#42925334">next</a><span>|</span><label class="collapse" for="c-42928181">[-]</label><label class="expand" for="c-42928181">[1 more]</label></div><br/><div class="children"><div class="content">It is interesting to consider how `panic!` serves as some documentation of explicitly giving up. Easy to see in a pull request. And having the string packed alongside it is nice.<p>Still miffed, but we&#x27;ll get there.</div><br/></div></div><div id="42925334" class="c"><input type="checkbox" id="c-42925334" checked=""/><div class="controls bullet"><span class="by">pluto_modadic</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925254">parent</a><span>|</span><a href="#42928181">prev</a><span>|</span><a href="#42925836">next</a><span>|</span><label class="collapse" for="c-42925334">[-]</label><label class="expand" for="c-42925334">[5 more]</label></div><br/><div class="children"><div class="content">I mean... rust modules aren&#x27;t typically in your CWD, no? they&#x27;re not in some node_modules that you can grep, but in a cargo folder with &#x2F;all of the libraries you ever used&#x2F;, not just the ones you have for this one project.</div><br/><div id="42925350" class="c"><input type="checkbox" id="c-42925350" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925334">parent</a><span>|</span><a href="#42925787">next</a><span>|</span><label class="collapse" for="c-42925350">[-]</label><label class="expand" for="c-42925350">[2 more]</label></div><br/><div class="children"><div class="content">Putting them all in the project root takes just a single `cargo vendor` command.<p>But I would assume that for mozilla their entire CSS subsystem is pulled in as a git (hg?) submodule or something anyways.</div><br/><div id="42925413" class="c"><input type="checkbox" id="c-42925413" checked=""/><div class="controls bullet"><span class="by">est31</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925350">parent</a><span>|</span><a href="#42925787">next</a><span>|</span><label class="collapse" for="c-42925413">[-]</label><label class="expand" for="c-42925413">[1 more]</label></div><br/><div class="children"><div class="content">not sure how the CSS subsystem is included (I remember it is shared with Servo?), but in general all of the Rust dependencies in mozilla-central is vendored, so nothing is in your ~&#x2F;.cargo directory.</div><br/></div></div></div></div><div id="42925787" class="c"><input type="checkbox" id="c-42925787" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925334">parent</a><span>|</span><a href="#42925350">prev</a><span>|</span><a href="#42925365">next</a><span>|</span><label class="collapse" for="c-42925787">[-]</label><label class="expand" for="c-42925787">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, eg vscode can jump to definition even when your code is in a different crate that&#x27;s not in your repository.</div><br/></div></div><div id="42925365" class="c"><input type="checkbox" id="c-42925365" checked=""/><div class="controls bullet"><span class="by">est31</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925334">parent</a><span>|</span><a href="#42925787">prev</a><span>|</span><a href="#42925836">next</a><span>|</span><label class="collapse" for="c-42925365">[-]</label><label class="expand" for="c-42925365">[1 more]</label></div><br/><div class="children"><div class="content">If you run cargo vendor, they end up in a neat directory.</div><br/></div></div></div></div></div></div><div id="42925836" class="c"><input type="checkbox" id="c-42925836" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#42925122">parent</a><span>|</span><a href="#42925254">prev</a><span>|</span><a href="#42925469">next</a><span>|</span><label class="collapse" for="c-42925836">[-]</label><label class="expand" for="c-42925836">[2 more]</label></div><br/><div class="children"><div class="content">While sure, more things could be baked as results, most of the time when you see a panic that&#x27;s not the case. It&#x27;s a violation of the callee&#x27;s invariants that the caller fucked up.<p>Essentially an error means that the caller failed in a way that&#x27;s expected. A panic means the caller broke some contract that wasn&#x27;t expressed in the arguments.<p>A good example of this is array indexing. If you&#x27;re using it you&#x27;re saying that the caller (whoever is indexing into the array) has already agreed not to access out of bounds. But we still have to double check if that&#x27;s the case.<p>And if you were to say that hey, that implies that the checks and branches should just be elided - you can! But not in safe rust, because safe code can&#x27;t invoke undefined behavior.</div><br/><div id="42928197" class="c"><input type="checkbox" id="c-42928197" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42925122">root</a><span>|</span><a href="#42925836">parent</a><span>|</span><a href="#42925469">next</a><span>|</span><label class="collapse" for="c-42928197">[-]</label><label class="expand" for="c-42928197">[1 more]</label></div><br/><div class="children"><div class="content">I understand the value of panic when your invariants really are no longer holding. What I have seen is many cases of &quot;oh a micro-invariant I kind of half believe to be true isn&#x27;t being held, and so I will panic&quot;.<p>Obviously context-free this is very hand wave-y, but would you want Firefox to crash every time a website prematurely closes its connection to your browser for whatever reason? No, right? You would want Firefox to fail gracefully. That is what I wanted.</div><br/></div></div></div></div></div></div><div id="42925117" class="c"><input type="checkbox" id="c-42925117" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#42925122">prev</a><span>|</span><a href="#42924996">next</a><span>|</span><label class="collapse" for="c-42925117">[-]</label><label class="expand" for="c-42925117">[5 more]</label></div><br/><div class="children"><div class="content">This seems to obviate a lot of Rust&#x27;s advantages (like a good std library). I wonder what it would take to write a nopanic-std library?<p>Panics really seem bad for composability. And relying on the optimzer here seems like a fragile approach.<p>(And how is there no -nopanic compiler flag?)</div><br/><div id="42925757" class="c"><input type="checkbox" id="c-42925757" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#42925117">parent</a><span>|</span><a href="#42925297">next</a><span>|</span><label class="collapse" for="c-42925757">[-]</label><label class="expand" for="c-42925757">[2 more]</label></div><br/><div class="children"><div class="content">Rust doesn&#x27;t want to add any proof-system that isn&#x27;t 100% repeatable, reliable, and forwards compatible to the language. The borrow checker is ok, because it meets those requirements. The optimizer based &quot;no panic&quot; proof system is not. It <i>will</i> break between releases as LLVM optimizations change, and there&#x27;s no way to avoid it.<p>Trying to enforce no-panics without a proof system helping out is just not a very practical approach to programming. Consider code like<p><pre><code>    some_queue.push_back(&quot;new_value&quot;);
    process(some_queue.pop_front().unwrap());
</code></pre>
This code is obviously correct. It never panics. There&#x27;s no better way to write it. The optimizer will instantly see that and remove the panicing branch. The language itself doesn&#x27;t want to be in the business of trying to see things like that.<p>Or consider code like<p><pre><code>    let mut count: usize = 0;
    for item in some_vec {
        &#x2F;&#x2F; Do some stuff with item
        if some_cond() {
            count += 1;
        }
    }
</code></pre>
This code never panics. Integer arithmetic contains a hidden panic path on overflow, but that can&#x27;t occur here because the length of a vector is always less than usize::MAX.<p>Or so on.<p>Basically every practical language has some form of &quot;this should never happen&quot; root. Rust&#x27;s is panics. C&#x27;s is undefined behavior. Java&#x27;s is exceptions.<p>Finally consider that this same mechanism is used for things like stack overflows, which can&#x27;t be statically guaranteed to not occur short of rejecting recursion <i>and</i> knowledge of the runtime environment that rustc does not have.<p>---<p>Proof systems on top of rust like creusot or kani do tend to try to prove the absence of panics, because they don&#x27;t have the same compunctions about not approving code today that they aren&#x27;t absolutely sure they will approve tomorrow as well.</div><br/><div id="42928370" class="c"><input type="checkbox" id="c-42928370" checked=""/><div class="controls bullet"><span class="by">RainyDayTmrw</span><span>|</span><a href="#42925117">root</a><span>|</span><a href="#42925757">parent</a><span>|</span><a href="#42925297">next</a><span>|</span><label class="collapse" for="c-42928370">[-]</label><label class="expand" for="c-42928370">[1 more]</label></div><br/><div class="children"><div class="content">To add to this, I believe that there will always be some amount of &quot;should never happen but I can&#x27;t prove it&quot; due to Rice&#x27;s Theorem[1].<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rice%27s_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rice%27s_theorem</a></div><br/></div></div></div></div><div id="42925297" class="c"><input type="checkbox" id="c-42925297" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42925117">parent</a><span>|</span><a href="#42925757">prev</a><span>|</span><a href="#42925866">next</a><span>|</span><label class="collapse" for="c-42925297">[-]</label><label class="expand" for="c-42925297">[1 more]</label></div><br/><div class="children"><div class="content">The standard library is slowly adding non-panicking options. The article shows some of them (like vec.push_within_capacity()) and ignores some others (vec.get_unchecked()). There is still a lot of work to do, but it is an area where a lot of work gets done. The issue is just that a) Rust is still a fairly young language, barely a decade old counting from 1.0 release, and b) Rust is really slow and methodical in adding anything to stdlib because of how hard&#x2F;impossible it is to reverse bad decisions in the stdlib.<p>The same article written a couple years in the future would look very different</div><br/></div></div><div id="42925866" class="c"><input type="checkbox" id="c-42925866" checked=""/><div class="controls bullet"><span class="by">hathawsh</span><span>|</span><a href="#42925117">parent</a><span>|</span><a href="#42925297">prev</a><span>|</span><a href="#42924996">next</a><span>|</span><label class="collapse" for="c-42925866">[-]</label><label class="expand" for="c-42925866">[1 more]</label></div><br/><div class="children"><div class="content">What I would like to see is a reliable distinction of different types of panics. In the environments where software I write is typically run, panics due to heap allocation failure are generally acceptable and rarely an indication of fragility. (By the time a heap allocation failure occurs, the computer is probably already thrashing and needs to be rebooted.) On the other hand, other kinds of panics are a bad sign. For example, I would frown on any library that panics just because it can&#x27;t reach the Internet.<p>In other environments, like embedded or safety-critical devices, I would need a guarantee that even heap allocation failure can not cause a panic.</div><br/></div></div></div></div><div id="42924996" class="c"><input type="checkbox" id="c-42924996" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#42925117">prev</a><span>|</span><a href="#42929104">next</a><span>|</span><label class="collapse" for="c-42924996">[-]</label><label class="expand" for="c-42924996">[14 more]</label></div><br/><div class="children"><div class="content">This website makes by browser freeze... No idea why. Not able to read the article.</div><br/><div id="42929510" class="c"><input type="checkbox" id="c-42929510" checked=""/><div class="controls bullet"><span class="by">arijun</span><span>|</span><a href="#42924996">parent</a><span>|</span><a href="#42925084">next</a><span>|</span><label class="collapse" for="c-42929510">[-]</label><label class="expand" for="c-42929510">[1 more]</label></div><br/><div class="children"><div class="content">This happened to me too (Safari on iOS).<p>Here’s a archived link:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20250204050500&#x2F;https:&#x2F;&#x2F;blog.reverberate.org&#x2F;2025&#x2F;02&#x2F;03&#x2F;no-panic-rust.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20250204050500&#x2F;https:&#x2F;&#x2F;blog.reve...</a></div><br/></div></div><div id="42925084" class="c"><input type="checkbox" id="c-42925084" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#42924996">parent</a><span>|</span><a href="#42929510">prev</a><span>|</span><a href="#42925120">next</a><span>|</span><label class="collapse" for="c-42925084">[-]</label><label class="expand" for="c-42925084">[8 more]</label></div><br/><div class="children"><div class="content">Author here -- that is surprising.  What browser&#x2F;OS are you on?  I haven&#x27;t had anyone else report this problem before.</div><br/><div id="42925242" class="c"><input type="checkbox" id="c-42925242" checked=""/><div class="controls bullet"><span class="by">TallonRain</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925084">parent</a><span>|</span><a href="#42925548">next</a><span>|</span><label class="collapse" for="c-42925242">[-]</label><label class="expand" for="c-42925242">[3 more]</label></div><br/><div class="children"><div class="content">I’m seeing the same problem, the page crashes on Safari on iOS, saying a problem repeatedly occurred. Haven’t seen a webpage do that in quite a while.</div><br/><div id="42925306" class="c"><input type="checkbox" id="c-42925306" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925242">parent</a><span>|</span><a href="#42925548">next</a><span>|</span><label class="collapse" for="c-42925306">[-]</label><label class="expand" for="c-42925306">[2 more]</label></div><br/><div class="children"><div class="content">Yep, same experience, same platform. I guess straight to reader mode, it is.<p>EDIT - shockingly, reader mode also fails completely after the page reloads itself</div><br/><div id="42925772" class="c"><input type="checkbox" id="c-42925772" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925306">parent</a><span>|</span><a href="#42925548">next</a><span>|</span><label class="collapse" for="c-42925772">[-]</label><label class="expand" for="c-42925772">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m seeing the same problem--the page crashes on mobile (Brave). On desktop it loads, but all of the code cells have a crashed page symbol in them.</div><br/></div></div></div></div></div></div><div id="42925548" class="c"><input type="checkbox" id="c-42925548" checked=""/><div class="controls bullet"><span class="by">IX-103</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925084">parent</a><span>|</span><a href="#42925242">prev</a><span>|</span><a href="#42925339">next</a><span>|</span><label class="collapse" for="c-42925548">[-]</label><label class="expand" for="c-42925548">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also seeing this on Android Chrome. When I opened the page on my Linux desktop, I also saw the crashes (though they only affected the godbolt iframes).<p>Note that on Android process separation is not usually as good, so a crashing iframe can bring down the whole page.</div><br/></div></div><div id="42925339" class="c"><input type="checkbox" id="c-42925339" checked=""/><div class="controls bullet"><span class="by">wbobeirne</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925084">parent</a><span>|</span><a href="#42925548">prev</a><span>|</span><a href="#42926507">next</a><span>|</span><label class="collapse" for="c-42925339">[-]</label><label class="expand" for="c-42925339">[2 more]</label></div><br/><div class="children"><div class="content">Same issue on Android using Brave.</div><br/><div id="42925637" class="c"><input type="checkbox" id="c-42925637" checked=""/><div class="controls bullet"><span class="by">lacraig2</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925339">parent</a><span>|</span><a href="#42926507">next</a><span>|</span><label class="collapse" for="c-42925637">[-]</label><label class="expand" for="c-42925637">[1 more]</label></div><br/><div class="children"><div class="content">same on chrome android</div><br/></div></div></div></div><div id="42926507" class="c"><input type="checkbox" id="c-42926507" checked=""/><div class="controls bullet"><span class="by">anymouse123456</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925084">parent</a><span>|</span><a href="#42925339">prev</a><span>|</span><a href="#42925120">next</a><span>|</span><label class="collapse" for="c-42926507">[-]</label><label class="expand" for="c-42926507">[1 more]</label></div><br/><div class="children"><div class="content">same for me. Chrome on Pixel 8</div><br/></div></div></div></div><div id="42925120" class="c"><input type="checkbox" id="c-42925120" checked=""/><div class="controls bullet"><span class="by">DemetriousJones</span><span>|</span><a href="#42924996">parent</a><span>|</span><a href="#42925084">prev</a><span>|</span><a href="#42929104">next</a><span>|</span><label class="collapse" for="c-42925120">[-]</label><label class="expand" for="c-42925120">[4 more]</label></div><br/><div class="children"><div class="content">Same, the web view in my Android client crashed after a couple seconds.</div><br/><div id="42925170" class="c"><input type="checkbox" id="c-42925170" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925120">parent</a><span>|</span><a href="#42929104">next</a><span>|</span><label class="collapse" for="c-42925170">[-]</label><label class="expand" for="c-42925170">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if it&#x27;s all the Godbolt iframes.  Do you have the same problem on other pages, like <a href="https:&#x2F;&#x2F;blog.reverberate.org&#x2F;2025&#x2F;01&#x2F;27&#x2F;an-ode-to-header-files.html" rel="nofollow">https:&#x2F;&#x2F;blog.reverberate.org&#x2F;2025&#x2F;01&#x2F;27&#x2F;an-ode-to-header-fil...</a> ?</div><br/><div id="42926342" class="c"><input type="checkbox" id="c-42926342" checked=""/><div class="controls bullet"><span class="by">IX-103</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925170">parent</a><span>|</span><a href="#42925205">next</a><span>|</span><label class="collapse" for="c-42926342">[-]</label><label class="expand" for="c-42926342">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I think it&#x27;s all those iframes. I&#x27;m seeing something weird on my Linux desktop - all the godbolt iframes crash on reload <i>unless</i> I have another tab with godbolt open. I didn&#x27;t see anything obvious in Chrome&#x27;s log.<p>I can&#x27;t replicate the crash at all on my Linux cloud VM though. Usually the only difference there is that advertisers tend to not buy  ads for clients on cloud IPs.</div><br/></div></div><div id="42925205" class="c"><input type="checkbox" id="c-42925205" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#42924996">root</a><span>|</span><a href="#42925170">parent</a><span>|</span><a href="#42926342">prev</a><span>|</span><a href="#42929104">next</a><span>|</span><label class="collapse" for="c-42925205">[-]</label><label class="expand" for="c-42925205">[1 more]</label></div><br/><div class="children"><div class="content">Other pages on the site work fine for me yeah. But the OP blog post is crashing my Android browser, like the other commenters have mentioned.</div><br/></div></div></div></div></div></div></div></div><div id="42929104" class="c"><input type="checkbox" id="c-42929104" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42924996">prev</a><span>|</span><a href="#42928934">next</a><span>|</span><label class="collapse" for="c-42929104">[-]</label><label class="expand" for="c-42929104">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If we are trying to port a C library to Rust, we really do not want to introduce panics in the code, even for unusual error condition.<p>&quot;We&#x27;d much rather like to make library to corrupt the memory of the rest of the application and generally make the demons fly out of the users&#x27; noses, as it does when written in C&quot;?<p>I believe implementations of C stdio also can abort on program startup if somehow the pthreads&#x27; locking mechanism is broken (or if e.g. fcntl(2)&#x2F;open(2) keeps returning -1), Rust is not that unique in this regard.</div><br/></div></div><div id="42928934" class="c"><input type="checkbox" id="c-42928934" checked=""/><div class="controls bullet"><span class="by">nektro</span><span>|</span><a href="#42929104">prev</a><span>|</span><a href="#42925067">next</a><span>|</span><label class="collapse" for="c-42928934">[-]</label><label class="expand" for="c-42928934">[1 more]</label></div><br/><div class="children"><div class="content">OP sounds like they&#x27;d be very interested in Zig to tackle this particular problem. they&#x27;d get to a very similar place and not have to fight the language or the standard library to get there.</div><br/></div></div><div id="42925067" class="c"><input type="checkbox" id="c-42925067" checked=""/><div class="controls bullet"><span class="by">davisp</span><span>|</span><a href="#42928934">prev</a><span>|</span><a href="#42929544">next</a><span>|</span><label class="collapse" for="c-42925067">[-]</label><label class="expand" for="c-42925067">[5 more]</label></div><br/><div class="children"><div class="content">Does anyone know if there&#x27;s an obvious reason that adding a `no_panic` crate attribute wouldn&#x27;t be feasible? It certainly seems like an &quot;obvious&quot; thing to add so I&#x27;m hesitant to take the obvious nerd snipe bait.</div><br/><div id="42925531" class="c"><input type="checkbox" id="c-42925531" checked=""/><div class="controls bullet"><span class="by">hathawsh</span><span>|</span><a href="#42925067">parent</a><span>|</span><a href="#42925403">next</a><span>|</span><label class="collapse" for="c-42925531">[-]</label><label class="expand" for="c-42925531">[2 more]</label></div><br/><div class="children"><div class="content">The standard library has a significant amount of code that panics, so a `no_panic` crate attribute would currently only work for crates that don&#x27;t depend on the standard library. I imagine most interesting crates depend on the standard library.</div><br/><div id="42925690" class="c"><input type="checkbox" id="c-42925690" checked=""/><div class="controls bullet"><span class="by">davisp</span><span>|</span><a href="#42925067">root</a><span>|</span><a href="#42925531">parent</a><span>|</span><a href="#42925403">next</a><span>|</span><label class="collapse" for="c-42925690">[-]</label><label class="expand" for="c-42925690">[1 more]</label></div><br/><div class="children"><div class="content">What caught my eye in the article was the desire to have something that doesn&#x27;t panic with a release profile, while allowing for panics in dev profiles. Based on other comments I think the general &quot;allow use of std, but don&#x27;t panic&quot; seems like something that could be useful purely on the &quot;Wait, why doesn&#x27;t that exist?&quot; reactions.</div><br/></div></div></div></div><div id="42925403" class="c"><input type="checkbox" id="c-42925403" checked=""/><div class="controls bullet"><span class="by">7e</span><span>|</span><a href="#42925067">parent</a><span>|</span><a href="#42925531">prev</a><span>|</span><a href="#42929544">next</a><span>|</span><label class="collapse" for="c-42925403">[-]</label><label class="expand" for="c-42925403">[2 more]</label></div><br/><div class="children"><div class="content">You could do it, but I would prefer guarantees on a per-call chain basis using a sanitizer. It should be quite easy to write.</div><br/><div id="42925847" class="c"><input type="checkbox" id="c-42925847" checked=""/><div class="controls bullet"><span class="by">davisp</span><span>|</span><a href="#42925067">root</a><span>|</span><a href="#42925403">parent</a><span>|</span><a href="#42929544">next</a><span>|</span><label class="collapse" for="c-42925847">[-]</label><label class="expand" for="c-42925847">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no rustc expert, but from what little I know it seems like disabling panics for a crate would be an obvious first step. You make a great point though. Turning that into a compiler assertion of &quot;this function will never panic&quot; would also be useful.</div><br/></div></div></div></div></div></div><div id="42929544" class="c"><input type="checkbox" id="c-42929544" checked=""/><div class="controls bullet"><span class="by">vollbrecht</span><span>|</span><a href="#42925067">prev</a><span>|</span><a href="#42928800">next</a><span>|</span><label class="collapse" for="c-42929544">[-]</label><label class="expand" for="c-42929544">[1 more]</label></div><br/><div class="children"><div class="content">Most people are using a prebuild standard library. That comes with the problem that it comes with the features it was build for. Most of the bloat around panic for example can be eliminated by just compiling the std library yourself. This is done via the `-Zbuild-std` flag.<p>Using this flag one than can use `panic_abort`. This will eliminate the unwinding part but would still give a &quot;nice&quot; printout on a panic itself. This reduces, in most cases, the mention bloat by a lot. Though nice printouts also cost binary space. For eliminating that `panic_immidiate_abort` exists.<p>But yeah the above is only about bloat and not the core goal to eliminate potential path&#x27;s in your program, that would lead to a panic condition itself.<p>Also currently building the std library yourself needs a nightly compiler. There is afaik work on bringing this to a stable compiler but how exactly is still work in progress.</div><br/></div></div><div id="42928800" class="c"><input type="checkbox" id="c-42928800" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#42929544">prev</a><span>|</span><a href="#42925767">next</a><span>|</span><label class="collapse" for="c-42928800">[-]</label><label class="expand" for="c-42928800">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps verus would be helpful to the op: <a href="https:&#x2F;&#x2F;github.com&#x2F;verus-lang&#x2F;verus">https:&#x2F;&#x2F;github.com&#x2F;verus-lang&#x2F;verus</a></div><br/></div></div><div id="42925767" class="c"><input type="checkbox" id="c-42925767" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#42928800">prev</a><span>|</span><a href="#42925106">next</a><span>|</span><label class="collapse" for="c-42925767">[-]</label><label class="expand" for="c-42925767">[4 more]</label></div><br/><div class="children"><div class="content">Does Rust have something like a deep-codemodding macro that could be used to un-panic-fy an entire function etc. automatically?<p>Something like: Given a function, rewrite its signature to return a Result if it doesn&#x27;t already, rewrite each non-Resulty return site to a Some(), add a ? to every function call, then recurse into each called function and do the same.</div><br/><div id="42925788" class="c"><input type="checkbox" id="c-42925788" checked=""/><div class="controls bullet"><span class="by">dccsillag</span><span>|</span><a href="#42925767">parent</a><span>|</span><a href="#42925106">next</a><span>|</span><label class="collapse" for="c-42925788">[-]</label><label class="expand" for="c-42925788">[3 more]</label></div><br/><div class="children"><div class="content">It has `catch_unwind` [1], but that still retains the panicking runtime, so not sufficient in the context of the post.<p>[1] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;panic&#x2F;fn.catch_unwind.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;panic&#x2F;fn.catch_unwind.html</a></div><br/><div id="42925957" class="c"><input type="checkbox" id="c-42925957" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#42925767">root</a><span>|</span><a href="#42925788">parent</a><span>|</span><a href="#42925106">next</a><span>|</span><label class="collapse" for="c-42925957">[-]</label><label class="expand" for="c-42925957">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also not guaranteed to catch every panic - sometimes (notably if a destructor panics during unwinding) a panic can turn into a process-abort.</div><br/><div id="42926220" class="c"><input type="checkbox" id="c-42926220" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42925767">root</a><span>|</span><a href="#42925957">parent</a><span>|</span><a href="#42925106">next</a><span>|</span><label class="collapse" for="c-42926220">[-]</label><label class="expand" for="c-42926220">[1 more]</label></div><br/><div class="children"><div class="content">To add to that, Rust code is generally not written to be &#x27;exception-safe&#x27; when panics occur: if a third-party function causes a panic, or if your own code panics from within a callback, then memory may be leaked, and objects in use may end up in an incorrect or unusable state.<p>You really want to avoid sharing mutable objects across a catch_unwind() boundary, and also avoid using it on a regular basis. Aside from memory leaks, panicking runs the thread&#x27;s panic hook, which by default prints a stacktrace. You can override the panic hook to be a no-op, but then you won&#x27;t see anything for actual panics.</div><br/></div></div></div></div></div></div></div></div><div id="42925106" class="c"><input type="checkbox" id="c-42925106" checked=""/><div class="controls bullet"><span class="by">meltyness</span><span>|</span><a href="#42925767">prev</a><span>|</span><a href="#42925442">next</a><span>|</span><label class="collapse" for="c-42925106">[-]</label><label class="expand" for="c-42925106">[1 more]</label></div><br/><div class="children"><div class="content">While not as strict, you can filter lints by their description and apply a policy to your crate
<a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;rust-1.84.0&#x2F;index.html#&#x2F;panic" rel="nofollow">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;rust-1.84.0&#x2F;index.ht...</a></div><br/></div></div><div id="42925442" class="c"><input type="checkbox" id="c-42925442" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42925106">prev</a><span>|</span><a href="#42925385">next</a><span>|</span><label class="collapse" for="c-42925442">[-]</label><label class="expand" for="c-42925442">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  Protocol Buffers<p>Instead of serializing data (to disk, not the network), it would be much faster if Rust allowed us to allocate datastructures directly in an mmapped file, and allowed us to read back the data (basically patching the pointers so they become valid if the base address changed).</div><br/><div id="42926238" class="c"><input type="checkbox" id="c-42926238" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#42925442">parent</a><span>|</span><a href="#42925385">next</a><span>|</span><label class="collapse" for="c-42926238">[-]</label><label class="expand" for="c-42926238">[1 more]</label></div><br/><div class="children"><div class="content">This is basically what Cap&#x27;n Proto does, and it uses offsets instead of pointers so that way the mmapped data can be used as-is.</div><br/></div></div></div></div><div id="42925385" class="c"><input type="checkbox" id="c-42925385" checked=""/><div class="controls bullet"><span class="by">7e</span><span>|</span><a href="#42925442">prev</a><span>|</span><a href="#42925042">next</a><span>|</span><label class="collapse" for="c-42925385">[-]</label><label class="expand" for="c-42925385">[1 more]</label></div><br/><div class="children"><div class="content">It should be possible to write a sanitizer which verifies no panic behavior on a call graph, just as you can to verify no blocking, or no races.</div><br/></div></div><div id="42925042" class="c"><input type="checkbox" id="c-42925042" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42925385">prev</a><span>|</span><a href="#42929666">next</a><span>|</span><label class="collapse" for="c-42925042">[-]</label><label class="expand" for="c-42925042">[10 more]</label></div><br/><div class="children"><div class="content">This seems..absurd for a programming language with goals like Rust. Why isn&#x27;t this a compiler option? Just set -nopanics and the compiler errors and flags anything which is pulling in a panic at the very least?</div><br/><div id="42925146" class="c"><input type="checkbox" id="c-42925146" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42925042">parent</a><span>|</span><a href="#42929587">next</a><span>|</span><label class="collapse" for="c-42925146">[-]</label><label class="expand" for="c-42925146">[1 more]</label></div><br/><div class="children"><div class="content">You can set panic: abort [1] if you don&#x27;t want the unwinding mechanism. You still get a nice error message on panic, which causes the compiler to link in some formatting code from the standard library.  I&#x27;m not sure if you can get rid of that.<p>On the same page are also the options for controlling debug assertions and overflow checks, which would get rid of the &quot;panics in debug, but not release&quot;, if that behavior bugs you<p>1: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;profiles.html#panic" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;profiles.html#pani...</a></div><br/></div></div><div id="42929587" class="c"><input type="checkbox" id="c-42929587" checked=""/><div class="controls bullet"><span class="by">goodpoint</span><span>|</span><a href="#42925042">parent</a><span>|</span><a href="#42925146">prev</a><span>|</span><a href="#42925114">next</a><span>|</span><label class="collapse" for="c-42929587">[-]</label><label class="expand" for="c-42929587">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sad. If anything panics in the stdlib should be opt-in, not opt-out.</div><br/></div></div><div id="42925114" class="c"><input type="checkbox" id="c-42925114" checked=""/><div class="controls bullet"><span class="by">dpc_01234</span><span>|</span><a href="#42925042">parent</a><span>|</span><a href="#42929587">prev</a><span>|</span><a href="#42925189">next</a><span>|</span><label class="collapse" for="c-42925114">[-]</label><label class="expand" for="c-42925114">[5 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-01-unrecoverable-errors-with-panic.html#unrecoverable-errors-with-panic" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-01-unrecoverable-errors-...</a><p>```
[profile.release]
panic = &#x27;abort&#x27;
```</div><br/><div id="42928858" class="c"><input type="checkbox" id="c-42928858" checked=""/><div class="controls bullet"><span class="by">surajrmal</span><span>|</span><a href="#42925042">root</a><span>|</span><a href="#42925114">parent</a><span>|</span><a href="#42925476">next</a><span>|</span><label class="collapse" for="c-42928858">[-]</label><label class="expand" for="c-42928858">[1 more]</label></div><br/><div class="children"><div class="content">After using rust for several years, I&#x27;m shocked this isn&#x27;t the default. Making panics recoverable leads to them being used incorrectly.</div><br/></div></div><div id="42925476" class="c"><input type="checkbox" id="c-42925476" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42925042">root</a><span>|</span><a href="#42925114">parent</a><span>|</span><a href="#42928858">prev</a><span>|</span><a href="#42925189">next</a><span>|</span><label class="collapse" for="c-42925476">[-]</label><label class="expand" for="c-42925476">[3 more]</label></div><br/><div class="children"><div class="content">that just makes the panics unrecoverable. It doesn&#x27;t statically guarantee no panics.</div><br/><div id="42925894" class="c"><input type="checkbox" id="c-42925894" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42925042">root</a><span>|</span><a href="#42925476">parent</a><span>|</span><a href="#42925848">next</a><span>|</span><label class="collapse" for="c-42925894">[-]</label><label class="expand" for="c-42925894">[1 more]</label></div><br/><div class="children"><div class="content">There is no-panic [1] to turn panics in a function into compile errors, or the older no-panics-whatsoever [2] to do the same for the entire binary<p>1: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;no-panic" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;no-panic</a><p>2: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;no-panics-whatsoever" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;no-panics-whatsoever</a></div><br/></div></div><div id="42925848" class="c"><input type="checkbox" id="c-42925848" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42925042">root</a><span>|</span><a href="#42925476">parent</a><span>|</span><a href="#42925894">prev</a><span>|</span><a href="#42925189">next</a><span>|</span><label class="collapse" for="c-42925848">[-]</label><label class="expand" for="c-42925848">[1 more]</label></div><br/><div class="children"><div class="content">It presumably avoids the linked in 300Kb that was supposedly part of the motivation for doing this though?</div><br/></div></div></div></div></div></div><div id="42925189" class="c"><input type="checkbox" id="c-42925189" checked=""/><div class="controls bullet"><span class="by">winstonewert</span><span>|</span><a href="#42925042">parent</a><span>|</span><a href="#42925114">prev</a><span>|</span><a href="#42925066">next</a><span>|</span><label class="collapse" for="c-42925189">[-]</label><label class="expand" for="c-42925189">[1 more]</label></div><br/><div class="children"><div class="content">Well, if they did that, then people could expect&#x2F;demand stability with regard to what scenarios get the checks&#x2F;panics optimized out. This would be a bit of a burden for the Rust maintainers. It would effectively make the optimizer part of the language specification, and that&#x27;s undesireable.</div><br/></div></div><div id="42925066" class="c"><input type="checkbox" id="c-42925066" checked=""/><div class="controls bullet"><span class="by">dccsillag</span><span>|</span><a href="#42925042">parent</a><span>|</span><a href="#42925189">prev</a><span>|</span><a href="#42929666">next</a><span>|</span><label class="collapse" for="c-42925066">[-]</label><label class="expand" for="c-42925066">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;m fairly sure that there is such a flag&#x2F;toplevel attribute... and if there isn&#x27;t, there should be one.<p>It also feels like most of the pains on avoiding panics centers around allocations which, though a bit unfortunate, makes sense; it was an intentional design choice to make allocations panic instead of return Results, because most users of the language would probably crash on allocation fails anyways and it would introduce a lot of clutter. There was some effort some while ago on having better fallible allocations, but I&#x27;m not sure what happened over there.</div><br/></div></div></div></div></div></div></div></div></div></body></html>